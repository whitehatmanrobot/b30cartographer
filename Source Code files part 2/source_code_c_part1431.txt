  
    return NSTATUS_PENDING; 
}

VOID
UL_NATIVE_REQUEST::ResetContext(
    VOID
)
/*++

Routine Description:

    The implementation of UlAtqResetContext which the consumer of W3DT.DLL 
    calls to cleanup the context.  

Arguments:

    None
    
Return Value:

    None

--*/
{
    DereferenceWorkerRequest();
}

VOID
UL_NATIVE_REQUEST::ReferenceWorkerRequest(
    VOID
)
/*++

Routine Description:

    Increment the reference count on the worker request

Arguments:

    None
    
Return Value:

    None

--*/
{
    LONG cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }
}

VOID
UL_NATIVE_REQUEST::DereferenceWorkerRequest(
    BOOL                    fAttemptReset
)
/*++

Routine Description:

    Dereference Request.  This routine will optionally reset the context
    for use for reading the next HTTP request.  Putting the reset code in
    one place (here) handles all the cases where we would want to reset.  
    However, there are a few places where we definitely don't want to reset
    (in the case of error where the context will be going away)

    In either case, if the ref count goes to 0, we can delete the object.

Arguments:

    fAttemptReset - If TRUE, do a reset if ref-count goes to 1. (DEFAULT)
                  - If FALSE, do nothing if ref-count goes to 0.
    
Return Value:

    None

--*/
{
    LONG cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    if ( cRefs == 0 )
    {
        //
        // If 0, we can definitely cleanup, regardless.  This is the error
        // case which is used to cleanup contexts on shutdown (on shutdown,
        // the apppool handle is closed which will error out all pending
        // UlReceiveHttpRequests
        //
        
        delete this;
    }
    else if ( cRefs == 1 && fAttemptReset )
    {
        //
        // Reset the state machine.  Now we can increment our served count
        //
        
        InterlockedIncrement( (PLONG) &sm_cRequestsServed );
       
        //
        // If we have too many outstanding requests, then clean this one up
        // instead of reseting it.
        //
       
        if ( sm_cRequestsPending > sm_cDesiredPendingRequests )
        {
            cRefs = InterlockedDecrement( &_cRefs );
            DBG_ASSERT( cRefs == 0 );
            
            delete this;
        }
        else
        {
            Reset();
        
            //
            // Re-kickoff the state machine
            //
        
            DoWork( 0, 0, NULL );
        }
    }
}

VOID
UL_NATIVE_REQUEST::RemoveFromRequestList(
    VOID
)
/*++

Routine Description:

    Remove this UL_NATIVE_REQUEST from the static list of requests.  Main
    purpose of the list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );
    
    RemoveEntryList( &_ListEntry );
    sm_cRequests--;
    
    LeaveCriticalSection( &sm_csRequestList );
}

VOID
UL_NATIVE_REQUEST::AddToRequestList(
    VOID
)
/*++

Routine Description:

    Add this request to the static list of requests.  The main purpose of the
    list is for debugging.

Arguments:

    None

Return Value:

    None

--*/
{
    EnterCriticalSection( &sm_csRequestList );

    sm_cRequests++;
    InsertTailList( &sm_RequestListHead, &_ListEntry );
    
    LeaveCriticalSection( &sm_csRequestList );
}

HRESULT
UL_NATIVE_REQUEST::SendResponse(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    HTTP_RESPONSE *         pResponse,
    HTTP_CACHE_POLICY *     pCachePolicy,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP response thru UL.  

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    pResponse - Pointer to UL_HTTP_RESPONSE
    pCachePolicy - Cache policy
    pcbSent - Receives number of bytes send
    pULLogData - Logging information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }
    
    Status = HttpSendHttpResponse( g_pwpContext->GetAsyncHandle(),
                                   QueryRequestId(),
                                   dwFlags,
                                   pResponse,
                                   pCachePolicy,
                                   pcbSent,
                                   fAsync ? &(_Overlapped) : NULL ,
                                   pUlLogData );

    //
    // If the response is pending, then we return a successful error code.  
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //
    
    if ( fAsync )
    {
        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }    
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }
    
    return hr;
}

HRESULT
UL_NATIVE_REQUEST::SendEntity(
    BOOL                    fAsync,
    DWORD                   dwFlags,
    DWORD                   cChunks,
    HTTP_DATA_CHUNK *       pChunks,
    DWORD                  *pcbSent,
    HTTP_LOG_FIELDS_DATA   *pUlLogData
)
/*++

Routine Description:

    Send an HTTP entity thru UL.  

Arguments:

    fAsync - TRUE if send is async
    dwFlags - UlSendHttpResponse flags
    cChunks - Number of chunks in response
    pChunks - Pointer to array of UL_DATA_CHUNKs
    pcbSent - Receives number of bytes sent
    pUlLogData - Log information

Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;

    if ( pcbSent == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }
    
    Status = HttpSendEntityBody( g_pwpContext->GetAsyncHandle(),
                                 QueryRequestId(),
                                 dwFlags,
                                 cChunks,
                                 pChunks,
                                 pcbSent,
                                 fAsync ? &(_Overlapped) : NULL,
                                 pUlLogData );

    //
    // If the send is pending, then we return a successful error code.  
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //
    
    if ( fAsync )
    {
        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }    
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }
    
    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveEntity(
    BOOL                fAsync,
    DWORD               dwFlags,
    VOID *              pBuffer,
    DWORD               cbBuffer,
    DWORD *             pBytesReceived
)
/*++

Routine Description:

    Receive HTTP entity thru UL.  

Arguments:

    fAsync - TRUE if receive is async
    dwFlags - UlSendHttpResponse flags
    pBuffer - A buffer to receive the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - Upon return, the number of bytes
                     copied to the buffer
    
Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status = NO_ERROR;
    HRESULT                 hr = NO_ERROR;
    DWORD                   cbSent = 0;
    
    if ( fAsync )
    {
        ReferenceWorkerRequest();
    }
    
    Status = HttpReceiveEntityBody( g_pwpContext->GetAsyncHandle(),
                                    QueryRequestId(),
                                    dwFlags,
                                    pBuffer,
                                    cbBuffer,
                                    pBytesReceived,
                                    fAsync ? &(_Overlapped) : NULL );
    
    //
    // If the receive is pending, then we return a successful error code.  
    // This frees the caller from the ERROR_IO_PENDING checks in common
    // case
    //
    
    if ( fAsync )
    {
        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
        }
    }    
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }
    
    return hr;
}

HRESULT
UL_NATIVE_REQUEST::ReceiveClientCertificate(
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive a client certificate

Arguments:

    fAsync - TRUE if receive should be async
    fDoCertMap - TRUE if we should map client certificate to token
    ppClientCertInfo - Set to point to client cert info on success
    
Return Value:

    HRESULT (if pending, the return is NO_ERROR)

--*/
{
    ULONG                   Status;
    HTTP_REQUEST *          pHttpRequest;
    HRESULT                 hr = NO_ERROR;
    
    if ( ppClientCertInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    *ppClientCertInfo = NULL;

    //
    // If this request is not SSL enabled, then getting the client cert is
    // a no-go
    //
    
    pHttpRequest = QueryHttpRequest();
    DBG_ASSERT( pHttpRequest != NULL );
    
    if ( pHttpRequest->pSslInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    //
    // Do we already have a cert associated with this request?
    //
    
    DBG_ASSERT( pHttpRequest->pSslInfo != NULL );
    
    if ( pHttpRequest->pSslInfo->pClientCertInfo != NULL )
    {
        if ( fAsync )
        {
            //
            // BUGBUG:  Probably should support this case.  And if I do, then 
            //          need to fake a completion!
            //
        
            DBG_ASSERT( FALSE );
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        *ppClientCertInfo = pHttpRequest->pSslInfo->pClientCertInfo;
        
        return NO_ERROR;
    }

    //
    // OK.  We'll have to ask UL to renegotiate.  We must be processing 
    // a request
    //    
    
    DBG_ASSERT( _ExecState == NREQ_STATE_PROCESS );

    if ( !_buffClientCertInfo.Resize( INITIAL_CERT_INFO_SIZE ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Are we cert mapping?
    //
    
    if ( fDoCertMap )
    {
        _dwClientCertFlags = HTTP_RECEIVE_CLIENT_CERT_FLAG_MAP;
    }
    else
    {
        _dwClientCertFlags = 0;
    }

    //
    // If we're doing this async, then manage state such that
    // DoStateClientCert gets the completion
    //
    
    if ( fAsync )
    {
        ReferenceWorkerRequest();
        _ExecState = NREQ_STATE_CLIENT_CERT;
    }
    
    Status = HttpReceiveClientCertificate( g_pwpContext->GetAsyncHandle(),
                                           QueryConnectionId(),
                                           _dwClientCertFlags,
                                           (HTTP_SSL_CLIENT_CERT_INFO*)
                                           _buffClientCertInfo.QueryPtr(),
                                           _buffClientCertInfo.QuerySize(),
                                           NULL,
                                           fAsync ? &_Overlapped : NULL );
    if ( fAsync )
    {
        if ( Status != ERROR_IO_PENDING )
        {
            DereferenceWorkerRequest();
            hr = HRESULT_FROM_WIN32( Status );
            _ExecState = NREQ_STATE_PROCESS;
        }
    }    
    else if ( Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
    }
    
    return hr;
}

//static
HRESULT
UL_NATIVE_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Static initialization of UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_NATIVE_REQUEST );
    
    DBG_ASSERT( sm_pachNativeRequests == NULL );
    
    sm_pachNativeRequests = new ALLOC_CACHE_HANDLER( "UL_NATIVE_REQUEST",
                                                     &acConfig );
    if ( sm_pachNativeRequests == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    InitializeCriticalSectionAndSpinCount( &sm_csRequestList,
                                           UL_NATIVE_REQUEST_CS_SPINS );

    InitializeListHead( &sm_RequestListHead );

    sm_cRequestsServed          = 0;
    sm_cRestart                 = 0;
    sm_RestartMsgSent           = 0;
    sm_cRequestsPending         = 0;
    sm_cDesiredPendingRequests  = DESIRED_PENDING_REQUESTS;
    sm_fAddingRequests          = 0;

    InitializeSListHead(&sm_ReadRequestListHead);
    sm_hReadRequestEvent = CreateEvent(NULL,
                                       FALSE,
                                       FALSE,
                                       NULL);
    if ( sm_hReadRequestEvent == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    sm_hReadRequestThread = CreateThread(NULL,
                                         0,
                                         ReadRequestThread,
                                         NULL,
                                         0,
                                         NULL);
    if ( sm_hReadRequestThread == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
   
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    return NO_ERROR;
}

//static
VOID
UL_NATIVE_REQUEST::Terminate(
    VOID
)
/*++

Routine Description:

    Static termination

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_hReadRequestThread != NULL )
    {
        WaitForSingleObject( sm_hReadRequestThread, INFINITE );
        CloseHandle( sm_hReadRequestThread );
        sm_hReadRequestThread = NULL;
    }

    if ( sm_hReadRequestEvent != NULL )
    {
        CloseHandle( sm_hReadRequestEvent );
        sm_hReadRequestEvent = NULL;
    }

    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    DeleteCriticalSection( &sm_csRequestList );
    
    if ( sm_pachNativeRequests != NULL )
    {
        delete sm_pachNativeRequests;
        sm_pachNativeRequests = NULL;
    }
}

//static
HRESULT
UL_NATIVE_REQUEST::AddPendingRequests(
    DWORD                   cRequests
)
/*++

Routine Description:

    Pools calls to UlReceiveHttpRequest by creating new UL_NATIVE_REQUESTs 
    and kicking off their state machines

Arguments:

    cRequests - Number of requests to read

Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    for ( DWORD i = 0; i < cRequests; i++ )
    {
        pRequest = new UL_NATIVE_REQUEST;
        if ( pRequest == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        
        pRequest->DoWork( 0, 0, NULL );
    }
    
    return NO_ERROR;
}

//static
HRESULT
UL_NATIVE_REQUEST::ReleaseAllWorkerRequests(
    VOID
)
/*++

Routine Description:

    Wait for all outstanding UL_NATIVE_REQUESTs to drain

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Wake up the ReadRequest thread so all the pending HttpReceiveHttpRequest
    // calls are canceled
    //
    SetEvent( sm_hReadRequestEvent );

    while ( sm_cRequests )
    {
        Sleep( 1000 );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "UL_NATIVE_REQUEST::ReleaseAllWorkerRequests waiting for %d requests to drain.\n",
                    sm_cRequests ));                    
    } 
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\ulatq.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module Name :
     ulatq.cxx

   Abstract:
     Exported ULATQ.DLL routines
 
   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3dt";

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();


WP_CONTEXT *            g_pwpContext = NULL;

//
// Completion routines for new requests, io completions, and disconnect
// notifications.  
//
// CODEWORK: Can we get away with these being global
//

PFN_ULATQ_NEW_REQUEST           g_pfnNewRequest = NULL;
PFN_ULATQ_IO_COMPLETION         g_pfnIoCompletion = NULL;
PFN_ULATQ_DISCONNECT            g_pfnDisconnect = NULL;
PFN_ULATQ_ON_SHUTDOWN           g_pfnOnShutdown = NULL;
PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters = NULL;


HRESULT
UlAtqInitialize(
    INT                 argc,
    LPWSTR              argv[],
    ULATQ_CONFIG *      pConfig
)
/*++

Routine Description:

    Initialize ULATQ

Arguments:

    argc - Number of command line parameters to worker process
    argv - Command line parameters
    pConfig - Configuration settings for ULATQ

Return Value:

    HRESULT

--*/
{
    HRESULT             rc = NO_ERROR;
    BOOL                fUlInit = FALSE;
    BOOL                fThreadPoolInit = FALSE;

    CREATE_DEBUG_PRINT_OBJECT("w3dt");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    //
    // Honour ULATQ_CONFIG settings.  Set completion routines
    // Need to set this up before we do any other initialization
    //
    
    g_pfnNewRequest = pConfig->pfnNewRequest;
    g_pfnIoCompletion = pConfig->pfnIoCompletion;
    g_pfnDisconnect = pConfig->pfnDisconnect;
    g_pfnOnShutdown = pConfig->pfnOnShutdown;
    g_pfnCollectCounters = pConfig->pfnCollectCounters;

    //
    // Initialize the thread pool
    //

    rc = ThreadPoolInitialize();
    if ( FAILED( rc ) )
    {
        goto Finished;
    }
    fThreadPoolInit = TRUE;

    //
    // Init UL
    //

    rc = HttpInitialize( 0 );
    if ( rc != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT, "Error (rc=%08x) in UlInitialize. Exiting\n",
                    rc ));
        goto Finished;    
    }
    fUlInit = TRUE;

    //
    // Create global state object
    //

    g_pwpContext = new WP_CONTEXT;
    if ( g_pwpContext == NULL )
    {
        rc = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Do global state initialization
    //

    rc = g_pwpContext->Initialize( argc, argv );
    if ( rc != NO_ERROR )
    {   
        //
        // WP_CONTEXT::Initialize returns a Win32 error code
        //
        
        rc = HRESULT_FROM_WIN32( rc );
        goto Finished;
    }

Finished:
    if ( rc != NO_ERROR )
    {
        if ( g_pwpContext != NULL )
        {
            delete g_pwpContext;
            g_pwpContext = NULL;
        }
        
        if ( fUlInit )
        {
            HttpTerminate();
        }
        
        if ( fThreadPoolInit )
        {
            ThreadPoolTerminate();
        }
    }

    return rc;
}

HRESULT
UlAtqStartListen(
    VOID
)
/*++

Routine Description:

    Begin listening for HTTP requests from UL.  This call must happen only
    after ULATQ has been initialized correctly (for example, completion
    routines should be set). 

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT         rc = NO_ERROR;

    DBG_ASSERT( g_pfnIoCompletion != NULL );
    DBG_ASSERT( g_pfnNewRequest != NULL );

    //
    // Make some UlReceiveHttpRequest calls
    //

    rc = g_pwpContext->Start();
    if ( rc != NO_ERROR )
    {
        return rc;
    }

    //
    // Send message to WAS that our initialization is complete
    //
    g_pwpContext->SendInitCompleteMessage( S_OK );

    //
    // Wait for shutdown because of WAS/request-count-max/etc.
    //

    g_pwpContext->RunMainThreadLoop();

    //
    // Before connection drain, allow the user to execute some code
    //

    if ( g_pfnOnShutdown != NULL )
    {
        g_pfnOnShutdown( g_pwpContext->QueryDoImmediateShutdown() );
    }

    //
    // Before we return, wait for outstanding requests to drain.  This 
    // prevents race before caller's shutdown and new requests coming in
    //
    
    g_pwpContext->CleanupOutstandingRequests();
    
    return rc;
}

VOID
UlAtqTerminate(
    HRESULT hrToSend
)
/*++

Routine Description:

    Terminate ULATQ

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pwpContext != NULL )
    {
        if (FAILED(hrToSend))
        {
            g_pwpContext->SendInitCompleteMessage( hrToSend );
        }

        g_pwpContext->Terminate();
        delete g_pwpContext;
        g_pwpContext = NULL;
    } 
    
    HttpTerminate();

    ThreadPoolTerminate();

    DELETE_DEBUG_PRINT_OBJECT();
}

VOID *
UlAtqGetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId
)
/*++

Routine Description:

    Get the UL_HTTP_REQUEST from the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set
    
Return Value:

    The actual property

--*/
{
    switch (PropertyId)
    {
    case ULATQ_PROPERTY_HTTP_REQUEST:
        UL_NATIVE_REQUEST *         pRequest;
        pRequest = (UL_NATIVE_REQUEST*) pContext;
        DBG_ASSERT( pRequest != NULL );
    
        return pRequest->QueryHttpRequest();

    case ULATQ_PROPERTY_APP_POOL_ID:
        return (VOID *)g_pwpContext->QueryConfig()->QueryAppPoolName();

    default:
        DBG_ASSERT(FALSE);
    }

    return NULL;
}

VOID
UlAtqSetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   PropertyId,
    PVOID                       pvData
)
/*++

Routine Description:

    Set a property of the ULATQ_CONTEXT

Arguments:

    pContext - ULATQ_CONTEXT
    PropertyId - Property Id to set
    pvData - Data specific to the property being set
    
Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );

    switch ( PropertyId )
    {
    case ULATQ_PROPERTY_COMPLETION_CONTEXT:
        pRequest->SetContext( pvData );
        break;
    
    default:
        DBG_ASSERT( FALSE );
    }
}

VOID
UlAtqFreeContext(
    ULATQ_CONTEXT               pContext
)
/*++

Routine Description:

    Frees the ULATQ_CONTEXT so that it can be used to retrieve next request

Arguments:

    pContext - ULATQ_CONTEXT
    
Return Value:

    None

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    
    pRequest->ResetContext();
}

HRESULT
UlAtqSendHttpResponse(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send a response to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pResponse - UL_HTTP_RESPONSE to send
    pCachePolicy - Cache policy
    
Return Value:

    Win32 Error

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
   
    return pRequest->SendResponse( fAsync,
                                   dwFlags,
                                   pResponse,
                                   pCachePolicy,
                                   pcbSent,
                                   pUlLogData ); 
}

HRESULT
UlAtqSendEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    DWORD                       cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
)
/*++

Routine Description:

    Send entity to the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    cChunks - Number of chunks in the response
    pChunks - Points to array of chunks
    
Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    
    return pRequest->SendEntity( fAsync,
                                 dwFlags,
                                 cChunks,
                                 pChunks,
                                 pcbSent,
                                 pUlLogData );
}

HRESULT
UlAtqReceiveEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    VOID *                      pBuffer,
    DWORD                       cbBuffer,
    DWORD *                     pBytesReceived
)
/*++

Routine Description:

    Receive entity from the client

Arguments:

    pContext - ULATQ_CONTEXT
    fAsync - Asynchronous or not?
    dwFlags - Response flags (like killing the connection)
    pBuffer - Buffer to store the data
    cbBuffer - The size of the receive buffer
    pBytesReceived - The number of bytes copied to the buffer upon return
    
Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    
    return pRequest->ReceiveEntity( fAsync,
                                    dwFlags,
                                    pBuffer,
                                    cbBuffer,
                                    pBytesReceived);
}

HRESULT
UlAtqWaitForDisconnect( 
    HTTP_CONNECTION_ID              connectionId,
    BOOL                            fAsync,
    PVOID                           pvContext
)
/*++

Routine Description:

    Used to wait for a connection to close.  

Arguments:

    connectionId - connection in question
    fAsync - should we wait asynchronously?
    pvContext - context to pass back on async disconnect wait
    
Return Value:

    HRESULT

--*/
{
    UL_DISCONNECT_CONTEXT *         pContext;
    ULONG                           Status;
    HRESULT                         hr = NO_ERROR;

    //
    // Allocate an async context which will be freed once the connection
    // has been closed
    //
    
    pContext = new UL_DISCONNECT_CONTEXT( pvContext );
    if ( pContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Do the wait
    //
    
    Status = HttpWaitForDisconnect( g_pwpContext->GetAsyncHandle(),
                                    connectionId,
                                    fAsync ? &(pContext->_Overlapped) : NULL );

    if ( Status != ERROR_IO_PENDING && Status != NO_ERROR )
    {
        hr = HRESULT_FROM_WIN32( Status );
        delete pContext;
    }

    return hr;
}

HRESULT
UlAtqInduceShutdown(
    BOOL fImmediate
)
/*++

Routine Description:

    Induce shutdown (used when IIS+ hosted in inetinfo.exe).  Simulates
    WAS telling us to shutdown

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( g_pwpContext != NULL );

    if ( !g_pwpContext->IndicateShutdown( fImmediate ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

HRESULT
UlAtqReceiveClientCertificate(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
)
/*++

Routine Description:

    Receive client certificate

Arguments:

    pContext - ULATQ context
    fAsync - TRUE if we should do it asynchronously
    fDoCertMap - Map client certificate to token
    ppClientCertInfo - Set to point to client cert on success
    
Return Value:

    HRESULT

--*/
{
    UL_NATIVE_REQUEST *         pRequest;
    
    pRequest = (UL_NATIVE_REQUEST*) pContext;
    DBG_ASSERT( pRequest != NULL );
    DBG_ASSERT( pRequest->CheckSignature() );
    
    return pRequest->ReceiveClientCertificate( fAsync,
                                               fDoCertMap,
                                               ppClientCertInfo );
}

HRESULT
UlAtqFlushUlCache(
    WCHAR *                     pszUrlPrefix
)
/*++

Routine Description:

    Flush the UL cache at the given URL prefix 

Arguments:

    pszUrlPrefix - UL prefix to flush
    
Return Value:

    HRESULT

--*/
{
    if ( pszUrlPrefix == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( g_pwpContext == NULL )
    {
        //
        // Before removing this assert, please think hard (and then
        // think again)
        //
        
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    HttpFlushResponseCache( g_pwpContext->GetAsyncHandle(),
                            pszUrlPrefix,
                            HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE,
                            NULL );

    //
    // Mask the error since we may be flushing URLs which aren't 
    // in the cache (that's OK)
    //

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     WpConfig.cxx

   Abstract:
     Module implementing the Worker Process Configuration Data structure.
     WP_CONFIG object encapsulates configuration supplied from the commandline
     as well as remotely supplied from the admin process.

   Author:

       Murali R. Krishnan    ( MuraliK )     21-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

/*
Usage: \bin\iisrearc\inetsrv\iiswp [options] APN
        APN -- AppPool Name
        -d <URL List> -- Indicates that the process should register the given
                namespace itself. This mode is for running worker process in
                stand alone mode (for debugging)
        -l  -- Log errors that stop the worker process into the eventlog
        -ld -- Disables logging the errors of worker process to eventlog
                (default is not write to eventlog)
        -a  -- Look for web admin service and register with the same
                (default is look for web admin service)
        -ad -- Do not look for web admin service and do registration
        -r <n> -- Restart the worker process after n requests.
        -t <n> -- Shutdown the worker process if idle for n milliseconds.
        <URL List> uses the syntax: {http[s]://IP:port/URL | http[s]://hostname:port/URL }+
                with space as separator
                 eg: -d http://localhost:80/  => listen for all HTTP requests on port 80
                 eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81

 */

const CHAR g_rgchUsage[] =
"Usage: %ws [options] APN\n"
"\tAPN -- AppPool Name\n"
"\t-d <URL List> -- Indicates that the process should register the given \n"
"\t\tnamespace itself. This mode is for running worker process in\n"
"\t\tstand alone mode (for debugging)\n"
"\t-l  -- Log errors that stop the worker process into the eventlog\n"
"\t-ld -- Disables logging the errors of worker process to eventlog\n"
"\t\t(default is not write to eventlog)\n"
"\t-a  -- Look for web admin service and register with the same\n"
"\t\t(default is look for web admin service)\n"
"\t-ad -- Do not look for web admin service and do registration\n"
"\t-r <n> -- Restart the worker process after n requests\n"
"\t-t <n> -- Shutdown the worker process if idle for n milliseconds\n"
"\t-p  -- Tell COR to add IceCAP instrumentation\n"
"\t<URL List> uses the syntax: {http[s]://IP:port/URL | http[s]://hostname:port/URL }+\n"
"\t\twith space as separator\n"
"\t\t eg: -d http://*:80/  => listen for all HTTP requests on port 80\n"
"\t\t eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81\n"
;

/************************************************************
 *     Member functions of WP_CONFIG
 ************************************************************/

WP_CONFIG::WP_CONFIG(void)
    : _pwszAppPoolName     (AP_NAME),
      _fSetupControlChannel(false),
      _fLogErrorsToEventLog(false),
      _fRegisterWithWAS    (true),
      _RestartCount    (0),
      _NamedPipeId     (0),
      _IdleTime        (0)
{
    lstrcpy( _pwszProgram,  L"WP");
}

WP_CONFIG::~WP_CONFIG()
{
    _ulcc.Cleanup();
}


void
WP_CONFIG::PrintUsage() const
{
    DBGPRINTF((DBG_CONTEXT, g_rgchUsage, _pwszProgram));
}

/********************************************************************++

Routine Description:
    Parses the command line to read in all configuration supplied.
    This function updates the state variables inside WP_CONFIG for use
    in starting up the Worker process.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:
    argc - count of arguments supplied
    argv - pointer to strings containing the arguments.

Returns:
    Boolean

--********************************************************************/
BOOL
WP_CONFIG::ParseCommandLine(int argc, PWSTR  argv[])
{
    BOOL    fRet = true;
    int     iArg;

    lstrcpyn( _pwszProgram, argv[0], sizeof _pwszProgram / sizeof _pwszProgram[0]);

    if ( argc < 2)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid number of parameters (%d)\n", argc));
        PrintUsage();
        return (false);
    }

    for( iArg = 1; iArg < argc; iArg++)
    {
        if ( (argv[iArg][0] == L'-') || (argv[iArg][0] == L'/'))
        {
            switch (argv[iArg][1])
            {

            case L'c': case L'C':
                DBGPRINTF((DBG_CONTEXT, "-C: obsolete\n"));
                break;

            case L'd': case L'D':

                _fSetupControlChannel = true;
                iArg++;

                while ( (iArg < argc-1) &&
                        (argv[iArg][0] != L'-') && (argv[iArg][0] != L'/'))
                {
                    if ( !InsertURLIntoList(argv[iArg]) )
                    {
                        DBGPRINTF((DBG_CONTEXT, "Invalid URL: %ws\n", argv[iArg]));
                    }

                    iArg++;
                }

                iArg--;
                break;

            case L'a': case L'A':
                if ( (L'd' == argv[iArg][2]) || (L'D' == argv[iArg][2]))
                {
                    _fRegisterWithWAS = false;
                }
                else
                {
                    // -a NamedPipeId
                    if (L'\0' == argv[iArg][2])
                    {
                        iArg++;
                    }

                    _NamedPipeId = wcstoul(argv[iArg], NULL, 0);
                    DBGPRINTF((DBG_CONTEXT, "NamedPipe Id, %lu\n", _NamedPipeId));

                    if (0 == _NamedPipeId)
                    {
                        DBGPRINTF((DBG_CONTEXT, "Invalid NamedPipe Id, %ws\n",
                            argv[iArg]));
                        fRet = false;
                    }
                }
                break;

            case L'l': case L'L':
                DBGPRINTF((DBG_CONTEXT, "Warning: This option is not supported presently\n"));
                if (L' ' == argv[iArg][0])
                {
                    _fLogErrorsToEventLog = true;
                }
                break;

            case L'r': case L'R':
                _RestartCount = wcstoul(argv[++iArg], NULL, 0);

                if (_RestartCount == 0)
                {
                    DBGPRINTF((DBG_CONTEXT, "Invalid maximum requests %ws\n", argv[iArg]));
                    return false;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Maximum requests is %lu\n", _RestartCount));
                }
                break;

            case L't': case L'T':
                _IdleTime  = wcstoul(argv[++iArg], NULL, 0);

                if (_IdleTime == 0)
                {
                    DBGPRINTF((DBG_CONTEXT, "Invalid idle time %ws\n", argv[iArg]));
                    return false;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "The idle time value is %lu\n", _IdleTime));
                }
                break;

            case L'p': case L'P':
                SetEnvironmentVariable(L"CORDBG_ENABLE", L"0x20");
                SetEnvironmentVariable(L"COR_PROFILER", L"\"ComPlusIcecapProfile.CorIcecapProfiler\"");
                SetEnvironmentVariable(L"PROF_CONFIG", L"/callcap");

                break;

            default:
            case L'?':
                fRet = false;
                break;
            } // switch
        }
        else
        {
            //
            // Take the next item as the NSG name and bail out here
            //
            _pwszAppPoolName = argv[iArg];

            if ( iArg != (argc - 1))
            {
                //
                // this is not the last argument => unwanted parameters exist
                // give warning and ignore
                //
                DBGPRINTF((DBG_CONTEXT, "Warning: Too many arguments supplied\n"));
            }

            break; // get out of here.
        }
    }

    if (!_fRegisterWithWAS)
    {
        _RestartCount  = 0;
        _IdleTime      = 0;
    }

    if (!fRet)
    {
        PrintUsage();
    }

    return ( fRet);

} // WP_CONFIG::ParseCommandLine()


/********************************************************************++

Routine Description:
    Sets up the control channel for processing requests. It uses
    the configuration parameters supplied for initializing the
    UL_CONTROL_CHANNEL.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:

Returns:
    Win32 error

--********************************************************************/

ULONG
WP_CONFIG::SetupControlChannel(void)
{

    //
    // Setup a control channel for our local use now. Used mainly for
    // the purpose of debugging.
    // In general control channel work is done by the AdminProces.
    //

    return _ulcc.Initialize( _mszURLList, _pwszAppPoolName);

} // WP_CONFIG::SetupControlChannel()

/********************************************************************++
--********************************************************************/

WP_CONFIG::InsertURLIntoList( LPCWSTR pwszURL  )
{
    LPCWSTR pwszOriginalURL = pwszURL;

    //
    // Minimum length: 11 (http://*:1/). Begins with http
    //

    if ( ( wcslen(pwszURL) < 11 ) || ( 0 != _wcsnicmp(pwszURL, L"http", 4)) )
    {
        return false;
    }

    pwszURL += 4;

    //
    // https
    //

    if ((L's' == *pwszURL) || (L'S' == *pwszURL))
    {
        pwszURL++;
    }

    //
    // ://
    //

    if ( (L':' != *pwszURL) || (L'/' != *(pwszURL+1)) || (L'/' != *(pwszURL+2)) )
    {
        return false;
    }

    pwszURL += 3;

    //
    // Skip host name or Ip Address
    //

    while ( (0 != *pwszURL) && ( L':' != *pwszURL))
    {
        pwszURL++;
    }

    //
    // Check port # exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // Check port number is numeric
    //

    pwszURL++;

    while ( (0 != *pwszURL) && ( L'/' != *pwszURL) )
    {
        if (( L'0' > *pwszURL) || ( L'9' < *pwszURL))
        {
            return false;
        }

        pwszURL++;
    }

    //
    // Check / after port number exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // URL is good.
    //

    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Inserting URL '%ws' into Config Group List\n",
                    pwszOriginalURL
                    ));
    }
    return ( TRUE == _mszURLList.Append( pwszOriginalURL));

} // WP_CONFIG::InsertURLIntoList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpipm.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wpipm.cxx

Abstract:

    Contains the WPIPM class that handles communication with
    the admin service. WPIPM responds to pings, and tells
    the process when to shut down.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include <precomp.hxx>
#include "ipm.hxx"
#include "wpipm.hxx"
#include "ipm_io_c.hxx"

extern PFN_ULATQ_COLLECT_PERF_COUNTERS g_pfnCollectCounters;

/**
 *
 *   Routine Description:
 *
 *   Initializes WPIPM.
 *   
 *   Arguments:
 *
 *   pWpContext - pointer to the wp context (so we can tell it to shutdown)
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Initialize(
    WP_CONTEXT * pWpContext
    )
{

    HRESULT        hr           = S_OK;
    IO_FACTORY_C * pFactory;
    STRU           strPipeName;
    MESSAGE_PIPE * pPipe        = NULL;

    m_pWpContext      = pWpContext;
    m_pMessageGlobal  = NULL;
    m_pPipe           = NULL;
    m_hTerminateEvent = NULL;

    //
    // create MESSAGE_GLOBAL
    //
    pFactory = new IO_FACTORY_C();
    if (pFactory) {
        m_pMessageGlobal = new MESSAGE_GLOBAL(pFactory);

        if (m_pMessageGlobal) {
            hr = m_pMessageGlobal->InitializeMessageGlobal();
        } else {
            delete pFactory;
            pFactory = NULL;
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // create connect event
    //
    if (SUCCEEDED(hr)) {
        m_hConnectEvent = CreateEvent(
                                NULL,   // default security
                                TRUE,   // manual reset
                                FALSE,  // initial state
                                NULL    // unnamed event
                                );

        if (m_hConnectEvent) {
            hr = m_pMessageGlobal->CreateMessagePipe(
                        this,
                        &pPipe
                        );
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
                                

    //
    // create the MESSAGE_PIPE and termination event
    //
    if (SUCCEEDED(hr)) {
        m_hTerminateEvent = CreateEvent(
                                NULL,  // default security
                                TRUE,  // manual reset
                                FALSE, // initial state
                                NULL   // unnamed
                                );

        if (m_hTerminateEvent) {
            hr = m_pMessageGlobal->CreateMessagePipe(
                        this,
                        &pPipe
                        );
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // connect the MESSAGE_PIPE
    //
    if (SUCCEEDED(hr)) {
        hr = strPipeName.Copy(IPM_NAMED_PIPE_NAME);

        if (SUCCEEDED(hr)) {
            hr = m_pMessageGlobal->ConnectMessagePipe(
                        strPipeName,
                        pWpContext->_pConfigInfo->QueryNamedPipeId(),
                        pPipe
                        );
        }
    }

    if (SUCCEEDED(hr)) {

        m_pPipe = pPipe;

        //
        // wait for connect
        //
        WaitForSingleObject(m_hConnectEvent, INFINITE);    

    } else {
        // pipe takes care of itself
        
        Terminate();
    }

    return hr;
}


/**
 *
 * Routine Description:
 *
 *   Terminates WPIPM.
 *
 *   If the message pipe is open this function will disconnect it
 *   and wait for the pipe's disconnection callback.
 *   
 *  Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Terminate(
    VOID
    )
{
    HRESULT hr = S_OK;
    HRESULT hrGlobalTerminate;
    DWORD   dwWaitResult;

    if (m_pMessageGlobal) {
        if (m_pPipe) {
            hr = m_pMessageGlobal->DisconnectMessagePipe(m_pPipe);
            m_pPipe = NULL;
            // pipe deletes itself

            if (SUCCEEDED(hr)) {
                dwWaitResult = WaitForSingleObject(
                                    m_hTerminateEvent,
                                    INFINITE
                                    );

            }
        }

        hrGlobalTerminate = m_pMessageGlobal->TerminateMessageGlobal();

        if (SUCCEEDED(hr)) {
            hr = hrGlobalTerminate;
        }

        m_pMessageGlobal = NULL;
    }

    m_pWpContext = NULL;

    if (m_hTerminateEvent) {
        CloseHandle(m_hTerminateEvent);
        m_hTerminateEvent = NULL;
    }

    if (m_hConnectEvent) {
        CloseHandle(m_hConnectEvent);
        m_hConnectEvent = NULL;
    }

    return hr;
}


/**
 *
 *
 *  Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has received a message.
 *   
 *   We decode the message and respond appropriately.
 *   
 *   Arguments:
 *
 *   pPipeMessage - the message that we received
 *   
 *   Return Value:
 *
 *   HRESULT
 *
 */
HRESULT
WP_IPM::AcceptMessage(
    IN const MESSAGE * pPipeMessage
    )
{
    HRESULT hr;

    switch (pPipeMessage->GetOpcode()) {
    case IPM_OP_PING:
        hr = HandlePing();
        break;

    case IPM_OP_SHUTDOWN:
        hr = HandleShutdown(
                *( reinterpret_cast<const BOOL *>( pPipeMessage->GetData() ) )
                );
        break;

    case IPM_OP_REQUEST_COUNTERS:
        hr = HandleCounterRequest();
        break;

    case IPM_OP_PERIODIC_PROCESS_RESTART_PERIOD_IN_MINUTES:
        // Issue 01/21/01: Jaroslad - Enable or remove for Beta3
        hr = NO_ERROR;
        break;
        
    case IPM_OP_PERIODIC_PROCESS_RESTART_REQUEST_COUNT:
        // Issue 01/21/01: Jaroslad - Enable or remove for Beta3
        hr = NO_ERROR;
        break;
        
    case IPM_OP_PERIODIC_PROCESS_RESTART_MEMORY_USAGE_IN_KB:

        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartMemoryBased(
                *( reinterpret_cast<const DWORD *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;
 
    case IPM_OP_PERIODIC_PROCESS_RESTART_SCHEDULE:
      
        DBG_ASSERT( pPipeMessage->GetData() != NULL );
        hr = WP_RECYCLER::StartScheduleBased(
                ( reinterpret_cast<const WCHAR *>( pPipeMessage->GetData() ) )
                );
        hr = NO_ERROR;
        break;

    default:
        DBG_ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }

    return hr;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been connected and is ready for use.
 *   
 * Arguments:
 *
 *   None.
 *   
 * Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::PipeConnected(
    VOID
    )
{
    DBG_ASSERT(m_hConnectEvent);

    DBG_REQUIRE( SetEvent(m_hConnectEvent) );

    return S_OK;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been disconnected and you won't be receiving
 *   any more messages.
 *   
 *   Tells WPIPM::Terminate that it's ok to exit now.
 *   
 * Arguments:
 *
 *   hr - the error code associated with the pipe disconnection
 *   
 * Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::PipeDisconnected(
    IN HRESULT hr
    )
{
    //
    // CODEWORK: should we do something with the parameter?
    //
    if (FAILED(hr))
    {
        WpTrace(WPIPM, (DBG_CONTEXT, "PipeDisconnected with hr ( %d).\n", hr));
    }
    //
    // If the pipe disappears out from under us, assume the WAS has
    // gone bad, and initiate fast shutdown of this worker process.
    //

    m_pWpContext->IndicateShutdown( TRUE );


    if (SetEvent(m_hTerminateEvent)) {
        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}

/**
 *
 *  Routine Description:
 *
 *   Handles the ping message. Sends the ping response message.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandlePing(
    VOID
    )
{
    HRESULT hr;

    WpTrace(WPIPM, (DBG_CONTEXT, "Handle Ping\n\n"));
    hr = m_pPipe->WriteMessage(
                IPM_OP_PING_REPLY,  // ping reply opcode
                0,                  // no data to send
                NULL                // pointer to no data
                );

    return hr;
}

/**
 *
 *  Routine Description:
 *
 *   Handles the counter request message. 
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleCounterRequest(
    VOID
    )
{
    WpTrace(WPIPM, (DBG_CONTEXT, "Handle Counter Request\n\n"));

    HRESULT hr;
    PBYTE pCounterData;
    DWORD dwCounterData;
    if (FAILED(hr = g_pfnCollectCounters(&pCounterData, &dwCounterData)))
    {
        return hr;
    }

    return m_pPipe->WriteMessage(IPM_OP_SEND_COUNTERS,  // ping reply opcode
                                 dwCounterData,         // no data to send
                                 pCounterData);         // pointer to no data
}

/**
 *
 * Routine Description: 
 *
 *
 *   Handles the shutdown message. Shuts down the process
 *   
 *  Arguments:
 *
 *   None.
 *  
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleShutdown(
    BOOL fDoImmediate
    )
{
    HRESULT hr = S_OK;

    WpTrace(WPIPM, (DBG_CONTEXT, "Handle ******************** Shutdown\n\n"));
    m_pWpContext->IndicateShutdown( fDoImmediate );

    return hr;
}



/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has either finished
 *   initializing or has failed to initialize.
 *   
 *  Arguments:
 *
 *   HRESULT indicating success/failure of initialization
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendInitCompleteMessage(
    HRESULT hrToSend
    )
{
    return m_pPipe->WriteMessage(
               IPM_OP_HRESULT,                      // opcode
               sizeof( hrToSend ),                  // data length
               reinterpret_cast<BYTE*>( &hrToSend ) // pointer to data
               );
}


/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has reach certain state.
 *   Main use is in shutdown.  See IPM_WP_SHUTDOWN_MSG for reasons.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendMsgToAdminProcess(
    IPM_WP_SHUTDOWN_MSG reason
    )
{
    return m_pPipe->WriteMessage(
               IPM_OP_WORKER_REQUESTS_SHUTDOWN,  // sends message indicate shutdown
               sizeof(reason),                   // no data to send
               (BYTE *)&reason                   // pointer to no data
               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wpcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     wpcontext.cxx

   Abstract:
     This module defines the member functions of the WP_CONTEXT.
     The WP_CONTEXT object embodies an instance of the Worker process
     object. It contains a completion port, pool of worker threads,
     pool of worker requests, a data channel for the worker process, etc.
     It is responsible for setting up the context for processing requests
     and handles delegating the processing of requests.

     NYI: In the future we should be able to run WP_CONTEXT object as
     a COM+ object and be run standalone using a hosting exe.

   Author:

       Murali R. Krishnan    ( MuraliK )     17-Nov-1998

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"

VOID
WINAPI
IdleTimeCheckCallback(
    VOID *              pvContext,
    BOOLEAN             fUnused
)
/*++

Routine Description:
    
    Callback function provided for TimerQueue.  Called every minute

Arguments:

    pvContext - Context
    
Return Value:

    None

--*/
{
    WP_IDLE_TIMER * pTimer = (WP_IDLE_TIMER *)pvContext;

    DBGPRINTF(( DBG_CONTEXT, 
                "Check Idle Time Callback.\n" ));

    DBG_ASSERT( pTimer );

    pTimer->IncrementTick();
}

WP_IDLE_TIMER::WP_IDLE_TIMER(
    ULONG               IdleTime
)
:   _BusySignal(0),
    _CurrentIdleTick(0),
    _IdleTime(IdleTime),
    _hIdleTimeExpiredTimer((HANDLE)NULL)
{
}

WP_IDLE_TIMER::~WP_IDLE_TIMER(
    VOID
)
{
    //
    // Cancel IdleTimeExpiredTimer
    //
    
    if (_hIdleTimeExpiredTimer)
    {
        StopTimer();
    }
}

HRESULT
WP_IDLE_TIMER::Initialize(
    VOID
)
/*++

Routine Description:
    
    Initialize the idle timer.  Setup NT thread pool to callback every minute

Arguments:

    None
    
Return Value:

    HRESULT    

--*/
{
    BOOL                fRet;
    HRESULT             hr = NO_ERROR;

    //
    // IdleTime is stored as in minutes, 1 min = 60*1000 milliseconds.
    //
    
    fRet = CreateTimerQueueTimer(
            &_hIdleTimeExpiredTimer,                // handle to the Timer
            NULL,                                   // Default Timer Queue
            IdleTimeCheckCallback,                  // Callback function
            this,                                   // Context.
            60000,                                  // Due Time
            60000,                                  // Signal every minute
            WT_EXECUTEINIOTHREAD
            );

    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create idle timer.  hr = %x\n",
                    hr ));
    }
    
    return hr;
}

VOID
WP_IDLE_TIMER::IncrementTick(
    VOID
)
/*++

Routine Description:
    
    Check every minute whether we've been idle long enough.  If so, 
    tell WAS

Arguments:

    None
    
Return Value:

    None

--*/
{
    ULONG           BusySignal = _BusySignal;
    
    InterlockedIncrement( (PLONG)&_CurrentIdleTick );
    
    _BusySignal = 0;

    if ( !BusySignal && _CurrentIdleTick >= _IdleTime ) 
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Idle time reached.  Send shutdown message to WAS.\n" ));

        g_pwpContext->SendMsgToAdminProcess( IPM_WP_IDLE_TIME_REACHED );
    }
}

VOID
WP_IDLE_TIMER::StopTimer(
    VOID
)
/*++

Routine Description:
    
    Remove timer

Arguments:

    None
    
Return Value:

    None

--*/
{
    BOOL fRet;

    DBG_ASSERT( _hIdleTimeExpiredTimer );

    fRet = DeleteTimerQueueTimer( NULL,
                                  _hIdleTimeExpiredTimer,
                                  (HANDLE)-1 );

    if ( !fRet )
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Failed to delete Timer queue.  Win32 = %ld\n",
                    GetLastError() ));
    }
    
    _hIdleTimeExpiredTimer = NULL;
}


VOID
OverlappedCompletionRoutine(
    DWORD               dwErrorCode,
    DWORD               dwNumberOfBytesTransfered,
    LPOVERLAPPED        lpOverlapped
)
/*++

Routine Description:
    
    Main completion routine called on completions for UL app pool handle.

Arguments:

    dwErrorCode - Win32 Error code of completion
    dwNumberOfBytesTransfered - Bytes completed
    lpOverlapped - Overlapped structure passed on async operation
    
Return Value:

    None

--*/
{
    ASYNC_CONTEXT *         pContext = NULL;

    //
    // Use the overlapped to get at the async context
    //

    if (lpOverlapped != NULL)
    {
        pContext = CONTAINING_RECORD( lpOverlapped,
                                      ASYNC_CONTEXT,
                                      _Overlapped );
    }
    
    DBG_ASSERT( pContext != NULL );
    
    //
    // Call virtual DoWork() to actually handle the completion
    // (context can represent a UL_NATIVE_REQUEST or a UL_DISCONNECT)
    //
    
    pContext->DoWork( dwNumberOfBytesTransfered,
                      dwErrorCode,
                      lpOverlapped );
}

WP_CONTEXT::WP_CONTEXT(
    VOID
) : _hDoneEvent( NULL ),
    _pConfigInfo( NULL ),
    _fShutdown( FALSE ),
    _pIdleTimer( NULL )
{
}

WP_CONTEXT::~WP_CONTEXT(
    VOID
)
{
}

HRESULT
WP_CONTEXT::Initialize(
    INT             argc,
    LPWSTR *        argv 
)
/*++

Routine Description:
    
    Initialize global context

Arguments:

    argc - Command argument count
    argv - Command arguments

Return Value:

    HRESULT

--*/
{
    LPCWSTR     pwszAppPoolName;
    HRESULT     hr = NO_ERROR;
    BOOL        fAppPoolInit = FALSE;
    BOOL        fNativeRequestInit = FALSE;
    BOOL        fDisconnectInit = FALSE;
    BOOL        fIpmInit = FALSE;
    BOOL        fWpRecyclerInit = FALSE;

    _pConfigInfo = new WP_CONFIG();
    if ( _pConfigInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }

    //
    // Validate the parameters passed into executable
    //
    
    if ( !_pConfigInfo->ParseCommandLine( argc, argv ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid command line arguments.\n" ));
                    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    
    pwszAppPoolName = _pConfigInfo->QueryAppPoolName();

    //
    // Initialize UL AppPool
    //

    hr = _ulAppPool.Initialize( pwszAppPoolName );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize AppPool.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fAppPoolInit = TRUE;
    
    //
    // Initialize UL_NATIVE_REQUEST globals
    //
    
    hr = UL_NATIVE_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_NATIVE_REQUEST globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fNativeRequestInit = TRUE;
   
    //
    // Initialize UL_DISCONNECTs
    //
    
    hr = UL_DISCONNECT_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize UL_DISCONNECT_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fDisconnectInit = TRUE;
    
    DBGPRINTF(( DBG_CONTEXT,
                "AppPool '%ws' initialized\n",
                pwszAppPoolName ));

    //
    // Initialize of the shutdown event
    //

    _hDoneEvent = IIS_CREATE_EVENT( "WP_CONTEXT::_hDoneEvent", 
                                    &_hDoneEvent,           
                                    TRUE,                 
                                    FALSE );

    if ( _hDoneEvent == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create shutdown event.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    
    //
    // If an idle time is set, then set idle timer
    //
    
    if ( _pConfigInfo->QueryIdleTime() != 0 )
    {
        _pIdleTimer = new WP_IDLE_TIMER( _pConfigInfo->QueryIdleTime() );
        if ( _pIdleTimer )
        {
            hr = _pIdleTimer->Initialize();
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // Setup all async completions on data channel handle to go thru W3TP
    //

    if (!ThreadPoolBindIoCompletionCallback( _ulAppPool.QueryHandle(), 
                                             OverlappedCompletionRoutine,
                                             0 ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to associate handle with thread pool.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    
    //
    // Need to init this first as we may start getting callbacks as soon
    // as we init IPM
    //
    hr = WP_RECYCLER::Initialize();
    
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize WP_RECYCLER.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    fWpRecyclerInit = TRUE;

    //
    // Register with WAS
    //
    
    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Initialize( this );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to initialize IPM.  hr = %x\n",
                        hr ));
            goto Finished;
        }
        fIpmInit = TRUE;
    }

    //
    // Set the window title to something nice when we're running
    // under the debugger.
    //

    if ( IsDebuggerPresent() )
    {
        STRU strTitle;
        WCHAR buffer[sizeof("w3wp[1234567890] - ")];
        WCHAR buffer2[sizeof(" - wp1234567890 - mm/dd hh:mm:ss")];

        wsprintf( buffer, L"w3wp[%lu] - ", GetCurrentProcessId() );
        hr = strTitle.Append( buffer );

        if (SUCCEEDED(hr))
        {
            hr = strTitle.Append( _pConfigInfo->QueryAppPoolName() );
        }

        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER sysTime;
            LARGE_INTEGER localTime;
            TIME_FIELDS fields;

            NtQuerySystemTime( &sysTime );
            RtlSystemTimeToLocalTime( &sysTime, &localTime );
            RtlTimeToTimeFields( &localTime, &fields );

            wsprintf(
                buffer2,
                L" - wp%lu  - %02u/%02u %02u:%02u:%02u",
                _pConfigInfo->QueryNamedPipeId(),
                fields.Month,
                fields.Day,
                fields.Hour,
                fields.Minute,
                fields.Second
                );

            hr = strTitle.Append( buffer2 );
        }

        if (SUCCEEDED(hr))
        {
            SetConsoleTitleW( strTitle.QueryStr() );
        }
    }
    
    return NO_ERROR;
    
Finished:

    //
    // Terminate recycler object
    // Dependency warning: _WpIpm must still be valid
    //
    if ( fWpRecyclerInit )
    {
        WP_RECYCLER::Terminate();
    }    

    if ( fIpmInit )
    {
        _WpIpm.Terminate();
    }
    
    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL; 
    }    
    
    if ( _hDoneEvent != NULL )
    {
        CloseHandle( _hDoneEvent );
        _hDoneEvent = NULL;
    }
    
    if ( fDisconnectInit )
    {
        UL_DISCONNECT_CONTEXT::Terminate();
    }
    
    if ( fNativeRequestInit )
    {
        UL_NATIVE_REQUEST::Terminate();
    }
    
    if ( fAppPoolInit )
    {
        _ulAppPool.Cleanup();
    }

    if ( _pConfigInfo != NULL )
    {
        delete _pConfigInfo;
        _pConfigInfo = NULL;
    }
    
    return hr;
}

HRESULT
WP_CONTEXT::Start(
    VOID
)
/*++

Routine Description:
    
    Start listening for requests by creating UL_NATIVE_REQUESTs

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    
    //
    // Create a pool of worker requests
    // NYI: Allow the worker requests limit to be configurable.
    //

    UL_NATIVE_REQUEST::SetRestartCount( _pConfigInfo->QueryRestartCount() );

    hr = UL_NATIVE_REQUEST::AddPendingRequests( 
                                  (_pConfigInfo->QueryRestartCount() == 0 ||
                                   (_pConfigInfo->QueryRestartCount() >=
                                    NUM_INITIAL_REQUEST_POOL_ITEMS)) ?
                                    NUM_INITIAL_REQUEST_POOL_ITEMS :
                                    _pConfigInfo->QueryRestartCount()
                                  );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to add pending UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));
    }
    
    return hr;
}

BOOL
WP_CONTEXT::IndicateShutdown(
    BOOL fImmediate
)
/*++

Routine Description:
    
    Set shutdown event which allows StartListen to wake up and 
    begin cleanup

Arguments:

    reason - Reason for shutdown

Return Value:

    BOOL

--*/
{
    _fImmediateShutdown = fImmediate;

    if ( !InterlockedCompareExchange((LONG *)&_fShutdown, TRUE, FALSE ) )
    {
        return SetEvent( _hDoneEvent );
    }
    else
    {
        return TRUE;
    }
}

VOID
WP_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:
    
    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // Cleanup async contexts
    //

    UL_DISCONNECT_CONTEXT::Terminate();
    
    UL_NATIVE_REQUEST::Terminate();
    
    if ( _pIdleTimer != NULL )
    {
        delete _pIdleTimer;
        _pIdleTimer = NULL;
    }

    //
    // Cleanup the Shutdown Event.
    //
    
    DBG_ASSERT( _hDoneEvent != NULL );
    
    CloseHandle( _hDoneEvent );
    _hDoneEvent = NULL;


    //
    // Terminate procerr recycler.
    // Dependency warning: _WpIpm must still be valid
    //
    
    WP_RECYCLER::Terminate();

    //
    // Stop IPM
    //
    
    if ( _pConfigInfo->QueryRegisterWithWAS() )
    {
        hr = _WpIpm.Terminate();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to shutdown IPM.  hr = %x\n",
                        hr ));
        }
    }

    //
    // Cleanup config object
    //

    delete _pConfigInfo;
    _pConfigInfo = NULL;
}

HRESULT
WP_CONTEXT::CleanupOutstandingRequests(
    VOID
)
/*++

Routine Description:
    
    Cleanup WP_CONTEXT data structures

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    //
    // If we want to shut-down immediately, then close the AppPool handle now
    //
    if (_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for requests to drain away.  If they were pending 
    // UlReceiveHttpRequest, they will complete with error.  If they were 
    // already processing, then we wait for them to finish
    //

    hr = UL_NATIVE_REQUEST::ReleaseAllWorkerRequests();
    if ( FAILED( hr ) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error draining UL_NATIVE_REQUESTs.  hr = %x\n",
                    hr ));
        
        return hr;
    }

    //
    // If we want to shut-down gracefully, then close the AppPool handle now
    //
    if (!_fImmediateShutdown)
    {
        _ulAppPool.Cleanup();
    }

    //
    // Wait for outstanding disconnect requests (i.e. UlWaitForDisconnect)
    // to drain
    //
    
    UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects();

    //
    // Send WAS final counter data before shutting down
    //

    hr = _WpIpm.HandleCounterRequest();

    return hr;
}

VOID
WP_CONTEXT::RunMainThreadLoop(
    VOID
)
/*++

Routine Description:
    
    Wait for the shutdown event

Arguments:

    None

Return Value:

    None

--*/
{
    do
    {
        DWORD result;

        result = WaitForSingleObject( _hDoneEvent, INFINITE );
        
        DBG_ASSERT( result == WAIT_OBJECT_0 );

    } while ( !_fShutdown );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\wprecycler.cxx ===
/*++

   Copyright    (c)    1998   Microsoft Corporation

   Module  Name :
     wprecycler.cxx

   Abstract:
     Implementation of WP_RECYCLER.  Object handles worker process recycling
         - Memory based recycling
         - Schedule based recycling
         - Elapsed Time based recycling
         - Processed Request Count based recycling

   Dependencies:
         g_pwpContext is used by WP_RECYCLER to be able to send messages
    
 
   Author:
     Jaroslav Dunajsky         (JaroslaD)         07-Dec-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"
#include "wprecycler.hxx"

#define ONE_DAY_IN_MILLISECONDS (1000 * 60 * 60 * 24)

//
// Static variables
//

CRITICAL_SECTION  WP_RECYCLER::sm_CritSec;

//
// Static variables for Memory based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedMemoryBased = FALSE;
SIZE_T WP_RECYCLER::sm_MaxValueForMemoryBased = 0;
HANDLE WP_RECYCLER::sm_hCurrentProcess = NULL;

//
// Static variables for Time based recycling
//

HANDLE WP_RECYCLER::sm_hTimerForTimeBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

//
// Static variables for Schedule based recycling
//

HANDLE WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
BOOL   WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;

//
// Static variables for Request based recycling
//

BOOL   WP_RECYCLER::sm_fIsStartedRequestBased = FALSE;
DWORD  WP_RECYCLER::sm_dwMaxValueForRequestBased = 0;
LONG   WP_RECYCLER::sm_RecyclingMsgSent = 0;

BOOL   WP_RECYCLER::sm_fCritSecInit = FALSE;


//
// Static methods for Schedule based recycling
//


//static
HRESULT
WP_RECYCLER::StartScheduleBased(
    IN  const WCHAR * pwszScheduleTimes
)

/*++

Routine Description:

    Start schedule based recycling
    
    
Arguments:

    pwszScheduleTimes - MULTISZ array of time information
                        <time>\0<time>\0\0
                        time is of military format hh:mm 
                        (hh>=0 && hh<=23)
                        (mm>=0 && hh<=59)
    
Return Value:

    HRESULT

--*/

{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;
    const WCHAR *     pwszCurrentChar = pwszScheduleTimes;

    HANDLE      hTimer;

    WORD        wHours = 0;
    WORD        wMinutes = 0;
    WORD        wDigitCount = 0;

    SYSTEMTIME      SystemTime;
    FILETIME        FileTime; 
    FILETIME        CurrentFileTime; 
    ULARGE_INTEGER  largeintCurrentTime;
    ULARGE_INTEGER  largeintTime;
    DWORD           dwDueTime = 0;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased()\n"));
    }
    
    DBG_ASSERT( pwszScheduleTimes != NULL );

    //
    // If scheduler based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedScheduleBased )
    {
        WP_RECYCLER::TerminateScheduleBased();
    }


    WP_RECYCLER::sm_hTimerQueueForScheduleBased = CreateTimerQueue();

    if ( WP_RECYCLER::sm_hTimerQueueForScheduleBased == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    //
    // Gets current time
    //
    
    GetLocalTime( &SystemTime );
    SystemTimeToFileTime(   &SystemTime, 
                            &CurrentFileTime );
    memcpy( &largeintCurrentTime, 
            &CurrentFileTime, 
            sizeof( ULARGE_INTEGER ) );
    

    //
    // empty string in MULTISZ indicates the end of MULTISZ
    //

    while ( *pwszCurrentChar != '\0' )
    {


        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t) *pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Start of the time info
        // Expect military format hh:mm
        //

        //
        // Process hours (up to 2 digits is valid)
        //
        
        wHours = 0;
        wDigitCount = 0;
        while ( iswdigit( *pwszCurrentChar ) )
        {
            wDigitCount++;
            wHours = 10 * wHours + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( wDigitCount > 2  ||
             ( wHours > 23 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        //
        // Hours - minutes separator
        // Be liberal - any character that is not a digit or '\0' is OK
        // 

        if ( *pwszCurrentChar == '\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;
        
        //
        // Process minutes (must be exactly 2 digits)
        //

        wMinutes = 0;
        wDigitCount = 0;
        while ( iswdigit( (wint_t) *pwszCurrentChar ) )
        {
            wDigitCount++;
            wMinutes = 10 * wMinutes + (*pwszCurrentChar - '0');
            pwszCurrentChar++;
        }

        if ( ( wDigitCount != 2 ) ||
             ( wMinutes > 59 ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
        
        //
        // Skip white spaces
        //
        
        while ( iswspace( (wint_t)*pwszCurrentChar ) )
        {
            pwszCurrentChar++;
        }

        //
        // Check for terminating zero
        //

        if ( *pwszCurrentChar != '\0' )
        {
            //
            // Extra characters in the time string
            //

            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }

        pwszCurrentChar++;

        // 
        // Convert Hours and Minutes info
        //

        SystemTime.wHour = wHours;
        SystemTime.wMinute = wMinutes;
        SystemTime.wSecond = 0;
        SystemTime.wMilliseconds = 0;

        SystemTimeToFileTime(   &SystemTime, 
                                &FileTime );
        memcpy( &largeintTime, 
                &FileTime, 
                sizeof(ULARGE_INTEGER) );

        //
        // Issue 12/21/2000 jaroslad: 
        // This method of setting absolute time with CreateTimerQueueTimer
        // is bad since instead of setting absolute time the relative time is 
        // calculated and used for timer. 
        // This approach fails badly if someone changes machine
        // time. Other Api that enables setting abolute time must be used for proper 
        // implementation

        // 
        // Get Due Time in milliseconds
        //
        
        dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);

        if ( largeintTime.QuadPart < largeintCurrentTime.QuadPart)
        {
            dwDueTime = ONE_DAY_IN_MILLISECONDS - static_cast<DWORD>(
                     ( largeintCurrentTime.QuadPart - largeintTime.QuadPart )/ 10000);
        }
        else
        {
            dwDueTime = static_cast<DWORD>(
                     ( largeintTime.QuadPart - largeintCurrentTime.QuadPart )/ 10000);
        }
        
        if ( dwDueTime == 0 )
        {
            //
            // this event is to be scheduled for the next day
            // one day has 1000 * 60 * 60 * 24 of (100-nanosecond intervals)
            //
            dwDueTime += ONE_DAY_IN_MILLISECONDS;
        }

        //
        // Schedule event for specified time, repeating once a day
        //
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Schedule recycling for %d:%d (in %d milliseconds)\n", 
                        (int) wHours,
                        (int) wMinutes,
                        dwDueTime));
        }

        
        fRet = CreateTimerQueueTimer( 
                    &hTimer,
                    WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                    WP_RECYCLER::TimerCallbackForScheduleBased,
                    NULL,
                    dwDueTime,
                    // repeat daily (interval in milliseconds)
                    ONE_DAY_IN_MILLISECONDS,
                    WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failed;
        }

        //
        // hTimer will not be stored
        // sm_hTimerQueueForScheduleBased is going to be used for cleanup 
        // DeleteTimerQueueEx() should be able to correctly delete all timers 
        // in the queue
        //
        
    }
    WP_RECYCLER::sm_fIsStartedScheduleBased = TRUE;
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
Failed:
    WP_RECYCLER::TerminateScheduleBased();
    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartScheduleBased() failed with error hr=0x%x\n",
                    hr ));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    return hr;
}

//static
VOID
WP_RECYCLER::TerminateScheduleBased(
    VOID
)
/*++

Routine Description:

    Stops schedule based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID

--*/

{

    HRESULT hr = E_FAIL;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    if( WP_RECYCLER::sm_hTimerQueueForScheduleBased != NULL )
    {
        if ( !DeleteTimerQueueEx( 
                            WP_RECYCLER::sm_hTimerQueueForScheduleBased,
                            INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                            ) ) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueEx(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                    
        WP_RECYCLER::sm_hTimerQueueForScheduleBased = NULL;
    }

    WP_RECYCLER::sm_fIsStartedScheduleBased = FALSE;
   
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForScheduleBased(
     PVOID                   pParam,
     BOOLEAN                 TimerOrWaitFired
)

/*++

Routine Description:

    Timer callback for Schedule based recycling   
    It is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because scheduled time has been reached
    
Arguments:

    see the description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedScheduleBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForScheduleBased()"
                    " - tell WAS to recycle\n" ));
    }
    //
    // Indicate to WAS that we are ready for recycling
    //

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_SCHEDULED_TIME_REACHED );
}


//
// Static methods for Memory based recycling
//


//static
HRESULT
WP_RECYCLER::StartMemoryBased(
    IN  DWORD dwMaxVirtualMemoryUsageInKB
)
/*++

Routine Description:

    Start virtual memory usage based recycling. 
    
    
Arguments:

    dwMaxVirtualMemoryUsageInKB - If usage of virtual memory reaches this value 
                                  worker process is ready for recycling

Note:

    VM usage will be checked periodically. See the value of internal constant 
    CHECK_MEMORY_TIME_PERIOD
                                  
    
Return Value:

    HRESULT

--*/


{
    HRESULT     hr   = E_FAIL;
    BOOL        fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);
   
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
   
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased(%d kB)\n",
                    dwMaxVirtualMemoryUsageInKB ));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedMemoryBased == TRUE )
    {
        WP_RECYCLER::TerminateMemoryBased();
    }

    
    if ( dwMaxVirtualMemoryUsageInKB  == 0 )
    {
        //
        // 0 means not to run memory recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForMemoryBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForMemoryBased,
                                  NULL,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  CHECK_MEMORY_TIME_PERIOD,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }

    //
    // Get current process handle
    // It will be used for NtQueryInformationProcess()
    // in the timer callback
    // there is no error to check for and handle doesn't need to be closed
    // on cleanup
    //
    
    sm_hCurrentProcess = GetCurrentProcess();
    
    sm_MaxValueForMemoryBased = 1024 * dwMaxVirtualMemoryUsageInKB;
    
    WP_RECYCLER::sm_fIsStartedMemoryBased = TRUE;

succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateMemoryBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartMemoryBased() failed with error hr=0x%x\n",
                    hr ));
    }

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
}

//static
VOID
WP_RECYCLER::TerminateMemoryBased(
    VOID
)
/*++

Routine Description:

    Stops virtual memory usage based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    VOID  
    
--*/

{
    HRESULT hr = E_FAIL;

    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForMemoryBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                            NULL,
                            WP_RECYCLER::sm_hTimerForMemoryBased,
                            INVALID_HANDLE_VALUE  /* wait for callbacks to complete */
                            ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
        WP_RECYCLER::sm_hTimerForMemoryBased = NULL;
    }
    WP_RECYCLER::sm_fIsStartedMemoryBased = FALSE;
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );
    return;

}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForMemoryBased(
    PVOID                   pParam,
    BOOLEAN                 TimerOrWaitFired
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Virtual memory usage will be checked and if limit has been reached
    then routine will inform WAS that process is ready to be recycled
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{
    NTSTATUS  Status = 0;
    VM_COUNTERS VmCounters;

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedMemoryBased );

    Status = NtQueryInformationProcess(  sm_hCurrentProcess,
                                         ProcessVmCounters,
                                         &VmCounters,
                                         sizeof(VM_COUNTERS),
                                         NULL );

    if ( ! NT_SUCCESS ( Status ) )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "NtQueryInformationProcess failed with Status: %d\n", 
                        Status ));
        }
        return;
    }

    if ( VmCounters.VirtualSize >= sm_MaxValueForMemoryBased )
    {
        IF_DEBUG( WPRECYCLER )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "WP_RECYCLER::TimerCallbackForMemoryBased()"
                        " - current VM:%ld kB, configured max VM:%ld kB"
                        " - tell WAS to recycle\n", 
                        VmCounters.VirtualSize/1024 , 
                        sm_MaxValueForMemoryBased/1024    ));
        }

        //
        // we reached Virtual Memory Usage limit
        //
        WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_MEMORY_LIMIT_REACHED );  
    }
}


//
// Static methods for Time based recycling
//


//static
HRESULT
WP_RECYCLER::StartTimeBased(
    IN  DWORD dwPeriodicRestartTimeInMinutes
)
/*++

Routine Description:

    Start elapsed time based recycling
    
    
Arguments:

    dwPeriodicRestartTimeInMinutes - how often to restart (in minutes)
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr   = E_FAIL;
    BOOL    fRet = FALSE;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );
    
    IF_DEBUG( WPRECYCLER )
    {

        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased(%d min)\n" ,   
                    dwPeriodicRestartTimeInMinutes ));
    }


    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedTimeBased == TRUE )
    {
        WP_RECYCLER::TerminateTimeBased();
    }

    
    if ( dwPeriodicRestartTimeInMinutes == 0 )
    {
        //
        // 0 means not to run time based recycling
        //
        hr = S_OK;
        goto succeeded;
    }

    fRet = CreateTimerQueueTimer( &WP_RECYCLER::sm_hTimerForTimeBased,
                                  NULL,
                                  WP_RECYCLER::TimerCallbackForTimeBased,
                                  NULL,
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  dwPeriodicRestartTimeInMinutes * 60000, 
                                        // convert to msec
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto failed;
    }
    
    WP_RECYCLER::sm_fIsStartedTimeBased = TRUE;
    
succeeded:    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return S_OK;
    
failed:
    DBG_ASSERT( FAILED( hr ) );
    WP_RECYCLER::TerminateTimeBased();

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartTimeBased() failed with error hr=0x%x\n",
                    hr));
    }
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;
    
}

//static
VOID
WP_RECYCLER::TerminateTimeBased(
    VOID
)
/*++

Routine Description:

    Stops elapsed time based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;

    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    if ( WP_RECYCLER::sm_hTimerForTimeBased != NULL )
    {
        if ( !DeleteTimerQueueTimer(   
                       NULL,
                       WP_RECYCLER::sm_hTimerForTimeBased,
                       INVALID_HANDLE_VALUE /* wait for callbacks to complete */ 
                       ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "failed to call DeleteTimerQueueTimer(): hr=0x%x\n",
                        HRESULT_FROM_WIN32(GetLastError()) ));
        }                                                              
                                              
        WP_RECYCLER::sm_hTimerForTimeBased = NULL;
    }
    WP_RECYCLER::sm_fIsStartedTimeBased = FALSE;

    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;
}

//static
VOID
WINAPI
WP_RECYCLER::TimerCallbackForTimeBased(
    PVOID                   pParam,
    BOOLEAN                 TimerOrWaitFired
)
/*++

Routine Description:

    Timer callback for Elapsed time based recycling   
    This Callback is passed to CreateTimerQueueTimer()

    Routine will inform WAS that process is ready to be recycled
    because required elapsed time has been reached
    
Arguments:

    see description of WAITORTIMERCALLBACK type in MSDN

    
Return Value:

    none

--*/


{

    DBG_ASSERT( WP_RECYCLER::sm_fIsStartedTimeBased );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::TimerCallbackForTimeBased"
                    " - tell WAS to recycle\n"           ));
    }

    WP_RECYCLER::SendRecyclingMsg( IPM_WP_RESTART_ELAPSED_TIME_REACHED );
}

//
// Static methods for Request based recycling
//


//static
HRESULT
WP_RECYCLER::StartRequestBased(
    IN  DWORD dwRequests
)
/*++

Routine Description:

    Start request based recycling. 
    
    
Arguments:

    dwRequests - If number of requests processed by worker process reaches this value
                 recycling will be required
    
Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_FAIL;
    
    DBG_ASSERT(TRUE == sm_fCritSecInit);

    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    IF_DEBUG( WPRECYCLER )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "WP_RECYCLER::StartRequestBased(%d kB)\n" ,   
                    dwRequests ));
    }

  
    //
    // If time based recycling has been running already
    // terminate it before restarting with new settings
    //
    
    if ( WP_RECYCLER::sm_fIsStartedRequestBased == TRUE )
    {
        WP_RECYCLER::TerminateRequestBased();
    }

    
    if ( dwRequests == 0 )
    {
        //
        // 0 means not to run request based recycling
        //
        hr = S_OK;
        goto succeeded;
    }


    InterlockedExchange( 
            reinterpret_cast<LONG *>(&sm_dwMaxValueForRequestBased), 
            dwRequests );
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            TRUE );

    hr = S_OK;
succeeded:
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return hr;

}

//static
VOID
WP_RECYCLER::TerminateRequestBased(
    VOID
)
/*++

Routine Description:

    Stops request based recycling 
    Performs cleanup

Note:
    It is safe to call this method for cleanup if Start failed
    
Arguments:

    NONE
    
Return Value:

    HRESULT

--*/

{
  
    DBG_ASSERT(TRUE == sm_fCritSecInit);
    
    EnterCriticalSection( &WP_RECYCLER::sm_CritSec );

    //
    // InterlockedExchange is used because Request Based recycling callback 
    // IsRequestCountLimitReached() is called for each request
    // and we don't synchronize it with &WP_RECYCLER::sm_CritSec 
    //
    
    InterlockedExchange( 
            reinterpret_cast<LONG *>(&WP_RECYCLER::sm_fIsStartedTimeBased), 
            FALSE );
    
    LeaveCriticalSection( &WP_RECYCLER::sm_CritSec );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\anonymousprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     anonymousprovider.cxx

   Abstract:
     Anonymous authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "anonymousprovider.hxx"

HRESULT
ANONYMOUS_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does anonymous apply to this request?

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
Return Value:

    HRESULT

--*/
{
    if ( pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Anonymous ALWAYS applies!
    //
    
    *pfApplies = TRUE;
    return NO_ERROR;
}
    
HRESULT
ANONYMOUS_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Routine Description:

    Do anonymous authentication (trivial)

Arguments:

    pMainContext - Main context representing request
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA *           pMetaData = NULL;
    TOKEN_CACHE_ENTRY *     pCachedToken = NULL;
    HRESULT                 hr;
    ANONYMOUS_USER_CONTEXT* pUserContext = NULL;
    // add 1 to strUserDomain for separator "\"
    STACK_STRA(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRA(             strPassword, PWLEN + 1 );
    // add 1 to strUserDomainW for separator "\"
    STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strPasswordW, PWLEN + 1 );
    STACK_STRU(             strDomainNameW, IIS_DNLEN + 1 );
    STACK_STRU(             strUserNameW, UNLEN + 1 );
    BOOL                    fFinished;
    BOOL                    fRet;
    DWORD                   dwLogonError;
    BOOL                    fPossibleUPNLogon = FALSE;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Notify authentication filters
    //
    
    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTHENTICATION ) )
    {
        HTTP_FILTER_AUTHENT     filterAuthent;
        
        DBG_ASSERT( strUserDomain.IsEmpty() );
        hr = strUserDomain.Resize( SF_MAX_USERNAME );
        if ( FAILED( hr ) )
        {
            return hr;
        }        

        DBG_ASSERT( strPassword.IsEmpty() );        
        hr = strPassword.Resize( SF_MAX_PASSWORD );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        filterAuthent.pszUser = strUserDomain.QueryStr();
        filterAuthent.cbUserBuff = SF_MAX_USERNAME;
        
        filterAuthent.pszPassword = strPassword.QueryStr();
        filterAuthent.cbPasswordBuff = SF_MAX_PASSWORD;
        
        fRet = pMainContext->NotifyFilters( SF_NOTIFY_AUTHENTICATION,
                                            &filterAuthent,
                                            &fFinished );

        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        if ( fFinished )
        {
            pMainContext->SetFinishedResponse();
            return NO_ERROR;
        }
        
        strUserDomain.SetLen( strlen( strUserDomain.QueryStr() ) );
        strPassword.SetLen( strlen( strPassword.QueryStr() ) );
    }
    
    //
    // If the filter set a user/password, then use it
    //
    
    if ( strUserDomain.QueryCCH() > 0 )
    {
        //
        // Convert to unicode 
        //
    
        hr = strUserDomainW.CopyA( strUserDomain.QueryStr() );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }
    
        hr = strPasswordW.CopyA( strPassword.QueryStr() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    
        //
        // Get username/domain out of domain\username
        //
    
        hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomainW,
                                                       &strUserNameW,
                                                       &strDomainNameW,
                                                       pMetaData->QueryDomainName(),
                                                       &fPossibleUPNLogon );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    
        //
        // Try to get the token
        // 

        DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
        hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                              strUserNameW.QueryStr(),
                                              strDomainNameW.QueryStr(),
                                              strPasswordW.QueryStr(),
                                              pMetaData->QueryLogonMethod(),
                                              fPossibleUPNLogon,
                                              &pCachedToken,
                                              &dwLogonError );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    else
    {
        //
        // Use the IUSR account
        //
        pCachedToken = pMetaData->QueryAnonymousToken();
       
        if ( pCachedToken != NULL )
        {
            //
            // Reference cached token because the metadata may go away from us
            // if AUTH_COMPLETE backed up the state machine
            //
            
            pCachedToken->ReferenceCacheEntry();
        }
    }
    
    if ( pCachedToken == NULL )
    {
        //
        // Bogus anonymous account
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        return NO_ERROR;
    }

    //
    // For perf reasons, the anonymous user context is inline
    //

    pUserContext = new (pMainContext) ANONYMOUS_USER_CONTEXT( this );
    DBG_ASSERT( pUserContext != NULL );
    
    hr = pUserContext->Create( pCachedToken,
                               pMetaData->QueryLogonMethod() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR; 
}

HRESULT
ANONYMOUS_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken,
    DWORD                       dwLogonMethod
)
/*++

Routine Description:

    Initialize anonymous context

Arguments:

    pCachedToken - anonymous user token
    dwLogonMethod - logon method
    
Return Value:

    HRESULT

--*/
{
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( dwLogonMethod == LOGON32_LOGON_INTERACTIVE ||
         dwLogonMethod == LOGON32_LOGON_BATCH )
    {
        _fDelegatable = TRUE;
    }
    
    _pCachedToken = pCachedToken;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\basicprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     basicprovider.cxx

   Abstract:
     Basic authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "basicprovider.hxx"
#include "uuencode.hxx"

HRESULT
BASIC_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does basic authentication apply to this request?

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA(         strAuthType, 64 );
    HRESULT             hr;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    
    *pfApplies = FALSE;
    
    //
    // Get auth type
    //
    
    hr = pMainContext->QueryRequest()->GetAuthType( &strAuthType );
    if ( FAILED( hr ) ) 
    {
        return hr;
    }
    
    //
    // No package, no auth
    //
    
    if ( strAuthType.IsEmpty() )
    {
        return NO_ERROR;
    }
    
    //
    // Is it basic?
    //
    
    if ( _stricmp( strAuthType.QueryStr(), "Basic" ) == 0 )
    {
        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}
    
HRESULT
BASIC_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *           pMainContext
)
/*++

Routine Description:

    Do the authentication thing!

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    CHAR *                  pszAuthHeader = NULL;
    HRESULT                 hr;
    BOOL                    fRet;
    BOOL                    fFinished = FALSE;
    STACK_BUFFER          ( buffDecoded, 256 );
    CHAR *                  pszDecoded;
    CHAR *                  pszColon;
    // add 1 to strUserDomain for separator "\"
    STACK_STRA(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRA(             strUserName, UNLEN + 1 );
    STACK_STRA(             strPassword, PWLEN  + 1 );
    STACK_STRA(             strDomainName, IIS_DNLEN + 1 );
    // add 1 to strUserDomainW for separator "\"
    STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strUserNameW, UNLEN + 1 );
    STACK_STRU(             strPasswordW, PWLEN + 1 );
    STACK_STRU(             strRemotePasswordW, PWLEN + 1 );
    STACK_STRU(             strDomainNameW, IIS_DNLEN + 1 );
    // add 1 to strRemoteUserNameW for separator "\"
    STACK_STRU(             strRemoteUserNameW, UNLEN + IIS_DNLEN + 1 );
    W3_METADATA *           pMetaData = NULL;
    TOKEN_CACHE_ENTRY *     pCachedToken = NULL;
    BASIC_USER_CONTEXT *    pUserContext = NULL;
    DWORD                   dwLogonError = ERROR_SUCCESS;
    BOOL                    fPossibleUPNLogon = FALSE;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the part after the auth type
    //
    
    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
    DBG_ASSERT( pszAuthHeader != NULL );

    //
    // We better have an Authorization: Basic header if we got to here!
    //
    
    DBG_ASSERT( _strnicmp( pszAuthHeader, "Basic", 5 ) == 0 );

    //
    // Advance to good stuff
    //

    if ( pszAuthHeader[ 5 ] == '\0' )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }
    pszAuthHeader = pszAuthHeader + 6;

    //
    // UUDecode the buffer
    //

    if ( !uudecode( pszAuthHeader,
                    &buffDecoded ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
    }
    
    pszDecoded = (CHAR*) buffDecoded.QueryPtr();

    //
    // Now split out user:password
    //
    
    pszColon = strchr( pszDecoded, ':' );
    if ( pszColon == NULL )
    {
        //
        // Bad credentials
        //   
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

        hr = NO_ERROR;
        goto exit;
    }   
    
    //
    // Get user/password
    // 

    hr = strUserDomain.Copy( pszDecoded,
                             DIFF( pszColon - pszDecoded ) );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
        
    hr = strPassword.Copy( pszColon + 1 );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Copy the user name into the request
    //
    
    hr = pMainContext->QueryRequest()->SetRequestUserName( strUserDomain );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Remember the unmapped user name and password
    //
    
    hr = strRemoteUserNameW.CopyA( strUserDomain.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    hr = strRemotePasswordW.CopyA( strPassword.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Notify authentication filters
    //
    
    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTHENTICATION ) )
    {
        HTTP_FILTER_AUTHENT     filterAuthent;
        
        hr = strUserDomain.Resize( SF_MAX_USERNAME );
        if ( FAILED( hr ) )
        {
            goto exit;
        }        
        
        hr = strPassword.Resize( SF_MAX_PASSWORD );
        if ( FAILED( hr ) )
        {
            goto exit;
        }
        
        filterAuthent.pszUser = strUserDomain.QueryStr();
        filterAuthent.cbUserBuff = SF_MAX_USERNAME;
        
        filterAuthent.pszPassword = strPassword.QueryStr();
        filterAuthent.cbPasswordBuff = SF_MAX_PASSWORD;
        
        fRet = pMainContext->NotifyFilters( SF_NOTIFY_AUTHENTICATION,
                                            &filterAuthent,
                                            &fFinished );

        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }
        
        if ( fFinished )
        {
            pMainContext->SetFinishedResponse();
            hr = NO_ERROR;
            goto exit;
        }
        
        strUserDomain.SetLen( strlen( strUserDomain.QueryStr() ) );
        strPassword.SetLen( strlen( strPassword.QueryStr() ) );
    }
    
    if( strUserDomain.IsEmpty() )
    {
        //
        // If user domain string is empty, then we will fall back to 
        // anonymous authentication
        //

        AUTH_PROVIDER * pAnonymousProvider = 
                W3_STATE_AUTHENTICATION::QueryAnonymousProvider();

        DBG_ASSERT( pAnonymousProvider != NULL );
    
        hr = pAnonymousProvider->DoAuthenticate( pMainContext );

        goto exit;
    }

    //
    // Convert to unicode 
    //
    
    hr = strUserDomainW.CopyA( strUserDomain.QueryStr() );
    if ( FAILED( hr ) ) 
    {
        goto exit;
    }
    
    hr = strPasswordW.CopyA( strPassword.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Get username/domain out of domain\username
    //
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomainW,
                                                   &strUserNameW,
                                                   &strDomainNameW,
                                                   pMetaData->QueryDomainName(),
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // Try to get the token
    // 
    
    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                          strUserNameW.QueryStr(),
                                          strDomainNameW.QueryStr(),
                                          strPasswordW.QueryStr(),
                                          pMetaData->QueryLogonMethod(),
                                          fPossibleUPNLogon,
                                          &pCachedToken,
                                          &dwLogonError );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    //
    // If pCachedToken is NULL, then logon failed
    //

    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( dwLogonError != ERROR_SUCCESS );
        
        if( dwLogonError == ERROR_PASSWORD_MUST_CHANGE ||
            dwLogonError == ERROR_PASSWORD_EXPIRED )
        {
            hr = HRESULT_FROM_WIN32( dwLogonError );
            goto exit;
        }

        pMainContext->QueryResponse()->SetStatus( 
                               HttpStatusUnauthorized,
                               Http401BadLogon );
        pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( dwLogonError ) );

        hr = NO_ERROR;
        goto exit;
    }

    //
    // We have a token! Setup a W3_USER_CONTEXT and we're done
    //
    
    pUserContext = new BASIC_USER_CONTEXT( this );
    if ( FAILED( hr ) )
    {
        goto exit;
    }
    
    hr = pUserContext->Create( pCachedToken,
                               strUserNameW,
                               strDomainNameW,
                               strRemotePasswordW,
                               strRemoteUserNameW,
                               strUserDomainW,
                               pMetaData->QueryLogonMethod() );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        goto exit;
    }
                                                        
    pMainContext->SetUserContext( pUserContext );
    
exit:

    //
    // Zero out all copies of password in this routine
    //
    ZeroMemory( buffDecoded.QueryPtr(), buffDecoded.QuerySize() );

    if( strPassword.QueryCB() )
    {
        ZeroMemory( ( VOID * )strPassword.QueryStr(), 
                    strPassword.QueryCB() );
    }

    if( strPasswordW.QueryCB() )
    {
        ZeroMemory( ( VOID * )strPasswordW.QueryStr(), 
                    strPassword.QueryCB() );
    }

    if( strRemotePasswordW.QueryCB() )
    {
        ZeroMemory( ( VOID * )strRemotePasswordW.QueryStr(), 
                    strPassword.QueryCB() );
    }

    return hr;
}

HRESULT
BASIC_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *           pMainContext
)
/*++

Routine Description:

    Add basic authentication header

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strAuthHeader, 256 );
    STACK_STRA(         straAuthHeader, 256 );
    STACK_STRU(         strHostAddr, 256 );
    HRESULT             hr;
    W3_METADATA *       pMetaData;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = strAuthHeader.Copy( L"Basic realm=\"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // If a realm is configured, use it.  Otherwise use host address of 
    // request 
    //
    
    if ( pMetaData->QueryRealm() != NULL )
    {
        hr = strAuthHeader.Append( pMetaData->QueryRealm() );
    }
    else
    {
        hr = pMainContext->QueryRequest()->GetHostAddr( &strHostAddr );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = strAuthHeader.Append( strHostAddr );
    }
    
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = strAuthHeader.Append( L"\"" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if (FAILED(hr = straAuthHeader.CopyW(strAuthHeader.QueryStr())))
    {
        return hr;
    }
    
    return pMainContext->QueryResponse()->SetHeader( "WWW-Authenticate",
                                                     16,
                                                     straAuthHeader.QueryStr(),
                                                     straAuthHeader.QueryCCH() );
}

HRESULT
BASIC_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken,
    STRU &                      strUserName,
    STRU &                      strDomainName,
    STRU &                      strPassword,
    STRU &                      strRemoteUserName,
    STRU &                      strMappedDomainUser,
    DWORD                       dwLogonMethod
)
/*++

Routine Description:

    Initialize a basic user context

Arguments:

    pCachedToken - The token
    strUserName - User name (without embedded domain)
    strDomainName - Domain name
    strPassword - Password
    strRemoteUserName - Unmapped user name
    strMappedDomainUser - Mapped domain user (may have embedded domain)
    dwLogonMethod - Logon method
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = _strUserName.Copy( strMappedDomainUser );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strPassword.Append( strPassword );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRemoteUserName.Append( strRemoteUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( dwLogonMethod == LOGON32_LOGON_INTERACTIVE ||
         dwLogonMethod == LOGON32_LOGON_BATCH )
    {
        _fDelegatable = TRUE;
    }
         
    _pCachedToken = pCachedToken;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\authstate.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation
            
   Module Name:
      authstate.cxx

   Abstract:
      Authenticate state implementation (and authentication utilities)

   Author:
      Ming Lu    ( MingLu )    2-Feb-2000

   Environment:
      Win32 User Mode

   Revision History:

--*/

#include "precomp.hxx"
#include "sspiprovider.hxx"
#include "digestprovider.hxx"
#include "iisdigestprovider.hxx"
#include "basicprovider.hxx"
#include "anonymousprovider.hxx"
#include "certmapprovider.hxx"
#include "iiscertmapprovider.hxx"
#include "customprovider.hxx"

W3_STATE_AUTHENTICATION *   W3_STATE_AUTHENTICATION::sm_pAuthState;
LUID               W3_STATE_AUTHENTICATION::sm_BackupPrivilegeTcbValue;
PTOKEN_PRIVILEGES  W3_STATE_AUTHENTICATION::sm_pTokenPrivilege = NULL;
PTRACE_LOG         W3_USER_CONTEXT::sm_pTraceLog;
PTRACE_LOG         CONNECTION_AUTH_CONTEXT::sm_pTraceLog;

HRESULT
W3_STATE_AUTHENTICATION::GetDefaultDomainName(
    VOID
)
/*++
  Description:
    
    Fills in the member variable with the name of the default domain 
    to use for logon validation

  Arguments:

    szDefaultDomainName - Buffer to hold the default domain name 

  Returns:    
    
    HRESULT

--*/
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       dwLength;
    DWORD                       err                = 0;
    LSA_HANDLE                  LsaPolicyHandle    = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAcctDomainInfo    = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo = NULL;
    HRESULT                     hr                 = S_OK;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  
                                NULL,             
                                0L,               
                                NULL,             
                                NULL );           

    NtStatus = LsaOpenPolicy( NULL,               
                              &ObjectAttributes,  
                              POLICY_EXECUTE,     
                              &LsaPolicyHandle ); 

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF((  DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );

        //
        // Failure LsaOpenPolicy() does not guarantee that 
        // LsaPolicyHandle was not touched.
        //
        LsaPolicyHandle = NULL;

        goto Cleanup;
    }

    //
    //  Query the account domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&pAcctDomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    DBG_ASSERT( pAcctDomainInfo != NULL );
    
    dwLength = pAcctDomainInfo->DomainName.Length / sizeof( WCHAR );

    wcsncpy( _achDefaultDomainName, 
             (LPCWSTR)pAcctDomainInfo->DomainName.Buffer, 
             sizeof( _achDefaultDomainName ) / sizeof( WCHAR ) );

    _achDefaultDomainName[ dwLength ] = L'\0';

    //
    //  Query the primary domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyPrimaryDomainInformation,
                                          (PVOID *)&pPrimaryDomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    DBG_ASSERT( pPrimaryDomainInfo != NULL );
    
    if( pPrimaryDomainInfo->Sid )
    {
        // 
        // We are a domain member
        //
        _fIsDomainMember = TRUE;
    }
    else
    {
        _fIsDomainMember = FALSE;
    }

    //
    //  Success!
    //

    DBG_ASSERT( err == 0 );

Cleanup:

    if( pAcctDomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)pAcctDomainInfo );
        pAcctDomainInfo = NULL;                                          
    }

    if( pPrimaryDomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)pPrimaryDomainInfo ); 
        pPrimaryDomainInfo = NULL;                                         
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    if ( err )
    {
        hr = HRESULT_FROM_WIN32( err );
    }

    return hr;
};

//static
HRESULT
W3_STATE_AUTHENTICATION::SplitUserDomain(
    STRU &                  strUserDomain,
    STRU *                  pstrUserName,
    STRU *                  pstrDomainName,
    WCHAR *                 pszDefaultDomain,
    BOOL *                  pfPossibleUPNLogon
)
/*++
  Description:
    
    Split the input user name into user/domain.  

  Arguments:

    strUserDomain - Combined domain\username (not altered)
    pstrUserName - Filled with user name only
    pstrDomainName - Filled with domain name (either embedded in 
                     *pstrUserName,or from metabase/computer domain name)
    pszDefaultDomain - Default domain specified in metabase
    pfPossibleUPNLogon - TRUE if we may need to do UNP logon, 
                         otherwise FALSE

  Returns:    
    
    HRESULT

--*/
{
    WCHAR *                 pszUserName;
    W3_METADATA *           pMetaData = NULL;
    WCHAR *                 pszDomain;
    DWORD                   cbDomain;
    HRESULT                 hr;
    
    if ( pstrUserName == NULL   ||
         pstrDomainName == NULL ||
         pfPossibleUPNLogon == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pszUserName = wcspbrk( strUserDomain.QueryStr(), L"/\\" );
    if ( pszUserName == NULL )
    {
        //
        // No domain in the user name.  First try the metabase domain 
        // name
        //
        
        pszDomain = pszDefaultDomain;
        if ( pszDomain == NULL || *pszDomain == L'\0' )
        {
            //
            // No metabase domain, use default domain name
            //
            
            pszDomain = QueryDefaultDomainName();
            DBG_ASSERT( pszDomain != NULL );
        }
        
        pszUserName = strUserDomain.QueryStr();
        
        hr = pstrDomainName->Copy( pszDomain );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *pfPossibleUPNLogon = TRUE;
    }
    else
    {
        cbDomain = DIFF( pszUserName - strUserDomain.QueryStr() );
        if( cbDomain == 0 )
        {
            hr = pstrDomainName->Copy( L"." );
        }
        else
        {
            hr = pstrDomainName->Copy( strUserDomain.QueryStr(), cbDomain );
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }

        pszUserName = pszUserName + 1;

        *pfPossibleUPNLogon = FALSE;
    }
    
    hr = pstrUserName->Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_STATE_AUTHENTICATION::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++
  Description:
    
    Called when a resource is access denied.  This routines will call 
    all authentication providers so that they may add authentication 
    headers, etc. 

  Arguments:

    pMainContext - main context

  Returns:    
    
    HRESULT

--*/
{
    AUTH_PROVIDER *         pProvider;
    DWORD                   cProviderCount = 0;
    W3_METADATA *           pMetaData;
    HRESULT                 hr = NO_ERROR;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Loop thru all authentication providers
    //

    for ( cProviderCount = 0; ; cProviderCount++ )
    {
        pProvider = _rgAuthProviders[ cProviderCount ];
        if ( pProvider == NULL )
        {
            break;
        }
        
        //
        // Only call OnAccessDenied() if the authentication provider is 
        // supported for the given metadata of the denied request 
        //
        
        if ( !pMetaData->QueryAuthTypeSupported( 
                                  pProvider->QueryAuthType() ) )
        {
            continue;
        }
        
        hr = pProvider->OnAccessDenied( pMainContext );
        if ( FAILED( hr ) )
        {
            break;
        }
    }
    
    return hr;
}

VOID
W3_STATE_AUTHENTICATION::GetSSPTokenPrivilege(
    VOID
    )
/*++
  Description:
    
    Prepare an appropriate token privilege used to adjust the 
    SSP impersonation token privilege in order to work around 
    the problem introduced by using FILE_FLAG_BACKUP_SEMANTICS
    in CreateFileW call in W3_FILE_INFO::OpenFile. 

  Arguments:

    None.

  Returns:    
    
    None.

--*/
{
    sm_pTokenPrivilege = ( PTOKEN_PRIVILEGES )LocalAlloc( LMEM_FIXED,
            sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ));
    if ( sm_pTokenPrivilege != NULL )
    {
        if ( !LookupPrivilegeValue( NULL,
                                    L"SeBackupPrivilege",
                                    &sm_BackupPrivilegeTcbValue ) )
        {
            sm_pTokenPrivilege->PrivilegeCount = 0;
        }
        else
        {
            //
            // Set attributes to disable SeBackupPrivilege for SSP
            // impersonation token
            //

            sm_pTokenPrivilege->PrivilegeCount = 1;

            sm_pTokenPrivilege->Privileges[0].Luid = 
                                      sm_BackupPrivilegeTcbValue;
            
            sm_pTokenPrivilege->Privileges[0].Attributes = 0;
        }
    }
}
    
W3_STATE_AUTHENTICATION::W3_STATE_AUTHENTICATION()
{
    _pAnonymousProvider = NULL;
    _pCustomProvider = NULL;
    _fHasAssociatedUserBefore = FALSE;
    
    //
    // Initialize token privilege for SSP impersionation token
    //

    GetSSPTokenPrivilege();
    
    //
    // Figure out the default domain name once
    //
    
    _hr = GetDefaultDomainName();
    if ( FAILED( _hr ) )
    {
        return;
    }
    
    //
    // Initialize all the authentication providers
    //
    
    ZeroMemory( _rgAuthProviders, sizeof( _rgAuthProviders ) );
    
    _hr = InitializeAuthenticationProviders();
    if ( FAILED( _hr ) )
    {
        return;
    }
    
    _cbContextSize = sizeof( SSPI_CONTEXT_STATE ) + 
                     sizeof( ANONYMOUS_USER_CONTEXT );

    //
    // Initialize reverse DNS service
    //    
    
    if (!InitRDns())
    {
        _hr = HRESULT_FROM_WIN32(GetLastError());

        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing RDns service.  hr = 0x%x\n",
                    _hr ));
        
        TerminateAuthenticationProviders();
        return;
    }

    //
    // Initialize the W3_USER_CONTEXT reftrace log
    //
#if DBG
    W3_USER_CONTEXT::sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    W3_USER_CONTEXT::sm_pTraceLog = NULL;
#endif
    
    //
    // Store a pointer to the singleton (no C++ goo used in creating
    // this singleton)
    //
   
    if ( sm_pAuthState != NULL )
    {
        DBG_ASSERT( sm_pAuthState != NULL );
        _hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    else
    {
        sm_pAuthState = this;
    }
}

W3_STATE_AUTHENTICATION::~W3_STATE_AUTHENTICATION()
{
    if ( W3_USER_CONTEXT::sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( W3_USER_CONTEXT::sm_pTraceLog );
        W3_USER_CONTEXT::sm_pTraceLog = NULL;
    }

    TerminateRDns();
    
    TerminateAuthenticationProviders();
    
    if (sm_pTokenPrivilege != NULL)
    {
        LocalFree(sm_pTokenPrivilege);
        sm_pTokenPrivilege = NULL;
    }

    sm_pAuthState = NULL;
}

HRESULT
W3_STATE_AUTHENTICATION::InitializeAuthenticationProviders(
    VOID
)
/*++

Routine Description:

    Initialize all authentication providers

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    DWORD               cProviderCount = 0;

    //
    // Initialize trace for connection contexts
    //
    
    hr = CONNECTION_AUTH_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Certificate map provider.  This must be the first !!!!!!
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new CERTMAP_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new IISCERTMAP_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // SSPI provider
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new SSPI_AUTH_PROVIDER( MD_AUTH_NT );
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // Digest provider
    //

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new DIGEST_AUTH_PROVIDER( MD_AUTH_MD5 );
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;

    //
    // IIS Digest provider (for backward compatibility)
    //

    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = 
           new IIS_DIGEST_AUTH_PROVIDER();
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;
    
    //
    // Basic provider
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new BASIC_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    cProviderCount++;
    
    //
    // Anonymous provider.
    //
    // Note: This one should always be the last one
    //
    
    DBG_ASSERT( cProviderCount < AUTH_PROVIDER_COUNT );
    _rgAuthProviders[ cProviderCount ] = new ANONYMOUS_AUTH_PROVIDER;
    if ( _rgAuthProviders[ cProviderCount ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }
    hr = _rgAuthProviders[ cProviderCount ]->Initialize( cProviderCount );
    if ( FAILED( hr ) )
    {
        delete _rgAuthProviders[ cProviderCount ];
        _rgAuthProviders[ cProviderCount ] = NULL;
        goto Failure;
    }
    _pAnonymousProvider = _rgAuthProviders[ cProviderCount ];
    
    cProviderCount++;

    //
    // Custom provider.  Not really a provider in the sense that it does not
    // participate in authenticating a request.  Instead, it is just used
    // as a stub provider for custom authentication done with
    // HSE_REQ_EXEC_URL
    //
    
    _pCustomProvider = new CUSTOM_AUTH_PROVIDER;
    if ( _pCustomProvider == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;    
    }

    return NO_ERROR;
    
Failure:
    
    for ( DWORD i = 0; i < AUTH_PROVIDER_COUNT; i++ )
    {
        if ( _rgAuthProviders[ i ] != NULL )
        {
            _rgAuthProviders[ i ]->Terminate();
            delete _rgAuthProviders[ i ];
            _rgAuthProviders[ i ] = NULL;
        }
    }
    
    CONNECTION_AUTH_CONTEXT::Terminate();
    
    return hr;
}

VOID
W3_STATE_AUTHENTICATION::TerminateAuthenticationProviders(
    VOID
)
/*++

Routine Description:

    Terminate all authentication providers

Arguments:

    None
    
Return Value:

    None

--*/
{
    for ( DWORD i = 0; i < AUTH_PROVIDER_COUNT; i++ )
    {
        if ( _rgAuthProviders[ i ] != NULL )
        {
            _rgAuthProviders[ i ]->Terminate();
            delete _rgAuthProviders[ i ];
            _rgAuthProviders[ i ] = NULL;
        }
    }
    
    if ( _pCustomProvider != NULL )
    {
        delete _pCustomProvider;
        _pCustomProvider = NULL;
    }
    
    CONNECTION_AUTH_CONTEXT::Terminate();
}

CONTEXT_STATUS
W3_STATE_AUTHENTICATION::DoWork(
    W3_MAIN_CONTEXT *            pMainContext,
    DWORD                        cbCompletion,
    DWORD                        dwCompletionStatus
    )
/*++

Routine Description:

    Handle authentication for this request

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state 
                   machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    DWORD                   cProviderCount = 0;
    AUTH_PROVIDER *         pProvider = NULL;
    W3_METADATA *           pMetaData = NULL;
    W3_USER_CONTEXT *       pUserContext = NULL;
    URL_CONTEXT *           pUrlContext = NULL;
    BOOL                    fSupported = FALSE;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fApplies = FALSE;

    
    DBG_ASSERT( pMainContext != NULL );

    //
    // If we already have a user context, then we must have had an
    // AUTH_COMPLETE notification which caused the state machine to back up
    // and resume from URLINFO state.  In that case, just bail
    //
    
    if ( pMainContext->QueryUserContext() != NULL )
    {
        DBG_ASSERT( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) );

        return CONTEXT_STATUS_CONTINUE;
    }
   
    //
    // First, find the authentication provider which applies. We 
    // should always find a matching provider (since anonymous 
    // provider) should always match!
    //

    for ( ; ; )
    {
        pProvider = _rgAuthProviders[ cProviderCount ];
        if ( pProvider == NULL )
        {
            break;
        }
        
        DBG_ASSERT( pProvider != NULL );

        hr = pProvider->DoesApply( pMainContext,
                                   &fApplies );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
                
        if ( fApplies )
        {
            //
            // Cool.  We have a match!  
            //
            
            break;
        }
        
        cProviderCount++;

    }

    //
    // If only the anonymous provider matched, then check whether we 
    // have credentials associated with the connection (since IE won't 
    // send Authorization: header for subsequent SSPI authenticated 
    // requests on a connection)
    //
    
    if ( pProvider->QueryAuthType() == MD_AUTH_ANONYMOUS )
    {   
        //
        // Another slimy optimization.  If we haven't associated a user
        // with the connection, then we don't have to bother looking up
        // connection
        //

        if ( _fHasAssociatedUserBefore )
        {
            pUserContext = pMainContext->QueryConnectionUserContext();
            if ( pUserContext != NULL )
            {
                pProvider = pUserContext->QueryProvider();
                DBG_ASSERT( pProvider != NULL );
            }
        }
    }
    else
    {
        //
        // If a provider applies, then ignore/remove any
        // cached user associated with the request
        //

        pUserContext = pMainContext->QueryConnectionUserContext();
        if ( pUserContext != NULL )
        {
            pMainContext->SetConnectionUserContext( NULL );
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
        }
    }

    //
    // Is the given provider supported (by metadata)
    //

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    if ( pMetaData->QueryAuthTypeSupported( pProvider->QueryAuthType() ) )
    {
        fSupported = TRUE;
    }
    else
    {
        //
        // If anonymous authentication is supported, then we can
        // still let it thru
        // 
     
        if ( pMetaData->QueryAuthTypeSupported( MD_AUTH_ANONYMOUS ) )
        {
            pProvider = QueryAnonymousProvider();
            DBG_ASSERT( pProvider != NULL );

            //
            // Anonymous provider applies, remove the previous cached
            // user associated with the request
            //

            if ( pUserContext != NULL )
            {
                pMainContext->SetConnectionUserContext( NULL );
                pUserContext->DereferenceUserContext();
                pUserContext = NULL;
            }        

            fSupported = TRUE;
        }   
    }

    //
    // Not supported, you're outta here!
    //

    if ( !fSupported )
    {
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401Config );
        pMainContext->SetFinishedResponse();

        hr = pMainContext->OnAccessDenied();
        goto Finished;
    }

    //
    // Now we can authenticate
    //

    if ( pUserContext != NULL )
    {   
        //
        // We already have a context associated with connection.  Use it!
        //

        pUserContext->ReferenceUserContext();
        pMainContext->SetUserContext( pUserContext );
    }
    else
    {
        DBG_ASSERT( pProvider != NULL );

        // perf ctr
        pMainContext->QuerySite()->IncLogonAttempts();

        hr = pProvider->DoAuthenticate( pMainContext );
        if ( FAILED( hr ) )
        {
            if( WIN32_FROM_HRESULT( hr ) == ERROR_PASSWORD_MUST_CHANGE ||
                WIN32_FROM_HRESULT( hr ) == ERROR_PASSWORD_EXPIRED )
            {
                hr = pMainContext->PasswdChangeExecute();
                if( S_OK == hr )
                {
                    return CONTEXT_STATUS_PENDING;
                }
                else if( S_FALSE == hr )
                {
                    //
                    // S_FALSE means password change disabled
                    //
                    pMainContext->QueryResponse()->SetStatus( 
                                           HttpStatusUnauthorized,
                                           Http401BadLogon );
                    pMainContext->SetErrorStatus( hr );
                    pMainContext->SetFinishedResponse();

                    return CONTEXT_STATUS_CONTINUE;        
                }
            }

            goto Finished;
        }
    }

    //
    // Do we have a valid user now
    //

    pUserContext = pMainContext->QueryUserContext();

    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthType() != MD_AUTH_ANONYMOUS )
        {
            hr = pMainContext->PasswdExpireNotify(); 
            if( FAILED( hr ) )
            {
                //
                // Internal error
                //
                goto Finished;
            }
            else if( hr == S_OK )
            {
                //
                // We've successfully handled password expire 
                // notification 
                //

                return CONTEXT_STATUS_PENDING;
            }

            //
            // Advanced password expire notification is disabled, 
            // we should allow the user to get access, fall through
            //
        }
        
        //
        // Should we cache the user on the connection?  Do so, only if 
        //
        
        DBG_ASSERT( pMetaData != NULL );
        
        if ( pMetaData->QueryAuthPersistence() != MD_AUTH_SINGLEREQUEST
             && pUserContext->QueryProvider()->QueryAuthType() == MD_AUTH_NT 
             && !pMainContext->QueryRequest()->IsProxyRequest() 
             && pUserContext != pMainContext->QueryConnectionUserContext() )
        {
            pUserContext->ReferenceUserContext();
            pMainContext->SetConnectionUserContext( pUserContext );
            _fHasAssociatedUserBefore = TRUE;
        }
    }
    else
    {
        //
        // If we don't have a user, then we must not allow handle request 
        // state to happen!
        //
        
        pMainContext->SetFinishedResponse();
    }
    
    //
    // OK.  If we got to here and we have a user context, then authentication
    // is complete!  So lets notify AUTH_COMPLETE filters
    //
    
    if ( pUserContext != NULL )
    {
        if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) )
        {
            HTTP_FILTER_AUTH_COMPLETE_INFO      AuthInfo;
            STACK_STRU(                         strOriginal, MAX_PATH );    
            STACK_STRU(                         strNewUrl, MAX_PATH );
            BOOL                                fFinished = FALSE;
        
            //
            // Store away the original URL
            //
            
            hr = pMainContext->QueryRequest()->GetUrl( &strOriginal );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }

            //
            // Call the filter
            //
            
            pMainContext->NotifyFilters( SF_NOTIFY_AUTH_COMPLETE,
                                         &AuthInfo,
                                         &fFinished );
        
            if ( fFinished )
            {
                pMainContext->SetDone();
                return CONTEXT_STATUS_CONTINUE;
            }
                        
            //
            // If the URL has changed, we'll need to backup the state machine
            //
            
            hr = pMainContext->QueryRequest()->GetUrl( &strNewUrl );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
            
            if ( wcscmp( strNewUrl.QueryStr(), 
                         strOriginal.QueryStr() ) != 0 )
            {
                //
                // URL is different!
                //
                
                pMainContext->BackupStateMachine();
            }
            else
            {
                //
                // URL is the same.  Do nothing and continue
                //
            }
        }
    }

Finished:
    if ( FAILED( hr ) )
    {
        pMainContext->QueryResponse()->
                           SetStatus( HttpStatusServerError );
        pMainContext->SetFinishedResponse();
        pMainContext->SetErrorStatus( hr );
    }
    
    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cachevalidation.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     cachevalidation.cxx

   Abstract:
     Handle Cache Validation (If-* headers)

   Author:
     Anil Ruia (AnilR)            3-Apr-2000

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

dllexp BOOL FindInETagList(CHAR * pLocalETag,
                           CHAR * pETagList,
                           BOOL   fWeakCompare)
/*++

Routine Description:
    Search input list of ETags for one that matches our local ETag.

Arguments:
    pLocalETag   - The local ETag we're using.
    pETagList    - The ETag list we've received from the client.
    bWeakCompare - Whether using Weak Comparison is ok

Returns:

    TRUE if we found a matching ETag, FALSE otherwise.

--*/
{
    UINT   QuoteCount;
    CHAR * pFileETag;
    BOOL   Matched;

    // We'll loop through the ETag string, looking for ETag to
    // compare, as long as we have an ETag to look at.

    do
    {
        while (SAFEIsSpace(*pETagList))
        {
            pETagList++;
        }

        if (!*pETagList)
        {
            // Ran out of ETag.
            return FALSE;
        }

        // If this ETag is *, it's a match.
        if (*pETagList == '*')
        {
            return TRUE;
        }

        // See if this ETag is weak.
        if (pETagList[0] == 'W' && pETagList[1] == '/')
        {
            // This is a weak validator. If we're not doing the weak
            // comparison, fail.

            if (!fWeakCompare)
            {
                return FALSE;
            }

            // Skip over the 'W/', and any intervening whitespace.
            pETagList += 2;

            while (SAFEIsSpace(*pETagList))
            {
                pETagList++;
            }

            if (!*pETagList)
            {
                // Ran out of ETag.
                return FALSE;
            }
        }

        if (*pETagList != '"')
        {
            // This isn't a quoted string, so fail.
            return FALSE;
        }

        // OK, right now we should be at the start of a quoted string that
        // we can compare against our current ETag.

        QuoteCount = 0;

        Matched = TRUE;
        pFileETag = pLocalETag;

        // Do the actual compare. We do this by scanning the current ETag,
        // which is a quoted string. We look for two quotation marks, the
        // the delimiters if the quoted string. If after we find two quotes
        // in the ETag everything has matched, then we've matched this ETag.
        // Otherwise we'll try the next one.

        do
        {
            CHAR Temp;

            Temp = *pETagList;

            if (Temp == '"')
            {
                QuoteCount++;
            }

            if (*pFileETag != Temp)
            {
                Matched = FALSE;
            }

            if (!Temp)
            {
                return FALSE;
            }

            pETagList++;

            if (*pFileETag == '\0')
            {
                break;
            }

            pFileETag++;


        }
        while (QuoteCount != 2);

        if (Matched)
        {
            return TRUE;
        }

        // Otherwise, at this point we need to look at the next ETag.

        while (QuoteCount != 2)
        {
            if (*pETagList == '"')
            {
                QuoteCount++;
            }
            else
            {
                if (*pETagList == '\0')
                {
                    return FALSE;
                }
            }

            pETagList++;
        }

        while (SAFEIsSpace(*pETagList))
        {
            pETagList++;
        }

        if (*pETagList == ',')
        {
            pETagList++;
        }
        else
        {
            return FALSE;
        }

    }
    while ( *pETagList );

    return FALSE;
}


HRESULT W3_STATIC_FILE_HANDLER::CacheValidationDoWork(
    W3_CONTEXT   *pW3Context,
    W3_FILE_INFO *pOpenFile,
    BOOL         *pfHandled)
/*++
  Synopsis
    Handle the Cache Related If-* headers

  Input
    pW3Context : W3_CONTEXT for the request
    pOpenFile  : The file's cache entry
    pfHandled  : On return indicates whether, we have handled the request
                 or further processing needs to be done

  Returns
    HRESULT
--*/
{
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();

    //
    // There are currently 4 possible Cache Related If-* modifiers:
    // If-Match, If-Unmodified-Since, If-Non-Match, If-Modified-Since.
    // We handle them in that order if all are present, and as soon as
    // one condition fails we stop processing
    //

    //
    // Now handle the If-Match header, if we have one.
    //
    CHAR * pszIfMatch = pRequest->GetHeader(HttpHeaderIfMatch);
    if (pszIfMatch != NULL)
    {
        if (pOpenFile->QueryIsWeakETag() ||
            !FindInETagList(pOpenFile->QueryETag(), pszIfMatch, FALSE))
        {
            pResponse->ClearHeaders();
            pResponse->SetStatus(HttpStatusPreconditionFailed);
            *pfHandled = TRUE;
            return S_OK;
        }
    }

    //
    // Now see if we have an If-None-Match, and if so handle that.
    //
    CHAR * pszIfNoneMatch = pRequest->GetHeader(HttpHeaderIfNoneMatch);
    BOOL fIsNoneMatchPassed = TRUE;
    BOOL fSkipIfModifiedSince = FALSE;
    if (pszIfNoneMatch != NULL)
    {
        if (FindInETagList(pOpenFile->QueryETag(),
                           pszIfNoneMatch,
                           TRUE))
        {
            fIsNoneMatchPassed = FALSE;
        }
        else
        {
            // If none of the tags match, we should skip If-Modified-Since
            fSkipIfModifiedSince = TRUE;
        }
    }

    //
    // Made it through that, handle If-Modified-Since if we have that.
    //
    CHAR * pszIfModifiedSince = pRequest->GetHeader(HttpHeaderIfModifiedSince);
    if (!fSkipIfModifiedSince && pszIfModifiedSince != NULL)
    {
        LARGE_INTEGER liModifiedSince;
        if (StringTimeToFileTime(pszIfModifiedSince,
                                 &liModifiedSince))
        {
            FILETIME tm;
            pOpenFile->QueryLastWriteTime(&tm);

            // Check if our last write time is greater than their
            // ModifiedSince time
            if (*(LONGLONG*)&tm <= liModifiedSince.QuadPart)
            {
                // Need to check and see if the Modified-Since time is greater
                // than our current time. If it is, we ignore it.

                GetSystemTimeAsFileTime(&tm);

                if (*(LONGLONG *)&tm >= liModifiedSince.QuadPart)
                {
                    pResponse->SetStatus(HttpStatusNotModified);
                    *pfHandled = TRUE;
                    return S_OK;
                }
            }
        }

        fIsNoneMatchPassed = TRUE;
    }

    if (!fIsNoneMatchPassed)
    {
        pResponse->SetStatus(HttpStatusNotModified);
        *pfHandled = TRUE;
        return S_OK;
    }

    //
    // Made it through that, handle If-Unmodified-Since if we have that.
    //
    CHAR * pszIfUnmodifiedSince = pRequest->GetHeader(
               HttpHeaderIfUnmodifiedSince);
    if (pszIfUnmodifiedSince != NULL)
    {
        LARGE_INTEGER liUnmodifiedSince;
        if (StringTimeToFileTime(pszIfUnmodifiedSince,
                                 &liUnmodifiedSince))
        {
            FILETIME    tm;
            
            pOpenFile->QueryLastWriteTime(&tm);

            // If our last write time is greater than their UnmodifiedSince
            // time, the precondition fails.
            if (*(LONGLONG*)&tm > liUnmodifiedSince.QuadPart)
            {
                pResponse->ClearHeaders();
                pResponse->SetStatus(HttpStatusPreconditionFailed);
                *pfHandled = TRUE;
                return S_OK;
            }
        }
    }

    *pfHandled = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\certcontext.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     certcontext.cxx

   Abstract:
     Simple wrapper of a certificate blob
 
   Author:
     Bilal Alam (balam)             5-Sept-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

HCRYPTPROV              CERTIFICATE_CONTEXT::sm_CryptProvider;
ALLOC_CACHE_HANDLER *   CERTIFICATE_CONTEXT::sm_pachCertContexts;

CERTIFICATE_CONTEXT::CERTIFICATE_CONTEXT(
    HTTP_SSL_CLIENT_CERT_INFO *       pClientCertInfo
) : _fCertDecoded( FALSE ),
    _pClientCertInfo( pClientCertInfo ),
    _buffCertInfo( (PBYTE) &_CertInfo, sizeof( _CertInfo ) )
{
    DBG_ASSERT( _pClientCertInfo != NULL );
}

CERTIFICATE_CONTEXT::~CERTIFICATE_CONTEXT(
    VOID
)
{
    _pClientCertInfo = NULL;
}

HRESULT
CERTIFICATE_CONTEXT::GetIssuer(
    STRA *                  pstrIssuer
)
/*++

Routine Description:

    Get the issuer of the client certificate

Arguments:

    pstrIssuer - Filled with issuer string

Return Value:

    HRESULT

--*/
{
    STACK_BUFFER  ( buffIssuer, 256 );
    HRESULT         hr;
    
    if ( pstrIssuer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    &(QueryCertInfo()->Issuer),
                    CERT_X500_NAME_STR,
                    (CHAR *) buffIssuer.QueryPtr(),
                    buffIssuer.QuerySize());

    return pstrIssuer->Copy( (CHAR *) buffIssuer.QueryPtr() );
}

HRESULT
CERTIFICATE_CONTEXT::GetFlags(
    STRA *                  pstrFlags
)
/*++

Routine Description:

    Get certificate validity flags for CERT_FLAGS

Arguments:

    pstrFlags - Filled with string representation of flags

Return Value:

    HRESULT

--*/
{
    CHAR *             pszNumber;

    if ( pstrFlags == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Bit 0 indicates whether a cert is available.  If this routine is 
    // being called, then it must be TRUE
    //

    pszNumber = "1";

    //
    // Bit 1 indicates whether the authority is trusted
    //

    if ( _pClientCertInfo->CertFlags & CERT_TRUST_IS_UNTRUSTED_ROOT )
    {
        pszNumber = "3";
    }

    return pstrFlags->Copy( pszNumber, 1 );
}

HRESULT
CERTIFICATE_CONTEXT::GetSerialNumber(
    STRA *                  pstrSerialNumber
)
/*++

Routine Description:

    Stringize the certificate's serial number for filling in the
    CERT_SERIAL_NUMBER

Arguments:

    pstrSerialNumber - Filled with serial number string

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    INT                     i;
    DWORD                   cbSerialNumber;
    PBYTE                   pbSerialNumber;
    CHAR                   achDigit[ 2 ] = { '\0', '\0' };

    if ( pstrSerialNumber == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    cbSerialNumber = QueryCertInfo()->SerialNumber.cbData;
    pbSerialNumber = QueryCertInfo()->SerialNumber.pbData;
    
    for ( i = cbSerialNumber-1; i >=0; i-- )
    {
        //
        // Just like IIS 5.0, we make the serial number in reverse byte order
        //
        
        achDigit[ 0 ] = HEX_DIGIT( ( pbSerialNumber[ i ] >> 4 ) );
        hr = pstrSerialNumber->Append( achDigit, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        achDigit[ 0 ] = HEX_DIGIT( ( pbSerialNumber[ i ] & 0xF ) );
        hr = pstrSerialNumber->Append( achDigit, 1 );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }   

        //
        // Do not append "-" after last digit of Serial Number
        //

        if( i != 0 )
        {
            
            hr = pstrSerialNumber->Append( "-", 1 ); 
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    
    return NO_ERROR;
}

HRESULT
CERTIFICATE_CONTEXT::DecodeCert(
    VOID
)
/*++

Routine Description:

    Decode client certificate into stuff needed to fill in some server 
    variables

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD                   cbBuffer;
    
    cbBuffer = _buffCertInfo.QuerySize();
        
    if ( !CryptDecodeObjectEx( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               X509_CERT_TO_BE_SIGNED,
                               _pClientCertInfo->pCertEncoded,
                               _pClientCertInfo->CertEncodedSize,
                               CRYPT_DECODE_NOCOPY_FLAG,
                               NULL,
                               _buffCertInfo.QueryPtr(),
                               &cbBuffer ) )
    {
        if ( GetLastError() == ERROR_MORE_DATA )
        {
            DBG_ASSERT( cbBuffer > _buffCertInfo.QuerySize() );
                
            if ( !_buffCertInfo.Resize( cbBuffer ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                
            if ( !CryptDecodeObjectEx( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                       X509_CERT_TO_BE_SIGNED,
                                       _pClientCertInfo->pCertEncoded,
                                       _pClientCertInfo->CertEncodedSize,
                                       CRYPT_DECODE_NOCOPY_FLAG,
                                       NULL,
                                       _buffCertInfo.QueryPtr(),
                                       &cbBuffer ) )
            {
                DBG_ASSERT( GetLastError() != ERROR_MORE_DATA );
                    
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        else
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    _fCertDecoded = TRUE;
    
    return NO_ERROR;
}

HRESULT
CERTIFICATE_CONTEXT::GetSubject(
    STRA *                  pstrSubject
)
/*++

Routine Description:

    Get subject string for cert

Arguments:

    pstrSubject - Filled with subject string

Return Value:

    HRESULT

--*/
{
    STACK_BUFFER ( buffIssuer, 256);
    HRESULT        hr;

    if ( pstrSubject == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    CertNameToStrA( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    &(QueryCertInfo()->Subject),
                    CERT_X500_NAME_STR,
                    (CHAR *) buffIssuer.QueryPtr(),
                    buffIssuer.QuerySize());

    return pstrSubject->Copy( (CHAR *) buffIssuer.QueryPtr() );
}

HRESULT
CERTIFICATE_CONTEXT::GetCookie(
    STRA *                  pstrCookie
)
/*++

Routine Description:

    CERT_COOKIE server variable

Arguments:

    pstrCookie - Filled with CERT_COOKIE

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    HCRYPTHASH          cryptHash;
    STACK_STRA(         strIssuer, 256 );
    DWORD               cbHashee;
    STACK_BUFFER      ( buffFinal, 256);
    BYTE *              pbFinal;
    DWORD               cbFinal;
    CHAR               achDigit[ 2 ] = { '\0', '\0' };
    
    if ( pstrCookie == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Decoding deferred until needed
    //
    
    if ( !_fCertDecoded )
    {
        hr = DecodeCert();
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( _fCertDecoded );
    }
    
    //
    // Cookie is MD5(<issuer string> <serial number in binary>)
    //
    
    hr = GetIssuer( &strIssuer );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Begin the hashing
    //
    
    if ( !CryptCreateHash( sm_CryptProvider,
                           CALG_MD5,
                           0,
                           0,
                           &cryptHash ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    if ( !CryptHashData( cryptHash,
                         (BYTE*) strIssuer.QueryStr(),
                         strIssuer.QueryCCH(),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    if ( !CryptHashData( cryptHash,
                         QueryCertInfo()->SerialNumber.pbData,
                         QueryCertInfo()->SerialNumber.cbData,
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    //
    // Get the final hash value
    //
    
    cbFinal = buffFinal.QuerySize();
        
    if ( !CryptGetHashParam( cryptHash,
                             HP_HASHVAL,
                             (BYTE*) buffFinal.QueryPtr(),
                             &cbFinal,
                             0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CryptDestroyHash( cryptHash );
        return hr;
    }
    
    CryptDestroyHash( cryptHash );
    
    //
    // Now ascii'ize the final hex string
    // 

    pbFinal = (BYTE*) buffFinal.QueryPtr();
    
    for ( DWORD i = 0; i < cbFinal; i++ )
    {
        achDigit[ 0 ] = HEX_DIGIT( ( pbFinal[ i ] & 0xF0 ) >> 4 );
        hr = pstrCookie->Append( achDigit, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
       
        achDigit[ 0 ] = HEX_DIGIT( ( pbFinal[ i ] & 0xF ) );
        hr = pstrCookie->Append( achDigit, 1 );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }     
    }
    
    return NO_ERROR;
}

//static
HRESULT
CERTIFICATE_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Do one time initialization of CRYPTO provider for doing MD5 hashes

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    if ( !CryptAcquireContext( &sm_CryptProvider,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    DBG_ASSERT( sm_CryptProvider != NULL );
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( CERTIFICATE_CONTEXT );

    DBG_ASSERT( sm_pachCertContexts == NULL );
    
    sm_pachCertContexts = new ALLOC_CACHE_HANDLER( "CERTIFICATE_CONTEXT",
                                                   &acConfig );
    if ( sm_pachCertContexts == NULL )
    {
        CryptReleaseContext( sm_CryptProvider, 0 );
        sm_CryptProvider = NULL;
        
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
CERTIFICATE_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachCertContexts != NULL )
    {
        delete sm_pachCertContexts;
        sm_pachCertContexts = NULL;
    }
    
    if ( sm_CryptProvider != NULL )
    {
        CryptReleaseContext( sm_CryptProvider, 0 );
        sm_CryptProvider = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\certmapprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     certmapprovider.cxx

   Abstract:
     Active Directory Certificate Mapper provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "certmapprovider.hxx"

HRESULT
CERTMAP_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does certificate map authentication apply? 

Arguments:

    pMainContext - Main context
    pfApplies - Set to TRUE if cert map auth applies

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *           pCertificateContext;
    URL_CONTEXT *                   pUrlContext = NULL;
    W3_METADATA *                   pMetaData = NULL;
    BOOL                            fApplies = FALSE;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If cert mapping is not allowed for this vroot, then ignore client
    // cert token and let other authentication mechanisms do their thing
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    DBG_ASSERT( pMainContext->QuerySite() );
    
    if ( !pMainContext->QuerySite()->QueryUseDSMapper() )
    {
        fApplies = FALSE;
    }
    else if ( pMetaData->QuerySslAccessPerms() & VROOT_MASK_MAP_CERT )
    {
        pCertificateContext = pMainContext->QueryCertificateContext();
        if ( pCertificateContext != NULL )
        {
            if ( pCertificateContext->QueryImpersonationToken() != NULL )
            {
                fApplies = TRUE;
            }
        }
    }
    
    *pfApplies = fApplies;
    
    return NO_ERROR;
}

HRESULT
CERTMAP_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Routine Description:

    Create a user context representing a cert mapped token

Arguments:

    pMainContext - Main context

Return Value:

    HRESULT

--*/
{
    CERTMAP_USER_CONTEXT *          pUserContext = NULL;
    CERTIFICATE_CONTEXT *           pCertificateContext = NULL;
    HANDLE                          hImpersonation;
    BOOL                            fDelegatable = FALSE;
    HRESULT                         hr = NO_ERROR;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pCertificateContext = pMainContext->QueryCertificateContext();
    DBG_ASSERT( pCertificateContext != NULL );

    hImpersonation = pCertificateContext->QueryImpersonationToken();
    DBG_ASSERT( hImpersonation != NULL );
   
    //
    // Create the user context for this request
    //
    
    pUserContext = new CERTMAP_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Is this a delegatable token?  Put another way is this token mapped
    // using an IIS cert mapper (IIS cert mapper creates delegatable token,
    // the DS mapper does not)
    //
    
    fDelegatable = FALSE;
    
    hr = pUserContext->Create( hImpersonation, fDelegatable );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        return hr;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR;
}

HRESULT
CERTMAP_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *               pMainContext
)
/*++

Routine Description:

    NOP since we have nothing to do on access denied

Arguments:

    pMainContext - Main context

Return Value:

    HRESULT

--*/
{
    //
    // No headers to add
    //
    
    return NO_ERROR;
}

HRESULT
CERTMAP_USER_CONTEXT::Create(
    HANDLE                  hImpersonation,
    BOOL                    fDelegatable
)
/*++

Routine Description:

    Create a certificate mapped user context

Arguments:

    hImpersonation - Impersonation token
    fDelegatable - Is this token delegatable?

Return Value:

    HRESULT

--*/
{
    DWORD       cchUserName = sizeof( _achUserName ) / sizeof( WCHAR );
    
    if ( hImpersonation == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the easy stuff
    //
    
    _fDelegatable = fDelegatable;
    
    _hImpersonationToken = hImpersonation;

    //
    // Now get the user name
    //
    
    if ( !SetThreadToken( NULL, _hImpersonationToken ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    if ( !GetUserNameEx( NameSamCompatible,
                         _achUserName,
                         &cchUserName ) )
    {
        RevertToSelf();
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    RevertToSelf();
    
    return NO_ERROR;
}

HANDLE
CERTMAP_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get a primary token

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }
    }
    
    return _hPrimaryToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cgi_handler.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     cgi_handler.cxx

   Abstract:
     Handle CGI requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "cgi_handler.h"

//
// W3_CGI_HANDLER statics
//

BOOL             W3_CGI_HANDLER::sm_fAllowSpecialCharsInShell = FALSE;
BOOL             W3_CGI_HANDLER::sm_fForwardServerEnvironmentBlock = FALSE;
WCHAR *          W3_CGI_HANDLER::sm_pEnvString = NULL;
DWORD            W3_CGI_HANDLER::sm_cchEnvLength = 0;
LIST_ENTRY       W3_CGI_HANDLER::sm_CgiListHead;
CRITICAL_SECTION W3_CGI_HANDLER::sm_CgiListLock;
WCHAR            W3_CGI_HANDLER::sm_achStdinPipeName[ PIPENAME_SIZE ];
WCHAR            W3_CGI_HANDLER::sm_achStdoutPipeName[ PIPENAME_SIZE ];
HANDLE           W3_CGI_HANDLER::sm_hPreCreatedStdOut = INVALID_HANDLE_VALUE;
HANDLE           W3_CGI_HANDLER::sm_hPreCreatedStdIn = INVALID_HANDLE_VALUE;


//
//  Environment variable block used for CGI
//
LPSTR g_CGIServerVars[] =
{
    {"ALL_HTTP"},
    // Means insert all HTTP_ headers here
    {"APP_POOL_ID"},
    {"AUTH_TYPE"},
    {"AUTH_PASSWORD"},
    {"AUTH_USER"},
    {"CERT_COOKIE"},
    {"CERT_FLAGS"},
    {"CERT_ISSUER"},
    {"CERT_SERIALNUMBER"},
    {"CERT_SUBJECT"},
    {"CONTENT_LENGTH"},
    {"CONTENT_TYPE"},
    {"GATEWAY_INTERFACE"},
    {"HTTPS"},
    {"HTTPS_KEYSIZE"},
    {"HTTPS_SECRETKEYSIZE"},
    {"HTTPS_SERVER_ISSUER"},
    {"HTTPS_SERVER_SUBJECT"},
    {"INSTANCE_ID"},
    {"LOCAL_ADDR"},
    {"LOGON_USER"},
    {"PATH_INFO"},
    {"PATH_TRANSLATED"},
    {"QUERY_STRING"},
    {"REMOTE_ADDR"},
    {"REMOTE_HOST"},
    {"REMOTE_USER"},
    {"REQUEST_METHOD"},
    {"SCRIPT_NAME"},
    {"SERVER_NAME"},
    {"SERVER_PORT"},
    {"SERVER_PORT_SECURE"},
    {"SERVER_PROTOCOL"},
    {"SERVER_SOFTWARE"},
    {"UNMAPPED_REMOTE_USER"},
    {NULL}
};


// static
HRESULT W3_CGI_HANDLER::Initialize()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::Initialize() called\n"));

    //
    // Read some CGI configuration from the registry
    //
    HRESULT hr;

    INITIALIZE_CRITICAL_SECTION(&sm_CgiListLock);
    InitializeListHead(&sm_CgiListHead);

    HKEY w3Params;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     W3_PARAMETERS_KEY,
                     0,
                     KEY_READ,
                     &w3Params) == NO_ERROR)
    {
        DWORD dwType;
        DWORD cbData = sizeof BOOL;
        if ((RegQueryValueEx(w3Params,
                             L"AllowSpecialCharsInShell",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_fAllowSpecialCharsInShell,
                             &cbData) != NO_ERROR) ||
            (dwType != REG_DWORD))
        {
            sm_fAllowSpecialCharsInShell = FALSE;
        }

        cbData = sizeof BOOL;
        if ((RegQueryValueEx(w3Params,
                             L"ForwardServerEnvironmentBlock",
                             NULL,
                             &dwType,
                             (LPBYTE)&sm_fForwardServerEnvironmentBlock,
                             &cbData) != NO_ERROR) ||
            (dwType != REG_DWORD))
        {
            sm_fForwardServerEnvironmentBlock = TRUE;
        }

        RegCloseKey( w3Params);
    }

    //
    // Read the environment
    //
    if (sm_fForwardServerEnvironmentBlock)
    {
        WCHAR *EnvString;
        if (!(EnvString = GetEnvironmentStrings()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBGPRINTF((DBG_CONTEXT, "GetEnvironmentStrings failed\n"));
            goto Exit;
        }

        //
        // Compute length of environment block (excluding block delimiter)
        //

        DWORD length;
        sm_cchEnvLength = 0;
        while (length = wcslen(EnvString + sm_cchEnvLength))
        {
            sm_cchEnvLength += length + 1;
        }

        //
        // store it
        //
        if ((sm_pEnvString = new WCHAR[sm_cchEnvLength]) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            FreeEnvironmentStrings(EnvString);
            goto Exit;
        }

        memcpy(sm_pEnvString,
               EnvString,
               sm_cchEnvLength * sizeof(WCHAR));

        FreeEnvironmentStrings(EnvString);
    }

    //
    // Set up unique pipe names
    // BUGBUG: actually open an instance of the pipe to make sure it cannot
    // be hijacked
    //
    WCHAR pszPid[16];
    DWORD dwPid = GetCurrentProcessId();
    _itow(dwPid, pszPid, 10);
    
    wcscpy( sm_achStdinPipeName, L"\\\\.\\pipe\\IISCgiStdIn" );
    wcscat( sm_achStdinPipeName, pszPid );
    
    wcscpy( sm_achStdoutPipeName, L"\\\\.\\pipe\\IISCgiStdOut");
    wcscat( sm_achStdoutPipeName, pszPid );

    //
    // Pre-create an instance of the pipe to make sure no-one hijacks it
    //
    STARTUPINFO startupinfo;
    if (FAILED(hr = SetupChildPipes(&sm_hPreCreatedStdOut,
                                    &sm_hPreCreatedStdIn,
                                    &startupinfo,
                                    TRUE)))
    {
        g_pW3Server->LogEvent(W3_EVENT_FAIL_PIPE_CREATION,
                              0,
                              NULL);

        goto Exit;
    }
    DBG_REQUIRE(CloseHandle(startupinfo.hStdOutput));
    DBG_REQUIRE(CloseHandle(startupinfo.hStdInput));

    return S_OK;

 Exit:
    DBG_ASSERT(FAILED(hr));

    //
    // Cleanup partially created stuff
    //
    Terminate();

    return hr;
}

W3_CGI_HANDLER::~W3_CGI_HANDLER()
{
    //
    // Close all open handles related to this request
    //
    EnterCriticalSection(&sm_CgiListLock);
    RemoveEntryList(&m_CgiListEntry);
    LeaveCriticalSection(&sm_CgiListLock);

    if (m_hTimer)
    {
        if (!DeleteTimerQueueTimer(NULL,
                                   m_hTimer,
                                   INVALID_HANDLE_VALUE))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "DeleteTimerQueueTimer failed, %d\n",
                       GetLastError()));
        }
        m_hTimer = NULL;
    }

    if (m_hStdOut != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(m_hStdOut))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CloseHandle failed on StdOut, %d\n",
                       GetLastError()));
        }
        m_hStdOut = INVALID_HANDLE_VALUE;
    }

    if (m_hStdIn != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(m_hStdIn))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CloseHandle failed on StdIn, %d\n",
                       GetLastError()));
        }
        m_hStdIn = INVALID_HANDLE_VALUE;
    }

    if (m_hProcess)
    {
        //
        // Just in case it is still running
        //
        TerminateProcess(m_hProcess, 0);

        if (!CloseHandle(m_hProcess))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CloseHandle failed on Process, %d\n",
                       GetLastError()));
        }
        m_hProcess = NULL;
    }
}

VOID CALLBACK W3_CGI_HANDLER::OnPipeIoCompletion(
                                  DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransfered,
                                  LPOVERLAPPED lpOverlapped)
{
    if (dwErrorCode && dwErrorCode != ERROR_BROKEN_PIPE)
    {
        DBGPRINTF((DBG_CONTEXT, "Error %d on CGI_HANDLER::OnPipeIoCompletion\n", dwErrorCode));
    }

    HRESULT hr = S_OK;
    BOOL    fIsCgiError = TRUE;

    W3_CGI_HANDLER *pHandler = CONTAINING_RECORD(lpOverlapped,
                                                 W3_CGI_HANDLER,
                                                 m_Overlapped);

    if (dwErrorCode ||
        (dwNumberOfBytesTransfered == 0))
    {
        if (pHandler->m_dwRequestState & CGI_STATE_READING_REQUEST_ENTITY)
        {
            //
            // If we could not write the request entity, for example because
            // the CGI did not wait to read the entity, ignore the error and
            // continue on to reading the output
            //

            //
            // If this is an nph cgi, we do not parse header
            //
            if (pHandler->QueryIsNphCgi())
            {
                pHandler->m_dwRequestState = CGI_STATE_READING_RESPONSE_ENTITY;
            }
            else
            {
                pHandler->m_dwRequestState = CGI_STATE_READING_RESPONSE_HEADERS;
            }
            pHandler->m_cbData = 0;

            if (SUCCEEDED(hr = pHandler->CGIReadCGIOutput()))
            {
                return;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErrorCode);
        }

        fIsCgiError = TRUE;
        goto ErrorExit;
    }

    if (pHandler->m_dwRequestState & CGI_STATE_READING_RESPONSE_HEADERS)
    {
        //
        // Copy the headers to the header buffer to be parsed when we have
        // all the headers
        //
        if (!pHandler->m_bufResponseHeaders.Resize(
                 pHandler->m_cbData + dwNumberOfBytesTransfered + 1))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        memcpy((LPSTR)pHandler->m_bufResponseHeaders.QueryPtr() +
                   pHandler->m_cbData,
               pHandler->m_DataBuffer,
               dwNumberOfBytesTransfered);

        pHandler->m_cbData += dwNumberOfBytesTransfered;

        ((LPSTR)pHandler->m_bufResponseHeaders.QueryPtr())[pHandler->m_cbData] = '\0';
    }
    else if (pHandler->m_dwRequestState & CGI_STATE_READING_RESPONSE_ENTITY)
    {
        pHandler->m_cbData = dwNumberOfBytesTransfered;
    }

    if (FAILED(hr = pHandler->CGIContinueOnPipeCompletion(&fIsCgiError)))
    {
        goto ErrorExit;
    }

    return;

 ErrorExit:
    pHandler->QueryW3Context()->SetErrorStatus(hr);

    //
    // If the error happened due to an CGI problem, mark it as 502
    // appropriately
    //
    if (fIsCgiError)
    {
        if (!(pHandler->m_dwRequestState & CGI_STATE_READING_RESPONSE_ENTITY))
        {
            pHandler->QueryW3Context()->QueryResponse()->Clear();

            DWORD dwExitCode;
            if (GetExitCodeProcess(pHandler->m_hProcess,
                                   &dwExitCode) &&
                dwExitCode == CGI_PREMATURE_DEATH_CODE)
            {
                STACK_STRU( strUrl, 128);
                STACK_STRU( strQuery, 128);
                if (SUCCEEDED(pHandler->QueryW3Context()->QueryRequest()->GetUrl(&strUrl)) &&
                    SUCCEEDED(pHandler->QueryW3Context()->QueryRequest()->GetQueryString(&strQuery)))
                {
                    LPCWSTR apsz[2];
                    apsz[0] = strUrl.QueryStr();
                    apsz[1] = strQuery.QueryStr();

                    g_pW3Server->LogEvent(W3_EVENT_KILLING_SCRIPT,
                                          2,
                                          apsz);
                }

                pHandler->QueryW3Context()->QueryResponse()->SetStatus(
                    HttpStatusBadGateway,
                    Http502Timeout);
            }
            else
            {
                pHandler->QueryW3Context()->QueryResponse()->SetStatus(
                    HttpStatusBadGateway,
                    Http502PrematureExit);
            }
        }
    }
    else
    {
        pHandler->QueryW3Context()->QueryResponse()->SetStatus(
            HttpStatusBadRequest);
    }

    pHandler->m_dwRequestState |= CGI_STATE_DONE_WITH_REQUEST;

    ThreadPoolPostCompletion(
        0,
        W3_MAIN_CONTEXT::OnPostedCompletion,
        (LPOVERLAPPED)pHandler->QueryW3Context()->QueryMainContext());
}

// static
HRESULT W3_CGI_HANDLER::SetupChildPipes(
    HANDLE *phStdOut,
    HANDLE *phStdIn,
    STARTUPINFO *pstartupinfo,
    BOOL fFirstInstance)
/*++
  Synopsis
    Setup the pipes to use for communicating with the child process

  Arguments
    pstartupinfo: this will be populated with the startinfo that can be
      passed to a CreateProcess call

  Return Value
    HRESULT
--*/
{
    DBG_ASSERT(phStdOut != NULL);
    DBG_ASSERT(phStdIn != NULL);
    DBG_ASSERT(pstartupinfo != NULL);

    SECURITY_ATTRIBUTES sa;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = TRUE;

    pstartupinfo->hStdOutput = INVALID_HANDLE_VALUE;
    pstartupinfo->hStdInput = INVALID_HANDLE_VALUE;
    pstartupinfo->dwFlags = STARTF_USESTDHANDLES;

    //
    // Synchronize so that the wrong instance of the server end of the pipe
    // is not connected to the wrong instance of the client end
    //
    EnterCriticalSection(&sm_CgiListLock);
    HRESULT hr = S_OK;

    *phStdOut = CreateNamedPipe(sm_achStdoutPipeName,
                                PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED | (fFirstInstance ? FILE_FLAG_FIRST_PIPE_INSTANCE : 0),
                                0,
                                PIPE_UNLIMITED_INSTANCES,
                                MAX_CGI_BUFFERING,
                                MAX_CGI_BUFFERING,
                                INFINITE,
                                NULL);
    if (*phStdOut == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    if (!ThreadPoolBindIoCompletionCallback(*phStdOut,
                                            OnPipeIoCompletion,
                                            0))
    {
        DBGPRINTF((DBG_CONTEXT, "ThreadPoolBindIo failed\n"));
        hr = E_FAIL;
        goto ErrorExit;
    }
    pstartupinfo->hStdOutput = CreateFile(sm_achStdoutPipeName,
                                          GENERIC_WRITE,
                                          0,
                                          &sa,
                                          OPEN_EXISTING,
                                          FILE_FLAG_OVERLAPPED,
                                          NULL);
    if (pstartupinfo->hStdOutput == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    DBG_ASSERT(!ConnectNamedPipe(*phStdOut, NULL));
    DBG_ASSERT(GetLastError() == ERROR_PIPE_CONNECTED);

    *phStdIn = CreateNamedPipe(sm_achStdinPipeName,
                                PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED | (fFirstInstance ? FILE_FLAG_FIRST_PIPE_INSTANCE : 0),
                               0,
                               PIPE_UNLIMITED_INSTANCES,
                               MAX_CGI_BUFFERING,
                               MAX_CGI_BUFFERING,
                               INFINITE,
                               NULL);
    if (*phStdIn == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    if (!ThreadPoolBindIoCompletionCallback(*phStdIn,
                                            OnPipeIoCompletion,
                                            0))
    {
        DBGPRINTF((DBG_CONTEXT, "ThreadPoolBindIo failed\n"));
        hr = E_FAIL;
        goto ErrorExit;
    }
    pstartupinfo->hStdInput = CreateFile(sm_achStdinPipeName,
                                         GENERIC_READ,
                                         0,
                                         &sa,
                                         OPEN_EXISTING,
                                         FILE_FLAG_OVERLAPPED,
                                         NULL);
    if (pstartupinfo->hStdInput == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    DBG_ASSERT(!ConnectNamedPipe(*phStdIn, NULL));
    DBG_ASSERT(GetLastError() == ERROR_PIPE_CONNECTED);

    //
    //  Stdout and Stderror will use the same pipe.
    //
    pstartupinfo->hStdError = pstartupinfo->hStdOutput;

    LeaveCriticalSection(&sm_CgiListLock);
    return S_OK;

ErrorExit:
    DBGPRINTF((DBG_CONTEXT, "SetupChildPipes Failed, hr %x\n", hr));

    //
    // Need to close these now so that other instances do not connect to it
    //
    if (pstartupinfo->hStdOutput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(pstartupinfo->hStdOutput));
        pstartupinfo->hStdOutput = INVALID_HANDLE_VALUE;
    }

    if (pstartupinfo->hStdInput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(pstartupinfo->hStdInput));
        pstartupinfo->hStdInput = INVALID_HANDLE_VALUE;
    }

    if (*phStdOut != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(*phStdOut));
        *phStdOut = INVALID_HANDLE_VALUE;
    }

    if (*phStdIn != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(*phStdIn));
        *phStdIn = INVALID_HANDLE_VALUE;
    }

    LeaveCriticalSection(&sm_CgiListLock);
    return hr;
}


BOOL IsCmdExe(const WCHAR *pchPath)
/*++
  Tells whether the CGI call is for a cmd shell
--*/
{
    LPWSTR pszcmdExe = wcsstr(pchPath, L"cmd.exe");
    if ((pszcmdExe != NULL) &&
        (pszcmdExe[7] != L'\\'))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL IsNphCgi(const WCHAR *pszUrl)
/*++
  Tells whether the URL is for an nph cgi script
--*/
{
    LPWSTR pszLastSlash = wcsrchr(pszUrl, L'/');
    if (pszLastSlash != NULL)
    {
        if (_wcsnicmp(pszLastSlash + 1, L"nph-", 4) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT SetupCmdLine(W3_REQUEST *pRequest,
                     STRU *pstrCmdLine)
{
    STACK_STRU (queryString, MAX_PATH);
    HRESULT hr = S_OK;
    if (FAILED(hr = pRequest->GetQueryString(&queryString)))
    {
        return hr;
    }

    //
    // If there is no QueryString OR if an unencoded "=" is found, don't
    // append QueryString to the command line according to spec
    //

    if ((!queryString.QueryCCH()) ||
        wcschr(queryString.QueryStr(), L'='))
    {
        return S_OK;
    }

    queryString.Unescape();

    return pstrCmdLine->Append(queryString);
} // SetupCmdLine


HRESULT SetupWorkingDir(STRU *pstrPhysical,
                        STRU *pstrWorkingDir)
{
    LPWSTR dirDelimiter = wcsrchr(pstrPhysical->QueryStr(), L'\\');

    if (dirDelimiter == NULL)
    {
        return pstrWorkingDir->Copy(L"");
    }
    else
    {
        return pstrWorkingDir->Copy(pstrPhysical->QueryStr(),
                   DIFF(dirDelimiter - pstrPhysical->QueryStr()) + 1);
    }
}


HRESULT 
W3_CGI_HANDLER::SetupChildEnv(OUT BUFFER *pBuff)
{
    //
    // Build the environment block for CGI
    //

    DWORD cchCurrentPos = 0;

    //
    // Copy the environment variables
    //
    
    if (sm_fForwardServerEnvironmentBlock)
    {
        if (!pBuff->Resize(sm_cchEnvLength * sizeof(WCHAR), 512))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        
        memcpy(pBuff->QueryPtr(),
               sm_pEnvString,
               sm_cchEnvLength * sizeof(WCHAR));
               
        cchCurrentPos = sm_cchEnvLength;
    }

    CHAR * pszName;
    STACK_STRU (strVal, 512);
    STACK_STRU (struName, 32);
    for (int i = 0; pszName = g_CGIServerVars[i]; i++)
    {
        HRESULT hr;
        if (FAILED(hr = SERVER_VARIABLE_HASH::GetServerVariableW(
                            QueryW3Context(), 
                            pszName,
                            &strVal)))
        {
            return hr;
        }

        DWORD cchName = strlen(pszName);
        DWORD cchValue = strVal.QueryCCH();

        //
        //  We need space for the terminating '\0' and the '='
        //

        DWORD cbNeeded = (cchName + cchValue + 1 + 1) * sizeof(WCHAR);

        if (!pBuff->Resize(cchCurrentPos * sizeof(WCHAR) + cbNeeded,
                           512))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        WCHAR * pchtmp = (WCHAR *)pBuff->QueryPtr();
        if (strcmp(pszName, "ALL_HTTP") == 0)
        {
            //
            // ALL_HTTP means we're adding all of the HTTP_ header
            // fields which requires a little bit of special processing
            //

            memcpy(pchtmp + cchCurrentPos,
                   strVal.QueryStr(),
                   (cchValue + 1) * sizeof(WCHAR));

            WCHAR * pszColonPosition = wcschr(pchtmp + cchCurrentPos, L':');
            WCHAR * pszNewLinePosition;

            //
            // Convert the Name:Value\n entries to Name=Value\0 entries
            // for the environment table
            //

            while (pszColonPosition != NULL)
            {
                *pszColonPosition = L'=';

                pszNewLinePosition = wcschr(pszColonPosition + 1, L'\n');

                DBG_ASSERT(pszNewLinePosition != NULL);

                *pszNewLinePosition = L'\0';

                pszColonPosition = wcschr(pszNewLinePosition + 1, L':');
            }

            cchCurrentPos += cchValue;
        }
        else
        {
            //
            // Normal ServerVariable, add it
            //
            if (FAILED(hr = struName.CopyA(pszName,
                                           cchName)))
            {
                return hr;
            }

            memcpy(pchtmp + cchCurrentPos,
                   struName.QueryStr(),
                   cchName * sizeof(WCHAR));

            *(pchtmp + cchCurrentPos + cchName) = L'=';

            memcpy(pchtmp + cchCurrentPos + cchName + 1,
                   strVal.QueryStr(),
                   (cchValue + 1) * sizeof(WCHAR));

            cchCurrentPos += cchName + cchValue + 1 + 1;
        }
    }

    //
    //  Add an extra null terminator to the environment list
    //

    if (!pBuff->Resize((cchCurrentPos + 1) * sizeof(WCHAR)))
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    *((WCHAR *)pBuff->QueryPtr() + cchCurrentPos) = L'\0';

    return S_OK;
}


VOID CALLBACK W3_CGI_HANDLER::CGITerminateProcess(PVOID pContext,
                                                  BOOLEAN)
/*++

Routine Description:

    This function is the callback called by the scheduler thread after the
    specified timeout period has elapsed.

Arguments:

    pContext - Handle of process to kill

--*/
{
    W3_CGI_HANDLER *pHandler = reinterpret_cast<W3_CGI_HANDLER *>(pContext);

    if (pHandler->m_hProcess &&
        !TerminateProcess(pHandler->m_hProcess, CGI_PREMATURE_DEATH_CODE))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - TerminateProcess failed, error %d\n",
                   GetLastError()));
    }

    if (pHandler->m_hStdIn != INVALID_HANDLE_VALUE &&
        !DisconnectNamedPipe(pHandler->m_hStdIn))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - DisconnectNamedPipe failed, error %d\n",
                   GetLastError()));
    }

    if (pHandler->m_hStdOut != INVALID_HANDLE_VALUE &&
        !DisconnectNamedPipe(pHandler->m_hStdOut))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CGITerminateProcess - DisconnectNamedPipe failed, error %d\n",
                   GetLastError()));
    }
} // CGITerminateProcess


BOOL CheckForEndofHeaders(IN LPSTR pbuff,
                          IN int cbData,
                          OUT DWORD *pcbIndexStartOfData)
{
    //
    // If the response starts with a newline (\n, \r\n or \r\r\n), then,
    // no headers present, it is all data
    //
    if (pbuff[0] == '\n')
    {
        *pcbIndexStartOfData = 1;
        return TRUE;
    }
    if ((pbuff[0] == '\r') && (pbuff[1] == '\n'))
    {
        *pcbIndexStartOfData = 2;
        return TRUE;
    }
    if ((pbuff[0] == '\r') && (pbuff[1] == '\r') && (pbuff[2] == '\n'))
    {
        *pcbIndexStartOfData = 3;
        return TRUE;
    }

    //
    // Look for two consecutive newline, \n\r\r\n, \n\r\n or \n\n
    // No problem with running beyond the end of buffer as the buffer is
    // null terminated
    //
    int index;
    for (index = 0; index < cbData - 1; index++)
    {
        if (pbuff[index] == '\n')
        {
            if (pbuff[index + 1] == '\n')
            {
                *pcbIndexStartOfData = index + 2;
                return TRUE;
            }
            else if (pbuff[index + 1] == '\r')
            {
                if (pbuff[index + 2] == '\n')
                {
                    *pcbIndexStartOfData = index + 3;
                    return TRUE;
                }
                else if ((pbuff[index + 2] == '\r') &&
                         (pbuff[index + 3] == '\n'))
                {
                    *pcbIndexStartOfData = index + 4;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


HRESULT 
W3_CGI_HANDLER::ProcessCGIOutput()
/*++
  Synopsis
    This function parses the CGI output and seperates out the headers and
    interprets them as appropriate

  Return Value
    HRESULT
--*/
{
    W3_REQUEST  *pRequest  = QueryW3Context()->QueryRequest();
    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    HRESULT      hr        = S_OK;
    STACK_STRA (strReason, 32);
    DWORD       index = 0;
    BOOL        fCanKeepConn = FALSE;

    //
    //  The end of CGI headers are marked by a blank line, check to see if
    //  we've hit that line.
    //
    LPSTR Headers = (LPSTR)m_bufResponseHeaders.QueryPtr();
    DWORD cbIndexStartOfData;
    if (!CheckForEndofHeaders(Headers,
                              m_cbData,
                              &cbIndexStartOfData))
    {
        return CGIReadCGIOutput();
    }

    m_dwRequestState = CGI_STATE_READING_RESPONSE_ENTITY;
    //
    // We've found the end of the headers, process them
    //
    // if request header contains:
    //
    //    Location: xxxx - if starts with /, send doc, otherwise send
    //       redirect message
    //    URI: preferred synonym to Location:
    //    Status: nnn xxxx - Send as status code (HTTP/1.1 nnn xxxx)
    //

    //
    // The first line in the response could (optionally) look like
    // HTTP/n.n nnn xxxx\r\n
    //
    if (!strncmp(Headers, "HTTP/", 5))
    {
        USHORT statusCode;
        LPSTR pszSpace;
        LPSTR pszNewline;
        if ((pszNewline = strchr(Headers, '\n')) == NULL)
        {
            goto ErrorExit;
        }
        index = DIFF(pszNewline - Headers) + 1;
        if (pszNewline[-1] == '\r')
            pszNewline--;


        if (((pszSpace = strchr(Headers, ' ')) == NULL) ||
            (pszSpace >= pszNewline))
        {
            goto ErrorExit;
        }
        while (pszSpace[0] == ' ')
            pszSpace++;
        statusCode = (USHORT) atoi(pszSpace);

        //
        // UL only allows status codes upto 999, so reject others
        //
        if (statusCode > 999)
        {
            goto ErrorExit;
        }

        if (((pszSpace = strchr(pszSpace, ' ')) == NULL) ||
            (pszSpace >= pszNewline))
        {
            goto ErrorExit;
        }
        while (pszSpace[0] == ' ')
            pszSpace++;

        if (FAILED(hr = strReason.Copy(pszSpace,
                            DIFF(pszNewline - pszSpace))) ||
            FAILED(hr = pResponse->SetStatus(statusCode, strReason)))
        {
            goto ErrorExit;
        }
        
        if (pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode)
        {
            pResponse->SetStatus(HttpStatusUnauthorized,
                                 Http401Application);
        }
    }
        
    while ((index + 3) < cbIndexStartOfData)
    {
        //
        // Find the ':' in Header : Value\r\n
        //
        LPSTR pchColon = strchr(Headers + index, ':');

        //
        // Find the '\n' in Header : Value\r\n
        //
        LPSTR pchNewline = strchr(Headers + index, '\n');

        //
        // Take care of header continuation
        //
        while (pchNewline[1] == ' ' ||
               pchNewline[1] == '\t')
        {
            pchNewline = strchr(pchNewline + 1, '\n');
        }

        if ((pchColon == NULL) ||
            (pchColon >= pchNewline))
        {
            goto ErrorExit;
        }

        //
        // Skip over any spaces before the ':'
        //
        LPSTR pchEndofHeaderName;
        for (pchEndofHeaderName = pchColon - 1;
             (pchEndofHeaderName >= Headers + index) &&
                 (*pchEndofHeaderName == ' ');
             pchEndofHeaderName--)
        {}

        //
        // Copy the header name
        //
        STACK_STRA (strHeaderName, 32);
        if (FAILED(hr = strHeaderName.Copy(Headers + index,
                            DIFF(pchEndofHeaderName - Headers) - index + 1)))
        {
            goto ErrorExit;
        }

        //
        // Skip over the ':' and any trailing spaces
        //
        for (index = DIFF(pchColon - Headers) + 1;
             Headers[index] == ' ';
             index++)
        {}

        //
        // Skip over any spaces before the '\n'
        //
        LPSTR pchEndofHeaderValue;
        for (pchEndofHeaderValue = pchNewline - 1;
             (pchEndofHeaderValue >= Headers + index) &&
                 ((*pchEndofHeaderValue == ' ') ||
                  (*pchEndofHeaderValue == '\r'));
             pchEndofHeaderValue--)
        {}

        //
        // Copy the header value
        //
        STACK_STRA (strHeaderValue, 32);
        if (FAILED(hr = strHeaderValue.Copy(Headers + index,
                            DIFF(pchEndofHeaderValue - Headers) - index + 1)))
        {
            goto ErrorExit;
        }

        if (!_stricmp("Status", strHeaderName.QueryStr()))
        {
            USHORT statusCode = (USHORT) atoi(strHeaderValue.QueryStr());

            //
            // UL only allows status codes upto 999, so reject others
            //
            if (statusCode > 999)
            {
                goto ErrorExit;
            }

            CHAR * pchReason = strchr(strHeaderValue.QueryStr(), ' ');
            if (pchReason != NULL)
            {
                pchReason++;
                if (FAILED(hr = strReason.Copy(pchReason)) ||
                    FAILED(hr = pResponse->SetStatus(statusCode, strReason)))
                {
                    goto ErrorExit;
                }

                if (pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode)
                {
                    pResponse->SetStatus(HttpStatusUnauthorized,
                                         Http401Application);
                }
            }
        }
        else if (!_stricmp("Location", strHeaderName.QueryStr()) ||
                 !_stricmp("URI", strHeaderName.QueryStr()))
        {
            //
            // The CGI script is redirecting us to another URL.  If it
            // begins with a '/', then get it, otherwise send a redirect
            // message
            //

            m_dwRequestState = CGI_STATE_DONE_WITH_REQUEST |
                CGI_STATE_RESPONSE_REDIRECTED;

            if (strHeaderValue.QueryStr()[0] == '/')
            {
                //
                // Execute a child request
                //
                pResponse->Clear();
                pResponse->SetStatus(HttpStatusOk);
                
                if (FAILED(hr = pRequest->SetUrlA(strHeaderValue)) ||
                    FAILED(hr = QueryW3Context()->ExecuteChildRequest(
                                    pRequest,
                                    FALSE,
                                    W3_FLAG_ASYNC )))
                {
                    return hr;
                }
                
                return S_OK;
            }
            else 
            {
                HTTP_STATUS httpStatus;
                pResponse->GetStatus(&httpStatus);

                //
                // Plain old redirect since this was not a "local" URL
                // If the CGI had already set the status to some 3xx value,
                // honor it
                //
                
                if (FAILED(hr = QueryW3Context()->SetupHttpRedirect(
                                    strHeaderValue,
                                    FALSE,
                                    ((httpStatus.statusCode / 100) == 3) ? httpStatus : HttpStatusRedirect)))
                {
                    return hr;
                }
            }
        }
        else
        {
            //
            // Remember the Content-Length the cgi specified
            //

            if (!_stricmp("Content-Length", strHeaderName.QueryStr()))
            {
                fCanKeepConn = TRUE;
                m_bytesToSend = atoi(strHeaderValue.QueryStr());
            }
            else if (!_stricmp("Transfer-Encoding", strHeaderName.QueryStr()) &&
                     !_stricmp("chunked", strHeaderValue.QueryStr()))
            {
                fCanKeepConn = TRUE;
            }
            else if (!_stricmp("Connection", strHeaderName.QueryStr()) &&
                     !_stricmp("close", strHeaderValue.QueryStr()))
            {
                QueryW3Context()->SetDisconnect(TRUE);
            }

            //
            //  Copy any other fields the script specified
            //
            pResponse->SetHeader(strHeaderName.QueryStr(),
                                 strHeaderName.QueryCCH(),
                                 strHeaderValue.QueryStr(),
                                 strHeaderValue.QueryCCH());
        }

        index = DIFF(pchNewline - Headers) + 1;
    } // while

    if (m_dwRequestState & CGI_STATE_RESPONSE_REDIRECTED) 
    {
        return QueryW3Context()->SendResponse(W3_FLAG_ASYNC);
    }

    //
    // Now send any data trailing the headers
    //
    if (cbIndexStartOfData < m_cbData)
    {
        if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                            Headers + cbIndexStartOfData,
                            m_cbData - cbIndexStartOfData)))
        {
            return hr;
        }

        if ((m_bytesToSend -=
             m_cbData - cbIndexStartOfData) <= 0)
            m_dwRequestState |= CGI_STATE_DONE_WITH_REQUEST;
    }

    //
    // If the CGI did not say how much data was present, mark the
    // connection for closing
    //
    if (!fCanKeepConn)
    {
        QueryW3Context()->SetDisconnect(TRUE);
    }
    return QueryW3Context()->SendResponse(W3_FLAG_ASYNC | W3_FLAG_MORE_DATA);

 ErrorExit:
    m_dwRequestState = CGI_STATE_READING_RESPONSE_HEADERS;
    if (FAILED(hr))
    {
        return hr;
    }

    return E_FAIL;
}

HRESULT W3_CGI_HANDLER::CGIReadRequestEntity(BOOL *pfIoPending)
/*++
  Synopsis

    This function reads the next chunk of request entity

  Arguments

    pfIoPending: On return indicates if there is an I/O pending

  Return Value
    HRESULT
--*/
{
    if (m_bytesToReceive == 0)
    {
        *pfIoPending = FALSE;
        return S_OK;
    }

    HRESULT hr;
    DWORD cbRead;
    if (FAILED(hr = QueryW3Context()->ReceiveEntity(
                        W3_FLAG_ASYNC,
                        m_DataBuffer,
                        min(m_bytesToReceive, sizeof m_DataBuffer),
                        &cbRead)))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
        {
            *pfIoPending = FALSE;
            return S_OK;
        }

        DBGPRINTF((DBG_CONTEXT,
                   "CGIReadEntity Error reading gateway data, hr %x\n",
                   hr));

        return hr;
    }

    *pfIoPending = TRUE;
    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIWriteResponseEntity()
/*++
  Synopsis

    This function writes the next chunk of response entity

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    pResponse->Clear( TRUE );

    HRESULT hr;
    if (FAILED(hr = pResponse->AddMemoryChunkByReference(m_DataBuffer,
                                                         m_cbData)))
        return hr;

    if ((m_bytesToSend -= m_cbData) <= 0)
        m_dwRequestState |= CGI_STATE_DONE_WITH_REQUEST;

    //
    // At this point, we got to be reading the entity
    //
    DBG_ASSERT(m_dwRequestState & CGI_STATE_READING_RESPONSE_ENTITY);

    return QueryW3Context()->SendEntity(W3_FLAG_ASYNC | W3_FLAG_MORE_DATA);
}

HRESULT W3_CGI_HANDLER::CGIReadCGIOutput()
/*++
  Synopsis

    This function Reads the next chunk of data from the CGI

  Arguments

    None

  Return Value
    S_OK if async I/O posted
    Failure otherwise
--*/
{
    if (!ReadFile(m_hStdOut,
                  m_DataBuffer,
                  MAX_CGI_BUFFERING,
                  NULL,
                  &m_Overlapped))
    {
        DWORD dwErr = GetLastError();
        if (dwErr == ERROR_IO_PENDING)
            return S_OK;

        m_dwRequestState |= CGI_STATE_DONE_WITH_REQUEST;

        if (dwErr != ERROR_BROKEN_PIPE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReadFile from child stdout failed, error %d\n",
                       GetLastError()));
        }

        return HRESULT_FROM_WIN32(dwErr);
    }

    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIWriteCGIInput()
/*++
  Synopsis

    This function 

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    if (!WriteFile(m_hStdIn,
                   m_DataBuffer,
                   m_cbData,
                   NULL,
                   &m_Overlapped))
    {
        if (GetLastError() == ERROR_IO_PENDING)
            return S_OK;

        DBGPRINTF((DBG_CONTEXT, "WriteFile failed, error %d\n",
                   GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT W3_CGI_HANDLER::CGIContinueOnPipeCompletion(
    BOOL *pfIsCgiError)
/*++
  Synopsis

    This function continues on I/O completion to a pipe.
      If the I/O completion was because of a write on the pipe, it reads
    the next chunk of request entity, or if there is no more request entity,
    reads the first chunk of CGI output.
      If the I/O completion was because of a read on the pipe, it processes
    that data by either adding it to the header buffer or sending it to the
    client

  Arguments

    pfIsCgiError - Tells whether any error occurring inside this function
        was the fault of the CGI or the client

  Return Value

    HRESULT
--*/
{
    HRESULT hr;
    if (m_dwRequestState == CGI_STATE_READING_REQUEST_ENTITY)
    {
        BOOL fIoPending = FALSE;
        if (FAILED(hr = CGIReadRequestEntity(&fIoPending)) ||
            (fIoPending == TRUE))
        {
            *pfIsCgiError = FALSE;
            return hr;
        }

        //
        // There was no more request entity to read
        //
        DBG_ASSERT(fIoPending == FALSE);

        //
        // If this is an nph cgi, we do not parse header
        //
        if (QueryIsNphCgi())
        {
            m_dwRequestState = CGI_STATE_READING_RESPONSE_ENTITY;
        }
        else
        {
            m_dwRequestState = CGI_STATE_READING_RESPONSE_HEADERS;
        }
        m_cbData = 0;

        if (FAILED(hr = CGIReadCGIOutput()))
        {
            *pfIsCgiError = TRUE;
        }
        return hr;
    }
    else if (m_dwRequestState == CGI_STATE_READING_RESPONSE_HEADERS)
    {
        if (FAILED(hr = ProcessCGIOutput()))
        {
            *pfIsCgiError = TRUE;
        }
        return hr;
    }
    else
    {
        DBG_ASSERT(m_dwRequestState == CGI_STATE_READING_RESPONSE_ENTITY);

        if (FAILED(hr = CGIWriteResponseEntity()))
        {
            *pfIsCgiError = FALSE;
        }
        return hr;
    }
}

HRESULT W3_CGI_HANDLER::CGIStartProcessing()
/*++
  Synopsis

    This function kicks off the CGI processing by reading request entity
    if any or reading the first chunk of CGI output

  Arguments

    None

  Return Value

    HRESULT
--*/
{
    DWORD                   cbAvailableAlready;
    PVOID                   pbAvailableAlready;
    
    m_dwRequestState = CGI_STATE_READING_REQUEST_ENTITY;

    //
    // First we have to write any entity body to the program's stdin
    //
    // Start with the Entity Body already read
    //
    
    QueryW3Context()->QueryAlreadyAvailableEntity( &pbAvailableAlready,
                                                   &cbAvailableAlready );
                                                   
    m_bytesToReceive = QueryW3Context()->QueryRemainingEntityFromUl();

    if ( cbAvailableAlready != 0 )
    {
        if (!WriteFile(m_hStdIn,
                       pbAvailableAlready,
                       cbAvailableAlready,
                       NULL,
                       &m_Overlapped))
        {
            if (GetLastError() == ERROR_IO_PENDING)
                return S_OK;

            DBGPRINTF((DBG_CONTEXT, "WriteFile failed, error %d\n",
                       GetLastError()));
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
    }

    //
    // Now continue with either reading the rest of the request entity
    // or the CGI response
    //
    BOOL fIsCgiError;
    return CGIContinueOnPipeCompletion(&fIsCgiError);
}

HRESULT W3_CGI_HANDLER::CGIContinueOnClientCompletion()
{
    if (m_dwRequestState & CGI_STATE_READING_REQUEST_ENTITY)
    {
        if (SUCCEEDED(CGIWriteCGIInput()))
        {
            return S_OK;
        }

        //
        // If we could not write the request entity, for example because
        // the CGI did not wait to read the entity, ignore the error and
        // continue on to reading the output
        //

        //
        // If this is an nph cgi, we do not parse header
        //
        if (QueryIsNphCgi())
        {
            m_dwRequestState = CGI_STATE_READING_RESPONSE_ENTITY;
        }
        else
        {
            m_dwRequestState = CGI_STATE_READING_RESPONSE_HEADERS;
        }
        m_cbData = 0;
    }

    return CGIReadCGIOutput();
}

CONTEXT_STATUS W3_CGI_HANDLER::OnCompletion(DWORD cbCompletion,
                                            DWORD dwCompletionStatus)
{
    HRESULT hr = S_OK;

    if (dwCompletionStatus)
    {
        hr = HRESULT_FROM_WIN32(dwCompletionStatus);
        DBGPRINTF((DBG_CONTEXT, "Error %d on CGI_HANDLER::OnCompletion\n", dwCompletionStatus));
    }

    //
    // Is this completion for the entity body preload?  If so note the 
    // number of bytes and start handling the CGI request
    //
    
    if (!m_fEntityBodyPreloadComplete)
    {
        BOOL fComplete = FALSE;

        //
        // This completion is for entity body preload
        //

        W3_REQUEST *pRequest = QueryW3Context()->QueryRequest();
        hr = pRequest->PreloadCompletion(QueryW3Context(),
                                         cbCompletion,
                                         dwCompletionStatus,
                                         &fComplete);

        if (SUCCEEDED(hr))
        {
            if (!fComplete)
            {
                return CONTEXT_STATUS_PENDING;
            }

            m_fEntityBodyPreloadComplete = TRUE;

            //
            // Finally we can call the CGI
            //

            return DoWork();
        }
    }

    W3_RESPONSE *pResponse = QueryW3Context()->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    if (SUCCEEDED(hr) &&
        !(m_dwRequestState & CGI_STATE_DONE_WITH_REQUEST))
    {
        if (m_dwRequestState == CGI_STATE_READING_REQUEST_ENTITY)
        {
            m_bytesToReceive -= cbCompletion;
            m_cbData = cbCompletion;
        }

        if (SUCCEEDED(hr = CGIContinueOnClientCompletion()))
        {
            return CONTEXT_STATUS_PENDING;
        }

        if (!(m_dwRequestState & CGI_STATE_READING_RESPONSE_ENTITY))
        {
            pResponse->SetStatus(HttpStatusBadGateway,
                                 Http502PrematureExit);
        }
    }
    else
    {
        if ((m_dwRequestState & CGI_STATE_READING_REQUEST_ENTITY) ||
            !m_fEntityBodyPreloadComplete)
        {
            pResponse->SetStatus(HttpStatusBadRequest);
        }
    }

    if (FAILED(hr))
    {
        QueryW3Context()->SetErrorStatus(hr);
    }
    
    if (!(m_dwRequestState &
          (CGI_STATE_RESPONSE_REDIRECTED | CGI_STATE_READING_RESPONSE_ENTITY)))
    {
        //
        // If we reached here, i.e. no response was sent, status should be
        // 502 or 400
        //
        DBG_ASSERT(pResponse->QueryStatusCode() == HttpStatusBadGateway.statusCode ||
                   pResponse->QueryStatusCode() == HttpStatusBadRequest.statusCode );

        QueryW3Context()->SendResponse(W3_FLAG_SYNC);
    }

    // perf ctr
    QueryW3Context()->QuerySite()->DecCgiReqs();

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS 
W3_CGI_HANDLER::DoWork()
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    W3_RESPONSE  *pResponse;
    W3_REQUEST   *pRequest;
    URL_CONTEXT  *pUrlContext;
    W3_METADATA  *pMetaData;
    HRESULT       hr = S_OK;
    STACK_STRU(   strSSICommandLine, 256 );
    STRU         *pstrPhysical;
    HANDLE        hImpersonationToken;
    HANDLE        hPrimaryToken;
    DWORD         dwFlags = DETACHED_PROCESS;
    STACK_STRU(   strCmdLine, 256);
    BOOL          fIsCmdExe;
    STACK_STRU(   strWorkingDir, 256);
    STACK_BUFFER( buffEnv, MAX_CGI_BUFFERING);
    STACK_STRU  ( strApplicationName, 256);
    WCHAR *       pszCommandLine = NULL;
    DWORD         dwFileAttributes = 0;

    STARTUPINFO startupinfo;

    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT( pResponse != NULL );

    ZeroMemory(&startupinfo, sizeof(startupinfo));
    startupinfo.cb = sizeof(startupinfo);
    startupinfo.hStdOutput = INVALID_HANDLE_VALUE;
    startupinfo.hStdInput = INVALID_HANDLE_VALUE;

    if (!m_fEntityBodyPreloadComplete)
    {
        BOOL fComplete = FALSE;

        hr = pRequest->PreloadEntityBody( pW3Context,
                                          &fComplete );
        if (FAILED(hr))
        {
            goto Exit;
        }

        if (!fComplete)
        {
            return CONTEXT_STATUS_PENDING;
        }

        m_fEntityBodyPreloadComplete = TRUE;
    }

    DBG_ASSERT( m_fEntityBodyPreloadComplete );

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    if (m_pszSSICommandLine == NULL)
    {
        pstrPhysical = pUrlContext->QueryPhysicalPath();
        DBG_ASSERT(pstrPhysical != NULL);
    }
    else
    {
        hr = strSSICommandLine.CopyA(m_pszSSICommandLine);
        if (FAILED(hr))
        {
            goto Exit;
        }
        
        pstrPhysical = &strSSICommandLine;
    }
    
    hImpersonationToken = pW3Context->QueryImpersonationToken();
    hPrimaryToken = pW3Context->QueryPrimaryToken();

    // perf ctr
    pW3Context->QuerySite()->IncCgiReqs();

    if (QueryScriptMapEntry() != NULL &&
        !QueryScriptMapEntry()->QueryIsStarScriptMap())
    {
        STRU *pstrExe = QueryScriptMapEntry()->QueryExecutable();
        fIsCmdExe = IsCmdExe(pstrExe->QueryStr());

        STACK_STRU (strDecodedQueryString, MAX_PATH);
        if (FAILED(hr = SetupCmdLine(pRequest, &strDecodedQueryString)))
        {
            goto Exit;
        }

        STACK_BUFFER (bufCmdLine, MAX_PATH);
        DWORD cchLen = pstrExe->QueryCCH() +
                       pstrPhysical->QueryCCH() +
                       strDecodedQueryString.QueryCCH();
        if (!bufCmdLine.Resize(cchLen*sizeof(WCHAR) + sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        cchLen = _snwprintf((LPWSTR)bufCmdLine.QueryPtr(),
                            cchLen,
                            pstrExe->QueryStr(),
                            pstrPhysical->QueryStr(),
                            strDecodedQueryString.QueryStr());

        if (FAILED(hr = strCmdLine.Copy((LPWSTR)bufCmdLine.QueryPtr(),
                                        cchLen)))
        {
            goto Exit;
        }
    }
    else
    {
        fIsCmdExe = IsCmdExe(pstrPhysical->QueryStr());

        if (FAILED(hr = strCmdLine.Copy(L"\"", 1)) ||
            FAILED(hr = strCmdLine.Append(*pstrPhysical)) ||
            FAILED(hr = strCmdLine.Append(L"\" ", 2)) ||
            FAILED(hr = SetupCmdLine(pRequest, &strCmdLine)))
        {
            goto Exit;
        }
    }

    if (FAILED(hr = SetupChildEnv(&buffEnv)) ||
        FAILED(hr = SetupWorkingDir(pstrPhysical, &strWorkingDir)))
    {
        goto Exit;
    }

    //
    // Check to see if we're spawning cmd.exe, if so, refuse the request if
    // there are any special shell characters.  Note we do the check here
    // so that the command line has been fully unescaped
    //
    // Also, if invoking cmd.exe for a UNC script then don't set the
    // working directory.  Otherwise cmd.exe will complain about
    // working dir on UNC being not supported, which will destroy the
    // HTTP headers.
    //

    if (fIsCmdExe)
    {
        if (ISUNC(pstrPhysical->QueryStr()))
        {
            strWorkingDir.Reset();
        }

        if (!sm_fAllowSpecialCharsInShell)
        {
            DWORD i;

            //
            //  We'll either match one of the characters or the '\0'
            //

            i = wcscspn(strCmdLine.QueryStr(), L"&|(),;%<>");

            if (strCmdLine.QueryStr()[i])
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Refusing request for command shell due to special characters\n"));

                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto Exit;
            }
        }
        
        //
        // If this is a cmd.exe invocation, then ensure that the script
        // does exist
        //
       
        if (!SetThreadToken(NULL, hImpersonationToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        
        dwFileAttributes = GetFileAttributes(pstrPhysical->QueryStr());
        if (dwFileAttributes == 0xFFFFFFFF)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            RevertToSelf();
            goto Exit;
        }
        
        RevertToSelf();
    }

    //
    // Now check if it is an nph cgi (if not already)
    //
   
    if (!m_fIsNphCgi)
    {
        m_fIsNphCgi = IsNphCgi( pUrlContext->QueryUrlInfo()->QueryProcessedUrl()->QueryStr() );
    }
    
    if (m_fIsNphCgi)
    {
        pW3Context->SetDisconnect(TRUE);
    }

    //
    // We specify an unnamed desktop so a new windowstation will be
    // created in the context of the calling user
    //
    startupinfo.lpDesktop = L"";

    //
    // Setup the pipes information
    //

    if (FAILED(hr = SetupChildPipes(&m_hStdOut,
                                    &m_hStdIn,
                                    &startupinfo)))
    {
        goto Exit;
    }

    if (pMetaData->QueryCreateProcessNewConsole())
    {
        dwFlags = CREATE_NEW_CONSOLE;
    }

    //
    //  Depending what type of CGI this is (SSI command exec, Scriptmap, 
    //  Explicit), the command line and application path are different
    //
    
    if (m_pszSSICommandLine != NULL )
    {
        pszCommandLine = strSSICommandLine.QueryStr();
    }
    else
    {
        if (QueryScriptMapEntry() == NULL )
        {
            if (FAILED(hr = MakePathCanonicalizationProof(pstrPhysical->QueryStr(),
                                                          &strApplicationName)))
            {
                goto Exit;
            }
        }

        pszCommandLine = strCmdLine.QueryStr();
    }

    //
    //  Spawn the process and close the handles since we don't need them
    //

    if (!SetThreadToken(NULL, hImpersonationToken))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "SetThreadToken failed, error %d\n",
                   GetLastError()));

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    PROCESS_INFORMATION processinfo;

    if (!pMetaData->QueryCreateProcessAsUser())
    {
        if (!CreateProcess(strApplicationName.QueryCCH() ? strApplicationName.QueryStr() : NULL,
                           pszCommandLine,
                           NULL,      // Process security
                           NULL,      // Thread security
                           TRUE,      // Inherit handles
                           dwFlags | CREATE_UNICODE_ENVIRONMENT,
                           buffEnv.QueryPtr(),
                           strWorkingDir.QueryCCH() ? strWorkingDir.QueryStr() : NULL,
                           &startupinfo,
                           &processinfo))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CreateProcess failed, error %d\n",
                       GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_REQUIRE(RevertToSelf());

            goto Exit;
        }
    }
    else
    {
        if (!CreateProcessAsUser(hPrimaryToken,
                                 strApplicationName.QueryCCH() ? strApplicationName.QueryStr() : NULL,
                                 pszCommandLine,
                                 NULL,      // Process security
                                 NULL,      // Thread security
                                 TRUE,      // Inherit handles
                                 dwFlags | CREATE_UNICODE_ENVIRONMENT,
                                 buffEnv.QueryPtr(),
                                 strWorkingDir.QueryCCH() ? strWorkingDir.QueryStr() : NULL,
                                 &startupinfo,
                                 &processinfo))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "CreateProcessAsUser failed, error %d\n",
                       GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_REQUIRE(RevertToSelf());

            goto Exit;
        }
    }
        
    DBG_REQUIRE(RevertToSelf());

    DBG_REQUIRE(CloseHandle(startupinfo.hStdInput));
    startupinfo.hStdInput = INVALID_HANDLE_VALUE;
    DBG_REQUIRE(CloseHandle(startupinfo.hStdOutput));
    startupinfo.hStdOutput = INVALID_HANDLE_VALUE;

    DBG_REQUIRE(CloseHandle(processinfo.hThread));
    //
    //  Save the process handle in case we need to terminate it later on
    //
    m_hProcess = processinfo.hProcess;

    //
    //  Schedule a callback to kill the process if it doesn't die
    //  in a timely manner
    //
    if (!CreateTimerQueueTimer(&m_hTimer,
                               NULL,
                               CGITerminateProcess,
                               this,
                               pMetaData->QueryScriptTimeout() * 1000,
                               0,
                               WT_EXECUTEONLYONCE))
    {
        DBGPRINTF((DBG_CONTEXT,
                   "CreateTimerQueueTimer failed, error %d\n",
                   GetLastError()));
    }

    if (SUCCEEDED(hr = CGIStartProcessing()))
    {
        return CONTEXT_STATUS_PENDING;
    }

Exit:
    if (startupinfo.hStdInput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(startupinfo.hStdInput));
        startupinfo.hStdInput = INVALID_HANDLE_VALUE;
    }
    if (startupinfo.hStdOutput != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(startupinfo.hStdOutput));
        startupinfo.hStdOutput = INVALID_HANDLE_VALUE;
    }

    if (FAILED(hr))
    {
        switch (WIN32_FROM_HRESULT(hr))
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
            pResponse->SetStatus(HttpStatusNotFound);
            break;

        case ERROR_ACCESS_DENIED:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_LOGON_FAILURE:
            pResponse->SetStatus(HttpStatusUnauthorized,
                                 Http401Resource);
            break;

        //
        // CreateProcess returns this error when the path is too long
        //
        case ERROR_INVALID_NAME:
            pResponse->SetStatus(HttpStatusUrlTooLong);
            break;

        case ERROR_PRIVILEGE_NOT_HELD:
            pResponse->SetStatus(HttpStatusForbidden,
                                 Http403ExecAccessDenied);
            break;

        default:
            pResponse->SetStatus(HttpStatusServerError);
        }

        pW3Context->SetErrorStatus(hr);
    }

    //
    // If we reached here, there was some error, response should not be 200
    //
    DBG_ASSERT(pResponse->QueryStatusCode() != HttpStatusOk.statusCode);
    pW3Context->SendResponse(W3_FLAG_SYNC);

    // perf ctr
    pW3Context->QuerySite()->DecCgiReqs();

    return CONTEXT_STATUS_CONTINUE;
}

// static
VOID W3_CGI_HANDLER::KillAllCgis()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::KillAllCgis() called\n"));

    //
    // Kill all outstanding processes
    //

    EnterCriticalSection(&sm_CgiListLock);

    for (LIST_ENTRY *pEntry = sm_CgiListHead.Flink;
         pEntry != &sm_CgiListHead;
         pEntry = pEntry->Flink)
    {
        W3_CGI_HANDLER *pCgi = CONTAINING_RECORD(pEntry,
                                                 W3_CGI_HANDLER,
                                                 m_CgiListEntry);

        CGITerminateProcess(pCgi, 0);
    }

    LeaveCriticalSection(&sm_CgiListLock);
}

// static
VOID W3_CGI_HANDLER::Terminate()
{
    DBGPRINTF((DBG_CONTEXT, "W3_CGI_HANDLER::Terminate() called\n"));

    if (sm_hPreCreatedStdOut != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(sm_hPreCreatedStdOut));
        sm_hPreCreatedStdOut = INVALID_HANDLE_VALUE;
    }

    if (sm_hPreCreatedStdIn != INVALID_HANDLE_VALUE)
    {
        DBG_REQUIRE(CloseHandle(sm_hPreCreatedStdIn));
        sm_hPreCreatedStdIn = INVALID_HANDLE_VALUE;
    }

    if (sm_pEnvString != NULL)
    {
        delete sm_pEnvString;
        sm_pEnvString = NULL;
    }

    DeleteCriticalSection(&sm_CgiListLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compress.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    compression.h

Abstract:

    Do Http compression

Author:

    Anil Ruia (AnilR)           10-Apr-2000

--*/

#ifndef _COMPRESSION_H_
#define _COMPRESSION_H_

#define COMPRESSION_MIN_IO_BUFFER_SIZE                  256
#define COMPRESSION_MAX_IO_BUFFER_SIZE               100000
#define COMPRESSION_MIN_COMP_BUFFER_SIZE               1024
#define COMPRESSION_MAX_COMP_BUFFER_SIZE             100000
#define COMPRESSION_MAX_QUEUE_LENGTH                  10000
#define COMPRESSION_MIN_FILES_DELETED_PER_DISK_FREE       1
#define COMPRESSION_MAX_FILES_DELETED_PER_DISK_FREE    1024
#define COMPRESSION_MAX_COMPRESSION_LEVEL                10

#define COMPRESSION_DEFAULT_DISK_SPACE_USAGE      100000000
#define COMPRESSION_DEFAULT_BUFFER_SIZE                8192
#define COMPRESSION_DEFAULT_QUEUE_LENGTH               1000
#define COMPRESSION_DEFAULT_FILES_DELETED_PER_DISK_FREE 256
#define COMPRESSION_DEFAULT_FILE_SIZE_FOR_COMPRESSION     1


class COMPRESSION_SCHEME
{
 public:
    COMPRESSION_SCHEME()
        : m_hCompressionDll            (NULL),
          m_pCompressionContext        (NULL),
          m_dwPriority                 (1),
          m_dwDynamicCompressionLevel  (0),
          m_dwOnDemandCompressionLevel (COMPRESSION_MAX_COMPRESSION_LEVEL),
          m_dwCreateFlags              (0),
          m_fDoStaticCompression       (TRUE),
          m_fDoOnDemandCompression     (TRUE),
          m_fDoDynamicCompression      (TRUE),
          m_pfnInitCompression         (NULL),
          m_pfnDeInitCompression       (NULL),
          m_pfnCreateCompression       (NULL),
          m_pfnCompress                (NULL),
          m_pfnDestroyCompression      (NULL),
          m_pfnResetCompression        (NULL)
    {}

    HRESULT Initialize(MB *pmb, LPWSTR schemeName);

    ~COMPRESSION_SCHEME()
    {
        if (m_pfnDestroyCompression && m_pCompressionContext)
        {
            m_pfnDestroyCompression(m_pCompressionContext);
            m_pCompressionContext = NULL;
        }

        if (m_pfnDeInitCompression)
        {
            m_pfnDeInitCompression();
        }

        if (m_hCompressionDll)
        {
            FreeLibrary(m_hCompressionDll);
            m_hCompressionDll = NULL;
        }
    }

    STRU                           m_strCompressionSchemeName;
    STRA                           m_straCompressionSchemeName;
    STRU                           m_strFilePrefix;
    MULTISZ                        m_mszFileExtensions;
    MULTISZ                        m_mszScriptFileExtensions;

    DWORD                          m_dwPriority;

    HMODULE                        m_hCompressionDll;
    PFNCODEC_INIT_COMPRESSION      m_pfnInitCompression;
    PFNCODEC_DEINIT_COMPRESSION    m_pfnDeInitCompression;
    PFNCODEC_CREATE_COMPRESSION    m_pfnCreateCompression;
    PFNCODEC_COMPRESS              m_pfnCompress;
    PFNCODEC_DESTROY_COMPRESSION   m_pfnDestroyCompression;
    PFNCODEC_RESET_COMPRESSION     m_pfnResetCompression;

    // The compression context used for static compression
    PVOID                          m_pCompressionContext;

    DWORD                          m_dwDynamicCompressionLevel;
    DWORD                          m_dwOnDemandCompressionLevel;
    DWORD                          m_dwCreateFlags;
    BOOL                           m_fDoDynamicCompression;
    BOOL                           m_fDoStaticCompression;
    BOOL                           m_fDoOnDemandCompression;
};

typedef enum
{
    COMPRESSION_WORK_ITEM_COMPRESS,
    COMPRESSION_WORK_ITEM_DELETE,
    COMPRESSION_WORK_ITEM_TERMINATE
} COMPRESSION_WORK_ITEM_TYPE;

typedef struct
{
    LIST_ENTRY                  ListEntry;
    COMPRESSION_WORK_ITEM_TYPE  WorkItemType;
    COMPRESSION_SCHEME         *scheme;
    STRU                        strPhysicalPath;
} COMPRESSION_WORK_ITEM;

#define MAX_SERVER_SCHEMES 100

typedef enum
{
    DO_STATIC_COMPRESSION,
    DO_DYNAMIC_COMPRESSION
} COMPRESSION_TO_PERFORM;

#define DYNAMIC_COMPRESSION_BUFFER_SIZE 4096

typedef enum
{
    IN_CHUNK_LENGTH,
    IN_CHUNK_EXTENSION,
    IN_CHUNK_HEADER_NEW_LINE,
    AT_CHUNK_DATA_NEW_LINE,
    IN_CHUNK_DATA_NEW_LINE,
    IN_CHUNK_DATA
} COMPRESS_CHUNK_STATE;

class COMPRESSION_BUFFER
{
 public:
    static HRESULT Initialize()
    {
        ALLOC_CACHE_CONFIGURATION acConfig;
        
        acConfig.nConcurrency = 1;
        acConfig.nThreshold = 100;
        acConfig.cbSize = sizeof COMPRESSION_BUFFER;

        allocHandler = new ALLOC_CACHE_HANDLER("COMPRESSION_BUFFER",
                                               &acConfig);
        if (allocHandler == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        return S_OK;
    }

    static void Terminate()
    {
        if (allocHandler != NULL)
        {
            delete allocHandler;
        }
    }

    void *operator new(size_t size)
    {
        DBG_ASSERT(size == sizeof COMPRESSION_BUFFER);
        DBG_ASSERT(allocHandler != NULL);
        return allocHandler->Alloc();
    }

    void operator delete(void *pCompressionBuffer)
    {
        DBG_ASSERT(pCompressionBuffer != NULL);
        DBG_ASSERT(allocHandler != NULL);
        DBG_REQUIRE(allocHandler->Free(pCompressionBuffer));
    }

    BYTE       buffer[6 + DYNAMIC_COMPRESSION_BUFFER_SIZE + 7];
    LIST_ENTRY listEntry;

    static ALLOC_CACHE_HANDLER *allocHandler;
};

class COMPRESSION_CONTEXT
{
 public:
    static HRESULT Initialize()
    {
        ALLOC_CACHE_CONFIGURATION acConfig;
        
        acConfig.nConcurrency = 1;
        acConfig.nThreshold = 100;
        acConfig.cbSize = sizeof COMPRESSION_CONTEXT;

        allocHandler = new ALLOC_CACHE_HANDLER("COMPRESSION_CONTEXT",
                                               &acConfig);
        if (allocHandler == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        return S_OK;
    }

    static void Terminate()
    {
        if (allocHandler != NULL)
        {
            delete allocHandler;
        }
    }

    void *operator new(size_t size)
    {
        DBG_ASSERT(size == sizeof COMPRESSION_CONTEXT);
        DBG_ASSERT(allocHandler != NULL);
        return allocHandler->Alloc();
    }

    void operator delete(void *pCompressionContext)
    {
        DBG_ASSERT(pCompressionContext != NULL);
        DBG_ASSERT(allocHandler != NULL);
        DBG_REQUIRE(allocHandler->Free(pCompressionContext));
    }

    COMPRESSION_CONTEXT()
        : m_pScheme                      (NULL),
          m_fTransferChunkEncoded        (FALSE),
          m_pCompressionContext          (NULL),
          m_dwBytesInCurrentEncodedChunk (0),
          m_encodedChunkState            (IN_CHUNK_LENGTH),
          m_pIoBuffer                    (NULL),
          m_fRequestIsHead               (FALSE),
          m_fOriginalBodyEmpty           (TRUE)
    {
        InitializeListHead(&m_BufferListHead);
    }

    ~COMPRESSION_CONTEXT()
    {
        FreeBuffers();

        if (m_pIoBuffer != NULL)
        {
            delete m_pIoBuffer;
        }

        if (m_pCompressionContext)
        {
            m_pScheme->m_pfnDestroyCompression(m_pCompressionContext);
            m_pCompressionContext = NULL;
        }
    }

    void FreeBuffers()
    {
        while (!IsListEmpty(&m_BufferListHead))
        {
            LIST_ENTRY *pEntry = RemoveHeadList(&m_BufferListHead);
            COMPRESSION_BUFFER *pBuffer = CONTAINING_RECORD(pEntry,
                                                            COMPRESSION_BUFFER,
                                                            listEntry);
            delete pBuffer;
        }
    }

    BYTE *GetNewBuffer()
    {
        COMPRESSION_BUFFER *pBuffer = new COMPRESSION_BUFFER;
        if (pBuffer == NULL)
        {
            return NULL;
        }

        InitializeListHead(&pBuffer->listEntry);
        InsertHeadList(&m_BufferListHead, &pBuffer->listEntry);

        return pBuffer->buffer;
    }

    HRESULT SetupCurrentULChunk();

    DWORD QueryBytesAvailable()
    {
        if (m_fCurrentULChunkFromMemory)
        {
            return m_pCurrentULChunk->FromMemory.BufferLength;
        }

        // We don't handle (nor do we plan to) FileName chunks
        DBG_ASSERT(m_pCurrentULChunk->DataChunkType == HttpDataChunkFromFileHandle);
        return m_bytesInIoBuffer - m_currentLocationInIoBuffer;
    }

    BYTE *QueryBytePtr()
    {
        if (m_fCurrentULChunkFromMemory)
        {
            return (PBYTE)m_pCurrentULChunk->FromMemory.pBuffer;
        }

        // We don't handle (nor do we plan to) FileName chunks
        DBG_ASSERT(m_pCurrentULChunk->DataChunkType == HttpDataChunkFromFileHandle);
        return m_pIoBuffer + m_currentLocationInIoBuffer;
    }

    HRESULT ProcessEncodedChunkHeader();

    HRESULT CalculateEncodedChunkByteCount();

    HRESULT DeleteEncodedChunkExtension();

    HRESULT IncrementPointerInULChunk(IN DWORD dwIncr = 1);

    COMPRESSION_SCHEME          *m_pScheme;

    //
    // Is the original response chunk encoded?
    //
    BOOL                        m_fTransferChunkEncoded;

    //
    // If the original response is Chunk encoded, information about the
    // current chunk in the response
    //
    DWORD                       m_dwBytesInCurrentEncodedChunk;
    COMPRESS_CHUNK_STATE        m_encodedChunkState;

    //
    // The context used by the compression routines
    //
    PVOID                       m_pCompressionContext;

    //
    // Storage for the original response
    //
    BUFFER                      m_ULChunkBuffer;
    DWORD                       m_cULChunks;

    //
    // position in the original response
    //
    DWORD                       m_cCurrentULChunk;
    HTTP_DATA_CHUNK            *m_pCurrentULChunk;
    BOOL                        m_fCurrentULChunkFromMemory;

    //
    // buffer for reading data for FileHandle chunks
    //
    BYTE                       *m_pIoBuffer;
    DWORD                       m_currentLocationInIoBuffer;
    DWORD                       m_bytesInIoBuffer;

    static ALLOC_CACHE_HANDLER *allocHandler;

    LIST_ENTRY                  m_BufferListHead;

    //
    // Some members to keep track of HEAD request body suppression
    //
    BOOL                        m_fRequestIsHead;
    BOOL                        m_fOriginalBodyEmpty;
};

class HTTP_COMPRESSION
{
 public:

    static HRESULT Initialize();

    static VOID Terminate();

    static HRESULT DoStaticFileCompression(IN     W3_CONTEXT    *pW3Context,
                                           IN OUT W3_FILE_INFO **ppFileInfo);

    static HRESULT OnSendResponse(
                       IN  W3_CONTEXT *pW3Context,
                       IN  BOOL        fMoreData);

    static HRESULT DoDynamicCompression(
                       IN  W3_CONTEXT *pW3Context,
                       IN  BOOL        fMoreData);

    static BOOL QueryDoStaticCompression()
    {
        return sm_fDoStaticCompression;
    }

    static BOOL QueryDoDynamicCompression()
    {
        return sm_fDoDynamicCompression;
    }

 private:

    static COMPRESSION_SCHEME *sm_pCompressionSchemes[MAX_SERVER_SCHEMES];
    static DWORD sm_dwNumberOfSchemes;
    static STRU *sm_pstrCompressionDirectory;
    static STRA *sm_pstrCacheControlHeader;
    static STRA *sm_pstrExpiresHeader;
    static BOOL  sm_fDoStaticCompression;
    static BOOL  sm_fDoDynamicCompression;
    static BOOL  sm_fDoOnDemandCompression;
    static BOOL  sm_fDoDiskSpaceLimiting;
    static BOOL  sm_fNoCompressionForHttp10;
    static BOOL  sm_fNoCompressionForProxies;
    static BOOL  sm_fNoCompressionForRange;
    static BOOL  sm_fSendCacheHeaders;
    static DWORD sm_dwMaxDiskSpaceUsage;
    static DWORD sm_dwIoBufferSize;
    static DWORD sm_dwCompressionBufferSize;
    static DWORD sm_dwMaxQueueLength;
    static DWORD sm_dwFilesDeletedPerDiskFree;
    static DWORD sm_dwMinFileSizeForCompression;
    static PBYTE sm_pIoBuffer;
    static PBYTE sm_pCompressionBuffer;
    static CRITICAL_SECTION sm_CompressionDirectoryLock;
    static DWORD sm_dwCurrentDiskSpaceUsage;
    static BOOL  sm_fCompressionVolumeIsFat;
    static LIST_ENTRY sm_CompressionThreadWorkQueue;
    static CRITICAL_SECTION sm_CompressionThreadLock;
    static HANDLE sm_hThreadEvent;
    static HANDLE sm_hCompressionThreadHandle;
    static DWORD sm_dwCurrentQueueLength;
    static BOOL  sm_fHttpCompressionInitialized;
    static BOOL  sm_fIsTerminating;

    static HRESULT ReadMetadata(MB *pmb);

    static HRESULT InitializeCompressionSchemes(MB *pmb);

    static HRESULT InitializeCompressionDirectory();

    static HRESULT InitializeCompressionThread();

    static DWORD WINAPI CompressionThread(LPVOID);

    static BOOL QueueWorkItem(
        IN COMPRESSION_WORK_ITEM   *WorkItem,
        IN BOOL                     fOverrideMaxQueueLength,
        IN BOOL                     fQueueAtHead);

    static VOID FindMatchingSchemes(
                    IN  CHAR * pszAcceptEncoding,
                    IN  LPWSTR pszExtension,
                    IN  COMPRESSION_TO_PERFORM performCompr,
                    OUT DWORD  matchingSchemes[],
                    OUT DWORD *pdwClientCompressionCount);

    static HRESULT ConvertPhysicalPathToCompressedPath(
        IN COMPRESSION_SCHEME *scheme,
        IN STRU  *pstrPhysicalPath,
        OUT STRU *pstrCompressedFileName);

    static BOOL CheckForExistenceOfCompressedFile(
        IN  W3_FILE_INFO  *pOrigFile,
        IN  STRU          *pstrCompressedFileName,
        OUT W3_FILE_INFO **ppCompFile,
        IN  BOOL           fDeleteAllowed = TRUE);

    static BOOL QueueCompressFile(
        IN COMPRESSION_SCHEME *scheme,
        IN STRU               &strPhysicalPath);

    static VOID CompressFile(IN COMPRESSION_SCHEME *scheme,
                             IN STRU               &strPhysicalPath);

    static VOID FreeDiskSpace();

    static BOOL CompressAndWriteData(
                    IN  COMPRESSION_SCHEME *scheme,
                    IN  PBYTE               InputBuffer,
                    IN  DWORD               BytesToCompress,
                    OUT PDWORD              BytesWritten,
                    IN  HANDLE              hCompressedFile);
};

#endif _COMPRESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compressionapi.h ===
/*
 * api.h
 */
typedef HRESULT (WINAPI *PFNCODEC_INIT_COMPRESSION)(VOID);
typedef HRESULT (WINAPI *PFNCODEC_INIT_DECOMPRESSION)(VOID);

typedef VOID (WINAPI *PFNCODEC_DEINIT_COMPRESSION)(VOID);
typedef VOID (WINAPI *PFNCODEC_DEINIT_DECOMPRESSION)(VOID);

typedef HRESULT (WINAPI *PFNCODEC_CREATE_COMPRESSION)(PVOID *context, ULONG flags);
typedef HRESULT (WINAPI *PFNCODEC_CREATE_DECOMPRESSION)(PVOID *context, ULONG flags);

typedef HRESULT (WINAPI *PFNCODEC_COMPRESS)(
	PVOID		context, 
	CONST PBYTE	input, 
	LONG		input_size, 
	PBYTE		output, 
	LONG		output_size,
	PLONG		input_used,
	PLONG		output_used,
	INT			compression_level
);

typedef HRESULT (WINAPI *PFNCODEC_DECOMPRESS)(
	PVOID		context,
	CONST PBYTE	input,
	LONG		input_size,
	PBYTE		output,
	LONG		output_size,
	PLONG		input_used,
	PLONG		output_used
);

typedef VOID (WINAPI *PFNCODEC_DESTROY_COMPRESSION)(PVOID context);
typedef VOID (WINAPI *PFNCODEC_DESTROY_DECOMPRESSION)(PVOID context);

typedef HRESULT (WINAPI *PFNCODEC_RESET_COMPRESSION)(PVOID context);
typedef HRESULT (WINAPI *PFNCODEC_RESET_DECOMPRESSION)(PVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\childcontext.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     childcontext.cxx

   Abstract:
     Child context implementation
 
   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    W3_CHILD_CONTEXT::sm_pachChildContexts;

W3_CHILD_CONTEXT::W3_CHILD_CONTEXT(
    W3_MAIN_CONTEXT *           pMainContext,
    W3_CONTEXT *                pParentContext,
    W3_REQUEST *                pRequest,
    BOOL                        fOwnRequest,
    W3_USER_CONTEXT *           pCustomUserContext,
    DWORD                       dwExecFlags
)
  : W3_CONTEXT( dwExecFlags ),
    _pMainContext( pMainContext ),
    _pParentContext( pParentContext ),
    _pRequest( pRequest ),
    _fOwnRequest( fOwnRequest ),
    _pCustomUserContext( pCustomUserContext )
{
    //
    // If the parent context is disabling wildcards, custom errors, or
    // headers --> we should ensure those features are disabled for 
    // this context too
    //
    
    DBG_ASSERT( _pParentContext != NULL );
    
    if ( !_pParentContext->QuerySendCustomError() )
    {
        _dwExecFlags |= W3_FLAG_NO_CUSTOM_ERROR;
    }
    
    if ( !_pParentContext->QuerySendHeaders() )
    {
        _dwExecFlags |= W3_FLAG_NO_HEADERS;
    }
    
    if ( !_pParentContext->QuerySendErrorBody() )
    {
        _dwExecFlags |= W3_FLAG_NO_ERROR_BODY;
    }

    //
    // Get the fAuthAccessCheckRequired flag from the main context so 
    // the child conext would know if we need to do auth access check 
    // or not.
    //
    DBG_ASSERT( _pMainContext != NULL );
    
    SetAuthAccessCheckRequired( _pMainContext->
                                  QueryAuthAccessCheckRequired() );
}

W3_CHILD_CONTEXT::~W3_CHILD_CONTEXT()
/*++

Routine Description:

    Deletes a child context.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _pUrlContext != NULL )
    {
        delete _pUrlContext;
        _pUrlContext = NULL;
    }
    
    //
    // Only delete the request object if we own it!  (we won't own it in
    // case where we're doing a "reprocessurl" 
    //
    
    if ( _pRequest )
    {
        if ( _fOwnRequest )
        {
            delete _pRequest;
            _pRequest = NULL;
        }
    }
    
    //
    // Clean up the custom user context if there is one
    //
    
    if ( _pCustomUserContext != NULL )
    {
        _pCustomUserContext->DereferenceUserContext();
        _pCustomUserContext = NULL;
    }
}

// static
HRESULT
W3_CHILD_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_CHILD_CONTEXTs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CHILD_CONTEXT );

    DBG_ASSERT( sm_pachChildContexts == NULL );
    
    sm_pachChildContexts = new ALLOC_CACHE_HANDLER( "W3_CHILD_CONTEXT",  
                                                    &acConfig );

    if ( sm_pachChildContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

// static
VOID
W3_CHILD_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachChildContexts != NULL )
    {
        delete sm_pachChildContexts;
        sm_pachChildContexts = NULL;
    }
}

HRESULT
W3_CHILD_CONTEXT::RetrieveUrlContext(
    BOOL *                      pfFinished
)
/*++

Routine Description:

    Retrieves URL context for this context
    
Arguments:

    pfFinished - Set to TRUE if filter wants out

Return Value:

    HRESULT

--*/
{
    URL_CONTEXT *                   pUrlContext;
    HRESULT                         hr;
    
    if ( pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfFinished = FALSE;
    
    QueryMainContext()->PushCurrentContext( this );
    
    hr = URL_CONTEXT::RetrieveUrlContext( this,
                                          QueryRequest(),
                                          &pUrlContext,
                                          pfFinished );

    QueryMainContext()->PopCurrentContext();

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( *pfFinished )
    {
        return NO_ERROR;
    }
    
    DBG_ASSERT( pUrlContext != NULL );
    
    _pUrlContext = pUrlContext;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\cgi_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    cgi_handler.h

Abstract:

    Handler class for CGI

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _CGI_HANDLER_H_
#define _CGI_HANDLER_H_

#define MAX_CGI_BUFFERING                  4096

#define CGI_STATE_READING_REQUEST_ENTITY   0x01
#define CGI_STATE_READING_RESPONSE_HEADERS 0x02
#define CGI_STATE_READING_RESPONSE_ENTITY  0x04
#define CGI_STATE_DONE_WITH_REQUEST        0x08
#define CGI_STATE_RESPONSE_REDIRECTED      0x10

#define PIPENAME_SIZE       ( sizeof( "\\\\.\\pipe\\IISCgiStdOut" ) + 64 )

class W3_CGI_HANDLER : public W3_HANDLER
{
public:
    W3_CGI_HANDLER( W3_CONTEXT * pW3Context,
                    META_SCRIPT_MAP_ENTRY * pScriptMapEntry,
                    LPSTR pszSSICommandLine = NULL )
      : W3_HANDLER        (pW3Context, pScriptMapEntry),
        m_cbData          (0),
        m_hStdOut         (INVALID_HANDLE_VALUE),
        m_hStdIn          (INVALID_HANDLE_VALUE),
        m_hProcess        (NULL),
        m_hTimer          (NULL),
        m_dwRequestState  (0),
        m_bytesToSend     (INFINITE),
        m_bytesToReceive  (0),
        m_fEntityBodyPreloadComplete (FALSE),
        m_pszSSICommandLine(pszSSICommandLine),
        m_fIsNphCgi       (FALSE)
    {
        ZeroMemory(&m_Overlapped, sizeof OVERLAPPED);

        InitializeListHead(&m_CgiListEntry);

        EnterCriticalSection(&sm_CgiListLock);
        InsertHeadList(&sm_CgiListHead, &m_CgiListEntry);
        LeaveCriticalSection(&sm_CgiListLock);

        if (pszSSICommandLine != NULL)
        {
            m_fIsNphCgi = TRUE;
        }
    }

    ~W3_CGI_HANDLER();

    WCHAR *QueryName()
    {
        return L"CGIHandler";
    }

    CONTEXT_STATUS DoWork();

    CONTEXT_STATUS OnCompletion(IN DWORD cbCompletion,
                                IN DWORD dwCompletionStatus);

    static HRESULT Initialize();

    static VOID KillAllCgis();

    static VOID Terminate();

private:

    HRESULT CGIStartProcessing();

    HRESULT CGIContinueOnClientCompletion();

    HRESULT CGIContinueOnPipeCompletion(BOOL *pfIsCgiError);

    HRESULT CGIReadRequestEntity(BOOL *pfIoPending);

    HRESULT CGIWriteResponseEntity();

    HRESULT CGIReadCGIOutput();

    HRESULT CGIWriteCGIInput();

    HRESULT ProcessCGIOutput();

    HRESULT SetupChildEnv(OUT BUFFER *pBuffer);

    static HRESULT SetupChildPipes(OUT HANDLE *phStdOut,
                                   OUT HANDLE *phStdIn,
                                   IN OUT STARTUPINFO *pstartupinfo,
                                   BOOL fFirstInstance = FALSE);

    static VOID CALLBACK CGITerminateProcess(PVOID pContext,
                                             BOOLEAN);

    BOOL QueryIsNphCgi() const
    {
        return m_fIsNphCgi;
    }

    static VOID CALLBACK OnPipeIoCompletion(
                             DWORD dwErrorCode,
                             DWORD dwNumberOfBytesTransfered,
                             LPOVERLAPPED lpOverlapped);

    static BOOL             sm_fAllowSpecialCharsInShell;
    static BOOL             sm_fForwardServerEnvironmentBlock;
    static WCHAR *          sm_pEnvString;
    static DWORD            sm_cchEnvLength;
    static LIST_ENTRY       sm_CgiListHead;
    static CRITICAL_SECTION sm_CgiListLock;

    //
    // The names for the stdin and stdout pipes
    //
    static WCHAR            sm_achStdinPipeName[ PIPENAME_SIZE ];
    static WCHAR            sm_achStdoutPipeName[ PIPENAME_SIZE ];
    static HANDLE           sm_hPreCreatedStdOut;
    static HANDLE           sm_hPreCreatedStdIn;

    //
    // DWORD containing the state of the current request
    //
    DWORD                   m_dwRequestState;

    //
    // The timer callback handle
    //
    HANDLE                   m_hTimer;

    //
    //  Parent's input and output handles and child's process handle
    //
    
    HANDLE                  m_hStdOut;
    HANDLE                  m_hStdIn;
    HANDLE                  m_hProcess;

    //
    // Variable to keep track of how many more bytes of request/response left
    //
    DWORD                   m_bytesToSend;
    DWORD                   m_bytesToReceive;

    //
    // Buffer to do I/O to/from CGI/client
    //
    CHAR                    m_DataBuffer[MAX_CGI_BUFFERING];

    //
    // Buffer to store response headers
    //
    BUFFER                  m_bufResponseHeaders;

    //
    // Number of bytes in the buffer (m_DataBuffer or
    // m_bufResponseHeaders) currently
    //
    DWORD                   m_cbData;

    //
    // OVERLAPPED structure for async I/O
    //
    OVERLAPPED m_Overlapped;

    //
    // Store a list of active CGI requests so we can timeout bad requests
    //
    LIST_ENTRY              m_CgiListEntry;

    //
    // Have we completed preloading the entity body
    //
    BOOL                    m_fEntityBodyPreloadComplete;

    //
    // For the SSI #EXEC CMD case, m_pszSSICommandLine contains the explicit
    // command to execute
    //
    // Note: CGI_HANDLER does not own this string so it doesn't need to
    // free it.
    //
    LPSTR                   m_pszSSICommandLine;

    //
    // Is this an nph CGI (or a cmd exec from SSI)
    //
    BOOL                    m_fIsNphCgi;
};

//
//  This is the exit code given to processes that we terminate
//

#define CGI_PREMATURE_DEATH_CODE  0xf1256323

// Is it a UNC Path?
#define ISUNC(a) ((a)[0]=='\\' && (a)[1]=='\\')

#endif // _CGI_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\customprovider.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     customprovider.cxx

   Abstract:
     Authentication provider for arbitrary user-name/auth-type/token combo
     set by ISAPI during call to HSE_REQ_EXEC_URL
 
   Author:
     Bilal Alam (balam)             29-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include "precomp.hxx"
#include "customprovider.hxx"

HRESULT
CUSTOM_USER_CONTEXT::Create(
    HANDLE          hImpersonationToken,
    CHAR *          pszUserName,
    DWORD           dwAuthType
)
/*++

Routine Description:

    Initialize custom user context

Arguments:

    hImpersonationToken - Impersonation token for the custom user
    pszUserName - Custom user name
    dwAuthType - Auth type
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( hImpersonationToken == NULL ||
         pszUserName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Duplicate the token
    // 
   
    if ( !DuplicateTokenEx( hImpersonationToken,
                            TOKEN_ALL_ACCESS,
                            NULL,
                            SecurityImpersonation,
                            TokenImpersonation,
                            &_hImpersonationToken ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Copy the user name
    //
    
    hr = _strUserName.CopyA( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _dwAuthType = dwAuthType;
    
    return NO_ERROR;
}

HANDLE
CUSTOM_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get the primary token

Arguments:

    None
    
Return Value:

    HANDLE to primary token

--*/
{
    if ( _hPrimaryToken == NULL )
    {
        _Lock.WriteLock();
        
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }

        _Lock.WriteUnlock();
    }
    
    return _hPrimaryToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\customerror.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     customerror.cxx

   Abstract:
     Custom Error goo
 
   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

HRESULT
CUSTOM_ERROR_TABLE::FindCustomError(
    USHORT                  StatusCode,
    USHORT                  SubError,
    BOOL *                  pfIsFile,
    STRU *                  pstrError
)
/*++

Routine Description:

    Find the applicable custom error entry for a given status/subcode

Arguments:

    StatusCode - Status code
    SubError - sub error
    pfIsFile - Set to TRUE if this is a file error
    pstrError - Error path (URL or file)

Return Value:

    HRESULT

--*/
{
    LIST_ENTRY *            pListEntry;
    CUSTOM_ERROR_ENTRY *    pCustomEntry = NULL;
    BOOL                    fFound = FALSE;
    HRESULT                 hr = NO_ERROR;
    
    if ( pfIsFile == NULL ||
         pstrError == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    for ( pListEntry = _ErrorListHead.Flink;
          pListEntry != &_ErrorListHead;
          pListEntry = pListEntry->Flink )
    {
        pCustomEntry = CONTAINING_RECORD( pListEntry,
                                          CUSTOM_ERROR_ENTRY,
                                          _listEntry ); 
        DBG_ASSERT( pCustomEntry != NULL );

        if ( pCustomEntry->_StatusCode == StatusCode )
        {
            if ( pCustomEntry->_SubError == SubError ||
                 pCustomEntry->_SubError == SUBERROR_WILDCARD )
            {
                fFound = TRUE;
                break;
            }
        }
    }
    
    if ( fFound )
    {
        hr = pstrError->Copy( pCustomEntry->_strError );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        *pfIsFile = pCustomEntry->_fIsFile;
        return NO_ERROR;
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
}

HRESULT
CUSTOM_ERROR_TABLE::BuildTable(
    WCHAR *             pszErrorList
)
/*++

Routine Description:

    Build custom error table from metabase
    
Arguments:

    pszErrorList - Magic error MULTISZ

Return Value:

    HRESULT

--*/
{
    WCHAR *             pszType;
    WCHAR *             pszSubError;
    WCHAR *             pszPath;
    WCHAR *             pszNewPath;
    WCHAR               cTemp;
    USHORT              StatusCode;
    USHORT              SubError;
    BOOL                fIsFile;
    CUSTOM_ERROR_ENTRY* pNewEntry;
    DWORD               dwPathLength;
    HRESULT             hr = NO_ERROR;

    for (;;)
    {
        //
        // Get the status code
        //
        
        StatusCode = (USHORT) _wtoi( pszErrorList );
        if ( StatusCode < 300 )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }

        //
        // Now convert the second parameter (the suberror) to a number.
        //

        pszSubError = wcschr( pszErrorList, L',' );
        if ( pszSubError == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszSubError++;
        
        while ( iswspace( *pszSubError ) )
        {
            pszSubError++;
        }
        
        //
        // Either we have a specific sub error or a wildcard (any suberror)
        //

        if ( *pszSubError == L'*' )
        {
            SubError = SUBERROR_WILDCARD;
        }
        else
        {
            if ( !iswdigit( *pszSubError ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Finished;
            }

            SubError = (USHORT) _wtoi( pszSubError );
        }

        //
        // Now find the comma that seperates the number and the type.
        //
        
        pszType = wcschr( pszSubError, L',' );
        if ( pszType == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszType++;

        while ( iswspace( *pszType ) )
        {
            pszType++;
        }

        // We found the end of ws. If this isn't an alphabetic character, it's
        // an error. If it is, find the end of the alpha. chars.

        if ( !iswalpha( *pszType ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszPath = pszType;

        while ( iswalpha( *pszPath ) )
        {
            pszPath++;
        }

        cTemp = *pszPath;
        *pszPath = L'\0';

        //
        // What type of custom error is this?
        //

        if ( !_wcsicmp( pszType, L"FILE" ) )
        {
            fIsFile = TRUE;
        }
        else
        {
            if (!_wcsicmp( pszType, L"URL" ) )
            {
                fIsFile = FALSE;
            }
            else
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Finished;
            }
        }
        *pszPath = cTemp;

        //
        // Now find the comma that seperates the type from the URL/path.
        //
        
        pszPath = wcschr( pszPath, L',' );
        if ( pszPath == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }
        pszPath++;

        while ( SAFEIsSpace( *pszPath ) )
        {
            pszPath++;
        }

        if ( *pszPath == '\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto Finished;
        }

        dwPathLength = wcslen( pszPath ) + 1;

        //
        // OK.  Now we can allocate a table entry
        //
        
        pNewEntry = new CUSTOM_ERROR_ENTRY;
        if ( pNewEntry == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Finished;
        }
            
        pNewEntry->_StatusCode = StatusCode;
        pNewEntry->_SubError = SubError;
        pNewEntry->_fIsFile = fIsFile;
        
        hr = pNewEntry->_strError.Copy( pszPath );
        if ( FAILED( hr ) )
        {
            delete pNewEntry;
            return hr;
        }
        
        //
        // Give more specific errors higher priority in lookup
        //

        if ( SubError == SUBERROR_WILDCARD )
        {
            InsertTailList( &_ErrorListHead, &pNewEntry->_listEntry );
        }
        else
        {
            InsertHeadList( &_ErrorListHead, &pNewEntry->_listEntry );
        }

        pszErrorList = pszPath + dwPathLength;

        if ( *pszErrorList == L'\0' )
        {
            hr = NO_ERROR;
            break;
        }
    }
Finished:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\compress.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    compression.cxx

Abstract:

    Do Http compression

Author:

    Anil Ruia (AnilR)           10-Apr-2000

--*/

#include "precomp.hxx"

#define HTTP_COMPRESSION_KEY           L"/LM/w3svc/Filters/Compression"
#define HTTP_COMPRESSION_PARAMETERS    L"Parameters"
#define COMP_FILE_PREFIX               L"$^_"
#define TEMP_COMP_FILE_SUFFIX          L"~TMP~"

// mask for clearing bits when comparing file acls
#define ACL_CLEAR_BIT_MASK (~(SE_DACL_AUTO_INHERITED |      \
                              SE_SACL_AUTO_INHERITED |      \
                              SE_DACL_PROTECTED      |      \
                              SE_SACL_PROTECTED))

#define HEX_TO_ASCII(c) ((CHAR)((c) < 10 ? ((c) + '0') : ((c) + 'a' - 10)))


//
// static variables
//
COMPRESSION_SCHEME *HTTP_COMPRESSION::sm_pCompressionSchemes[MAX_SERVER_SCHEMES];
LIST_ENTRY          HTTP_COMPRESSION::sm_CompressionThreadWorkQueue;
CRITICAL_SECTION    HTTP_COMPRESSION::sm_CompressionThreadLock;
CRITICAL_SECTION    HTTP_COMPRESSION::sm_CompressionDirectoryLock;
DWORD  HTTP_COMPRESSION::sm_dwNumberOfSchemes           = 0;
STRU  *HTTP_COMPRESSION::sm_pstrCompressionDirectory    = NULL;
STRA  *HTTP_COMPRESSION::sm_pstrCacheControlHeader      = NULL;
STRA  *HTTP_COMPRESSION::sm_pstrExpiresHeader           = NULL;
BOOL   HTTP_COMPRESSION::sm_fDoStaticCompression        = FALSE;
BOOL   HTTP_COMPRESSION::sm_fDoDynamicCompression       = FALSE;
BOOL   HTTP_COMPRESSION::sm_fDoOnDemandCompression      = TRUE;
BOOL   HTTP_COMPRESSION::sm_fDoDiskSpaceLimiting        = FALSE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForHttp10     = TRUE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForProxies    = FALSE;
BOOL   HTTP_COMPRESSION::sm_fNoCompressionForRange      = TRUE;
BOOL   HTTP_COMPRESSION::sm_fSendCacheHeaders           = TRUE;
DWORD  HTTP_COMPRESSION::sm_dwMaxDiskSpaceUsage         = COMPRESSION_DEFAULT_DISK_SPACE_USAGE;
DWORD  HTTP_COMPRESSION::sm_dwIoBufferSize              = COMPRESSION_DEFAULT_BUFFER_SIZE;
DWORD  HTTP_COMPRESSION::sm_dwCompressionBufferSize     = COMPRESSION_DEFAULT_BUFFER_SIZE;
DWORD  HTTP_COMPRESSION::sm_dwMaxQueueLength            = COMPRESSION_DEFAULT_QUEUE_LENGTH;
DWORD  HTTP_COMPRESSION::sm_dwFilesDeletedPerDiskFree   = COMPRESSION_DEFAULT_FILES_DELETED_PER_DISK_FREE;
DWORD  HTTP_COMPRESSION::sm_dwMinFileSizeForCompression = COMPRESSION_DEFAULT_FILE_SIZE_FOR_COMPRESSION;
PBYTE  HTTP_COMPRESSION::sm_pIoBuffer                   = NULL;
PBYTE  HTTP_COMPRESSION::sm_pCompressionBuffer          = NULL;
DWORD  HTTP_COMPRESSION::sm_dwCurrentDiskSpaceUsage     = 0;
BOOL   HTTP_COMPRESSION::sm_fCompressionVolumeIsFat     = FALSE;
HANDLE HTTP_COMPRESSION::sm_hThreadEvent                = NULL;
HANDLE HTTP_COMPRESSION::sm_hCompressionThreadHandle    = NULL;
DWORD  HTTP_COMPRESSION::sm_dwCurrentQueueLength        = 0;
BOOL   HTTP_COMPRESSION::sm_fHttpCompressionInitialized = FALSE;
BOOL   HTTP_COMPRESSION::sm_fIsTerminating              = FALSE;

ALLOC_CACHE_HANDLER *COMPRESSION_BUFFER::allocHandler;
ALLOC_CACHE_HANDLER *COMPRESSION_CONTEXT::allocHandler;

// static
HRESULT HTTP_COMPRESSION::Initialize()
/*++
  Synopsis
    Initialize function called during Server startup

  Returns
    HRESULT
--*/
{
    //
    // Construct some static variables
    //
    sm_pstrCompressionDirectory = new STRU;
    sm_pstrCacheControlHeader = new STRA;
    sm_pstrExpiresHeader = new STRA;
    if (sm_pstrCompressionDirectory == NULL ||
        sm_pstrCacheControlHeader == NULL ||
        sm_pstrExpiresHeader == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    HRESULT hr;
    if (FAILED(hr = sm_pstrCompressionDirectory->Copy(
                        L"%windir%\\IIS Temporary Compressed Files")) ||
        FAILED(hr = sm_pstrCacheControlHeader->Copy("maxage=86400")) ||
        FAILED(hr = sm_pstrExpiresHeader->Copy(
                        "Wed, 01 Jan 1997 12:00:00 GMT")))
    {
        return hr;
    }

    MB mb(g_pW3Server->QueryMDObject());
    if (!mb.Open(HTTP_COMPRESSION_KEY))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Read the global configuration from the metabase
    //
    if (FAILED(hr = ReadMetadata(&mb)))
    {
        return hr;
    }

    //
    // Read in all the compression schemes and initialize them
    //
    if (FAILED(hr = InitializeCompressionSchemes(&mb)))
    {
        return hr;
    }

    mb.Close();

    if (FAILED(hr = COMPRESSION_CONTEXT::Initialize()))
    {
        return hr;
    }

    if (FAILED(hr = COMPRESSION_BUFFER::Initialize()))
    {
        return hr;
    }

    //
    // Initialize other stuff
    //
    sm_pIoBuffer = new BYTE[sm_dwIoBufferSize];
    sm_pCompressionBuffer = new BYTE[sm_dwCompressionBufferSize];
    if (!sm_pIoBuffer || !sm_pCompressionBuffer)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    INITIALIZE_CRITICAL_SECTION(&sm_CompressionDirectoryLock);

    if (FAILED(hr = InitializeCompressionDirectory()))
    {
        return hr;
    }

    if (FAILED(hr = InitializeCompressionThread()))
    {
        return hr;
    }

    sm_fHttpCompressionInitialized = TRUE;
    return S_OK;
}


DWORD WINAPI HTTP_COMPRESSION::CompressionThread(LPVOID)
/*++
  Synopsis
    Entry point for the thread which takes Compression work-items off the
    queue and processes them

  Arguments and Return Values are ignored
--*/
{
    BOOL fTerminate = FALSE;

    while (!fTerminate)
    {
        //
        // Wait for some item to appear on the work queue
        //
        if (WaitForSingleObject(sm_hThreadEvent, INFINITE) == WAIT_FAILED)
        {
            DBG_ASSERT(FALSE);
        }

        EnterCriticalSection(&sm_CompressionThreadLock);

        while (!IsListEmpty(&sm_CompressionThreadWorkQueue))
        {
            LIST_ENTRY *listEntry =
                RemoveHeadList(&sm_CompressionThreadWorkQueue);

            LeaveCriticalSection(&sm_CompressionThreadLock);

            COMPRESSION_WORK_ITEM *workItem =
                CONTAINING_RECORD(listEntry,
                                  COMPRESSION_WORK_ITEM,
                                  ListEntry);

            //
            // Look at what the work item exactly is
            //
            if(workItem->WorkItemType == COMPRESSION_WORK_ITEM_TERMINATE)
            {
                fTerminate = TRUE;
            }
            else if (!fTerminate)
            {
                if (workItem->WorkItemType == COMPRESSION_WORK_ITEM_DELETE)
                {
                    //
                    // special scheme to indicate that this item is for
                    // deletion, not compression
                    //
                    DeleteFile(workItem->strPhysicalPath.QueryStr());
                }
                else
                {
                    DBG_ASSERT(workItem->WorkItemType == COMPRESSION_WORK_ITEM_COMPRESS);

                    CompressFile(workItem->scheme,
                                 workItem->strPhysicalPath);
                }
            }

            delete workItem;

            EnterCriticalSection(&sm_CompressionThreadLock);
        }

        LeaveCriticalSection(&sm_CompressionThreadLock);
    }

    //
    // We are terminating, close the Event handle
    //
    CloseHandle(sm_hThreadEvent);
    sm_hThreadEvent = NULL;
    return 0;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionThread()
/*++
  Initialize stuff related to the Compression Thread
--*/
{
    InitializeListHead(&sm_CompressionThreadWorkQueue);
    INITIALIZE_CRITICAL_SECTION(&sm_CompressionThreadLock);

    sm_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (sm_hThreadEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    DWORD threadId;
    sm_hCompressionThreadHandle = CreateThread(NULL, 0,
                                               CompressionThread,
                                               NULL, 0,
                                               &threadId);
    if (sm_hCompressionThreadHandle == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // CODEWORK: configurable?
    SetThreadPriority(sm_hCompressionThreadHandle, THREAD_PRIORITY_LOWEST);

    return S_OK;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionDirectory()
/*++
  Setup stuff related to the compression directory
--*/
{
    WIN32_FILE_ATTRIBUTE_DATA fileInformation;

    //
    // Find if the directory exists, if not create it
    //
    if (!GetFileAttributesEx(sm_pstrCompressionDirectory->QueryStr(),
                             GetFileExInfoStandard,
                             &fileInformation))
    {
        if (!CreateDirectory(sm_pstrCompressionDirectory->QueryStr(), NULL))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else if (!(fileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    }

    if (sm_fDoDiskSpaceLimiting)
    {
        sm_dwCurrentDiskSpaceUsage = 0;

        //
        // Find usage in the directory
        //
        STACK_STRU (CompDirWildcard, 512);
        HRESULT hr;

        if (FAILED(hr = CompDirWildcard.Copy(*sm_pstrCompressionDirectory)) ||
            FAILED(hr = CompDirWildcard.Append(L"\\", 1)) ||
            FAILED(hr = CompDirWildcard.Append(COMP_FILE_PREFIX)) ||
            FAILED(hr = CompDirWildcard.Append(L"*", 1)))
        {
            return hr;
        }

        WIN32_FIND_DATA win32FindData;
        HANDLE hDirectory = FindFirstFile(CompDirWildcard.QueryStr(),
                                          &win32FindData);
        if (hDirectory != INVALID_HANDLE_VALUE)
        {
            do
            {
                sm_dwCurrentDiskSpaceUsage += win32FindData.nFileSizeLow;
            }
            while (FindNextFile(hDirectory, &win32FindData));

            FindClose(hDirectory);
        }
    }

    //
    // Find if the Volume is FAT or NTFS, check for file change differs
    //
    WCHAR volumeRoot[10];
    volumeRoot[0] = sm_pstrCompressionDirectory->QueryStr()[0];
    volumeRoot[1] = L':';
    volumeRoot[2] = L'\\';
    volumeRoot[3] = L'\0';

    DWORD maximumComponentLength;
    DWORD fileSystemFlags;
    WCHAR fileSystemName[256];
    if (!GetVolumeInformation(volumeRoot, NULL, 0, NULL,
                              &maximumComponentLength,
                              &fileSystemFlags,
                              fileSystemName,
                              sizeof(fileSystemName)/sizeof(WCHAR)) ||
        !wcsncmp(L"FAT", fileSystemName, 3))
    {
        sm_fCompressionVolumeIsFat = TRUE;
    }
    else
    {
        sm_fCompressionVolumeIsFat = FALSE;
    }

    for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
    {
        STRU &filePrefix = sm_pCompressionSchemes[i]->m_strFilePrefix;
        HRESULT hr;

        if (FAILED(hr = filePrefix.Copy(*sm_pstrCompressionDirectory)) ||
            FAILED(hr = filePrefix.Append(L"\\", 1)) ||
            FAILED(hr = filePrefix.Append(COMP_FILE_PREFIX)) ||
            FAILED(hr = filePrefix.Append(
                sm_pCompressionSchemes[i]->m_strCompressionSchemeName)) ||
            FAILED(hr = filePrefix.Append(L"_", 1)))
        {
            return hr;
        }
    }

    return S_OK;
}


// static
HRESULT HTTP_COMPRESSION::InitializeCompressionSchemes(MB *pmb)
/*++
  Synopsis:
    Read in all the compression schemes and initialize them

  Arguments:
    pmb: pointer to the Metabase object

  Return Value
    HRESULT
--*/
{
    COMPRESSION_SCHEME *scheme;
    BOOL fExistStaticScheme = FALSE;
    BOOL fExistDynamicScheme = FALSE;
    BOOL fExistOnDemandScheme = FALSE;
    HRESULT hr;

    //
    // Enumerate all the scheme names under the main Compression key
    //
    WCHAR schemeName[METADATA_MAX_NAME_LEN + 1];
    for (DWORD schemeIndex = 0;
         pmb->EnumObjects(L"", schemeName, schemeIndex);
         schemeIndex++)
    {
        if (_wcsicmp(schemeName, HTTP_COMPRESSION_PARAMETERS) == 0)
        {
            continue;
        }

        scheme = new COMPRESSION_SCHEME;
        if (scheme == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (FAILED(hr = scheme->Initialize(pmb, schemeName)))
        {
            DBGPRINTF((DBG_CONTEXT, "Error initializing scheme, error %x\n", hr));
            delete scheme;
            continue;
        }

        if (scheme->m_fDoStaticCompression)
        {
            fExistStaticScheme = TRUE;
        }

        if (scheme->m_fDoDynamicCompression)
        {
            fExistDynamicScheme = TRUE;
        }

        if (scheme->m_fDoOnDemandCompression)
        {
            fExistOnDemandScheme = TRUE;
        }

        sm_pCompressionSchemes[sm_dwNumberOfSchemes++] = scheme;
        if (sm_dwNumberOfSchemes == MAX_SERVER_SCHEMES)
        {
            break;
        }
    }

    //
    // Sort the schemes by priority
    //
    for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
    {
        for (DWORD j=i+1; j<sm_dwNumberOfSchemes; j++)
        {
            if (sm_pCompressionSchemes[j]->m_dwPriority >
                sm_pCompressionSchemes[i]->m_dwPriority)
            {
                scheme = sm_pCompressionSchemes[j];
                sm_pCompressionSchemes[j] = sm_pCompressionSchemes[i];
                sm_pCompressionSchemes[i] = scheme;
            }
        }
    }

    if (!fExistStaticScheme)
    {
        sm_fDoStaticCompression = FALSE;
    }

    if (!fExistDynamicScheme)
    {
        sm_fDoDynamicCompression = FALSE;
    }

    if (!fExistOnDemandScheme)
    {
        sm_fDoOnDemandCompression = FALSE;
    }

    return S_OK;
}


//static
HRESULT HTTP_COMPRESSION::ReadMetadata(MB *pmb)
/*++
  Read all the global compression configuration
--*/
{
    BUFFER TempBuff;
    DWORD dwNumMDRecords;
    DWORD dwDataSetNumber;
    METADATA_GETALL_RECORD *pMDRecord;
    DWORD i;
    BOOL fExpandCompressionDirectory = TRUE;
    HRESULT hr;

    if (!pmb->GetAll(HTTP_COMPRESSION_PARAMETERS,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH,
                     IIS_MD_UT_SERVER,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    pMDRecord = (METADATA_GETALL_RECORD *)TempBuff.QueryPtr();

    for (i=0; i < dwNumMDRecords; i++, pMDRecord++)
    {
        PVOID pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                          pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch (pMDRecord->dwMDIdentifier)
        {
        case MD_HC_COMPRESSION_DIRECTORY:
            if (pMDRecord->dwMDDataType != STRING_METADATA &&
                pMDRecord->dwMDDataType != EXPANDSZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (pMDRecord->dwMDDataType == STRING_METADATA)
            {
                fExpandCompressionDirectory = FALSE;
            }

            if (FAILED(hr = sm_pstrCompressionDirectory->Copy(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_CACHE_CONTROL_HEADER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (FAILED(hr = sm_pstrCacheControlHeader->CopyWTruncate(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_EXPIRES_HEADER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (FAILED(hr = sm_pstrExpiresHeader->CopyWTruncate(
                                (LPWSTR)pDataPointer)))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_DO_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoDynamicCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoStaticCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoOnDemandCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_DISK_SPACE_LIMITING:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fDoDiskSpaceLimiting = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_HTTP_10:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForHttp10 = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_PROXIES:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForProxies = *((BOOL *)pDataPointer);
            break;

        case MD_HC_NO_COMPRESSION_FOR_RANGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fNoCompressionForRange = *((BOOL *)pDataPointer);
            break;

        case MD_HC_SEND_CACHE_HEADERS:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_fSendCacheHeaders = *((BOOL *)pDataPointer);
            break;

        case MD_HC_MAX_DISK_SPACE_USAGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMaxDiskSpaceUsage = *((DWORD *)pDataPointer);
            break;

        case MD_HC_IO_BUFFER_SIZE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwIoBufferSize = *((DWORD *)pDataPointer);
            sm_dwIoBufferSize = max(COMPRESSION_MIN_IO_BUFFER_SIZE,
                                    sm_dwIoBufferSize);
            sm_dwIoBufferSize = min(COMPRESSION_MAX_IO_BUFFER_SIZE,
                                    sm_dwIoBufferSize);
            break;

        case MD_HC_COMPRESSION_BUFFER_SIZE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwCompressionBufferSize = *((DWORD *)pDataPointer);
            sm_dwCompressionBufferSize = max(COMPRESSION_MIN_COMP_BUFFER_SIZE,
                                             sm_dwCompressionBufferSize);
            sm_dwCompressionBufferSize = min(COMPRESSION_MAX_COMP_BUFFER_SIZE,
                                             sm_dwCompressionBufferSize);
            break;

        case MD_HC_MAX_QUEUE_LENGTH:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMaxQueueLength = *((DWORD *)pDataPointer);
            sm_dwMaxQueueLength = min(COMPRESSION_MAX_QUEUE_LENGTH,
                                      sm_dwMaxQueueLength);
            break;

        case MD_HC_FILES_DELETED_PER_DISK_FREE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwFilesDeletedPerDiskFree = *((DWORD *)pDataPointer);
            sm_dwFilesDeletedPerDiskFree =
                max(COMPRESSION_MIN_FILES_DELETED_PER_DISK_FREE,
                    sm_dwFilesDeletedPerDiskFree);
            sm_dwFilesDeletedPerDiskFree =
                min(COMPRESSION_MAX_FILES_DELETED_PER_DISK_FREE,
                    sm_dwFilesDeletedPerDiskFree);
            break;

        case MD_HC_MIN_FILE_SIZE_FOR_COMP:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            sm_dwMinFileSizeForCompression = *((DWORD *)pDataPointer);
            break;

        default:
            ;
        }
    }

    //
    // The compression directory name contains an environment vairable,
    // expand it
    //
    if (fExpandCompressionDirectory)
    {
        WCHAR pszCompressionDir[MAX_PATH + 1];
        if (!ExpandEnvironmentStrings(sm_pstrCompressionDirectory->QueryStr(),
                                      pszCompressionDir,
                                      sizeof pszCompressionDir/sizeof WCHAR))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrorExit;
        }
        sm_pstrCompressionDirectory->Copy(pszCompressionDir);
    }

    return S_OK;

 ErrorExit:
    return hr;
}


HRESULT COMPRESSION_SCHEME::Initialize(
     IN MB *pmb,
     IN LPWSTR schemeName)
/*++
  Initialize all the scheme specific data for the given scheme
--*/
{
    BUFFER TempBuff;
    DWORD dwNumMDRecords;
    DWORD dwDataSetNumber;
    HRESULT hr;
    METADATA_GETALL_RECORD *pMDRecord;
    DWORD i;
    STACK_STRU (strCompressionDll, 256);
    HMODULE compressionDll = NULL;

    //
    // Copy the scheme name
    //
    if (FAILED(hr = m_strCompressionSchemeName.Copy(schemeName)) ||
        FAILED(hr = m_straCompressionSchemeName.CopyWTruncate(schemeName)))
    {
        return hr;
    }

    //
    // First get all the metabase data
    //
    if (!pmb->GetAll(schemeName,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH,
                     IIS_MD_UT_SERVER,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    pMDRecord = (METADATA_GETALL_RECORD *)TempBuff.QueryPtr();

    for (i=0; i < dwNumMDRecords; i++, pMDRecord++)
    {
        PVOID pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                          pMDRecord->dwMDDataOffset);

        DBG_ASSERT( pMDRecord->dwMDDataTag == 0);

        switch (pMDRecord->dwMDIdentifier)
        {
        case MD_HC_COMPRESSION_DLL:
            if (pMDRecord->dwMDDataType != STRING_METADATA &&
                pMDRecord->dwMDDataType != EXPANDSZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            if (pMDRecord->dwMDDataType == EXPANDSZ_METADATA)
            {
                WCHAR CompressionDll[MAX_PATH + 1];
                if (!ExpandEnvironmentStrings((LPWSTR)pDataPointer,
                                              CompressionDll,
                                              sizeof CompressionDll/sizeof WCHAR))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto ErrorExit;
                }

                hr = strCompressionDll.Copy(CompressionDll);
            }
            else
            {
                hr = strCompressionDll.Copy((LPWSTR)pDataPointer);
            }

            if (FAILED(hr))
            {
                goto ErrorExit;
            }
            break;

        case MD_HC_DO_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoDynamicCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoStaticCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_DO_ON_DEMAND_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_fDoOnDemandCompression = *((BOOL *)pDataPointer);
            break;

        case MD_HC_FILE_EXTENSIONS:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            {
                MULTISZ mszTemp((LPWSTR)pDataPointer);
                m_mszFileExtensions.Copy(mszTemp);
            }

            break;

        case MD_HC_SCRIPT_FILE_EXTENSIONS:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            {
                MULTISZ mszTemp((LPWSTR)pDataPointer);
                m_mszScriptFileExtensions.Copy(mszTemp);
            }

            break;

        case MD_HC_PRIORITY:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwPriority = *((DWORD *)pDataPointer);
            break;

        case MD_HC_DYNAMIC_COMPRESSION_LEVEL:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwDynamicCompressionLevel = *((DWORD *)pDataPointer);
            m_dwDynamicCompressionLevel =
                min(COMPRESSION_MAX_COMPRESSION_LEVEL,
                    m_dwDynamicCompressionLevel);
            break;

        case MD_HC_ON_DEMAND_COMP_LEVEL:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwOnDemandCompressionLevel = *((DWORD *)pDataPointer);
            m_dwOnDemandCompressionLevel =
                min(COMPRESSION_MAX_COMPRESSION_LEVEL,
                    m_dwOnDemandCompressionLevel);
            break;

        case MD_HC_CREATE_FLAGS:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto ErrorExit;
            }

            m_dwCreateFlags = *((DWORD *)pDataPointer);
            break;

        default:
            ;
        }
    }

    //
    // Now, get the dll and the entry-points
    //
    compressionDll = LoadLibrary(strCompressionDll.QueryStr());
    if (compressionDll == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    m_pfnInitCompression = (PFNCODEC_INIT_COMPRESSION)
        GetProcAddress(compressionDll, "InitCompression");
    m_pfnDeInitCompression = (PFNCODEC_DEINIT_COMPRESSION)
        GetProcAddress(compressionDll, "DeInitCompression");
    m_pfnCreateCompression = (PFNCODEC_CREATE_COMPRESSION)
        GetProcAddress(compressionDll, "CreateCompression");
    m_pfnCompress = (PFNCODEC_COMPRESS)
        GetProcAddress(compressionDll, "Compress");
    m_pfnDestroyCompression = (PFNCODEC_DESTROY_COMPRESSION)
        GetProcAddress(compressionDll, "DestroyCompression");
    m_pfnResetCompression = (PFNCODEC_RESET_COMPRESSION)
        GetProcAddress(compressionDll, "ResetCompression");

    if (!m_pfnInitCompression    ||
        !m_pfnDeInitCompression  ||
        !m_pfnCreateCompression  ||
        !m_pfnCompress           ||
        !m_pfnDestroyCompression ||
        !m_pfnResetCompression)
    {
        hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);
        goto ErrorExit;
    }

    //
    // Call the initialize entry-point
    //
    if (FAILED(hr = m_pfnInitCompression()) ||
        FAILED(hr = m_pfnCreateCompression(&m_pCompressionContext,
                                           m_dwCreateFlags)))
    {
        goto ErrorExit;
    }

    m_hCompressionDll = compressionDll;

    return S_OK;

 ErrorExit:
    if (compressionDll)
    {
        FreeLibrary(compressionDll);
    }
    return hr;
}


// static
BOOL HTTP_COMPRESSION::QueueWorkItem (
    IN COMPRESSION_WORK_ITEM   *WorkItem,
    IN BOOL                     fOverrideMaxQueueLength,
    IN BOOL                     fQueueAtHead)
/*++
  Routine Description:
    This is the routine that handles queuing work items to the compression
    thread.

Arguments:
    WorkRoutine - the routine that the compression thread should call
        to do work.  If NULL, then the call is an indication to the
        compression thread that it should terminate.

    Context - a context pointer which is passed to WorkRoutine.

    WorkItem - if not NULL, this is a pointer to the work item to use
        for this request.  If NULL, then this routine will allocate a
        work item to use.  Note that by passing in a work item, the
        caller agrees to give up control of the memory: we will free it
        as necessary, either here or in the compression thread.

    MustSucceed - if TRUE, then this request is not subject to the
        limits on the number of work items that can be queued at any one
        time.

    QueueAtHead - if TRUE, then this work item is placed at the head
        of the queue to be serviced immediately.

Return Value:
    TRUE if the queuing succeeded.
--*/
{
    DBG_ASSERT(WorkItem != NULL);

    //
    // Acquire the lock that protects the work queue list test to see
    // how many items we have on the queue.  If this is not a "must
    // succeed" request and if we have reached the configured queue size
    // limit, then fail this request.  "Must succeed" requests are used
    // for thread shutdown and other things which we really want to
    // work.
    //

    EnterCriticalSection(&sm_CompressionThreadLock);

    if (!fOverrideMaxQueueLength &&
        (sm_dwCurrentQueueLength >= sm_dwMaxQueueLength))
    {
        LeaveCriticalSection(&sm_CompressionThreadLock);
        return FALSE;
    }

    //
    // All looks good, so increment the count of items on the queue and
    // add this item to the queue.
    //

    sm_dwCurrentQueueLength++;

    if (fQueueAtHead)
    {
        InsertHeadList(&sm_CompressionThreadWorkQueue, &WorkItem->ListEntry);
    }
    else
    {
        InsertTailList(&sm_CompressionThreadWorkQueue, &WorkItem->ListEntry);
    }

    LeaveCriticalSection(&sm_CompressionThreadLock);

    //
    // Signal the event that will cause the compression thread to wake
    // up and process this work item.
    //

    SetEvent(sm_hThreadEvent);

    return TRUE;
}


// static
VOID HTTP_COMPRESSION::Terminate()
/*++
  Called on server shutdown
--*/
{
    DBG_ASSERT(sm_fHttpCompressionInitialized);
    sm_fIsTerminating = TRUE;

    //
    // Make the CompressionThread terminate by queueing a work item indicating
    // that
    //
    COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;

    if (WorkItem == NULL)
    {
        // if we can't even allocate this much memory, skip the rest of
        // the termination and exit
        return;
    }

    WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_TERMINATE;

    QueueWorkItem(WorkItem, TRUE, TRUE);
    WaitForSingleObject(sm_hCompressionThreadHandle, INFINITE);
    CloseHandle(sm_hCompressionThreadHandle);
    sm_hCompressionThreadHandle = NULL;

    COMPRESSION_BUFFER::Terminate();

    COMPRESSION_CONTEXT::Terminate();

    //
    // Free static objects
    //
    delete sm_pstrCompressionDirectory;
    sm_pstrCompressionDirectory = NULL;

    delete sm_pstrCacheControlHeader;
    sm_pstrCacheControlHeader = NULL;

    delete sm_pstrExpiresHeader;
    sm_pstrExpiresHeader = NULL;

    delete sm_pIoBuffer;
    sm_pIoBuffer = NULL;

    delete sm_pCompressionBuffer;
    sm_pCompressionBuffer = NULL;

    DeleteCriticalSection(&sm_CompressionDirectoryLock);
    DeleteCriticalSection(&sm_CompressionThreadLock);

    //
    // For each compression scheme, unload the compression dll and free
    // the space that holds info about the scheme
    //
    for (DWORD i=0; i<sm_dwNumberOfSchemes; i++)
    {
        delete sm_pCompressionSchemes[i];
    }
}


// static
HRESULT HTTP_COMPRESSION::DoStaticFileCompression(
            IN     W3_CONTEXT    *pW3Context,
            IN OUT W3_FILE_INFO **ppOpenFile)
/*++
  Synopsis:
    Handle compression of static file request by either sending back the
    compression version if present and applicable or queueing a work-item
    to compress it for future requests.  Called by
    W3_STATIC_FILE_HANDLER::FileDoWork

  Arguments:
    pW3Context: The W3_CONTEXT for the request
    ppOpenFile: On entry contains the cache entry to the physical path.
        If a suitable file is found, on exit contains cach entry to the
        compressed file

  Returns:
    HRESULT
--*/
{
    //
    // If compression is not initialized, return
    //
    if (!sm_fHttpCompressionInitialized)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the client has not sent an Accept-Encoding header, or an empty
    // Accept-Encoding header, return
    //
    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    CHAR *pszAcceptEncoding = pRequest->GetHeader(HttpHeaderAcceptEncoding);
    if (pszAcceptEncoding == NULL || *pszAcceptEncoding == '\0')
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for 1.0, and version is not 1.1,
    // return
    //
    if (sm_fNoCompressionForHttp10 &&
        ((pRequest->QueryVersion().MajorVersion == 0) ||
         ((pRequest->QueryVersion().MajorVersion == 1) &&
          (pRequest->QueryVersion().MinorVersion == 0))))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for proxies and it is a proxy
    // request, return
    //
    if (sm_fNoCompressionForProxies && pRequest->IsProxyRequest())
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not Compress for range requests and Range
    // is present, return
    // BUGBUG: Is the correct behavior to take range on the original request
    // and compress those chunks or take range on the compressed file?  We do
    // the latter (same as IIS 5.0), figure out if that is correct.
    //
    if (sm_fNoCompressionForRange &&
        pRequest->GetHeader(HttpHeaderRange))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If file is too small, return
    //
    W3_FILE_INFO *pOrigFile = *ppOpenFile;
    LARGE_INTEGER originalFileSize;
    pOrigFile->QuerySize(&originalFileSize);
    if (originalFileSize.QuadPart < sm_dwMinFileSizeForCompression)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Break the accept-encoding header into all the encoding accepted by
    // the client sorting using the quality value
    //

    STACK_STRA( strAcceptEncoding, 512);
    HRESULT hr;
    if (FAILED(hr = strAcceptEncoding.Copy(pszAcceptEncoding)))
    {
        return hr;
    }

    STRU *pstrPhysical = pW3Context->QueryUrlContext()->QueryPhysicalPath();
    LPWSTR pszExtension = wcsrchr(pstrPhysical->QueryStr(), L'.');
    if (pszExtension != NULL)
    {
        pszExtension++;
    }

    DWORD dwClientCompressionCount;
    DWORD matchingSchemes[MAX_SERVER_SCHEMES];
    //
    // Find out all schemes which will compress for this file
    //
    FindMatchingSchemes(strAcceptEncoding.QueryStr(),
                        pszExtension,
                        DO_STATIC_COMPRESSION,
                        matchingSchemes,
                        &dwClientCompressionCount);

    //
    // Try to find a static scheme, which already has the file
    // pre-compressed
    //
    COMPRESSION_SCHEME *firstOnDemandScheme = NULL;
    STACK_STRU (strCompressedFileName, 256);
    for (DWORD i=0; i<dwClientCompressionCount; i++)
    {
        COMPRESSION_SCHEME *scheme = sm_pCompressionSchemes[matchingSchemes[i]];

        //
        // Now, see if there exists a version of the requested file
        // that has been compressed with that scheme.  First, calculate
        // the name the file would have.  The compressed file will live
        // in the special compression directory with a special converted
        // name.  The file name starts with the compression scheme used,
        // then the fully qualified file name where slashes and colons
        // have been converted to underscores.  For example, the gzip
        // version of "c:\inetpub\wwwroot\file.htm" would be
        // "c:\compdir\$^_gzip^c^^inetpub^wwwroot^file.htm".
        //

        if (FAILED(hr = ConvertPhysicalPathToCompressedPath(
                            scheme,
                            pstrPhysical,
                            &strCompressedFileName)))
        {
            return hr;
        }

        W3_FILE_INFO *pCompFile;
        if (CheckForExistenceOfCompressedFile(
                pOrigFile,
                &strCompressedFileName,
                &pCompFile))
        {
            //
            // Bingo--we have a compressed version of the file in a
            // format that the client understands.  Add the appropriate
            // Content-Encoding header so that the client knows it is
            // getting compressed data and change the server's mapping
            // to the compressed version of the file.
            //

            W3_RESPONSE *pResponse = pW3Context->QueryResponse();
            if (FAILED(hr = pResponse->SetHeaderByReference(
                              HttpHeaderContentEncoding,
                              scheme->m_straCompressionSchemeName.QueryStr(),
                              scheme->m_straCompressionSchemeName.QueryCCH())))
            {
                pCompFile->DereferenceCacheEntry();
                return hr;
            }

            if (sm_fSendCacheHeaders)
            {
                if (FAILED(hr = pResponse->SetHeaderByReference(
                                    HttpHeaderExpires,
                                    sm_pstrExpiresHeader->QueryStr(),
                                    sm_pstrExpiresHeader->QueryCCH())) ||
                    FAILED(hr = pResponse->SetHeaderByReference(
                                    HttpHeaderCacheControl,
                                    sm_pstrCacheControlHeader->QueryStr(),
                                    sm_pstrCacheControlHeader->QueryCCH())))
                {
                    pCompFile->DereferenceCacheEntry();
                    return hr;
                }
            }

            if (FAILED(hr = pResponse->SetHeaderByReference(
                                           HttpHeaderVary,
                                           "Accept-Encoding", 15)))
            {
                pCompFile->DereferenceCacheEntry();
                return hr;
            }

            pW3Context->SetDoneWithCompression();

            //
            // Change the cache entry to point to the new file and close
            // the original file
            //
            *ppOpenFile = pCompFile;
            pOrigFile->DereferenceCacheEntry();

            return S_OK;
        }

        //
        // We found a scheme, but we don't have a matching file for it.
        // Remember whether this was the first matching scheme that
        // supports on-demand compression.  In the event that we do not
        // find any acceptable files, we'll attempt to do an on-demand
        // compression for this file so that future requests get a
        // compressed version.
        //

        if (firstOnDemandScheme == NULL &&
            scheme->m_fDoOnDemandCompression)
        {
            firstOnDemandScheme = scheme;
        }

        //
        // Loop to see if there is another scheme that is supported
        // by both client and server.
        //
    }

    if (sm_fDoOnDemandCompression && firstOnDemandScheme != NULL)
    {
        //
        // if we are here means scheme was found but no compressed 
        // file matching any scheme. So schedule file to compress
        //
        QueueCompressFile(firstOnDemandScheme,
                          *pstrPhysical);
    }

    //
    // No static compression for this request, will try dynamic compression
    // if so configured while sending response
    //
    return S_OK;
}


// static
VOID HTTP_COMPRESSION::FindMatchingSchemes(
    IN  CHAR * pszAcceptEncoding,
    IN  LPWSTR pszExtension,
    IN  COMPRESSION_TO_PERFORM performCompr,
    OUT DWORD  matchingSchemes[],
    OUT DWORD *pdwClientCompressionCount)
{
    struct
    {
        LPSTR schemeName;
        float quality;
    } parsedAcceptEncoding[MAX_SERVER_SCHEMES];
    DWORD NumberOfParsedSchemes = 0;

    //
    // First parse the Accept-Encoding header
    //
    BOOL fAddStar = FALSE;
    while (*pszAcceptEncoding != '\0')
    {
        LPSTR schemeEnd;
        BOOL fStar = FALSE;

        while (*pszAcceptEncoding == ' ')
        {
            pszAcceptEncoding++;
        }

        if (isalnum(*pszAcceptEncoding))
        {
            parsedAcceptEncoding[NumberOfParsedSchemes].schemeName =
                pszAcceptEncoding;
            parsedAcceptEncoding[NumberOfParsedSchemes].quality = 1;

            while (isalnum(*pszAcceptEncoding))
            {
                pszAcceptEncoding++;
            }

            // Mark the end of the scheme name
            schemeEnd = pszAcceptEncoding;
        }
        else if (*pszAcceptEncoding == '*')
        {
            fStar = TRUE;
            parsedAcceptEncoding[NumberOfParsedSchemes].quality = 1;

            pszAcceptEncoding++;
        }
        else
        {
            // incorrect syntax
            break;
        }

        while (*pszAcceptEncoding == ' ')
        {
            pszAcceptEncoding++;
        }

        if (*pszAcceptEncoding == ';')
        {
            // quality specifier: looks like q=0.7
            pszAcceptEncoding++;

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            if (*pszAcceptEncoding == 'q')
            {
                pszAcceptEncoding++;
            }
            else
            {
                break;
            }

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            if (*pszAcceptEncoding == '=')
            {
                pszAcceptEncoding++;
            }
            else
            {
                break;
            }

            while (*pszAcceptEncoding == ' ')
            {
                pszAcceptEncoding++;
            }

            parsedAcceptEncoding[NumberOfParsedSchemes].quality =
                atof(pszAcceptEncoding);

            while (*pszAcceptEncoding && *pszAcceptEncoding != ',')
            {
                pszAcceptEncoding++;
            }
        }

        if (*pszAcceptEncoding == ',')
        {
            pszAcceptEncoding++;
        }

        if (fStar)
        {
            //
            // A star with non-zero quality means that all schemes are
            // acceptable except those explicitly unacceptable
            //
            if (parsedAcceptEncoding[NumberOfParsedSchemes].quality != 0)
            {
                fAddStar = TRUE;
            }
        }
        else
        {
            *schemeEnd = '\0';
            NumberOfParsedSchemes++;
            if (NumberOfParsedSchemes >= MAX_SERVER_SCHEMES)
            {
                break;
            }
        }
    }

    //
    // Now sort by quality
    //
    LPSTR tempName;
    float tempQuality;
    for (DWORD i=0; i<NumberOfParsedSchemes; i++)
    {
        for (DWORD j=i+1; j<NumberOfParsedSchemes; j++)
        {
            if (parsedAcceptEncoding[j].quality <
                parsedAcceptEncoding[i].quality)
            {
                tempName = parsedAcceptEncoding[i].schemeName;
                parsedAcceptEncoding[i].schemeName = parsedAcceptEncoding[j].schemeName;
                parsedAcceptEncoding[j].schemeName = tempName;

                tempQuality = parsedAcceptEncoding[i].quality;
                parsedAcceptEncoding[i].quality = parsedAcceptEncoding[j].quality;
                parsedAcceptEncoding[j].quality = tempQuality;
            }
        }
    }

    //
    // Now convert the names to indexes into actual schemes
    //
    BOOL fAddedScheme[MAX_SERVER_SCHEMES];
    for (i=0; i<sm_dwNumberOfSchemes; i++)
    {
        fAddedScheme[i] = FALSE;
    }

    DWORD dwNumberOfActualSchemes = 0;
    for (i=0; i<NumberOfParsedSchemes; i++)
    {
        //
        // Find this scheme
        //
        for (DWORD j=0; j<sm_dwNumberOfSchemes; j++)
        {
            if (!fAddedScheme[j] &&
                !_stricmp(parsedAcceptEncoding[i].schemeName,
                         sm_pCompressionSchemes[j]->
                         m_straCompressionSchemeName.QueryStr()))
            {
                // found a match
                fAddedScheme[j] = TRUE;

                if (parsedAcceptEncoding[i].quality == 0)
                {
                    break;
                }

                //
                // Check if the given scheme does the required kind of
                // compression.  Also, check that either there is no list
                // of restricted extensions or that the given file extension
                // matches one in the list
                //
                if (performCompr == DO_STATIC_COMPRESSION)
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoStaticCompression ||
                        (sm_pCompressionSchemes[j]->m_mszFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszFileExtensions.FindString(pszExtension))))
                    {
                        break;
                    }
                }
                else
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoDynamicCompression ||
                        (sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.FindString(pszExtension))))
                    {
                        break;
                    }
                }

                matchingSchemes[dwNumberOfActualSchemes++] = j;
                break;
            }
        }
    }

    //
    // If * was specified, add all unadded applicable schemes
    //
    if (fAddStar)
    {
        for (DWORD j=0; j<sm_dwNumberOfSchemes; j++)
        {
            if (!fAddedScheme[j])
            {
                fAddedScheme[j] = TRUE;

                //
                // Check if the given scheme does the required kind of
                // compression.  Also, check that either there is no list
                // of restricted extensions or that the given file extension
                // matches one in the list
                //
                if (performCompr == DO_STATIC_COMPRESSION)
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoStaticCompression ||
                        (sm_pCompressionSchemes[j]->m_mszFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszFileExtensions.FindString(pszExtension))))
                    {
                        continue;
                    }
                }
                else
                {
                    if (!sm_pCompressionSchemes[j]->m_fDoDynamicCompression ||
                        (sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.QueryStringCount() &&
                         (!pszExtension ||
                          !sm_pCompressionSchemes[j]->m_mszScriptFileExtensions.FindString(pszExtension))))
                    {
                        continue;
                    }
                }

                matchingSchemes[dwNumberOfActualSchemes++] = j;
            }
        }
    }

    *pdwClientCompressionCount = dwNumberOfActualSchemes;
}


// static
HRESULT HTTP_COMPRESSION::ConvertPhysicalPathToCompressedPath(
    IN COMPRESSION_SCHEME *scheme,
    IN STRU  *pstrPhysicalPath,
    OUT STRU *pstrCompressedPath)
/*++
  Routine Description:
    Builds a string that has the directory for the specified compression
    scheme, followed by the file name with all slashes and colons
    converted to underscores.  This allows for a flat directory which
    contains all the compressed files.

Arguments:
    Scheme - the compression scheme to use.

    pstrPhysicalPath - the physical file name that we want to convert.

    pstrCompressedPath - the resultant string.

  Return Value:
    HRESULT
--*/

{
    HRESULT hr;

    EnterCriticalSection(&sm_CompressionDirectoryLock);

    hr = pstrCompressedPath->Copy(scheme->m_strFilePrefix);

    LeaveCriticalSection(&sm_CompressionDirectoryLock);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Copy over the actual file name, converting slashes and colons
    // to underscores.
    //

    DWORD cchPathLength = pstrCompressedPath->QueryCCH();
    if (FAILED(hr = pstrCompressedPath->Append(*pstrPhysicalPath)))
    {
        return hr;
    }

    for (LPWSTR s = pstrCompressedPath->QueryStr() + cchPathLength;
         *s != L'\0';
         s++)
    {
        if (*s == L'\\' || *s == L':')
        {
            *s = L'^';
        }
    }

    return S_OK;
}


BOOL HTTP_COMPRESSION::CheckForExistenceOfCompressedFile(
    IN  W3_FILE_INFO  *pOrigFile,
    IN  STRU          *pstrFileName,
    OUT W3_FILE_INFO **ppCompFile,
    IN  BOOL           fDeleteAllowed)
{
    HRESULT                 hr;
    FILE_CACHE_USER         fileUser;
    
    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
    
    hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                        *pstrFileName,
                                        NULL,
                                        &fileUser,
                                        TRUE,
                                        ppCompFile ); 
    if (FAILED(hr))
    {
        return FALSE;
    }

    //
    // So far so good.  Determine whether the compressed version
    // of the file is out of date.  If the compressed file is
    // out of date, delete it and remember that we did not get a
    // good match.  Note that there's really nothing we can do
    // if the delete fails, so ignore any failures from it.
    //
    // The last write times must differ by exactly two seconds
    // to constitute a match.  The two-second difference results
    // from the fact that we set the time on the compressed file
    // to be two seconds behind the uncompressed version in
    // order to ensure unique ETag: header values.
    //

    W3_FILE_INFO *pCompFile = *ppCompFile;
    LARGE_INTEGER compressedFileSize;
    FILETIME compressedFileTime;
    LARGE_INTEGER *pli = (LARGE_INTEGER *)&compressedFileTime;
    FILETIME originalFileTime;
    BOOL success = FALSE;

    pCompFile->QuerySize(&compressedFileSize);
    pCompFile->QueryLastWriteTime(&compressedFileTime);
    pOrigFile->QueryLastWriteTime(&originalFileTime);

    pli->QuadPart += 2*10*1000*1000;

    LONG timeResult = CompareFileTime(&compressedFileTime, &originalFileTime);
    if ( timeResult != 0 )
    {
        //
        // That check failed.  If the compression directory is
        // on a FAT volume, then see if they are within two
        // seconds of one another.  If they are, then consider
        // things valid.  We have to do this because FAT file
        // times get truncated in weird ways sometimes: despite
        // the fact that we request setting the file time
        // different by an exact amount, it gets rounded
        // sometimes.
        //

        if (sm_fCompressionVolumeIsFat) 
        {
            pli->QuadPart -= 2*10*1000*1000 + 1;
            timeResult += CompareFileTime(&compressedFileTime, &originalFileTime);
        }
    }

    if (timeResult == 0) 
    {
        //
        // The filetime passed, also check if ACLs are the same
        //
        PSECURITY_DESCRIPTOR compressedFileAcls =
            pCompFile->QuerySecDesc();
        PSECURITY_DESCRIPTOR originalFileAcls =
            pOrigFile->QuerySecDesc();

        if (compressedFileAcls != NULL && originalFileAcls != NULL )
        {
            DWORD compressedFileAclsLen =
                GetSecurityDescriptorLength(compressedFileAcls);
            DWORD originalFileAclsLen =
                GetSecurityDescriptorLength(originalFileAcls);

            if (originalFileAclsLen == compressedFileAclsLen)
            {
                SECURITY_DESCRIPTOR_CONTROL compressedFileCtl =
                    ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control;
                SECURITY_DESCRIPTOR_CONTROL originalFileCtl =
                    ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control;

                ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control &=
                    ACL_CLEAR_BIT_MASK;
                ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control &=
                    ACL_CLEAR_BIT_MASK;

                success = (memcmp((PVOID)originalFileAcls,(PVOID)compressedFileAcls, originalFileAclsLen) == 0);

                ((PISECURITY_DESCRIPTOR)compressedFileAcls)->Control =
                    compressedFileCtl;
                ((PISECURITY_DESCRIPTOR)originalFileAcls)->Control =
                    originalFileCtl;
            }
        }
    }

    //
    // The original file has changed since the compression, close this cache
    // entry
    //
    if (!success)
    {
        pCompFile->DereferenceCacheEntry();
        *ppCompFile = NULL;
    }

    //
    // If the compressed file exists but is stale, queue for deletion
    //
    if (!success && fDeleteAllowed)
    {
        // don't delete if call came from compression thread because then
        // delete request will be in a queue after compression request
        // and will delete a file which was just moment ago compressed
        COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;
        if (WorkItem == NULL)
        {
            return FALSE;
        }

        WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_DELETE;
        if (FAILED(WorkItem->strPhysicalPath.Copy(*pstrFileName)))
        {
            delete WorkItem;
            return FALSE;
        }

        if (!QueueWorkItem(WorkItem,
                           FALSE,
                           FALSE))
        {
            delete WorkItem;
            return FALSE;
        }

        //
        // If we are configured to limit the amount of disk
        // space we use for compressed files, then, in a
        // thread-safe manner, update the tally of disk
        // space used by compression.
        //

        if (sm_fDoDiskSpaceLimiting) 
        {
            InterlockedExchangeAdd((PLONG)&sm_dwCurrentDiskSpaceUsage,
                                   -1 * compressedFileSize.LowPart);
        }
    }

    return success;
}


BOOL HTTP_COMPRESSION::QueueCompressFile(
    IN COMPRESSION_SCHEME *scheme,
    IN STRU &strPhysicalPath)
/*++
  Routine Description:
    Queues a compress file request to the compression thread.

Arguments:
    Scheme - a pointer to the compression scheme to use in compressing
        the file.

    pszPhysicalPath - the current physical path to the file.

Return Value:
    TRUE if the queuing succeeded.
--*/
{
    COMPRESSION_WORK_ITEM *WorkItem = new COMPRESSION_WORK_ITEM;
    if ( WorkItem == NULL )
    {
        return FALSE;
    }

    //
    // Initialize this structure with the necessary information.
    //
    WorkItem->WorkItemType = COMPRESSION_WORK_ITEM_COMPRESS;
    WorkItem->scheme = scheme;
    if (FAILED(WorkItem->strPhysicalPath.Copy(strPhysicalPath)))
    {
        delete WorkItem;
        return FALSE;
    }

    //
    // Queue a work item and we're done.
    //
    if (!QueueWorkItem(WorkItem,
                       FALSE,
                       FALSE))
    {
        delete WorkItem;
        return FALSE;
    }

    return TRUE;
}


VOID HTTP_COMPRESSION::CompressFile(IN COMPRESSION_SCHEME *scheme,
                                    IN STRU               &strPhysicalPath)
/*++
  Routine Description:
    This routine does the real work of compressing a static file and
    storing it to the compression directory with a unique name.

  Arguments:
    Context - a pointer to context information for the request,
        including the compression scheme to use for compression and the
        physical path to the file that we need to compress.

Return Value:
    None.  If the compression fails, we just press on and attempt to
    compress the file the next time it is requested.
--*/
{
    HANDLE                  hOriginalFile = NULL;
    HANDLE                  hCompressedFile = NULL;
    STACK_STRU            ( compressedFileName, 256);
    STACK_STRU            ( realCompressedFileName, 256);
    BOOL                    success = FALSE;
    DWORD                   cbIo = 0;
    DWORD                   bytesCompressed = 0;
    SECURITY_ATTRIBUTES     securityAttributes;
    DWORD                   totalBytesWritten = 0;
    BOOL                    usedScheme = FALSE;
    LARGE_INTEGER          *pli = NULL;
    W3_FILE_INFO           *pofiOriginalFile = NULL;
    W3_FILE_INFO           *pofiCompressedFile = NULL;
    FILETIME                originalFileTime;
    PSECURITY_DESCRIPTOR    originalFileAcls = NULL;
    DWORD                   originalFileAclsLen = 0;
    OVERLAPPED              ovlForRead;
    DWORD                   readStatus;
    ULARGE_INTEGER          readOffset;
    SYSTEMTIME              systemTime;
    FILETIME                fileTime;
    WCHAR                   pszPid[16];
    DWORD                   dwPid;
    BYTE                   *pCachedFileBuffer;
    BOOL                    fHaveCachedFileBuffer = FALSE;
    DWORD                   dwOrigFileSize;
    LARGE_INTEGER           liOrigFileSize;
    DIRMON_CONFIG           dirConfig;
    FILE_CACHE_USER         fileUser;

    //
    // Determine the name of the file to which we will write compression
    // file data.  Note that we use a bogus file name initially: this
    // allows us to rename it later and ensure an atomic update to the
    // file system, thereby preventing other threads from returning the
    // compressed file when it has only been partially written.
    //
    // If the caller specified a specific output file name, then use that
    // instead of the calculated name.
    //
    if (FAILED(ConvertPhysicalPathToCompressedPath(
                   scheme,
                   &strPhysicalPath,
                   &realCompressedFileName)))
    {
        goto exit;
    }

    dwPid = GetCurrentProcessId();
    _itow(dwPid, pszPid, 10);
    if (FAILED(compressedFileName.Copy(realCompressedFileName)) ||
        FAILED(compressedFileName.Append(pszPid)) ||
        FAILED(compressedFileName.Append(TEMP_COMP_FILE_SUFFIX)))
    {
        goto exit;
    }
    
    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );

    if (FAILED(g_pW3Server->QueryFileCache()->GetFileInfo(
                                 strPhysicalPath,
                                 NULL,
                                 &fileUser,
                                 TRUE,
                                 &pofiOriginalFile)))                  
    {
        goto exit;
    }

    success = CheckForExistenceOfCompressedFile(pofiOriginalFile,
                                                &realCompressedFileName,
                                                &pofiCompressedFile,
                                                FALSE);

    if (!success)
    {
        originalFileAcls = pofiOriginalFile->QuerySecDesc();

        if (originalFileAcls == NULL)
        {
            goto exit;
        }

        originalFileAclsLen = GetSecurityDescriptorLength(originalFileAcls);

        pofiOriginalFile->QueryLastWriteTime(&originalFileTime);

        pCachedFileBuffer = pofiOriginalFile->QueryFileBuffer();

        pofiOriginalFile->QuerySize(&liOrigFileSize);
        dwOrigFileSize = liOrigFileSize.LowPart;

        securityAttributes.nLength = originalFileAclsLen;
        securityAttributes.lpSecurityDescriptor = originalFileAcls;
        securityAttributes.bInheritHandle = FALSE;

        //
        // Do the actual file open.  We open the file for exclusive access,
        // and we assume that the file will not already exist.
        //

        hCompressedFile = CreateFile(
                            compressedFileName.QueryStr(),
                            GENERIC_WRITE,
                            0,
                            &securityAttributes,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hCompressedFile == INVALID_HANDLE_VALUE)
        {
            goto exit;
        }

        //
        // Loop through the file data, reading it, then compressing it, then
        // writing out the compressed data.
        //

        if (pCachedFileBuffer)
        {
            fHaveCachedFileBuffer = TRUE;
        }
        else
        {
            hOriginalFile = pofiOriginalFile->QueryFileHandle();
            if ( hOriginalFile == INVALID_HANDLE_VALUE )
            {
                hOriginalFile = NULL;
                goto exit;
            }
            
            ovlForRead.Offset     = 0;
            ovlForRead.OffsetHigh = 0;
            ovlForRead.hEvent     = NULL; 
            readOffset.QuadPart   = 0;
        }

        while (TRUE)
        {
            if (!fHaveCachedFileBuffer)
            {
                success = ReadFile(hOriginalFile, sm_pIoBuffer,
                                   sm_dwIoBufferSize, &cbIo, &ovlForRead);

                if (!success)
                {
                    switch (readStatus = GetLastError())     
                    {
                    case ERROR_HANDLE_EOF:
                        cbIo = 0;
                        success = TRUE;
                        break;

                    case ERROR_IO_PENDING:
                        success = GetOverlappedResult(hOriginalFile, &ovlForRead, &cbIo, TRUE);
                        if (!success)
                        {
                            switch (readStatus = GetLastError())
                            {
                            case ERROR_HANDLE_EOF:
                                cbIo = 0;
                                success = TRUE;
                                break;

                            default:
                                break;
                            }
                        }
                        break;

                    default:
                        break;
                    }
                }

                if (!success)
                {
                    goto exit;
                }

                if (cbIo)
                {
                    readOffset.QuadPart += cbIo;
                    ovlForRead.Offset = readOffset.LowPart;
                    ovlForRead.OffsetHigh = readOffset.HighPart;
                }
                else
                {
                    //
                    // ReadFile returns zero bytes read at the end of the
                    // file.  If we hit that, then break out of this loop.
                    //

                    break;
                }
            }

            //
            // Remember that we used this compression scheme and that we
            // will need to reset it on exit.
            //

            usedScheme = TRUE;

            //
            // Write the compressed data to the output file.
            //

            success = CompressAndWriteData(
                          scheme,
                          fHaveCachedFileBuffer ? pCachedFileBuffer : sm_pIoBuffer,
                          fHaveCachedFileBuffer ? dwOrigFileSize : cbIo,
                          &totalBytesWritten,
                          hCompressedFile
                          );
            if (!success)
            {
                goto exit;
            }

            if (fHaveCachedFileBuffer)
            {
                break;
            }
        } // end while(TRUE)

        if (!success)
        {
            goto exit;
        }

        //
        // Tell the compression DLL that we're done with this file.  It may
        // return a last little bit of data for us to write to the the file.
        // This is because most compression schemes store an end-of-file
        // code in the compressed data stream.  Using "0" as the number of
        // bytes to compress handles this case.
        //

        success = CompressAndWriteData(
                      scheme,
                      NULL,
                      0,
                      &totalBytesWritten,
                      hCompressedFile
                      );
        if (!success)
        {
            goto exit;
        }

        //
        // Set the compressed file's creation time to be identical to the
        // original file.  This allows a more granular test for things being
        // out of date.  If we just did a greater-than-or-equal time
        // comparison, then copied or renamed files might not get registered
        // as changed.
        //

        //
        // Subtract two seconds from the file time to get the file time that
        // we actually want to put on the file.  We do this to make sure
        // that the server will send a different Etag: header for the
        // compressed file than for the uncompressed file, and the server
        // uses the file time to calculate the Etag: it uses.
        //
        // We set it in the past so that if the original file changes, it
        // should never happen to get the same value as the compressed file.
        // We pick two seconds instead of one second because the FAT file
        // system stores file times at a granularity of two seconds.
        //

        pli = (PLARGE_INTEGER)(&originalFileTime);
        pli->QuadPart -= 2*10*1000*1000;

        success = SetFileTime(
                      hCompressedFile,
                      NULL,
                      NULL,
                      &originalFileTime
                      );
        if (!success)
        {
            goto exit;
        }


        CloseHandle(hCompressedFile);
        hCompressedFile = NULL;

        //
        // Almost done now.  Just rename the file to the proper name.
        //

        success = MoveFileEx(
                      compressedFileName.QueryStr(),
                      realCompressedFileName.QueryStr(),
                      MOVEFILE_REPLACE_EXISTING);
        if (!success)
        {
            goto exit;
        }

        //
        // If we are configured to limit the amount of disk space we use for
        // compressed files, then update the tally of disk space used by
        // compression.  If the value is too high, then free up some space.
        //
        // Use InterlockedExchangeAdd to update this value because other
        // threads may be deleting files from the compression directory
        // because they have gone out of date.
        //

        if (sm_fDoDiskSpaceLimiting)
        {
            InterlockedExchangeAdd((PLONG)&sm_dwCurrentDiskSpaceUsage,
                                   totalBytesWritten);

            if (sm_dwCurrentDiskSpaceUsage > sm_dwMaxDiskSpaceUsage)
            {
                FreeDiskSpace();
            }
        }
    }

    //
    // Free the context structure and return.
    //

exit:
    if (pofiOriginalFile != NULL) 
    {
        pofiOriginalFile->DereferenceCacheEntry();
        pofiOriginalFile = NULL;
    }

    if (pofiCompressedFile != NULL) 
    {
        pofiCompressedFile->DereferenceCacheEntry();
        pofiCompressedFile = NULL;
    }

    //
    // Reset the compression context for reuse the next time through.
    // This is more optimal than recreating the compression context for
    // every file--it avoids allocations, etc.
    //
    if (usedScheme)
    {
        scheme->m_pfnResetCompression(scheme->m_pCompressionContext);
    }

    if (hCompressedFile != NULL)
    {
        CloseHandle(hCompressedFile);
    }

    if (!success)
    {
        DeleteFile(compressedFileName.QueryStr());
    }

    return;
}


VOID HTTP_COMPRESSION::FreeDiskSpace()
/*++
  Routine Description:
    If disk space limiting is in effect, this routine frees up the
    oldest compressed files to make room for new files.

  Arguments:
    None.

  Return Value:
    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.
--*/
{
    WIN32_FIND_DATA  **filesToDelete;
    WIN32_FIND_DATA *currentFindData;
    WIN32_FIND_DATA *findDataHolder;
    BOOL success;
    DWORD i;
    HANDLE hDirectory = INVALID_HANDLE_VALUE;
    STACK_STRU (strFile, MAX_PATH);

    //
    // Allocate space to hold the array of files to delete and the
    // WIN32_FIND_DATA structures that we will need.  We will find the
    // least-recently-used files in the compression directory to delete.
    // The reason we delete multpiple files is to reduce the number of
    // times that we have to go through the process of freeing up disk
    // space, since this is a fairly expensive operation.
    //

    filesToDelete = (WIN32_FIND_DATA **)LocalAlloc(
                        LMEM_FIXED,
                        sizeof(filesToDelete)*sm_dwFilesDeletedPerDiskFree +
                        sizeof(WIN32_FIND_DATA)*(sm_dwFilesDeletedPerDiskFree + 1));
    if (filesToDelete == NULL)
    {
        return;
    }

    //
    // Parcel out the allocation to the various uses.  The initial
    // currentFindData will follow the array, and then the
    // WIN32_FIND_DATA structures that start off in the sorted array.
    // Initialize the last access times of the entries in the array to
    // 0xFFFFFFFF so that they are considered recently used and quickly
    // get tossed from the array with real files.
    //

    currentFindData = (PWIN32_FIND_DATA)(filesToDelete + sm_dwFilesDeletedPerDiskFree);

    for (i = 0; i < sm_dwFilesDeletedPerDiskFree; i++)
    {
        filesToDelete[i] = currentFindData + 1 + i;
        filesToDelete[i]->ftLastAccessTime.dwLowDateTime = 0xFFFFFFFF;
        filesToDelete[i]->ftLastAccessTime.dwHighDateTime = 0x7FFFFFFF;
    }

    //
    // Start enumerating the files in the compression directory.  Do
    // this while holding the lock that protects the
    // CompressionDirectoryWildcard variable, since it is possible for
    // that string pointer to get freed if there is a metabase
    // configuration change.  Note that holding the critical section for
    // a long time is not a perf issue because, in general, only this
    // thread ever acquires this lock, except for the rare configuration
    // change.
    //

    EnterCriticalSection(&sm_CompressionDirectoryLock);

    STACK_STRU (CompDirWildcard, 512);

    if (FAILED(CompDirWildcard.Copy(*sm_pstrCompressionDirectory)) ||
        FAILED(CompDirWildcard.Append(L"\\", 1)) ||
        FAILED(CompDirWildcard.Append(COMP_FILE_PREFIX)) ||
        FAILED(CompDirWildcard.Append(L"*", 1)))
    {
        LeaveCriticalSection(&sm_CompressionDirectoryLock);
        goto exit;
    }

    hDirectory = FindFirstFile(CompDirWildcard.QueryStr(), currentFindData);

    LeaveCriticalSection(&sm_CompressionDirectoryLock);

    if (hDirectory == INVALID_HANDLE_VALUE)
    {
        goto exit;
    }

    while (TRUE)
    {
        //
        // Ignore this entry if it is a directory.
        //

        if (!(currentFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //
            // Walk down the sorted array of files, comparing the time
            // of this file against the times of the files currently in
            // the array.  We need to find whether this file belongs in
            // the array at all, and, if so, where in the array it
            // belongs.
            //

            for (i = 0;
                 i < sm_dwFilesDeletedPerDiskFree &&
                 CompareFileTime(&currentFindData->ftLastAccessTime,
                                 &filesToDelete[i]->ftLastAccessTime) > 0;
                 i++)
            {}

            //
            // If this file needs to get inserted in the array, put it
            // in and move the other entries forward.
            //
            while (i < sm_dwFilesDeletedPerDiskFree)
            {
                findDataHolder = currentFindData;
                currentFindData = filesToDelete[i];
                filesToDelete[i] = findDataHolder;

                i++;
            }
        }

        //
        // Get the next file in the directory.
        //

        if (!FindNextFile(hDirectory, currentFindData))
        {
            break;
        }
    }

    //
    // Now walk through the array of files to delete and get rid of
    // them.
    //

    for (i = 0; i < sm_dwFilesDeletedPerDiskFree; i++)
    {
        if (filesToDelete[i]->ftLastAccessTime.dwHighDateTime != 0x7FFFFFFF)
        {
            if (FAILED(strFile.Copy(*sm_pstrCompressionDirectory)) ||
                FAILED(strFile.Append(L"\\", 1)) ||
                FAILED(strFile.Append(filesToDelete[i]->cFileName)))
            {
                goto exit;
            }

            if (DeleteFile(strFile.QueryStr()))
            {
                InterlockedExchangeAdd((LPLONG)&sm_dwCurrentDiskSpaceUsage,
                                       -(LONG)filesToDelete[i]->nFileSizeLow);
            }
        }
    }

exit:
    if (filesToDelete)
    {
        LocalFree(filesToDelete);
    }

    if (hDirectory != INVALID_HANDLE_VALUE)
    {
        FindClose(hDirectory);
    }

    return;
}


BOOL HTTP_COMPRESSION::CompressAndWriteData(
    COMPRESSION_SCHEME *scheme,
    PBYTE InputBuffer,
    DWORD BytesToCompress,
    PDWORD BytesWritten,
    HANDLE hCompressedFile)
/*++
  Routine Description:
    Takes uncompressed data, compresses it with the specified compression
    scheme, and writes the result to the specified file.

  Arguments:
    Scheme - the compression scheme to use.

    InputBuffer - the data we need to compress.

    BytesToCompress - the size of the input buffer, or 0 if we should
        flush the compression buffers to the file at the end of the
        input file.  Note that this routine DOES NOT handle compressing
        a zero-byte file; we assume that the input file has some data.

    BytesWritten - the number of bytes written to the output file.

    hCompressedFile - a handle to the file to which we should write the
        compressed results.

  Return Value:
    None.  This routine makes a best-effort attempt to free space, but
    if it doesn't work, oh well.
--*/
{
    DWORD inputBytesUsed;
    DWORD bytesCompressed;
    HRESULT hResult;
    BOOL keepGoing;
    BOOL success;
    DWORD cbIo;

    if (sm_fIsTerminating)
    {
        return FALSE;
    }

    //
    // Perform compression on the actual file data.  Note that it is
    // possible that the compressed data is actually larger than the
    // input data, so we might need to call the compression routine
    // multiple times.
    //

    do
    {
        bytesCompressed = sm_dwCompressionBufferSize;

        hResult = scheme->m_pfnCompress(
                      scheme->m_pCompressionContext,
                      InputBuffer,
                      BytesToCompress,
                      sm_pCompressionBuffer,
                      sm_dwCompressionBufferSize,
                      (PLONG)&inputBytesUsed,
                      (PLONG)&bytesCompressed,
                      scheme->m_dwOnDemandCompressionLevel);

        if (FAILED(hResult))
        {
            return FALSE;
        }

        if (hResult == S_OK && BytesToCompress == 0)
        {
            keepGoing = TRUE;
        }
        else
        {
            keepGoing = FALSE;
        }

        //
        // If the compressor gave us any data, then write the result to
        // disk.  Some compression schemes buffer up data in order to
        // perform better compression, so not every compression call
        // will result in output data.
        //

        if (bytesCompressed > 0)
        {
            if (!WriteFile(hCompressedFile,
                           sm_pCompressionBuffer,
                           bytesCompressed,
                           &cbIo,
                           NULL))
            {
                return FALSE;
            }

            *BytesWritten += cbIo;
        }

        //
        // Update the number of input bytes that we have compressed
        // so far, and adjust the input buffer pointer accordingly.
        //

        BytesToCompress -= inputBytesUsed;
        InputBuffer += inputBytesUsed;
    }
    while ( BytesToCompress > 0 || keepGoing );

    return TRUE;
}


BOOL DoesCacheControlNeedMaxAge(IN PCHAR CacheControlHeaderValue)
/*++

Routine Description:

    This function determines whether the Cache-Control header on a
    compressed response needs to have the max-age directive added.
    If there is already a max-age, or if there is a no-cache directive,
    then we should not add max-age.

Arguments:

    CacheControlHeaderValue - the value of the cache control header to
        scan.  The string should be zero-terminated.

Return Value:

    TRUE if we need to add max-age; FALSE if we should not add max-age.

--*/

{
    if (strstr(CacheControlHeaderValue, "max-age"))
    {
        return FALSE;
    }

    PCHAR s;
    while (s = strstr(CacheControlHeaderValue, "no-cache"))
    {
        //
        // If it is a no-cache=foo then it only refers to a specific header
        // Continue
        //

        if (s[8] != '=')
        {
            return FALSE;
        }

        CacheControlHeaderValue = s + 8;
    }

    //
    // We didn't find any directives that would prevent us from adding
    // max-age.
    //

    return TRUE;
}


// static
HRESULT HTTP_COMPRESSION::OnSendResponse(
    IN  W3_CONTEXT *pW3Context,
    IN  BOOL        fMoreData)
{
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();

    //
    // If compression is not initialized, return
    //
    if (!sm_fHttpCompressionInitialized)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If Response status is not 200 (let us not try compressing 206, 3xx or
    // error responses), return
    //
    if (pResponse->QueryStatusCode() != HttpStatusOk.statusCode &&
        pResponse->QueryStatusCode() != HttpStatusMultiStatus.statusCode)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the client has not sent an Accept-Encoding header, or an empty
    // Accept-Encoding header, return
    //
    CHAR *pszAcceptEncoding = pRequest->GetHeader(HttpHeaderAcceptEncoding);
    if (pszAcceptEncoding == NULL || *pszAcceptEncoding == L'\0')
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Don't compress for TRACEs
    //
    HTTP_VERB VerbType = pW3Context->QueryRequest()->QueryVerbType();
    if (VerbType == HttpVerbTRACE ||
        VerbType == HttpVerbTRACK)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for 1.0, and version is not 1.1,
    // return
    //
    if (sm_fNoCompressionForHttp10 &&
        ((pRequest->QueryVersion().MajorVersion == 0) ||
         ((pRequest->QueryVersion().MajorVersion == 1) &&
          (pRequest->QueryVersion().MinorVersion == 0))))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If we are configured to not compress for proxies and it is a proxy
    // request, return
    //
    if (sm_fNoCompressionForProxies && pRequest->IsProxyRequest())
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // If the response already has a Content-Encoding header, return
    //
    if (pResponse->GetHeader(HttpHeaderContentEncoding))
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // Now see if we have any matching scheme
    //
    STACK_STRA( strAcceptEncoding, 512);
    HRESULT hr;
    if (FAILED(hr = strAcceptEncoding.Copy(pszAcceptEncoding)))
    {
        return hr;
    }

    STRU *pstrPhysical = pW3Context->QueryUrlContext()->QueryPhysicalPath();
    LPWSTR pszExtension = wcsrchr(pstrPhysical->QueryStr(), L'.');
    if (pszExtension != NULL)
    {
        pszExtension++;
    }

    DWORD dwClientCompressionCount;
    DWORD matchingSchemes[MAX_SERVER_SCHEMES];
    //
    // Find out all schemes which will compress for this url
    //
    FindMatchingSchemes(strAcceptEncoding.QueryStr(),
                        pszExtension,
                        DO_DYNAMIC_COMPRESSION,
                        matchingSchemes,
                        &dwClientCompressionCount);
    if (dwClientCompressionCount == 0)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }

    //
    // All tests passed, we are GO for dynamic compression
    //
    COMPRESSION_CONTEXT *pCompressionContext = new COMPRESSION_CONTEXT;
    if (pCompressionContext == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    pW3Context->SetCompressionContext(pCompressionContext);
    pCompressionContext->m_pScheme = sm_pCompressionSchemes[matchingSchemes[0]];

    PCHAR xferEncoding = pResponse->GetHeader(HttpHeaderTransferEncoding);
    if (xferEncoding &&
        _stricmp(xferEncoding, "chunked") == 0)
    {
        pCompressionContext->m_fTransferChunkEncoded = TRUE;
    }

    //
    // Remove the Content-Length header, set the Content-Encoding, Vary and
    // Transfer-Encoding headers
    //
    if (FAILED(hr = pResponse->SetHeaderByReference(HttpHeaderContentLength,
                                         NULL, 0)) ||
        FAILED(hr = pResponse->SetHeaderByReference(
                        HttpHeaderContentEncoding,
                        pCompressionContext->m_pScheme->m_straCompressionSchemeName.QueryStr(),
                        pCompressionContext->m_pScheme->m_straCompressionSchemeName.QueryCCH())) ||
        FAILED(hr = pResponse->SetHeader(HttpHeaderVary,
                                         "Accept-Encoding", 15,
                                         TRUE)) ||
        FAILED(hr = pResponse->SetHeaderByReference(HttpHeaderTransferEncoding,
                                         "chunked", 7)))
    {
        return hr;
    }

    if (sm_fSendCacheHeaders)
    {
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderExpires,
                            sm_pstrExpiresHeader->QueryStr(),
                            sm_pstrExpiresHeader->QueryCCH())))
        {
            return hr;
        }

        PCHAR cacheControl = pResponse->GetHeader(HttpHeaderCacheControl);
        if (!cacheControl || DoesCacheControlNeedMaxAge(cacheControl))
        {
            if (FAILED(hr = pResponse->SetHeader(
                                HttpHeaderCacheControl,
                                sm_pstrCacheControlHeader->QueryStr(),
                                sm_pstrCacheControlHeader->QueryCCH(),
                                TRUE)))
            {
                return hr;
            }
        }
    }

    //
    // Get a compression context
    //
    if (FAILED(hr = pCompressionContext->m_pScheme->m_pfnCreateCompression(
                        &pCompressionContext->m_pCompressionContext,
                        pCompressionContext->m_pScheme->m_dwCreateFlags)))
    {
        return hr;
    }

    //
    // Ok, done with all the header stuff, now actually start compressing
    // the entity
    //

    if (VerbType == HttpVerbHEAD)
    {
        pCompressionContext->m_fRequestIsHead = TRUE;
    }

    //
    // BUGBUG: UL does not know about compression right now, so
    // disable UL caching for this response
    //
    pW3Context->DisableUlCache();

    return DoDynamicCompression(pW3Context,
                                fMoreData);
}


// static
HRESULT HTTP_COMPRESSION::DoDynamicCompression(
    IN  W3_CONTEXT *pW3Context,
    IN  BOOL        fMoreData)
{
    COMPRESSION_CONTEXT *pCompressionContext = pW3Context->QueryCompressionContext();

    if (pCompressionContext == NULL)
    {
        pW3Context->SetDoneWithCompression();
        return S_OK;
    }
    pCompressionContext->FreeBuffers();

    //
    // Get hold of the response chunks
    //
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    HRESULT hr;
    if (FAILED(hr = pResponse->GetChunks(&pCompressionContext->m_ULChunkBuffer,
                                         &pCompressionContext->m_cULChunks)))
    {
        return hr;
    }

    if (pCompressionContext->m_cULChunks > 0)
    {
        pCompressionContext->m_fOriginalBodyEmpty = FALSE;
    }

    //
    // If the request was a HEAD request and we haven't seen any
    // entity body, no point in going any further (if the output
    // is already suppressed, we do not want to compress it and make it
    // non-empty)
    //
    if (pCompressionContext->m_fRequestIsHead &&
        pCompressionContext->m_fOriginalBodyEmpty)
    {
        return S_OK;
    }

    pCompressionContext->m_cCurrentULChunk = 0;
    pCompressionContext->m_pCurrentULChunk =
        (HTTP_DATA_CHUNK *)pCompressionContext->m_ULChunkBuffer.QueryPtr();
    //
    // Do whatever is necessary to setup the current chunk of response
    // e.g. do an I/O for FileHandle chunk
    //
    if (FAILED(hr = pCompressionContext->SetupCurrentULChunk()))
    {
        return hr;
    }

    BOOL fKeepGoing;
    do
    {
        fKeepGoing = FALSE;

        if (pCompressionContext->m_fTransferChunkEncoded)
        {
            //
            // If the input data is being chunk-transfered, initially,
            // we'll be looking at the chunk header.  This is a hex
            // representation of the number of bytes in this chunk.
            // Translate this number from ASCII to a DWORD and remember
            // it.  Also advance the chunk pointer to the start of the
            // actual data.
            //

            if (FAILED(hr = pCompressionContext->ProcessEncodedChunkHeader()))
            {
                return hr;
            }
        }

        //
        // Try to compress all the contiguous bytes
        //
        DWORD bytesToCompress = 0;
        if (pCompressionContext->m_cCurrentULChunk < pCompressionContext->m_cULChunks)
        {
            bytesToCompress = pCompressionContext->QueryBytesAvailable();
            if (pCompressionContext->m_fTransferChunkEncoded)
            {
                bytesToCompress =
                    min(bytesToCompress,
                        pCompressionContext->m_dwBytesInCurrentEncodedChunk);
            }
        }

        if (!fMoreData || bytesToCompress > 0)
        {
            DWORD inputBytesUsed = 0;
            DWORD bytesCompressed = 0;

            PBYTE compressionBuffer = pCompressionContext->GetNewBuffer();

            hr = pCompressionContext->m_pScheme->m_pfnCompress(
                     pCompressionContext->m_pCompressionContext,
                     bytesToCompress ? pCompressionContext->QueryBytePtr() : NULL,
                     bytesToCompress,
                     compressionBuffer + 6,
                     DYNAMIC_COMPRESSION_BUFFER_SIZE,
                     (PLONG)&inputBytesUsed,
                     (PLONG)&bytesCompressed,
                     pCompressionContext->m_pScheme->m_dwDynamicCompressionLevel);

            if (FAILED(hr))
            {
                return hr;
            }

            if (hr == S_OK)
            {
                fKeepGoing = TRUE;
            }

            if (FAILED(hr =
              pCompressionContext->IncrementPointerInULChunk(inputBytesUsed)))
            {
                return hr;
            }
            if (pCompressionContext->m_fTransferChunkEncoded)
            {
                pCompressionContext->m_dwBytesInCurrentEncodedChunk -=
                    inputBytesUsed;
            }

            DWORD startSendLocation = 8;
            DWORD bytesToSend = 0;

            if (bytesCompressed > 0)
            {
                //
                // Add the CRLF just before and after the chunk data
                //
                compressionBuffer[4] = '\r';
                compressionBuffer[5] = '\n';

                compressionBuffer[bytesCompressed + 6] = '\r';
                compressionBuffer[bytesCompressed + 7] = '\n';

                //
                // Now create the chunk header which is basically the chunk
                // size written out in hex
                //

                if (bytesCompressed < 0x10 )
                {
                    startSendLocation = 3;
                    bytesToSend = 3 + bytesCompressed + 2;
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed);
                }
                else if (bytesCompressed < 0x100)
                {
                    startSendLocation = 2;
                    bytesToSend = 4 + bytesCompressed + 2;
                    compressionBuffer[2] = HEX_TO_ASCII(bytesCompressed >> 4);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
                else if (bytesCompressed < 0x1000)
                {
                    startSendLocation = 1;
                    bytesToSend = 5 + bytesCompressed + 2;
                    compressionBuffer[1] = HEX_TO_ASCII(bytesCompressed >> 8);
                    compressionBuffer[2] = HEX_TO_ASCII((bytesCompressed >> 4) & 0xF);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
                else
                {
                    DBG_ASSERT( bytesCompressed < 0x10000 );

                    startSendLocation = 0;
                    bytesToSend = 6 + bytesCompressed + 2;
                    compressionBuffer[0] = HEX_TO_ASCII(bytesCompressed >> 12);
                    compressionBuffer[1] = HEX_TO_ASCII((bytesCompressed >> 8) & 0xF);
                    compressionBuffer[2] = HEX_TO_ASCII((bytesCompressed >> 4) & 0xF);
                    compressionBuffer[3] = HEX_TO_ASCII(bytesCompressed & 0xF);
                }
            }

            if (!fKeepGoing)
            {
                //
                // If this is the last send, add the trailer 0 length chunk
                //

                memcpy(compressionBuffer + bytesCompressed + 8, "0\r\n\r\n", 5);
                bytesToSend += 5;
            }

            if (!fKeepGoing || bytesCompressed > 0)
            {
                if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                                    compressionBuffer + startSendLocation,
                                    bytesToSend)))
                {
                    return hr;
                }
            }
        }
    }
    while (fKeepGoing);

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::SetupCurrentULChunk()
/*++
  Set up this new chunk so that compression has some bytes to read.  If
  the current chunk is a 0 length chunk or we have reached the end-of-file
  on the file handle, this function will recurse

  Return Value:
    HRESULT
--*/
{
    if (m_cCurrentULChunk >= m_cULChunks)
    {
        return S_OK;
    }

    if (m_pCurrentULChunk->DataChunkType == HttpDataChunkFromMemory)
    {
        if (m_pCurrentULChunk->FromMemory.BufferLength == 0)
        {
            m_cCurrentULChunk++;
            m_pCurrentULChunk++;
            return SetupCurrentULChunk();
        }

        m_fCurrentULChunkFromMemory = TRUE;
        return S_OK;
    }

    // We do not (nor do we plan to) handle filename chunks
    DBG_ASSERT(m_pCurrentULChunk->DataChunkType == HttpDataChunkFromFileHandle);
    m_fCurrentULChunkFromMemory = FALSE;
    if (m_pIoBuffer == NULL)
    {
        m_pIoBuffer = new BYTE[DYNAMIC_COMPRESSION_BUFFER_SIZE];
        if (m_pIoBuffer == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    DWORD bytesToRead =
        (DWORD)min(DYNAMIC_COMPRESSION_BUFFER_SIZE,
                m_pCurrentULChunk->FromFileHandle.ByteRange.Length.QuadPart);

    OVERLAPPED ovl;
    ZeroMemory(&ovl, sizeof ovl);
    ovl.Offset =
        m_pCurrentULChunk->FromFileHandle.ByteRange.StartingOffset.LowPart;
    ovl.OffsetHigh =
        m_pCurrentULChunk->FromFileHandle.ByteRange.StartingOffset.HighPart;
    DWORD bytesRead = 0;

    if (!ReadFile(m_pCurrentULChunk->FromFileHandle.FileHandle,
                  m_pIoBuffer,
                  bytesToRead,
                  &bytesRead,
                  &ovl))
    {
        DWORD dwErr = GetLastError();
        switch (dwErr)
        {
        case ERROR_IO_PENDING:
            if (!GetOverlappedResult(
                     m_pCurrentULChunk->FromFileHandle.FileHandle,
                     &ovl,
                     &bytesRead,
                     TRUE))
            {
                dwErr = GetLastError();
                switch(dwErr)
                {
                case ERROR_HANDLE_EOF:
                    m_pCurrentULChunk++;
                    m_cCurrentULChunk++;
                    return SetupCurrentULChunk();

                default:
                    return HRESULT_FROM_WIN32(dwErr);
                }
            }

            break;

        case ERROR_HANDLE_EOF:
            m_pCurrentULChunk++;
            m_cCurrentULChunk++;
            return SetupCurrentULChunk();

        default:
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    m_pCurrentULChunk->FromFileHandle.ByteRange.Length.QuadPart -= bytesRead;
    m_pCurrentULChunk->FromFileHandle.ByteRange.StartingOffset.QuadPart +=
        bytesRead;
    m_currentLocationInIoBuffer = 0;
    m_bytesInIoBuffer = bytesRead;

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::ProcessEncodedChunkHeader()
{
    HRESULT hr;

    while ((m_dwBytesInCurrentEncodedChunk == 0 ||
            m_encodedChunkState != IN_CHUNK_DATA) &&
           m_cCurrentULChunk < m_cULChunks)
    {
        switch (m_encodedChunkState)
        {
        case IN_CHUNK_LENGTH:
            if (FAILED(hr = CalculateEncodedChunkByteCount()))
            {
                return hr;
            }
            break;

        case IN_CHUNK_EXTENSION:
            if (FAILED(hr = DeleteEncodedChunkExtension()))
            {
                return hr;
            }
            break;

        case IN_CHUNK_HEADER_NEW_LINE:
            if (FAILED(hr = IncrementPointerInULChunk()))
            {
                return hr;
            }
            m_encodedChunkState = IN_CHUNK_DATA;
            break;

        case AT_CHUNK_DATA_NEW_LINE:
            if (FAILED(hr = IncrementPointerInULChunk()))
            {
                return hr;
            }
            m_encodedChunkState = IN_CHUNK_DATA_NEW_LINE;
            break;

        case IN_CHUNK_DATA_NEW_LINE:
            if (FAILED(hr = IncrementPointerInULChunk()))
            {
                return hr;
            }
            m_encodedChunkState = IN_CHUNK_LENGTH;
            break;

        case IN_CHUNK_DATA:
            m_encodedChunkState = AT_CHUNK_DATA_NEW_LINE;
            break;

        default:
            DBG_ASSERT(FALSE);
        }
    }

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::IncrementPointerInULChunk(IN DWORD dwIncr)
{
    while (dwIncr &&
           (m_cCurrentULChunk < m_cULChunks))
    {
        DWORD bytesLeft = QueryBytesAvailable();
        if (bytesLeft > dwIncr)
        {
            if (m_fCurrentULChunkFromMemory)
            {
                m_pCurrentULChunk->FromMemory.pBuffer =
                    (PBYTE)m_pCurrentULChunk->FromMemory.pBuffer + dwIncr;
                m_pCurrentULChunk->FromMemory.BufferLength -= dwIncr;
            }
            else
            {
                // We do not (nor do we plan to) handle filename chunks
                DBG_ASSERT(m_pCurrentULChunk->DataChunkType == HttpDataChunkFromFileHandle);
                m_currentLocationInIoBuffer += dwIncr;
            }
            return S_OK;
        }
        else
        {
            dwIncr -= bytesLeft;
            if (m_fCurrentULChunkFromMemory ||
                m_pCurrentULChunk->FromFileHandle.ByteRange.Length.QuadPart == 0)
            {
                m_cCurrentULChunk++;
                m_pCurrentULChunk++;
            }

            HRESULT hr;
            if (FAILED(hr = SetupCurrentULChunk()))
            {
                return hr;
            }
        }
    }

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::CalculateEncodedChunkByteCount()
{
    CHAR c;
    HRESULT hr;
    //
    // Walk to the first '\r' or ';' which signifies the end of the chunk
    // byte count
    //

    while (m_cCurrentULChunk < m_cULChunks &&
           SAFEIsXDigit(c = (CHAR)*QueryBytePtr()))
    {
        m_dwBytesInCurrentEncodedChunk <<= 4;
        if (c >= '0' && c <= '9')
        {
            m_dwBytesInCurrentEncodedChunk += c - '0';
        }
        else
        {
            m_dwBytesInCurrentEncodedChunk += (c | 0x20) - 'a' + 10;
        }
        if (FAILED(hr = IncrementPointerInULChunk()))
        {
            return hr;
        }
    }

    if (m_cCurrentULChunk < m_cULChunks)
    {
        if (c == ';')
        {
            m_encodedChunkState = IN_CHUNK_EXTENSION;
        }
        else if (c == '\r')
        {
            m_encodedChunkState = IN_CHUNK_HEADER_NEW_LINE;
        }
        else
        {
            DBG_ASSERT(!"Malformed chunk header");
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        if (FAILED(hr = IncrementPointerInULChunk()))
        {
            return hr;
        }
    }

    return S_OK;
}


HRESULT COMPRESSION_CONTEXT::DeleteEncodedChunkExtension()
{
    CHAR c;
    HRESULT hr;
    //
    // Walk to the first '\r' which signifies the end of the chunk extension
    //

    while (m_cCurrentULChunk < m_cULChunks &&
           (c = (CHAR)*QueryBytePtr()) != '\r')
    {
        if (FAILED(hr = IncrementPointerInULChunk()))
        {
            return hr;
        }
    }

    if (m_cCurrentULChunk < m_cULChunks)
    {
        m_encodedChunkState = IN_CHUNK_HEADER_NEW_LINE;
        if (FAILED(hr = IncrementPointerInULChunk()))
        {
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dbgutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_DLL_SECURITY             0x80000000
#define DEBUG_CONN                     0x40000000
#define DEBUG_HANDLE_REQUEST           0x20000000
#define DEBUG_STATICFILE               0x10000000
#define DEBUG_ISAPI                    0x08000000


// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dav_handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     dav_handler.cxx

   Abstract:
     Handle DAV requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "dav_handler.h"

WCHAR   g_szDavImage[MAX_PATH] = DAV_MODULE_NAME;

// static
HRESULT
W3_DAV_HANDLER::Initialize(
    VOID
    )
{
    WCHAR   szTemp[MAX_PATH];
    WCHAR * szPtr = NULL;
    
    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Get a full path to the DAV extension
    //

    if ( GetModuleFileName( GetModuleHandle( NULL ), szTemp, MAX_PATH ) )
    {
        if ( szPtr = wcsrchr( szTemp, L'\\' ) )
        {
            szPtr[1] = L'\0';
            wcscat( szTemp, DAV_MODULE_NAME );
        }
    }
    
    if ( szPtr )
    {
        wcscpy( g_szDavImage, szTemp );
    }

    return NO_ERROR;
}


CONTEXT_STATUS
W3_DAV_HANDLER::DoWork(
    VOID
)
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT                 hr = NO_ERROR;

    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Set the DAV ISAPI for this request
    //

    hr = W3_ISAPI_HANDLER::SetDavRequest( g_szDavImage );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return W3_ISAPI_HANDLER::DoWork();

Failed:

    //
    // BUGBUG - This code won't return an entity body
    // to the client...but if we can't allocate a
    // W3_ISAPI_HANDLER, we probably can't allocate
    // an entity body either.
    //
    // Actually, the whole thing is probably destined
    // to fail if we're really that low on memory, and
    // we could probably just fire off a debugger
    // message and return STATUS_CONTINUE...
    //
    
    W3_RESPONSE *   pResponse = pW3Context->QueryResponse();

    DBG_ASSERT( pResponse );

    pResponse->Clear();
    pW3Context->SetErrorStatus( hr );
    pResponse->SetStatus( HttpStatusServerError );

    pW3Context->SendResponse( W3_FLAG_SYNC );

    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_DAV_HANDLER::OnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
{
    DBG_ASSERT( W3_ISAPI_HANDLER::QueryIsInitialized() );

    //
    // Hand off the completion to the ISAPI handler
    //

    return W3_ISAPI_HANDLER::OnCompletion(
        cbCompletion,
        dwCompletionStatus
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dav_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    dav_handler.h

Abstract:

    Handler class for DAV

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _DAV_HANDLER_H_
#define _DAV_HANDLER_H_

#include "isapi_handler.h"

#define DAV_MODULE_NAME       L"httpext.dll"

//
// The W3_DAV_HANDLER is essentially just a wrapper for
// the W3_ISAPI_HANDLER.  It takes the original target of
// the request URL and submits it to the ISAPI handler
// as if it were script mapped to the DAV ISAPI.
//

class W3_DAV_HANDLER : public W3_ISAPI_HANDLER
{
public:

    W3_DAV_HANDLER( W3_CONTEXT * pW3Context )
        : W3_ISAPI_HANDLER( pW3Context, NULL )
    {
    }

    WCHAR *
    QueryName(
        VOID
        )
    {
        return L"DAVHandler";
    }

    CONTEXT_STATUS
    DoWork(
        VOID
        );

    CONTEXT_STATUS
    OnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    static
    HRESULT
    W3_DAV_HANDLER::Initialize(
        VOID
        );

    static
    VOID
    Terminate(
        VOID
        )
    {
    }
};

#endif // _DAV_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\digestprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     digestprovider.cxx

   Abstract:
     Digest authentication provider
 
   Author:
     Ming Lu (minglu)             24-Jun-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "sspiprovider.hxx"
#include "digestprovider.hxx"
#include "uuencode.hxx"

ALLOC_CACHE_HANDLER * DIGEST_SECURITY_CONTEXT::sm_pachDIGESTSecContext  
                                                               = NULL;

//static
HRESULT
DIGEST_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize Digest SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;

    SetInternalId( dwInternalId );
    hr = DIGEST_SECURITY_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing Digest Auth Prov.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
DIGEST_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSPI Digest provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    DIGEST_SECURITY_CONTEXT::Terminate();
}

HRESULT
DIGEST_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the Digest 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if Digest is applicable
    
    
Return Value:

    HRESULT

--*/
{
    CHAR *                  pszAuthHeader = NULL;
    HRESULT                 hr;
    SSPI_CONTEXT_STATE *    pContextState;
    STACK_STRA(             strPackage, 64 );
    W3_METADATA *           pMetaData = NULL;
    
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfApplies = FALSE;

    //
    // Is using of Digest SSP enabled?    
    //
    if ( !g_pW3Server->QueryUseDigestSSP() )
    {
        return NO_ERROR;
    }

    //
    // Get the auth type
    //
    
    hr = pMainContext->QueryRequest()->GetAuthType( &strPackage );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // No package, no auth
    //
    
    if ( strPackage.IsEmpty() )
    {
        return NO_ERROR;
    }
    
    //
    // Is it Digest?
    //
    
    if ( _stricmp( strPackage.QueryStr(), "Digest" ) == 0 )
    {
        //
        // Save away the package so we don't have to calc again
        //

        DBG_ASSERT( !strPackage.IsEmpty() );

        pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
        DBG_ASSERT( pszAuthHeader != NULL );
                
        pContextState = new (pMainContext) SSPI_CONTEXT_STATE( 
                        pszAuthHeader + strPackage.QueryCCH() + 1 );
        if ( pContextState == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        hr = pContextState->SetPackage( strPackage.QueryStr() );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in SetPackage().  hr = %x\n",
                        hr ));
            delete pContextState;
            pContextState = NULL;
            return hr;
        }

        pMainContext->SetContextState( pContextState );

        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}

HRESULT
DIGEST_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{
    DWORD                       err;
    HRESULT                     hr                     = E_FAIL;
    W3_METADATA *               pMetaData              = NULL;
    W3_CONNECTION *             pW3Connection          = NULL;
    DIGEST_SECURITY_CONTEXT   * pDigestSecurityContext = NULL;
    SSPI_CONTEXT_STATE        * pContextState          = NULL;
    SSPI_USER_CONTEXT         * pUserContext           = NULL;
    SSPI_CREDENTIAL *           pDigestCredentials     = NULL;

    SecBufferDesc               SecBuffDescOutput;
    SecBufferDesc               SecBuffDescInput;

    //
    // We have 5 input buffer and 1 output buffer to fill data 
    // in for digest authentication
    //

    SecBuffer                   SecBuffTokenOut[ 1 ];
    SecBuffer                   SecBuffTokenIn[ 5 ];

    SECURITY_STATUS             secStatus              = SEC_E_OK;

    CtxtHandle                  hServerCtxtHandle;

    TimeStamp                   Lifetime;

    ULONG                       ContextReqFlags        = 0;
    ULONG                       ContextAttributes      = 0;

    STACK_STRU(                 strOutputHeader, 256 );

    STACK_BUFFER(               bufOutputBuffer, 4096 );
    STACK_STRA(                 strMethod,       10 );
    STACK_STRU(                 strUrl,          MAX_PATH );
    STACK_STRA(                 strUrlA,         MAX_PATH );
    STACK_STRA(                 strRealm,        128 );

    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pContextState = ( SSPI_CONTEXT_STATE* ) 
                    pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    //  clean the memory and set it to zero
    //
    ZeroMemory( &SecBuffDescOutput, sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenOut   , sizeof( SecBuffTokenOut ) );

    ZeroMemory( &SecBuffDescInput , sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenIn    , sizeof( SecBuffTokenIn ) );

    //
    //  define the buffer descriptor for the Outpt
    //
    SecBuffDescOutput.ulVersion    = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers     = 1;
    SecBuffDescOutput.pBuffers     = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType  = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer    = bufOutputBuffer.QuerySize();
    SecBuffTokenOut[0].pvBuffer    = ( PVOID )bufOutputBuffer.QueryPtr();

    //
    //  define the buffer descriptor for the Input
    //

    SecBuffDescInput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers      = 5;
    SecBuffDescInput.pBuffers      = SecBuffTokenIn;

    //
    // set the digest auth header in the buffer
    //

    SecBuffTokenIn[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer     = strlen(pContextState->QueryCredentials());
    SecBuffTokenIn[0].pvBuffer     = pContextState->QueryCredentials();

    //  
    //  Get and Set the information for the method
    //
    
    hr = pMainContext->QueryRequest()->GetVerbString( &strMethod );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the method.  hr = %x\n",
                    hr ));
        return hr;
    }

    SecBuffTokenIn[1].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer     = strMethod.QueryCCH();
    SecBuffTokenIn[1].pvBuffer     = strMethod.QueryStr();

    //
    // Get and Set the infomation for the Url
    //

    hr = pMainContext->QueryRequest()->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    hr = strUrlA.CopyW( strUrl.QueryStr() );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error copying the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    SecBuffTokenIn[2].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer     = strUrlA.QueryCB();
    SecBuffTokenIn[2].pvBuffer     = ( PVOID )strUrlA.QueryStr();


    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer     = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer     = 0;    // this is not yet implemeted   

    //
    //Get and Set the Realm Information
    //

    if( pMetaData->QueryRealm() )
    {
        hr = strRealm.CopyW( pMetaData->QueryRealm() );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error copying the realm.  hr = %x\n",
                        hr ));
            return hr;
        }
    }

    SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[4].cbBuffer     = strRealm.QueryCB();  
    SecBuffTokenIn[4].pvBuffer     = ( PVOID )strRealm.QueryStr(); 

    //
    //  Get a Security Context
    //

    // 
    // get the credential for the server
    //
    
    hr = SSPI_CREDENTIAL::GetCredential( NTDIGEST_SP_NAME,
                                         &pDigestCredentials );    
    if ( FAILED( hr ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Error get credential handle. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }

    DBG_ASSERT( pDigestCredentials != NULL );

    //
    // Resize the output buffer to max token size
    //
    if( !bufOutputBuffer.Resize( 
                  pDigestCredentials->QueryMaxTokenSize() ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    pDigestSecurityContext = 
       ( DIGEST_SECURITY_CONTEXT * ) QueryConnectionAuthContext( pMainContext );


    //
    // check to see if there is an old Context Handle
    //
    if ( pDigestSecurityContext != NULL )
    {
        //
        // defined the buffer
        //
        SecBuffTokenIn[4].BufferType   = SECBUFFER_TOKEN;
        SecBuffTokenIn[4].cbBuffer     = bufOutputBuffer.QuerySize();
        SecBuffTokenIn[4].pvBuffer     = 
                            ( PVOID )bufOutputBuffer.QueryPtr();

        secStatus = VerifySignature(
                            pDigestSecurityContext->QueryContextHandle(),
                            &SecBuffDescInput,
                            0,
                            0 );

    }
    else
    {
        //
        //  set the flags
        //
        ContextReqFlags = ASC_REQ_REPLAY_DETECT | 
                          ASC_REQ_CONNECTION;

        //
        // get the security context
        //
        secStatus = AcceptSecurityContext(
                        pDigestCredentials->QueryCredHandle(),
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &hServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);

        if( SEC_I_COMPLETE_NEEDED == secStatus ) 
        {
            //
            //defined the buffer
            //

            SecBuffTokenIn[4].BufferType   = SECBUFFER_TOKEN;
            SecBuffTokenIn[4].cbBuffer     = bufOutputBuffer.QuerySize();
            SecBuffTokenIn[4].pvBuffer     = 
                                ( PVOID )bufOutputBuffer.QueryPtr();

            secStatus = CompleteAuthToken( 
                                &hServerCtxtHandle, 
                                &SecBuffDescInput 
                                );
        }

        if ( SUCCEEDED( secStatus ) )
        {
            pDigestSecurityContext = new DIGEST_SECURITY_CONTEXT( 
                                               pDigestCredentials );
            if ( NULL == pDigestSecurityContext )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            pDigestSecurityContext->SetContextHandle( 
                                       hServerCtxtHandle );

            pDigestSecurityContext->SetContextAttributes( 
                                       ContextAttributes );

            //
            // Mark the security context is complete, so we can detect 
            // reauthentication on the same connection
            //
            // CODEWORK:  Can probably get away will just 
            //            un-associating/deleting the 
            //            SSPI_SECURITY_CONTEXT now!
            //
        
            pDigestSecurityContext->SetIsComplete( TRUE );

            SetConnectionAuthContext( pMainContext,
                                      pDigestSecurityContext );
        }
    }

    //
    // Check to see if the nonce has expired
    //
    if (SEC_E_CONTEXT_EXPIRED == secStatus)
    {
        //
        // stale = true indicates that user knows password but he need to use new nonce
        // let's treat stale = true as part of the continuing authentication handshake
        // IIS will send back only Digest header in this case ( even if more auth methods
        // are enabled )
        //
        
        if ( NULL != pDigestSecurityContext )
        {
            pDigestSecurityContext->SetStale( TRUE );
        }
        
        //
        // Add Digest headers to response
        //
        
        hr = SetDigestHeader( pMainContext, 
                              TRUE //Stale
                            );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        //
        // Don't let anyone else send back authentication headers when
        // the 401 is sent
        //
        
        pMainContext->SetProviderHandled( TRUE );

        //
        // We need to send a 401 response to continue the handshake.  
        // We have already setup the WWW-Authenticate header
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
     
        pMainContext->SetFinishedResponse();
        
        pMainContext->SetErrorStatus( SEC_E_CONTEXT_EXPIRED );
    }
    
    else if( FAILED( secStatus ) )
    {
        err = GetLastError();
        if( err == ERROR_PASSWORD_MUST_CHANGE ||
            err == ERROR_PASSWORD_EXPIRED )
        {
            return HRESULT_FROM_WIN32( err );
        }

        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
                                                  
        pMainContext->SetErrorStatus( HRESULT_FROM_WIN32( secStatus ) );
    }
    else
    {
        //
        // Create a user context and setup it up
        //
        
        pUserContext = new SSPI_USER_CONTEXT( this );
        if ( pUserContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        } 
        
        hr = pUserContext->Create( pDigestSecurityContext, pMainContext );
        if ( FAILED( hr ) )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
            return hr;
        }
        
        pMainContext->SetUserContext( pUserContext );        
    }

    return NO_ERROR;
}

HRESULT
DIGEST_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA *           pMetaData;

    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Is using of Digest SSP enabled?    
    //
    if ( !g_pW3Server->QueryUseDigestSSP() )
    {
        return NO_ERROR;
    }

    if( !W3_STATE_AUTHENTICATION::QueryIsDomainMember() )
    {
        //
        // We are not a domain member, so do nothing
        //
        return NO_ERROR;
    }

    return SetDigestHeader( pMainContext,
                            FALSE           //stale will not be sent
                          );
}

HRESULT
DIGEST_AUTH_PROVIDER::SetDigestHeader(
    IN  W3_MAIN_CONTEXT *          pMainContext,
    IN BOOL                        fStale )
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    pDigestSecurityContext - Digest context containing information such as
                             Stale. NULL means that no stale is to be sent
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr                    = E_FAIL;
    W3_METADATA *           pMetaData;
    W3_CONNECTION *         pW3Connection;

    //
    // 4096 is the max output for digest authenticaiton
    //
    
    STACK_BUFFER(           bufOutputBuffer, 4096 );
    STACK_STRA(             strOutputHeader, MAX_PATH ); 
    STACK_STRA(             strMethod,       10 );
    STACK_STRU(             strUrl,          MAX_PATH );
    STACK_STRA(             strRealm,        128 );

    STACK_STRA(             strUrlA,         MAX_PATH );

    SecBufferDesc           SecBuffDescOutput;
    SecBufferDesc           SecBuffDescInput;

    SecBuffer               SecBuffTokenOut[ 1 ];
    SecBuffer               SecBuffTokenIn[ 5 ];

    SECURITY_STATUS         secStatus              = SEC_E_OK;

    SSPI_CREDENTIAL *       pDigestCredential      = NULL;
    CtxtHandle              hServerCtxtHandle;

    ULONG                   ContextReqFlags        = 0;
    ULONG                   ContextAttributes      = 0;
    TimeStamp               Lifetime;

 

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    //  Get a Security Context
    //

    // 
    // get the credential for the server
    //
    
    hr = SSPI_CREDENTIAL::GetCredential( NTDIGEST_SP_NAME,
                                         &pDigestCredential );    
    if ( FAILED( hr ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "Error get credential handle. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }

    DBG_ASSERT( pDigestCredential != NULL );

    if( !bufOutputBuffer.Resize( 
                  pDigestCredential->QueryMaxTokenSize() ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF((DBG_CONTEXT,
                  "Error resize the output buffer. hr = 0x%x \n",
                  hr ));
        
        return hr;
    }


    //
    //  clean the memory and set it to zero
    //
    ZeroMemory( &SecBuffDescOutput, sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenOut   , sizeof( SecBuffTokenOut ) );

    ZeroMemory( &SecBuffDescInput , sizeof( SecBufferDesc ) );
    ZeroMemory( SecBuffTokenIn    , sizeof( SecBuffTokenIn ) );

    //
    // define the OUTPUT
    //
    
    SecBuffDescOutput.ulVersion    = SECBUFFER_VERSION;
    SecBuffDescOutput.cBuffers     = 1;
    SecBuffDescOutput.pBuffers     = SecBuffTokenOut;

    SecBuffTokenOut[0].BufferType  = SECBUFFER_TOKEN;
    SecBuffTokenOut[0].cbBuffer    = bufOutputBuffer.QuerySize(); 
    SecBuffTokenOut[0].pvBuffer    = ( PVOID )bufOutputBuffer.QueryPtr();

    //
    //  define the Input
    //

    SecBuffDescInput.ulVersion     = SECBUFFER_VERSION;
    SecBuffDescInput.cBuffers      = 5;
    SecBuffDescInput.pBuffers      = SecBuffTokenIn;

    //
    //  Get and Set the information for the challenge
    //

    //
    // set the inforamtion in the buffer, this case is Null to 
    // authenticate user
    //
    SecBuffTokenIn[0].BufferType   = SECBUFFER_TOKEN;
    SecBuffTokenIn[0].cbBuffer     = 0; 
    SecBuffTokenIn[0].pvBuffer     = NULL;

    //  
    //  Get and Set the information for the method
    //
    
    hr = pMainContext->QueryRequest()->GetVerbString( &strMethod );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the method.  hr = %x\n",
                    hr ));
        return hr;
    }

    SecBuffTokenIn[1].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[1].cbBuffer     = strMethod.QueryCCH();
    SecBuffTokenIn[1].pvBuffer     = strMethod.QueryStr();

    //
    // Get and Set the infomation for the Url
    //

    hr = pMainContext->QueryRequest()->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    hr = strUrlA.CopyW( strUrl.QueryStr() );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error copying the URL.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    SecBuffTokenIn[2].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[2].cbBuffer     = strUrlA.QueryCB();
    SecBuffTokenIn[2].pvBuffer     = ( PVOID )strUrlA.QueryStr();

    //
    //  Get and Set the information for the hentity
    //
    SecBuffTokenIn[3].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[3].cbBuffer     = 0;    // this is not yet implemeted
    SecBuffTokenIn[3].pvBuffer     = NULL; // this is not yet implemeted   

    //
    //Get and Set the Realm Information
    //

    if( pMetaData->QueryRealm() )
    {
        hr = strRealm.CopyW( pMetaData->QueryRealm() );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error copying the realm.  hr = %x\n",
                        hr ));
            return hr;
        }
    }

    SecBuffTokenIn[4].BufferType   = SECBUFFER_PKG_PARAMS;
    SecBuffTokenIn[4].cbBuffer     = strRealm.QueryCB();  
    SecBuffTokenIn[4].pvBuffer     = ( PVOID )strRealm.QueryStr(); 

    //
    //  set the flags
    //

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | 
                      ASC_REQ_CONNECTION;

    //
    // get the security context
    //
    secStatus = AcceptSecurityContext(
                        pDigestCredential->QueryCredHandle(),
                        NULL,
                        &SecBuffDescInput,
                        ContextReqFlags,
                        SECURITY_NATIVE_DREP,
                        &hServerCtxtHandle,
                        &SecBuffDescOutput,
                        &ContextAttributes,
                        &Lifetime);

    //
    // a challenge has to be send back to the client
    //
    if ( SEC_I_CONTINUE_NEEDED == secStatus )
    {
        //
        //  Do we already have a digest security context
        //

    
        if( fStale )
        {
            hr = strOutputHeader.Copy( "Digest stale=TRUE ," );
        }
        else
        {
            hr = strOutputHeader.Copy( "Digest " );
        }

        if( FAILED( hr ) )
        {
            return hr;
        } 

        hr = strOutputHeader.Append(
                ( CHAR * )SecBuffDescOutput.pBuffers[0].pvBuffer, 
                SecBuffDescOutput.pBuffers[0].cbBuffer - 1 );
        if( FAILED( hr ) )
        {
            return hr;
        }    

        //
        //  Add the header WWW-Authenticate to the response after a 
        //  401 server error
        //

        hr = pMainContext->QueryResponse()->SetHeader(
                                        "WWW-Authenticate",
                                        16,
                                        strOutputHeader.QueryStr(),
                                        strOutputHeader.QueryCCH() 
                                        );
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//static
HRESULT
DIGEST_SECURITY_CONTEXT::Initialize(
    VOID
)
/*++

  Description:
    
    Global DIGEST_SECURITY_CONTEXT initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( DIGEST_SECURITY_CONTEXT );

    DBG_ASSERT( sm_pachDIGESTSecContext == NULL );
    
    sm_pachDIGESTSecContext = new ALLOC_CACHE_HANDLER( 
                                     "DIGEST_SECURITY_CONTEXT",  
                                     &acConfig );

    if ( sm_pachDIGESTSecContext == NULL )
    {
        HRESULT hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
               "Error initializing sm_pachDIGESTSecContext. hr = 0x%x\n",
               hr ));

        return hr;
    }
    
    return S_OK;

} // DIGEST_SECURITY_CONTEXT::Initialize

//static
VOID
DIGEST_SECURITY_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy DIGEST_SECURITY_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT( sm_pachDIGESTSecContext != NULL );

    delete sm_pachDIGESTSecContext;
    sm_pachDIGESTSecContext = NULL;

} // DIGEST_SECURITY_CONTEXT::Terminate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\generalhandler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     generalhandler.cxx

   Abstract:
     A general purpose error sending handler.  This cleans up some of the 
     logic needed to allow DetermineHandler() to send HTTP errors.  
     
   Author:
     Bilal Alam (balam)             7-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "generalhandler.hxx"

ALLOC_CACHE_HANDLER *       W3_GENERAL_HANDLER::sm_pachGeneralHandlers;

CONTEXT_STATUS
W3_GENERAL_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Send the configured error response to the client

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;

    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Setup the error response and send it
    //
    
    pW3Context->QueryResponse()->SetStatus( _httpStatus, _httpSubError ); 
    
    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
        return CONTEXT_STATUS_CONTINUE;
    }
    
    return CONTEXT_STATUS_PENDING;
}

// static
HRESULT
W3_GENERAL_HANDLER::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_GENERAL_HANDLERs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_GENERAL_HANDLER );

    DBG_ASSERT( sm_pachGeneralHandlers == NULL );
    
    sm_pachGeneralHandlers = new ALLOC_CACHE_HANDLER( "W3_GENERAL_HANDLER",  
                                                      &acConfig );

    if ( sm_pachGeneralHandlers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

// static
VOID
W3_GENERAL_HANDLER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachGeneralHandlers != NULL )
    {
        delete sm_pachGeneralHandlers;
        sm_pachGeneralHandlers = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\dirlist.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     dirlist.cxx

   Abstract:
     Handle directory listing
 
   Author:
     Anil Ruia (AnilR)             8-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define PAD_LONG_DATE           29
#define PAD_SHORT_DATE          10
#define PAD_TIME                 8
#define PAD_FILESIZE            12

#define PAD_COL_SPACING          1

void PadDirField(CHAR *pszString,
                 int    pad)
{
    int cchLen = strlen(pszString);

    if (cchLen > pad)
        pad = cchLen;

    int diff = pad - cchLen;

    //
    //  Insert spaces in front of the text to pad it out
    //
    memmove(pszString + diff, pszString, cchLen + 1);
    for (int i = 0; i < diff; i++, pszString++)
        *pszString = ' ';

    //
    //  Append a column spacer at the end
    //

    pszString += cchLen;
    for (i = 0; i < PAD_COL_SPACING; i++, pszString++)
        *pszString = ' ';

    *pszString = '\0';
}


HRESULT AddFileEntry(IN STRA &strURL,
                     IN WIN32_FIND_DATA &fileData,
                     IN DWORD dwDirBrowseFlags,
                     IN OUT STRA *pstrResponse)
/*++

Routine Description:

    Adds the HTML corresponding to an individual directory entry to
    strResponse

Arguments:

    fileData: the File Information obtained from Find[First|Next]File

Returns:

    HRESULT

--*/
{
    HRESULT hr;

    //
    //  Add optional date and time of this file.  We use the locale
    //  and timezone of the server
    //
    FILETIME lastModTime = fileData.ftLastWriteTime;
    if ((dwDirBrowseFlags & (DIRBROW_SHOW_DATE | DIRBROW_SHOW_TIME)) &&
        ((lastModTime.dwLowDateTime != 0) ||
         (lastModTime.dwHighDateTime != 0)))
    {
        FILETIME ftLocal;
        SYSTEMTIME systime;

        if (!FileTimeToLocalFileTime(&lastModTime, &ftLocal) ||
            !FileTimeToSystemTime(&ftLocal, &systime))
        {
                return HRESULT_FROM_WIN32(GetLastError());
        }

        LCID lcid = GetSystemDefaultLCID();
        if (lcid == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (dwDirBrowseFlags & DIRBROW_SHOW_DATE)
        {
            CHAR pszDate[50];
            BOOL fLongDate = dwDirBrowseFlags & DIRBROW_LONG_DATE;
            if (GetDateFormatA(lcid,
                               LOCALE_NOUSEROVERRIDE |
                               (fLongDate ? DATE_LONGDATE :
                               DATE_SHORTDATE),
                               &systime,
                               NULL,
                               pszDate,
                               sizeof(pszDate)) == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            PadDirField(pszDate,
                        fLongDate ? PAD_LONG_DATE : PAD_SHORT_DATE );

            if (FAILED(hr = pstrResponse->Append(pszDate)))
            {
                return hr;
            }
        }

        if (dwDirBrowseFlags & DIRBROW_SHOW_TIME)
        {
            CHAR pszTime[15];
            if (GetTimeFormatA(lcid,
                               LOCALE_NOUSEROVERRIDE |
                               TIME_NOSECONDS,
                               &systime,
                               NULL,
                               pszTime,
                               sizeof(pszTime)) == 0)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            PadDirField(pszTime, PAD_TIME);

            if (FAILED(hr = pstrResponse->Append(pszTime)))
            {
                return hr;
            }
        }
    }

    //
    //  Add the optional file size
    //
    LARGE_INTEGER liSize;
    liSize.HighPart = fileData.nFileSizeHigh;
    liSize.LowPart  = fileData.nFileSizeLow;
    if (dwDirBrowseFlags & DIRBROW_SHOW_SIZE)
    {
        CHAR pszSize[30];
        int pad = PAD_FILESIZE;

        if (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            strcpy(pszSize, "&lt;dir&gt;");

            //
            //  Need to adjust for using "&lt;" instead of "<"
            //
            pad += 6;
        }
        else
        {
            _i64toa(liSize.QuadPart, pszSize, 10);
        }

        PadDirField(pszSize, pad);

        if (FAILED(hr = pstrResponse->Append(pszSize)))
        {
            return hr;
        }
    }

    //
    //  We have to escape the link name that is used in the URL anchor
    //
    // BUGBUG
    // UrlEscape(fileData.cFileName);

    STACK_STRA (straFileName, 16);

    if (FAILED(hr = pstrResponse->Append("<A HREF=\"")) ||
        FAILED(hr = pstrResponse->Append(strURL)) ||
        FAILED(hr = straFileName.CopyWToUTF8(fileData.cFileName)) ||
        FAILED(hr = pstrResponse->Append(straFileName)))
    {
        return hr;
    }

    if ((fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        FAILED(hr = pstrResponse->Append("/")))
    {
        return hr;
    }

    if (FAILED(hr = pstrResponse->Append("\">")))
    {
        return hr;
    }

    if (FAILED(hr = straFileName.CopyWToUTF8Unescaped(fileData.cFileName)))
    {
        return hr;
    }

    //
    //  If the show extension flag is not set, then strip it.  If the
    //  file name begins with a dot, then don't strip it.
    //
    if (!(dwDirBrowseFlags & DIRBROW_SHOW_EXTENSION))
    {
        int dotIndex = straFileName.QueryCCH() - 1;

        while ((dotIndex > 0) &&
               (straFileName.QueryStr()[dotIndex] != '.'))
        {
            dotIndex--;
        }

        if (dotIndex > 0)
            straFileName.SetLen(dotIndex);
    }

    if (FAILED(hr = pstrResponse->Append(straFileName)) ||
        FAILED(hr = pstrResponse->Append("</A><br>")))
    {
        return hr;
    }

    return S_OK;
}

HRESULT 
W3_STATIC_FILE_HANDLER::HandleDirectoryListing(
     IN W3_CONTEXT *            pContext,
     OUT BOOL *                 pfHandled
)
{
    DBG_ASSERT(pfHandled != NULL);
    DBG_ASSERT(pContext != NULL);

    W3_RESPONSE *pResponse = pContext->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    URL_CONTEXT *pUrlContext = pContext->QueryUrlContext();
    DBG_ASSERT(pUrlContext != NULL);

    DWORD dwDirBrowseFlags = pUrlContext->QueryMetaData()->QueryDirBrowseFlags();

    HRESULT hr;

    // Append a '*' to get all files in the directory
    STACK_STRU (strPhysical, MAX_PATH);
    if (FAILED(hr = strPhysical.Copy(
                        pUrlContext->QueryPhysicalPath()->QueryStr())))
    {
        return hr;
    }
    LPWSTR starString;
    if (strPhysical.QueryStr()[strPhysical.QueryCCH() - 1] == L'\\')
        starString = L"*";
    else
        starString = L"\\*";
    if (FAILED(hr = strPhysical.Append(starString)))
    {
        return hr;
    }

    WIN32_FIND_DATA fileData;
    HANDLE hFindFile = FindFirstFile(strPhysical.QueryStr(), &fileData);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pResponse->SetStatus(HttpStatusOk);
    if (FAILED(hr = pResponse->SetHeader("Content-Type", 12,
                                         "text/html", 9)))
    {
        return hr;
    }

    STACK_STRA (strHostName, 16);
    if (FAILED(hr = GetServerVariableServerName(pContext, &strHostName)))
    {
        return hr;
    }

    STACK_STRU (strURL, 128);
    STACK_STRA (straURL, 128);
    STACK_STRA (straUTF8UnescapedURL, 128);

    if (FAILED(hr = pContext->QueryRequest()->GetUrl(&strURL)))
    {
        return hr;
    }
    if ((strURL.QueryStr()[strURL.QueryCCH() - 1] != L'/') &&
        FAILED(hr = strURL.Append(L"/")))
    {
        return hr;
    }

    if (FAILED(hr = straURL.CopyWToUTF8(strURL.QueryStr())) ||
        FAILED(hr = straUTF8UnescapedURL.CopyWToUTF8Unescaped(strURL.QueryStr())))
    {
        return hr;
    }

    //
    // Write hardcoded HTML header
    //
    if (FAILED(hr = m_strDirlistResponse.Copy("<html><head>")) ||
        FAILED(hr = m_strDirlistResponse.Append("<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">")) ||
        FAILED(hr = m_strDirlistResponse.Append("<title>")) ||
        FAILED(hr = m_strDirlistResponse.Append(strHostName)) ||
        FAILED(hr = m_strDirlistResponse.Append(" - ")) ||
        FAILED(hr = m_strDirlistResponse.Append(straUTF8UnescapedURL)) ||
        FAILED(hr = m_strDirlistResponse.Append("</title></head><body><H1>")) ||
        FAILED(hr = m_strDirlistResponse.Append(strHostName)) ||
        FAILED(hr = m_strDirlistResponse.Append(" - ")) ||
        FAILED(hr = m_strDirlistResponse.Append(straUTF8UnescapedURL)) ||
        FAILED(hr = m_strDirlistResponse.Append("</H1><hr>\r\n\r\n<pre>")))
    {
        return hr;
    }

    //
    // Create the link to the parent directory, if applicable
    //
    if (straURL.QueryCCH() >= 3)
    {
        int cchParentIndex;

        for (cchParentIndex = straURL.QueryCCH() - 2;
             (cchParentIndex >= 0) &&
                 (straURL.QueryStr()[cchParentIndex] != L'/');
             cchParentIndex--);

        if ( cchParentIndex != -1 )
        {
            if (FAILED(hr = m_strDirlistResponse.Append("<A HREF=\"")) ||
                FAILED(hr = m_strDirlistResponse.Append(straURL.QueryStr(), cchParentIndex + 1)) ||
                FAILED(hr = m_strDirlistResponse.Append("\">[To Parent Directory]</A><br><br>")))
            {
                return hr;
            }
        }
    }
        
    while(TRUE)
    {
        if (((fileData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) == 0) &&
            wcscmp(fileData.cFileName, L".") &&
            wcscmp(fileData.cFileName, L".."))
        {
            //
            //  Add the entry for this file
            //
            if (FAILED(hr = AddFileEntry(straURL,
                                         fileData,
                                         dwDirBrowseFlags,
                                         &m_strDirlistResponse)))
            {
                FindClose(hFindFile);
                return hr;
            }
        }
        if (!FindNextFile(hFindFile, &fileData))
        {
            DWORD err = GetLastError();
            if (err == ERROR_NO_MORE_FILES)
                break;

            FindClose(hFindFile);
            return HRESULT_FROM_WIN32(err);
        }
    }

    if (!FindClose(hFindFile))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (FAILED(hr = m_strDirlistResponse.Append("</pre><hr></body></html>")))
    {
        return hr;
    }

    if (FAILED(hr = pResponse->AddMemoryChunkByReference(m_strDirlistResponse.QueryStr(),
                                                         m_strDirlistResponse.QueryCCH())))
    {
        return hr;
    }

    *pfHandled = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\filecache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     filecache.cxx

   Abstract:
     A file cache (filename->W3_FILE_INFO cache)
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define STRONG_ETAG_DELTA       30000000

#define SIZE_PRIVILEGE_SET                      128

ALLOC_CACHE_HANDLER *    W3_FILE_INFO::sm_pachW3FileInfo;

GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

HRESULT
W3_FILE_INFO_KEY::CreateCacheKey(
    WCHAR *             pszFileKey,
    DWORD               cchFileKey,
    BOOL                fCopy
)
/*++

Routine Description:

    Initialize a file cache key

Arguments:

    pszFileKey - filename
    cchFileKey - size of filename
    fCopy - TRUE if we should copy into key buffer, otherwise just keep ref

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( fCopy )
    {
        hr = _strFileKey.Copy( pszFileKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszFileKey = _strFileKey.QueryStr();
        _cchFileKey = _strFileKey.QueryCCH();
    }
    else
    {
        _pszFileKey = pszFileKey;
        _cchFileKey = cchFileKey;
    }

    return NO_ERROR;
}

W3_FILE_INFO::~W3_FILE_INFO(
    VOID
)
{
    HRESULT             hr;
    W3_FILE_INFO_CACHE* pFileCache;
    
    DBG_ASSERT( CheckSignature() );
    
    _dwSignature = W3_FILE_INFO_SIGNATURE_FREE;

    //
    // Clear any associated object
    //
    
    LockCacheEntry();
    
    if ( _pAssociatedObject != NULL )
    {
        _pAssociatedObject->Cleanup();
        _pAssociatedObject = NULL;
    }

    UnlockCacheEntry();

    //
    // Release the contents buffer if it exists
    //
    
    if ( _pFileBuffer != NULL )
    {
        pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();
        
        hr = pFileCache->ReleaseFromMemoryCache( _pFileBuffer,
                                                 _nFileSizeLow );
        DBG_ASSERT( SUCCEEDED( hr ) );
        
        _pFileBuffer = NULL;
    }
    
    //
    // Close the file handle if it still around
    //
    
    if ( _hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hFile );
        _hFile = NULL;
    }
}

BOOL
W3_FILE_INFO::SetAssociatedObject(
    ASSOCIATED_FILE_OBJECT *        pObject
)
/*++

Routine Description:

    Associate object with this cache entry

Arguments:

    pObject - Object to associate

Return Value:

    BOOL

--*/
{
    BOOL            fRet = FALSE;
    
    LockCacheEntry();
    
    if ( _pAssociatedObject == NULL )
    {
        _pAssociatedObject = pObject;
        fRet = TRUE;
    }
    
    UnlockCacheEntry();
    
    return fRet;
}

PSECURITY_DESCRIPTOR
W3_FILE_INFO::QuerySecDesc(
    VOID
)
/*++

Routine Description:

    Return security descriptor

Arguments:

    None

Return Value:

    pointer to security descriptor

--*/
{
    if ( _pFileBuffer != NULL )
    {
        //
        // The file is cached, therefore we must have security already
        //
        
        return _bufSecDesc.QueryPtr();
    }
    else
    {
        DBG_ASSERT( _hFile != NULL );
        
        if ( FAILED( ReadSecurityDescriptor() ) )
        {
            return NULL;
        }
        
        return _bufSecDesc.QueryPtr();
    }
}

HRESULT
W3_FILE_INFO::GenerateETag(
    VOID
)
/*++

Routine Description:

    Generate ETag string

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CHAR *      psz = _achETag;
    PBYTE       pbTime = (PBYTE) &_ftLastWriteTime;
    DWORD       dwChangeNumber;
    const CHAR  szHex[] = "0123456789abcdef";
    FILETIME    ftNow;
    __int64     iNow;
    __int64     iFileTime;

    //
    // Is this ETag weak?  If so put the preceding W/
    //
    
    GetSystemTimeAsFileTime(&ftNow);
    iNow = (__int64)*(__int64 *)&ftNow;
    iFileTime = (__int64)*(__int64 *)&_ftLastWriteTime;

    if ( ( iNow - iFileTime ) <= STRONG_ETAG_DELTA )
    {
        //
        // This is a weak ETag
        //
        
        *psz++ = 'W';
        *psz++ = '/';
    }
    
    //
    // System change number is from the metabase
    //

    dwChangeNumber = g_pW3Server->QuerySystemChangeNumber();

    //
    // Generate the meat of the ETag
    //

    *psz++ = '\"';
    for (int i = 0; i < 8; i++)
    {
        BYTE b = *pbTime++;
        BYTE bH = b >> 4;
        if (bH != 0)
            *psz++ = szHex[bH];
        *psz++ = szHex[b & 0xF];
    }
    *psz++ = ':';
    psz += strlen(_itoa((DWORD) dwChangeNumber, psz, 16));
    *psz++ = '\"';
    *psz = '\0';

    _cchETag = DIFF(psz - _achETag);
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::GenerateLastModifiedTimeString(
    VOID
)
/*++

Routine Description:

    Generate the Last-Modified-Time header string

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              st;
    
    FileTimeToSystemTime( &_ftLastWriteTime, &st );
                          
    if ( !SystemTimeToGMT( st, 
                           _achLastModified, 
                           sizeof(_achLastModified) ) ) 
    {  
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return NO_ERROR;
    }
}

HRESULT
W3_FILE_INFO::DoAccessCheck(
    FILE_CACHE_USER *   pFileCacheUser
)
/*++

Routine Description:

    Check whether given token has access to this file

Arguments:

    pFileCacheUser - User to access cache with

Return Value:

    HRESULT

--*/
{
    BYTE    psFile[SIZE_PRIVILEGE_SET];
    DWORD   dwPS;
    DWORD   dwGrantedAccess;
    BOOL    fAccess;
    
    if ( pFileCacheUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If we don't have a security descriptor, then local system must have
    // accessed the file originally.  Just return success
    //
    
    if ( pFileCacheUser->_hToken == NULL )
    {
        return NO_ERROR;
    }
    
    //
    // If we have a last-user-sid, and the caller provided a sid, then do a
    // quick check of sid equality
    //
    
    if ( QueryLastSid() != NULL &&
         pFileCacheUser->_pSid != NULL )
    {
        if ( EqualSid( QueryLastSid(), pFileCacheUser->_pSid ) )
        {
            return NO_ERROR;
        }
    }
    
    //
    // Ok.  Just use the token and cached security descriptor
    //

    dwPS = sizeof(psFile);
    ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

    //
    // We must have a security descriptor if we've cached the file
    //

    DBG_ASSERT( QuerySecDesc() );

    if ( !AccessCheck( QuerySecDesc(),
                       pFileCacheUser->_hToken,
                       FILE_GENERIC_READ,
                       &g_gmFile,
                       (PRIVILEGE_SET*)psFile,
                       &dwPS,
                       &dwGrantedAccess,
                       &fAccess ) || !fAccess )
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::OpenFile(
    STRU &              strFileName,
    FILE_CACHE_USER *   pOpeningUser
)
/*++

Routine Description:

    Open the given file (but don't read in the file contents).  This method
    does the minimum needed to allow the caller to make a reasonable 
    decision about whether this file should be cached here or in UL

Arguments:

    strFileName - file name to open
    pOpeningUser - User to open file under

Return Value:

    HRESULT

--*/
{
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    STACK_STRU(             strFilePath, MAX_PATH + 1 );
    HRESULT                 hr = NO_ERROR;
    BOOL                    fImpersonated = FALSE;
    BY_HANDLE_FILE_INFORMATION FileInfo; 

    if ( pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // First make a cache key
    //

    hr = _cacheKey.CreateCacheKey( strFileName.QueryStr(),
                                   strFileName.QueryCCH(),
                                   TRUE );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //    
    // Avoid the infamous ::$DATA bug
    //

    if ( wcschr( strFileName.QueryStr() + 2, L':' ) != NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        goto Finished;
    }

    //
    // Turn off NT file canonicalization
    //

    hr = MakePathCanonicalizationProof( strFileName.QueryStr(),
                                        &strFilePath );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // We may need to impersonate some other user to open the file
    //

    if ( pOpeningUser->_hToken != NULL )
    {
        if ( !SetThreadToken( NULL, pOpeningUser->_hToken ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        fImpersonated = TRUE;
    }

    //
    // Open the file
    //

    hFile = CreateFileW( strFilePath.QueryStr(),
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_DIRECTORY_FILE | FILE_FLAG_BACKUP_SEMANTICS,
                         NULL );
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }

    //
    // Stop impersonating
    // 

    if ( fImpersonated )
    {
        RevertToSelf();
        fImpersonated = FALSE;
    }

    //
    // We shouldn't be opening byte streams (like COM, LPT)
    //

    if ( GetFileType( hFile ) != FILE_TYPE_DISK )
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        
        CloseHandle( hFile );
        
        hFile = INVALID_HANDLE_VALUE;
        
        goto Finished;
    }

    //
    // Get file attributes
    //

    if ( !GetFileInformationByHandle( hFile,
                                      &FileInfo ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        CloseHandle( hFile );
        
        hFile = INVALID_HANDLE_VALUE;
        
        goto Finished;
    }

    //
    // Set the minimum properties now
    //

    _hFile = hFile;
    _ftLastWriteTime = FileInfo.ftLastWriteTime;
    _dwFileAttributes = FileInfo.dwFileAttributes;
    _nFileSizeLow   = FileInfo.nFileSizeLow;
    _nFileSizeHigh  = FileInfo.nFileSizeHigh;

    *((__int64 *)&_CastratedLastWriteTime)
        = (*((__int64 *)&_ftLastWriteTime) / 10000000) * 10000000;

    //
    // Create the ETag and LastModified strings
    //

    hr = GenerateETag();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    hr = GenerateLastModifiedTimeString();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Turn off the hidden attribute if this is a root directory listing
    // (root some times has the bit set for no apparent reason)
    //

    if ( _dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
    {
        if ( strFileName.QueryCCH() >= 2 )
        {
            if ( strFileName.QueryStr()[ 1 ] == L':' )
            {
                if ( ( strFileName.QueryStr()[ 2 ] == L'\0' ) ||
                     ( strFileName.QueryStr()[ 2 ] == L'\\' && 
                       strFileName.QueryStr()[ 3 ] == L'\0' ) )
                {
                    //
                    // This looks like a local root.  Mask out the bit
                    //
            
                    _dwFileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                }
            }
        }
    }

Finished:

    if ( FAILED( hr ) )
    {
        if ( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( hFile );
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    return hr;
}

HRESULT
W3_FILE_INFO::ReadSecurityDescriptor(
    VOID
)
/*++

Routine Description:

    Read security descriptor for current file

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD                   cbRequired;
    
    
    //
    // Cache the security descriptor
    //
    
    if ( !GetKernelObjectSecurity( _hFile,
                                   OWNER_SECURITY_INFORMATION
                                   | GROUP_SECURITY_INFORMATION
                                   | DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) _bufSecDesc.QueryPtr(),
                                   _bufSecDesc.QuerySize(),
                                   &cbRequired ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        DBG_ASSERT( cbRequired > _bufSecDesc.QuerySize() );
            
        if ( !_bufSecDesc.Resize( cbRequired ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        //
        // Try again with the bigger buffer.  No more excuses
        //
        
        if ( !GetKernelObjectSecurity( _hFile,
                                       OWNER_SECURITY_INFORMATION
                                       | GROUP_SECURITY_INFORMATION
                                       | DACL_SECURITY_INFORMATION,
                                       (PSECURITY_DESCRIPTOR) _bufSecDesc.QueryPtr(),
                                       _bufSecDesc.QuerySize(),
                                       &cbRequired ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO::MakeCacheable(
    FILE_CACHE_USER *       pFileUser
)
/*++

Routine Description:

    Make the file cacheable by reading contents into memory, and caching
    the security descriptor

Arguments:

    pFileUser - User trying to open file

Return Value:

    HRESULT

--*/
{
    DWORD                   dwError;
    HRESULT                 hr;
    W3_FILE_INFO_CACHE*     pFileCache;

    if ( pFileUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    DBG_ASSERT( IsCacheable() );
    
    //
    // We must have a file handle if we're here
    //
    
    DBG_ASSERT( _hFile != INVALID_HANDLE_VALUE );
   
    //
    // Get the security descriptor
    //
    
    hr = ReadSecurityDescriptor();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // On top of reading the security descriptor, we will also store the
    // last sid accessing the file if available
    //
    
    if ( pFileUser->_pSid != NULL )
    {
        if ( GetLengthSid( pFileUser->_pSid ) <= sizeof( _abLastSid ) )
        {
            memcpy( _abLastSid, 
                    pFileUser->_pSid,
                    GetLengthSid( pFileUser->_pSid ) );
            
            _pLastSid = (PSID) _abLastSid;
        }
    }
    
    //
    // Now read the contents of the file into memory since we cannot cache
    // the file handle itself
    //
    
    pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();

    dwError = pFileCache->ReadFileIntoMemoryCache( _hFile,
                                                   _nFileSizeLow,
                                                   (PVOID*) &_pFileBuffer );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // OK.  The contents are now in memory.  We can now close the file
        //
        
        CloseHandle( _hFile );
        _hFile = INVALID_HANDLE_VALUE;
        
        return NO_ERROR;
    }
    else
    {
        return HRESULT_FROM_WIN32( dwError );
    }
}

BOOL
W3_FILE_INFO::IsCacheable(
    VOID
) const
/*++

Routine Description:

    Is this file cacheable?  Specically, we should we even attempt to cache
    this file?

Arguments:

    None

Return Value:

    TRUE if cacheable 

--*/
{
    LARGE_INTEGER           liFileSize;
    W3_FILE_INFO_CACHE *    pFileCache;
   
    pFileCache = (W3_FILE_INFO_CACHE*) QueryCache();
    DBG_ASSERT( pFileCache != NULL );

    //
    // Are we past the limit of file entries?
    //
    
    if ( pFileCache->QueryElementLimitExceeded() )
    {
        return FALSE;
    }
    
    //
    // No caching of directories
    //
    
    if ( _dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        return FALSE;
    }
    
    //
    // No caching of file sizes greater than the configured threshold
    //
    
    liFileSize.LowPart = _nFileSizeLow;
    liFileSize.HighPart = _nFileSizeHigh;

    if ( liFileSize.QuadPart > pFileCache->QueryFileSizeThreshold() )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
W3_FILE_INFO::QueryIsOkToFlushDirmon(
    WCHAR *                 pszPath,
    DWORD                   cchPath
)
/*++

Routine Description:

    Determine whether this file entry should be flushed, given the path
    which has changed (dir monitor changed)

Arguments:

    pszPath - Path which changed
    cchPath - Size of path changed

Return Value:

    TRUE if we should flush, else FALSE

--*/
{
    DBG_ASSERT( _cacheKey._pszFileKey != NULL );
    
    if ( _wcsnicmp( _cacheKey._pszFileKey,
                    pszPath,
                    cchPath ) == 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//static
HRESULT
W3_FILE_INFO::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize W3_FILE_INFO lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_FILE_INFO );

    DBG_ASSERT( sm_pachW3FileInfo == NULL );
    
    sm_pachW3FileInfo = new ALLOC_CACHE_HANDLER( "W3_FILE_INFO",  
                                                &acConfig );

    if ( sm_pachW3FileInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3FileInfo. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_FILE_INFO::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup W3_FILE_INFO lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachW3FileInfo != NULL )
    {
        delete sm_pachW3FileInfo;
        sm_pachW3FileInfo = NULL;
    }
}

//static
VOID
W3_FILE_INFO_CACHE::MemoryCacheAdjustor(
    PVOID               pCache,
    BOOLEAN             TimerOrWaitFired
)
/*++

Routine Description:

    Called to adjust our memory cache size if necessary

Arguments:

    pCache - Points to file cache

Return Value:

    None

--*/
{
    W3_FILE_INFO_CACHE *        pFileCache;
    MEMORYSTATUSEX              MemoryStatus;
    
    pFileCache = (W3_FILE_INFO_CACHE*) pCache;

    MemoryStatus.dwLength = sizeof( MemoryStatus );

    GlobalMemoryStatusEx( &MemoryStatus );
    
    EnterCriticalSection( &( pFileCache->_csMemCache ) );

    pFileCache->_cbMemCacheLimit = min( 
            MemoryStatus.ullAvailPhys + pFileCache->_cbMemCacheCurrentSize,
            MemoryStatus.ullTotalVirtual ) / 2;

    LeaveCriticalSection( &( pFileCache->_csMemCache ) );
}

W3_FILE_INFO_CACHE::W3_FILE_INFO_CACHE()
{
    _cbFileSizeThreshold = DEFAULT_FILE_SIZE_THRESHOLD;
    _cbMemoryCacheSize = 0;
    _cMaxFileEntries = 0;
    _cbMemCacheLimit = 0;
    _cbMemCacheCurrentSize = 0;
    _cbMaxMemCacheSize = 0;
    _hMemCacheHeap = NULL;
    _hTimer = NULL;
    _fEnableCache = TRUE;
}

W3_FILE_INFO_CACHE::~W3_FILE_INFO_CACHE()
{
}

HRESULT
W3_FILE_INFO_CACHE::InitializeMemoryCache(
    VOID
)
/*++

Routine Description:

    Initialize the memory cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BOOL                    fRet;
    HRESULT                 hr = NO_ERROR;

    InitializeCriticalSection( &_csMemCache );
    
    //
    // If the memory cache size was not explicitly set, then we occasionally
    // check memory status when determining what to cache
    // 

    if ( _cbMemoryCacheSize == 0 )
    {
        MEMORYSTATUSEX          MemoryStatus;
        
        MemoryStatus.dwLength = sizeof( MemoryStatus );
    
        // 
        // Get our own estimate of size of cache
        //
        
        GlobalMemoryStatusEx( &MemoryStatus );
        
        _cbMemCacheLimit = min( MemoryStatus.ullAvailPhys,
                                MemoryStatus.ullTotalVirtual ) / 2;
    
        //
        // Setup timer so we can update our memory status
        //
                                  
        fRet = CreateTimerQueueTimer( &_hTimer,
                                      NULL,
                                      W3_FILE_INFO_CACHE::MemoryCacheAdjustor,
                                      this,
                                      30000,
                                      30000,
                                      WT_EXECUTELONGFUNCTION );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {   
        _cbMemCacheLimit = _cbMemoryCacheSize;
    }
    
    //
    // Allocate a private heap
    //
    
    if ( SUCCEEDED( hr ) ) 
    {
        _hMemCacheHeap = HeapCreate( 0, 0, 0 );
        if ( _hMemCacheHeap == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if ( FAILED( hr ) )
    {
        if ( _hMemCacheHeap != NULL )
        {
            HeapDestroy( _hMemCacheHeap );
            _hMemCacheHeap = NULL;
        }
        
        if ( _hTimer != NULL )
        {
            DeleteTimerQueueTimer( NULL,
                                   _hTimer, 
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
        }
        
        DeleteCriticalSection( &_csMemCache );
    }
    
    return hr;
}

HRESULT
W3_FILE_INFO_CACHE::ReadFileIntoMemoryCache( 
    IN HANDLE               hFile,
    IN DWORD                cbFile,
    OUT VOID **             ppvBuffer
)
/*++

Routine Description:

    Read contents of file into a buffer

Arguments:

    hFile - Handle to valid file
    cbFile - Size of file ( ==> size of buffer )
    ppvBuffer - Filled in with pointer to buffer with file contents.  Set
                to NULL on failure

Return Value:

    HRESULT

--*/
{
    BOOL                    bRet;
    VOID *                  pvBuffer = NULL;
    DWORD                   cbRead;
    OVERLAPPED              Overlapped;
    HRESULT                 hr = NO_ERROR;

    DBG_ASSERT( hFile && ( hFile != INVALID_HANDLE_VALUE ) );
    DBG_ASSERT( ppvBuffer != NULL );

    //
    // First check whether there will be room in cache for the blob 
    //

    EnterCriticalSection( &_csMemCache );
    
    if ( ( _cbMemCacheCurrentSize + cbFile ) > _cbMemCacheLimit ) 
    {
        // 
        // Not enough room for cache
        //
        
        LeaveCriticalSection( &_csMemCache );

        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    _cbMemCacheCurrentSize += cbFile;
    
    _cbMaxMemCacheSize = max( _cbMaxMemCacheSize, _cbMemCacheCurrentSize );

    LeaveCriticalSection( &_csMemCache );

    //
    // Allocate blob for file
    //
    
    DBG_ASSERT( _hMemCacheHeap != NULL );
    pvBuffer = HeapAlloc( _hMemCacheHeap, 0, cbFile );
    if ( pvBuffer == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Read file into blob
    //
    
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent = NULL;
    
    bRet = ReadFile( hFile,
                     pvBuffer,
                     cbFile,
                     &cbRead,
                     &Overlapped );

    if ( !bRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        if ( hr != HRESULT_FROM_WIN32( ERROR_IO_PENDING ) )
        {
            // 
            // Something bad happened
            //
            
            goto Finished;
        }
        else
        {
            //
            // Reset the error lest we confuse ourselves later on cleanup
            //
            
            hr = NO_ERROR;
        
            //
            // Wait for async read to complete
            //
                           
            bRet = GetOverlappedResult( hFile,
                                        &Overlapped,
                                        &cbRead,
                                        TRUE );
            if ( !bRet )
            {
                //
                // Something bad happened
                //
                
                hr = HRESULT_FROM_WIN32( GetLastError() );
                
                goto Finished;
            }
        }
    }

    //
    // Ensure that we read the number of bytes we expected to
    //
    
    if ( cbRead != cbFile )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
    }
    
Finished:
    
    if ( FAILED( hr ) )
    {
        //
        // Undo changes to memory cache statistics
        //
        
        EnterCriticalSection( &_csMemCache );

        _cbMemCacheCurrentSize -= cbFile;

        LeaveCriticalSection( &_csMemCache );
    
        if ( pvBuffer != NULL )
        {
            HeapFree( _hMemCacheHeap, 0, pvBuffer );
            pvBuffer = NULL;
        }
    }
    
    *ppvBuffer = pvBuffer;

    return hr;
}

HRESULT
W3_FILE_INFO_CACHE::ReleaseFromMemoryCache(
    IN VOID *                  pvBuffer,
    IN DWORD                   cbBuffer
)
/*++
Routine Description:

    Release file content blob from cache

Arguments:

    pvBuffer - Buffer to release
    cbBuffer - Size of buffer

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pvBuffer );

    DBG_ASSERT( _hMemCacheHeap != NULL);

    HeapFree( _hMemCacheHeap, 0, pvBuffer );
    
    EnterCriticalSection( &_csMemCache );
    
    _cbMemCacheCurrentSize -= cbBuffer;

    LeaveCriticalSection( &_csMemCache );    

    return NO_ERROR;    
}

VOID
W3_FILE_INFO_CACHE::TerminateMemoryCache(
    VOID
)
/*++

Routine Description:

    Terminate memory cache

Arguments:

Return Value:

    None

--*/
{
    if ( _hTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                               _hTimer, 
                               INVALID_HANDLE_VALUE );
        _hTimer = NULL;
    }
    
    if ( _hMemCacheHeap != NULL )
    {
        HeapDestroy( _hMemCacheHeap );
        _hMemCacheHeap = NULL;
    }

    DeleteCriticalSection( &_csMemCache );
}

HRESULT
W3_FILE_INFO_CACHE::GetFileInfo(
    STRU &                  strFileName,
    DIRMON_CONFIG *         pDirmonConfig,
    FILE_CACHE_USER *       pOpeningUser,
    BOOL                    fDoCache,
    W3_FILE_INFO **         ppFileInfo
)
/*++

Routine Description:

    Returns a W3_FILE_INFO for the given file path.  Depending on fDoCache, 
    this W3_FILE_INFO will be cached

Arguments:

    strFileName - file name to find
    pDirmonConfig - Dir monitor config
    pOpeningUser - Token for user accessing the cache
    fDoCache - Set to TRUE if we should attempt to cache if possible
    ppFileInfo - Points to W3_FILE_INFO on success

Return Value:

    HRESULT

--*/
{
    W3_FILE_INFO_KEY            fileKey;
    DIRMON_CONFIG               DefaultDirmonConfig;
    STACK_STRU(                 strParentDir, MAX_PATH );
    WCHAR *                     pszParentDir;
    W3_FILE_INFO *              pFileInfo;
    HRESULT                     hr;
    STACK_STRU(                 strFilePath, MAX_PATH );
    BOOL                        fShouldCacheHint = FALSE;
    
    if ( ppFileInfo == NULL || 
         pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppFileInfo = NULL;

    //
    // We need to upper case the path to avoid a bunch of insensitive
    // compares in the hash table lookup
    //
   
    hr = strFilePath.Copy( strFileName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    _wcsupr( strFilePath.QueryStr() );

    //
    // If the cache is enabled, lookup there first
    //

    if ( QueryCacheEnabled() )
    {
        //
        // Make a key for the lookup
        //
    
        hr = fileKey.CreateCacheKey( strFilePath.QueryStr(),
                                     strFilePath.QueryCCH(),
                                     FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    
        //
        // Look it up
        //
    
        hr = FindCacheEntry( &fileKey,
                             (CACHE_ENTRY**) &pFileInfo,
                             &fShouldCacheHint );
        if ( SUCCEEDED( hr ) )
        {
            DBG_ASSERT( pFileInfo != NULL );
            
            hr = pFileInfo->DoAccessCheck( pOpeningUser );
            if ( SUCCEEDED( hr ) ) 
            {
                *ppFileInfo = pFileInfo;
            }
            else
            {
                pFileInfo->DereferenceCacheEntry();
            }
        
            return hr;
        }
    }
    
    //
    // We will simply open the file and return the object
    //
    
    pFileInfo = new W3_FILE_INFO( this );
    if ( pFileInfo == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Open the file
    //
    
    hr = pFileInfo->OpenFile( strFilePath,
                              pOpeningUser );
    if ( FAILED( hr ) )
    {
        pFileInfo->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // If we aren't asked to cache the file, OR the file is not cacheable 
    // then we can return it now
    //
    
    if ( !QueryCacheEnabled() ||
         !fDoCache || 
         !pFileInfo->IsCacheable() ||
         !fShouldCacheHint )
    {
        *ppFileInfo = pFileInfo;
        return NO_ERROR;
    }
    
    //
    // If we're supposed to cache but no dirmon was configured, then just
    // assume the directory to monitor is the parent directory (and token
    // to use is NULL)
    //
    
    if ( pDirmonConfig == NULL )
    {
        DefaultDirmonConfig.hToken = NULL;
    
        pszParentDir = wcsrchr( strFilePath.QueryStr(), L'\\' );
        if ( pszParentDir != NULL )
        {
            hr = strParentDir.Copy( strFilePath.QueryStr(),
                                    DIFF( pszParentDir - strFilePath.QueryStr() ) );
            if ( SUCCEEDED( hr ) )
            {
                DefaultDirmonConfig.pszDirPath = strParentDir.QueryStr();
                pDirmonConfig = &DefaultDirmonConfig;
            }                   
        }        
    }
    
    //
    // If we still don't have a dir mon configuration, then just don't cache
    //
    
    if ( pDirmonConfig == NULL )
    {
        *ppFileInfo = pFileInfo;
        return NO_ERROR;
    }

    //
    // Start monitoring the appropriate directory for changes
    //
    
    hr = pFileInfo->AddDirmonInvalidator( pDirmonConfig );
    if ( FAILED( hr ) )
    {
        //
        // If we can't monitor the directory, then just don't cache the item
        //
        
        *ppFileInfo = pFileInfo;
        return NO_ERROR;
    }
    
    //
    // Attempt to cache the file.  Caching the file means reading the 
    // contents into memory, as well as caching the security descriptor
    //
    
    hr = pFileInfo->MakeCacheable( pOpeningUser );
    if ( FAILED( hr ) )
    {
        *ppFileInfo = pFileInfo;
        return NO_ERROR;
    }
    
    //
    // Insert into the hash table.  AddCacheEntry() will only error if some
    // thing fatal happened.  If someone else already added the item, that
    // is not fatal and we will simply return this item and it will cleanup
    // on dereference
    //
    
    AddCacheEntry( pFileInfo );
    
    *ppFileInfo = pFileInfo;
    
    return NO_ERROR;
}

HRESULT
W3_FILE_INFO_CACHE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the file cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD               dwError;
    DWORD               dwType;
    DWORD               dwValue;
    DWORD               cbData;
    DWORD               csecTTL = DEFAULT_W3_FILE_INFO_CACHE_TTL;
    DWORD               csecActivity = DEFAULT_W3_FILE_INFO_CACHE_ACTIVITY;
    HKEY                hKey = NULL;
    HRESULT             hr;
    CACHE_HINT_CONFIG   cacheHintConfig;
    
    //
    // Read the registry configuration of the file cache.
    // For now, that is just the legacy confiugration from IIS 5.x
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Should we be file caching at all?
        //
    
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"DisableMemoryCache",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _fEnableCache = dwValue ? FALSE : TRUE;
        }
        
        //
        // What is the biggest file we should cache in user mode?
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxCachedFileSize",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cbFileSizeThreshold = dwValue;
        }
        
        //
        // What is the size of our memory cache?  Size is in MB
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MemCacheSize",
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cbMemoryCacheSize = dwValue * (1024 * 1024);
        }

        //
        // Read the maximum # of files in cache
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxOpenFiles",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            _cMaxFileEntries = dwValue;
        }
        
        //
        // What is the TTL for the file cache?
        //

        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"ObjectCacheTTL",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            csecTTL = dwValue;
        }
        
        //
        // What is the activity period before putting into cache
        //
        
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"ActivityPeriod",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            csecActivity = dwValue;
        }
        
        RegCloseKey( hKey );
    }
    
    //
    // Initialize memory cache
    //
    
    hr = InitializeMemoryCache();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Setup cache hint config (for now hardcoded)
    //
    
    if ( csecActivity != 0 )
    {
        cacheHintConfig.cmsecActivityWindow = csecActivity * 1000;
        cacheHintConfig.cmsecScavengeTime = cacheHintConfig.cmsecActivityWindow * 2;
        cacheHintConfig.cmsecTTL = cacheHintConfig.cmsecActivityWindow * 2;
    }

    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_DIRMON_FLUSH |
                                CACHE_INVALIDATION_DIRMON_SPECIFIC,
                                csecActivity ? &cacheHintConfig : NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Initialize file info lookaside
    //
    
    return W3_FILE_INFO::Initialize();
}    

VOID
W3_FILE_INFO_CACHE::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate the file cache

Argument:

    None

Return Value:

    None

--*/
{
    TerminateMemoryCache();
    
    W3_FILE_INFO::Terminate();
}

VOID
W3_FILE_INFO_CACHE::DoDirmonInvalidationSpecific(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Handle dirmon invalidation

Arguments:

    pszPath - Path which changed

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_FILE_INFO_KEY        fileKey;
    
    DBG_ASSERT( pszPath != NULL );
    
    //
    // We're not flushing all, then just lookup given file and flush it
    //    
    
    hr = fileKey.CreateCacheKey( pszPath, 
                                 wcslen( pszPath ),
                                 FALSE );
    if ( SUCCEEDED( hr ) )
    {
        FlushCacheEntry( &fileKey );
    }
}

//static
W3_FILE_INFO_CACHE *
W3_FILE_INFO_CACHE::GetFileCache(
    VOID
)
{
    DBG_ASSERT( g_pW3Server != NULL );
    return g_pW3Server->QueryFileCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iiscertmap.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     iiscertmap.cxx

   Abstract:
     IIS Certificate mapping

 
   Author:
     Bilal Alam         (BAlam)         19-Apr-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"
#include <mbstring.h>



IIS_CERTIFICATE_MAPPING::IIS_CERTIFICATE_MAPPING( VOID )
    : _pCert11Mapper( NULL ),
      _pCertWildcardMapper( NULL ),
      _cRefs( 1 )
{
}

IIS_CERTIFICATE_MAPPING::~IIS_CERTIFICATE_MAPPING( VOID )
{
    if ( _pCert11Mapper != NULL )
    {
        delete _pCert11Mapper;
        _pCert11Mapper = NULL;
    }
    
    if ( _pCertWildcardMapper != NULL )
    {
        delete _pCertWildcardMapper;
        _pCertWildcardMapper = NULL;
    }
}

HRESULT
IIS_CERTIFICATE_MAPPING::Read11Mappings(
    DWORD                   dwSiteId
)
/*++

Routine Description:

    Read 1-1 mappings from metabase

Arguments:

    dwSiteId - Site ID (duh)

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    WCHAR                   achMBPath[ 256 ];
    HRESULT                 hr = NO_ERROR;
    WCHAR                   achMappingName[ MAX_PATH + 1 ];
    BOOL                    fRet;
    DWORD                   dwIndex;
    BYTE                    abBuffer[ 1024 ];
    BUFFER                  buff( abBuffer, sizeof( abBuffer ) );
    DWORD                   cbRequired;
    STACK_STRU(             strTemp, 64 );
    STACK_STRU(             strUserName, 64 );
    STACK_STRU(             strPassword, 64 );
    DWORD                   dwEnabled;
    CIisMapping *           pCertMapping;
    
    //
    // Setup the NSEPM path to get at 1-1 mappings
    //
    
    _snwprintf( achMBPath,
                sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                L"/LM/W3SVC/%d/<nsepm>/Cert11/Mappings",
                dwSiteId );
    
    //
    // Open the metabase and read 1-1 mapping properties
    // 
    
    fRet = mb.Open( achMBPath,
                    METADATA_PERMISSION_READ );
    if ( fRet )
    {
        dwIndex = 0;
        achMappingName[ 0 ] = L'/';
        
        for ( ; ; )
        {
            //
            // We will need to prepend the object name with '/'.  Hence
            // goofyness of sending an offseted pointed to name
            //
            
            fRet = mb.EnumObjects( L"",
                                   achMappingName + 1,
                                   dwIndex );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                break;
            }
            
            //
            // Get certificate blob
            //
            
            cbRequired = buff.QuerySize();
            
            fRet = mb.GetData( achMappingName,
                               MD_MAPCERT,
                               IIS_MD_UT_SERVER,
                               BINARY_METADATA,
                               buff.QueryPtr(),
                               &cbRequired,
                               METADATA_NO_ATTRIBUTES );
            if ( !fRet )
            {
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    DBG_ASSERT( cbRequired > buff.QuerySize() );
                    
                    if ( !buff.Resize( cbRequired ) )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }
                    
                    fRet = mb.GetData( achMappingName,
                                       MD_MAPCERT,
                                       IIS_MD_UT_SERVER,
                                       BINARY_METADATA,
                                       buff.QueryPtr(),
                                       &cbRequired,
                                       METADATA_NO_ATTRIBUTES );
                    if ( !fRet )
                    {
                        DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
            }
            
            //
            // Get NT account name
            //
            
            if ( !mb.GetStr( achMappingName,
                             MD_MAPNTACCT,
                             IIS_MD_UT_SERVER,
                             &strUserName ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
            
            //
            // Get NT password
            //
            
            if ( !mb.GetStr( achMappingName,
                             MD_MAPNTPWD,
                             IIS_MD_UT_SERVER,
                             &strPassword ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
            
            //
            // Is this mapping enabled?  
            //
            
            if ( !mb.GetDword( achMappingName,
                               MD_MAPENABLED,
                               IIS_MD_UT_SERVER,
                               &dwEnabled ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
            
            //
            // If this mapping is enabled, add it to 1-1 mapper
            //
            
            if ( dwEnabled )
            {
                if ( _pCert11Mapper == NULL )
                {
                    _pCert11Mapper = new CIisCert11Mapper();
                    if ( _pCert11Mapper == NULL )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }

                    //
                    // Reset() will configure default hierarchies
                    // If hierarchies are not configured then comparison (CIisMapping::Cmp() function 
                    // implemented in iismap.cxx) will fail 
                    // (and mapper will always incorrectly map to first available 1to1 mapping)
                    //

                    if(!_pCert11Mapper->Reset())
                    {
                        delete _pCert11Mapper;
                        _pCert11Mapper = NULL;
                        
                        hr = HRESULT_FROM_WIN32( GetLastError() );
                        break;
                    }
                }
                
                DBG_ASSERT( _pCert11Mapper != NULL );
                
                pCertMapping = _pCert11Mapper->CreateNewMapping();
                if ( pCertMapping == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }         
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_CERT, 
                                                     (CHAR*)buff.QueryPtr(),
                                                     cbRequired,
                                                     FALSE ) )
                {   
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                //
                // Encrypted metabase stuff returned as ANSI (LAME!!!!!)
                //
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_ACCT,
                                                     (CHAR*) strUserName.QueryStr() ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                if ( !pCertMapping->MappingSetField( IISMDB_INDEX_CERT11_NT_PWD,
                                                     (CHAR*) strPassword.QueryStr() ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }

                if ( !((CIisAcctMapper*)_pCert11Mapper)->Add( pCertMapping, FALSE ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
            } 
            
            dwIndex++;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    
    return hr;
}

HRESULT
IIS_CERTIFICATE_MAPPING::ReadWildcardMappings(
    DWORD                   dwSiteId
)
/*++

Routine Description:

    Read wildcard mappings from metabase

Arguments:

    dwSiteId - Site ID (duh)

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    WCHAR                   achMBPath[ 256 ];
    BOOL                    fRet;
    BYTE                    abBuffer[ 1024 ];
    BUFFER                  buff( abBuffer, sizeof( abBuffer ) );
    DWORD                   cbRequired;
    PUCHAR                  pLamePointer;
    
    //
    // Setup the NSEPM path to get at wildcard mappings
    //
    
    _snwprintf( achMBPath,
                sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                L"/LM/W3SVC/%d/<nsepm>/CertW",
                dwSiteId );

    //
    // Open the metabase and read wildcard mappings
    // 
    
    fRet = mb.Open( achMBPath,
                    METADATA_PERMISSION_READ );
    if ( fRet )
    {
        cbRequired = buff.QuerySize();
        
        fRet = mb.GetData( L"",
                           MD_SERIAL_CERTW,
                           IIS_MD_UT_SERVER,
                           BINARY_METADATA,
                           buff.QueryPtr(),
                           &cbRequired,
                           METADATA_NO_ATTRIBUTES );
        if ( !fRet )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                DBG_ASSERT( cbRequired > buff.QuerySize() );
                
                if ( !buff.Resize( cbRequired ) )
                {
                    return HRESULT_FROM_WIN32( GetLastError() );
                }
                
                fRet = mb.GetData( L"",
                                   MD_SERIAL_CERTW,
                                   IIS_MD_UT_SERVER,
                                   BINARY_METADATA,
                                   buff.QueryPtr(),
                                   &cbRequired,
                                   METADATA_NO_ATTRIBUTES );
                if ( !fRet )
                {
                    DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                    
                    return HRESULT_FROM_WIN32( GetLastError() );
                }
            }
            
            return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        
        //
        // Thanx to the man, I can just unserialize.  XBF rocks ;-)
        //
        
        DBG_ASSERT( _pCertWildcardMapper == NULL );
        
        _pCertWildcardMapper = new CIisRuleMapper();
        if ( _pCertWildcardMapper == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        pLamePointer = (PUCHAR) buff.QueryPtr();
        
        fRet = _pCertWildcardMapper->Unserialize( &pLamePointer,
                                                  &cbRequired );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );        
    }
    
    return NO_ERROR;
}


//static
HRESULT
IIS_CERTIFICATE_MAPPING::GetCertificateMapping(
    DWORD                   dwSiteId,
    IIS_CERTIFICATE_MAPPING **  ppCertificateMapping
)
/*++

Routine Description:

    Read appropriate metabase configuration to get configured IIS
    certificate mapping

Arguments:

    dwSiteId - Site ID (duh)
    ppCertificateMapping - Filled with certificate mapping descriptor on
                           success

Return Value:

    HRESULT

--*/
{
    IIS_CERTIFICATE_MAPPING *       pCertMapping = NULL;
    HRESULT                     hr = NO_ERROR;
    
    if ( ppCertificateMapping == NULL )
    {   
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppCertificateMapping = NULL;
    
    //
    // Create a certificate mapping descriptor
    //
    
    pCertMapping = new IIS_CERTIFICATE_MAPPING();
    if ( pCertMapping == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Read 1-1 mappings
    //
    
    hr = pCertMapping->Read11Mappings( dwSiteId );
    if ( FAILED( hr ) &&
         hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        goto Finished;
    }
    hr = NO_ERROR;

    //
    // Read wildcards
    //
    
    hr = pCertMapping->ReadWildcardMappings( dwSiteId );
    if ( FAILED( hr ) &&
         hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
    {
        goto Finished;
    }
    hr = NO_ERROR;
    
Finished:
    if ( FAILED( hr ) )
    {
        if ( pCertMapping != NULL )
        {
            delete pCertMapping;
        } 
    }
    else
    {
        DBG_ASSERT( pCertMapping != NULL );
        *ppCertificateMapping = pCertMapping;
    }
    
    return hr;
}


HRESULT
IIS_CERTIFICATE_MAPPING::DoMapCredential(
    PBYTE                   pClientCertBlob,
    DWORD                   cbClientCertBlob,
    TOKEN_CACHE_ENTRY **    ppCachedToken,
    BOOL *                  pfClientCertDeniedByMapper
)
{
    CIisMapping *           pQuery;
    CIisMapping *           pResult;
    CHAR                    achUserName[ UNLEN + 1 ];
    LPSTR                   pszUserName;
    DWORD                   cbUserName;
    CHAR                    achPassword[ PWLEN + 1 ];
    LPSTR                   pszPassword;
    DWORD                   cbPassword;
    CHAR *                  pszDomain;
    DWORD                   dwEnabled = 0;
    DWORD                   cbEnabled;
    BOOL                    fMatch = FALSE;
    DWORD                   dwLogonError = NO_ERROR;
    HRESULT                 hr = S_OK;
    //
    // add 1 to strUserDomainW for separator "\"
    //
    STACK_STRU(             strUserDomainW, UNLEN + IIS_DNLEN + 1 + 1 );
    STACK_STRU(             strUserNameW, UNLEN + 1 );
    STACK_STRU(             strPasswordW, PWLEN + 1 );

    DBG_ASSERT( pClientCertBlob   != NULL );
    DBG_ASSERT( cbClientCertBlob != 0 );
    DBG_ASSERT( ppCachedToken != NULL );
    DBG_ASSERT( pfClientCertDeniedByMapper != NULL );

    
    //
    // First try the 1-1 mapper
    //
    

    if ( _pCert11Mapper != NULL )
    {
        //
        // Build a query mapping to check
        //
        
        pQuery = _pCert11Mapper->CreateNewMapping( pClientCertBlob,
                                                   cbClientCertBlob );
        if ( pQuery == NULL )
        {
            return SEC_E_INTERNAL_ERROR;
        }

        _pCert11Mapper->Lock();
       
        if ( _pCert11Mapper->FindMatch( pQuery,
                                       &pResult ) )
        {
            //
            // Awesome.  We found a match.  Do the deed if the rule is 
            // enabled
            //
            
            if ( pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT,
                                            &pszUserName,
                                            &cbUserName,
                                            FALSE ) &&
                 pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_PWD,
                                            &pszPassword,
                                            &cbPassword,
                                            FALSE ) )
            {
                //
                // No need to check for Enabled (IISMDB_INDEX_CERT11_ENABLED)
                // since Read11Mappings() will build mapping table consisting only 
                // of enabled mappings
                //

                strncpy( achUserName,
                         pszUserName,
                          UNLEN );
                achUserName[ UNLEN ] = '\0';                    
                
                strncpy( achPassword,
                         pszPassword,
                         PWLEN );
                achPassword[ PWLEN ] = '\0';
                
                fMatch = TRUE;
            }
        }
        
        _pCert11Mapper->Unlock();
        
        delete pQuery;
        pQuery = NULL;
    }
    
    //
    // Try the wildcard mapper if we still haven't found a match
    //
    
    if ( !fMatch &&
         _pCertWildcardMapper != NULL )
    {

        PCCERT_CONTEXT pClientCert = CertCreateCertificateContext(
                                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                pClientCertBlob,
                                                cbClientCertBlob );
        if ( pClientCert == NULL )
        {
            DBG_ASSERT( pClientCert != NULL );
        }
        else if ( !_pCertWildcardMapper->Match( (PCERT_CONTEXT) (pClientCert),
                                           NULL, // legacy value
                                           achUserName,
                                           achPassword ) )
        {
            //
            // If the mapping rule is denied then return 
            // a NULL pointer through ppCachedToken with SEC_E_OK.
            // That indicated to caller that mapping was denied
            //
            
            if ( GetLastError() == ERROR_ACCESS_DENIED )
            {
                *ppCachedToken = NULL;
                *pfClientCertDeniedByMapper = TRUE;

                if ( pClientCert != NULL )
                {
                    CertFreeCertificateContext( pClientCert );
                    pClientCert = NULL;
                }

                return SEC_E_OK;
            }
        }
        else
        {
            fMatch = TRUE;
        }
        
        if ( pClientCert != NULL )
        {
            CertFreeCertificateContext( pClientCert );
            pClientCert = NULL;
        }
    }
    
    //
    // If we still haven't found a match, then return error
    //
         
    if ( fMatch )
    {
        //
        // Split up the user name into domain/user if needed
        //
        
        pszUserName = (LPSTR) _mbspbrk( (UCHAR*) achUserName, (UCHAR*) "/\\" );
        if ( pszUserName == NULL )
        {
            //
            // No domain in the user name.  First try the metabase domain 
            // name
            //

            // 
            // BUGBUG: DefaultLogonDomain is not used for cert mapping at all
            //
            
            pszDomain = "";
            pszUserName = achUserName;
        }
        else
        {
            *pszUserName = '\0';
            pszDomain = achUserName;
            pszUserName = pszUserName + 1;
        }

        //
        // Convert domain, user and password to unicode 
        //
    
        hr = strUserNameW.CopyA( pszUserName );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }

        hr = strUserDomainW.CopyA( pszDomain );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }

        hr = strPasswordW.CopyA( achPassword );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // We should have valid credentials to call LogonUser()
        //
        DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
        hr = g_pW3Server->QueryTokenCache()->GetCachedToken(
                                             strUserNameW.QueryStr(),
                                             strUserDomainW.QueryStr(),
                                             strPasswordW.QueryStr(),
                                             LOGON32_LOGON_INTERACTIVE,
                                             FALSE,                // BUGBUG not UPN logon
                                             ppCachedToken,
                                             &dwLogonError );
        if ( FAILED( hr ) )
        {
            return SEC_E_UNKNOWN_CREDENTIALS;
        }                                          
        //
        // If *ppCachedToken is NULL, then logon failed
        //

        if ( *ppCachedToken == NULL )
        {
            //
            // Note: With IIS5 we used to log logon failure to event log
            // however it doesn't seem to be necessary because if logon/logoff auditing is enabled
            // then security log would have relevant information about the logon failure
            //
            DBG_ASSERT( dwLogonError != ERROR_SUCCESS );
            return SEC_E_UNKNOWN_CREDENTIALS;
        }

        DBG_ASSERT( (*ppCachedToken)->CheckSignature() );
        *pfClientCertDeniedByMapper = FALSE;
        return SEC_E_OK;
    }
    
    return SEC_E_UNKNOWN_CREDENTIALS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\handlerequest.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     handlerequest.cxx

   Abstract:
     Handle request state
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"
#include "isapi_handler.h"
#include "cgi_handler.h"
#include "trace_handler.h"
#include "dav_handler.h"
#include "generalhandler.hxx"

W3_STATE_HANDLE_REQUEST::W3_STATE_HANDLE_REQUEST()
{
    BOOL    fStaticInit = FALSE;
    BOOL    fCGIInit = FALSE;
    BOOL    fTraceInit = FALSE;
    BOOL    fISAPIInit = FALSE;
    BOOL    fDAVInit = FALSE;
    BOOL    fGeneralInit = FALSE;

    //
    // Initialize static file handler
    //
    
    _hr = W3_STATIC_FILE_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fStaticInit = TRUE;
    
    //
    // Initialize ISAPI handler
    //
    
    _hr = W3_ISAPI_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fISAPIInit = TRUE;

    //
    // Initialize CGI handler
    //
    
    _hr = W3_CGI_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fCGIInit = TRUE;

    //
    // Initialize Trace handler
    //

    _hr = W3_TRACE_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fTraceInit = TRUE;

    //
    // Initialize DAV handler
    //

    _hr = W3_DAV_HANDLER::Initialize();
    if ( FAILED( _hr ) ) 
    {
        goto Failure;
    }
    fDAVInit = TRUE;
    
    //
    // Initialize general handler
    //
    
    _hr = W3_GENERAL_HANDLER::Initialize();
    if ( FAILED( _hr ) )
    {
        goto Failure;
    }
    fGeneralInit = TRUE;
    
    return;
    
Failure:
    if ( fGeneralInit )
    {
        W3_GENERAL_HANDLER::Terminate();
    }

    if ( fDAVInit )
    {
        W3_DAV_HANDLER::Terminate();
    }
    
    if ( fCGIInit )
    {
        W3_CGI_HANDLER::Terminate();
    }
    
    if ( fISAPIInit )
    {
        W3_ISAPI_HANDLER::Terminate();
    }

    if ( fStaticInit )
    {
        W3_STATIC_FILE_HANDLER::Terminate();
    }
}

W3_STATE_HANDLE_REQUEST::~W3_STATE_HANDLE_REQUEST()
{
    if ( FAILED( _hr ) )
    {
        return;
    }
    
    W3_STATIC_FILE_HANDLER::Terminate();
    
    W3_ISAPI_HANDLER::Terminate();
    
    W3_CGI_HANDLER::Terminate();
    
    W3_DAV_HANDLER::Terminate();
    
    W3_GENERAL_HANDLER::Terminate();
}

CONTEXT_STATUS
W3_STATE_HANDLE_REQUEST::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle the request.

    This routine should determine and invoke the appropriate request 
    handler. 

Arguments:

    pMainContext - Mainline context
    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion status
    
Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                             hr = NO_ERROR;
    BOOL                                fImmediateFinish = FALSE;

    //
    // We must NOT allow any handlers to store state with the context
    // (that would screw up child execution)
    //

    DBG_ASSERT( pMainContext->QueryContextState() == NULL );

    //
    // We must have a user by now!
    //

    DBG_ASSERT( pMainContext->QueryUserContext() != NULL );

    //
    // What handler should handle this request?
    //
        
    hr = pMainContext->DetermineHandler( TRUE );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // If we were successful, but no handler was set, then there must 
    // be an error for us to send
    //
    
    if ( pMainContext->QueryHandler() == NULL )
    {
        DBG_ASSERT( pMainContext->QueryResponse()->QueryStatusCode() != 200 );
        
        hr = pMainContext->SendResponse( W3_FLAG_ASYNC );
    }
    else
    {
        hr = pMainContext->ExecuteHandler( W3_FLAG_ASYNC,
                                           &fImmediateFinish ); 
    }
    
    //
    // If the execution succeeded, then we expect a completion so bail
    //
    
    if ( SUCCEEDED( hr ) )
    {
        if ( fImmediateFinish )
        {
            return CONTEXT_STATUS_CONTINUE;
        }
        else
        {
            return CONTEXT_STATUS_PENDING;
        }
    }
    
Failure:

    pMainContext->SetErrorStatus( hr );
    pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
    pMainContext->SetFinishedResponse();

    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iisdigestprovider.cxx ===
/*++
   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     iisdigestprovider.cxx

   Abstract:
     IIS Digest authentication provider
     - version of Digest auth as implemented by IIS5 and IIS5.1
 
   Author:
     Jaroslad - based on code from md5filt      10-Nov-2000
     

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "iisdigestprovider.hxx"
#include "uuencode.hxx"

# include <mbstring.h>

#include <lm.h>
#include <lmcons.h>
#include <lmjoin.h>

#include <time.h>
//
// lonsint.dll related heade files
//
#include <lonsi.hxx>
#include <tslogon.hxx>

#define DIGEST_AUTH         "Digest"

//
// value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAMES
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME,
    MD5_AUTH_URI,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_DIGEST,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_QOP,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_LAST,
};

//
// Value names used by MD5 authentication.
// must be in sync with MD5_AUTH_NAME
//

PSTR MD5_AUTH_NAMES[] = {
    "username",
    "uri",
    "realm",
    "nonce",
    "response",
    "algorithm",
    "digest",
    "opaque",
    "qop",
    "cnonce",
    "nc"
};

//
// Local function implementation
//


static 
LPSTR
SkipWhite(
    IN OUT LPSTR p
)
/*++

Routine Description:

    Skip white space and ','

Arguments:

    p - ptr to string

Return Value:

    updated ptr after skiping white space

--*/
{
    while ( SAFEIsSpace((UCHAR)(*p) ) || *p == ',' )
    {
        ++p;
    }

    return p;
}

//
// class IIS_DIGEST_AUTH_PROVIDER implementation
//

//static 
STRA *   IIS_DIGEST_AUTH_PROVIDER::_pstraComputerDomain = NULL;


//static
HRESULT
IIS_DIGEST_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize IIS Digest SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;

    SetInternalId( dwInternalId );

    _pstraComputerDomain = new STRA;
    if( _pstraComputerDomain == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY);
    }
        
    //
    // Ignore errors that may occur while retrieving domain name
    // it is important but not critical information
    // client can always explicitly specify domain
    //

    GetLanGroupDomainName( *_pstraComputerDomain );


    hr = IIS_DIGEST_CONN_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing Digest Auth Prov.  hr = %x\n",
                    hr ));
        return hr;
    }
    return NO_ERROR;
}

//static
VOID
IIS_DIGEST_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate IIS SSPI Digest provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    if( _pstraComputerDomain != NULL )
    {
        delete _pstraComputerDomain;
    }
    
    IIS_DIGEST_CONN_CONTEXT::Terminate();
}

HRESULT
IIS_DIGEST_AUTH_PROVIDER::DoesApply(
    IN  W3_MAIN_CONTEXT *           pMainContext,
    OUT BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the Digest 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if Digest is applicable
    
    
Return Value:

    HRESULT

--*/
{
    CHAR *                  pszAuthHeader   = NULL;
    W3_METADATA *           pMetaData       = NULL;    
    HRESULT                 hr              = E_FAIL;
    STACK_STRA(             strPackage, 64 );
        
    
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pfApplies != NULL );
    
    *pfApplies = FALSE;

    //
    // Is using of Digest SSP enabled?    
    //
    if ( g_pW3Server->QueryUseDigestSSP() )
    {
        //
        // Digest SSP is enabled => IIS Digest cannot be used
        //

        return NO_ERROR;
    }

    //
    // Get the auth type
    //
    
    if ( FAILED( hr = pMainContext->QueryRequest()->GetAuthType( &strPackage ) ) )
    {
        return hr;
    }
    
    //
    // No package, no auth
    //
    
    if ( strPackage.IsEmpty() )
    {
        return NO_ERROR;
    }
    
    //
    // Is it Digest?
    //
    
    if ( strPackage.EqualsNoCase( DIGEST_AUTH ) )
    {
        *pfApplies = TRUE;
    }
    
    return NO_ERROR;
}



HRESULT
IIS_DIGEST_AUTH_PROVIDER::DoAuthenticate(
    IN  W3_MAIN_CONTEXT *       pMainContext
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{

    HRESULT                     hr                          = E_FAIL;
    IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext          = NULL;
    PCHAR                       pszAuthHeader               = NULL;
    BOOL                        fQOPAuth                    = FALSE;
    BOOL                        fSt                         = FALSE;
    HANDLE                      hAccessTokenImpersonation   = NULL;
    IIS_DIGEST_USER_CONTEXT *   pUserContext                = NULL;
    W3_METADATA *               pMetaData                   = NULL;    
    BOOL                        fSendAccessDenied           = FALSE;

    STACK_STRA(                 straVerb, 10 );
    STACK_STRU(                 strDigestUri, MAX_URL_SIZE + 1 );
    STACK_STRU(                 strUrl, MAX_URL_SIZE + 1 );
    STACK_STRA(                 straCurrentNonce, NONCE_SIZE + 1 );
    LPSTR                       aValueTable[ MD5_AUTH_LAST ];
    DIGEST_LOGON_INFO           DigestLogonInfo;
    CHAR                        achDomain[ IIS_DNLEN + 1 ];
    CHAR                        achNtUser[ 64 ];
    STACK_STRA(                 straUserName, UNLEN + 1 );
    STACK_STRA(                 straDomainName, IIS_DNLEN + 1 );
    STACK_STRA(                 straMetabaseDomainName, IIS_DNLEN + 1 );
    ULONG                       cbBytesCopied;

    DBG_ASSERT( pMainContext != NULL );

    //
    // Get the part after the auth type
    //
    
    pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );

    DBG_ASSERT( pszAuthHeader != NULL );
    DBG_ASSERT( _strnicmp( pszAuthHeader, DIGEST_AUTH, sizeof(DIGEST_AUTH) - 1 ) == 0 );

    //
    // Skip the name of Authentication scheme
    //

    if ( pszAuthHeader[ sizeof(DIGEST_AUTH) ] == '\0' )
    {
        DBG_ASSERT( pszAuthHeader[ sizeof(DIGEST_AUTH) - 1 ] != '\0' );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
        goto ExitPoint;
    }
    pszAuthHeader = pszAuthHeader + sizeof(DIGEST_AUTH) - 1;

    if ( !IIS_DIGEST_CONN_CONTEXT::ParseForName( pszAuthHeader,
                                                 MD5_AUTH_NAMES,
                                                 MD5_AUTH_LAST,
                                                 aValueTable ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }
    
    //
    // Simple validation of received arguments
    //

    if ( aValueTable[ MD5_AUTH_USERNAME ] == NULL ||
         aValueTable[ MD5_AUTH_REALM ] == NULL ||
         aValueTable[ MD5_AUTH_URI ] == NULL ||
         aValueTable[ MD5_AUTH_NONCE ] == NULL ||
         aValueTable[ MD5_AUTH_RESPONSE ] == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }

    //
    // Verify quality of protection (qop) required by client
    // We only support "auth" type. If anything else is sent by client it will be ignored
    //
    
    if ( aValueTable[ MD5_AUTH_QOP ] != NULL )
    {
        if ( _stricmp( aValueTable[ MD5_AUTH_QOP ], "auth" ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto ExitPoint;
        }

        //
        // qop="auth" has mandatory arguments CNONCE and NC
        //
           
        if ( aValueTable[ MD5_AUTH_CNONCE ] == NULL ||
             aValueTable[ MD5_AUTH_NC ] == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto ExitPoint;
        }
        
        fQOPAuth = TRUE;
    }
    else
    {
        aValueTable[ MD5_AUTH_QOP ]    = "none";
        aValueTable[ MD5_AUTH_CNONCE ] = "none";
        aValueTable[ MD5_AUTH_NC ]     = "none";
    }

    if ( FAILED( hr = straCurrentNonce.Copy( aValueTable[ MD5_AUTH_NONCE ] ) ) )
    {
        goto ExitPoint;
    }

    //
    // Verify that the nonce is well-formed
    //
    if ( !IIS_DIGEST_CONN_CONTEXT::IsWellFormedNonce( straCurrentNonce ) )
    {
        fSendAccessDenied = TRUE;
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }

    //
    // What is the request verb?
    //

    if ( FAILED( hr = pMainContext->QueryRequest()->GetVerbString( &straVerb ) ) )
    {
        goto ExitPoint;
    }

    //
    // Check URI field match URL
    //

    if ( strlen(aValueTable[MD5_AUTH_URI]) > MAX_URL_SIZE )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }

    //
    // Normalize DigestUri 
    //

    hr = UlCleanAndCopyUrl( (PUCHAR)aValueTable[MD5_AUTH_URI],
                            strlen( aValueTable[MD5_AUTH_URI] ),
                            &cbBytesCopied,
                            strDigestUri.QueryStr(),
                            NULL );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    if ( FAILED( hr = pMainContext->QueryRequest()->GetUrl( &strUrl ) ) )
    {
        goto ExitPoint;
    }

    if ( !strUrl.Equals( strDigestUri.QueryStr() ) )
    {
        //
        // Note: RFC says that BAD REQUEST should be returned
        // but for now to be backward compatible with IIS5.1
        // we will return ACCESS_DENIED
        //
        fSendAccessDenied = TRUE;

        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }


    pDigestConnContext = (IIS_DIGEST_CONN_CONTEXT *)
                         QueryConnectionAuthContext( pMainContext );

    if ( pDigestConnContext == NULL )
    {
        //
        // Create new Authentication context
        //

        pDigestConnContext = new IIS_DIGEST_CONN_CONTEXT();
        if ( pDigestConnContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ExitPoint;
        }

        hr = SetConnectionAuthContext(  pMainContext, 
                                        pDigestConnContext );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
    }
    

    DBG_ASSERT( pDigestConnContext != NULL );

    if ( FAILED( hr = pDigestConnContext->GenerateNonce( ) ) )
    {
        goto ExitPoint;
    }


    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if ( FAILED( hr = straMetabaseDomainName.CopyW( pMetaData->QueryDomainName() ) ) )
    {
        goto ExitPoint;
    }
    
    if ( FAILED( hr = BreakUserAndDomain(   aValueTable[ MD5_AUTH_USERNAME ],
                                            straMetabaseDomainName,
                                            straDomainName,
                                            straUserName ) ) )
    {
        goto ExitPoint;
    }
        
    DigestLogonInfo.pszNtUser       = straUserName.QueryStr();
    DigestLogonInfo.pszDomain       = straDomainName.QueryStr();
    DigestLogonInfo.pszUser         = aValueTable[ MD5_AUTH_USERNAME ];
    DigestLogonInfo.pszRealm        = aValueTable[ MD5_AUTH_REALM ];
    DigestLogonInfo.pszURI          = aValueTable[ MD5_AUTH_URI ];
    DigestLogonInfo.pszMethod       = straVerb.QueryStr();
    DigestLogonInfo.pszNonce        = straCurrentNonce.QueryStr();
    DigestLogonInfo.pszCurrentNonce = pDigestConnContext->QueryNonce().QueryStr();
    DigestLogonInfo.pszCNonce       = aValueTable[ MD5_AUTH_CNONCE ];
    DigestLogonInfo.pszQOP          = aValueTable[ MD5_AUTH_QOP ];
    DigestLogonInfo.pszNC           = aValueTable[ MD5_AUTH_NC ];
    DigestLogonInfo.pszResponse     = aValueTable[ MD5_AUTH_RESPONSE ];

    fSt = IISLogonDigestUserA( &DigestLogonInfo,
                            IISSUBA_DIGEST ,
                            &hAccessTokenImpersonation );
    if ( fSt == FALSE )
    {
        DWORD dwRet = GetLastError();
        if ( dwRet == ERROR_PASSWORD_MUST_CHANGE ||
            dwRet == ERROR_PASSWORD_EXPIRED )
        {
            return HRESULT_FROM_WIN32( dwRet );
        }

        fSendAccessDenied = TRUE;

        hr = HRESULT_FROM_WIN32( dwRet );

        goto ExitPoint;
    }

    //
    // Response from the client was correct but the nonce has expired,
    // 

    if ( pDigestConnContext->IsExpiredNonce( straCurrentNonce,
                                             pDigestConnContext->QueryNonce() ) )
    {

        //
        // User knows password but nonce that was used for 
        // response calculation already expired
        // Respond to client with stale=TRUE
        // Only Digest header will be sent to client
        // ( it will prevent state information needed to be passed
        //  from DoAuthenticate() to OnAccessDenied() )
        //
        
        pDigestConnContext->SetStale( TRUE );

        hr = SetDigestHeader( pMainContext, pDigestConnContext );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
        //
        // Don't let anyone else send back authentication headers when
        // the 401 is sent
        //
        
        pMainContext->SetProviderHandled( TRUE );

        //
        // We need to send a 401 response to continue the handshake.  
        // We have already setup the WWW-Authenticate header
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        pMainContext->SetFinishedResponse();

        pMainContext->SetErrorStatus( SEC_E_CONTEXT_EXPIRED );
        hr = NO_ERROR;
        
        goto ExitPoint;
    }

    //
    // We successfully authenticated.
    // Create a user context and setup it up
    //

    DBG_ASSERT( hAccessTokenImpersonation != NULL );
    
    pUserContext = new IIS_DIGEST_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ExitPoint;
    } 
    
    hr = pUserContext->Create( hAccessTokenImpersonation,
                               aValueTable[MD5_AUTH_USERNAME] );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        goto ExitPoint;
    }
    
    pMainContext->SetUserContext( pUserContext );        

    hr = NO_ERROR;

ExitPoint:

    if ( FAILED( hr ) )
    {
        if ( fSendAccessDenied )
        {
            //
            // if ACCESS_DENIED then inform server to send 401 response
            // if SetStatus is not called then server will respond
            // with 500 Server Error
            //

            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );

            //
            // SetErrorStatus() and reset value of hr
            //

            pMainContext->SetErrorStatus( hr );

            hr = NO_ERROR;
        }
        if ( hAccessTokenImpersonation != NULL )
        {
            CloseHandle( hAccessTokenImpersonation );
            hAccessTokenImpersonation = NULL;
        }
    }
    return hr;
}


HRESULT
IIS_DIGEST_AUTH_PROVIDER::OnAccessDenied(
    IN  W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    HRESULT                     hr                    = E_FAIL;
    W3_METADATA *               pMetaData             = NULL;
    IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext    = NULL;
    
    DBG_ASSERT( pMainContext != NULL );

    //
    // 2 providers implement Digest but they are mutually exclusive
    // If DigestSSP is enabled then IIS-DIGEST cannot be used
    //
    if ( g_pW3Server->QueryUseDigestSSP() )
    {
        //
        // Digest SSP is enabled => IIS Digest cannot be used
        //
        return NO_ERROR;
    }

    if( !W3_STATE_AUTHENTICATION::QueryIsDomainMember() )
    {
        //
        // We are not a domain member, so do nothing
        //
        return NO_ERROR;
    }

    pDigestConnContext = (IIS_DIGEST_CONN_CONTEXT *)
                         QueryConnectionAuthContext( pMainContext );

    if ( pDigestConnContext == NULL )
    {
        //
        // Create new Authentication context
        // it may get reused for next request 
        // if connection is reused
        //

        pDigestConnContext = new IIS_DIGEST_CONN_CONTEXT();
        if ( pDigestConnContext == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        hr = SetConnectionAuthContext(  pMainContext, 
                                        pDigestConnContext );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return SetDigestHeader( pMainContext, pDigestConnContext );
}



HRESULT
IIS_DIGEST_AUTH_PROVIDER::SetDigestHeader(
    IN  W3_MAIN_CONTEXT *       pMainContext,
    IN IIS_DIGEST_CONN_CONTEXT *   pDigestConnContext  
)
/*++

  Description:
    
    Add WWW-Authenticate Digest headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    HRESULT                     hr                    = E_FAIL;
    BOOL                        fStale                = FALSE;
    W3_METADATA *               pMetaData             = NULL;
   
    STACK_STRA(                 strOutputHeader, MAX_PATH + 1); 
    STACK_STRA(                 strNonce, NONCE_SIZE + 1  ); 


    DBG_ASSERT( pMainContext != NULL );

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );


    fStale = pDigestConnContext->QueryStale(  );    
    
    //
    // Reset Stale so that it will not be used for next request
    //

    pDigestConnContext->SetStale( FALSE );

    if ( FAILED( hr = pDigestConnContext->GenerateNonce() ) )
    {
        return hr;
    }

    //
    // If a realm is configured, use it.  Otherwise use host address of 
    // request 
    //

    STACK_STRA(      straRealm, IIS_DNLEN + 1 );
    STACK_STRU(      strHostAddr, 256       );

    if ( pMetaData->QueryRealm() != NULL )
    {
        hr = straRealm.CopyW( pMetaData->QueryRealm() );
    }
    else
    {
        hr = pMainContext->QueryRequest()->GetHostAddr( &strHostAddr );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        hr = straRealm.CopyW( strHostAddr.QueryStr() );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // build WWW-Authenticate header
    //
    
    if ( FAILED( hr = strOutputHeader.Copy( "Digest qop=\"auth\", realm=\"" ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( straRealm ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( "\", nonce=\"" ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( pDigestConnContext->QueryNonce() ) ) )
    {
        return hr;
    }
    if ( FAILED( hr = strOutputHeader.Append( fStale ? "\", stale=true" : "\"" ) ) )
    {
        return hr;
    }

    //
    //  Add the header WWW-Authenticate to the response 
    //

    hr = pMainContext->QueryResponse()->SetHeader(
                                        "WWW-Authenticate",
                                        16,
                                        strOutputHeader.QueryStr(),
                                        strOutputHeader.QueryCCH() 
                                        );
    return hr;
}


//static 
HRESULT
IIS_DIGEST_AUTH_PROVIDER::GetLanGroupDomainName( 
    OUT  STRA& straDomain
)
/*++

Routine Description:

    Tries to retrieve the "LAN group"/domain this machine is a member of.

Arguments:

    straDomain - receives current domain name

Returns:

    HRESULT

--*/
{
    //
    // NET_API_STATUS is equivalent to WIN32 errors
    //
    NET_API_STATUS          dwStatus        = 0;
    NETSETUP_JOIN_STATUS    JoinStatus;
    LPWSTR                  pwszDomainInfo  = NULL;
    HRESULT                 hr              = E_FAIL;

    dwStatus = NetGetJoinInformation( NULL,
                                      &pwszDomainInfo,
                                      &JoinStatus );
    if( dwStatus == NERR_Success)
    {
        if ( JoinStatus == NetSetupDomainName )
        {
            //
            // we got a domain
            //
            DBG_ASSERT( pwszDomainInfo != NULL );
            if ( FAILED( hr = straDomain.CopyW( pwszDomainInfo ) ) )
            {
                goto ExitPoint;
            }
        }
        else
        {
            //
            // Domain information is not available
            // (maybe server is member of workgroup)
            //
        
            straDomain.Reset();
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwStatus );
        goto ExitPoint;
    }

    hr = NO_ERROR;

ExitPoint:
    if ( pwszDomainInfo != NULL )
    {
        NetApiBufferFree( (LPVOID) pwszDomainInfo );
    }

    return hr;
}


//static 
HRESULT
IIS_DIGEST_AUTH_PROVIDER::BreakUserAndDomain(
    IN  PCHAR            pszFullName,
    IN  STRA&            straMetabaseConfiguredDomain,
    OUT STRA&            straDomainName,
    OUT STRA&            straUserName
)
/*++

Routine Description:

    Breaks up the supplied account into a domain and username; if no domain 
is specified
    in the account, tries to use either domain configured in metabase or 
domain the computer
    is a part of.

Arguments:

    straFullName - account, of the form domain\username or just username
    straMetabaseConfiguredDomain - auth domain configured in metabase 
    straDomainName - filled in with domain to use for authentication
    straUserName - filled in with username on success

Return Value:

    HRESULT

--*/

{
    PCHAR           pszSeparator        = NULL;
    HRESULT         hr                  = E_FAIL;
    
    if( pszFullName == NULL && pszFullName[0] == '\0' )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pszSeparator = (PCHAR) _mbschr( (PUCHAR) pszFullName, '\\' );
    if ( pszSeparator != NULL )
    {
        if ( FAILED( hr = straDomainName.Copy ( pszFullName,
                                                DIFF( pszSeparator - pszFullName ) ) ) )
        {
            return hr;
        }
        pszFullName = pszSeparator + 1;
    }
    else
    {
        straDomainName.Reset();
    }

    if ( FAILED( hr = straUserName.Copy ( pszFullName ) ) )
    {
        return hr;
    } 
    
    //
    // If no domain name was specified, try using the metabase-configured domain name; if that
    // is non-existent, try getting the name of the domain the computer is a part of 
    //
    
    if ( straDomainName.IsEmpty() )
    {
        if ( straMetabaseConfiguredDomain.IsEmpty() )
        {
            if ( FAILED( hr = straDomainName.Copy ( QueryComputerDomain() ) ) )
            {
                return hr;
            } 
        }
        else
        {
            if ( FAILED( hr = straDomainName.Copy ( straMetabaseConfiguredDomain ) ) )
            {
                return hr;
            } 
        }
    }

    return NO_ERROR;
}


//
// class IIS_DIGEST_USER_CONTEXT implementation
//

HANDLE
IIS_DIGEST_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get primary token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _hImpersonationToken != NULL );

    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }
    }
    
    return _hPrimaryToken;
}


HRESULT
IIS_DIGEST_USER_CONTEXT::Create(
         IN HANDLE                      hImpersonationToken,
         IN PSTR                        pszUserName

)
/*++

Routine Description:

    Create an user context

Arguments:

    
Return Value:

    HRESULT

--*/
{
    HRESULT         hr = E_FAIL;

    DBG_ASSERT( pszUserName != NULL );
    DBG_ASSERT( hImpersonationToken != NULL );

    if ( hImpersonationToken == NULL ||
         pszUserName == NULL )  
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    _hImpersonationToken = hImpersonationToken;
    
    if ( FAILED( hr = _strUserName.CopyA(pszUserName) ) )
    {
        return hr;
    }

    return NO_ERROR;
}


//
// Class IIS_DIGEST_CONN_CONTEXT implementation
//

// Initialize static variables

//static
ALLOC_CACHE_HANDLER * IIS_DIGEST_CONN_CONTEXT::sm_pachIISDIGESTConnContext = NULL;

//static 
const PCHAR     IIS_DIGEST_CONN_CONTEXT::_pszSecret = "IISMD5";

//static 
const DWORD     IIS_DIGEST_CONN_CONTEXT::_cchSecret = 6;

//static
HCRYPTPROV IIS_DIGEST_CONN_CONTEXT::s_hCryptProv = NULL;

//static
HRESULT
IIS_DIGEST_CONN_CONTEXT::Initialize(
    VOID
)
/*++

  Description:
    
    Global IIS_DIGEST_CONN_CONTEXT initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( IIS_DIGEST_CONN_CONTEXT );

    DBG_ASSERT( sm_pachIISDIGESTConnContext == NULL );
    
    sm_pachIISDIGESTConnContext = new ALLOC_CACHE_HANDLER( 
                                            "IIS_DIGEST_CONTEXT",  
                                            &acConfig );

    if ( sm_pachIISDIGESTConnContext == NULL )
    {
        HRESULT hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
               "Error initializing sm_pachIISDIGESTSecContext. hr = 0x%x\n",
               hr ));

        return hr;
    }

    //
    //  Get a handle to the CSP we'll use for all our hash functions etc
    //
    
    if ( !CryptAcquireContext( &s_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptAcquireContext() failed : 0x%x\n", GetLastError()));
        return hr;
    }


    
    return S_OK;

} 
//static
VOID
IIS_DIGEST_CONN_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT( sm_pachIISDIGESTConnContext != NULL );

    delete sm_pachIISDIGESTConnContext;
    sm_pachIISDIGESTConnContext = NULL;


    if ( s_hCryptProv != NULL )
    {
        CryptReleaseContext( s_hCryptProv,
                             0 );
        s_hCryptProv = NULL;
    }


} 

//static
HRESULT
IIS_DIGEST_CONN_CONTEXT::HashData( 
    IN  BUFFER& buffData,
    OUT BUFFER& buffHash )
/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    buffData - data to hash
    buffHash - buffer that receives hash; is assumed to be big enough to 
contain MD5 hash

Return Value:

    HRESULT
--*/

{
    HCRYPTHASH      hHash   = NULL;
    HRESULT         hr      = E_FAIL;
    DWORD           cbHash  = 0;  


    DBG_ASSERT( buffHash.QuerySize() >= MD5_HASH_SIZE );

    if ( !CryptCreateHash( s_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "CryptCreateHash() failed : 0x%x\n", GetLastError()));
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    if ( !CryptHashData( hHash,
                         (PBYTE) buffData.QueryPtr(),
                         buffData.QuerySize(),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    cbHash = buffHash.QuerySize();
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             (PBYTE) buffHash.QueryPtr(),
                             &cbHash,
                             0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    hr = NO_ERROR;
    
ExitPoint:

    if ( hHash != NULL )
    {
        CryptDestroyHash( hHash );
    }
    return hr;
}


//static
BOOL
IIS_DIGEST_CONN_CONTEXT::IsExpiredNonce( 
    IN  STRA& strRequestNonce,
    IN  STRA& strPresentNonce 
)
/*++

Routine Description:

    Checks whether nonce is expired or not by looking at the timestamp on the 
nonce
    that came in with the request and comparing it with the timestamp on the 
latest nonce

Arguments:

    strRequestNonce - nonce that came in with request
    strPresentNonce - latest nonce

Return Value:

    TRUE if expired, FALSE if not
    
--*/
{
    //
    // Timestamp is after first 2*RANDOM_SIZE bytes of nonce; also, note that
    // timestamp is time() mod NONCE_GRANULARITY, so all we have to do is simply
    // compare for equality to check that the request nonce hasn't expired
    //

    DBG_ASSERT( strRequestNonce.QueryCCH() >= 2*RANDOM_SIZE + TIMESTAMP_SIZE );
    DBG_ASSERT( strPresentNonce.QueryCCH() >= 2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( memcmp( strRequestNonce.QueryStr() + 2*RANDOM_SIZE, 
                 strPresentNonce.QueryStr() + 2*RANDOM_SIZE,
                 TIMESTAMP_SIZE ) != 0 )
    {
        return TRUE;
    }
    return FALSE;
}

//static
BOOL
IIS_DIGEST_CONN_CONTEXT::IsWellFormedNonce( 
    IN  STRA& strNonce 
)
/*++

Routine Description:

    Checks whether a nonce is "well-formed" by checking hash value, length etc 
    
Arguments:

    pszNonce - nonce to be checked

Return Value:

    TRUE if nonce is well-formed, FALSE if not

--*/

{

    if ( strNonce.QueryCCH()!= NONCE_SIZE ) 
    {
        return FALSE;
    }

    //
    // Format of nonce : <random bytes><time stamp><hash of (secret,random bytes,time stamp)>
    // 
    
    STACK_BUFFER(       buffBuffer, 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );
    STACK_BUFFER(       buffHash, MD5_HASH_SIZE );
    STACK_STRA(         strAsciiHash, 2*MD5_HASH_SIZE + 1 );

    memcpy( buffBuffer.QueryPtr(), 
            _pszSecret, 
            _cchSecret );
    memcpy( (PBYTE) buffBuffer.QueryPtr() + _cchSecret, 
            strNonce.QueryStr(), 
            2*RANDOM_SIZE + TIMESTAMP_SIZE );

    if ( FAILED( HashData( buffBuffer, 
                           buffHash ) ) )
    {
        return FALSE;
    }

    ToHex( buffHash, 
           strAsciiHash );

    if ( memcmp( strAsciiHash.QueryStr(),
                 strNonce.QueryStr() + 2*RANDOM_SIZE + TIMESTAMP_SIZE,
                 2*MD5_HASH_SIZE ) != 0)
    {
        return FALSE;
    }

    return TRUE;
                    
}

HRESULT
IIS_DIGEST_CONN_CONTEXT::GenerateNonce( 
    VOID
)
/*++

Routine Description:

    Generate nonce to be stored in user filter context. Nonce is

    <ASCII rep of Random><Time><ASCII of MD5(Secret:Random:Time)>

    Random = <8 random bytes>
    Time = <16 bytes, reverse string rep of result of time() call>
    Secret = 'IISMD5'

Arguments:

    none

Return Value:

    HRESULT

--*/
{
    HRESULT             hr      = E_FAIL;
    DWORD               tNow    = (DWORD) ( time( NULL ) / NONCE_GRANULARITY );

    //
    // If nonce has timed out, generate a new one
    //
    if ( _tLastNonce < tNow )
    {
        STACK_BUFFER(       buffTempBuffer, 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );
        STACK_BUFFER(       buffDigest, MD5_HASH_SIZE );
        STACK_BUFFER(       buffRandom, RANDOM_SIZE );
        STACK_STRA(         strTimeStamp, TIMESTAMP_SIZE + 1 );
        STACK_STRA(         strAsciiDigest, 2*MD5_HASH_SIZE + 1 );
        STACK_STRA(         strAsciiRandom, 2*RANDOM_SIZE + 1);

        DWORD               cbTimeStamp     =  0;
        PSTR                pszTimeStamp    =  NULL;

        
        _tLastNonce = tNow;

        //
        // First, random bytes
        //
        if ( !CryptGenRandom( s_hCryptProv,
                              RANDOM_SIZE,
                              (PBYTE) buffRandom.QueryPtr() ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto ExitPoint;
        }
        
        //
        // Convert to ASCII, doubling the length, and add to nonce 
        //

        ToHex( buffRandom, 
               strAsciiRandom );

        if ( FAILED( hr = _straNonce.Copy( strAsciiRandom ) ) )
        {
            goto ExitPoint;
        }

        //
        // Next, reverse string representation of current time; pad with zeros if necessary
        //
        pszTimeStamp = strTimeStamp.QueryStr();
        DBG_ASSERT( pszTimeStamp != NULL );
        while ( tNow != 0 )
        {
            *(pszTimeStamp++) = (BYTE)( '0' + tNow % 10 );
            cbTimeStamp++;
            tNow /= 10;
        }

        DBG_ASSERT( cbTimeStamp <=  TIMESTAMP_SIZE );
        
        //
        // pad with zeros if necessary
        //
        while ( cbTimeStamp < TIMESTAMP_SIZE )
        {
            *(pszTimeStamp++) = '0';
            cbTimeStamp++;
        }

        //
        // terminate the timestamp
        //
        *(pszTimeStamp) = '\0';
        DBG_REQUIRE( strTimeStamp.SetLen( cbTimeStamp ) );
        
        //
        // Append TimeStamp to Nonce
        //
        if ( FAILED( hr = _straNonce.Append( strTimeStamp ) ) )
        {
            goto ExitPoint;
        }
        
        //
        // Now hash everything, together with a private key ( IISMD5 )
        //
        memcpy( buffTempBuffer.QueryPtr(), 
                _pszSecret, 
                _cchSecret );
                
        memcpy( (PBYTE) buffTempBuffer.QueryPtr() + _cchSecret, 
                _straNonce.QueryStr(), 
                2*RANDOM_SIZE + TIMESTAMP_SIZE );

        DBG_ASSERT( buffTempBuffer.QuerySize() == 2*RANDOM_SIZE + TIMESTAMP_SIZE + _cchSecret );

        if ( FAILED( hr = HashData( buffTempBuffer,
                                    buffDigest ) ) )
        {
            goto ExitPoint;
        }

        //
        // Convert to ASCII, doubling the length
        //
        DBG_ASSERT( buffDigest.QuerySize() == MD5_HASH_SIZE );
 
        ToHex( buffDigest, 
               strAsciiDigest );

        //
        // Add hash to nonce 
        //
        if ( FAILED( hr = _straNonce.Append( strAsciiDigest ) ) )
        {
            goto ExitPoint;
        }
    }

    hr = NO_ERROR;

ExitPoint:
    return hr;
}


//static 
BOOL 
IIS_DIGEST_CONN_CONTEXT::ParseForName(
    IN  PSTR    pszStr,
    IN  PSTR *  pNameTable,
    IN  UINT    cNameTable,
    OUT PSTR *  pValueTable
)
/*++

Routine Description:

    Parse list of name=value pairs for known names

Arguments:

    pszStr - line to parse ( '\0' delimited )
    pNameTable - table of known names
    cNameTable - number of known names
    pValueTable - updated with ptr to parsed value for corresponding name

Return Value:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt     = TRUE;
    PSTR    pszBeginName;
    PSTR    pszEndName;
    PSTR    pszBeginVal;
    PSTR    pszEndVal;
    UINT    iN;
    int     ch;


    DBG_ASSERT( pszStr!= NULL );

    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        pValueTable[iN] = NULL;
    }

    for ( ; *pszStr && fSt ; )
    {
        pszStr = SkipWhite( pszStr );

        pszBeginName = pszStr;

        for ( pszEndName = pszStr ; (ch=*pszEndName) && ch != '=' && ch != ' ' ; ++pszEndName )
        {
        }

        if ( *pszEndName )
        {
            *pszEndName = '\0';
            pszEndVal = NULL;

            if ( !_stricmp( pszBeginName, "NC" ) )
            {
                for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && !SAFEIsXDigit((UCHAR)ch) ; ++pszBeginVal )
                {
                }
                
                if ( SAFEIsXDigit((UCHAR)(*pszBeginVal)) )
                {
                    if ( strlen( pszBeginVal ) >= 8 )
                    {
                        pszEndVal = pszBeginVal + 8;
                    }
                }
            }
            else
            {   
                //
                // Actually this routine is not compatible with rfc2617 at all It treats all 
                // values as quoted string which is not right. To fix the whole parsing problem, 
                // we will need to rewrite the routine. As for now, the following is a simple 
                // fix for whistler bug 95886. 
                //
                
                if ( !_stricmp( pszBeginName, "qop" ) )
                {
                    BOOL fQuotedQop = FALSE;

                    for( pszBeginVal = ++pszEndName; ( ch=*pszBeginVal ) && ( ch == '=' || ch == ' ' ); ++pszBeginVal )
                    {
                    }

                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        fQuotedQop = TRUE;
                    }

                    for ( pszEndVal = pszBeginVal; ( ch = *pszEndVal ); ++pszEndVal )
                    {
                        if ( ch == '"' || ch == ' ' || ch == ',' || ch == '\0' )
                        {
                            break;
                        }
                    }

                    if ( *pszEndVal != '"' && fQuotedQop )
                    {
                        pszEndVal = NULL;
                    }
                }
                else
                {                
                    for ( pszBeginVal = ++pszEndName ; (ch=*pszBeginVal) && ch != '"' ; ++pszBeginVal )
                    {
                    }
                    if ( *pszBeginVal == '"' )
                    {
                        ++pszBeginVal;
                        for ( pszEndVal = pszBeginVal ; (ch=*pszEndVal) ; ++pszEndVal )
                        {
                            if ( ch == '"' )
                            {
                                break;
                            }
                        }
                        if ( *pszEndVal != '"' )
                        {
                            pszEndVal = NULL;
                        }
                    }
                }
            }
            
            if ( pszEndVal != NULL )
            {
                //
                // Find name in table
                //

                for ( iN = 0 ; iN < cNameTable ; ++iN )
                {
                    if ( !_stricmp( pNameTable[iN], pszBeginName ) )
                    {
                        break;
                    }
                }
                if ( iN < cNameTable )
                {
                    pValueTable[iN] = pszBeginVal;
                }
                
                pszStr = pszEndVal;
                
                if ( *pszEndVal != '\0' )
                {
                    *pszEndVal = '\0';
                    pszStr++;
                }

                continue;
            }
        }
        
        fSt = FALSE;
    }

    return fSt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\iiscertmapprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     certmapprovider.cxx

   Abstract:
     IIS Certificate Mapper provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "iiscertmapprovider.hxx"



HRESULT
IISCERTMAP_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *       pMainContext,
    BOOL *                  pfApplies
)
/*++

Routine Description:

    Does certificate map authentication apply? 

Arguments:

    pMainContext - Main context
    pfApplies - Set to TRUE if cert map auth applies

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *           pCertificateContext;
    URL_CONTEXT *                   pUrlContext = NULL;
    W3_METADATA *                   pMetaData = NULL;
    BOOL                            fApplies = FALSE;
    W3_SITE *                       pSite = NULL;
    IIS_CERTIFICATE_MAPPING *       pIISCertificateMapping = NULL;
    TOKEN_CACHE_ENTRY *             pCachedIISMappedToken = NULL;
    BOOL                            fClientCertDeniedByMapper = FALSE;
                    
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // If cert mapping is not allowed for this vroot, then ignore client
    // cert token and let other authentication mechanisms do their thing
    //
    
    pUrlContext = pMainContext->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pSite = pMainContext->QuerySite();
    DBG_ASSERT( pSite != NULL );

    
    if ( pMetaData->QuerySslAccessPerms() & VROOT_MASK_MAP_CERT )
    {
        pCertificateContext = pMainContext->QueryCertificateContext();
        if ( pCertificateContext == NULL )
        {
            fApplies = FALSE;            
            goto Finished;
        }

        if ( ! pSite->QueryUseDSMapper() )
        {
            //
            // IIS mapper enabled
            //
            HRESULT hr = E_FAIL;
            PBYTE         pbClientCertBlob = NULL;
            DWORD         cbClientCertBlob = 0;
            
            //
            // No need to call DereferenceCertMapping after QueryIISCertificateMapping
            // IISCertificateMapping is referenced by W3_SITE and we hold reference 
            // to W3_SITE  already
            //
            hr = pSite->GetIISCertificateMapping( &pIISCertificateMapping );
            if ( FAILED( hr ) ||
               ( pIISCertificateMapping == NULL ) )
            {
                //
                // If we couldn't read the mapping because not found, thats OK.
                //
                // CODEWORK: we may need smarted error handling (ignoring error 
                // and assuming that mapping was not found is not very good idea
                //
                fApplies = FALSE;            
                goto Finished;
            }

            //
            // retrieve client certificate
            //
            pCertificateContext->QueryEncodedCertificate( 
                                        reinterpret_cast<PVOID *>(&pbClientCertBlob), 
                                        &cbClientCertBlob );

            if( pbClientCertBlob == NULL || cbClientCertBlob == 0 )
            {
                fApplies = FALSE;            
                goto Finished;
            }
            DBG_ASSERT( pIISCertificateMapping != NULL );
            
            hr = pIISCertificateMapping->DoMapCredential( pbClientCertBlob,
                                                          cbClientCertBlob,
                                                          &pCachedIISMappedToken,
                                                          &fClientCertDeniedByMapper );
            if ( FAILED( hr ) )
            {
                //
                // IISCERTMAP applies only when there was successful mapping
                // Otherwise it will yield other auth providers
                //
                
                if ( hr == SEC_E_UNKNOWN_CREDENTIALS )
                {
                    //
                    // DoMapCredential didn't find any mathing mapping
                    // or user/pwd in the mapping was invalid
                    //
                    hr = S_OK;
                }
                fApplies = FALSE;            
                goto Finished;
            }

            DBG_ASSERT ( fClientCertDeniedByMapper || pCachedIISMappedToken!= NULL );

            if( ( pCachedIISMappedToken != NULL &&
                  pCachedIISMappedToken->QueryImpersonationToken() != NULL ) ||
                  fClientCertDeniedByMapper )
            {
                
                IISCERTMAP_CONTEXT_STATE * pContextState = NULL;
                //
                // Use IISCERTMAP_CONTEXT_STATE to communicate information
                // from DoesApply() to DoAuthenticate()
                // We don't want to be calling mapper twice
                //
                pContextState = new (pMainContext) IISCERTMAP_CONTEXT_STATE( 
                                                           pCachedIISMappedToken,
                                                           fClientCertDeniedByMapper );
                if ( pContextState == NULL )
                {
                    if ( pCachedIISMappedToken != NULL )
                    {
                        pCachedIISMappedToken->DereferenceCacheEntry();
                        pCachedIISMappedToken = NULL;
                    }
                    
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                    goto Finished;
                }
                //
                // pContextState is taking ownership of pCachedIISMappedToken
                //
                pMainContext->SetContextState( pContextState );
                fApplies = TRUE;
                 
            }
        }
    }
Finished:    
    *pfApplies = fApplies;

    if ( pCachedIISMappedToken != NULL )
    {
        //
        // if creating CERTMAP_CONTEXT_STATE succeeded it will hold it's own reference
        // to cached token
        //
        pCachedIISMappedToken->DereferenceCacheEntry();
        pCachedIISMappedToken = NULL;
    }
    return NO_ERROR;
}

HRESULT
IISCERTMAP_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Routine Description:

    Create a user context representing a cert mapped token

Arguments:

    pMainContext - Main context

Return Value:

    HRESULT

--*/
{
    IISCERTMAP_USER_CONTEXT *       pUserContext = NULL;
    CERTIFICATE_CONTEXT *           pCertificateContext = NULL;
    HANDLE                          hImpersonation;
    BOOL                            fDelegatable = FALSE;
    HRESULT                         hr = NO_ERROR;
    W3_SITE *                       pSite = NULL;
    IISCERTMAP_CONTEXT_STATE *      pContextState = NULL;
    TOKEN_CACHE_ENTRY *             CachedToken = NULL;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pSite = pMainContext->QuerySite();
    DBG_ASSERT( pSite != NULL );

    // IIS mapper
    DBG_ASSERT ( !pSite->QueryUseDSMapper() );
    

    pContextState = (IISCERTMAP_CONTEXT_STATE *) pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );

    if ( pContextState->QueryClientCertDeniedByIISCertMap() )
    {
        //
        // Report denied by IIS mapper error
        //
        pMainContext->QueryResponse()->SetStatus( HttpStatusForbidden,
                                                  Http403MapperDenyAccess);
        pMainContext->SetErrorStatus( S_OK );
        return S_OK;
    }

    CachedToken = pContextState->QueryCachedIISCertMapToken();
    DBG_ASSERT( CachedToken != NULL );
    
    //
    // Create the user context for this request
    //
    
    pUserContext = new IISCERTMAP_USER_CONTEXT( this );
    if ( pUserContext == NULL )
    {
        CachedToken->DereferenceCacheEntry();
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    hr = pUserContext->Create( CachedToken );
    if ( FAILED( hr ) )
    {
        pUserContext->DereferenceUserContext();
        pUserContext = NULL;
        return hr;
    }
    
    pMainContext->SetUserContext( pUserContext );
    
    return NO_ERROR;
}

HRESULT
IISCERTMAP_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *               pMainContext
)
/*++

Routine Description:

    NOP since we have nothing to do on access denied

Arguments:

    pMainContext - Main context

Return Value:

    HRESULT

--*/
{
    //
    // No headers to add
    //
    
    return NO_ERROR;
}

HRESULT
IISCERTMAP_USER_CONTEXT::Create(
    TOKEN_CACHE_ENTRY *         pCachedToken
)
/*++

Routine Description:

    Create a certificate mapped user context

Arguments:

    pCachedToken - cached token

    Note: function takes ownership of pCachedToken. 
          It will dereference it even in the case of failure

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = E_FAIL;
    DWORD       cchUserName = sizeof( _achUserName ) / sizeof( WCHAR );
    
    if ( pCachedToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the easy stuff
    //

    pCachedToken->ReferenceCacheEntry();
    _pCachedToken = pCachedToken;

    //
    // Now get the user name
    //
    
    if ( !SetThreadToken( NULL, _pCachedToken->QueryImpersonationToken() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }
    
    if ( !GetUserNameEx( NameSamCompatible,
                         _achUserName,
                         &cchUserName ) )
    {
        RevertToSelf();
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }
    
    RevertToSelf();
    
    return NO_ERROR;
Failed:
    if ( _pCachedToken != NULL )
    {
        _pCachedToken->DereferenceCacheEntry();
        _pCachedToken = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     isapi_handler.cxx

   Abstract:
     Handle ISAPI extension requests
 
   Author:
     Taylor Weiss (TaylorW)             27-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include <initguid.h>
#include "precomp.hxx"
#include "isapi_handler.h"
#include <wmrgexp.h>
#include <iisextp.h>

HMODULE                      W3_ISAPI_HANDLER::sm_hIsapiModule;
PFN_ISAPI_TERM_MODULE        W3_ISAPI_HANDLER::sm_pfnTermIsapiModule;
PFN_ISAPI_PROCESS_REQUEST    W3_ISAPI_HANDLER::sm_pfnProcessIsapiRequest;
PFN_ISAPI_PROCESS_COMPLETION W3_ISAPI_HANDLER::sm_pfnProcessIsapiCompletion;
W3_INPROC_ISAPI_HASH *       W3_ISAPI_HANDLER::sm_pInprocIsapiHash;
CRITICAL_SECTION             W3_ISAPI_HANDLER::sm_csInprocHashLock;
CRITICAL_SECTION             W3_ISAPI_HANDLER::sm_csBigHurkinWamRegLock;
WAM_PROCESS_MANAGER *        W3_ISAPI_HANDLER::sm_pWamProcessManager;
BOOL                         W3_ISAPI_HANDLER::sm_fWamActive;
CHAR                         W3_ISAPI_HANDLER::sm_szInstanceId[SIZE_CLSID_STRING];
ALLOC_CACHE_HANDLER *        W3_ISAPI_HANDLER::sm_pachIsapiHandlers;

BOOL sg_Initialized = FALSE;

/***********************************************************************
    Local Declarations
***********************************************************************/

VOID
AddFiltersToMultiSz(
    IN const MB &       mb,
    IN LPCWSTR          szFilterPath,
    IN OUT MULTISZ *    pmsz
    );

VOID
AddAllFiltersToMultiSz(
    IN const MB &       mb,
    IN OUT MULTISZ *    pmsz
    );

/***********************************************************************
    Module Definitions
***********************************************************************/

CONTEXT_STATUS
W3_ISAPI_HANDLER::DoWork(
    VOID
    )
/*++

Routine Description:

    Main ISAPI handler routine

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT                     hr;
    BOOL                        fComplete = FALSE;
    W3_REQUEST *pRequest = pW3Context->QueryRequest();

    //
    // Preload entity if needed
    // 
    
    hr = pRequest->PreloadEntityBody( pW3Context,
                                      &fComplete );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
        return CONTEXT_STATUS_CONTINUE;
    }
    
    if ( !fComplete )
    {
        //
        // Async read pending.  Just bail
        //
    
        return CONTEXT_STATUS_PENDING;
    }
    
    _fEntityBodyPreloadComplete = TRUE;
    _State = ISAPI_STATE_INITIALIZING;

    return IsapiDoWork( pW3Context );
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::IsapiDoWork(
    W3_CONTEXT *            pW3Context
    )
/*++

Routine Description:

    Called to execute an ISAPI.  This routine must be called only after
    we have preloaded entity for the request

Arguments:

    pW3Context - Context for this request

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    DWORD           dwHseResult;
    HRESULT         hr = NOERROR;
    HANDLE          hOopToken;
    URL_CONTEXT *   pUrlContext;
    BOOL            fIsVrToken;

    //
    // We must have preloaded entity by the time this is called
    //
    
    DBG_ASSERT( _State == ISAPI_STATE_INITIALIZING );
    DBG_ASSERT( _fEntityBodyPreloadComplete );
    DBG_ASSERT( sm_pfnProcessIsapiRequest );
    DBG_ASSERT( sm_pfnProcessIsapiCompletion );

    DBG_REQUIRE( pUrlContext = pW3Context->QueryUrlContext() );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "IsapiDoWork called for new request.\r\n"
            ));
    }

    //
    // Initialize the ISAPI_CORE_DATA and ISAPI_CORE_INTERFACE
    // for this request
    //

    if ( FAILED( hr = InitCoreData( &fIsVrToken ) ) )
    {
        goto ErrorExit;
    }

    DBG_ASSERT( _pCoreData );

    _pIsapiRequest = new ISAPI_REQUEST( pW3Context, _pCoreData->fIsOop );

    if ( _pIsapiRequest == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    if ( FAILED( hr = _pIsapiRequest->Create() ) )
    {
        goto ErrorExit;
    }

    //
    // If the request should run OOP, get the WAM process and
    // duplicate the impersonation token
    //

    if ( _pCoreData->fIsOop )
    {
        DWORD   dwAuthType;

        DBG_ASSERT( sm_pWamProcessManager );
        DBG_ASSERT( _pCoreData->szWamClsid[0] != L'\0' );

        hr = sm_pWamProcessManager->GetWamProcess(
            (LPCWSTR)&_pCoreData->szWamClsid,
            &_pWamProcess,
            sm_szInstanceId
            );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        //
        // For SSPI and Digest authenticated requests, we have to
        // modify the token that we're passing to the OOP process.
        //
        // We don't need to do this in the case of Anonymous or
        // Basic because the token cache will take care of it.
        //

        dwAuthType = pW3Context->QueryUserContext()->QueryAuthType();

        if ( ( dwAuthType == MD_AUTH_MD5 ||
               dwAuthType == MD_AUTH_NT ) &&
               fIsVrToken == FALSE )
        {
            hr = GrantWpgAccessToToken( _pCoreData->hToken );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }

            hr = AddWpgToTokenDefaultDacl( _pCoreData->hToken );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }
        }

        if ( DuplicateHandle( GetCurrentProcess(), _pCoreData->hToken,
                               _pWamProcess->QueryProcess(), &hOopToken,
                               0, FALSE, DUPLICATE_SAME_ACCESS ) )
        {
            _pCoreData->hToken = hOopToken;
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            //
            // CODEWORK - If the target process has exited, then
            // DuplicateHandle fails with ERROR_ACCESS_DENIED.  This
            // will confuse our error handling logic because it'll
            // thing that we really got this error attempting to
            // process the request.
            //
            // For the time being, we'll detect this error and let
            // it call into ProcessRequest.  If the process really
            // has exited, this will cause the WAM_PROCESS cleanup
            // code to recover everything.
            //
            // In the future, we should consider waiting on the
            // process handle to detect steady-state crashes of
            // OOP hosts so that we don't have to discover the
            // problem only when something trys to talk to the
            // process.
            //
            // Another thing to consider is that we could trigger
            // the crash recovery directly and call GetWamProcess
            // again to get a new process.  This would make the
            // crash completely transparent to the client, which
            // would be an improvement over the current solution
            // (and IIS 4 and 5) which usually waits until a client
            // request fails before recovering.
            //

            _pCoreData->hToken = NULL;

            if ( hr != HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            {
                goto ErrorExit;
            }
        }
    }

    //
    // Handle the request
    //

    _State = ISAPI_STATE_PENDING;

    if ( !_pCoreData->fIsOop )
    {
        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Processing ISAPI_REQUEST %p OOP.\r\n",
                _pIsapiRequest
                ));
        }

        hr = sm_pfnProcessIsapiRequest(
            _pIsapiRequest,
            _pCoreData,
            &dwHseResult
            );
    }
    else
    {
        hr = _pWamProcess->ProcessRequest(
            _pIsapiRequest,
            _pCoreData,
            &dwHseResult
            );
    }

    if ( FAILED( hr ) )
    {
        _State = ISAPI_STATE_FAILED;
        goto ErrorExit;
    }

    //
    // Determine whether the extension was synchronous or pending.
    // We need to do this before releasing our reference on the
    // ISAPI_REQUEST since the final release will check the state
    // to determine if an additional completion is necessary.
    //
    // In either case, we should just return with the appropriate
    // return code after setting the state.
    //

    if ( dwHseResult != HSE_STATUS_PENDING &&
         _pCoreData->fIsOop == FALSE )
    {
        _State = ISAPI_STATE_DONE;

        //
        // This had better be the final release...
        //

        LONG Refs = _pIsapiRequest->Release();

        DBGPRINTF((
            DBG_CONTEXT,
            "Sync request detected.  Release returned %d.\r\n",
            Refs
            ));

        DBG_ASSERT( Refs == 0 );

        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // This may or may not be the final release...
    //
    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    //
    // Spew on failure.
    //

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Attempt to process ISAPI request failed.  Error 0x%08x.\r\n",
            hr
            ));
    }

    //
    // Set the error status now.
    //

    pW3Context->SetErrorStatus( hr );

    //
    // If we've failed, and the state is ISAPI_STATE_INITIALIZING, then
    // we never made the call out to the extension.  It's therefore
    // safe to handle the error and advance the state machine.
    //
    // It's also safe to advance the state machine in the special case
    // error where the attempt to call the extension results in
    // ERROR_ACCESS_DENIED.
    //

    if ( _State == ISAPI_STATE_INITIALIZING ||
         hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED) )
    {
        //
        // Setting the state to ISAPI_STATE_DONE will cause the
        // next completion to advance the state machine.
        //
        
        _State = ISAPI_STATE_DONE;

        //
        // The _pWamProcess and _pCoreData members are cleaned up
        // by the destructor.  We don't need to worry about them.
        // We also don't need to worry about any tokens that we
        // are using.  The tokens local to this process are owned
        // by W3_USER_CONTEXT; any duplicates for OOP are the
        // responsibility of the dllhost process (if it still
        // exists).
        //
        // We do need to clean up the _pIsapiRequest if we've
        // created it.  This had better well be the final release.
        //

        if ( _pIsapiRequest )
        {
            DBG_REQUIRE( _pIsapiRequest->Release() == 0 );
        }

        //
        // Set the HTTP status and send it asynchronously.
        // This will ultimately trigger the completion that
        // advances the state machine.
        //

        if ( hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                    Http401Resource );
        }
        else
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
        }

        hr = pW3Context->SendResponse( W3_FLAG_ASYNC );

        if ( SUCCEEDED( hr ) )
        {
            return CONTEXT_STATUS_PENDING;
        }

        //
        // Ouch - couldn't send the error page...
        //

        _State = ISAPI_STATE_FAILED;

        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // If we get here, then an error has occured during or after
    // our call into the extension.  Because it's possible for an
    // OOP call to fail after entering the extension, we can't
    // generally know our state.
    //
    // Because of this, we'll assume that the extension has
    // outstanding references to the ISAPI_REQUEST on its behalf.
    // We'll set the state to ISAPI_STATE_PENDING and let the
    // destructor on the ISAPI_REQUEST trigger the final
    // completion.
    //
    // Also, we'll set the error status, just in case the extension
    // didn't get a response off before it failed.
    //

    
    // CODEWORK - Is this safe?  What if an OOP crashes while a SendResponse
    // call is running through the core?
    pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );

    _State = ISAPI_STATE_PENDING;

    //
    // This may or may not be the final release on the ISAPI_REQUEST.
    //
    // It had better be non-NULL if we got past ISAPI_STATE_INITIALIZING.
    //

    DBG_ASSERT( _pIsapiRequest );

    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::OnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
/*++

Routine Description:

    ISAPI async completion handler.  

Arguments:

    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                 hr;
    W3_CONTEXT *            pW3Context;
    
    pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Is this completion for the entity body preload?  If so note the 
    // number of bytes and start handling the ISAPI request
    //
    
    if ( !_fEntityBodyPreloadComplete )
    {
        BOOL fComplete = FALSE;

        //
        // This completion is for entity body preload
        //
        
        W3_REQUEST *pRequest = pW3Context->QueryRequest();
        hr = pRequest->PreloadCompletion(pW3Context,
                                         cbCompletion,
                                         dwCompletionStatus,
                                         &fComplete);
        if ( FAILED( hr ) )
        {
            pW3Context->SetErrorStatus( hr );
            pW3Context->QueryResponse()->SetStatus( HttpStatusServerError );
            return CONTEXT_STATUS_CONTINUE;
        }

        if (!fComplete)
        {
            return CONTEXT_STATUS_PENDING;
        }

        _fEntityBodyPreloadComplete = TRUE;
        _State = ISAPI_STATE_INITIALIZING;
        
        //
        // Finally we can call the ISAPI
        //
        
        return IsapiDoWork( pW3Context );
    }
    
    DBG_ASSERT( _fEntityBodyPreloadComplete );
    
    return IsapiOnCompletion( cbCompletion, dwCompletionStatus );
}

CONTEXT_STATUS
W3_ISAPI_HANDLER::IsapiOnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
    )
/*++

Routine Description:

    Funnels a completion to an ISAPI

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Win32 Error status of completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending, 
    else CONTEXT_STATUS_CONTINUE

--*/
{
    DWORD64     IsapiContext;
    HRESULT     hr = NO_ERROR;

    DBG_ASSERT( _pCoreData );
    DBG_ASSERT( _pIsapiRequest );

    //
    // If the state is ISAPI_STATE_DONE, then we should
    // advance the state machine now.
    //

    if ( _State == ISAPI_STATE_DONE ||
         _State == ISAPI_STATE_FAILED )
    {
        return CONTEXT_STATUS_CONTINUE;
    }

    //
    // If we get here, then this completion should be passed
    // along to the extension.
    //
 
    IsapiContext =  _pIsapiRequest->QueryIsapiContext();

    DBG_ASSERT( IsapiContext != 0 );

    //
    // Process the completion.
    //

    _pIsapiRequest->AddRef();

    if ( !_pCoreData->fIsOop )
    {
        //
        // Need to reset the ISAPI context in case the extension
        // does another async operation before the below call returns
        //

        _pIsapiRequest->ResetIsapiContext();

        hr = sm_pfnProcessIsapiCompletion(
            IsapiContext,
            cbCompletion,
            dwCompletionStatus
            );
    }
    else
    {
        DBG_ASSERT( _pWamProcess );

        //
        // _pWamProcess->ProcessCompletion depends on the ISAPI
        // context, so it will make the Reset call.
        //

        hr = _pWamProcess->ProcessCompletion(
            _pIsapiRequest,
            IsapiContext,
            cbCompletion,
            dwCompletionStatus
            );
    }

    _pIsapiRequest->Release();

    return CONTEXT_STATUS_PENDING;
}

HRESULT
W3_ISAPI_HANDLER::InitCoreData(
    BOOL *  pfIsVrToken
    )
/*++

Routine Description:

    Initializes the ISAPI_CORE_DATA for a request

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DWORD           cbSizeNeeded;
    DWORD           cbString;
    HRESULT         hr = NO_ERROR;
    W3_CONTEXT *    pW3Context;
    URL_CONTEXT *   pUrlContext;
    W3_URL_INFO *   pUrlInfo;
    W3_METADATA *   pMetadata;
    CHAR *          szHeaderTemp;
    STACK_STRU(     struPathInfo, 128);
    STACK_STRU(     struPathTranslated, 128);
    STACK_STRA(     straMethod, 16);
    STACK_STRA(     straQueryString, 128);
    STACK_STRA(     straContentType, 32);
    STACK_STRA(     straUserAgent, 128);
    STACK_STRA(     straApplMdPath, 128);
    STACK_STRA(     straCookie, 128);
    STACK_STRA(     straConnection, 32);
    STACK_STRU(     struApplMdPathW, 128);
    STACK_STRU(     struWamClsid, SIZE_CLSID_STRING);
    STACK_STRA(     straPhysicalPath, 128);
    STACK_STRA(     straPathInfo, 128);
    STACK_STRA(     straPathTranslated, 128);
    STRU *          pstruGatewayImage;
    STRU *          pstruPhysicalPath;
    STRU *          pstruWamClsid;
    DWORD           cbAvailableEntity;
    PVOID           pbAvailableEntity;
    BOOL            fIsOop = FALSE;
    ISAPI_CORE_DATA icdTemp;
    W3_REQUEST *    pRequest = NULL;
    CHAR *          szContentLength;

    DBG_REQUIRE( pW3Context = QueryW3Context() );
    DBG_REQUIRE( pRequest = pW3Context->QueryRequest() );
    DBG_REQUIRE( pUrlContext = pW3Context->QueryUrlContext() );
    DBG_REQUIRE( pUrlInfo = pUrlContext->QueryUrlInfo() );
    DBG_REQUIRE( pMetadata = pUrlContext->QueryMetaData() );

    //
    // Collect the core data that we'll need
    //

    // Physical Path
    pstruPhysicalPath = pUrlContext->QueryPhysicalPath();
    if (FAILED(hr = straPhysicalPath.CopyW( pstruPhysicalPath->QueryStr(),
                                            pstruPhysicalPath->QueryCCH() )))
    {
        goto ErrorExit;
    }

    // Gateway Image
    //
    // If this is a DAV request, then the gateway image should be DAV's dll,
    // else if this is a script mapped request, then the image should be
    // the executable associated with the script map.  If it's not DAV and
    // not script mapped, then the gateway image is just the physical path
    // associated with the URL.
    if ( _fIsDavRequest )
    {
        pstruGatewayImage = &_strDavIsapiImage;
    }
    else if ( QueryScriptMapEntry() )
    {
        pstruGatewayImage = QueryScriptMapEntry()->QueryExecutable();
    }
    else
    {
        pstruGatewayImage = pUrlContext->QueryPhysicalPath();
    }

    //
    // ApplMdPath
    //
    hr = GetServerVariableApplMdPath( pW3Context, &straApplMdPath );
    if( FAILED(hr) )
    {
        goto ErrorExit;
    }

    //
    // If WAM is active, then we need to determine if this is
    // an OOP request.
    //

    if ( sm_fWamActive )
    {

        switch ( pMetadata->QueryAppIsolated() )
        {
        case APP_INPROC:

            fIsOop = FALSE;

            break;

        case APP_ISOLATED:

            fIsOop = TRUE;

            pstruWamClsid = pMetadata->QueryWamClsId();

            DBG_ASSERT( pstruWamClsid );

            if ( pstruWamClsid == NULL )
            {
                goto ErrorExit;
            }

            hr = struWamClsid.Copy( pstruWamClsid->QueryStr() );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }

            break;

        case APP_POOL:

            fIsOop = TRUE;

            hr = struWamClsid.Copy( POOL_WAM_CLSID );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }

        default:

            //
            // We'll only get here if someone has hand-edited their
            // metabase.  In this case, we'll treat it as an inproc
            // application.
            //

            break;
        }

        //
        //
        // If the extension is on the InProcessIsapiApps list,
        // then it's going to be inproc, regardless
        //
        
        if ( fIsOop && IsInprocIsapi( pstruGatewayImage->QueryStr() ) )
        {
            fIsOop = FALSE;
        }
    }

    // Path info
    //
    // Set path info to be the URL if the target URL is a script
    // unless the AllowPathInfoForScriptMappings key is set on the site.
    // This makes us compatible with earlier versions of IIS, and DAV
    // depends on this.
    //
    BOOL fUsePathInfo;
    if ( ( QueryScriptMapEntry() &&
           !pW3Context->QuerySite()->QueryAllowPathInfoForScriptMappings() ) ||
         _fIsDavRequest )
    {
        hr = pRequest->GetUrl( &struPathInfo );
        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        fUsePathInfo = FALSE;
    }
    else
    {
        //
        // This is a new virtual path to have filters map
        //
        
        hr = struPathInfo.Copy( *pUrlInfo->QueryPathInfo() );
        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        fUsePathInfo = TRUE;
    }

    if (FAILED(hr = straPathInfo.CopyW( struPathInfo.QueryStr(),
                                        struPathInfo.QueryCCH() )))
    {
        goto ErrorExit;
    }

    hr = pUrlInfo->GetPathTranslated( pW3Context,
                                      fUsePathInfo,
                                      &struPathTranslated );
    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    if (FAILED(hr = straPathTranslated.CopyW( struPathTranslated.QueryStr(),
                                              struPathTranslated.QueryCCH() )))
    {
        goto ErrorExit;
    }

    // Request method
    hr = pRequest->GetVerbString( &straMethod );
    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    // Query string
    hr = pRequest->GetQueryStringA( &straQueryString );
    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    // Content type
    szHeaderTemp = pRequest->GetHeader( HttpHeaderContentType );
    hr = straContentType.Copy( szHeaderTemp ? szHeaderTemp : "" );
    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    // UserAgent
    szHeaderTemp = pRequest->GetHeader( HttpHeaderUserAgent );
    hr = straUserAgent.Copy( szHeaderTemp ? szHeaderTemp : "" );
    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    // Cookie
    szHeaderTemp = pRequest->GetHeader( HttpHeaderCookie );
    hr = straCookie.Copy( szHeaderTemp ? szHeaderTemp : "" );
    if (FAILED( hr ) )
    {
        goto ErrorExit;
    }

    // Connection
    szHeaderTemp = pRequest->GetHeader( HttpHeaderConnection );
    hr = straConnection.Copy( szHeaderTemp ? szHeaderTemp : "" );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // Calculate the size of buffer that we will need to
    // hold the ISAPI_CORE_STATE and any associated data
    // and allocate it.
    //

    icdTemp.cbSize = sizeof(ISAPI_CORE_DATA);
    icdTemp.cbSize += ( icdTemp.cbGatewayImage = pstruGatewayImage->QueryCB() + sizeof(WCHAR) );
    icdTemp.cbSize += ( icdTemp.cbPhysicalPath = straPhysicalPath.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbPathInfo = straPathInfo.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbMethod = straMethod.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbQueryString = straQueryString.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbPathTranslated = straPathTranslated.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbContentType = straContentType.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbConnection = straConnection.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbUserAgent = straUserAgent.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbCookie = straCookie.QueryCCH() + 1 );
    icdTemp.cbSize += ( icdTemp.cbApplMdPath = straApplMdPath.QueryCCH() + 1 );

    if ( fIsOop )
    {
        hr = GetServerVariableApplMdPathW( pW3Context, &struApplMdPathW );
        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }

        icdTemp.cbSize += ( icdTemp.cbApplMdPathW = ( struApplMdPathW.QueryCCH() + 1 ) * sizeof( WCHAR ) );
        icdTemp.cbSize += ( icdTemp.cbPathTranslatedW = ( struPathTranslated.QueryCCH() + 1 ) * sizeof( WCHAR ) );
    }
    else
    {
        icdTemp.cbSize += ( icdTemp.cbApplMdPathW = sizeof( WCHAR ) );
        icdTemp.cbSize += ( icdTemp.cbPathTranslatedW = sizeof( WCHAR ) );
    }
    
    pW3Context->QueryAlreadyAvailableEntity( &pbAvailableEntity,
                                             &cbAvailableEntity );

    icdTemp.cbAvailableEntity = cbAvailableEntity;

    if ( fIsOop )
    {
        icdTemp.cbSize += icdTemp.cbAvailableEntity;
    }
    
    //
    // Allocate space for core data now that we know its size
    //
    
    if ( !_buffCoreData.Resize( icdTemp.cbSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ErrorExit;
    }
    
    _pCoreData = (ISAPI_CORE_DATA*) _buffCoreData.QueryPtr();
    DBG_ASSERT( _pCoreData != NULL );

    //
    // Populate the core state
    //

    memcpy( _pCoreData, &icdTemp, sizeof( ISAPI_CORE_DATA ) );

    // OOP flag
    _pCoreData->fIsOop = fIsOop;

    // Secure flag
    _pCoreData->fSecure = pRequest->IsSecureRequest();

    // Client major and minor version
     _pCoreData->dwVersionMajor = pRequest->QueryVersion().MajorVersion;
     _pCoreData->dwVersionMinor = pRequest->QueryVersion().MinorVersion;

    // ImpersonationToken
    _pCoreData->hToken = pW3Context->QueryImpersonationToken( pfIsVrToken );
    
    // Sid (if available and inproc to avoid buffer copying)
    if ( !fIsOop )
    {
        _pCoreData->pSid = pW3Context->QueryUserContext()->QuerySid();
    }
    else
    {
        _pCoreData->pSid = NULL;
    }

    DBG_ASSERT( _pCoreData->hToken );

    // InstanceID
    _pCoreData->dwInstanceId = pRequest->QuerySiteId();

    // Content length
    if ( pRequest->IsChunkedRequest() )
    {
        _pCoreData->dwContentLength = (DWORD) -1;
    }
    else
    {
        szContentLength = pRequest->GetHeader( HttpHeaderContentLength );
        if ( szContentLength != NULL )
        {
            _pCoreData->dwContentLength = atol( szContentLength );
        }
        else
        {
            _pCoreData->dwContentLength = 0;
        }
    }

    // WAM CLSID
    wcscpy( _pCoreData->szWamClsid, struWamClsid.QueryStr() );

    //
    // Set the pointers so that they point into a reasonable offset into
    // the additional buffer space.
    //

    //
    // All the extra data begins right at the end of _pCoreData, start
    // pointing there.
    //
    // Note that we should included the UNICODE data before the ANSI
    // strings to avoid byte alignment issues on IA64...
    //
    _pCoreData->szGatewayImage = (LPWSTR)(_pCoreData + 1);
    _pCoreData->szApplMdPathW = (LPWSTR)((LPSTR)_pCoreData->szGatewayImage + _pCoreData->cbGatewayImage);
    _pCoreData->szPathTranslatedW = (LPWSTR)((LPSTR)_pCoreData->szApplMdPathW + _pCoreData->cbApplMdPathW);
    _pCoreData->szPhysicalPath = (LPSTR)_pCoreData->szPathTranslatedW + _pCoreData->cbPathTranslatedW;
    _pCoreData->szPathInfo = _pCoreData->szPhysicalPath + _pCoreData->cbPhysicalPath;
    _pCoreData->szMethod = _pCoreData->szPathInfo + _pCoreData->cbPathInfo;
    _pCoreData->szQueryString = _pCoreData->szMethod + _pCoreData->cbMethod;
    _pCoreData->szPathTranslated = _pCoreData->szQueryString + _pCoreData->cbQueryString;
    _pCoreData->szContentType = _pCoreData->szPathTranslated + _pCoreData->cbPathTranslated;
    _pCoreData->szConnection = _pCoreData->szContentType + _pCoreData->cbContentType;
    _pCoreData->szUserAgent = _pCoreData->szConnection + _pCoreData->cbConnection;
    _pCoreData->szCookie = _pCoreData->szUserAgent + _pCoreData->cbUserAgent;
    _pCoreData->szApplMdPath = _pCoreData->szCookie + _pCoreData->cbCookie;

    //
    // If this request is OOP, then we need to package the entity that we already
    // have with the core data buffer.
    //

    if ( fIsOop )
    {
        _pCoreData->pAvailableEntity = _pCoreData->szApplMdPath + _pCoreData->cbApplMdPath;
        memcpy( _pCoreData->pAvailableEntity, pbAvailableEntity, _pCoreData->cbAvailableEntity );
    }
    else
    {
        _pCoreData->pAvailableEntity = pbAvailableEntity;
    }

    //
    // Now go ahead and stuff the data into our buffers.  We're not checking
    // return codes because we've presumably allocated enough space and these
    // shouldn't fail...
    //

    pstruGatewayImage->CopyToBuffer( _pCoreData->szGatewayImage, &_pCoreData->cbGatewayImage );

    if ( fIsOop )
    {
        struApplMdPathW.CopyToBuffer( _pCoreData->szApplMdPathW, &_pCoreData->cbApplMdPathW );
        struPathTranslated.CopyToBuffer( _pCoreData->szPathTranslatedW, &_pCoreData->cbPathTranslatedW );
    }
    else
    {
        *_pCoreData->szApplMdPathW = L'\0';
        *_pCoreData->szPathTranslatedW = L'\0';
    }
    
    straPhysicalPath.CopyToBuffer( _pCoreData->szPhysicalPath, &_pCoreData->cbPhysicalPath );
    straPathInfo.CopyToBuffer( _pCoreData->szPathInfo, &_pCoreData->cbPathInfo );
    straMethod.CopyToBuffer( _pCoreData->szMethod, &_pCoreData->cbMethod );
    straQueryString.CopyToBuffer( _pCoreData->szQueryString, &_pCoreData->cbQueryString );
    straPathTranslated.CopyToBuffer( _pCoreData->szPathTranslated, &_pCoreData->cbPathTranslated );
    straContentType.CopyToBuffer( _pCoreData->szContentType, &_pCoreData->cbContentType );
    straConnection.CopyToBuffer( _pCoreData->szConnection, &_pCoreData->cbConnection );
    straUserAgent.CopyToBuffer( _pCoreData->szUserAgent, &_pCoreData->cbUserAgent );
    straCookie.CopyToBuffer( _pCoreData->szCookie, &_pCoreData->cbCookie );
    straApplMdPath.CopyToBuffer( _pCoreData->szApplMdPath, &_pCoreData->cbApplMdPath );

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    _pCoreData = NULL;

    return hr;
}

HRESULT
W3_ISAPI_HANDLER::DuplicateWamProcessHandleForLocalUse(
    HANDLE      hWamProcessHandle,
    HANDLE *    phLocalHandle
    )
/*++

Routine Description:

    Duplicates a handle defined in a WAM process to a local
    handle useful in the IIS core

Arguments:

    hWamProcessHandle - The value of the handle from the WAM process
    phLocalHandle     - Upon successful return, the handle useable in
                        the core process

Return Value:

    HRESULT

--*/
{
    HANDLE  hWamProcess;
    HRESULT hr = NOERROR;

    DBG_ASSERT( _pWamProcess );

    DBG_REQUIRE( hWamProcess = _pWamProcess->QueryProcess() );

    if ( !DuplicateHandle( hWamProcess, hWamProcessHandle, GetCurrentProcess(),
                           phLocalHandle, 0, FALSE, DUPLICATE_SAME_ACCESS ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    return hr;
}

HRESULT
W3_ISAPI_HANDLER::MarshalAsyncReadBuffer(
    DWORD_PTR   pWamExecInfo,
    LPBYTE      pBuffer,
    DWORD       cbBuffer
    )
/*++

Routine Description:

    Pushes a buffer into a WAM process.  This function is called
    to copy a local read buffer into the WAM process just prior
    to notifying the I/O completion function of an OOP extension.

Arguments:

    pWamExecInfo - A WAM_EXEC_INFO pointer that identifies the request
                   to the OOP host.
    pBuffer      - The buffer to copy
    cbBuffer     - The amount of data in pBuffer

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_fWamActive );
    DBG_ASSERT( _pWamProcess );

    return _pWamProcess->MarshalAsyncReadBuffer( pWamExecInfo, pBuffer,
                                                 cbBuffer );
}

VOID
W3_ISAPI_HANDLER::IsapiRequestFinished(
    VOID
    )
/*++

Routine Description:

    This function is called by the destructor for the
    ISAPI_REQUEST associated with this request.  If the
    current state of the W3_ISAPI_HANDLER is
    ISAPI_STATE_PENDING, then it will advance the core
    state machine.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( _State == ISAPI_STATE_PENDING )
    {
        RestartCoreStateMachine();
    }
}

VOID
W3_ISAPI_HANDLER::RestartCoreStateMachine(
    VOID
    )
/*++

Routine Description:

    Advances the core state machine by setting state
    to ISAPI_STATE_DONE and triggering an I/O completion.
    
    Note that this function is only expected to be called
    if the object state is ISAPI_STATE_PENDING.

Arguments:

    None

Return Value:

    None

--*/
{
    W3_CONTEXT *    pW3Context = QueryW3Context();
    BOOL            fResult;
    
    DBG_ASSERT( pW3Context );
    DBG_ASSERT( _State == ISAPI_STATE_PENDING );

    //
    // Need to set state to ISAPI_STATE_DONE so that the
    // resulting completion does the advance for us.
    //

    _State = ISAPI_STATE_DONE;

    fResult = ThreadPoolPostCompletion(
        0,
        W3_MAIN_CONTEXT::OnPostedCompletion,
        (LPOVERLAPPED)pW3Context->QueryMainContext()
        );

    DBG_ASSERT( fResult );
}

//static
HRESULT
W3_ISAPI_HANDLER::Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes W3_ISAPI_HANDLER

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NOERROR;
    
    DBGPRINTF(( DBG_CONTEXT, "W3_ISAPI_HANDLER::Initialize()\n" ));

    //
    // Initialize lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_ISAPI_HANDLER );

    DBG_ASSERT( sm_pachIsapiHandlers == NULL );
    
    sm_pachIsapiHandlers = new ALLOC_CACHE_HANDLER( "W3_ISAPI_HANDLER",
                                                    &acConfig );

    if ( sm_pachIsapiHandlers == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // For debugging purposes, create a unique instance ID for this
    // instance of the handler.
    //

#ifdef DBG
    
    UUID            uuid;
    RPC_STATUS      rpcStatus;
    unsigned char * szRpcString;
    
    rpcStatus = UuidCreate( &uuid );

    if ( (rpcStatus != RPC_S_OK) && (rpcStatus != RPC_S_UUID_LOCAL_ONLY) )
    {
        SetLastError( rpcStatus );
        goto error_exit;
    }

    rpcStatus = UuidToStringA( &uuid, &szRpcString );

    if ( rpcStatus != RPC_S_OK )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    strncpy( sm_szInstanceId, (LPSTR)szRpcString, SIZE_CLSID_STRING );
    sm_szInstanceId[SIZE_CLSID_STRING - 1] = '\0';

    RpcStringFreeA( &szRpcString );

    DBGPRINTF((
        DBG_CONTEXT,
        "W3_ISAPI_HANDLER initialized instance %s.\r\n",
        sm_szInstanceId
        ));

#else

    sm_szInstanceId[0] = '\0';

#endif _DBG
        
    PFN_ISAPI_INIT_MODULE pfnInit = NULL;
    
    sm_hIsapiModule = LoadLibrary( ISAPI_MODULE_NAME );
    if( sm_hIsapiModule == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error_exit;
    }

    sm_pfnTermIsapiModule = 
        (PFN_ISAPI_TERM_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_TERM_MODULE 
                                               );

    sm_pfnProcessIsapiRequest = 
        (PFN_ISAPI_PROCESS_REQUEST)GetProcAddress( sm_hIsapiModule,
                                                   ISAPI_PROCESS_REQUEST
                                                   );

    sm_pfnProcessIsapiCompletion =
        (PFN_ISAPI_PROCESS_COMPLETION)GetProcAddress( sm_hIsapiModule,
                                                      ISAPI_PROCESS_COMPLETION
                                                      );

    if( !sm_pfnTermIsapiModule ||
        !sm_pfnProcessIsapiRequest ||
        !sm_pfnProcessIsapiCompletion )
    {
        hr = E_FAIL;
        goto error_exit;
    }

    pfnInit = 
        (PFN_ISAPI_INIT_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_INIT_MODULE 
                                               );
    if( !pfnInit )
    {
        hr = E_FAIL;
        goto error_exit;
    }

    hr = pfnInit(
        NULL,
        sm_szInstanceId,
        GetCurrentProcessId()
        );

    if( FAILED(hr) )
    {
        goto error_exit;
    }

    DBG_REQUIRE( ISAPI_REQUEST::InitClass() );

    sm_pInprocIsapiHash = NULL;

    //
    // If we're running in backward compatibility mode, initialize
    // the WAM process manager and inprocess ISAPI app list
    //
    
    if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
    {
        WCHAR   szIsapiModule[MAX_PATH];
        //
        // Store away the full path to the loaded ISAPI module
        // so that we can pass it to OOP processes so that they
        // know how to load it
        //

        if ( GetModuleFileNameW(
            GetModuleHandleW( ISAPI_MODULE_NAME ),
            szIsapiModule,
            MAX_PATH
            ) == 0 )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto error_exit;
        }

        DBG_ASSERT( szIsapiModule[0] != '\0' );

        //
        // Initialize the WAM_PROCESS_MANAGER
        //
        
        sm_pWamProcessManager = new WAM_PROCESS_MANAGER( szIsapiModule );

        if ( !sm_pWamProcessManager )
        {
            goto error_exit;
        }

        hr = sm_pWamProcessManager->Create();

        if ( FAILED( hr ) )
        {
            sm_pWamProcessManager->Release();
            sm_pWamProcessManager = NULL;

            goto error_exit;
        }

        //
        // Hook up wamreg
        //

        hr = WamReg_RegisterSinkNotify( W3SVC_WamRegSink );

        if ( FAILED( hr ) )
        {
            goto error_exit;
        }

        INITIALIZE_CRITICAL_SECTION( &sm_csInprocHashLock );
        
        UpdateInprocIsapiHash();

        INITIALIZE_CRITICAL_SECTION( &sm_csBigHurkinWamRegLock );

        sm_fWamActive = TRUE;
    }
    else
    {
        sm_pWamProcessManager = NULL;
        sm_fWamActive = FALSE;
    }

    sg_Initialized = TRUE;

    return hr;
error_exit:

    DBGPRINTF(( DBG_CONTEXT, 
                "W3_ISAPI_HANDLER::Initialize() Error=%08x\n",
                hr
                ));

    if ( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }
    
    if ( sm_pachIsapiHandlers != NULL )
    {
        delete sm_pachIsapiHandlers;
        sm_pachIsapiHandlers = NULL;
    }
    
    sm_pfnTermIsapiModule = NULL;

    return hr;
}

//static
VOID
W3_ISAPI_HANDLER::Terminate(
    VOID
    )
/*++

Routine Description:

    Terminates W3_ISAPI_HANDLER

Arguments:

    None

Return Value:

    None

--*/

{
    DBGPRINTF(( DBG_CONTEXT, "W3_ISAPI_HANDLER::Terminate()\n" ));

    sg_Initialized = FALSE;

    DBG_ASSERT( sm_pfnTermIsapiModule );
    DBG_ASSERT( sm_hIsapiModule );

    if( sm_pfnTermIsapiModule )
    {
        sm_pfnTermIsapiModule();
        sm_pfnTermIsapiModule = NULL;
    }

    if( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }

    if ( sm_pInprocIsapiHash )
    {
        delete sm_pInprocIsapiHash;
    }

    if ( sm_fWamActive )
    {
        //
        // Disconnect wamreg
        //

        WamReg_UnRegisterSinkNotify();

        if ( sm_pWamProcessManager )
        {
            sm_pWamProcessManager->Shutdown();

            sm_pWamProcessManager->Release();
            sm_pWamProcessManager = NULL;
        }

        DeleteCriticalSection( &sm_csInprocHashLock );
        DeleteCriticalSection( &sm_csBigHurkinWamRegLock );
    }
    
    if ( sm_pachIsapiHandlers != NULL )
    {
        delete sm_pachIsapiHandlers;
        sm_pachIsapiHandlers = NULL;
    }

    ISAPI_REQUEST::CleanupClass();
}

// static
HRESULT
W3_ISAPI_HANDLER::W3SVC_WamRegSink(
    LPCSTR      szAppPath,
    const DWORD dwCommand,
    DWORD *     pdwResult
    )
{
    HRESULT         hr = NOERROR;
    WAM_PROCESS *   pWamProcess = NULL;
    WAM_APP_INFO *  pWamAppInfo = NULL;
    BOOL            fIsLoaded = FALSE;

    //
    // Scary monsters live in the land where this function
    // is allowed to run willy nilly
    //

    LockWamReg();

    DBG_ASSERT( szAppPath );
    DBG_ASSERT( sm_pWamProcessManager );

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS_MANAGER received a Sink Notify on MD path %S, cmd = %d.\r\n",
        (LPCWSTR)szAppPath,
        dwCommand
        ));

    *pdwResult = APPSTATUS_UnLoaded;

    switch ( dwCommand )
    {
    case APPCMD_UNLOAD:
    case APPCMD_DELETE:
    case APPCMD_CHANGETOINPROC:
    case APPCMD_CHANGETOOUTPROC:

        //
        // Unload the specified wam process.
        //
        // Note that we're casting the incoming app path to
        // UNICODE.  This is because wamreg would normally
        // convert the MD path (which is nativly UNICODE) to
        // MBCS in IIS 5.x.  It's smart enough to know that
        // for 6.0 we want to work directly with UNICODE.
        //

        hr = sm_pWamProcessManager->GetWamProcessInfo(
            reinterpret_cast<LPCWSTR>(szAppPath),
            &pWamAppInfo,
            &fIsLoaded
            );

        if ( FAILED( hr ) )
        {
            goto Done;
        }

        DBG_ASSERT( pWamAppInfo );

        //
        // If the app has not been loaded by the WAM_PROCESS_MANAGER
        // then there is nothing more to do.
        //

        if ( fIsLoaded == FALSE )
        {
            break;
        }

        hr = sm_pWamProcessManager->GetWamProcess(
            pWamAppInfo->_szClsid,
            &pWamProcess,
            sm_szInstanceId
            );

        if ( FAILED( hr ) )
        {
            //
            // Hey, this app was loaded just a moment ago!
            //

            DBG_ASSERT( FALSE );
            goto Done;
        }

        DBG_ASSERT( pWamProcess );

        hr = pWamProcess->Unload( 0 );

        if ( FAILED( hr ) )
        {
            goto Done;
        }

        break;

    case APPCMD_GETSTATUS:

        hr = sm_pWamProcessManager->GetWamProcessInfo(
            reinterpret_cast<LPCWSTR>(szAppPath),
            &pWamAppInfo,
            &fIsLoaded
            );

        if ( SUCCEEDED( hr ) )
        {
            if ( fIsLoaded )
            {
                *pdwResult = APPSTATUS_Running;
            }
            else
            {
                *pdwResult = APPSTATUS_Stopped;
            }
        }

        break;
    }

Done:

    UnlockWamReg();

    if ( pWamAppInfo )
    {
        pWamAppInfo->Release();
        pWamAppInfo = NULL;
    }

    if ( pWamProcess )
    {
        pWamProcess->Release();
        pWamProcess = NULL;
    }

    if ( FAILED( hr ) )
    {
        *pdwResult = APPSTATUS_Error;
    }

    return hr;
}

// static
HRESULT
W3_ISAPI_HANDLER::UpdateInprocIsapiHash(
    VOID
    )
/*++

Routine Description:

    Updates the table of InProcessIsapiApps

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    MB                      mb( g_pW3Server->QueryMDObject() );
    W3_INPROC_ISAPI_HASH *  pNewTable = NULL;
    W3_INPROC_ISAPI_HASH *  pOldTable = NULL;
    DWORD                   i;
    LPWSTR                  psz;
    HRESULT                 hr = NOERROR;
    LK_RETCODE              lkr = LK_SUCCESS;

    //
    // Allocate a new table and populate it.
    //

    pNewTable = new W3_INPROC_ISAPI_HASH;

    if ( !pNewTable )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ErrorExit;
    }

    if ( !mb.Open( L"/LM/W3SVC/" ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    if ( !mb.GetMultisz( L"",
                         MD_IN_PROCESS_ISAPI_APPS,
                         IIS_MD_UT_SERVER,
                         &pNewTable->_mszImages) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        mb.Close();
        goto ErrorExit;
    }

    //
    // Merge ISAPI filter images into the list
    //

    AddAllFiltersToMultiSz( mb, &pNewTable->_mszImages );

    mb.Close();

    //
    // Now that we have a complete list, add them to the
    // hash table.
    //

    for ( i = 0, psz = (LPWSTR)pNewTable->_mszImages.First();
          psz != NULL;
          i++, psz = (LPWSTR)pNewTable->_mszImages.Next( psz ) )
    {
        W3_INPROC_ISAPI *   pNewRecord;

        //
        // Allocate a new W3_INPROC_ISAPI object and add
        // it to the table
        //

        pNewRecord = new W3_INPROC_ISAPI;
        
        if ( !pNewRecord )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto ErrorExit;
        }

        hr = pNewRecord->Create( psz );

        if ( FAILED( hr ) )
        {
            pNewRecord->DereferenceInprocIsapi();
            pNewRecord = NULL;
            goto ErrorExit;
        }
              
        lkr = pNewTable->InsertRecord( pNewRecord, TRUE );

        pNewRecord->DereferenceInprocIsapi();
        pNewRecord = NULL;

        if ( lkr != LK_SUCCESS && lkr != LK_KEY_EXISTS )
        {
            hr = E_FAIL;
            goto ErrorExit;
        }
    }

    //
    // Now swap in the new table and delete the old one
    //

    EnterCriticalSection( &sm_csInprocHashLock );

    pOldTable = sm_pInprocIsapiHash;
    sm_pInprocIsapiHash = pNewTable;

    LeaveCriticalSection( &sm_csInprocHashLock );

    if ( pOldTable )
    {
        delete pOldTable;
    }

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;


ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( pNewTable )
    {
        delete pNewTable;
    };

    return hr;
}

VOID
AddFiltersToMultiSz(
    IN const MB &       mb,
    IN LPCWSTR          szFilterPath,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:
        Add the ISAPI filters at the specified metabase path to pmsz.
        
        Called by AddAllFiltersToMultiSz.

    Arguments:
        mb              metabase key open to /LM/W3SVC
        szFilterPath    path of /Filters key relative to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    WCHAR   szKeyName[MAX_PATH + 1];
    STRU    strFilterPath;
    STRU    strFullKeyName;
    INT     pchFilterPath = wcslen( szFilterPath );

    if ( FAILED( strFullKeyName.Copy( szFilterPath ) ) )
    {
        return;
    }

    DWORD   i = 0;

    if( SUCCEEDED( strFullKeyName.Append( L"/", 1 ) ) )
    {
        while ( const_cast<MB &>(mb).EnumObjects( szFilterPath,
                                                  szKeyName, 
                                                  i++ ) )
        {
        
            if( SUCCEEDED( strFullKeyName.Append( szKeyName ) ) )
            {
                if( const_cast<MB &>(mb).GetStr( strFullKeyName.QueryStr(),
                                                 MD_FILTER_IMAGE_PATH,
                                                 IIS_MD_UT_SERVER,
                                                 &strFilterPath ) )
                {
                    pmsz->Append( strFilterPath );
                }
            }
            strFullKeyName.SetLen( pchFilterPath + 1 );
        }
    }
}

VOID
AddAllFiltersToMultiSz(
    IN const MB &       mb,
    IN OUT MULTISZ *    pmsz
    )
/*++

    Description:

        This is designed to prevent ISAPI extension/filter
        combination dlls from running out of process.

        Add the base set of filters defined for the service to pmsz.
        Iterate through the sites and add the filters defined for
        each site.

    Arguments:

        mb              metabase key open to /LM/W3SVC
        pmsz            multisz containing the in proc dlls

    Return:
        Nothing - failure cases ignored.

--*/
{
    WCHAR   szKeyName[MAX_PATH + 1];
    STRU    strFullKeyName;
    DWORD   i = 0;
    DWORD   dwInstanceId = 0;

    if ( FAILED( strFullKeyName.Copy( L"/" ) ) )
    {
        return;
    }

    AddFiltersToMultiSz( mb, L"/Filters", pmsz );

    while ( const_cast<MB &>(mb).EnumObjects( L"",
                                              szKeyName,
                                              i++ ) )
    {
        dwInstanceId = _wtoi( szKeyName );
        if( 0 != dwInstanceId )
        {
            // This is a site.
            if( SUCCEEDED( strFullKeyName.Append( szKeyName ) ) &&
                SUCCEEDED( strFullKeyName.Append( L"/Filters" ) ) )
            {
                AddFiltersToMultiSz( mb, strFullKeyName.QueryStr(), pmsz );
            }

            strFullKeyName.SetLen( 1 );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\makefile.inc ===
$(O)\w3msg.h $(O)\MSG00001.bin: w3msg.mc $(IISBASEDIR)\inc\inetamsg.mc
    copy /a $(IISBASEDIR)\inc\inetamsg.mc + /a w3msg.mc $(O)\tmp.mc
    mc -v -h .\$(O) -r .\$(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\w3msg.h
    copy $(O)\tmp.rc $(O)\w3msg.rc
    del $(O)\tmp.*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_handler.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    isapi_handler.h

Abstract:

    Handler class for ISAPI

Author:

    Taylor Weiss (TaylorW)       01-Feb-1999

Revision History:

--*/

#ifndef _ISAPI_HANDLER_H_
#define _ISAPI_HANDLER_H_

#include "precomp.hxx"
#include <w3isapi.h>
#include "isapi_request.hxx"
#include "iwam.h"
#include "wam_process.hxx"

//
// OOP support flags
//

// The pool's hard-coded CLSID
#define POOL_WAM_CLSID   L"{99169CB1-A707-11d0-989D-00C04FD919C1}"

// Application type
#define APP_INPROC   0
#define APP_ISOLATED 1
#define APP_POOL     2

//
// W3_ISAPI_HANDLER states
//

#define ISAPI_STATE_PRELOAD      0 // Preloading entity body
#define ISAPI_STATE_INITIALIZING 1 // Not yet called into extension code
#define ISAPI_STATE_PENDING      2 // Extension has returned HSE_STATUS_PENDING
#define ISAPI_STATE_FAILED       3 // Call out to extension failed
#define ISAPI_STATE_DONE         4 // Extension is done, it's safe to advance

//
// ISAPI_CORE_DATA inline size
//

#define DEFAULT_CORE_DATA_SIZE  512

//
// Globals
//

extern BOOL sg_Initialized;

//
// W3_INPROC_ISAPI
//

class W3_INPROC_ISAPI
{
public:
    
    W3_INPROC_ISAPI()
        : _cRefs( 1 )
    {
    }

    HRESULT
    Create(
        LPWSTR pName
        )
    {
        return strName.Copy( pName );
    }

    LPWSTR
    QueryName(
        VOID
        ) const
    {
        return (LPWSTR)strName.QueryStr();
    }

    VOID
    ReferenceInprocIsapi(
        VOID
        )
    {
        InterlockedIncrement( &_cRefs );
    }

    VOID
    DereferenceInprocIsapi(
        VOID
        )
    {
        DBG_ASSERT( _cRefs != 0 );

        InterlockedDecrement( &_cRefs );

        if ( _cRefs == 0 )
        {
            delete this;
        }
    }

private:

    ~W3_INPROC_ISAPI()
    {
    }

    LONG    _cRefs;
    STRU    strName;
};

//
// W3_INPROC_ISAPI_HASH
//

class W3_INPROC_ISAPI_HASH
    : public CTypedHashTable<
            W3_INPROC_ISAPI_HASH,
            W3_INPROC_ISAPI,
            LPCWSTR
            >
{
public:
    W3_INPROC_ISAPI_HASH()
        : CTypedHashTable< W3_INPROC_ISAPI_HASH, 
                           W3_INPROC_ISAPI, 
                           LPCWSTR > ( "W3_INPROC_ISAPI_HASH" )
    {
    }
    
    static 
    LPCWSTR
    ExtractKey(
        const W3_INPROC_ISAPI *      pEntry
    )
    {
        return pEntry->QueryName();
    }
    
    static
    DWORD
    CalcKeyHash(
        LPCWSTR              pszKey
    )
    {
        int cchKey = wcslen(pszKey);

        return HashStringNoCase(pszKey, cchKey);
    }
     
    static
    bool
    EqualKeys(
        LPCWSTR               pszKey1,
        LPCWSTR               pszKey2
    )
    {
        return _wcsicmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        W3_INPROC_ISAPI *       pEntry,
        int                   nIncr
        )
    {
        if ( nIncr == +1 )
        {
            pEntry->ReferenceInprocIsapi();
        }
        else if ( nIncr == - 1)
        {
            pEntry->DereferenceInprocIsapi();
        }
    }

    MULTISZ     _mszImages;

};

class W3_ISAPI_HANDLER : public W3_HANDLER
{
public:
    
    W3_ISAPI_HANDLER( W3_CONTEXT * pW3Context,
                      META_SCRIPT_MAP_ENTRY * pScriptMapEntry )
        : W3_HANDLER( pW3Context, pScriptMapEntry ),
          _pIsapiRequest( NULL ),
          _fIsDavRequest( FALSE ),
          _pCoreData( NULL ),
          _fEntityBodyPreloadComplete( FALSE ),
          _pWamProcess( NULL ),
          _State( ISAPI_STATE_PRELOAD ),
          _buffCoreData( _abCoreData, sizeof( _abCoreData ) )
    {
        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Creating W3_ISAPI_HANDLER %p.  W3Context=%p.\r\n",
                this,
                pW3Context
                ));
        }
        
        //
        // Update perf counter information
        //

        pW3Context->QuerySite()->IncIsapiExtReqs();

        //
        // Temporarily up the thread threshold since we don't know when the 
        // ISAPI will return
        //
    
        ThreadPoolSetInfo( ThreadPoolIncMaxPoolThreads, 0 ); 

        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "W3_ISAPI_HANDLER %p created successfully.\r\n",
                this
                ));
        }
    }

    ~W3_ISAPI_HANDLER()
    {
        //
        // Update perf counter information.
        //

        QueryW3Context()->QuerySite()->DecIsapiExtReqs();

        //
        // Back down the count since the ISAPI has returned
        //
    
        ThreadPoolSetInfo( ThreadPoolDecMaxPoolThreads, 0 );

        //
        // Release this request's reference on the WAM_PROCESS
        // if applicable
        //

        if ( _pWamProcess )
        {
            _pWamProcess->Release();
            _pWamProcess = NULL;
        }

        IF_DEBUG( ISAPI )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "W3_ISAPI_HANDLER %p has been destroyed.\r\n"
                ));
        }
    }

    VOID * 
    operator new( 
        size_t            size
    )
    {
        DBG_ASSERT( size == sizeof( W3_ISAPI_HANDLER ) );
        DBG_ASSERT( sm_pachIsapiHandlers != NULL );
        return sm_pachIsapiHandlers->Alloc();
    }
    
    VOID
    operator delete(
        VOID *              pIsapiHandler
    )
    {
        DBG_ASSERT( pIsapiHandler != NULL );
        DBG_ASSERT( sm_pachIsapiHandlers != NULL );
        
        DBG_REQUIRE( sm_pachIsapiHandlers->Free( pIsapiHandler ) );
    }

    WCHAR *
    QueryName(
        VOID
        )
    {
        return L"ISAPIHandler";
    }

    BOOL
    QueryManagesOwnHead(
        VOID
        )
    {
        return TRUE;
    }

    CONTEXT_STATUS
    DoWork(
        VOID
        );

    CONTEXT_STATUS
    OnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    CONTEXT_STATUS
    IsapiDoWork(
        W3_CONTEXT *            pW3Context
        );

    CONTEXT_STATUS
    IsapiOnCompletion(
        DWORD                   cbCompletion,
        DWORD                   dwCompletionStatus
        );

    HRESULT
    InitCoreData(
        BOOL *  pfIsVrToken
        );

    HRESULT
    SetDavRequest( LPCWSTR szDavIsapiImage )
    {
        HRESULT hr = _strDavIsapiImage.Copy( szDavIsapiImage );

        if ( SUCCEEDED( hr ) )
        {
            _fIsDavRequest = TRUE;
        }

        return hr;
    }

    BOOL
    QueryIsOop(
        VOID
    ) const
    {
        return _pCoreData->fIsOop;
    }

    HRESULT
    DuplicateWamProcessHandleForLocalUse(
        HANDLE      hWamProcessHandle,
        HANDLE *    phLocalHandle
        );

    HRESULT
    MarshalAsyncReadBuffer(
        DWORD_PTR   pWamExecInfo,
        LPBYTE      pBuffer,
        DWORD       cbBuffer
        );

    VOID
    IsapiRequestFinished(
        VOID
        );
         
    static
    HRESULT
    Initialize(
        VOID
    );

    static
    VOID
    Terminate(
        VOID
    );

    static
    HRESULT
    W3SVC_WamRegSink(
        LPCSTR      szAppPath,
        const DWORD dwCommand,
        DWORD *     pdwResult
        );

    static
    BOOL QueryIsInitialized( VOID )
    {
        return sg_Initialized;
    }

    static
    BOOL
    IsInprocIsapi(
        WCHAR * szImage
    )
    {
        W3_INPROC_ISAPI *   pRecord;
        BOOL                fRet;

        DBG_ASSERT( sg_Initialized );

        EnterCriticalSection( &sm_csInprocHashLock );

        if ( sm_pInprocIsapiHash == NULL )
        {
            fRet = FALSE;
        }
        else
        {
            fRet = LK_SUCCESS == sm_pInprocIsapiHash->FindKey( szImage, &pRecord );
        }

        LeaveCriticalSection( &sm_csInprocHashLock );

        if ( fRet )
        {
            pRecord->DereferenceInprocIsapi();
        }

        return fRet;
    }

    static
    HRESULT
    UpdateInprocIsapiHash(
        VOID
    );

private:

    ISAPI_REQUEST *     _pIsapiRequest;
    BOOL                _fIsDavRequest;
    STRU                _strDavIsapiImage;
    ISAPI_CORE_DATA *   _pCoreData;
    WAM_PROCESS *       _pWamProcess;
    DWORD               _State;

    //
    // Have we finished preloading entity body?
    //
    BOOL                                _fEntityBodyPreloadComplete;

    //
    // Buffer containing core data
    //

    BUFFER              _buffCoreData;
    BYTE                _abCoreData[ DEFAULT_CORE_DATA_SIZE ];

    static HMODULE                      sm_hIsapiModule;
    static PFN_ISAPI_TERM_MODULE        sm_pfnTermIsapiModule;
    static PFN_ISAPI_PROCESS_REQUEST    sm_pfnProcessIsapiRequest;
    static PFN_ISAPI_PROCESS_COMPLETION sm_pfnProcessIsapiCompletion;
    static IWam *                       sm_pIWamPool;
    static W3_INPROC_ISAPI_HASH *       sm_pInprocIsapiHash;
    static CRITICAL_SECTION             sm_csInprocHashLock;
    static WAM_PROCESS_MANAGER *        sm_pWamProcessManager;
    static BOOL                         sm_fWamActive;
    static CHAR                         sm_szInstanceId[SIZE_CLSID_STRING];
    static ALLOC_CACHE_HANDLER *        sm_pachIsapiHandlers;
    static CRITICAL_SECTION             sm_csBigHurkinWamRegLock;

    //
    // Private functions
    //

    VOID
    RestartCoreStateMachine(
        VOID
        );

    static
    VOID
    LockWamReg()
    {
        EnterCriticalSection( &sm_csBigHurkinWamRegLock );
    }

    static
    VOID
    UnlockWamReg()
    {
        LeaveCriticalSection( &sm_csBigHurkinWamRegLock );
    }
};

#endif // _ISAPI_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\logging.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     logging.cxx

   Abstract:
     Handle Logging

   Author:
     Anil Ruia (AnilR)              1-Jul-2000

   Environment:
     Win32 - User Mode

   Project:
     w3core.dll
--*/

#include "precomp.hxx"

CONTEXT_STATUS W3_STATE_LOG::DoWork(
    W3_MAIN_CONTEXT *pMainContext,
    DWORD,
    DWORD)
/*++

Routine Description:

    Log the request (and call the END_OF_REQUEST notification)

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the
                   state machine

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    BOOL            fUnused = FALSE;

    if (pMainContext->QueryNeedFinalDone())
    {
        //
        // Clear remaining chunks from handle/response state
        //

        pMainContext->QueryResponse()->Clear();

        //
        // End of request notifications happen BEFORE logging.
        //

        if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST ) )
        {
            pMainContext->NotifyFilters( SF_NOTIFY_END_OF_REQUEST,
                                         NULL,
                                         &fUnused );
        }
        
        //
        // Clear any crud from the last write from END_OF_REQUEST filter
        //

        pMainContext->QueryResponse()->Clear();

        //
        // Do the final send
        //

        pMainContext->SendEntity(W3_FLAG_PAST_END_OF_REQ);
    }

    if (pMainContext->QueryDoCustomLogging())
    {
        if (FAILED(pMainContext->CollectLoggingData(FALSE)))
        {
            goto Exit;
        }

        pMainContext->QuerySite()->LogInformation(pMainContext->QueryLogContext());
    }

 Exit:
    return CONTEXT_STATUS_CONTINUE;
}


CONTEXT_STATUS W3_STATE_LOG::OnCompletion(
    W3_MAIN_CONTEXT *pMainContext,
    DWORD,
    DWORD)
/*++

Routine Description:

    Completion for the W3_STATE_LOG state

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the
                   state machine

Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    //
    // This code should never get hit
    //
    DBG_ASSERT(FALSE);

    return CONTEXT_STATUS_CONTINUE;
}


HRESULT W3_MAIN_CONTEXT::CollectLoggingData(BOOL fCollectForULLogging)
/*++

Routine Description:

    Routine which collects all the logging data

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    STACK_STRA(strVal, 64);
    STACK_STRU(strValW, 64);
    HRESULT hr = S_OK;
    DWORD dwLength;

    HTTP_LOG_FIELDS_DATA *pUlLogData = QueryUlLogData();
    W3_REQUEST *pRequest = QueryRequest();

    if (IsNotificationNeeded(SF_NOTIFY_LOG))
    {
        //
        // There is a SF_NOTIFY_LOG filter, collect the data for the
        // notification
        //
        HTTP_FILTER_LOG filtLog;
        ZeroMemory(&filtLog, sizeof filtLog);

        if (SUCCEEDED(GetServerVariableRemoteHost(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = _HeaderBuffer.AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszClientHostName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszClientHostName,
                                 &dwLength);
        }

        if (SUCCEEDED(GetServerVariableLogonUser(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = _HeaderBuffer.AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszClientUserName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszClientUserName,
                                 &dwLength);
        }
        else
        {
            filtLog.pszClientUserName = "";
        }

        if (SUCCEEDED(GetServerVariableLocalAddr(this, &strVal)))
        {
            dwLength = strVal.QueryCCH() + 1;
            if (FAILED(hr = _HeaderBuffer.AllocateSpace(
                                dwLength,
                                (PCHAR *)&filtLog.pszServerName)))
            {
                goto Exit;
            }
            strVal.CopyToBuffer((LPSTR)filtLog.pszServerName,
                                 &dwLength);
        }

        pRequest->QueryVerb((CHAR **)&filtLog.pszOperation, (USHORT *)&dwLength);

        if (FAILED(hr = pRequest->GetUrl(&strValW)) ||
            FAILED(hr = strVal.CopyWToUTF8(strValW)) ||
            FAILED(hr = _HeaderBuffer.AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                (CHAR **)&filtLog.pszTarget)))
        {
            goto Exit;
        }

        //
        // If an ISAPI used HSE_APPEND_LOG_PARAMETER use it
        //
        if (_LogContext.m_strLogParam.IsEmpty())
        {
            pRequest->GetQueryStringA(&_LogContext.m_strLogParam);
        }
        filtLog.pszParameters = _LogContext.m_strLogParam.QueryStr();

        filtLog.dwHttpStatus = QueryResponse()->QueryStatusCode();
        
        if ( HRESULT_FACILITY( QueryErrorStatus() ) == FACILITY_WIN32 )
        {
            filtLog.dwWin32Status = WIN32_FROM_HRESULT( QueryErrorStatus() );
        }
        else
        {
            filtLog.dwWin32Status = QueryErrorStatus();
        }

        filtLog.dwBytesSent = _LogContext.m_dwBytesSent;
        filtLog.dwBytesRecvd = _LogContext.m_dwBytesRecvd;
        filtLog.msTimeForProcessing = GetTickCount() - _LogContext.m_msStartTickCount;

        NotifyFilters(SF_NOTIFY_LOG, &filtLog, NULL);

        //
        // The filter may have changed some the data, copy it back to our
        // logging structure
        //
        pUlLogData->ClientIp = (CHAR *)filtLog.pszClientHostName;
        pUlLogData->ClientIpLength = (USHORT) strlen(filtLog.pszClientHostName);

        if (FAILED(hr = strValW.CopyA(filtLog.pszClientUserName)) ||
            FAILED(hr = _HeaderBuffer.AllocateSpace(
                            strValW.QueryStr(),
                            strValW.QueryCCH(),
                            &pUlLogData->UserName)))
        {
            goto Exit;
        }
        pUlLogData->UserNameLength =
            (USHORT)(strValW.QueryCCH() * sizeof(WCHAR));

        pUlLogData->ServerIp = (CHAR *)filtLog.pszServerName;
        pUlLogData->ServerIpLength = (USHORT) strlen(filtLog.pszServerName);

        pUlLogData->Method = (CHAR *)filtLog.pszOperation;
        pUlLogData->MethodLength = (USHORT) strlen(filtLog.pszOperation);

        if (FAILED(hr = strValW.CopyA(filtLog.pszTarget)) ||
            FAILED(hr = _HeaderBuffer.AllocateSpace(
                            strValW.QueryStr(),
                            strValW.QueryCCH(),
                            &pUlLogData->UriStem)))
        {
            goto Exit;
        }
        pUlLogData->UriStemLength =
            (USHORT)(strValW.QueryCCH() * sizeof(WCHAR));

        pUlLogData->UriQuery = (CHAR *)filtLog.pszParameters;
        pUlLogData->UriQueryLength = (USHORT) strlen(filtLog.pszParameters);

        pUlLogData->ProtocolStatus = filtLog.dwHttpStatus;
        pUlLogData->Win32Status = filtLog.dwWin32Status;
        _LogContext.m_dwBytesSent = filtLog.dwBytesSent;
        _LogContext.m_dwBytesRecvd = filtLog.dwBytesRecvd;
        _LogContext.m_msProcessingTime = filtLog.msTimeForProcessing;
    }
    else
    {
        //
        // No filter, just get the logging data
        //
        if (SUCCEEDED(GetServerVariableRemoteHost(this, &strVal)))
        {
            if (FAILED(hr = _HeaderBuffer.AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                &pUlLogData->ClientIp)))
            {
                goto Exit;
            }
            pUlLogData->ClientIpLength = (USHORT)strVal.QueryCCH();
        }

        if ( QueryUserContext() == NULL )
        {
            if (FAILED(hr = pRequest->GetRequestUserName(&strVal)))
            {
                goto Exit;
            }

            if (strVal.IsEmpty())
            {
                pUlLogData->UserName = L"";
                pUlLogData->UserNameLength = 0;
            }
            else
            {
                if (FAILED(hr = strValW.CopyA(strVal.QueryStr())) ||
                    FAILED(hr = _HeaderBuffer.AllocateSpace(
                                    strValW.QueryStr(),
                                    strValW.QueryCCH(),
                                    &pUlLogData->UserName)))
                {
                    goto Exit;
                }
                pUlLogData->UserNameLength = (USHORT)strValW.QueryCB();
            }
        }
        else
        {
            pUlLogData->UserName = QueryUserContext()->QueryUserName();
            if (pUlLogData->UserName)
            {
                pUlLogData->UserNameLength = wcslen(pUlLogData->UserName) * sizeof(WCHAR);
            }
        }

        if (SUCCEEDED(GetServerVariableLocalAddr(this, &strVal)))
        {
            if (FAILED(hr = _HeaderBuffer.AllocateSpace(
                                strVal.QueryStr(),
                                strVal.QueryCCH(),
                                &pUlLogData->ServerIp)))
            {
                goto Exit;
            }
            pUlLogData->ServerIpLength =
                (USHORT)strVal.QueryCCH();
        }

        pRequest->QueryVerb(&pUlLogData->Method,
                            &pUlLogData->MethodLength);

        pRequest->QueryUrl(&pUlLogData->UriStem,
                           &pUlLogData->UriStemLength);

        //
        // If an ISAPI used HSE_APPEND_LOG_PARAMETER use it
        //
        if (_LogContext.m_strLogParam.IsEmpty())
        {
            pRequest->GetQueryStringA(&_LogContext.m_strLogParam);
        }
        pUlLogData->UriQuery = _LogContext.m_strLogParam.QueryStr();
        pUlLogData->UriQueryLength = (USHORT)_LogContext.m_strLogParam.QueryCCH();

        pUlLogData->ProtocolStatus = QueryResponse()->QueryStatusCode();
        if ( HRESULT_FACILITY( QueryErrorStatus() ) == FACILITY_WIN32 )
        {
            pUlLogData->Win32Status = WIN32_FROM_HRESULT( QueryErrorStatus() );
        }
        else
        {
            pUlLogData->Win32Status = QueryErrorStatus();
        }
    }

    //
    // Now get data unaffected by any SF_NOTIFY_LOG filter
    //
    pUlLogData->ServerPort = pRequest->QueryLocalPort();

    pUlLogData->ServiceName = QuerySite()->QueryName()->QueryStr();
    pUlLogData->ServiceNameLength = (USHORT)QuerySite()->QueryName()->QueryCCH();

    pUlLogData->ServerName = g_pW3Server->QueryComputerName();
    pUlLogData->ServerNameLength = g_pW3Server->QueryComputerNameLength();

    if (fCollectForULLogging)
    {
        pUlLogData->Host = pRequest->GetHeader(HttpHeaderHost,
                                               &pUlLogData->HostLength);

        pUlLogData->UserAgent = pRequest->GetHeader(HttpHeaderUserAgent,
                                                    &pUlLogData->UserAgentLength);
        pUlLogData->Cookie = pRequest->GetHeader(HttpHeaderCookie,
                                                 &pUlLogData->CookieLength);

        pUlLogData->Referrer = pRequest->GetHeader(HttpHeaderReferer,
                                                   &pUlLogData->ReferrerLength);
    }
    else
    {
        _LogContext.m_msProcessingTime =
            GetTickCount() - _LogContext.m_msStartTickCount;

        GetServerVariableHttpVersion(this,
                                     &_LogContext.m_strVersion);

        if (QuerySite()->IsRequiredExtraLoggingFields())
        {
            //
            // If the custom logging module needs extra logging fields, get them
            //

            const MULTISZA *pmszExtraLoggingFields =
                QuerySite()->QueryExtraLoggingFields();
            LPSTR pszHeaderName = (LPSTR)pmszExtraLoggingFields->First();

            while (pszHeaderName != NULL)
            {
                hr = SERVER_VARIABLE_HASH::GetServerVariable(
                         this,
                         pszHeaderName,
                         &strVal);
                if (FAILED(hr))
                {
                    goto Exit;
                }

                if (!_LogContext.m_mszHTTPHeaders.Append(strVal.QueryStr()))
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }

                pszHeaderName = (LPSTR)pmszExtraLoggingFields->Next(pszHeaderName);
            }
        }
    }

 Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\isapi_request.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     isapi_request.cxx

   Abstract:
     IIS+ IIsapiCore implementation.
 
   Author:
     Wade Hilmo (wadeh)             29-Aug-2000

   Project:
     w3core.dll

--*/

#include "precomp.hxx"
#include "isapi_request.hxx"
#include "iisapicore_i.c"
#include "isapi_handler.h"
#include "stringau.hxx"

#define ISAPI_REQUEST_CACHE_THRESHOLD   (400) // Value lifted from IIS 5

ALLOC_CACHE_HANDLER *   ISAPI_REQUEST::sm_pachIsapiRequest;
PTRACE_LOG              ISAPI_REQUEST::sm_pTraceLog;


void *
ISAPI_REQUEST::operator new ( size_t s )
/*++

Routine Description:

    Overloaded allocator for acache

Arguments:

    s - Amount of memory to be allocated
    
Return Value:

    Pointer to the new object

--*/
{
    DBG_ASSERT( s == sizeof( ISAPI_REQUEST ) );

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachIsapiRequest);

    return ( sm_pachIsapiRequest->Alloc() );
}

void
ISAPI_REQUEST::operator delete( void * pir )
/*++

Routine Description:

    Overloaded deallocator for acache

Arguments:

    pir - Pointer to object to be deleted
    
Return Value:

    None

--*/
{
    DBG_ASSERT( NULL != pir);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachIsapiRequest );
    DBG_REQUIRE( sm_pachIsapiRequest->Free( pir ) );

    return;
}

BOOL
ISAPI_REQUEST::InitClass( VOID )
/*++

Routine Description:

    Acache initialization function

Arguments:

    None
    
Return Value:

    TRUE on success, FALSE on error

--*/
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, ISAPI_REQUEST_CACHE_THRESHOLD,
                                            sizeof( ISAPI_REQUEST ) };

    if ( NULL != sm_pachIsapiRequest) {

        // already initialized
        return ( TRUE);
    }

    sm_pachIsapiRequest = new ALLOC_CACHE_HANDLER( "IsapiRequest",
                                                    &acConfig);

#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    sm_pTraceLog = NULL;
#endif

    return ( NULL != sm_pachIsapiRequest);
}

VOID
ISAPI_REQUEST::CleanupClass( VOID )
/*++

Routine Description:

    Acache cleanup function

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    if ( NULL != sm_pachIsapiRequest)
    {
        delete sm_pachIsapiRequest;
        sm_pachIsapiRequest = NULL;
    }

    return;
}

HRESULT
ISAPI_REQUEST::Create(
    VOID
    )
/*++

Routine Description:

    Creates a newly allocated ISAPI_REQUEST object.  This
    function does initialization tasks which wouldn't be
    appropriate in the constructor due to potential failure
    during initialization.

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating ISAPI_REQUEST %p, W3Context=%p, Handler=%p.\r\n",
            this,
            _pW3Context,
            _pW3Context->QueryHandler()
            ));
    }

    if ( _fIsOop )
    {
        hr = CoCreateFreeThreadedMarshaler(this, &_pUnkFTM);
    }

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p.  Failed to CoCreate free threaded marshaler.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Failed to create ISAPI_REQUEST %p.  HRESULT=%08x.\r\n",
        this,
        hr
        ));

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::QueryInterface( 
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvObject
    )
/*++

Routine Description:

    COM Goo

Arguments:

    riid      - Id of the interface requested
    ppvObject - Upon return, points to requested interface
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( ppvObject );

    *ppvObject = NULL;
/*
    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_REQUEST::QueryInterface looking for ... ( " GUID_FORMAT " )\n",
        GUID_EXPAND( &riid)
        ));
*/
    if( riid == IID_IIsapiCore )
    {
        *ppvObject = static_cast<IIsapiCore *>( this );
    }
    else if ( riid == IID_IMarshal )
    {
        if ( _pUnkFTM == NULL )
        {
            DBG_ASSERT(FALSE);
            return E_NOINTERFACE;
        }
        else
        {
            return _pUnkFTM->QueryInterface(riid, ppvObject);
        }
    }
    else if( riid == IID_IUnknown )
    {
        *ppvObject = static_cast<IIsapiCore *>( this );
    }
    else if ( _pUnkFTM != NULL )
    {
        return _pUnkFTM->QueryInterface(riid, ppvObject);
    }
    else
    {
        return E_NOINTERFACE;
    }

    DBG_ASSERT( *ppvObject );
    ((IUnknown *)*ppvObject)->AddRef();
/*
    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_REQUEST::QueryInterface found ( " GUID_FORMAT ", %p )\n",
        GUID_EXPAND( &riid),
        *ppvObject
        ));
*/    
    return NOERROR;
}
    
ULONG STDMETHODCALLTYPE
ISAPI_REQUEST::AddRef(
    void
    )
/*++

Routine Description:

    COM Goo - adds a reference to the object

Arguments:

    None
    
Return Value:

    The number of references remaining at completion of this call

--*/
{
    LONG cRefs;

    DBG_ASSERT( CheckSignature() );

    cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    return cRefs;
}
    
ULONG STDMETHODCALLTYPE
ISAPI_REQUEST::Release(
    void
    )
/*++

Routine Description:

    COM Goo - deletes a referece to the object, and deletes
              the object upon zero references

Arguments:

    None
    
Return Value:

    The number of references remaining at completion of this call

--*/
{
    LONG cRefs;
    BOOL fIsOop = _fIsOop;

    DBG_ASSERT( CheckSignature() );

    //
    // WARNING - This object is always created by W3_ISAPI_HANDLER,
    //           and that code uses the return value from Release
    //           to determine if it's safe to advance the core
    //           state machine.  It is essential that this function
    //           only return 0 in the case where it's called delete.
    //

    cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    if ( ( cRefs == 1 ) && fIsOop )
    {
        _pWamProcess->RemoveIsapiRequestFromList( this );
    }

    if ( cRefs == 0 )
    {
        delete this;
        return 0;
    }

    return cRefs;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetServerVariable(
    LPSTR           szVariableName,
    BYTE *          szBuffer,
    DWORD           cbBuffer,
    DWORD *         pcbBufferRequired
    )
/*++

Routine Description:

    Returns the value of a server variable

Arguments:

    szVariableName    - The name of the server variable
    szBuffer          - Upon return, contains the value of the server variable
    cbBuffer          - The size of szBuffer.
    pcbBufferRequired - On successful return, the number of bytes copied
                        to the buffer.  On failure, the number of bytes
                        required to hold szBuffer.
    
Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szVariableName );
    DBG_ASSERT( pcbBufferRequired );
    DBG_ASSERT( szBuffer || ( cbBuffer == 0 ) );

    hr = SERVER_VARIABLE_HASH::GetServerVariable(
        _pW3Context,
        szVariableName,
        (LPSTR)szBuffer,
        &cbBuffer
        );

    *pcbBufferRequired = cbBuffer;

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ReadClient( 
    DWORD64 IsaContext,
    BYTE *pBuffer,
    DWORD cbBuffer,
    DWORD dwBytesToRead,
    DWORD *pdwSyncBytesRead,
    DWORD dwFlags
    )
 /*++

Routine Description:

    Reads data from the client

Arguments:

    IsaContext       - The ISAPI_CONTEXT for this request (opaque)
    pBuffer          - Contains read data upon return for sync reads
    cbBuffer         - The size of pSyncReadBuffer
    dwBytesToRead    - The number of bytes to read
    pdwSyncBytesRead - The number of bytes copied to pBuffer in sync case
    dwFlags          - HSE_IO_* flags from caller
    
Return Value:

    HRESULT

--*/
{
    DWORD   dwBytesRead;
    HRESULT hr = NOERROR;
    BOOL    fAsync = !!( dwFlags & HSE_IO_ASYNC );
    
    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( fAsync == !!IsaContext );
    DBG_ASSERT( dwBytesToRead );
    DBG_ASSERT( pBuffer || ( cbBuffer == 0 ) );
    DBG_ASSERT( pdwSyncBytesRead || fAsync );

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    //
    // If this is an OOP async read, then we need to create a
    // local buffer to read into.
    //

    if ( _fIsOop && fAsync )
    {
        DBG_ASSERT( _pAsyncReadBuffer == NULL );

        _pAsyncReadBuffer = (LPBYTE)LocalAlloc( LPTR, dwBytesToRead );

        if ( !_pAsyncReadBuffer )
        {
            goto ErrorExit;
        }

        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();

        hr = _pW3Context->ReceiveEntity(
            fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC,
            _pAsyncReadBuffer,
            dwBytesToRead,
            &dwBytesRead
            );
    }
    else
    {
        hr = _pW3Context->ReceiveEntity(
            fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC,
            pBuffer,
            dwBytesToRead,
            fAsync ? &dwBytesRead : pdwSyncBytesRead
            );
    }

    //
    // If the request is chunked, look for ERROR_HANDLE_EOF.  This
    // is how http.sys signals the end of a chunked request.
    //
    // Since an ISAPI extension is looking for a successful, zero
    // byte read, we'll need to change the result of the above call.
    //
    // Note that on an asynchronous call, we'll need to trigger a
    // "fake" completion with zero bytes.
    //

    if ( FAILED( hr ) && _pW3Context->QueryRequest()->IsChunkedRequest() )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ) )
        {
            hr = NOERROR;

            if ( fAsync )
            {
                ThreadPoolPostCompletion(
                    0,
                    W3_MAIN_CONTEXT::OnPostedCompletion,
                    (LPOVERLAPPED)_pW3Context->QueryMainContext()
                    );
            }
            else
            {
                *pdwSyncBytesRead = 0;
            }
        }
    }

    //
    // We now return you to your regular error handling program.
    //

    if ( FAILED( hr ) )
    {
        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no completion
            // will be coming.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _pAsyncReadBuffer )
    {
        LocalFree( _pAsyncReadBuffer );
        _pAsyncReadBuffer = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::WriteClient(
    DWORD64         IsaContext,
    BYTE *          pBuffer,
    DWORD           cbBuffer,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Writes data to the client

Arguments:

    IsaContext - The ISAPI_CONTEXT for this request (opaque)
    pBuffer    - Contains the data to write
    cbBuffer   - The amount of data to be written
    dwFlags    - HSE_IO_* flags from caller
    
Return Value:

    HRESULT

--*/
{
    W3_RESPONSE *   pResponse;
    HRESULT         hr = NOERROR;
    BOOL            fAsync = !!( dwFlags & HSE_IO_ASYNC );

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( fAsync == !!IsaContext );
    DBG_ASSERT( pBuffer || ( cbBuffer == 0 ) );

    //
    // For a zero byte send, just return
    //
    // If the call was async, we'll need to fire off a completion.
    //
    // Note that this case shouldn't ever happen, as the w3isapi.dll
    // code that calls this currently does a check for a zero byte
    // write attempt.  That code is somewhat broken in that a completion
    // will never occur for a zero byte completion.  That's the way all
    // previous versions of ISAPI have worked, though.  This code is
    // here for the sole purpose that this interface could work properly
    // with an API that expects a completion on a zero byte async write.
    //

    if ( cbBuffer == 0 )
    {
        if ( fAsync )
        {
            ThreadPoolPostCompletion(
                0,
                W3_MAIN_CONTEXT::OnPostedCompletion,
                (LPOVERLAPPED)_pW3Context->QueryMainContext()
                );
        }

        return hr;
    }

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    DBG_REQUIRE( pResponse = _pW3Context->QueryResponse() );

    //
    // If this as an OOP async write then we will work from a local copy
    // of pBuffer.
    //

    if ( _fIsOop && fAsync )
    {
        DBG_ASSERT( _pAsyncWriteBuffer == NULL );

        _pAsyncWriteBuffer = (LPBYTE)LocalAlloc( LPTR, cbBuffer );

        if ( !_pAsyncWriteBuffer )
        {
            goto ErrorExit;
        }

        memcpy( _pAsyncWriteBuffer, pBuffer, cbBuffer );

        pBuffer = _pAsyncWriteBuffer;
    }

    //
    // Before sending the current data, we need to clear out
    // any outstanding chunks from the response object.  This can't
    // ever cause a problem for a purely synchronous ISAPI.  And,
    // since w3isapi.dll protects against multiple outstanding
    // asynchronous I/O, we shouldn't see a problem with a
    // purely asynchronous I/O.
    //
    // If an ISAPI sends data asynchronously and then follows up
    // with a second, synchronous send, then it's possible that
    // the second send could clear the chunks from the first before
    // they've been fully processed.  This is a really, really
    // dumb thing for an ISAPI to do, since the response would
    // likely be scrambled at the client.  So, we'll live with
    // problems in that scenario.
    //

    pResponse->Clear();

    //
    // Now setup the buffer we want to send
    //

    hr = pResponse->AddMemoryChunkByReference(
        pBuffer,
        cbBuffer
        );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // Ok, now send what we've got.
    //

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    hr = _pW3Context->SendEntity(
        ( fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC ) | W3_FLAG_MORE_DATA 
        );

    if ( FAILED( hr ) )
    {
        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion
            // will ever happen.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _pAsyncWriteBuffer )
    {
        LocalFree( _pAsyncWriteBuffer );
        _pAsyncWriteBuffer = NULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendResponseHeaders(
    BOOL            fDisconnect,
    LPSTR           szStatus,
    LPSTR           szHeaders,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Sends response headers to the client

Arguments:

    fDisconnect - If FALSE, then we need to avoid closing the connection
    szStatus    - The status to send (ie. "200 OK")
    szHeaders   - The headers to send (ie. "foo: value1\r\nBar: value2\r\n")
    dwFlags     - HSE_IO_* flags from caller
    
Return Value:

    HRESULT

--*/
{
    W3_RESPONSE   * pResponse;
    HRESULT         hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //
    
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( pResponse = _pW3Context->QueryResponse() );

    //
    // Set the disconnect disposition
    //

    _pW3Context->SetDisconnect( fDisconnect );

    //
    // Need to clear any existing response
    //

    pResponse->Clear();

    //
    // Setup response from ISAPI
    //

    hr = pResponse->BuildResponseFromIsapi(
        _pW3Context,
        szStatus,
        szHeaders,
        szHeaders ? strlen( szHeaders ) : 0
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Is the status is access denied, then set the sub status to 
    // "Denied by Application"
    // 
    
    if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
    {
        pResponse->SetStatus( HttpStatusUnauthorized,
                              Http401Application );
    }

    hr =  _pW3Context->SendResponse(
          W3_FLAG_SYNC
          | W3_FLAG_MORE_DATA 
          | W3_FLAG_NO_ERROR_BODY );

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::MapPath(
    BYTE *          szPath,
    DWORD           cbPath,
    DWORD *         pcbBufferRequired,
    BOOL            fUnicode
    )
/*++

Routine Description:

    Maps a URL to a physical path

Arguments:

    szPath            - On entry, the URL to map
                      - On return, the mapped physical path
    cbPath            - The size of szPath
    pcbBufferRequired - On successful return, the number of szPath
                        On error return, the number of bytes needed in szPath
    fUnicode          - If TRUE, szPath should be a UNICODE string on entry
                        and return
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(     struUrl,MAX_PATH );
    STACK_STRU(     struPath,MAX_PATH );
    HRESULT         hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szPath || ( cbPath == 0 ) );
    DBG_ASSERT( pcbBufferRequired );

    //
    // This is kind of a weird function - the return string
    // gets copied over the top of the source string.
    //

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szPath );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szPath );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = W3_STATE_URLINFO::MapPath(
        _pW3Context,
        struUrl,
        &struPath,
        NULL,
        NULL,
        NULL
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    *pcbBufferRequired = cbPath;

    if ( fUnicode )
    {
        return struPath.CopyToBuffer( (LPWSTR)szPath, pcbBufferRequired );
    }
    else
    {
        STACK_STRA (straPath, MAX_PATH );

        if (FAILED(hr = straPath.CopyW(struPath.QueryStr(),
                                       struPath.QueryCCH())))
        {
            return hr;
        }

        return straPath.CopyToBuffer( (LPSTR)szPath, pcbBufferRequired );
    }
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::MapPathEx(
    BYTE *          szUrl,
    DWORD           cbUrl,
    BYTE *          szPath,
    DWORD           cbPath,
    DWORD *         pcbBufferRequired,
    DWORD *         pcchMatchingPath,
    DWORD *         pcchMatchingUrl,
    DWORD *         pdwFlags,
    BOOL            fUnicode
    )
/*++

Routine Description:

    Does path mapping, plus a bit more

Arguments:
    
    szUrl             - The URL to map
    szPath            - Upon return, the physical path for the URL
    cbPath            - The size of szPath
    pcbBufferRequired - Upon failed return, the size needed for szPath
    pcchMatchingPath  - Upon return, the number of characters in szPath
                        that correspond to the vroot in the URL
    pcchMatchingUrl   - Upon return, the number of characters in szUrl
                        that correspond to the vroot in the URL
    pdwFlags          - Upon return, the metadata AccessPerm flags for the URL
    fUnicode          - If TRUE, the caller wants to talk UNICODE
  
Return Value:

    HRESULT

--*/
{
    STACK_STRU( struUrl,MAX_PATH );
    STACK_STRU( struPath,MAX_PATH );
    DWORD       cbPathCopied;
    HRESULT     hr;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szUrl );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szUrl );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Call W3_STATE_URLINFO::MapPath to do the work
    //

    hr = W3_STATE_URLINFO::MapPath(
        _pW3Context,
        struUrl,
        &struPath,
        pcchMatchingPath,
        pcchMatchingUrl,
        pdwFlags
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // W3_STATE_URLINFO::MapPath works by looking for a cache entry
    // for the requested szUrl.  If it exists, the returned information
    // will come from the cache data.  This causes a potential problem
    // if the cache contains a URL as "/foo/" and the caller to this
    // function passes "/foo" as the URL.  In this case, *pcchMatchingUrl
    // will be 5, as it's derived from the cache data.  It would be bad,
    // though, to pass a *pcchMatchingUrl greater than the length of the
    // szUrl we were given...
    //

    if ( fUnicode )
    {
        if ( *pcchMatchingUrl &&
            ( ( ((LPWSTR)szUrl)[*pcchMatchingUrl - 1] == L'\0' ) ||
              ( ((LPWSTR)szUrl)[*pcchMatchingUrl - 1] == L'/' ) ) )
        {
            (*pcchMatchingUrl)--;
        }
    }
    else
    {
        if ( *pcchMatchingUrl &&
            ( ( szUrl[*pcchMatchingUrl - 1] == '\0' ) ||
              ( szUrl[*pcchMatchingUrl - 1] == '/' ) ) )
        {
            (*pcchMatchingUrl)--;
        }
    }

    if ( pcbBufferRequired )
    {
        if ( fUnicode )
        {
            *pcbBufferRequired = (struPath.QueryCCH() + 1) * sizeof(WCHAR);
        }
        else
        {
            *pcbBufferRequired = struPath.QueryCCH() + 1;
        }
    }

    if ( szPath )
    {
        if ( fUnicode )
        {
            cbPathCopied = cbPath;

            hr = struPath.CopyToBuffer( (LPWSTR)szPath, &cbPathCopied );

            if ( hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) &&
                 cbPath >= sizeof(WCHAR) )
            {
                //
                // Copy what we can
                //

                memset( szPath, 0, cbPath );
                memcpy( szPath, struPath.QueryStr(), cbPath - sizeof(WCHAR) );
            }

        }
        else
        {
            //
            // Convert the path to ANSI
            //

            STRA  strAnsiPath;
            
            if ( FAILED( strAnsiPath.Resize( struPath.QueryCCH() + 1 ) ) )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }
            else
            {
                if ( !WideCharToMultiByte(
                    CP_ACP,
                    0,
                    struPath.QueryStr(),
                    -1,
                    strAnsiPath.QueryStr(),
                    struPath.QueryCCH() + 1,
                    NULL,
                    NULL
                    ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                else
                {
                    cbPathCopied = cbPath;
                    strAnsiPath.SetLen( struPath.QueryCCH() );

                    hr = strAnsiPath.CopyToBuffer(
                        (LPSTR)szPath,
                        &cbPathCopied
                        );

                    if ( hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) &&
                         cbPath >= sizeof(CHAR) )
                    {
                        //
                        // Copy what we can
                        //

                        memset( szPath, 0, cbPath );
                        memcpy( szPath, strAnsiPath.QueryStr(), cbPath - sizeof(CHAR) );
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::TransmitFile(
    DWORD64         IsaContext,
    DWORD_PTR       hFile,
    DWORD64         cbOffset,
    DWORD64         cbWrite,
    LPSTR           szStatusCode,
    BYTE *          pHead,
    DWORD           cbHead,
    BYTE *          pTail,
    DWORD           cbTail,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Transmits a file to the client

Arguments:

    IsaContext   - The ISAPI_CONTEXT for this request (opaque)
    hFile        - Handle to file (requires FILE_FLAG_SEQUENTIAL_SCAN)
    cbOffset     - Offset in file to begin transmitting
    cbWrite      - The number of bytes to transmit
    szStatusCode - HTTP status to return (ie "200 OK")
    pHead        - Bytes to send before file data
    cbHead       - The size of pHead
    pTail        - Bytes to send after file data
    cbTail       - The size of pTail
    dwFlags      - HSE_IO_* flags from the caller
    
Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    W3_RESPONSE *       pResponse;
    CHAR                szDefaultStatus[] = "200 Ok";
    DWORD               dwW3Flags;
    BOOL                fSendAsResponse;
    URL_CONTEXT *       pUrlContext;
    WCHAR *             pszPhysicalPath;
    HRESULT             hr;

    //
    // The only current caller for this function is w3isapi.dll, which does
    // parameter validation from any outside code.  So, we can get away with
    // just asserting here.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( IsaContext );
    DBG_ASSERT( cbHead == 0 || pHead != NULL );
    DBG_ASSERT( cbTail == 0 || pTail != NULL );
    DBG_ASSERT( (HANDLE)hFile != INVALID_HANDLE_VALUE );
    DBG_ASSERT( dwFlags & HSE_IO_ASYNC );
    DBG_REQUIRE( pResponse = _pW3Context->QueryResponse() );
    DBG_REQUIRE( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() );

    DBG_ASSERT( _IsapiContext == 0 );
    _IsapiContext = IsaContext;

    //
    // If the caller is OOP, then make copies
    // of the file handle, head data and tail data.  We
    // don't need to make a copy of the status because
    // the BuildResponseFromIsapi function does that itself.
    //

    if ( _fIsOop )
    {
        if ( hFile != NULL )
        {
            hr = pW3IsapiHandler->DuplicateWamProcessHandleForLocalUse(
                (HANDLE)hFile, &_hTfFile
                );

            if ( FAILED( hr ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto ErrorExit;
            }

            hFile = (DWORD_PTR)_hTfFile;
        }

        if ( pHead )
        {
            _pTfHead = (LPBYTE)LocalAlloc( LPTR, cbHead );

            if ( !_pTfHead )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto ErrorExit;
            }

            memcpy( _pTfHead, pHead, cbHead );

            pHead = _pTfHead;
        }

        if ( pTail )
        {
            _pTfTail = (LPBYTE)LocalAlloc( LPTR, cbTail );

            if ( !_pTfTail )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto ErrorExit;
            }

            memcpy( _pTfTail, pTail, cbTail );

            pTail = _pTfTail;
        }
    }

    //
    // Convert the HSE_IO_* flags to W3_FLAG_* flags
    //

    // Init the flags for sending
    dwW3Flags = W3_FLAG_ASYNC | W3_FLAG_MORE_DATA;

    // If disconnect flag is not set, then we'll keep the connection open
    if ( !( dwFlags & HSE_IO_DISCONNECT_AFTER_SEND ) )
    {
        _pW3Context->SetDisconnect( FALSE );
    }
    
    //
    // Clear any previous chunks from the response
    //

    pResponse->Clear();

    //
    // If HSE_IO_SEND_HEADERS is specified, then we're sending
    // the initial part of the response (and pHead will be an
    // LPSTR containing the headers that the caller wants to
    // send), else we'll be sending this data completely as
    // entity data.
    //

    fSendAsResponse = !!( dwFlags & HSE_IO_SEND_HEADERS );

    if ( fSendAsResponse )
    {
        //
        // Set the status using data from the caller
        //
        
        hr = pResponse->BuildResponseFromIsapi( _pW3Context,
                                                szStatusCode,
                                                (LPSTR)pHead,
                                                cbHead );
        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    
        //
        // Is the status is access denied, then set the sub status to 
        // "Denied by Application"
        // 
    
        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Application );
        }
    }
    else
    {
        //
        // Do something with pHead if provided
        //

        if ( cbHead )
        {
            hr = pResponse->AddMemoryChunkByReference(
                    pHead,
                    cbHead
                );

            if ( FAILED( hr ) )
            {
                goto ErrorExit;
            }
        }
    }

    //
    // Now add the file handle to the response.  Note that it's
    // allowed for the caller to pass a NULL handle.  In that case,
    // we won't add it, and any present pHead and pTail will still
    // get sent to the client.
    //

    if ( hFile )
    {
        hr = pResponse->AddFileHandleChunk(
                (HANDLE)hFile,
                cbOffset,
                cbWrite
                );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    }

    //
    // Add the tail if provided
    //

    if ( cbTail )
    {
        hr = pResponse->AddMemoryChunkByReference(
            pTail,
            cbTail
            );

        if ( FAILED( hr ) )
        {
            goto ErrorExit;
        }
    }

    //
    // Ok, now that the stuff is all set up, send it, either
    // as a response or as entity
    //

    if ( _fIsOop )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    if ( fSendAsResponse )
    {
        hr = _pW3Context->SendResponse( dwW3Flags | W3_FLAG_NO_ERROR_BODY );
    }
    else
    {
        hr = _pW3Context->SendEntity( dwW3Flags );
    }

    if ( FAILED( hr ) )
    {
        if ( _fIsOop )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }

        goto ErrorExit;
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    if ( _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _fIsOop )
    {
        if ( _hTfFile != NULL && _hTfFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( _hTfFile );
            _hTfFile = INVALID_HANDLE_VALUE;
        }

        if ( _pTfHead )
        {
            LocalFree( _pTfHead );
            _pTfHead = NULL;
        }

        if ( _pTfTail )
        {
            LocalFree( _pTfTail );
            _pTfTail = NULL;
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SetConnectionClose(
    BOOL    fClose
    )
/*++

Routine Description:

    Sets the W3_CONTEXT to close (or not) connection
    upon completion of the response.

Arguments:

    fClose - BOOL to pass to SetDisconnect
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    _pW3Context->SetDisconnect( fClose );

    return NOERROR;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendRedirect(
    LPCSTR          szLocation
    )
/*++

Routine Description:

    Sends a 302 redirect message to the client

Arguments:

    szLocation - The URL to redirect to.
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA(     strLocation, MAX_PATH );
    HTTP_STATUS httpStatus = { 302, REASON("Object Moved") };
    HRESULT         hr;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szLocation );

    //
    // Use W3_CONTEXT::SetupHttpRedirect to build the redirect
    // response.
    //

    hr = strLocation.Copy( szLocation );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    _pW3Context->SetDisconnect( FALSE );

    hr = _pW3Context->SetupHttpRedirect(
        strLocation,
        FALSE,   // Don't include the original query string
        httpStatus
        );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Now send the response synchronously (the calling ISAPI might
    // do something silly like send more data after this function
    // returns, so we can't do it asynchronously.)
    //

    return _pW3Context->SendResponse(
        W3_FLAG_SYNC | W3_FLAG_MORE_DATA | W3_FLAG_GENERATE_CONTENT_LENGTH
        );
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetCertificateInfoEx( 
    DWORD           cbAllocated,
    DWORD *         pdwCertEncodingType,
    BYTE *          pbCertEncoded,
    DWORD *         pcbCertEncoded,
    DWORD *         pdwCertificateFlags
    )
/*++

Routine Description:

    Gets certificate info

Arguments:

    cbAllocated         - The size of the pbCertEncoded buffer
    pdwCertEncodingType - Upon return, the cert encoding type
    pbCertEncoded       - Upon return, contains the cert info
    pcbCertEncoded      - Upon successful return, the number of bytes
                          in pbCertEncoded.  On failed return, the number
                          of bytes required to contain pbCertEncoded
    pdwCertificateFlags - Upon return, the certificate flags
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    return _pW3Context->GetCertificateInfoEx( cbAllocated,
                                              pdwCertEncodingType,
                                              pbCertEncoded,
                                              pcbCertEncoded,
                                              pdwCertificateFlags );
}
    
HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::AppendLog( 
    LPSTR           szExtraParam
    )
/*++

Routine Description:

    Append the string to the querystring logged

Arguments:

    szExtraParam - the string to be appended
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    //
    // The only current caller for this function is w3isapi.dll,
    // which validates the parameters.
    //

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );

    STRA &strLogParam = _pW3Context->QueryMainContext()
                            ->QueryLogContext()->m_strLogParam;
    if (strLogParam.IsEmpty())
    {
        STACK_STRU (strQueryString, 128);

        if (FAILED(hr = _pW3Context->QueryRequest()->GetQueryStringA(&strLogParam)))
        {
            return hr;
        }
    }

    return strLogParam.Append(szExtraParam);
}
    
HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::ExecuteUrl( 
    DWORD64         IsaContext,
    EXEC_URL_INFO * pExecUrlInfo
    )
/*++

Routine Description:

    Execute a child request

Arguments:

    ISaContext   - The ISAPI_CONTEXT for this request (opaque)
    pExecUrlInfo - Description of request to execute
    
Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *      pIsapiHandler = NULL;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fAsync;
    BYTE *                  pbOriginalEntity = NULL;

    //
    // The parameters (i.e. HSE_EXEC_URL_INFO structure) was validated on
    // the W3ISAPI.DLL side, so we can make assumptions about validity
    //    

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( pExecUrlInfo != NULL );
    DBG_ASSERT( _pW3Context );
    
    DBG_REQUIRE( pIsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() );

    fAsync = pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_ASYNC ? TRUE : FALSE;

    DBG_ASSERT( fAsync == !!IsaContext );

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }
    
    //
    // If we're OOP, we need to dup the user token (if there) and the
    // entity body (if there and this is async request)
    //
   
    if ( _fIsOop )
    {
        //
        // Duplicate the user token if there
        //
        
        if ( pExecUrlInfo->pUserInfo != NULL &&
             pExecUrlInfo->pUserInfo->hImpersonationToken != NULL )
        {
            DBG_ASSERT( _hExecUrlToken == NULL );
            
            hr = pIsapiHandler->DuplicateWamProcessHandleForLocalUse( 
                            (HANDLE) pExecUrlInfo->pUserInfo->hImpersonationToken,
                            &_hExecUrlToken );
            if ( FAILED( hr ) )
            {
                goto Finished;
            } 
            
            pExecUrlInfo->pUserInfo->hImpersonationToken = reinterpret_cast<DWORD_PTR> (_hExecUrlToken);
        }
        
        //
        // Duplicate the entity buffer if there and this is async request
        //
        
        if ( fAsync &&
             pExecUrlInfo->pEntity != NULL &&
             pExecUrlInfo->pEntity->lpbData != NULL &&
             pExecUrlInfo->pEntity->cbAvailable > 0 )
        {
            DBG_ASSERT( _pbExecUrlEntity == NULL );
            
            _pbExecUrlEntity = LocalAlloc( LMEM_FIXED, 
                                           pExecUrlInfo->pEntity->cbAvailable );
            if ( _pbExecUrlEntity == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
            
            memcpy( _pbExecUrlEntity,
                    pExecUrlInfo->pEntity->lpbData,
                    pExecUrlInfo->pEntity->cbAvailable );

            //
            // Remember the original pointer to entity body.  We must 
            // maintain it on exit so that RPC unmarshalls the correct
            // buffer :-(
            //
            
            pbOriginalEntity = pExecUrlInfo->pEntity->lpbData;
            
            pExecUrlInfo->pEntity->lpbData = (LPBYTE) _pbExecUrlEntity;
        }
    }
    
    //
    // Execute the darn thing
    //

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }
    
    hr = _pW3Context->CleanIsapiExecuteUrl( 
                    reinterpret_cast<HSE_EXEC_URL_INFO*>( pExecUrlInfo ) );
   
    if ( FAILED( hr ) )
    {
        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }
    }

    //
    // If nothing is pending, then we can clean up any dup'd stuff now
    //

Finished:

    if ( FAILED( hr ) &&
         fAsync &&
         _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }
    
    if ( FAILED( hr ) || !fAsync )
    {
        if ( _pbExecUrlEntity != NULL )
        {
            LocalFree( _pbExecUrlEntity );
            _pbExecUrlEntity = NULL;
        }
        
        if ( _hExecUrlToken != NULL )
        {
            CloseHandle( _hExecUrlToken );
            _hExecUrlToken = NULL;
        }
    }
    
    //
    // Regardless of return status, we need to restore the entity pointer
    // if needed so RPC unmarshalls the right thing
    //
    
    if ( pbOriginalEntity != NULL )
    {
        DBG_ASSERT( pExecUrlInfo != NULL );
        DBG_ASSERT( pExecUrlInfo->pEntity != NULL );
        
        pExecUrlInfo->pEntity->lpbData = pbOriginalEntity;
    }
    
    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::SendCustomError(
    DWORD64         IsaContext,
    CHAR *          pszStatus,
    USHORT          uHttpSubError
)
/*++

Routine Description:

    Send a custom error (if available, otherwise error out with 
    ERROR_FILE_NOT_FOUND)

Arguments:

    IsaContext      - The ISAPI_CONTEXT for this request (opaque)
    pszStatus       - Status line
    uHttpSubError   - Sub error
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    BOOL                    fAsync;
    HSE_CUSTOM_ERROR_INFO   customErrorInfo;
    
    DBG_ASSERT( CheckSignature() );

    //
    // If we have a non-NULL IsaContext, then this is an async request
    //

    fAsync = !!IsaContext;

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }
    
    customErrorInfo.pszStatus = pszStatus;
    customErrorInfo.uHttpSubError = uHttpSubError;
    customErrorInfo.fAsync = fAsync;

    hr = _pW3Context->CleanIsapiSendCustomError( &customErrorInfo );
    if ( FAILED( hr ) )
    {
        if ( fAsync && _IsapiContext != 0 )
        {
            _IsapiContext = 0;
        }

        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion
            // will ever happen.
            //

            Release();
        }
    }

    return hr;
}
    
HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetExecuteUrlStatus( 
    USHORT *        pChildStatusCode,
    USHORT *        pChildSubErrorCode,
    DWORD *         pChildWin32Error
    )
/*++

Routine Description:

    Get the status of the last child execute

Arguments:

    pChildStatusCode   - Filled with status code of child execute
    pChildSubErrorCode - Filled sub error if applicable
    pChildWin32Error   - Filled last Win32 saved for child request
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context != NULL );
    
    _pW3Context->QueryChildStatusAndError( pChildStatusCode,
                                           pChildSubErrorCode,
                                           pChildWin32Error );
        
    return NO_ERROR;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::VectorSend(
    DWORD64         IsaContext,
    BOOL            fDisconnect,
    LPSTR           pszStatus,
    LPSTR           pszHeaders,
    VECTOR_ELEMENT *pElements,
    DWORD           nElementCount
    )
/*++
  Routine description

    Do a vector send of multiple file handle/memory chunks

  Parameters

    IsaContext      - The ISAPI_CONTEXT for this request (opaque)
    fDisconnect     - Do we disconnect after send
    pszStatus       - The status to be sent if any
    pszHeaders      - The headers to be sent if any
    pElements       - The file handle/memory chunks to be sent
    nElementCount   - The number of these chunks

  Return value

    HRESULT
--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    HRESULT             hr = S_OK;
    DWORD               cchHeaders = 0;
    W3_RESPONSE *       pResponse;
    BOOL                fAsync;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( pResponse = _pW3Context->QueryResponse() );
    DBG_REQUIRE( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() );

    //
    // A non-NULL context indicates async request
    //

    fAsync = !!IsaContext;

    if ( fAsync )
    {
        DBG_ASSERT( _IsapiContext == 0 );
        _IsapiContext = IsaContext;
    }

    if (pszHeaders != NULL)
    {
        cchHeaders = strlen(pszHeaders);
    }

    if ( _fIsOop )
    {
        //
        // Need to make copies of the file handles and maybe even memory buffer
        //
        if ( fAsync && pszHeaders )
        {
            _pTfHead = (LPBYTE)LocalAlloc(LMEM_FIXED, cchHeaders + 1 );

            if ( _pTfHead == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
                goto Exit;
            }

            memcpy( _pTfHead, pszHeaders, cchHeaders + 1 );

            pszHeaders = (LPSTR)_pTfHead;
        }

        if (!_bufVectorElements.Resize(nElementCount * sizeof(VECTOR_ELEMENT)))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }
        ZeroMemory(_bufVectorElements.QueryPtr(),
                   nElementCount * sizeof(VECTOR_ELEMENT));

        VECTOR_ELEMENT *pNewElements = (VECTOR_ELEMENT *)_bufVectorElements.QueryPtr();

        for (int i=0; i<nElementCount; i++)
        {
            if (pElements[i].hFile)
            {
                hr = pW3IsapiHandler->DuplicateWamProcessHandleForLocalUse(
                                        (HANDLE)pElements[i].hFile,
                                        (HANDLE *)&pNewElements[i].hFile);
                if (FAILED(hr))
                {
                    goto Exit;
                }
                pNewElements[i].cbOffset = pElements[i].cbOffset;
                pNewElements[i].cbFileSize = pElements[i].cbFileSize;
            }
            else
            {
                if (fAsync)
                {
                    //
                    // Need to copy the buffer too
                    //
                    pNewElements[i].pBuffer = (BYTE *)LocalAlloc(LMEM_FIXED, pElements[i].cbBufSize);
                    if (pNewElements[i].pBuffer == NULL)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        goto Exit;
                    }

                    memcpy(pNewElements[i].pBuffer,
                           pElements[i].pBuffer,
                           pElements[i].cbBufSize);
                }
                else
                {
                    pNewElements[i].pBuffer = pElements[i].pBuffer;
                }

                pNewElements[i].cbBufSize = pElements[i].cbBufSize;
            }

            _nElementCount++;
        }

        pElements = pNewElements;
    }

    //
    // First Clear any goo left from a previous Send
    //
    pResponse->Clear();

    _pW3Context->SetDisconnect(fDisconnect);

    //
    // Now do the real work
    //
    if (pszStatus != NULL)
    {
        hr = pResponse->BuildResponseFromIsapi( _pW3Context,
                                                pszStatus,
                                                pszHeaders,
                                                cchHeaders );
        if (FAILED(hr))
        {
            goto Exit;
        }

        //
        // Is the status is access denied, then set the sub status to 
        // "Denied by Application"
        // 
    
        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Application );
        }
    }

    for (int i=0; i<nElementCount; i++)
    {
        if (pElements[i].hFile)
        {
            hr = pResponse->AddFileHandleChunk((HANDLE)pElements[i].hFile,
                                               pElements[i].cbOffset,
                                               pElements[i].cbFileSize);
        }
        else
        {
            hr = pResponse->AddMemoryChunkByReference(pElements[i].pBuffer,
                                                      pElements[i].cbBufSize);
        }

        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    if ( _fIsOop && fAsync )
    {
        //
        // This reference insures that if the OOP host crashes and
        // COM releases all the OOP-held references, that this
        // object will survive until the I/O completion occurs.
        //

        AddRef();
    }

    if (pszStatus != NULL)
    {
        hr = _pW3Context->SendResponse( (fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC) 
                                        | W3_FLAG_MORE_DATA 
                                        | W3_FLAG_NO_ERROR_BODY );
    }
    else
    {
        hr = _pW3Context->SendEntity( fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC );
    }

    if (FAILED(hr))
    {
        if ( _fIsOop && fAsync )
        {
            //
            // Release the above reference, since no I/O completion will
            // occur.
            //

            Release();
        }
    }

 Exit:

    if ( FAILED( hr ) && fAsync && _IsapiContext != 0 )
    {
        _IsapiContext = 0;
    }

    if ( _fIsOop &&
        (FAILED(hr) || !fAsync) )
    {
        //
        // Need to destroy handles/memory buffers we copied
        //
        if ( _pTfHead )
        {
            LocalFree( _pTfHead );
            _pTfHead = NULL;
        }

        for (int i=0; i<_nElementCount; i++)
        {
            if (pElements[i].hFile)
            {
                CloseHandle((HANDLE)pElements[i].hFile);
            }
            else if (fAsync)
            {
                LocalFree(pElements[i].pBuffer);
            }
        }

        _nElementCount = 0;
    }

    return hr;
}

HRESULT
ISAPI_REQUEST::GetCustomError(
        DWORD dwError,
        DWORD dwSubError,
        DWORD dwBufferSize,
        BYTE  *pvBuffer,
        DWORD *pdwRequiredBufferSize,
        BOOL  *pfIsFileError)

/*++

Routine Description:

    Finds the CustomError for this error and subError.  The results are returned
    in pvBuffer provided there is enough buffer space.  The amount of buffer space
    required is returned in pdwRequestBufferSize regardless.

Arguments:


    dwError                 - major error (e.g. 500)
    dwSubError              - sub error (e.g. 13)
    dwBufferSize            - size, in bytes, of buffer at pvBuffer
    pvBuffer                - pointer to buffer for result
    pdwRequiredBufferSize   - amount of buffer used/need
    pfIsFileError           - return boolean if custom error is a filename

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;
    W3_METADATA     *pMetadata = NULL;
    LPSTR           pMimeStr = "text/html";
    
    STACK_STRA(mimeStr, 64);

    STACK_STRU(             strError, 64 );

    DBG_ASSERT( CheckSignature() );

    // first dig out the W3 Metadata pointer

    pMetadata = _pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetadata != NULL );

    // get the custom error for this error code

    hr = pMetadata->FindCustomError( dwError,
                                     dwSubError,
                                     pfIsFileError,
                                     &strError );

    // if successful, and the custom error is a file, we need to
    // get the file's mime type

    if (SUCCEEDED(hr) && *pfIsFileError) {

        // lookup the MIME_ENTRY for this file.

        if (SUCCEEDED(SelectMimeMappingForFileExt(strError.QueryStr(),pMetadata->QueryMimeMap(), &mimeStr))) {
            pMimeStr = mimeStr.QueryStr();
        }
    }

    // if found, convert the UNICODE string to ANSI

    if (SUCCEEDED(hr)) {

        int ret;

        ret = WideCharToMultiByte(CP_ACP,
                                  0,
                                  strError.QueryStr(),
                                  -1,
                                  (LPSTR)pvBuffer,
                                  dwBufferSize,
                                  NULL,
                                  NULL);

        *pdwRequiredBufferSize = ret;

        // check return.  If zero, then the conversion failed.  
        // GetLastError() contains the error.

        if (ret == 0) {

            DWORD   winError = GetLastError();
        
            // if InsufBuff, then call again to get the required size

            if (winError == ERROR_INSUFFICIENT_BUFFER) {

                *pdwRequiredBufferSize = WideCharToMultiByte(CP_ACP,
                                                             0,
                                                             strError.QueryStr(),
                                                             -1,
                                                             NULL,
                                                             0,
                                                             NULL,
                                                             NULL);

                // if the error is a filename, then include in the required
                // buffer size the length of the mime string

                if (*pfIsFileError) {

                    *pdwRequiredBufferSize += strlen(pMimeStr) + 1;
                }
            }
            // in any case, make a HRESULT from the win32 error and return that

            hr = HRESULT_FROM_WIN32(winError);
        }

        // if we continue to be successful, the next step is to put
        // the mime string after the null byte of the file name

        if (SUCCEEDED(hr) && *pfIsFileError) {

            int fileLen = strlen((char *)pvBuffer);

            // make sure we have enough buffer

            if ((fileLen + strlen(pMimeStr) + 2) > dwBufferSize) {

                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            else {
                
                // looks like we do.  Copy the mime string in

                strcpy(&((char *)pvBuffer)[fileLen+1],pMimeStr);

                pdwRequiredBufferSize += strlen(pMimeStr) + 1;
            }
        }
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::TestConnection(
    BOOL    *pfIsConnected
    )
/*++

Routine Description:

    returns state of the connection (TRUE = opened, FALSE = closed)

Arguments:

    pfIsConnected - sets to TRUE if connection is still open, 
                    FALSE if it was closed already
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NOERROR;
    W3_CONNECTION *     pConnection = NULL;
    W3_MAIN_CONTEXT *   pMainContext = NULL;
    
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( _pW3Context != NULL );
    pMainContext = _pW3Context->QueryMainContext();
    
    DBG_ASSERT( pMainContext != NULL );
    pConnection = pMainContext->QueryConnection( TRUE );

    if ( pConnection == NULL )
    {
        //
        // Issue 02/08/2001 jaroslad:
        // QueryConnection currently doesn't have a way to return
        // error that occured. For now assume that out of memory
        // occured
        //
        
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

        //
        // we will not touch pfIsConnected in the case of error
        // it is caller's responsibility to check if this call
        // succeeded before using pfIsConnected
        //
    }
    else
    {
        *pfIsConnected =  pConnection->QueryConnected();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::GetSspiInfo( 
    BYTE *pCredHandle,
    DWORD cbCredHandle,
    BYTE *pCtxtHandle,
    DWORD cbCtxtHandle)
/*++

Routine Description:

    Returns SSPI info about the request

Arguments:

    pCredHandle  - Upon return, contains the credential handle
    cbCredHandle - The size of pCredHandle
    pCtxtHandle  - Upon return, contains the context handle
    cbCtxtHandle - The size of pCtxtHandle
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_USER_CONTEXT *       pUserContext;
    
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context != NULL );

    if ( _fIsOop )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    pUserContext = _pW3Context->QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );
    
    return pUserContext->GetSspiInfo( pCredHandle,
                                      cbCredHandle,
                                      pCtxtHandle,
                                      cbCtxtHandle );
}

HRESULT STDMETHODCALLTYPE
ISAPI_REQUEST::QueryVrToken( 
    BYTE *szUrl,
    DWORD cbUrl,
    DWORD64 *pToken,
    BOOL fUnicode)
/*++

Routine Description:

    Returns the VR token for the request

Arguments:

    szUrl     - The URL for which we need to get the token
    cbUrl     - The size of szUrl
    pToken    - Upon return, points to the resulting token
    fUnicode  - If TRUE, szUrl is UNICODE, else it's ANSI
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(         struUrl,MAX_PATH );
    W3_URL_INFO *       pUrlInfo = NULL;
    W3_METADATA *       pMetaData = NULL;
    TOKEN_CACHE_ENTRY * pTokenEntry = NULL;
    HANDLE              hToken = NULL;
    HANDLE              hTokenLocalDuplicate = NULL;
    HRESULT             hr;
    BOOL                fSuccess;

    DBG_ASSERT( _pW3Context );
    DBG_ASSERT( szUrl );
    DBG_ASSERT( pToken );

    //
    // Get the metadata for the specified URL
    //

    if ( fUnicode )
    {
        hr = struUrl.Copy( (LPWSTR)szUrl );
    }
    else
    {
        hr = struUrl.CopyA( (LPSTR)szUrl );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );
    
    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( 
                                        _pW3Context,
                                        struUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pUrlInfo != NULL );

    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Assume that the VR token is NULL, unless we can determine otherwise
    //

    *pToken = NULL;

    //
    // Ok, so now let's get the VrAccessToken
    //

    if ( pMetaData->QueryVrAccessToken() != NULL )
    {
        hToken = pMetaData->QueryVrAccessToken()->QueryImpersonationToken();
    }

    if ( hToken )
    {
        //
        // Need to duplicate the handle.  This is really only necessary for
        // OOP requests, but we need to do it for both, so that the extension
        // doesn't need to worry about knowing if it's inproc or not before
        // deciding if it needs to close the handle.
        //

        fSuccess = DupTokenWithSameImpersonationLevel( 
            hToken,
            MAXIMUM_ALLOWED,
            TokenPrimary,
            &hTokenLocalDuplicate
            );
 
        if( fSuccess )
        {
            if( _fIsOop )
            {
                HANDLE  hTokenRemote = NULL;

                fSuccess = DuplicateHandle(
                                GetCurrentProcess(),
                                hTokenLocalDuplicate,
                                _pWamProcess->QueryProcess(),
                                &hTokenRemote,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

                CloseHandle(hTokenLocalDuplicate);
                hTokenLocalDuplicate = NULL;

                *pToken = (DWORD64)hTokenRemote;
            }
            else
            {
                *pToken = reinterpret_cast<DWORD64>(hTokenLocalDuplicate);
            }
        }
    }

    pUrlInfo->DereferenceCacheEntry();

    return hr;
}

HRESULT
ISAPI_REQUEST::PreprocessIoCompletion(
    DWORD   cbIo
    )
/*++

Routine Description:

    Handles cleanup for any functions that use fCopiedData=TRUE.

    In the case of a TransmitFile or WriteClient, this just
    involves closing handles and freeing buffers.  In the case
    of ReadClient, we need to push the read buffer to the OOP
    process.

Arguments:

    cbIo - The number of bytes in a read buffer, if present
    
Return Value:

    HRESULT

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    HRESULT             hr = NOERROR;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() );

    //
    // Cleanup any existing TF info, since we're done with it.
    //

    if ( _hTfFile != NULL && _hTfFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hTfFile );
        _hTfFile = INVALID_HANDLE_VALUE;
    }

    if ( _pTfHead )
    {
        LocalFree( _pTfHead );
        _pTfHead = NULL;
    }

    if ( _pTfTail )
    {
        LocalFree( _pTfTail );
        _pTfTail = NULL;
    }

    //
    // Cleanup any existing async write buffer
    //

    if ( _pAsyncWriteBuffer )
    {
        LocalFree( _pAsyncWriteBuffer );
        _pAsyncWriteBuffer = NULL;
    }

    //
    // If we have an async read buffer, then push the data
    // to the WAM process and free it
    //

    if ( _pAsyncReadBuffer )
    {
        hr = pW3IsapiHandler->MarshalAsyncReadBuffer(
            _IsapiContext,
            _pAsyncReadBuffer,
            cbIo
            );

        //
        // Note that the above function could fail if, for
        // example, the dllhost has crashed.  There's not
        // anything we can do about it here, though.  We'll
        // ignore it.
        //

        LocalFree( _pAsyncReadBuffer );
        _pAsyncReadBuffer = NULL;
    }
    
    //
    // Clean up HSE_EXEC_URL stuff
    //
    
    if ( _pbExecUrlEntity != NULL )
    {
        LocalFree( _pbExecUrlEntity );
        _pbExecUrlEntity = NULL;
    }
    
    if ( _hExecUrlToken != NULL )
    {
        CloseHandle( _hExecUrlToken );
        _hExecUrlToken = NULL;
    }

    //
    // Need to destroy handles/memory buffers we copied for vector send
    //
    VECTOR_ELEMENT *pElements = (VECTOR_ELEMENT *)_bufVectorElements.QueryPtr();
    for (int i=0; i<_nElementCount; i++)
    {
        if (pElements[i].hFile)
        {
            CloseHandle((HANDLE)pElements[i].hFile);
        }
        else
        {
            LocalFree(pElements[i].pBuffer);
        }
    }

    _nElementCount = 0;

    return hr;
}

ISAPI_REQUEST::~ISAPI_REQUEST()
/*++

Routine Description:

    Destructor

Arguments:

    None
    
Return Value:

    None

--*/
{
    W3_ISAPI_HANDLER *  pW3IsapiHandler;
    BOOL    fResult;
    
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pW3Context );
    DBG_REQUIRE( pW3IsapiHandler = (W3_ISAPI_HANDLER*)_pW3Context->QueryHandler() );

    _dwSignature = ISAPI_REQUEST_SIGNATURE_FREE;

    //
    // Release the free threaded marshaler
    //

    if ( _pUnkFTM )
    {
        _pUnkFTM->Release();
        _pUnkFTM = NULL;
    }

    //
    // Dissociate ourselves from the WAM_PROCESS, if present
    //

    if ( _pWamProcess )
    {
        _pWamProcess->DecrementRequestCount();

        _pWamProcess->Release();
        _pWamProcess = NULL;
    }

    //
    // Notify the W3_ISAPI_HANDLER that we are done with it
    //

    pW3IsapiHandler->IsapiRequestFinished();

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "ISAPI_REQUEST %p has been destroyed.\r\n",
            this
            ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\maincontext.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     maincontext.cxx

   Abstract:
     Drive the state machine
 
   Author:
     Bilal Alam (balam)             10-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "sspiprovider.hxx"
#include "basicprovider.hxx"
#include "servervar.hxx"

//
// Global alloc cache and context list 
//

ALLOC_CACHE_HANDLER *    W3_MAIN_CONTEXT::sm_pachMainContexts = NULL;
W3_STATE *               W3_MAIN_CONTEXT::sm_pStates[ STATE_COUNT ];
SHORT                    W3_MAIN_CONTEXT::sm_rgInline[ STATE_COUNT ];
USHORT                   W3_MAIN_CONTEXT::sm_cbInlineBytes = 0;
LONG                     W3_MAIN_CONTEXT::sm_cOutstandingThreads = 0;
DWORD                    W3_MAIN_CONTEXT::sm_dwTimeout = 0;

VOID
W3_MAIN_CONTEXT::DoWork(
    DWORD                cbCompletion,
    DWORD                dwCompletionStatus,
    BOOL                 fIoCompletion
)
/*++

Routine Description:

    Drives the W3 state machine

Arguments:

    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    fIoCompletion - TRUE if this was an IO completion,
                    FALSE if this was a new request completion

Return Value:

    None

--*/
{
    CONTEXT_STATUS         Status = CONTEXT_STATUS_CONTINUE;
    BOOL                   fLastState = FALSE;
    W3_CONTEXT *           pCurrentContext = NULL;

    if (fIoCompletion)
    {
        if (QueryLastIOPending() == LOG_WRITE_IO)
        {
            _LogContext.m_dwBytesSent += cbCompletion;
        }
        else if (QueryLastIOPending() == LOG_READ_IO)
        {
            _LogContext.m_dwBytesRecvd += cbCompletion;

            if ( _cbRemainingEntityFromUL != INFINITE )
            {
                if ( _cbRemainingEntityFromUL >= cbCompletion )
                {
                    _cbRemainingEntityFromUL -= cbCompletion;
                }
                else
                {
                    _cbRemainingEntityFromUL = 0;
                }
            }
        }
    }

    //
    // Progress thru states until we are finished or a state operation
    // is performed asynchronously
    //

    while ( !fLastState )
    {
        W3_STATE *              pState;

        //
        // Get the next function to call, and then call it
        //

        pState = sm_pStates[ _currentState ];
        DBG_ASSERT( pState != NULL );

        //
        // Manage the _nextState which indicates what the next state will be
        // if the DoWork() returns CONTEXT_STATUS_CONTINUE.  Note that this
        // state can be overriden by W3_MAIN_CONTEXT::SetFinishedResponse 
        //

        _nextState = _currentState + 1;

        //
        // If this is the last state, remember that so we can cleanup
        //

        if ( _currentState == CONTEXT_STATE_DONE )
        {
            fLastState = TRUE;
        }

        if ( !fIoCompletion )
        {
            Status = pState->DoWork( this,
                                     cbCompletion,
                                     dwCompletionStatus );
        }
        else
        {
            pCurrentContext = QueryCurrentContext();

            //
            // First try to complete handler contexts if any.  
            //

            Status = pCurrentContext->ExecuteHandlerCompletion(
                                                 cbCompletion,
                                                 dwCompletionStatus );

            if ( Status == CONTEXT_STATUS_CONTINUE )
            {   
                //
                // Excellent.  All handlers for this context have 
                // completed.  Now we finally complete the original
                // state which originally started the async ball rolling
                //

                Status = pState->OnCompletion( this,
                                               cbCompletion,
                                               dwCompletionStatus );
            }

            //
            // Reset fIoCompletion so we can continue the state machine
            // after the completion function is done 
            //
            fIoCompletion = FALSE;

        }
        
        //
        // An async operation was posted, bail immediately
        //

        if ( Status == CONTEXT_STATUS_PENDING )
        {
            return;
        }

        DBG_ASSERT( Status == CONTEXT_STATUS_CONTINUE );

        _currentState = _nextState;
    }

    //
    // If we get here, we must have executed the last state, so cleanup the
    // MAIN_CONTEXT
    //

    DBG_ASSERT( fLastState );
   
    //
    // If we have a raw connection, detach ourselves from it now
    //
    
    if ( _pRawConnection != NULL )
    {
        _pRawConnection->SetMainContext( NULL );
    }
    
    DereferenceMainContext();
}

VOID
W3_MAIN_CONTEXT::BackupStateMachine(
    VOID
)
/*++

Routine Description:

    Backup in state machine to the URL_INFO state.  This should be used only
    by AUTH_COMPLETE filters

Arguments:

    None
    
Return Value:

    None

--*/
{
    URL_CONTEXT *           pUrlContext;
    
    DBG_ASSERT( IsNotificationNeeded( SF_NOTIFY_AUTH_COMPLETE ) );

    //
    // Clear the URL context
    //

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    SetUrlContext( NULL );
    
    delete pUrlContext;
    
    //
    // Reset our access check state.  
    //
    
    ResetAccessCheck();
    
    //
    // Back that state up
    //
    
    _nextState = CONTEXT_STATE_URLINFO;   
}

// static
HRESULT
W3_MAIN_CONTEXT::SetupStateMachine(
    VOID
)
/*++

Routine Description:

    Setup state machine

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    W3_STATE *                  pState = NULL;
    USHORT                      cbContextSize = 0;
    DWORD                       cState = CONTEXT_STATE_START;
    
    //
    // First create all the states
    //
    
    //
    // Start State
    //
     
    pState = (W3_STATE*) new W3_STATE_START();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // URLINFO State
    //
     
    pState = (W3_STATE*) new W3_STATE_URLINFO();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Authentication State
    //
     
    pState = (W3_STATE*) new W3_STATE_AUTHENTICATION();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Authorization State
    //
     
    pState = (W3_STATE*) new W3_STATE_AUTHORIZATION();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Handle Request State
    //
     
    pState = (W3_STATE*) new W3_STATE_HANDLE_REQUEST();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Response State
    //
     
    pState = (W3_STATE*) new W3_STATE_RESPONSE();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Log State
    //
     
    pState = (W3_STATE*) new W3_STATE_LOG();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Done State
    //
     
    pState = (W3_STATE*) new W3_STATE_DONE();
    if ( pState == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    else if ( FAILED( hr = pState->QueryResult() ) )
    {
        goto Failure;
    }
    
    sm_pStates[ cState ] = pState;
    cbContextSize += pState->QueryContextSize();
    //
    // provide space for 8 bit alignment
    //
    cbContextSize = (cbContextSize + 7) & ~7;
    cState++;

    //
    // Keep track of total number of state bytes needed so that we can
    // initialize allocation cache properly
    //

    // throw in 8 more bytes, alignment may cause us to need it
    sm_cbInlineBytes = cbContextSize + 8;
    
    return NO_ERROR;

Failure:

    for ( int i = 0; i < STATE_COUNT; i++ )
    {
        if ( sm_pStates[ i ] != NULL )
        {
            delete sm_pStates[ i ];
            sm_pStates[ i ] = NULL;
        }
    }
    
    return hr;
}

// static
VOID
W3_MAIN_CONTEXT::CleanupStateMachine(
    VOID
)
/*++

Routine Description:

    Cleanup state machine

Arguments:

    None

Return Value:

    None

--*/
{
    for ( int i = CONTEXT_STATE_START;
          i < STATE_COUNT;
          i++ )
    {
        if ( sm_pStates[ i ] != NULL )
        {
            delete sm_pStates[ i ];
            sm_pStates[ i ] = NULL;
        }
    }
}

BOOL
W3_MAIN_CONTEXT::SetupContext(
    HTTP_REQUEST *          pUlHttpRequest,
    ULATQ_CONTEXT           ulatqContext
)
/*++

Routine Description:

    Sets up a MAIN_CONTEXT before executing the state machine for a new
    incoming request.  

Arguments:

    pUlHttpRequest - the HTTP_REQUEST from UL
    ulatqContext - used to send/receive data thru ULATQ

Return Value:

    TRUE if successful, else FALSE

--*/
{   
    memset( _rgStateContexts, 0, sizeof( _rgStateContexts ) );

    //
    // Should we generate a content-length header
    //
    
    if ( pUlHttpRequest->Verb == HttpVerbHEAD )
    {
        _fGenerateContentLength = TRUE;
    }

    //
    // Associate HTTP_REQUEST with W3_REQUEST wrapper
    //

    _request.SetHttpRequest( pUlHttpRequest );

    //
    // Associate context for async IO (if any)
    //

    _ulatqContext = ulatqContext;  

    UlAtqSetContextProperty( _ulatqContext,
                             ULATQ_PROPERTY_COMPLETION_CONTEXT,
                             this );

    //
    // Setup the state machine
    //    

    _currentState = CONTEXT_STATE_START;
    _nextState = CONTEXT_STATE_START;

    //
    // Setup current context to receive IO completions.  Naturally on 
    // startup, this context will be 'this'.  But it can change depending
    // on whether child executes are called
    //

    _pCurrentContext = this;

    return TRUE;
}

W3_CONNECTION_STATE *
W3_MAIN_CONTEXT::QueryConnectionState(
    VOID
)
/*++

Routine Description:

    Get any context associated with this connection and this state.

Arguments:

    None

Return Value:

    A W3_CONNECTION_STATE * or NULL if there is no state

--*/
{
    //
    // Since we are just looking for any existing connection state, make 
    // sure we don't create a connection object if none is already associated
    // (creating a connection object is expensive)
    //
    
    W3_CONNECTION *     pConn = QueryConnection( FALSE );

    return pConn ? pConn->QueryConnectionState( _currentState ) : NULL;
}

VOID
W3_MAIN_CONTEXT::SetConnectionState(
    W3_CONNECTION_STATE *       pConnectionState
)
/*++

Routine Description:

    Set any context to be associated with the connection and current state

Arguments:

    pConnectionState - Context to associate

Return Value:

    None

--*/
{ 
    if ( QueryConnection() )
    {
        QueryConnection()->SetConnectionState( _currentState,
                                               pConnectionState );
    }
}

W3_MAIN_CONTEXT::W3_MAIN_CONTEXT(
    HTTP_REQUEST *          pUlHttpRequest,
    ULATQ_CONTEXT           ulAtqContext
) 
    : W3_CONTEXT            ( 0 ),
      _pSite                ( NULL ),
      _pFilterContext       ( NULL ),
      _fDisconnect          ( FALSE ),
      _fNeedFinalDone       ( FALSE ),
      _fAssociationChecked  ( FALSE ),
      _pConnection          ( NULL ),
      _pUrlContext          ( NULL ),
      _pUserContext         ( NULL ),
      _fProviderHandled     ( FALSE ),
      _cbInlineOffset       ( 0 ),
      _fDoneWithCompression ( FALSE ),
      _pCompressionContext  ( NULL ),
      _fIsUlCacheable       ( TRUE ),
      _pCertificateContext  ( NULL ),
      _cbRemainingEntityFromUL ( 0 ),
      _fGenerateContentLength( FALSE ),
      _pRawConnection       ( NULL ),
      _cRefs                ( 1 ),
      _hTimer               (NULL)
{
    _LogContext.m_msStartTickCount = GetTickCount();

    SetupContext( pUlHttpRequest, ulAtqContext );

    _hTimer = NULL;

    if (sm_dwTimeout)
    {
        BOOL fRet;
        fRet = CreateTimerQueueTimer(&_hTimer,
                                     NULL,
                                     W3_MAIN_CONTEXT::TimerCallback,
                                     this,
                                     sm_dwTimeout,
                                     0,
                                     WT_EXECUTEONLYONCE
                                     );
        DBG_ASSERT(fRet);
    }

}

W3_MAIN_CONTEXT::~W3_MAIN_CONTEXT()
/*++

Routine Description:

    Main context destructor

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Cleanup context state
    //
    
    for ( DWORD i = 0; i < STATE_COUNT; i++ )
    {
        if ( _rgStateContexts[ i ] != NULL ) 
        {
            ((W3_MAIN_CONTEXT_STATE*) _rgStateContexts[ i ])->Cleanup( this );
            _rgStateContexts[ i ] = NULL;
        }
    }
    
    //
    // Let our filter context go
    //
    
    if ( _pFilterContext != NULL )
    {
        _pFilterContext->SetMainContext( NULL );
        _pFilterContext->DereferenceFilterContext();
        _pFilterContext = NULL;
    }
    
    //
    // Let go of reference to associated connection
    //
   
    if ( _pConnection != NULL )
    {
        _pConnection->DereferenceConnection();
        _pConnection = NULL;
    }
    
    //
    // Cleanup URL-Context
    //
    
    if ( _pUrlContext != NULL )
    {
        delete _pUrlContext;
        _pUrlContext = NULL;
    }
    
    //
    // Release our user context
    //
    
    if ( _pUserContext != NULL )
    {
        // perf ctr
        if (_pUserContext->QueryAuthType() == MD_AUTH_ANONYMOUS)
        {
            _pSite->DecAnonUsers();
        }
        else
        {
            _pSite->DecNonAnonUsers();
        }

        _pUserContext->DereferenceUserContext();
        _pUserContext = NULL;
    }

    //
    // Release the compression context
    //
    if ( _pCompressionContext != NULL )
    {
        delete _pCompressionContext;
        _pCompressionContext = NULL;
    }
    
    //
    // Cleanup RDNS crud
    //
    
    _IpAddressCheck.UnbindAddr();

    //
    // Cleanup client certificate context
    //
    
    if ( _pCertificateContext != NULL )
    {
        delete _pCertificateContext;
        _pCertificateContext = NULL;
    }
    
    //
    // Release the raw connection now
    //
    
    if ( _pRawConnection != NULL )
    {
        _pRawConnection->DereferenceRawConnection();
        _pRawConnection = NULL;
    }

    //
    // Allow ULATQ to cleanup itself up and to read the next request
    //

    UlAtqFreeContext( _ulatqContext );
    _ulatqContext = NULL;

    //
    // Finally release the site
    //
    if ( _pSite )
    {
        _pSite->Release();
        _pSite = NULL;
    }

    if (_hTimer)
    {
        BOOL fRet;
        fRet = DeleteTimerQueueTimer(NULL,
                                    _hTimer,
                                    INVALID_HANDLE_VALUE);
        DBG_ASSERT(fRet);
        _hTimer = NULL;
    }

}

// static
HRESULT
W3_MAIN_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_MAIN_CONTEXTs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup global state machine.  We do this BEFORE we setup the 
    // allocation cache because the state machine setup will tell how much
    // inline buffer space is needed for state
    //
    
    hr = SetupStateMachine();
    if ( FAILED( hr ) )
    {
        return hr;
    } 
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_MAIN_CONTEXT ) + sm_cbInlineBytes;

    DBG_ASSERT( sm_pachMainContexts == NULL );
    
    sm_pachMainContexts = new ALLOC_CACHE_HANDLER( "W3_MAIN_CONTEXT",  
                                                   &acConfig );

    if ( sm_pachMainContexts == NULL )
    {
        CleanupStateMachine();
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
        
    sm_dwTimeout = ReadRegDword(HKEY_LOCAL_MACHINE, 
                                REGISTRY_KEY_INETINFO_PARAMETERS_W, 
                                L"RequestTimeoutBreak", 
                                0);

    return NO_ERROR;
}

// static
VOID
W3_MAIN_CONTEXT::WaitForThreadDrain(
    VOID
)
/*++

Routine Description:

    Wait for all threads doing W3CORE stuff to drain away

Arguments:

    None
    
Return Value:

    None

--*/
{
    while ( sm_cOutstandingThreads != 0 )
    {
        Sleep( 200 );
    }
}

// static
VOID
W3_MAIN_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    CleanupStateMachine();

    if ( sm_pachMainContexts != NULL )
    {
        delete sm_pachMainContexts;
        sm_pachMainContexts = NULL;
    }
}

W3_USER_CONTEXT *
W3_MAIN_CONTEXT::QueryConnectionUserContext(
    VOID
)
/*++

Routine Description:

    Get any user context associated with this connection

Arguments:

    None

Return Value:

    Pointer to W3_USER_CONTEXT (or NULL if no used associated)

--*/
{
    W3_CONNECTION *         pConnection = NULL;
    
    pConnection = QueryConnection( FALSE );
    if ( pConnection != NULL )
    {
        return pConnection->QueryUserContext();
    }
    else
    {
        return NULL;
    }
}
    
VOID
W3_MAIN_CONTEXT::SetConnectionUserContext(
    W3_USER_CONTEXT *           pUserContext
)
/*++

Routine Description:

    Associate user context with connection

Arguments:

    pUserContext - User context to associate

Return Value:

    None

--*/
{
    W3_CONNECTION *         pConnection = NULL;
    
    pConnection = QueryConnection( TRUE );
    if ( pConnection != NULL )
    {
        pConnection->SetUserContext( pUserContext );
    }
    else
    {
        DBG_ASSERT( FALSE );
    }
}

HRESULT
W3_MAIN_CONTEXT::ReceiveEntityBody(
    BOOL            fAsync,
    VOID *          pBuffer,
    DWORD           cbBuffer,
    DWORD *         pBytesReceived
    )
/*++

Routine Description:

    Receives entity data from the client

Arguments:

    fAsync - TRUE if this is an async request
    pBuffer - The buffer to store the data
    cbBuffer - The size of the buffer
    pBytesReceived - Upon return, the amount of data copied
                     into the buffer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = UlAtqReceiveEntityBody( QueryUlatqContext(),
                                         fAsync,
                                         0,
                                         pBuffer,
                                         cbBuffer,
                                         pBytesReceived );

    //
    // Keep track of how much we're reading
    //

    if (!fAsync &&
        SUCCEEDED(hr))
    {
        if ( _cbRemainingEntityFromUL != INFINITE )
        {
            if ( _cbRemainingEntityFromUL >= *pBytesReceived )
            {
                _cbRemainingEntityFromUL -= *pBytesReceived;
            }
            else
            {
                _cbRemainingEntityFromUL = 0;
            }
        }
    }

    return hr;
}

W3_CONNECTION *
W3_MAIN_CONTEXT::QueryConnection(
    BOOL                fCreateIfNotFound
)
/*++

Routine Description:

    Get the W3_CONNECTION object associated with this request

Arguments:

    fCreateIfNotFound - If not found in hash table, create it

Return Value:

    Pointer to W3_CONNECTION.

--*/
{
    HRESULT             hr;

    if ( _pConnection == NULL )
    {
        //
        // Get the connection associated with this request
        //
        
        if ( !fCreateIfNotFound && _fAssociationChecked )
        {
            //
            // If we have already looked for the connection, and we're not
            // required to create one, then we can fast path
            //
            
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        else
        {
            hr = W3_CONNECTION::RetrieveConnection( _request.QueryConnectionId(),
                                                    fCreateIfNotFound,
                                                    &_pConnection );
        }
        
        if ( FAILED( hr ) )
        {
            if ( fCreateIfNotFound )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error retrieving connection.  hr = %x\n",
                            hr ));
            }
            else
            {
                //
                // Not really an error.  We were just querying the hash table
                // for an associated connection (but not creating one)
                //
            }
        }
        else
        {
            DBG_ASSERT( _pConnection != NULL );
        }
        
        //
        // Don't try to repeat connection lookup again
        //
        
        _fAssociationChecked = TRUE;
    }
    
    return _pConnection;
}

VOID *
W3_MAIN_CONTEXT::ContextAlloc(
    UINT                cbSize
)
/*++

Routine Description:

    Allocate context space from inline buffer in MAIN_CONTEXT.  This 
    complicated mechanism allows for states to allocate small state 
    without going to the heap.

Arguments:

    cbSize - Size to allocate
    
Return Value:

    Pointer to buffer

--*/
{
    BYTE *pOrigBuffer = (PBYTE) QueryInlineBuffer() + _cbInlineOffset;

    //
    // Make space for 8 byte alignment
    //
    VOID *pBuffer = (VOID *)(((DWORD_PTR)pOrigBuffer + 7) & ~7);
    _cbInlineOffset += DIFF((PBYTE)pBuffer - pOrigBuffer);
    
    if ( _cbInlineOffset + cbSize > sm_cbInlineBytes )
    {
        DBG_ASSERT( FALSE );
        return NULL;
    }
    
    _cbInlineOffset += cbSize;
    
    return pBuffer; 
}

BOOL
W3_MAIN_CONTEXT::NotifyFilters(
    DWORD                   dwNotification,
    PVOID                   pvFilterInfo,
    BOOL *                  pfFinished
)
/*++

Routine Description:

    Notify all applicable filters for a given notification.  This is a 
    wrapper of the W3_FILTER_CONTEXT call to actually do the work.  The 
    notifications made in this routine are those which would occur during
    the worker process state machine.  (excludes end_of_net_session and
    raw data notifications)

Arguments:

    dwNotification - Notification in question
    pvFilterInfo - Points to any info object passed to filter
    pfFinished - Set to TRUE if the filter decided to complete work
    
Return Value:

    BOOL

--*/
{
    BOOL                fRet = FALSE;
    BOOL                fSynchronized = FALSE;

    DBG_ASSERT( _pFilterContext != NULL );
    
    _pFilterContext->FilterLock();

    switch( dwNotification )
    {
    case SF_NOTIFY_PREPROC_HEADERS:
        fRet = _pFilterContext->NotifyPreProcHeaderFilters( pfFinished );
        break;
        
    case SF_NOTIFY_URL_MAP:
        fRet = _pFilterContext->NotifyUrlMap( (HTTP_FILTER_URL_MAP*) pvFilterInfo,
                                              pfFinished );
        break;

    case SF_NOTIFY_AUTHENTICATION:
        fRet = _pFilterContext->NotifyAuthentication( (HTTP_FILTER_AUTHENT*) pvFilterInfo,
                                                      pfFinished );
        break;
        
    case SF_NOTIFY_AUTH_COMPLETE:
        fRet = _pFilterContext->NotifyAuthComplete( 
                    ( HTTP_FILTER_AUTH_COMPLETE_INFO * )pvFilterInfo,
                    pfFinished );
        break;

    case SF_NOTIFY_SEND_RESPONSE:
        fRet = _pFilterContext->NotifySendResponseFilters( 
                            (HTTP_FILTER_SEND_RESPONSE*) pvFilterInfo,
                            pfFinished );
        break;

    case SF_NOTIFY_END_OF_REQUEST:
        fRet = _pFilterContext->NotifyEndOfRequest();
        break;

    case SF_NOTIFY_LOG:
        fRet = _pFilterContext->NotifyLogFilters((HTTP_FILTER_LOG *)pvFilterInfo);
        break;
        
    case SF_NOTIFY_SEND_RAW_DATA:
        fRet = _pFilterContext->NotifySendRawFilters(
                            (HTTP_FILTER_RAW_DATA*) pvFilterInfo,
                            pfFinished );
        break;        
        
    default:
        DBG_ASSERT( FALSE );
        fRet = FALSE;
    }

    _pFilterContext->FilterUnlock();
    
    return fRet;
}    

W3_FILTER_CONTEXT *
W3_MAIN_CONTEXT::QueryFilterContext(
    BOOL                    fCreateIfNotFound
)
/*++

Routine Description:

    Get a filter context to associate with the MAIN_CONTEXT and to also (
    AAAAAAAARRRRRRRGGGGGGGHHHHHH) associate with the connection on the
    W3_CONTXT

Arguments:

    fCreateIfNotFound - Should we create a context if it doesn't already exist
    
Return Value:

    Pointer to a new W3_FILTER_CONTEXT

--*/
{
    BOOL                            fSecure;
    
    if ( _pFilterContext == NULL &&
         fCreateIfNotFound )
    {
        fSecure = QueryRequest()->IsSecureRequest();

        DBG_ASSERT( _pSite != NULL );
       
        _pFilterContext = new W3_FILTER_CONTEXT( fSecure,
                                                 _pSite->QueryFilterList() );
        if ( _pFilterContext != NULL )
        {
            _pFilterContext->SetMainContext( this );
        }
        else
        {
            DBG_ASSERT( FALSE );
        }
    }
    return _pFilterContext;
}

BOOL
W3_MAIN_CONTEXT::IsNotificationNeeded(
    DWORD                   dwNotification
)
/*++
Routine Description:

    Is a specific filter notification applicable for this request

Arguments:

    dwNotification - Notification in question
    
Return Value:

    BOOL

--*/
{
    BOOL                fNeeded = FALSE;
    FILTER_LIST *       pFilterList = NULL;
    W3_FILTER_CONTEXT * pW3Context = NULL;

    if ( _pSite != NULL )
    {
        //
        // To avoid creating connection contexts, do the simple fast check
        // to determine whether the given contexts site supports the 
        // notification.  If it does, then we have to do the more robust
        // check to determine whether this specific request requires the 
        // notification (there is a difference because a filter can 
        // disable itself on the fly for any given request)
        //
        
        pFilterList = _pSite->QueryFilterList();
        DBG_ASSERT( pFilterList != NULL );

        if ( pFilterList->IsNotificationNeeded( dwNotification, 
                                                QueryRequest()->IsSecureRequest() ) )
        {
            pW3Context = QueryFilterContext();
            if ( pW3Context != NULL )
            {
                fNeeded = pW3Context->IsNotificationNeeded( dwNotification );
            }
        }
    }
    
    return fNeeded;
}

BOOL 
W3_MAIN_CONTEXT::QueryExpiry( 
    LARGE_INTEGER *           pExpiry 
)
/*++

Routine Description:

    Queries the expiration date/time for logon user

Arguments:

    pExpiry - ptr to buffer to update with expiration date

Return Value:

    TRUE if successful, FALSE if not available

--*/
{
    SECURITY_STATUS                ss;
    SecPkgContext_PasswordExpiry   speExpiry;
    SSPI_SECURITY_CONTEXT        * pSecurityContext;
    W3_USER_CONTEXT              * pW3UserContext;
    LARGE_INTEGER                * pUserAcctExpiry = NULL;

    
    pUserAcctExpiry = _pUserContext->QueryExpiry();

    if ( pUserAcctExpiry == NULL )
    {
        ((LARGE_INTEGER*)pExpiry)->HighPart = 0x7fffffff;
        ((LARGE_INTEGER*)pExpiry)->LowPart = 0xffffffff;
        return FALSE;
    }
    else
    {
        memcpy( pExpiry, 
                pUserAcctExpiry, 
                sizeof( LARGE_INTEGER ) );
    }
    return TRUE;

}

HRESULT
W3_MAIN_CONTEXT::ExecuteExpiredUrl(
    STRU & strExpUrl
)
/*++

Routine Description:

    Do child execution on the server configed expire url

Arguments:

    strExpUrl - The configed expire url to be executed

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    AUTH_PROVIDER *     pAnonymousProvider = NULL;
    STRA                strNewHeader;
    STRA                strNewValue;


    pAnonymousProvider = W3_STATE_AUTHENTICATION::QueryAnonymousProvider();
    DBG_ASSERT( pAnonymousProvider != NULL );
    
    hr = pAnonymousProvider->DoAuthenticate( this );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Execute a child request
    //
    QueryResponse()->Clear();
    QueryResponse()->SetStatus( HttpStatusOk );
    
    //
    // Reset the new url to be executed
    //
    hr = QueryRequest()->SetUrl( strExpUrl );
    if( FAILED( hr ) )
    {
        return hr;
    } 

    //
    // Add CFG_ENC_CAPS header and set its value to 1 to indicate 
    // the site support SSL, to 0 if not.
    //
    strNewHeader.Copy( "CFG-ENC-CAPS" );
    
    if( QuerySite()->QuerySSLSupported() )
    {
        strNewValue.Copy( "1" );
    }
    else
    {
        strNewValue.Copy( "0" );
    }
       
    hr = QueryRequest()->SetHeader( strNewHeader,
                                    strNewValue,
                                    TRUE );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Set the auth access check flag to FALSE so the 
    // child execution won't do auth access check
    //

    SetAuthAccessCheckRequired( FALSE );

    //
    // Set finished response for parent
    //
    SetFinishedResponse();


    //
    // Execute child request
    //
    hr = ExecuteChildRequest( QueryRequest(),
                              FALSE,
                              W3_FLAG_ASYNC );

    return hr;
}

HRESULT
W3_MAIN_CONTEXT::PasswdExpireNotify(
    VOID
)
/*++

Routine Description:

    Check if the user password has been expired

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_FALSE;
    LARGE_INTEGER       cExpire;
    FILETIME            ftNow;
    DWORD               dwExpireInDay;
    DWORD               dwTotalRequired;
    STACK_STRU        ( strExpUrl,  MAX_PATH );
    STACK_STRU        ( strFullUrl, MAX_PATH );
    STRU              * pstrAdvNotPwdExpUrl;
    BYTE                byTokenInfo[ SID_DEFAULT_SIZE + sizeof( TOKEN_USER ) ];
    PSID                pSid;

    if ( QueryExpiry( &cExpire ) )
    {
        if ( cExpire.HighPart == 0x7fffffff )
        {
            //
            // Password never expire
            //

            return hr;
        }
        else
        {
            GetSystemTimeAsFileTime( &ftNow );

            if ( *( __int64 * )&cExpire > *( __int64 * )&ftNow )
            {
                dwExpireInDay = ( DWORD )( ( * ( __int64 * )&cExpire
                                - *( __int64 * )&ftNow )
                                / ( ( __int64 )10000000 * 86400 ) );
                                
                if ( QuerySite()->QueryAdvNotPwdExpInDays() && 
                     dwExpireInDay <= QuerySite()->QueryAdvNotPwdExpInDays() )
                {
                    pstrAdvNotPwdExpUrl = QuerySite()->QueryAdvNotPwdExpUrl(); 
                    if( pstrAdvNotPwdExpUrl == NULL )
                    {
                        //
                        // Advanced password expire notification disabled
                        //
                        return hr;
                    }

                    //
                    // Check this SID has not already been notified
                    // of pwd expiration
                    //

                    if ( GetTokenInformation( 
                                 QueryUserContext()->QueryPrimaryToken(),
                                 TokenUser,
                                 ( LPVOID )byTokenInfo,
                                 sizeof( byTokenInfo ),
                                 &dwTotalRequired ) )
                    {
                        pSid = ( ( TOKEN_USER * )byTokenInfo )->User.Sid;

                        if( !PenCheckPresentAndResetTtl( 
                                     pSid,
                                     QuerySite()->QueryAdvCacheTTL() ) )
                        {
                            PenAddToCache( 
                                     pSid,
                                     QuerySite()->QueryAdvCacheTTL() );

                            //
                            // flush cache when connection close
                            // so that account change will not be masked
                            // by cached information
                            //

                            if( QueryUserContext()->QueryAuthType() == 
                                MD_AUTH_BASIC )
                            {
                                g_pW3Server->QueryTokenCache()->FlushCacheEntry( 
                                  ( ( BASIC_USER_CONTEXT * )QueryUserContext() )
                                   ->QueryCachedToken()->QueryCacheKey() );
                            }

                            hr = strExpUrl.Copy( pstrAdvNotPwdExpUrl->
                                                     QueryStr() );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            if ( strExpUrl.QueryStr()[0] == NULL )
                            {
                                return E_FAIL;
                            }
                            
                            //
                            // Add the arg to be passed to the 
                            // password-change URL - argument is the
                            // URL the user is pointed to after all 
                            // the password-change processing is done 
                            //

                            hr = strExpUrl.Append( L"?" );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            hr = QueryRequest()->GetOriginalFullUrl( 
                                                       &strFullUrl );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }

                            hr = strExpUrl.Append( strFullUrl );
                            if( FAILED( hr ) )
                            {
                                return hr;
                            }
                                
                            return ExecuteExpiredUrl( strExpUrl );
                        }
                    }
                }
            }
            else
            {
                //
                // flush cache when connection close
                // since the password has expired
                //

                if( QueryUserContext()->QueryAuthType() == MD_AUTH_BASIC )
                {
                    g_pW3Server->QueryTokenCache()->FlushCacheEntry( 
                      ( ( BASIC_USER_CONTEXT * )QueryUserContext() )
                       ->QueryCachedToken()->QueryCacheKey() );
                }

                return PasswdChangeExecute();
            }
        }
    }

    return hr;
}

HRESULT
W3_MAIN_CONTEXT::PasswdChangeExecute(
    VOID    
)
/*++

Routine Description:

    This method handles password expiration notification

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_FALSE;
    STACK_STRU        ( strExpUrl,  MAX_PATH );
    STACK_STRU        ( strFullUrl, MAX_PATH );
    STACK_STRU        ( strUrl,     MAX_PATH );
    STRU              * pstrAuthExpiredUrl;

    pstrAuthExpiredUrl = QuerySite()->QueryAuthExpiredUrl();
    
    if( pstrAuthExpiredUrl == NULL )
    {
        //
        // S_FALSE means password change disabled
        //

        return hr;

    } 

    hr = strExpUrl.Copy( pstrAuthExpiredUrl->QueryStr() );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if ( strExpUrl.QueryStr()[0] == NULL )
    {
        return E_FAIL;
    }

    hr = QueryRequest()->GetUrl( &strUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Add the arg to be passed to the password-change URL - argument 
    // is the URL the user is pointed to after all the password-change 
    // processing is done 
    //
    hr = strExpUrl.Append( L"?" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = QueryRequest()->GetOriginalFullUrl( &strFullUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strExpUrl.Append( strFullUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }
    
    return ExecuteExpiredUrl( strExpUrl );
}

HRESULT
W3_MAIN_CONTEXT::GetRemoteDNSName(
    STRA *              pstrDNSName
)
/*++

Routine Description:

    Get remote client's DNS name if it is resolved

Arguments:

    pstrDNSName - Filled with DNS name on success

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pstrDNSName != NULL );
    
    if ( _IpAddressCheck.IsDnsResolved() )
    {
        return pstrDNSName->Copy( _IpAddressCheck.QueryResolvedDnsName() );
    }
    else
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
}

CONTEXT_STATUS
W3_STATE_START::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Initial start state handling

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    W3_REQUEST *                    pRequest;
    DWORD                           dwSiteId;
    HRESULT                         hr;
    W3_SITE *                       pSite;
    BOOL                            fFinished = FALSE;
    BOOL                            fNeedRawRead = FALSE;
    RAW_CONNECTION *                pRawConnection = NULL;
    W3_FILTER_CONTEXT *             pFilterContext = NULL;
    
    //
    // Get the request out of the context and the SiteId out of the request
    //
    
    pRequest = pMainContext->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    dwSiteId = pRequest->QuerySiteId();

    //
    // Check if this site already exists
    //
    
    pSite = g_pW3Server->FindSite( dwSiteId );

    //
    // Now we need to do some locking while adding this site
    //

    if ( pSite == NULL )
    {
        g_pW3Server->WriteLockSiteList();

        //
        // try again, avoid race condition
        //
        
        pSite = g_pW3Server->FindSite( dwSiteId );
        if ( pSite == NULL )
        {
            //
            // Need to create a new site!
            //
            
            pSite = new W3_SITE( dwSiteId );
            if ( pSite == NULL )
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }
            else
            {
                hr = pSite->Initialize();
            }
            
            if ( FAILED( hr ) )
            {
                if ( pSite != NULL )
                {
                    pSite->Release();
                    pSite = NULL;
                }
                
                pMainContext->SetErrorStatus( hr );
                pMainContext->SetFinishedResponse();               
            }
            else
            {
                g_pW3Server->AddSite( pSite );
            }
        }

        g_pW3Server->WriteUnlockSiteList();
    }
    
    if ( pSite == NULL )
    {
        return CONTEXT_STATUS_CONTINUE;
    }
    
    //
    // If we found a site, associate it so that all future consumers can
    // get at site configuration settings
    //
    
    pMainContext->AssociateSite( pSite );

    //
    // Let the raw data fun begin. 
    //
    // If this request has gone thru the stream filter, then we'll need
    // to associate the current W3_CONNECTION with a RAW_CONNECTION.  Also,
    // we'll have to retrieve a filter context
    //
    
    fNeedRawRead = FILTER_LIST::QueryGlobalList()->IsNotificationNeeded(
                                                SF_NOTIFY_READ_RAW_DATA,
                                                FALSE );
    
    if ( pRequest->QueryRawConnectionId() != HTTP_NULL_ID &&
         fNeedRawRead )
    {
        //
        // Raw read filters should be loaded only in old mode
        //
        DBG_ASSERT( g_pW3Server->QueryInBackwardCompatibilityMode() );

        //
        // Find a raw connection for this request
        //

        hr = RAW_CONNECTION::FindConnection( pRequest->QueryRawConnectionId(),
                                             &pRawConnection );
        if ( FAILED( hr ) )
        {
            pMainContext->SetErrorStatus( hr ); 
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }  
        
        DBG_ASSERT( pRawConnection != NULL );                         
        
        //
        // We will need to copy over context pointers and allocated memory
        // from any existing read data filters
        // 
        
        pFilterContext = pMainContext->QueryFilterContext();
        if ( pFilterContext == NULL )
        {
            pMainContext->SetErrorStatus( hr ); 
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }
        
        pRawConnection->CopyContextPointers( pFilterContext );
        pRawConnection->CopyAllocatedFilterMemory( pFilterContext );
        
        hr = pRawConnection->CopyHeaders( pFilterContext );
        if ( FAILED( hr ) )
        {
            pMainContext->SetErrorStatus( hr ); 
            pMainContext->SetFinishedResponse();
            pMainContext->SetDisconnect( TRUE );
            return CONTEXT_STATUS_CONTINUE;
        }

        //
        // Associate the raw connection with the main context
        //
        
        pRawConnection->SetMainContext( pMainContext );
        pMainContext->SetRawConnection( pRawConnection );
    }    
    
    //
    // We can notify filters now that we have a site associated
    //
    
    if ( pMainContext->IsNotificationNeeded( SF_NOTIFY_PREPROC_HEADERS ) )
    {
        pMainContext->NotifyFilters( SF_NOTIFY_PREPROC_HEADERS,
                                     NULL,
                                     &fFinished );
        
        if ( fFinished )
        {
            pMainContext->SetFinishedResponse();
        }
    }

    //
    // Determine the amount of bytes available to be read thru UL
    //
    
    pMainContext->DetermineRemainingEntity();
    
    //
    // Now that filters have been notified, we can increment the appropriate
    // verb perf counter.
    //
    
    pSite->IncReqType( pRequest->QueryVerbType() );
    
    return CONTEXT_STATUS_CONTINUE;
}

VOID *
W3_MAIN_CONTEXT_STATE::operator new(
    size_t              uiSize,
    VOID *              pPlacement
)
{
    W3_MAIN_CONTEXT *           pContext;
    W3_MAIN_CONTEXT_STATE *     pState;
    PVOID                       pBuffer;
    
    pContext = (W3_MAIN_CONTEXT*) pPlacement;
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pBuffer = pContext->ContextAlloc( (UINT)uiSize );
    DBG_ASSERT( pBuffer != NULL );
    return pBuffer;
}
    
VOID
W3_MAIN_CONTEXT_STATE::operator delete(
    VOID *              pContext
)
{
    //
    // Do nothing here.  Either
    // a) memory was allocated from inline W3_MAIN_CONTEXT buffer and thus should
    //    not be freeed
    // b) memory was allocated from heap because inline buffer didn't have
    //    enough space.  In this case, the memory is freed on MAIN_CONTEXT
    //    cleanup
    //
}

VOID
W3_MAIN_CONTEXT::DetermineRemainingEntity(
    VOID
)
/*++

Routine Description:

    Determine remaining entity body to be read from UL

Arguments:

    None

Return Value:

    None

--*/
{
    CHAR *                  pszContentLength;
    DWORD                   cbContentLength;
    
    if ( _request.QueryMoreEntityBodyExists() )
    {
        pszContentLength = _request.GetHeader( HttpHeaderContentLength );
        if ( pszContentLength != NULL )
        {
            cbContentLength = atoi( pszContentLength );
            
            if ( _request.QueryAvailableBytes() <= cbContentLength )
            {
                _cbRemainingEntityFromUL = cbContentLength - _request.QueryAvailableBytes();
            } 
            else
            {
                _cbRemainingEntityFromUL = 0;
            }
        }
        else
        {
            _cbRemainingEntityFromUL = INFINITE;
        }
    }
    else
    {
        _cbRemainingEntityFromUL = 0;
    }
}

HRESULT
W3_MAIN_CONTEXT::SetupCertificateContext(
    HTTP_SSL_CLIENT_CERT_INFO * pClientCertInfo
)
/*++

Routine Description:

    Create a CERTIFICATE_CONTEXT representing the given client certificate

Arguments:

    pClientCertInfo - Client cert info from stream filter

Return Value:

    HRESULT

--*/
{
    if ( pClientCertInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Just for completeness sake, attach the raw cert descriptor to the
    // main request, as it automatically be for subsequent requests on this
    // connection
    //
    
    QueryRequest()->SetClientCertInfo( pClientCertInfo );

    //
    // Create a client certificate descriptor and associate it with
    //
    
    DBG_ASSERT( _pCertificateContext == NULL );
    
    _pCertificateContext = new CERTIFICATE_CONTEXT( pClientCertInfo );
    if ( _pCertificateContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

VOID
W3_MAIN_CONTEXT::SetRawConnection(
    RAW_CONNECTION *            pRawConnection
)
/*++

Routine Description:

    Set a raw connection for this context.  This raw connection is stored so
    that we can disassociate ourselves with it when the state machine is
    complete

Arguments:

    pRawConnection - Raw connection

Return Value:

    None

--*/
{
    pRawConnection->ReferenceRawConnection();
    _pRawConnection = pRawConnection;
}

CONTEXT_STATUS
W3_STATE_DONE::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Do the done state stuff

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_STATE_DONE::OnCompletion(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Complete the done state

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing an execution of the state machine
    cbCompletion - Number of bytes on completion
    dwCompletionStatus - Win32 Error on completion (if any)
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    DBG_ASSERT( pMainContext != NULL );
    
    //
    // We could only get to here, if a send raw notification caused us to
    // pend the done state until the connection goes away, or the current
    // context is disassociated with the connection
    //
    
    DBG_ASSERT( pMainContext->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) );

    return CONTEXT_STATUS_CONTINUE;
}

//static
VOID
W3_MAIN_CONTEXT::OnNewRequest(
    ULATQ_CONTEXT          ulatqContext
)
/*++

Routine Description:

    Completion routine called when a new request is dequeued to be handled

Arguments:

    ulatqContext - ULATQ_CONTEXT representing the request
    
Return Value:

    None

--*/
{
    HTTP_REQUEST *          pUlHttpRequest = NULL;
    W3_CONNECTION *         pConnection = NULL;
    W3_MAIN_CONTEXT *       pMainContext = NULL;
    HRESULT                 hr = NO_ERROR;

    InterlockedIncrement( &sm_cOutstandingThreads );
    
    //
    // Get the HTTP_REQUEST for this new request
    //
    
    pUlHttpRequest = (HTTP_REQUEST *)UlAtqGetContextProperty(
                                         ulatqContext,
                                         ULATQ_PROPERTY_HTTP_REQUEST );

    DBG_ASSERT( pUlHttpRequest != NULL );

    //
    // Setup the MAIN_CONTEXT for this new request
    //

    pMainContext = new W3_MAIN_CONTEXT( pUlHttpRequest,
                                        ulatqContext );
    
    if (NULL == pMainContext)
    {
        UlAtqFreeContext(ulatqContext);
        goto done;
    }

    pMainContext->_LogContext.m_dwBytesRecvd = pUlHttpRequest->BytesReceived;

    //
    // Start the state machine
    //
    
    pMainContext->DoWork( 0, 
                          0, 
                          FALSE );

done:                          
    InterlockedDecrement( &sm_cOutstandingThreads );
}

//static
VOID
W3_MAIN_CONTEXT::OnPostedCompletion(
    DWORD           dwCompletionStatus,
    DWORD           cbTransferred,
    LPOVERLAPPED    lpo
)
/*++

Routine Description:

    Fake completion routine called when we want to fake a completion for
    asynchronous sanity sake

Arguments:

    dwCompletionStatus - Error (if any) on the completion
    cbTransferred - Bytes Written
    lpo - Overlapped
    
Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *    pMainContext;

    InterlockedIncrement( &sm_cOutstandingThreads );

    pMainContext = (W3_MAIN_CONTEXT *)lpo;
    DBG_ASSERT( pMainContext != NULL );

    //
    // Continue the state machine
    //
    
    pMainContext->DoWork( cbTransferred,
                          dwCompletionStatus,
                          TRUE );
                          
    InterlockedDecrement( &sm_cOutstandingThreads );
}

//static
VOID
W3_MAIN_CONTEXT::OnIoCompletion(
    PVOID                   pvContext,
    DWORD                   cbTransferred,
    DWORD                   dwCompletionStatus,
    OVERLAPPED *            lpo
)
/*++

Routine Description:

    Completion routine called on async IO completions for a given request

Arguments:

    pvContext - Completion context (a UL_REQUEST*)
    cbTransferred - Bytes on the completion
    dwCompletionStatus - Error (if any) on the completion
    lpo - Overlapped
    
Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *            pMainContext;

    InterlockedIncrement( &sm_cOutstandingThreads );
    
    pMainContext = (W3_MAIN_CONTEXT*) pvContext;
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pMainContext->CheckSignature() );

    //
    // Continue the state machine
    //
    
    pMainContext->DoWork( cbTransferred,
                          dwCompletionStatus,
                          TRUE );
                          
    InterlockedDecrement( &sm_cOutstandingThreads );
}

//static
VOID
W3_MAIN_CONTEXT::AddressResolutionCallback(
    ADDRCHECKARG            pContext,
    BOOL                    fUnused,
    LPSTR                   pszUnused
)
/*++

Routine Description:

    Callback called when RDNS crud has done its resolution

Arguments:

    pContext - Context (in our case, pointer to W3_MAIN_CONTEXT so that 
                        we can resume state machine)
    fUnused - Not used
    pszUnused - Not used
    
Return Value:

    None

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    
    pMainContext = (W3_MAIN_CONTEXT*) pContext;
    DBG_ASSERT( pMainContext != NULL );
    DBG_ASSERT( pMainContext->CheckSignature() );
    
    ThreadPoolPostCompletion( 0,
                              W3_MAIN_CONTEXT::OnPostedCompletion,
                              (OVERLAPPED*) pMainContext );
}

VOID
W3_MAIN_CONTEXT::TimerCallback(LPVOID pvParam,
                             BOOLEAN fReason)
/*++

Routine Description:

    Callback called when W3_MAIN_CONTEXT has existed for too long

    OutputDebugString to tell people why we are doing this
    and DebugBreak if a debugger is attached.  
    
    If no debugger is attached, ignore the callback.

Arguments:

    pvParam - pointer to W3_MAIN_CONTEXT that has exceeded its maximum lifetime
    fReason - not used
    
Return Value:

    void

--*/
{
    W3_MAIN_CONTEXT* pThis = (W3_MAIN_CONTEXT*)pvParam;
    if (IsDebuggerPresent())
    {
        OutputDebugString(L"****************\nIIS (w3core.dll) has called DebugBreak because\nHKLM\\System\\CurrentControlSet\\Services\\InetInfo\\Parameters\\RequestTimeoutBreak\nwas set.\nAnd a request has taken longer than the specified maximium time in milliseconds\n****************\n");
        DebugBreak();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\map_handler.cxx ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     map_handler.cxx

   Abstract:
     Handle Map Files requests
 
   Author:
     Anil Ruia (AnilR)          9-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define MAXVERTS 160

const int MIN_INTEGER = 0x80000001;

void SkipLine(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex);

void SkipWhiteExceptNewLine(LPCSTR pszFileContents,
                            const DWORD cbFileSize,
                            DWORD &fileIndex);

void SkipWhite(LPCSTR pszFileContents,
               const DWORD cbFileSize,
               DWORD &fileIndex);

void SkipNonWhite(LPCSTR pszFileContents,
                  const DWORD cbFileSize,
                  DWORD &fileIndex);

int GetNumber(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex);

BOOL PointInRect(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex);

BOOL PointInCircle(LPCSTR pszFileContents,
                   const DWORD cbFileSize,
                   DWORD &fileIndex,
                   const int x,
                   const int y,
                   DWORD &urlIndex);

BOOL PointInPoly(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex);

double PointInPoint(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex,
                    const int x,
                    const int y,
                    DWORD &urlIndex);

DWORD GetDefaultUrl(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex);

HRESULT W3_STATIC_FILE_HANDLER::MapFileDoWork(
    W3_CONTEXT   *pW3Context,
    W3_FILE_INFO *pOpenFile,
    BOOL         *pfHandled)
{
    DBG_ASSERT(pW3Context != NULL);
    DBG_ASSERT(pOpenFile != NULL);
    DBG_ASSERT(pfHandled != NULL);

    STACK_STRA(strTargetUrl,        MAX_PATH);
    STACK_STRU(strQueryString,      MAX_PATH);
    HANDLE                          hToken;
    LPSTR                           pszFileContents = NULL;
    BOOL                            fFileContentsAllocated = FALSE;
    int                             x = 0;
    int                             y = 0;
    HRESULT                         hr = S_OK;

    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    *pfHandled = FALSE;

    DWORD cbFileSize;
    LARGE_INTEGER liFileSize;
    pOpenFile->QuerySize(&liFileSize);
    cbFileSize = liFileSize.LowPart;

    if (pOpenFile->QueryFileBuffer() != NULL)
    {
        pszFileContents = (LPSTR)pOpenFile->QueryFileBuffer();
    }
    else
    {
        pszFileContents = new CHAR[cbFileSize];
        if (pszFileContents == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Finished;
        }
        fFileContentsAllocated = TRUE;

        DWORD cbRead;
        OVERLAPPED ovl;
        ZeroMemory(&ovl, sizeof ovl);
        if (!ReadFile(pOpenFile->QueryFileHandle(),
                       pszFileContents,
                       cbFileSize,
                       &cbRead,
                      &ovl))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            switch (hr)
            {
            case HRESULT_FROM_WIN32(ERROR_IO_PENDING):
                if (!GetOverlappedResult(pOpenFile->QueryFileHandle(),
                                         &ovl,
                                         &cbRead,
                                         TRUE))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Finished;
                }
                break;

            default:
                goto Finished;
            }
        }
    }

    if (FAILED(hr = pW3Context->QueryRequest()->GetQueryString(&strQueryString)))
    {
        goto Finished;
    }

    strQueryString.Unescape();

    swscanf(strQueryString.QueryStr(), L"%d, %d", &x, &y);

    if (FAILED(hr = SearchMapFile(pszFileContents,
                                  cbFileSize,
                                  x, y, &strTargetUrl)))
    {
        goto Finished;
    }

    if (strTargetUrl.QueryCCH() == 0)
    {
        //
        // No entry found
        //
        CHAR * pszReferer;
        if ((pszReferer = pRequest->GetHeader(HttpHeaderReferer)) != NULL)
        {
            //
            // Redirect back to referrer
            //

            strTargetUrl.Copy(pszReferer);
        }
        else
        {
            *pfHandled = FALSE;
            goto Finished;
        }
    }

    *pfHandled = TRUE;
    hr = pW3Context->SetupHttpRedirect(strTargetUrl,
                                       FALSE,
                                       HttpStatusRedirect);

Finished:

    if (fFileContentsAllocated)
    {
        delete [] pszFileContents;
    }

    return hr;
}

HRESULT W3_STATIC_FILE_HANDLER::SearchMapFile(
            IN LPCSTR pszFileContents,
            IN const DWORD cbFileSize,
            IN const int x,
            IN const int y,
            OUT STRA *pstrTarget)
{
    DWORD fileIndex = 0;
    DWORD urlIndex = 0;
    BOOL fFound = FALSE;
    double MinDistanceFromPoint = 1e64;
    DWORD PointUrlIndex = 0;
    DWORD DefaultUrlIndex = 0;

    while ((fileIndex < cbFileSize) && !fFound)
    {
        switch (pszFileContents[fileIndex])
        {
        case '#':
            //
            // Comment, skip the line
            //
            break;

        case 'r':
        case 'R':
            //
            // Rectangle
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("rect", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInRect(pszFileContents, cbFileSize,
                                     fileIndex,
                                     x, y,
                                     urlIndex);
            }
            break;

        case 'c':
        case 'C':
            //
            // Circle
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("circ", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInCircle(pszFileContents, cbFileSize,
                                       fileIndex,
                                       x, y,
                                       urlIndex);
            }
            break;

        case 'p':
        case 'P':
            //
            // Polygon or point
            //

            if ((fileIndex < (cbFileSize - 4)) &&
                !_strnicmp("poly", pszFileContents + fileIndex, 4))
            {
                fileIndex += 4;
                fFound = PointInPoly(pszFileContents, cbFileSize,
                                     fileIndex,
                                     x, y,
                                     urlIndex);
            }
            else if ((fileIndex < (cbFileSize - 5)) &&
                     !_strnicmp("point", pszFileContents + fileIndex, 5))
            {
                fileIndex += 5;

                double distance = PointInPoint(pszFileContents, cbFileSize,
                                               fileIndex,
                                               x, y,
                                               urlIndex);

                if (distance < MinDistanceFromPoint)
                {
                    MinDistanceFromPoint = distance;
                    PointUrlIndex = urlIndex;
                }
            }
            break;

        case 'd':
        case 'D':
            //
            // default URL
            //

            if ((fileIndex < (cbFileSize - 3)) &&
                !_strnicmp("def", pszFileContents + fileIndex, 3))
            {
                fileIndex += 3;
                DefaultUrlIndex = GetDefaultUrl(pszFileContents,
                                                cbFileSize,
                                                fileIndex);
            }
            break;
        }  // switch

        if (!fFound)
            SkipLine(pszFileContents, cbFileSize, fileIndex);
    }  // while

    //
    //  If we didn't find a mapping and a point or a default was specified, 
    //  use that URL
    //

    if (!fFound)
    {
        if (PointUrlIndex != 0)
        {
            urlIndex = PointUrlIndex;
            fFound = TRUE;
        }
        else if (DefaultUrlIndex != 0)
        {
            urlIndex = DefaultUrlIndex;
            fFound = TRUE;
        }
    }

    if (fFound)
    {
        //
        //  make urlIndex point to the start of the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, urlIndex);

        //
        //  Determine the length of the URL and copy it out
        //

        DWORD endOfUrlIndex = urlIndex;
        SkipNonWhite(pszFileContents, cbFileSize, endOfUrlIndex); 

        HRESULT hr;
        if (FAILED(hr = pstrTarget->Copy(pszFileContents + urlIndex,
                                          endOfUrlIndex - urlIndex)))
        {
            return hr;
        }

        //
        // BUGBUG - Escape the URL
        //
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT, "No mapping found for %d, %d\n", x, y));
    }

    return S_OK;
}

void SkipLine(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           (pszFileContents[fileIndex] != '\n'))
        fileIndex++;

    fileIndex++;
}

void SkipWhiteExceptNewLine(LPCSTR pszFileContents,
                            const DWORD cbFileSize,
                            DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           ((pszFileContents[fileIndex] == ' ') ||
            (pszFileContents[fileIndex] == '\t') ||
            (pszFileContents[fileIndex] == '(') ||
            (pszFileContents[fileIndex] == ')')))
    {
        fileIndex++;
    }
}

void SkipWhite(LPCSTR pszFileContents,
               const DWORD cbFileSize,
               DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           ((pszFileContents[fileIndex] == ' ') ||
            (pszFileContents[fileIndex] == '\t') ||
            (pszFileContents[fileIndex] == '\r') ||
            (pszFileContents[fileIndex] == '\n') ||
            (pszFileContents[fileIndex] == '(') ||
            (pszFileContents[fileIndex] == ')')))
    {
        fileIndex++;
    }
}

void SkipNonWhite(LPCSTR pszFileContents,
                  const DWORD cbFileSize,
                  DWORD &fileIndex)
{
    while ((fileIndex < cbFileSize) &&
           (pszFileContents[fileIndex] != ' ') &&
           (pszFileContents[fileIndex] != '\t') &&
           (pszFileContents[fileIndex] != '\r') &&
           (pszFileContents[fileIndex] != '\n'))
    {
        fileIndex++;
    }
}

int GetNumber(LPCSTR pszFileContents,
              const DWORD cbFileSize,
              DWORD &fileIndex)
{
    int Value = MIN_INTEGER;

    char    ch;
    bool    fNegative = false;

    //
    //  Make sure we don't get into the URL
    //

    while ((fileIndex < cbFileSize) &&
           !isalnum(ch = pszFileContents[fileIndex]) &&
           (ch != '-') && (ch != '/') &&
           (ch != '\r') && (ch != '\n'))
    {
        fileIndex++;
    }

    //
    // Read the number
    //
    if ((fileIndex < cbFileSize) &&
        (pszFileContents[fileIndex] == '-'))
    {
        fNegative = true;
        fileIndex++;
    }

    while ((fileIndex < cbFileSize) &&
           isdigit(ch = pszFileContents[fileIndex]))
    {
        if (Value == MIN_INTEGER)
            Value = 0;

        Value = Value*10 + (ch - '0');
        fileIndex++;
    }

    if (fNegative)
        Value = -Value;

    return Value;
}

BOOL PointInRect(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex)
{
    BOOL fNCSA = FALSE;
    BOOL fFound  = FALSE;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex = fileIndex;                        // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (((ch < '0') || (ch > '9')) &&
        (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = true;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    int x1 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    int y1 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    int x2 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    int y2 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    if ((x >= x1) && (x < x2) &&  (y >= y1) && (y < y2))
        fFound = true;

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

BOOL PointInCircle(LPCSTR pszFileContents,
                   const DWORD cbFileSize,
                   DWORD &fileIndex,
                   const int x,
                   const int y,
                   DWORD &urlIndex)
{
    BOOL fNCSA = FALSE;
    BOOL fFound = FALSE;

    double      r1, r2;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex  =  fileIndex;                           // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (!isdigit(ch) && (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = true;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    //
    //  Get the center and edge of the circle
    //

    double xCenter = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double yCenter = GetNumber(pszFileContents, cbFileSize, fileIndex);

    double xEdge = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double yEdge = GetNumber(pszFileContents, cbFileSize, fileIndex);

    //
    // If we have the NCSA format, (xEdge, yEdge) is a point on the
    // circumference.  Otherwise xEdge specifies the radius
    //
    if (yEdge != (double)MIN_INTEGER)
    {
        r1 = (yCenter - yEdge) * (yCenter - yEdge) +
            (xCenter - xEdge) * (xCenter - xEdge);

        r2 = (yCenter - y) * (yCenter - y) +
            (xCenter - x) * (xCenter - x);

        if ( r2 <= r1 )
            fFound = true;
    }
    //
    //  CERN format, third param is the radius
    //
    else if(xEdge >= 0)
    {
        double radius;
        radius = xEdge;

        if (( xCenter - x ) * ( xCenter - x)  + 
            ( yCenter - y ) * ( yCenter - y) <= ( radius * radius))
            fFound = true;
    }
    // if invalid radius, just check if it is on center
    else if ((xCenter == x) && (yCenter == y))
    {
        fFound = true;
    }

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //
        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

const int X = 0;
const int Y = 1;

BOOL PointInPoly(LPCSTR pszFileContents,
                 const DWORD cbFileSize,
                 DWORD &fileIndex,
                 const int x,
                 const int y,
                 DWORD &urlIndex)
{
    //
    // Algorithm used is from http://www.whisqu.se/per/docs/math27.htm
    //

    BOOL fNCSA = FALSE;
    BOOL fFound = FALSE;

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    urlIndex  =  fileIndex;                           // NCSA case
    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);

    char ch   = pszFileContents[fileIndex];

    if (!isdigit(ch) && (ch != '-') && (ch != '('))
    {
        //
        // NCSA format. Skip the URL
        //

        fNCSA = TRUE;
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    //
    //  Build the array of points
    //

    double polygon[MAXVERTS][2];
    int count = 0;

    while ((fileIndex < cbFileSize) && 
           (pszFileContents[fileIndex] != '\r') && 
           (pszFileContents[fileIndex] != '\n'))
    {
        int polyX = GetNumber(pszFileContents, cbFileSize, fileIndex);

        //
        //  Did we hit the end of the line (and go past the URL)?
        //

        if ( polyX != MIN_INTEGER)
        {
            polygon[count][X] = polyX;
            polygon[count][Y] = GetNumber(pszFileContents, cbFileSize, fileIndex);
            count++;
            if (count >= MAXVERTS)
                return FALSE;
        }
        else
            break;
    }

    if (count > 1)
    {
        double tX = x;
        double tY = y;

        double prevX = polygon[count - 1][X];
        double prevY = polygon[count - 1][Y];

        double  currX, currY;

        int crossings = 0;

        for (int i=0; i < count; i++)
        {
            double  interpY;

            currX   = polygon[i][X];
            currY   = polygon[i][Y];

            if (((prevX >= tX) && (currX < tX)) ||
                ((prevX < tX) && (currX >= tX)))
            {
                //
                // Use linear interpolation to find the y coordinate of
                // the line connecting (prevX, prevY) to (currX, currY)
                // at the same x coordinate as the target point
                //

                interpY = prevY + ((currY - prevY)/(currX - prevX))* (tX - prevX);

                if (interpY == tY)
                {
                    fFound = true;
                    break;
                }
                else if (interpY > tY)
                    crossings++;
            }
            // To catch the left end of a line
            else if (((prevX == tX) && (prevY == tY)) ||
                     ((currX == tX) && (currY == tY)))
            {
                fFound = true;
                break;
            }
            // To catch a vertical line
            else if ((prevX == currX) && (prevX == tX))
                if (((prevY >= tY) && ( currY <= tY)) ||
                    ((prevY <= tY) && ( currY >= tY)))
                {
                    fFound = true;
                    break;
                }

            prevX = currX;
            prevY = currY;
        }

        if (!fFound)
        {
            //
            // If # crossings is odd => In polygon
            //
            fFound = crossings & 0x1;
        }
    }

    if (!fNCSA)
    {
        urlIndex = fileIndex;

        //
        //  Skip the URL
        //

        SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
        SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    }

    return fFound;
}

double PointInPoint(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex,
                    const int x,
                    const int y,
                    DWORD &urlIndex)
{
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    urlIndex  =  fileIndex;                               // NCSA case

    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    double x1 = GetNumber(pszFileContents, cbFileSize, fileIndex);
    double y1 = GetNumber(pszFileContents, cbFileSize, fileIndex);

    return ((x1-x)*(x1-x)) + ((y1-y)*(y1-y));
}

DWORD GetDefaultUrl(LPCSTR pszFileContents,
                    const DWORD cbFileSize,
                    DWORD &fileIndex)
{
    //
    //  Skip "default" (don't skip white space)
    //

    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);
    DWORD defUrlIndex  = fileIndex;

    //
    //  Skip URL
    //

    SkipWhiteExceptNewLine(pszFileContents, cbFileSize, fileIndex);
    SkipNonWhite(pszFileContents, cbFileSize, fileIndex);

    return defUrlIndex;                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\methodhash.h ===
#ifndef _METHODHASH_HXX_
#define _METHODHASH_HXX_

class METHOD_HASH
    : public CTypedHashTable< METHOD_HASH, 
                              HEADER_RECORD, 
                              CHAR * >
{
public:
    METHOD_HASH()
      : CTypedHashTable< METHOD_HASH, 
                         HEADER_RECORD, 
                         CHAR * >
            ("METHOD_HASH")
    {
    }
    
    static 
    CHAR *
    ExtractKey(
        const HEADER_RECORD * pRecord
    )
    {
        DBG_ASSERT( pRecord != NULL );
        return pRecord->_pszName;
    }
    
    static
    DWORD
    CalcKeyHash(
        CHAR *                 pszKey
    )
    {
        return Hash( pszKey ); 
    }
     
    static
    bool
    EqualKeys(
        CHAR *                 pszKey1,
        CHAR *                 pszKey2
    )
    {
        return strcmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        HEADER_RECORD *       pEntry,
        int                   nIncr
    )
    {
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );
    
    static
    ULONG
    GetIndex(
        CHAR *             pszName
    )
    {
        HEADER_RECORD *       pRecord = NULL;
        LK_RETCODE                  retCode;
        HRESULT                     hr;

        retCode = sm_pMethodHash->FindKey( pszName,
                                           &pRecord );
        if ( retCode == LK_SUCCESS )
        {
            DBG_ASSERT( pRecord != NULL );
            return pRecord->_ulHeaderIndex;
        }
        else
        {
            return HttpVerbUnknown;
        }
    }
    
    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        USHORT *            pcchLength
    )
    {
        for (DWORD i = 0; sm_rgMethods[i]._pszName != NULL; i++)
        {
            if (ulIndex == sm_rgMethods[i]._ulHeaderIndex)
            {
                *pcchLength = sm_rgMethods[i]._cchName;
                return sm_rgMethods[i]._pszName;
            }
        }

        return NULL;
    }
    
private:

    static METHOD_HASH    *sm_pMethodHash;
    static HEADER_RECORD   sm_rgMethods[];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\methodhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

METHOD_HASH *METHOD_HASH::sm_pMethodHash;

HEADER_RECORD METHOD_HASH::sm_rgMethods[] = 
{
    { HttpVerbOPTIONS,   HEADER("OPTIONS") },
    { HttpVerbGET,       HEADER("GET") },
    { HttpVerbHEAD,      HEADER("HEAD") },
    { HttpVerbPOST,      HEADER("POST") },
    { HttpVerbPUT,       HEADER("PUT") },
    { HttpVerbDELETE,    HEADER("DELETE") },
    { HttpVerbTRACE,     HEADER("TRACE") },
    { HttpVerbCONNECT,   HEADER("CONNECT") },
    { HttpVerbTRACK,     HEADER("TRACK") },
    { HttpVerbMOVE,      HEADER("MOVE") },
    { HttpVerbCOPY,      HEADER("COPY") },
    { HttpVerbPROPFIND,  HEADER("PROPFIND") },
    { HttpVerbPROPPATCH, HEADER("PROPPATCH") },
    { HttpVerbMKCOL,     HEADER("MKCOL") },
    { HttpVerbLOCK,      HEADER("LOCK") },
    { HttpVerbUNLOCK,    HEADER("UNLOCK") },
    { HttpVerbSEARCH,    HEADER("SEARCH") },
    { HttpVerbUnknown,   NULL }
};

//static
HRESULT
METHOD_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HEADER_RECORD *     pRecord;
    LK_RETCODE          lkrc = LK_SUCCESS;
    DWORD               dwNumRecords;
    
    //
    // Add header index/name to hash table
    //
    
    sm_pMethodHash = new METHOD_HASH();
    if ( sm_pMethodHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Add every string->routine mapping
    //

    dwNumRecords = sizeof( sm_rgMethods ) / sizeof( HEADER_RECORD ) - 1;
    
    for ( DWORD i = 0; i < dwNumRecords; i++ )
    {
        pRecord = &(sm_rgMethods[ i ]); 
        lkrc = sm_pMethodHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pMethodHash;
        sm_pMethodHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // BUGBUG
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
METHOD_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pMethodHash != NULL )
    {
        delete sm_pMethodHash;
        sm_pMethodHash = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\mimemap.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     mimemap.cxx

   Abstract:
     Store and retrieve mime-mapping for file types

   Author:
     Murali R. Krishnan (MuraliK)  10-Jan-1995

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll

   History:
     Anil Ruia          (AnilR)    27-Mar-2000   Ported to IIS+
--*/

#include "precomp.hxx"

#define g_pszDefaultFileExt L"*"
#define g_pszDefaultMimeType L"application/octet-stream"
LPWSTR g_pszDefaultMimeEntry = L"*,application/octet-stream";

MIME_MAP *g_pMimeMap = NULL;

HRESULT MIME_MAP::InitMimeMap()
/*++
  Synopsis
    This function reads the mimemap stored either as a MULTI_SZ or as a
    sequence of REG_SZ

  Returns:
    HRESULT
--*/
{
    DBG_ASSERT(!IsValid());

    // First read metabase (common types will have priority)
    HRESULT hr = InitFromMetabase();

    if (SUCCEEDED(hr))
    {
        m_fValid = TRUE;
    }

    //  Now read Chicago shell registration database
    hr = InitFromRegistryChicagoStyle();

    if (SUCCEEDED(hr))
    {
        m_fValid = TRUE;
    }

    //
    // If at least one succeeded, we are ok
    //
    if (IsValid())
        return S_OK;

    return hr;
}

static VOID GetFileExtension(IN  LPWSTR  pszPathName,
                             OUT LPWSTR *ppszExt,
                             OUT LPWSTR *ppszLastSlash)
/*++
  Synopsis
    Gets The extension portion from a filename.

  Arguments
    pszPathName:   The full path name (containing forward '/' or '\\' 's)
    ppszExt:       Points to start of extension on return
    ppszLastSlash: Points to the last slash in the path name on return

  Return Value
    None
--*/
{
    LPWSTR pszExt  = g_pszDefaultFileExt;

    DBG_ASSERT(ppszExt != NULL && ppszLastSlash != NULL);

    *ppszLastSlash = NULL;

    if (pszPathName)
    {
        LPWSTR pszLastDot;

        pszLastDot = wcsrchr(pszPathName, L'.');

        if (pszLastDot != NULL)
        {
            LPWSTR   pszLastWhack = NULL;
            LPWSTR   pszEnd;
            
            pszEnd = pszPathName + wcslen( pszPathName );
            while ( pszEnd >= pszPathName )
            {
                if ( *pszEnd == L'/' || *pszEnd == L'\\' )
                {
                    pszLastWhack = pszEnd;
                    break;
                }
                
                pszEnd--;
            }

            if (pszLastWhack == NULL)
            {
                pszLastWhack = pszPathName;  // only file name specified.
            }

            if (pszLastDot >= pszLastWhack)
            {
                // if the dot comes only in the last component, then get ext
                pszExt = pszLastDot + 1;  // +1 to skip last dot.
                *ppszLastSlash = pszLastWhack;
            }
        }
    }

    *ppszExt = pszExt;
}

const MIME_MAP_ENTRY *MIME_MAP::LookupMimeEntryForFileExt(
    IN LPWSTR pszPathName)
/*++
  Synopsis
    This function maps FileExtension to MimeEntry.
    The function returns a single mime entry for given file's extension.
    If no match is found, the default mime entry is returned.
    The returned entry is a readonly pointer and should not be altered.

    The file extension is the key field in the Hash table for mime entries.
    We can use the hash table lookup function to find the entry.

  Arguments:
    pszPathName
      pointer to string containing the path for file. (either full path or
      just the file name).  If NULL, then the default MimeMapEntry is returned.

  Returns:
    If a matching mime entry is found, a const pointer to MimeMapEntry
    object is returned.  Otherwise the default mime map entry object is
    returned.
--*/
{
    MIME_MAP_ENTRY *pMmeMatch = m_pMmeDefault;

    DBG_ASSERT( IsValid());

    if (pszPathName != NULL && *pszPathName)
    {
        LPWSTR pszExt;
        LPWSTR pszLastSlash;

        GetFileExtension(pszPathName, &pszExt, &pszLastSlash );
        DBG_ASSERT(pszExt);

        if (!wcscmp(pszExt, g_pszDefaultFileExt))
        {
            return m_pMmeDefault;
        }

        for (;;)
        {
            //
            // Successfully got extension. Search in the list of MimeEntries.
            //

            FindKey(pszExt, &pMmeMatch);
            pszExt--;

            if ( NULL == pMmeMatch)
            {
                pMmeMatch = m_pMmeDefault;

                // Look backwards for another '.' so we can support extensions
                // like ".xyz.xyz" or ".a.b.c".

                if (pszExt > pszLastSlash)
                {
                    pszExt--;
                    while ((pszExt > pszLastSlash) && (*pszExt != L'.'))
                    {
                        pszExt--;
                    }

                    if (*(pszExt++) != L'.')
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }
    }

    return pMmeMatch;
}

BOOL MIME_MAP::AddMimeMapEntry(IN MIME_MAP_ENTRY *pMmeNew)
{
    if (!wcscmp(pMmeNew->QueryFileExt(), g_pszDefaultFileExt))
    {
        m_pMmeDefault = pMmeNew;
        return TRUE;
    }

    if (InsertRecord(pMmeNew) == LK_SUCCESS)
    {
        return TRUE;
    }

    return FALSE;
}

BOOL MIME_MAP::CreateAndAddMimeMapEntry(
    IN  LPWSTR     pszMimeType,
    IN  LPWSTR     pszExtension)
{
    DWORD                   dwError;
    MIME_MAP_ENTRY   *pEntry = NULL;

    //
    // File extensions, stored by OLE/shell registration UI have leading
    // dot, we need to remove it , as other code won't like it.
    //
    if (pszExtension[0] == L'.')
    {
        pszExtension++;
    }

    //
    // First check if this extension is not yet present
    //
    FindKey(pszExtension, &pEntry);
    if (pEntry)
    {
        return TRUE;
    }

    MIME_MAP_ENTRY *pMmeNew;

    pMmeNew = new MIME_MAP_ENTRY(pszMimeType, pszExtension);

    if (!pMmeNew || !pMmeNew->IsValid())
    {
        //
        // unable to create a new MIME_MAP_ENTRY object.
        //
        if (pMmeNew)
        {
            delete pMmeNew;
        }
        return FALSE;
    }

    if (!AddMimeMapEntry(pMmeNew))
    {
        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     " Failed to add new MIME Entry. Error = %d\n",
                     dwError)
                   );

        delete pMmeNew;
        return FALSE;
    }

    return TRUE;
}

static BOOL ReadMimeMapFromMetabase(OUT MULTISZ *pmszMimeMap)
/*++
  Synopsis
    This function reads the mimemap stored either as a MULTI_SZ or as a
    sequence of REG_SZ and returns a double null terminated sequence of mime
    types on success. If there is any failure, the failures are ignored and
    it returns a NULL.

  Arguments:
    pmszMimeMap: MULTISZ which will contain the MimeMap on success

  Returns:
    BOOL
--*/
{
    MB mb(g_pW3Server->QueryMDObject());

    if (!mb.Open(L"/LM/MimeMap", METADATA_PERMISSION_READ))
    {
        //
        // if this fails, we're hosed.
        //
        DBGPRINTF((DBG_CONTEXT,"Open MD /LM/MimeMap returns %d\n", GetLastError()));
        return FALSE;
    }

    if (!mb.GetMultisz(L"", MD_MIME_MAP, IIS_MD_UT_FILE, pmszMimeMap))
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to read mime map from metabase: %d\n",GetLastError() ));
        mb.Close();
        return FALSE;
    }

    mb.Close();
    return TRUE;
}


static LPWSTR MMNextField(IN OUT LPWSTR *ppszFields)
/*++
    This function separates and terminates the next field and returns a
        pointer to the same.
    Also it updates the incoming pointer to point to start of next field.

    The fields are assumed to be separated by commas.

--*/
{
    LPTSTR pszComma;
    LPTSTR pszField = NULL;

    DBG_ASSERT( ppszFields != NULL);

    //
    // Look for a comma in the input.
    // If none present, assume that rest of string
    //  consists of the next field.
    //

    pszField  = *ppszFields;

    if ((pszComma = wcschr(*ppszFields, L',')) != NULL)
    {
        //
        //  update *ppszFields to contain the next field.
        //
        *ppszFields = pszComma + 1; // goto next field.
        *pszComma = L'\0';
    }
    else
    {
        //
        // Assume everything till end of string is the current field.
        //

        *ppszFields = *ppszFields + wcslen(*ppszFields) + 1;
    }

    pszField = ( *pszField == L'\0') ? NULL : pszField;
    return pszField;
}


static MIME_MAP_ENTRY *
ReadAndParseMimeMapEntry(IN OUT LPWSTR *ppszValues)
/*++
    This function parses the string containing next mime map entry and
        related fields and if successful creates a new MIME_MAP_ENTRY
        object and returns it.
    Otherwise it returns NULL.
    In either case, the incoming pointer is updated to point to next entry
     in the string ( past terminating NULL), assuming incoming pointer is a
     multi-string ( double null terminated).

    Arguments:
        ppszValues:  pointer to MULTISZ containing the MimeEntry values.

    Returns:
        On successful MIME_ENTRY being parsed, a new MIME_MAP_ENTRY object.
        On error returns NULL.
--*/
{
    MIME_MAP_ENTRY *pMmeNew = NULL;
    DBG_ASSERT( ppszValues != NULL);
    LPWSTR pszMimeEntry = *ppszValues;

    if ( pszMimeEntry != NULL && *pszMimeEntry != L'\0')
    {
        LPWSTR pszMimeType;
        LPWSTR pszFileExt;

        pszFileExt      = MMNextField(ppszValues);
        pszMimeType     = MMNextField(ppszValues);

        if ((pszMimeType == NULL)  ||
            (pszFileExt == NULL))
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        " ReadAndParseMimeEntry()."
                        " Invalid Mime String ( %S)."
                        "MimeType( %08x): %S, FileExt( %08x): %S\n",
                        pszMimeEntry,
                        pszMimeType, pszMimeType,
                        pszFileExt,  pszFileExt
                        ));

            DBG_ASSERT( pMmeNew == NULL);

        }
        else
        {
            // Strip leading dot.

            if (*pszFileExt == '.')
            {
                pszFileExt++;
            }

            pMmeNew = new MIME_MAP_ENTRY( pszMimeType, pszFileExt);

            if ( pMmeNew != NULL && !pMmeNew->IsValid())
            {
                //
                // unable to create a new MIME_MAP_ENTRY object. Delete it.
                //
                delete pMmeNew;
                pMmeNew = NULL;
            }
        }
    }

    return pMmeNew;
}


MIME_MAP::MIME_MAP(LPWSTR pszMimeMappings)
    : CTypedHashTable<MIME_MAP, MIME_MAP_ENTRY, LPWSTR>("MimeMapper"),
    m_fValid                                           (TRUE),
    m_pMmeDefault                                      (NULL)
{
    while (*pszMimeMappings != L'\0')
    {
        MIME_MAP_ENTRY *pMmeNew;

        pMmeNew = ReadAndParseMimeMapEntry(&pszMimeMappings);

        //
        // If New MimeMap entry found, Create a new object and update list
        //

        if ((pMmeNew != NULL) &&
            !AddMimeMapEntry(pMmeNew))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "MIME_MAP::InitFromRegistry()."
                       " Failed to add new MIME Entry. Error = %d\n",
                       GetLastError()));

            delete pMmeNew;
        }
    } // while
}


HRESULT MIME_MAP::InitFromMetabase()
/*++
  Synopsis
    This function reads the MIME_MAP entries from metabase and parses
    the entry, creates MIME_MAP_ENTRY object and adds the object to list
    of MimeMapEntries.

  Returns:
    HRESULT

  Format of Storage in registry:
    The entries are stored in NT in tbe metabase with a list of values in
    following format: file-extension, mimetype

--*/
{
    HRESULT hr = S_OK;


    LPTSTR  pszValueAlloc = NULL;
    LPTSTR  pszValue;
    MULTISZ mszMimeMap;

    //
    //  There is some registry key for Mime Entries. Try open and read.
    //
    if (!ReadMimeMapFromMetabase(&mszMimeMap))
    {
        mszMimeMap.Reset();

        if (!mszMimeMap.Append(g_pszDefaultMimeEntry))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // Ignore all errors.
    hr = S_OK;

    pszValue = (LPWSTR)mszMimeMap.QueryPtr();

    //
    // Parse each MimeEntry in the string containing list of mime objects.
    //
    for (; m_pMmeDefault == NULL; pszValue = g_pszDefaultMimeEntry)
    {
        while (*pszValue != L'\0')
        {
            MIME_MAP_ENTRY *pMmeNew;

            pMmeNew = ReadAndParseMimeMapEntry( &pszValue);

            //
            // If New MimeMap entry found, Create a new object and update list
            //

            if ((pMmeNew != NULL) &&
                !AddMimeMapEntry(pMmeNew))
            {
                DBGPRINTF((DBG_CONTEXT,
                           "MIME_MAP::InitFromRegistry()."
                           " Failed to add new MIME Entry. Error = %d\n",
                           GetLastError()));

                delete pMmeNew;
            }
        } // while
    } // for

    return hr;
}


HRESULT MIME_MAP::InitFromRegistryChicagoStyle()
/*++
  Synopsis
    This function reads the list of MIME content-types available for
    registered file extensions. Global list of MIME objects is updated with
    not yet added extensions.  This method should be invoked after
    server-specific map had been read, so it does not overwrite extensions
    common for two.

  Arguments:
     None.

  Returns:
    HRESULT
--*/
{
    HKEY  hkeyMimeMap = NULL;
    HKEY  hkeyMimeType = NULL;
    HKEY  hkeyExtension = NULL;


    DWORD dwIndexSubKey;
    DWORD dwMimeSizeAllowed;
    DWORD dwType;
    DWORD cbValue;

    LPWSTR  pszMimeMap = NULL;

    WCHAR   szSubKeyName[MAX_PATH];
    WCHAR   szExtension[MAX_PATH];

    LPWSTR  pszMimeType;

    //
    // Read content types from all registered extensions
    //
    DWORD dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT,   // hkey
                                 L"",                 // reg entry string
                                 0,                   // dwReserved
                                 KEY_READ,            // access
                                 &hkeyMimeMap);       // pHkeyReturned.

    if ( dwError != NO_ERROR)
    {
        DBGPRINTF( ( DBG_CONTEXT,
                "MIME_MAP::InitFromRegistry(). Cannot open RegKey %s."
                "Error = %d\n",
                "HKCR_",
                dwError) );

          goto AddDefault;
    }

    dwIndexSubKey = 0;

    *szSubKeyName = '\0';
    pszMimeType = szSubKeyName ;

    dwError = RegEnumKey(hkeyMimeMap,
                         dwIndexSubKey,
                         szExtension,
                         sizeof(szExtension)/sizeof(WCHAR));

    while (dwError == ERROR_SUCCESS)
    {
        //
        // Some entries in HKEY_CLASSES_ROOT are extensions ( start with dot)
        // and others are file types. We don't need file types here .
        //
        if (L'.' == *szExtension)
        {
            //
            // Got next eligible extension
            //
            dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT, // hkey
                                   szExtension,       // reg entry string
                                   0,                 // dwReserved
                                   KEY_READ,          // access
                                   &hkeyExtension);   // pHkeyReturned.

            if (dwError != NO_ERROR)
            {
                DBGPRINTF( ( DBG_CONTEXT,
                             "MIME_MAP::InitFromRegistry(). "
                             " Cannot open RegKey HKEY_CLASSES_ROOT\\%S."
                             "Ignoring Error = %d\n",
                             szExtension,
                             dwError));
                break;
            }

            //
            // Now get content type for this extension if present
            //
            *szSubKeyName = '\0';
            cbValue = sizeof szSubKeyName;

            dwError = RegQueryValueEx(hkeyExtension,
                                      L"Content Type",
                                      NULL,
                                      &dwType,
                                      (LPBYTE)&szSubKeyName[0],
                                      &cbValue);
            if (dwError == NO_ERROR)
            {
                //
                // Now we have MIME type and file extension
                // Create a new object and update list
                //

                if (!CreateAndAddMimeMapEntry(szSubKeyName, szExtension))
                {
                    dwError = GetLastError();

                    DBGPRINTF((DBG_CONTEXT,
                               "MIME_MAP::InitFromRegistry()."
                               " Failed to add new MIME Entry. Error = %d\n",
                               dwError)) ;
                }
            }

            RegCloseKey(hkeyExtension);
        }

        //
        // Attempt to read next extension
        //
        dwIndexSubKey++;

        dwError = RegEnumKey(hkeyMimeMap,
                             dwIndexSubKey,
                             szExtension,
                             sizeof(szExtension)/sizeof(WCHAR));
    } // end_while

    dwError = RegCloseKey( hkeyMimeMap);

AddDefault:

    //
    // Now after we are done with registry mapping - add default MIME type
    // in case if NT database does not exist
    //
    if (!CreateAndAddMimeMapEntry(g_pszDefaultMimeType,
                                  g_pszDefaultFileExt))
    {
        dwError = GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     "MIME_MAP::InitFromRegistry()."
                     "Failed to add new MIME Entry. Error = %d\n",
                     dwError) );
    }

    return S_OK;
}

HRESULT InitializeMimeMap(IN LPWSTR pszRegEntry)
/*++

  Creates a new mime map object and loads the registry entries from
    under this entry from  \\MimeMap.

--*/
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT(g_pMimeMap == NULL);

    g_pMimeMap = new MIME_MAP();

    if (g_pMimeMap == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr = g_pMimeMap->InitMimeMap()))
    {
        DBGPRINTF((DBG_CONTEXT,"InitMimeMap failed with hr %x\n", hr));
    }

    return hr;
} // InitializeMimeMap()


VOID CleanupMimeMap()
{
    if ( g_pMimeMap != NULL)
    {
         delete g_pMimeMap;
         g_pMimeMap = NULL;
   }
} // CleanupMimeMap()

HRESULT SelectMimeMappingForFileExt(IN  WCHAR    *pszFilePath,
                                    IN  MIME_MAP *pMimeMap,
                                    OUT STRA     *pstrMimeType)
/*++
  Synopsis
    Obtains the mime type for file based on the file extension.

  Arguments
    pszFilePath     pointer to path for the given file
    pstrMimeType    pointer to string to store the mime type on return

  Returns:
    HRESULT
--*/
{
    HRESULT hr = S_OK;

    DBG_ASSERT (pstrMimeType != NULL);

    const MIME_MAP_ENTRY *pMmeMatch = NULL;

    //
    // Lookup in the metabase entry
    //
    if (pMimeMap)
    {
        pMmeMatch = pMimeMap->LookupMimeEntryForFileExt(pszFilePath);
    }

    //
    // If not found, lookup in the global entry
    //
    if (!pMmeMatch)
    {
        pMmeMatch = g_pMimeMap->LookupMimeEntryForFileExt(pszFilePath);
    }

    DBG_ASSERT(pMmeMatch != NULL);

    return pstrMimeType->CopyWTruncate(pMmeMatch->QueryMimeType());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\range.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     range.cxx

   Abstract:
     Handle Range Requests

   Author:
     Anil Ruia (AnilR)            29-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     UlW3.dll
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

#define RANGE_BOUNDARY  "<q1w2e3r4t5y6u7i8o9p0zaxscdvfbgnhmjklkl>"


extern BOOL FindInETagList(CHAR * pLocalETag,
                           CHAR * pETagList,
                           BOOL   fWeakCompare);


STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeContentType;
STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeMidDelimiter;
STRA  *W3_STATIC_FILE_HANDLER::sm_pstrRangeEndDelimiter;


// static
HRESULT W3_STATIC_FILE_HANDLER::Initialize()
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_STATIC_FILE_HANDLER );

    DBG_ASSERT( sm_pachStaticFileHandlers == NULL );
    
    sm_pachStaticFileHandlers = new ALLOC_CACHE_HANDLER( "W3_STATIC_FILE_HANDLER",  
                                                         &acConfig );

    if ( sm_pachStaticFileHandlers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    //
    // Initialize the various Range Strings
    //
    sm_pstrRangeContentType = new STRA;
    sm_pstrRangeMidDelimiter = new STRA;
    sm_pstrRangeEndDelimiter = new STRA;
    if (sm_pstrRangeContentType == NULL ||
        sm_pstrRangeMidDelimiter == NULL ||
        sm_pstrRangeEndDelimiter == NULL)
    {
        delete sm_pachStaticFileHandlers;
        sm_pachStaticFileHandlers = NULL;
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr = sm_pstrRangeContentType->Copy(
                        "multipart/byteranges; boundary=")) ||
        FAILED(hr = sm_pstrRangeContentType->Append(RANGE_BOUNDARY)))
    {
        delete sm_pachStaticFileHandlers;
        sm_pachStaticFileHandlers = NULL;
        return hr;
    }

    if (FAILED(hr = sm_pstrRangeMidDelimiter->Copy("--")) ||
        FAILED(hr = sm_pstrRangeMidDelimiter->Append(RANGE_BOUNDARY)) ||
        FAILED(hr = sm_pstrRangeMidDelimiter->Append("\r\n")))
    {
        delete sm_pachStaticFileHandlers;
        sm_pachStaticFileHandlers = NULL;
        return hr;
    }

    if (FAILED(hr = sm_pstrRangeEndDelimiter->Copy("\r\n--")) ||
        FAILED(hr = sm_pstrRangeEndDelimiter->Append(RANGE_BOUNDARY)) ||
        FAILED(hr = sm_pstrRangeEndDelimiter->Append("--\r\n\r\n")))
    {
        delete sm_pachStaticFileHandlers;
        sm_pachStaticFileHandlers = NULL;
        return hr;
    }

    return S_OK;
}


BOOL ScanRange(CHAR *        *ppszRange,
               LARGE_INTEGER  liFileSize,
               LARGE_INTEGER *pliOffset,
               LARGE_INTEGER *pliSize,
               BOOL          *pfInvalidRange)
/*++
  Routine Description:
    Scan the next range in strRange

  Returns:
    TRUE if a range was found, else FALSE

  Arguments:
    ppszRange       String pointing to the current range.
    liFileSize      Size of the file being retrieved
    pliOffset       range offset on return
    pliSizeTo       range size on return
    pfInvalidRange  set to TRUE on return if Invalid syntax
--*/
{
    CHAR *pszRange = *ppszRange;
    CHAR c;

    //
    // Skip to begining of next range
    //
    while ((c = *pszRange) && (c == ' '))
    {
        ++pszRange;
    }

    //
    // Test for no range
    //
    if (*pszRange == '\0')
    {
        return FALSE;
    }

    //
    // determine Offset & Size to send
    //
    if (*pszRange == '-')
    {
        //
        // This is in format -nnn which means send bytes filesize-nnn
        // to eof
        //
        ++pszRange;

        if (!isdigit(*pszRange))
        {
            *pfInvalidRange = TRUE;
            return TRUE;
        }

        pliSize->QuadPart = _atoi64(pszRange);
        if (pliSize->QuadPart > liFileSize.QuadPart)
        {
            pliSize->QuadPart = liFileSize.QuadPart;
            pliOffset->QuadPart = 0;
        }
        else
        {
            pliOffset->QuadPart = liFileSize.QuadPart - pliSize->QuadPart;
        }
    }
    else if (isdigit(*pszRange))
    {
        //
        // This is in format mmm-nnn which menas send bytes mmm to nnn
        //         or format mmm- which means send bytes mmm to eof
        //
        pliOffset->QuadPart = _atoi64(pszRange);

        //
        // Skip over the beginning number - and any intervening spaces
        //
        while((c = *pszRange) && isdigit(c))
        {
            pszRange++;
        }

        while((c = *pszRange) && (c == ' '))
        {
            pszRange++;
        }

        if (*pszRange != '-')
        {
            *pfInvalidRange = TRUE;
            return TRUE;
        }
        pszRange++;

        while((c = *pszRange) && (c == ' '))
        {
            pszRange++;
        }

        if (isdigit(*pszRange))
        {
            //
            // We have mmm-nnn
            //
            LARGE_INTEGER liEnd;
            liEnd.QuadPart = _atoi64(pszRange);
            if (liEnd.QuadPart < pliOffset->QuadPart)
            {
                *pfInvalidRange = TRUE;
                return TRUE;
            }

            if (liEnd.QuadPart >= liFileSize.QuadPart)
            {
                pliSize->QuadPart = liFileSize.QuadPart - pliOffset->QuadPart;
            }
            else
            {
                pliSize->QuadPart = liEnd.QuadPart - pliOffset->QuadPart + 1;
            }
        }
        else
        {
            //
            // We have mmm-
            //
            pliSize->QuadPart = liFileSize.QuadPart - pliOffset->QuadPart;
        }
    }
    else
    {
        //
        // Invalid Syntax
        //
        *pfInvalidRange = TRUE;
        return TRUE;
    }

    //
    // Skip to the start of the next range
    //
    while ((c = *pszRange) && isdigit(c))
    {
        ++pszRange;
    }

    while ((c = *pszRange) && c == ' ')
    {
        ++pszRange;
    }

    if (c == ',')
    {
        ++pszRange;
    }
    else if (c != '\0')
    {
        *pfInvalidRange = TRUE;
        return TRUE;
    }

    *ppszRange = pszRange;
    return TRUE;
}


HRESULT W3_STATIC_FILE_HANDLER::RangeDoWork(W3_CONTEXT   *pW3Context,
                                            W3_FILE_INFO *pOpenFile,
                                            BOOL         *pfHandled)
{
    W3_REQUEST  *pRequest  = pW3Context->QueryRequest();
    W3_RESPONSE *pResponse = pW3Context->QueryResponse();

    // First, handle If-Range: if it exists.  If the If-Range matches we
    // don't do anything. If the If-Range doesn't match then we force
    // retrieval of the whole file.

    CHAR * pszIfRange = pRequest->GetHeader(HttpHeaderIfRange);
    if (pszIfRange != NULL && *pszIfRange != L'\0')
    {
        // Need to determine if what we have is a date or an ETag.
        // An ETag may start with a W/ or a quote. A date may start
        // with a W but will never have the second character be a /.

        if (*pszIfRange == L'"' ||
            (*pszIfRange == L'W' && pszIfRange[1] == L'/'))
        {
            // This is an ETag.
            if (pOpenFile->QueryIsWeakETag() ||
                !FindInETagList(pOpenFile->QueryETag(),
                                pszIfRange,
                                FALSE))
            {
                // The If-Range failed, so we can't send a range. Force
                // sending the whole thing.
                *pfHandled = FALSE;
                return S_OK;
            }
        }
        else
        {
            // This is a date
            LARGE_INTEGER   liRangeTime;

            // This must be a date. Convert it to a time, and see if it's
            // less than or equal to our last write time. If it is, the
            // file's changed, and we can't perform the range.

            if (!StringTimeToFileTime(pszIfRange, &liRangeTime))
            {
                // Couldn't convert it, so don't send the range.
                *pfHandled = FALSE;
                return S_OK;
            }
            else
            {
                FILETIME tm;
                
                pOpenFile->QueryLastWriteTime(&tm);

                if (*(LONGLONG*)&tm > liRangeTime.QuadPart )
                {
                    // The If-Range failed, so we can't send a range. Force
                    // sending the whole thing.
                    *pfHandled = FALSE;
                    return S_OK;
                }
            }
        }
    }

    // If we fell through, then If-Range passed, we are going to try sending
    // a range response
    CHAR * pszRange = pRequest->GetHeader(HttpHeaderRange);
    //
    // We have bytes = <range1>, <range2>, ...
    // skip past the '='
    //
    pszRange = strchr(pszRange, '=');
    if (pszRange == NULL)
    {
        // Invalid syntax, send entire file
        *pfHandled = FALSE;
        return S_OK;
    }
    pszRange++;

    LARGE_INTEGER liFileSize;
    HRESULT hr = S_OK;
    pOpenFile->QuerySize(&liFileSize);
    if (liFileSize.QuadPart <= 0)
    {
        pResponse->ClearHeaders();
        pResponse->SetStatus(HttpStatusRangeNotSatisfiable);

        CHAR pszContentRange[24];
        strcpy(pszContentRange, "bytes */");
        _i64toa(liFileSize.QuadPart, pszContentRange + 8, 10);
        if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                             pszContentRange,
                                             strlen(pszContentRange))))
        {
            return hr;
        }

        *pfHandled = TRUE;
        return S_OK;
    }

    DWORD cRanges = 0;
    STACK_BUFFER( bufByteRange, 256);
    HTTP_BYTE_RANGE *pByteRange;
    LARGE_INTEGER liRangeOffset;
    LARGE_INTEGER liRangeSize;
    BOOL fInvalidSyntax = FALSE;
    BOOL fAtLeastOneRange = FALSE;

    while (ScanRange(&pszRange,
                     liFileSize,
                     &liRangeOffset,
                     &liRangeSize,
                     &fInvalidSyntax))
    {
        fAtLeastOneRange = TRUE;

        if (fInvalidSyntax)
        {
            //
            // Invalid syntax in Range header.  Ignore Range headers,
            // Send complete File.
            //
            *pfHandled = FALSE;
            return S_OK;
        }

        if (liRangeOffset.QuadPart > liFileSize.QuadPart ||
            liRangeSize.QuadPart == 0)
        {
            //
            // The Range is not satisfiable
            //
            continue;
        }

        cRanges++;

        if (cRanges * sizeof(HTTP_BYTE_RANGE) > bufByteRange.QuerySize())
        {
            if (!bufByteRange.Resize(cRanges * sizeof(HTTP_BYTE_RANGE), 256))
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        pByteRange = (HTTP_BYTE_RANGE *)bufByteRange.QueryPtr();
        pByteRange[cRanges - 1].StartingOffset = liRangeOffset;
        pByteRange[cRanges - 1].Length         = liRangeSize;
    }

    if (!fAtLeastOneRange)
    {
        //
        // Syntactically invalid, ignore the range header
        //
        *pfHandled = FALSE;
        return S_OK;
    }

    if (cRanges == 0)
    {
        //
        // No byte ranges are satisfiable
        //
        pResponse->ClearHeaders();
        pResponse->SetStatus(HttpStatusRangeNotSatisfiable);

        CHAR pszContentRange[24];
        strcpy(pszContentRange, "bytes */");
        _i64toa(liFileSize.QuadPart, pszContentRange + 8, 10);
        if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                             pszContentRange,
                                             strlen(pszContentRange))))
        {
            return hr;
        }

        *pfHandled = TRUE;
        return S_OK;
    }

    *pfHandled = TRUE;
    pResponse->SetStatus(HttpStatusPartialContent);
    STRA *pstrContentType = pW3Context->QueryUrlContext()->QueryUrlInfo()->
        QueryContentType();

    STACK_STRA ( strPartContentType, 128);
    if (cRanges == 1)
    {
        //
        // Only one chunk, Content-Type is same as that of complete entity
        //
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderContentType,
                            pstrContentType->QueryStr(),
                            pstrContentType->QueryCCH())))
        {
            return hr;
        }
    }
    else
    {
        //
        // Content-Type is multipart/byteranges; boundary=....
        //
        if (FAILED(hr = pResponse->SetHeaderByReference(
                            HttpHeaderContentType,
                            sm_pstrRangeContentType->QueryStr(),
                            sm_pstrRangeContentType->QueryCCH())))
        {
            return hr;
        }

        //
        // The actual content-type of the entity to be sent with each part
        //
        if (FAILED(hr = strPartContentType.Copy("Content-Type: ")) ||
            FAILED(hr = strPartContentType.Append(*pstrContentType)) ||
            FAILED(hr = strPartContentType.Append("\r\n")))
        {
            return hr;
        }
    }

    //
    // build the response
    //
    STRA strContentRange;
    STRA strDelimiter;
    pByteRange = (HTTP_BYTE_RANGE *)bufByteRange.QueryPtr();
    for (DWORD i = 0; i < cRanges; i++)
    {
        liRangeOffset = pByteRange[i].StartingOffset;
        liRangeSize   = pByteRange[i].Length;

        //
        // Build up the Content-Range header
        //
        CHAR pszSize[24];
        if (FAILED(hr = strContentRange.Copy("bytes ")))
        {
            return hr;
        }
        _i64toa(liRangeOffset.QuadPart, pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)) ||
            FAILED(hr = strContentRange.Append("-")))
        {
            return hr;
        }
        _i64toa(liRangeOffset.QuadPart + liRangeSize.QuadPart - 1,
                pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)) ||
            FAILED(hr = strContentRange.Append("/")))
        {
            return hr;
        }
        _i64toa(liFileSize.QuadPart, pszSize, 10);
        if (FAILED(hr = strContentRange.Append(pszSize)))
        {
            return hr;
        }

        if (cRanges == 1)
        {
            //
            // If only one chunk, send Content-Range as a header
            //
            if (FAILED(hr = pResponse->SetHeader(HttpHeaderContentRange,
                                                 strContentRange.QueryStr(),
                                                 strContentRange.QueryCCH())))
            {
                return hr;
            }
        }
        else
        {
            if (i > 0)
            {
                // Already sent a range, add a newline
                if (FAILED(hr = strDelimiter.Copy("\r\n", 2)))
                {
                    return hr;
                }
            }

            //
            // Add delimiter, Content-Type, Content-Range
            //
            if (FAILED(hr = strDelimiter.Append(*sm_pstrRangeMidDelimiter)) ||
                FAILED(hr = strDelimiter.Append(strPartContentType)) ||
                FAILED(hr = strDelimiter.Append("Content-Range: ", 15)) ||
                FAILED(hr = strDelimiter.Append(strContentRange)) ||
                FAILED(hr = strDelimiter.Append("\r\n\r\n", 4)))
            {
                return hr;
            }

            //
            // store the ANSI version in the BUFFER chain
            //
            DWORD bufSize = strDelimiter.QueryCCH() + 1;
            BUFFER_CHAIN_ITEM *pBCI = new BUFFER_CHAIN_ITEM(bufSize);
            if (pBCI == NULL)
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            memcpy(pBCI->QueryPtr(),
                   strDelimiter.QueryStr(),
                   bufSize);
            if (!m_RangeBufferChain.AppendBuffer(pBCI))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            //
            // Now actually add this delimiter chunk
            //
            if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                                           pBCI->QueryPtr(),
                                           bufSize - 1)))
            {
                return hr;
            }
        }

        //
        // Add the actual file chunk
        //
        if (pOpenFile->QueryFileBuffer() != NULL &&
            liRangeSize.HighPart == 0 &&
            liRangeOffset.HighPart == 0)
        {
            hr = pResponse->AddMemoryChunkByReference(
                     pOpenFile->QueryFileBuffer() + liRangeOffset.LowPart,
                     liRangeSize.LowPart);
        }
        else
        {
            hr = pResponse->AddFileHandleChunk( pOpenFile->QueryFileHandle(),
                                                liRangeOffset.QuadPart,
                                                liRangeSize.QuadPart );
        }

        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (cRanges > 1)
    {
        //
        // Add the terminating delimiter
        //
        if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                            sm_pstrRangeEndDelimiter->QueryStr(),
                            sm_pstrRangeEndDelimiter->QueryCCH())))
        {
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\options_handler.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module Name :
     options_handler.cxx

   Abstract:
     Handle OPTIONS requests

   Author:
     Anil Ruia (AnilR)              4-Apr-2001

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "options_handler.hxx"

CONTEXT_STATUS
W3_OPTIONS_HANDLER::DoWork()
/*++

Routine Description:

    Do the OPTIONS thing if DAV is disabled

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT hr;
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT(pW3Context != NULL);

    W3_RESPONSE *pW3Response = pW3Context->QueryResponse();

    W3_REQUEST *pW3Request = pW3Context->QueryRequest();
    STACK_STRU (strUrl, 32);

    if (FAILED(hr = pW3Response->SetHeader(HEADER("Public"),
                                           HEADER("OPTIONS, TRACE, GET, HEAD, POST"))))
    {
        goto Failed;
    }

    if (FAILED(hr = pW3Request->GetUrl(&strUrl)))
    {
        goto Failed;
    }

    if (wcscmp(strUrl.QueryStr(), L"*") != 0 &&
        wcscmp(strUrl.QueryStr(), L"/*") != 0)
    {
        //
        // Add Allow header
        //
        if (FAILED(hr = pW3Context->SetupAllowHeader()))
        {
            goto Failed;
        }

        //
        // Also figure out whether Frontpage is enabled and send
        // MS-Author-Via header if so
        // Cannot store it with the metadata since we do not want to pick
        // up the inherited value, can store with url-info but deferred
        // for later (BUGBUG)
        //
        MB mb( g_pW3Server->QueryMDObject() );
        BOOL fIsFrontPageWeb;

        if (!mb.Open(pW3Context->QuerySite()->QueryMBRoot()->QueryStr()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Failed;
        }

        if (mb.GetDword(strUrl.QueryStr(),
                        MD_FRONTPAGE_WEB,
                        IIS_MD_UT_SERVER,
                        (DWORD *)&fIsFrontPageWeb,
                        METADATA_NO_ATTRIBUTES) &&
            fIsFrontPageWeb)
        {
            if (FAILED(hr = pW3Response->SetHeader("MS-Author-Via",
                                                   sizeof("MS-Author-Via") - 1,
                                                   "MS-FP/4.0",
                                                   sizeof("MS-FP/4.0") - 1)))
            {
                goto Failed;
            }
        }

        DBG_REQUIRE( mb.Close() );
    }
    else
    {
        pW3Response->SetHeaderByReference(HttpHeaderAllow,
                                          HEADER("OPTIONS, TRACE, GET, HEAD, POST"));
    }

    if (FAILED(hr = pW3Context->SendResponse(W3_FLAG_ASYNC)))
    {
        goto Failed;
    }

    return CONTEXT_STATUS_PENDING;

 Failed:
    pW3Context->SetErrorStatus(hr);
    pW3Response->SetStatus(HttpStatusServerError);
    pW3Context->SendResponse(W3_FLAG_SYNC);

    return CONTEXT_STATUS_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\rawconnection.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     rawconnection.cxx

   Abstract:
     ISAPI raw data filter support
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"

RAW_CONNECTION_HASH *    RAW_CONNECTION::sm_pRawConnectionHash;

RAW_CONNECTION::RAW_CONNECTION(
    CONNECTION_INFO *           pConnectionInfo
)
{
    _cRefs = 1;
    _pMainContext = NULL;
    _dwCurrentFilter = INVALID_DLL;
    
    DBG_ASSERT( pConnectionInfo != NULL );

    _hfc.cbSize             = sizeof( _hfc );
    _hfc.Revision           = HTTP_FILTER_REVISION;
    _hfc.ServerContext      = (void *) this;
    _hfc.ulReserved         = 0;
    _hfc.fIsSecurePort      = pConnectionInfo->fIsSecure;
    _hfc.pFilterContext     = NULL;

    _hfc.ServerSupportFunction = RawFilterServerSupportFunction;
    _hfc.GetServerVariable     = RawFilterGetServerVariable;
    _hfc.AddResponseHeaders    = RawFilterAddResponseHeaders;
    _hfc.WriteClient           = RawFilterWriteClient;
    _hfc.AllocMem              = RawFilterAllocateMemory;

    ZeroMemory( &_rgContexts, sizeof( _rgContexts ) );
    
    InitializeListHead( &_PoolHead );

    _pfnSendDataBack = pConnectionInfo->pfnSendDataBack;
    _pvStreamContext = pConnectionInfo->pvStreamContext;
    _LocalPort = pConnectionInfo->LocalPort;
    _LocalAddress = pConnectionInfo->LocalAddress;
    _RemotePort = pConnectionInfo->RemotePort;
    _RemoteAddress = pConnectionInfo->RemoteAddress;
    _RawConnectionId = pConnectionInfo->RawConnectionId;
    
    _dwSignature = RAW_CONNECTION_SIGNATURE;
}

RAW_CONNECTION::~RAW_CONNECTION()
{
    FILTER_POOL_ITEM *          pfpi;
    
    _dwSignature = RAW_CONNECTION_SIGNATURE_FREE;

    //
    // Free pool items (is most cases there won't be any since they will
    // have been migrated to the W3_FILTER_CONNECTION_CONTEXT)
    //

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        delete pfpi;
    }
    
    //
    // Disconnect raw connection from main context
    //
    
    if ( _pMainContext != NULL )
    {
        _pMainContext->DereferenceMainContext();
        _pMainContext = NULL;
    }
}

//static
HRESULT
RAW_CONNECTION::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ISAPI raw data filter crap

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    FILTER_LIST *           pFilterList;
    BOOL                    fSSLOnly = TRUE;
    HRESULT                 hr;
    STREAM_FILTER_CONFIG    sfConfig;

    DBG_ASSERT( g_pW3Server != NULL );
    
    DBG_ASSERT( sm_pRawConnectionHash == NULL );
    
    //
    // Create a UL_RAW_CONNECTION_ID keyed hash table
    //
    
    sm_pRawConnectionHash = new RAW_CONNECTION_HASH;
    if ( sm_pRawConnectionHash == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Is there a read raw data filter enabled?
    //
    
    pFilterList = FILTER_LIST::QueryGlobalList();
    if ( pFilterList != NULL )
    {
        if ( pFilterList->IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                                FALSE ) )
        {
            fSSLOnly = FALSE;
        }
    }
    
    //
    // Now initialize stream filter DLL
    //
    
    sfConfig.fSslOnly = fSSLOnly;
    sfConfig.pfnRawRead = RAW_CONNECTION::ProcessRawRead;    
    sfConfig.pfnRawWrite = RAW_CONNECTION::ProcessRawWrite;
    sfConfig.pfnConnectionClose = RAW_CONNECTION::ProcessConnectionClose;
    sfConfig.pfnNewConnection = RAW_CONNECTION::ProcessNewConnection;
    
    hr = StreamFilterInitialize( &sfConfig );
    if ( FAILED( hr ) )
    {
        delete sm_pRawConnectionHash;
        sm_pRawConnectionHash = NULL;
        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
RAW_CONNECTION::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate raw connection hash table

Arguments:

    None
    
Return Value:

    None

--*/
{
    StreamFilterTerminate();
    
    if ( sm_pRawConnectionHash != NULL )
    {
        delete sm_pRawConnectionHash;
        sm_pRawConnectionHash = NULL;
    }
}

//static
HRESULT
RAW_CONNECTION::StopListening(
    VOID
)
/*++

Routine Description:

    Begin shutdown by preventing further raw stream messages from UL

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    StreamFilterStop();
    
    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::StartListening(
    VOID
)
/*++

Routine Description:

    Start listening for stream messages from UL.  Unlike UlAtqStartListen(),
    this routine does NOT block and will return once the initial number
    of outstanding UlFilterAccept() requests have been made

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    return StreamFilterStart();
}

FILTER_LIST *
RAW_CONNECTION::QueryFilterList(
    VOID
)
/*++

Routine Description:

    Return the appropriate filter list to notify.  Before a W3_CONNECTION
    is established, this list will simply be the global filter list.  But 
    once the W3_CONNECTION is established, the list will be the appropriate
    instance filter list

Arguments:

    None
    
Return Value:

    FILTER_LIST *

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext = NULL;
    FILTER_LIST *               pFilterList = FILTER_LIST::QueryGlobalList();
    
    if ( _pMainContext != NULL )
    {
        pFilterContext = _pMainContext->QueryFilterContext();
        if ( pFilterContext != NULL )
        {
            pFilterList = pFilterContext->QueryFilterList();
            DBG_ASSERT( pFilterList != NULL );
        }
    }
    
    return pFilterList;
}

BOOL
RAW_CONNECTION::QueryNotificationChanged(
    VOID
)
/*++

Routine Description:

    Returns whether or not any notifications have been disabled on the fly

Arguments:

    None
    
Return Value:

    BOOL

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    
    if ( _pMainContext == NULL )
    {
        //
        // BUGBUG
        //
        // This isn't totally correct.  I guess a read raw filter could
        // disable any more notifications for itself before a
        // W3_CONNECTION is created.  This is really corner
        //
        
        return FALSE;
    }
    else
    {
        pFilterContext = _pMainContext->QueryFilterContext();
        if ( pFilterContext == NULL )
        {
            return FALSE;
        }
        else
        {
            return pFilterContext->QueryNotificationChanged();
        }
    }
}

BOOL
RAW_CONNECTION::IsDisableNotificationNeeded(
    DWORD                   dwFilter,
    DWORD                   dwNotification
)
/*++

Routine Description:

    If a notification was disabled on the fly, then this routine goes thru
    the notification copy path to find whether the given notification is
    indeed enabled

Arguments:

    dwFilter - Filter number
    dwNotification - Notification to check for
    
Return Value:

    BOOL (TRUE is the notification is needed)

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;

    //
    // The only way we could be here is if we determined notifications were
    // disabled.  That can only happen if we found a W3_CONNECTION associated
    //

    DBG_ASSERT( _pMainContext != NULL );
    pFilterContext = _pMainContext->QueryFilterContext();
    DBG_ASSERT( pFilterContext != NULL );
    
    return pFilterContext->IsDisableNotificationNeeded( dwFilter,
                                                        dwNotification );
    
}

PVOID
RAW_CONNECTION::QueryClientContext(
    DWORD                   dwFilter
)
/*++

Routine Description:

    Retrieve the filter client context for the given filter

Arguments:

    dwFilter - Filter number
    
Return Value:

    Context pointer

--*/
{
    //
    // If we have a main context associated, then use its merged context 
    // list
    //
    
    if ( _pMainContext == NULL )
    {
        return _rgContexts[ dwFilter ];
    }
    else
    {
        return _pMainContext->QueryFilterContext()->QueryClientContext( dwFilter ); 
    }
}

VOID
RAW_CONNECTION::SetClientContext(
    DWORD                   dwFilter,
    PVOID                   pvContext
)
/*++

Routine Description:

    Set client context for the given filter

Arguments:

    dwFilter - Filter number
    pvContext - Client context
    
Return Value:

    None

--*/
{
    //
    // If we have a main context, use its merged context list
    //
   
    if ( _pMainContext == NULL )
    {
        _rgContexts[ dwFilter ] = pvContext;
    } 
    else
    {
        _pMainContext->QueryFilterContext()->SetClientContext( dwFilter,
                                                               pvContext );
    }
}

HRESULT
RAW_CONNECTION::GetLimitedServerVariables(
    LPSTR                       pszVariableName,
    PVOID                       pvBuffer,
    PDWORD                      pdwSize
)
/*++

Routine Description:

    Get the server variables which are possible given that we haven't parsed
    the HTTP request yet

Arguments:

    pszVariableName - Variable name
    pvBuffer - Buffer to receive variable data
    pdwSize - On input size of buffer, on output the size needed
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA(         strVariable, 256 );
    HRESULT             hr = NO_ERROR;
    CHAR                achNumber[ 64 ];
   
    if ( strcmp( pszVariableName, "SERVER_PORT" ) == 0 || 
         strcmp( pszVariableName, "REMOTE_PORT" ) == 0 )
    {
        _itoa( pszVariableName[ 0 ] == 'S' ? 
                _LocalPort : _RemotePort,
              achNumber,
              10 );
        
        hr = strVariable.Copy( achNumber );
    } 
    else if ( strcmp( pszVariableName, "REMOTE_ADDR" ) == 0 || 
              strcmp( pszVariableName, "LOCAL_ADDR" ) == 0 )
    {
        DWORD           dwAddr;
        CHAR            szAddr[16];
        in_addr         inAddr;
        
        dwAddr = pszVariableName[ 0 ] == 'L' ?_LocalAddress : _RemoteAddress;
        
        //
        // The dwAddr is reverse order from in_addr...
        //

        inAddr.S_un.S_un_b.s_b1 = (u_char)(( dwAddr & 0xff000000 ) >> 24);
        inAddr.S_un.S_un_b.s_b2 = (u_char)(( dwAddr & 0x00ff0000 ) >> 16);
        inAddr.S_un.S_un_b.s_b3 = (u_char)(( dwAddr & 0x0000ff00 ) >> 8);
        inAddr.S_un.S_un_b.s_b4 = (u_char) ( dwAddr & 0x000000ff );

        LPSTR pszAddr = inet_ntoa( inAddr );
        if ( pszAddr == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        hr = strVariable.Copy( pszAddr );
    }
    else
    {
        hr = strVariable.Copy( "" );
    }
    
    return strVariable.CopyToBuffer( (LPSTR) pvBuffer, pdwSize );
}

//static    
BOOL
WINAPI
RAW_CONNECTION::RawFilterServerSupportFunction(
    HTTP_FILTER_CONTEXT *         pfc,
    enum SF_REQ_TYPE              SupportFunction,
    void *                        pData,
    ULONG_PTR                     ul,
    ULONG_PTR                     ul2
)
/*++

Routine Description:

    Stream filter SSF crap

Arguments:

    pfc - Used to get back the W3_FILTER_CONTEXT and W3_MAIN_CONTEXT pointers
    SupportFunction - SSF to invoke (see ISAPI docs)
    pData, ul, ul2 - Function specific data
    
Return Value:

    BOOL (use GetLastError() for error)

--*/
{
    RAW_CONNECTION *            pRawConnection;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fRet;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    switch ( SupportFunction )
    {
    case SF_REQ_SEND_RESPONSE_HEADER:

        hr = pRawConnection->SendResponseHeader( (CHAR*) pData,
                                                 (CHAR*) ul,
                                                 pfc );
        break;

    case SF_REQ_ADD_HEADERS_ON_DENIAL:
        
        hr = pRawConnection->AddDenialHeaders( (CHAR*) pData );
        break;

    case SF_REQ_SET_NEXT_READ_SIZE:

        pRawConnection->SetNextReadSize( (DWORD) ul );
        break;
    
    default:
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }    

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }    
    return TRUE;
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterGetServerVariable(
    HTTP_FILTER_CONTEXT *         pfc,
    LPSTR                         lpszVariableName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Stream filter GetServerVariable() implementation

Arguments:

    pfc - Filter context
    lpszVariableName - Variable name
    lpvBuffer - Buffer to receive the server variable
    lpdwSize - On input, the size of the buffer, on output, the sized needed
    
    
Return Value:

    BOOL (use GetLastError() for error).  
    ERROR_INSUFFICIENT_BUFFER if larger buffer needed
    ERROR_INVALID_INDEX if the server variable name requested is invalid

--*/
{
    HRESULT                         hr = NO_ERROR;
    RAW_CONNECTION *                pRawConnection = NULL;
    W3_MAIN_CONTEXT *               pMainContext;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    //
    // If we have a W3_CONNECTION associated, then use its context to 
    // get at server variables.  Otherwise we can only serve the ones that
    // make sense
    //

    pMainContext = pRawConnection->QueryMainContext();
    if ( pMainContext != NULL )
    {
        hr = SERVER_VARIABLE_HASH::GetServerVariable( pMainContext,
                                                      lpszVariableName,
                                                      (CHAR*) lpvBuffer,
                                                      lpdwSize ); 
    }
    else
    {
        //
        // We can supply only a few (since we haven't parsed the request yet)
        //
        
        hr = pRawConnection->GetLimitedServerVariables( lpszVariableName,
                                                        lpvBuffer,
                                                        lpdwSize );
    }
    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterWriteClient(
    HTTP_FILTER_CONTEXT *         pfc,
    LPVOID                        Buffer,
    LPDWORD                       lpdwBytes,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Synchronous WriteClient() for stream filter

Arguments:

    pfc - Filter context
    Buffer - buffer to write to client
    lpdwBytes - On input, the size of the input buffer.  On output, the number
                of bytes sent
    dwReserved - Reserved
    
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    HRESULT                     hr;
    RAW_CONNECTION *            pRawConnection = NULL;
    PVOID                       pvContext;
    RAW_STREAM_INFO             rawStreamInfo;
    BOOL                        fComplete = FALSE;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         Buffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    //
    // Remember the filter context since calling filters will overwrite it
    //
    
    pvContext = pfc->pFilterContext;
    
    //
    // We need to notify all write raw data filters which are a higher 
    // priority than the current filter 
    //
    
    if ( pRawConnection->_dwCurrentFilter > 0 )
    {
        rawStreamInfo.pbBuffer = (BYTE*) Buffer;
        rawStreamInfo.cbBuffer = *lpdwBytes;
        rawStreamInfo.cbData = rawStreamInfo.cbBuffer;
    
        hr = pRawConnection->NotifyRawWriteFilters( &rawStreamInfo,
                                                    &fComplete,
                                                    pRawConnection->_dwCurrentFilter - 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    pfc->pFilterContext = pvContext;
    
    //
    // Now call back into the stream filter to send the data.  In transmit
    // SSL might do its thing with the data as well
    //
   
    hr = pRawConnection->_pfnSendDataBack( pRawConnection->_pvStreamContext,
                                           &rawStreamInfo );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    return TRUE;
    
Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}
    
//static
VOID *
WINAPI
RAW_CONNECTION::RawFilterAllocateMemory(
    HTTP_FILTER_CONTEXT *         pfc,
    DWORD                         cbSize,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Used by filters to allocate memory freed on connection close

Arguments:

    pfc - Filter context
    cbSize - Amount to allocate
    dwReserved - Reserved
    
    
Return Value:

    A pointer to the allocated memory

--*/
{
    RAW_CONNECTION *        pRawConnection = NULL;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );

    return pRawConnection->AllocateFilterMemory( cbSize );
}

//static
BOOL
WINAPI
RAW_CONNECTION::RawFilterAddResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD                 dwReserved
)
/*++

Routine Description:

    Add response headers to whatever response eventually gets sent

Arguments:

    pfc - Filter context
    lpszHeaders - Headers to send (\r\n delimited)
    dwReserved - Reserved
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    HRESULT                         hr;
    RAW_CONNECTION *                pRawConnection;
    W3_MAIN_CONTEXT *               pMainContext = NULL;
    W3_FILTER_CONTEXT *             pFilterContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL || 
         lpszHeaders == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pRawConnection = (RAW_CONNECTION*) pfc->ServerContext;
    DBG_ASSERT( pRawConnection->CheckSignature() );
    
    pMainContext = pRawConnection->QueryMainContext();
    if ( pMainContext != NULL )
    {
        pFilterContext = pMainContext->QueryFilterContext();
        DBG_ASSERT( pFilterContext != NULL );

        hr = pFilterContext->AddResponseHeaders( lpszHeaders );        
    }
    else
    {
        hr = pRawConnection->AddResponseHeaders( lpszHeaders );
    }
    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

//static
HRESULT
RAW_CONNECTION::ProcessNewConnection(
    CONNECTION_INFO *       pConnectionInfo,
    PVOID *                 ppConnectionState
)
/*++

Routine Description:

    Called for every new raw connection to server

Arguments:

    pConnectionInfo - Information about the local/remote addresses
    ppConnectionState - Connection state to be associated with raw connection

Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *            pConnection = NULL;
    LK_RETCODE                  lkrc;
    
    if ( pConnectionInfo == NULL ||
         ppConnectionState == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppConnectionState = NULL;
    
    //
    // Try to create and add the connection
    // 

    pConnection = new RAW_CONNECTION( pConnectionInfo );
    if ( pConnection == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    } 
        
    lkrc = sm_pRawConnectionHash->InsertRecord( pConnection );
    if ( lkrc != LK_SUCCESS )
    {
        pConnection->DereferenceRawConnection();
        pConnection = NULL;
        
        return HRESULT_FROM_WIN32( lkrc );
    }
    
    *ppConnectionState = pConnection;
    
    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::ProcessRawRead(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pContext,
    BOOL *                  pfReadMore,
    BOOL *                  pfComplete,
    DWORD *                 pcbNextReadSize
)
/*++

Routine Description:

    Notify ISAPI read raw data filters

Arguments:

    pRawStreamInfo - The raw stream to muck with
    pContext - Raw connection context
    pfReadMore - Set to TRUE if we need to read more data
    pfComplete - Set to TRUE if we want to disconnect client
    pcbNextReadSize - Set to next read size (0 means use default size)

Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *        pConnection = NULL;
    HRESULT                 hr = NO_ERROR;
    W3_MAIN_CONTEXT *       pMainContext;
    
    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL ||
         pContext == NULL ||
         pcbNextReadSize == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfReadMore = FALSE;
    *pfComplete = FALSE;

    pConnection = (RAW_CONNECTION*) pContext;
    DBG_ASSERT( pConnection->CheckSignature() );

    pConnection->SetNextReadSize( 0 );

    //
    // Synchronize access to the filter to prevent raw notifications from
    // occurring at the same time as regular worker process notifications
    //
    
    pMainContext = pConnection->QueryMainContext();
    if ( pMainContext != NULL )
    {
        pMainContext->QueryFilterContext()->FilterLock();
    }

    hr = pConnection->NotifyRawReadFilters( pRawStreamInfo,
                                            pfReadMore,
                                            pfComplete );

    if ( pMainContext != NULL )
    {
        pMainContext->QueryFilterContext()->FilterUnlock();
    }
    
    *pcbNextReadSize = pConnection->QueryNextReadSize();
    
    return hr;
}

HRESULT
RAW_CONNECTION::NotifyRawReadFilters(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfReadMore,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Notify raw read filters

Arguments:

    pRawStreamInfo - Raw stream info
    pfReadMore - Set to TRUE to we should read more data
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;
    *pfReadMore = FALSE;

    //
    // Setup filter raw object
    //

    hfrd.pvInData = pRawStreamInfo->pbBuffer;
    hfrd.cbInData = pRawStreamInfo->cbData;
    hfrd.cbInBuffer = pRawStreamInfo->cbBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_READ_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_READ_RAW_DATA ) )
            {
                continue;
            }
        }

        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;
       
        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_READ_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfComplete = TRUE;
            goto Exit;

        case SF_STATUS_REQ_READ_NEXT:
            *pfReadMore = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:

    pRawStreamInfo->pbBuffer = (BYTE*) hfrd.pvInData;
    pRawStreamInfo->cbData = hfrd.cbInData;
    pRawStreamInfo->cbBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;

    return NO_ERROR;
}

//static
HRESULT
RAW_CONNECTION::ProcessRawWrite(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfComplete
)
/*++

Routine Description:

    Entry point called by stream filter to handle data coming from the 
    application.  We will call SF_NOTIFY_SEND_RAW_DATA filter notifications
    here

Arguments:

    pRawStreamInfo - The stream to process, as well as an optional opaque
                     context set by the RAW_CONNECTION code
    pvContext - Context pass back
    pfComplete - Set to TRUE if we should disconnect
    
Return Value:

    HRESULT

--*/
{
    RAW_CONNECTION *        pConnection = NULL;
    W3_MAIN_CONTEXT *       pMainContext;
    HRESULT                 hr = NO_ERROR;
    DWORD                   cbAppRead;
    
    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;
    
    return NO_ERROR;
}

HRESULT
RAW_CONNECTION::NotifyRawWriteFilters(
    RAW_STREAM_INFO *   pRawStreamInfo,
    BOOL *              pfComplete,
    DWORD               dwStartFilter
)
/*++

Routine Description:

    Notify raw write filters

Arguments:

    pRawStreamInfo - Raw stream to munge
    pfComplete - Set to TRUE if we should disconnect now
    dwStartFilter - Filter to start notifying.  If this valid is INVALID_DLL,
                    then simply start with the lowest priority filter

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    hfrd.pvInData = pRawStreamInfo->pbBuffer;
    hfrd.cbInData = pRawStreamInfo->cbData;
    hfrd.cbInBuffer = pRawStreamInfo->cbBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    if ( dwStartFilter == INVALID_DLL )
    {
        dwStartFilter = pFilterList->QueryFilterCount() - 1;
    }
    
    i = dwStartFilter;

    do
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_SEND_RAW_DATA ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;

        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_SEND_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfComplete = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }
    while ( i-- > 0 );

Exit:

    pRawStreamInfo->pbBuffer = (BYTE*) hfrd.pvInData;
    pRawStreamInfo->cbData = hfrd.cbInData;
    pRawStreamInfo->cbBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    return NO_ERROR;
}

HRESULT
RAW_CONNECTION::NotifyEndOfNetSessionFilters(
    VOID
)
/*++

Routine Description:

    Notify END_OF_NET_SESSION filters

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;

    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_END_OF_NET_SESSION ) )
            {
                continue;
            }
        }

        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;
       
        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_END_OF_NET_SESSION,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            return E_FAIL;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;

    return NO_ERROR;
}

//static
VOID
RAW_CONNECTION::ProcessConnectionClose(
    PVOID                       pvContext
)
/*++

Routine Description:

    Entry point called by stream filter when a connection has closed

Arguments:

    pvContext - Opaque context associated with the connection
    
Return Value:

    None

--*/
{
    RAW_CONNECTION *            pRawConnection;
    
    pRawConnection = (RAW_CONNECTION*) pvContext;
    if ( pRawConnection != NULL )
    {
        DBG_ASSERT( pRawConnection->CheckSignature() );

        //
        // We're done with the raw connection.  Delete it from hash table
        // In the process, this will dereference the connection
        //
        
        DBG_ASSERT( sm_pRawConnectionHash != NULL );
        
        sm_pRawConnectionHash->DeleteRecord( pRawConnection );
    }
}

VOID
RAW_CONNECTION::CopyAllocatedFilterMemory(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    Copy over any allocated filter memory items

Arguments:

    pFilterContext - Destination of filter memory item references

Return Value:

    None

--*/
{   
    FILTER_POOL_ITEM *          pfpi;
    
    //
    // We need to grab the raw connection lock since we don't want a 
    // read-raw data notification to muck with the pool list while we
    // are copying it over to the W3_CONNECTION
    //
    
    pFilterContext->FilterLock();

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        InitializeListHead( &pfpi->_ListEntry );

        //
        // Copy the pool item to the other list
        //

        pFilterContext->AddFilterPoolItem( pfpi );
    }
    
    pFilterContext->FilterUnlock();
}

VOID
RAW_CONNECTION::CopyContextPointers(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    The global filter list is constant, in addition, when an instance filter
    list is built, the global filters are always built into the list.  After
    the instance filter list has been identified, we need to copy any non-null
    client filter context values from the global filter list to the new
    positions in the instance filter list.  For example:

     Global List &  |  Instance List &
     context values | new context value positions
                    |
        G1     0    |    I1    0
        G2   555    |    G1    0
        G3   123    |    G2  555
                    |    I2    0
                    |    G3  123

    Note: This scheme precludes having the same .dll be used for both a
          global and per-instance dll.  Since global filters are automatically
          per-instance this shouldn't be an interesting case.

--*/
{
    DWORD i, j;
    DWORD cGlobal;
    DWORD cInstance;
    HTTP_FILTER_DLL * pFilterDll;
    FILTER_LIST * pGlobalFilterList;
    FILTER_LIST * pInstanceFilterList;

    pFilterContext->FilterLock();

    DBG_ASSERT( pFilterContext != NULL );

    pGlobalFilterList = FILTER_LIST::QueryGlobalList();
    DBG_ASSERT( pGlobalFilterList != NULL );

    cGlobal = pGlobalFilterList->QueryFilterCount();

    pInstanceFilterList = pFilterContext->QueryFilterList();
    DBG_ASSERT( pInstanceFilterList != NULL );
    
    cInstance = pInstanceFilterList->QueryFilterCount();

    //
    // If no global filters or no instance filters, then there won't be
    // any filter context pointers that need adjusting
    //

    if ( !cGlobal || !cInstance )
    {
        goto Finished;
    }
    
    //
    // For each global list context pointer, find the filter in the instance
    // list and adjust
    //

    for ( i = 0; i < cGlobal; i++ )
    {
        if ( _rgContexts[ i ] != NULL )
        {
            pFilterDll = pGlobalFilterList->QueryDll( i );
            
            //
            // We found one.  Find the filter in instance list and set
            //
            
            for ( j = 0; j < cInstance; j++ )
            {
                if ( pInstanceFilterList->QueryDll( j ) == pFilterDll )
                {
                    pFilterContext->SetClientContext( j, _rgContexts[ i ] );
                }
            }
            
        }
    }

Finished:
    pFilterContext->FilterUnlock();
}

HRESULT
RAW_CONNECTION::CopyHeaders(
    W3_FILTER_CONTEXT *             pFilterContext
)
/*++

Routine Description:

    Copy denied/response headers from read raw

Arguments:

    pFilterContext - Filter context to copy to

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    if ( pFilterContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = pFilterContext->AddDenialHeaders( _strAddDenialHeaders.QueryStr() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pFilterContext->AddResponseHeaders( _strAddResponseHeaders.QueryStr() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _strAddDenialHeaders.Reset();
    _strAddResponseHeaders.Reset();
    
    return NO_ERROR;
}

HRESULT
RAW_CONNECTION::SendResponseHeader(
    CHAR *                          pszStatus,
    CHAR *                          pszAdditionalHeaders,
    HTTP_FILTER_CONTEXT *           pfc
)
/*++

Routine Description:

    Called when raw filters want to send a response header.  Depending
    on whether a W3_CONNECTION is associated or not, we will either 
    send the stream ourselves here, or call in the main context's 
    response facilities

Arguments:

    pszStatus - ANSI status line
    pszAdditionalHeaders - Any additional headers to send
    pfc - Filter context (to be passed to FilterWriteClient())

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *       pMainContext = NULL;
    STACK_STRA(             strResponse, 256 );
    HRESULT                 hr = NO_ERROR;
    DWORD                   cbBytes = 0;
    BOOL                    fRet = FALSE;
    W3_RESPONSE *           pResponse = NULL;
    
    if ( pszStatus == NULL &&
         pszAdditionalHeaders == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Which response are we touching?
    //
    
    pMainContext = QueryMainContext();
    if ( pMainContext != NULL )
    {
        pResponse = pMainContext->QueryResponse();
    }
    else
    {
        pResponse = &_response;
    }
        
    //
    // Build up a response from what ISAPI gave us
    //
    
    hr = pResponse->BuildResponseFromIsapi( pMainContext,
                                            pszStatus,
                                            pszAdditionalHeaders,
                                            pszAdditionalHeaders ? 
                                            strlen( pszAdditionalHeaders ) : 0 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now if we have a w3 context then we can send the response normally.
    // Otherwise we must use the UL filter API
    //
       
    if ( pMainContext != NULL )
    {
        hr = pMainContext->SendResponse( W3_FLAG_SYNC | W3_FLAG_NO_ERROR_BODY );
    } 
    else
    {
        //
        // Add denial/response headers
        //
        
        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            hr = pResponse->AppendResponseHeaders( _strAddDenialHeaders );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
        
        hr = pResponse->AppendResponseHeaders( _strAddResponseHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = pResponse->GetRawResponseStream( &strResponse );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Go thru WriteClient() so the right filtering happens on the
        // response
        //
        
        cbBytes = strResponse.QueryCB();
        
        fRet = RAW_CONNECTION::RawFilterWriteClient( pfc,
                                                     strResponse.QueryStr(),
                                                     &cbBytes,
                                                     0 );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return hr;
}

//static
HRESULT
RAW_CONNECTION::FindConnection(
    HTTP_RAW_CONNECTION_ID      rawConnectionId,
    RAW_CONNECTION **           ppRawConnection
)
/*++

Routine Description:

    Find and return raw connection if found

Arguments:

    rawConnectionId - Raw connection ID from UL_HTTP_REQUEST
    ppRawConnection - Set to raw connection if found

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    
    if ( ppRawConnection == NULL ||
         rawConnectionId == HTTP_NULL_ID )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pRawConnectionHash != NULL );
    
    lkrc = sm_pRawConnectionHash->FindKey( rawConnectionId,
                                           ppRawConnection );
    
    if ( lkrc != LK_SUCCESS )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    else
    {
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\redirect.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    redirect.cxx

Abstract:

    This module contains code for handling HTTP redirections in server.


Revision History:

    balam       10-Jan-1996     Created
    taylorw     04-Apr-2000     Ported to IIS+

--*/

#include <precomp.hxx>
#include "redirect.hxx"

enum REDIR_TOKEN
{
    REDIR_TOKEN_EXACT_DST,
    REDIR_TOKEN_PERMANENT,
    REDIR_TOKEN_TEMPORARY,
    REDIR_TOKEN_SUFFIX,
    REDIR_TOKEN_FULL,
    REDIR_TOKEN_PARAMETERS,
    REDIR_TOKEN_QMARK_PARAMETERS,
    REDIR_TOKEN_VROOT_REQUEST,
    REDIR_TOKEN_CHILD_ONLY,
    REDIR_TOKEN_UNKNOWN
};

struct _REDIR_TOKEN_LIST
{
    WCHAR *          pszKeyword;
    DWORD            cbLen;
    REDIR_TOKEN      rtType;
}
RedirectTokenList[] =
{
    L"EXACT_DESTINATION",   17, REDIR_TOKEN_EXACT_DST,
    L"PERMANENT",           9,  REDIR_TOKEN_PERMANENT,
    L"TEMPORARY",           9,  REDIR_TOKEN_TEMPORARY,
    L"$S",                  2,  REDIR_TOKEN_SUFFIX,
    L"$P",                  2,  REDIR_TOKEN_PARAMETERS,
    L"$Q",                  2,  REDIR_TOKEN_QMARK_PARAMETERS,
    L"$V",                  2,  REDIR_TOKEN_VROOT_REQUEST,
    L"CHILD_ONLY",          10, REDIR_TOKEN_CHILD_ONLY,
    NULL,                   0,  REDIR_TOKEN_UNKNOWN
};

DWORD
GetRedirectToken(
    IN  WCHAR *     pchToken,
    OUT DWORD *     pdwLen
)
/*++

Routine Description:

    Searches token table for match.

Arguments:

    pchToken - Pointer to string to search for.
    pdwLen - Receives the length of matched token.

Return Value:

    The type (REDIR_TOKEN enum) of the token if matched.
    Or REDIR_TOKEN_UNKNOWN if string not found.

--*/
{
    DWORD           dwCounter = 0;

    while ( RedirectTokenList[ dwCounter ].pszKeyword != NULL )
    {
        if ( !_wcsnicmp( pchToken,
                         RedirectTokenList[ dwCounter ].pszKeyword,
                         RedirectTokenList[ dwCounter ].cbLen ) )
        {
            break;
        }
        dwCounter++;
    }
    if ( pdwLen != NULL )
    {
        *pdwLen = RedirectTokenList[ dwCounter ].cbLen;
    }
    return RedirectTokenList[ dwCounter ].rtType;
}

HRESULT
REDIRECTION_BLOB::ParseDestination(
    IN STRU &           strDestination
)
/*++

Routine Description:

    Parse destination template.

Arguments:

    strDestination - Destination template

Return Value:

    HRESULT

--*/
{
    WCHAR *             pchNextComma = NULL;
    DWORD               cbTokenLen;
    STACK_STRU(         strOptions, MAX_PATH );
    WCHAR *             pchWhiteSpace;
    DWORD               cchLen;
    HRESULT             hr;

    //
    // first separate out the destination path from the options (if any)
    //

    pchNextComma = wcschr( strDestination.QueryStr(), L',' );
    if ( pchNextComma != NULL )
    {
        if ( FAILED( hr = strOptions.Copy( pchNextComma + 1 ) ) )
        {
            return hr;
        }

        cchLen = DIFF(pchNextComma - strDestination.QueryStr());
    }
    else
    {
        cchLen = strDestination.QueryCCH();
    }

    if ( FAILED( hr = _strDestination.Copy( strDestination.QueryStr(),
                                            cchLen ) ) )
    {
        return hr;
    }

    //
    // look for any trailing white space in destination, remove it
    //

    pchWhiteSpace = _strDestination.QueryStr() + _strDestination.QueryCCH();

    while( pchWhiteSpace > _strDestination.QueryStr() )
    {
        if ( !iswspace( *( pchWhiteSpace - 1 ) ) )
        {
            break;
        }

        _strDestination.SetLen( --cchLen );

        pchWhiteSpace--;
    }

    //
    // now check whether this is a wildcard redirection
    //

    if ( _strDestination.QueryStr()[0] == L'*' )
    {
        if ( FAILED( hr = ParseWildcardDestinations() ) )
        {
            return hr;
        }

        _fWildcards = TRUE;
    }
    else
    {
        //
        // cache whether we expect tokens in the destination template
        //

        if ( wcschr( _strDestination.QueryStr(), L'$' ) != NULL )
        {
            _fHasTokens = TRUE;
        }
    }

    if ( !strOptions.IsEmpty() )
    {
        //
        // parse and cache any options set for redirection
        //

        pchNextComma = strOptions.QueryStr();

        while ( TRUE )
        {
            while ( iswspace( *pchNextComma ) )
            {
                pchNextComma++;
            }

            switch ( GetRedirectToken( pchNextComma, &cbTokenLen ) )
            {
                case REDIR_TOKEN_EXACT_DST:
                    _fExactDestination = TRUE;
                    break;
                case REDIR_TOKEN_PERMANENT:
                    _redirectType = PERMANENT_REDIRECT;
                    break;
                case REDIR_TOKEN_TEMPORARY:
                    _redirectType = TEMPORARY_REDIRECT;
                    break;
                case REDIR_TOKEN_CHILD_ONLY:
                    _fChildOnly = TRUE;
                    break;
                default:
                    break;
            }

            pchNextComma = wcschr( pchNextComma, L',' );

            if ( pchNextComma == NULL )
            {
                break;
            }

            pchNextComma++;
        }
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::ParseWildcardDestinations()
/*++

Routine Description:

    Parse wildcard destination.

    Wildcard destination takes the form:

    *;<wildcard1>;<destination1>;<wildcard2>;<destination2>...
    eg. *;*.stm;/default1.htm;*.htm;/default2.htm

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    WCHAR *             pchCursor;
    WCHAR *             pchNext;
    WCHAR *             pchEndToken;
    WILDCARD_ENTRY     *pEntry;
    HRESULT             hr;

    pchCursor = wcschr( _strDestination.QueryStr(), L';' );

    if ( pchCursor == NULL )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    while ( pchCursor != NULL )
    {
        pchCursor++;

        pchNext = wcschr( pchCursor, L';' );
        if ( pchNext == NULL )
        {
            break;
        }

        while ( iswspace( *pchCursor ) )
        {
            pchCursor++;
        }

        pEntry = AddWildcardEntry();
        if ( pEntry == NULL )
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        pchEndToken = pchNext - 1;
        while ( iswspace( *pchEndToken ) )
        {
            pchEndToken--;
        }

        if ( FAILED( hr = pEntry->_strWildSource.Copy(
                              pchCursor,
                              DIFF(pchEndToken - pchCursor) + 1 ) ) )
        {
            return hr;
        }

        pchCursor = pchNext + 1;

        while ( iswspace( *pchCursor ) )
        {
            pchCursor++;
        }

        pchNext = wcschr( pchCursor, ';' );

        if ( pchNext == NULL )
        {
            if ( FAILED( hr = pEntry->_strWildDest.Copy( pchCursor ) ) )
            {
                return hr;
            }
        }
        else
        {
            pchEndToken = pchNext - 1;
            while ( iswspace( *pchEndToken ) )
            {
                pchEndToken--;
            }

            if ( FAILED( hr = pEntry->_strWildDest.Copy(
                                  pchCursor,
                                  DIFF(pchEndToken - pchCursor) + 1 ) ) )
            {
                return hr;
            }
        }

        _fHasTokens |= wcschr( pEntry->_strWildDest.QueryStr(), L'$' ) != NULL;

        pchCursor = pchNext;
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::GetDestination(
    IN  W3_CONTEXT     *pW3Context,
    OUT STRU           *pstrFinalDestination,
    OUT BOOL           *pfMatch,
    OUT HTTP_STATUS    *pStatusCode
)
/*++

Routine Description:

    Get the complete destination of a redirection

Arguments:

    pW3Context      - W3_CONTEXT associated with the request
    pstrDestination - Redirection destination placed here
    pdwServerCode   - Server code of redirect (HT_REDIRECT or HT_MOVED )

Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strMatchedSuffix, MAX_PATH );
    STACK_STRU(         strRequestedURL, MAX_PATH );
    STACK_STRU(         strParameters, MAX_PATH );
    STRU *              pstrDestination;
    WILDCARD_ENTRY     *pEntry = NULL;
    HRESULT             hr;

    if (FAILED(hr = pW3Context->QueryRequest()->GetUrl(&strRequestedURL)))
    {
        return hr;
    }

    WILDCARD_MATCH_LIST wmlList( strRequestedURL.QueryCCH() );

    if (FAILED(hr = pW3Context->QueryRequest()->GetQueryString(&strParameters)))
    {
        return hr;
    }

    switch (_redirectType)
    {
    case NORMAL_REDIRECT:
        *pStatusCode = HttpStatusRedirect;
        break;
    case PERMANENT_REDIRECT:
        *pStatusCode = HttpStatusMovedPermanently;
        break;
    case TEMPORARY_REDIRECT:
        *pStatusCode = HttpStatusMovedTemporarily;
        break;
    default:
        DBG_ASSERT(FALSE);
    }

    DBG_ASSERT(strRequestedURL.QueryCCH() >= _strSource.QueryCCH());

    if ( FAILED( hr = strMatchedSuffix.Copy(
                          strRequestedURL.QueryStr() +
                          _strSource.QueryCCH() ) ) )
    {
        return hr;
    }

    if ( _fChildOnly )
    {
        WCHAR * pchOtherSlash;

        pchOtherSlash = wcschr( strMatchedSuffix.QueryStr(), L'/' );
        if ( pchOtherSlash == strMatchedSuffix.QueryStr() )
        {
            pchOtherSlash = wcschr( pchOtherSlash + 1, L'/' );
        }

        if ( pchOtherSlash != NULL )
        {
            *pfMatch = FALSE;
            return S_OK;
        }
    }

    if ( _fWildcards )
    {
        if ( FAILED(hr = FindWildcardMatch( strMatchedSuffix,
                                            &pEntry,
                                            &wmlList ) ) )
        {
            return hr;
        }

        if (pEntry == NULL)
        {
            *pfMatch = FALSE;
            return S_OK;
        }

        pstrDestination = &(pEntry->_strWildDest);
    }
    else
    {
        pstrDestination = &_strDestination;
    }

    if ( !_fHasTokens )
    {
        if ( FAILED(hr = pstrFinalDestination->Copy( *pstrDestination ) ) )
        {
            return hr;
        }
    }
    else
    {
        WCHAR           achAdd[ 2 ] = { L'\0', L'\0' };
        WCHAR           ch;
        WCHAR *         pchCursor = pstrDestination->QueryStr();
        DWORD           cchLen;
        WCHAR *         pchNext;

        while ( ( ch = *pchCursor ) != L'\0' )
        {
            switch ( ch )
            {
            case L'$':
                // Substitute for special tokens in destination template

                switch ( GetRedirectToken( pchCursor, &cchLen ) )
                {
                case REDIR_TOKEN_SUFFIX:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strMatchedSuffix ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_VROOT_REQUEST:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strRequestedURL ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_PARAMETERS:
                    pchCursor += ( cchLen - 1 );
                    if ( FAILED(hr = pstrFinalDestination->Append( strParameters ) ) )
                    {
                        return hr;
                    }
                    break;
                case REDIR_TOKEN_QMARK_PARAMETERS:
                    pchCursor += ( cchLen - 1 );
                    if ( !strParameters.IsEmpty() )
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append( L"?" ) ) ||
                             FAILED(hr = pstrFinalDestination->Append( strParameters ) ) )
                        {
                            return hr;
                        }
                    }
                    break;
                default:
                    pchCursor++;
                    ch = *pchCursor;
                    if ( iswdigit( ch ) )
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append(
                                wmlList.GetMatchNumber( ch - L'0' ) ) ) )
                        {
                            return hr;
                        }
                    }
                    else
                    {
                        if ( FAILED(hr = pstrFinalDestination->Append( L"$" ) ) )
                        {
                            return hr;
                        }
                        achAdd[ 0 ] = ch;
                        if ( FAILED(hr = pstrFinalDestination->Append( achAdd ) ) )
                        {
                            return hr;
                        }
                    }
                }
                break;
            default:
                pchNext = pchCursor;
                while ( pchCursor[ 1 ] != L'$' && pchCursor[ 1 ] != L'\0' )
                {
                    pchCursor++;
                }
                if ( FAILED(hr = pstrFinalDestination->Append(
                                     pchNext, 
                                     DIFF(pchCursor - pchNext) + 1 ) ) )
                {
                    return hr;
                }
            }
            pchCursor++;
        }
    }

    //
    // Now check to see if there were conditional headers configured for this
    // redirect. If there are, check them.
    //

    if (_ConditionalHeaderList != NULL)
    {
        // Have some conditional headers. Each conditional header in the list
        // must appear in the headers we got with this request (pReqHeaders),
        // and if there are parameters specifed with the conditional header
        // at least one of them must be present as a parameter of the input
        // header.

        RD_CONDITIONAL_HEADER      *pCurrentHeader;
        CHAR *                      pszParamList;

        pCurrentHeader = _ConditionalHeaderList;

        do
        {
            pszParamList = pW3Context->QueryRequest()->GetHeader(
                               pCurrentHeader->Header.QueryStr());

            if (pszParamList == NULL)
            {
                // Couldn't find this header in the list, fail.
                *pfMatch = FALSE;
                return S_OK;
            }

            // Found the header. If there are parameters specified for it,
            // check to see if they exist.

            if (!pCurrentHeader->Parameters.IsEmpty())
            {
                BOOL        bFound;
                const CHAR *pszCurrentParam;
                const CHAR *pszConfigParam;

                //
                // There are parameters. For each parameter in the input
                // header, check to see if it matches one in the configured
                // list for this header. If it does, we're done and we can
                // check the next header. If we get all the way through
                // and we don't find a match, we've failed and the redirect
                // won't be performed.

                pszCurrentParam = pszParamList;

                bFound = FALSE;

                //
                // For each token in the input parameters, compare
                // it against each string in the configured parameters.
                //

                while (TRUE)
                {
                    pszConfigParam = pCurrentHeader->Parameters.First();

                    DBG_ASSERT(pszConfigParam != NULL);
                    DBG_ASSERT(*pszConfigParam != '\0');

                    while (pszConfigParam != NULL)
                    {
                        if (!_strnicmp(pszCurrentParam,
                                       pszConfigParam,
                                       strlen(pszConfigParam)))
                        {
                            // Have a match.
                            bFound = TRUE;
                            break;
                        }

                        pszConfigParam =
                            pCurrentHeader->Parameters.Next(pszConfigParam);
                    }

                    if (bFound)
                    {
                        break;
                    }

                    pszCurrentParam = strchr(pszCurrentParam + 1, ',');

                    if (pszCurrentParam == NULL)
                    {
                        break;
                    }

                    pszCurrentParam++;
                }

                if (!bFound)
                {
                    //
                    // Didn't find a match, so fail.
                    //
                    *pfMatch = FALSE;
                    return S_OK;
                }
            }

            pCurrentHeader = pCurrentHeader->Next;

        } while ( pCurrentHeader != NULL );
    }

    //
    // At this point either there were no conditional headers, or there
    // were but we satisfied all the conditions, so continue.

    // was EXACT_DESTINATION option used?

    *pfMatch = TRUE;
    if ( !_fExactDestination )
    {
        return pstrFinalDestination->Append( strMatchedSuffix );
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::FindWildcardMatch(
    IN STRU &                   strInput,
    OUT WILDCARD_ENTRY **       ppEntry,
    OUT WILDCARD_MATCH_LIST *   pwmlList
)
/*++

Routine Description:

    Searches WILDCARD_ENTRYs for the first that matches the input string.
    Also fills in a WILDCARD_MATCH_LIST for the matched string (if any).

Arguments:

    strInput - Input string to check
    ppEntry - Set to point to the WILDCARD_ENTRY that matches (or NULL)
    pwmlList - Filled in if strInput matches a template

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    for ( LIST_ENTRY *pListEntry = _ListHead.Flink;
          pListEntry != &_ListHead;
          pListEntry = pListEntry->Flink )
    {
        WILDCARD_ENTRY *pWildcardEntry = CONTAINING_RECORD( pListEntry,
                                            WILDCARD_ENTRY,
                                            _ListEntry );

        HRESULT hr;
        BOOL    fMatch = FALSE;
        if ( FAILED(hr = IsWildcardMatch( strInput,
                                          pWildcardEntry->_strWildSource,
                                          pwmlList,
                                          &fMatch ) ) )
        {
            return hr;
        }

        if (fMatch)
        {
            *ppEntry = pWildcardEntry;
            return S_OK;
        }
    }

    *ppEntry = NULL;
    return S_OK;
}

HRESULT
REDIRECTION_BLOB::IsWildcardMatch(
    IN STRU &                   strInput,
    IN STRU &                   strTemplate,
    OUT WILDCARD_MATCH_LIST *   pwmlList,
    BOOL                    *   pfMatch
)
/*++

Routine Description:

    Checks whether input string matches wildcard expression of internal
    source string.  For example:  given internal source of "a*b*c",
    "abooc", "asdfjbsdfc" match, "foobar", "scripts" do not match

Arguments:

    strInput - input string to check for wildcard match
    pwmlList - List of matched strings (one for each * in wildcard)
               Only generated if the destination string of
               contains special tokens.

Return Value:

    HRESULT

--*/
{
    WCHAR           chExpr;
    WCHAR           chTemp;
    WCHAR *         pchExpr = strTemplate.QueryStr();
    WCHAR *         pchTest = strInput.QueryStr();
    WCHAR *         pchEnd;
    HRESULT         hr;

    pwmlList->Reset();

    pchEnd = pchExpr + strTemplate.QueryCCH();
    while ( TRUE )
    {
        chExpr = *pchExpr++;
        if ( chExpr == L'\0' )
        {
            if ( *pchTest == L'\0' )
            {
                *pfMatch = TRUE;
            }
            else
            {
                *pfMatch = FALSE;
            }

            return S_OK;
        }
        else if ( chExpr != L'*' )
        {
            chTemp = *pchTest++;
            if ( chTemp != chExpr )
            {
                *pfMatch = FALSE;
                return S_OK;
            }
        }
        else
        {
            INT             iComLen;
            WCHAR *         pchNextWild;

            while ( *pchExpr == L'*' )
            {
                pchExpr++;
            }

            pchNextWild = wcschr( pchExpr, L'*' );
            iComLen = pchNextWild == NULL ? DIFF(pchEnd - pchExpr) :
                                            DIFF(pchNextWild - pchExpr);
            while ( *pchTest != '\0' )
            {
                if ( wcsncmp( pchExpr,
                              pchTest,
                              iComLen ) || !iComLen )
                {
                    // if the destination has tokens, then generate WML
                    if ( _fHasTokens &&
                         FAILED(hr = pwmlList->AddChar( *pchTest ) ) )
                    {
                        return hr;
                    }
                    pchTest++;
                }
                else
                {
                    break;
                }
            }
            if ( *pchTest == L'\0' && iComLen )
            {
                *pfMatch = FALSE;
                return S_OK;
            }
            else if ( _fHasTokens && FAILED(hr = pwmlList->NewString() ) )
            {
                return hr;
            }
        }
    }

    *pfMatch = TRUE;
    return S_OK;
}

HRESULT
W3_CONTEXT::DoUrlRedirection(BOOL *pfRedirected)
/*++

Routine Description:

    Do a HTTP redirect as specified by template in metadata.

Arguments:

    pfFinished - Set to TRUE if no more processing required.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    REDIRECTION_BLOB *pRBlob = QueryUrlContext()->QueryMetaData()->QueryRedirectionBlob();
    STACK_STRU( strDestination, MAX_PATH );
    HTTP_STATUS statusCode;
    HRESULT hr = S_OK;

    if ( pRBlob == NULL ||
         FAILED(hr = pRBlob->GetDestination( this,
                                             &strDestination,
                                             pfRedirected,
                                             &statusCode ) ) || 
         !*pfRedirected ||
         FAILED(hr = SetupHttpRedirect( strDestination,
                                        FALSE,
                                        statusCode ) ) ||
         FAILED(hr = SendResponse( W3_FLAG_SYNC ) ) )
    {
        return hr;
    }

    return S_OK;
}

HRESULT W3_METADATA::SetRedirectionBlob(STRU &strSource,
                                        STRU &strDestination)
{
    //
    // If the redirection is nullified, don't allocate a blob
    // and just return success.
    //

    if (strDestination.QueryStr()[0] == L'!')
    {
        return S_OK;
    }

    _pRedirectBlob = new REDIRECTION_BLOB();
    if (_pRedirectBlob == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return _pRedirectBlob->Create(strSource, strDestination);
}

HRESULT
W3_METADATA::GetTrueRedirectionSource(
     LPWSTR                  pszURL,
     LPCWSTR                 pszMetabasePath,
     IN WCHAR *              pszDestination,
     IN BOOL                 bIsString,
     OUT STRU *              pstrTrueSource
)
/*++

Routine Description:

    Determine the true source of the redirection.  That is, the object from
    which the required URL inherited the redirect metadata.

Arguments:

    pszURL          - URL requested
    strMetabasePath - The metabase path to the root of the site
    pszDestination  - The destination metadata inherited by the original URL.
    pstrTrueSource  - The path of the object from which the original URL
                      inherited pszDestination.

Return Value:

    HRESULT

--*/
{
    MB       mb( g_pW3Server->QueryMDObject() );
    DWORD    dwNeed;
    DWORD    dwL;
    DWORD    dwVRLen;
    INT      ch;
    LPWSTR   pszInVr;
    LPWSTR   pszMinInVr;
    BOOL     bAtThisLevel;

    // need to reopen the metabase and search up the tree

    if ( !mb.Open(pszMetabasePath))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Check from where we got HTTP_REDIRECT
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + wcslen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = L'\0';
            dwNeed = 0;

            if (bIsString)
            {
                bAtThisLevel = !mb.GetString( pszURL,
                                              MD_HTTP_REDIRECT,
                                              IIS_MD_UT_FILE,
                                              NULL,
                                              &dwNeed,
                                              0 ) &&
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                bAtThisLevel = !mb.GetData( pszURL,
                                            MD_HTTP_REDIRECT,
                                            IIS_MD_UT_FILE,
                                            MULTISZ_METADATA,
                                            NULL,
                                            &dwNeed,
                                            0 ) &&
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER;
            }

            *pszInVr = (CHAR)ch;

            if ( bAtThisLevel )
            {
                // HTTP_REDIRECT was defined at this level !

                break;
            }

            if (ch)
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE(mb.Close());
                    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != L'/' && *pszInVr != L'\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    --pszInVr;
                }
                else
                {
                    DBG_REQUIRE( mb.Close() );
                    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    DBG_REQUIRE( mb.Close() );

    if ( dwVRLen > 1 )
    { 
        DBG_ASSERT( pszURL[ 0 ] == L'/' );

        return pstrTrueSource->Copy( pszURL, dwVRLen );
    }

    return S_OK;
}

HRESULT
REDIRECTION_BLOB::SetConditionalHeaders(
    WCHAR *pmszConditionalHeaders
)
/*++

Routine Description:

    Take a bunch of conditional headers as a multisz, and convert them to a
    list of RD_CONDITIONAL_HEADERs attached to this redirection blob.

Arguments:

    pHeaders        - Pointer to multisz of conditional headers.

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    WCHAR *                 pszHeader;
    RD_CONDITIONAL_HEADER  *pCondition;
    RD_CONDITIONAL_HEADER  *pPrevCondition;
    HRESULT                 hr;
    WCHAR                  *pszTemp;
    WCHAR                  *pszCurrentParam;
    WCHAR                  *pszCurrentComma;


    pPrevCondition = CONTAINING_RECORD(&_ConditionalHeaderList,
                            RD_CONDITIONAL_HEADER, Next);

    DBG_ASSERT(pPrevCondition->Next == NULL);

    while (*pmszConditionalHeaders != '\0')
    {
        //
        // Allocate a new conditional header block.
        //
        pCondition = new RD_CONDITIONAL_HEADER;

        if (pCondition == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        // Now find the header, and add it.
        //

        pszHeader = pmszConditionalHeaders;

        while (iswspace(*pszHeader))
        {
            pszHeader++;
        }

        pszTemp = wcschr(pszHeader, L':');

        if (pszTemp == NULL)
        {
            // Poorly formed header, fail.

            delete pCondition;
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

        pszTemp++;

        if (FAILED(hr = pCondition->Header.CopyW(pszHeader, DIFF(pszTemp - pszHeader))))
        {
            delete pCondition;
            return hr;
        }


        //
        // OK, now pszTemp points right after the header. We have a comma
        // seperated list of parameters following this, convert these to
        // the Parameters multisz.

        pszCurrentParam = pszTemp;
        pszCurrentComma = wcschr(pszTemp, L',');
        if (pszCurrentComma != NULL)
        {
            *pszCurrentComma = L'\0';
        }

        while (TRUE)
        {
            if (!pCondition->Parameters.AppendW(pszCurrentParam))
            {
                delete pCondition;
                return E_OUTOFMEMORY;
            }

            if (pszCurrentComma == NULL)
            {
                break;
            }
            *pszCurrentComma = L',';
            pszCurrentParam = pszCurrentComma + 1;
            pszCurrentComma = wcschr(pszCurrentParam, L',');
        }

        //
        // So far, so good. Append this one to the list.

        pPrevCondition->Next = pCondition;

        pPrevCondition = pCondition;

        pmszConditionalHeaders = pmszConditionalHeaders +
                                 wcslen(pmszConditionalHeaders) + 1;

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\requestheaderhash.h ===
#ifndef _REQUEST_HEADERHASH_HXX_
#define _REQUEST_HEADERHASH_HXX_

//
// Helper class for String->Index hash
//
    
struct HEADER_RECORD
{
    ULONG               _ulHeaderIndex;
    CHAR *              _pszName;
    DWORD               _cchName;
};

#define HEADER(x)           x, sizeof(x) - sizeof(CHAR)

//
// *_HEADER_HASH maps strings to UlHeader* values
//

#define UNKNOWN_INDEX           (0xFFFFFFFF)

class REQUEST_HEADER_HASH
    : public CTypedHashTable< REQUEST_HEADER_HASH, 
                              HEADER_RECORD, 
                              CHAR * >
{
public:
    REQUEST_HEADER_HASH() 
      : CTypedHashTable< REQUEST_HEADER_HASH, 
                         HEADER_RECORD, 
                         CHAR * >
            ("REQUEST_HEADER_HASH")
    {
    }
    
    static 
    CHAR *
    ExtractKey(
        const HEADER_RECORD * pRecord
    )
    {
        DBG_ASSERT( pRecord != NULL );
        return pRecord->_pszName;
    }
    
    static
    DWORD
    CalcKeyHash(
        CHAR *                 pszKey
    )
    {
        return HashStringNoCase( pszKey ); 
    }
     
    static
    bool
    EqualKeys(
        CHAR *                 pszKey1,
        CHAR *                 pszKey2
    )
    {
        return _stricmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        HEADER_RECORD *       pEntry,
        int                         nIncr
    )
    {
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );
    
    static
    ULONG
    GetIndex(
        CHAR *             pszName
    )
    {
        HEADER_RECORD *       pRecord = NULL;
        LK_RETCODE                  retCode;
        HRESULT                     hr;

        retCode = sm_pRequestHash->FindKey( pszName,
                                            &pRecord );
        if ( retCode == LK_SUCCESS )
        {
            DBG_ASSERT( pRecord != NULL );
            return pRecord->_ulHeaderIndex;
        }
        else
        {
            return UNKNOWN_INDEX;
        }
    }
    
    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        DWORD *             pcchLength
    )
    {
        if ( ulIndex < HttpHeaderRequestMaximum )
        {
            *pcchLength = sm_rgHeaders[ ulIndex ]._cchName;
            return sm_rgHeaders[ ulIndex ]._pszName;
        }
        
        return NULL;
    }
    
private:

    static REQUEST_HEADER_HASH  *sm_pRequestHash;
    static HEADER_RECORD         sm_rgHeaders[];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\responseheaderhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

RESPONSE_HEADER_HASH *RESPONSE_HEADER_HASH::sm_pResponseHash;

HEADER_RECORD RESPONSE_HEADER_HASH::sm_rgHeaders[] = 
{
    //
    // The only consumer of this data is W3_REQUEST::GetHeader
    // GetServerVariable is handled by SERVER_VARIABLE_HASH, so we do
    // not need to store the HTTP_'ed and capitalized names here
    //

    { HttpHeaderCacheControl       , HEADER("Cache-Control") },
    { HttpHeaderConnection         , HEADER("Connection") },
    { HttpHeaderDate               , HEADER("Date") },
    { HttpHeaderKeepAlive          , HEADER("Keep-Alive") },
    { HttpHeaderPragma             , HEADER("Pragma") },
    { HttpHeaderTrailer            , HEADER("Trailer") },
    { HttpHeaderTransferEncoding   , HEADER("Transfer-Encoding") },
    { HttpHeaderUpgrade            , HEADER("Upgrade") },
    { HttpHeaderVia                , HEADER("Via") },
    { HttpHeaderWarning            , HEADER("Warning") },
    { HttpHeaderAllow              , HEADER("Allow") },
    { HttpHeaderContentLength      , HEADER("Content-Length") },
    { HttpHeaderContentType        , HEADER("Content-Type") },
    { HttpHeaderContentEncoding    , HEADER("Content-Encoding") },
    { HttpHeaderContentLanguage    , HEADER("Content-Language") },
    { HttpHeaderContentLocation    , HEADER("Content-Location") },
    { HttpHeaderContentMd5         , HEADER("Content-Md5") },
    { HttpHeaderContentRange       , HEADER("Content-Range") },
    { HttpHeaderExpires            , HEADER("Expires") },
    { HttpHeaderLastModified       , HEADER("Last-Modified") },
    { HttpHeaderAcceptRanges       , HEADER("Accept-Ranges") },
    { HttpHeaderAge                , HEADER("Age") },
    { HttpHeaderEtag               , HEADER("ETag") },
    { HttpHeaderLocation           , HEADER("Location") },
    { HttpHeaderProxyAuthenticate  , HEADER("Proxy-Authenticate") },
    { HttpHeaderRetryAfter         , HEADER("Retry-After") },
    { HttpHeaderServer             , HEADER("Server") },
    // Set it to something which cannot be a header name, in effect
    // making Set-Cookie an unknown header
    { HttpHeaderSetCookie          , HEADER("a:b\r\n") },
    { HttpHeaderVary               , HEADER("Vary") },
    // Set it to something which cannot be a header name, in effect
    // making WWW-Authenticate an unknown header
    { HttpHeaderWwwAuthenticate    , HEADER("b:c\r\n") }
};

//static
HRESULT
RESPONSE_HEADER_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HEADER_RECORD *     pRecord;
    LK_RETCODE          lkrc = LK_SUCCESS;
    DWORD               dwNumRecords;
    
    //
    // Add header index/name to hash table
    //
    
    sm_pResponseHash = new RESPONSE_HEADER_HASH();
    if ( sm_pResponseHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Add every string->routine mapping
    //

    dwNumRecords = sizeof( sm_rgHeaders ) / sizeof( HEADER_RECORD );
    
    for ( DWORD i = 0; i < dwNumRecords; i++ )
    {
        pRecord = &(sm_rgHeaders[ i ]); 
        lkrc = sm_pResponseHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pResponseHash;
        sm_pResponseHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // BUGBUG
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
RESPONSE_HEADER_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pResponseHash != NULL )
    {
        delete sm_pResponseHash;
        sm_pResponseHash = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\staticfile.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     staticfile.cxx

   Abstract:
     Handle static file request
 
   Author:
     Bilal Alam (balam)             7-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "staticfile.hxx"

ALLOC_CACHE_HANDLER *       W3_STATIC_FILE_HANDLER::sm_pachStaticFileHandlers;

HRESULT
W3_STATIC_FILE_HANDLER::HandleDefaultLoad(
    W3_CONTEXT *            pW3Context,
    BOOL *                  pfHandled,
    BOOL *                  pfAsyncPending
)
/*++

Routine Description:

    Attempts to find a default load file applicable for this request.  If it
    does, it will switch the URL of the request and back track.

Arguments:

    pW3Context - Context
    pfHandled - Set to TRUE if this function has set a response or switched URL
                (in other words, no more processing is required)
    pfAsyncPending - Set to TRUE if async is pending so bail
    
Return Value:

    HRESULT - If not NO_ERROR, then *pfHandled is irrelevent

--*/
{
    URL_CONTEXT *           pUrlContext;
    W3_METADATA *           pMetaData;
    STACK_STRU(             strDefaultFiles, MAX_PATH );
    HRESULT                 hr = NO_ERROR;
    W3_REQUEST *            pRequest = pW3Context->QueryRequest();
    STRU *                  pstrPhysical;
    STACK_STRU(             strNextFile, MAX_PATH );
    WCHAR *                 pszNextFile;
    WCHAR *                 pszEndFile;
    W3_FILE_INFO *          pOpenFile = NULL;
    BOOL                    fFound = FALSE;
    STACK_STRU(             strNewUrl, MAX_PATH );
    WCHAR *                 pszQuery;
    CONTEXT_STATUS          status;
    FILE_CACHE_USER         FileUser;
    
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pRequest != NULL );
    DBG_ASSERT( pfHandled != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );

    *pfHandled = FALSE;
    *pfAsyncPending = FALSE;

    //
    // Get the configuration info
    //
    
    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
   
    pstrPhysical = pUrlContext->QueryPhysicalPath();
    DBG_ASSERT( pstrPhysical != NULL );
    
    //
    // First ensure the path is / suffixed.  Otherwise, redirect to such
    //
    if (pstrPhysical->QueryStr()[pstrPhysical->QueryCCH() - 1] != L'\\')
    {
        //
        // Before redirecting, first make sure it is a GET or a HEAD
        //
        HTTP_VERB VerbType = pRequest->QueryVerbType();
        if ( VerbType != HttpVerbGET &&
             VerbType != HttpVerbHEAD )
        {
            pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
            hr = pW3Context->SetupAllowHeader();
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            return S_OK;
        }

        STACK_STRU (strRedirect, MAX_PATH );

        //
        // Append the suffix '/'
        //
        if (FAILED(hr = pRequest->GetUrl(&strRedirect)) ||
            FAILED(hr = strRedirect.Append(L"/")))
        {
            return hr;
        }

        //
        // Do the HTTP redirect
        //
        if (FAILED(hr = pW3Context->SetupHttpRedirect(strRedirect,
                                                      TRUE,
                                                      HttpStatusMovedPermanently)))
        {
            return hr;
        }

        //
        // Tell callers we are finished
        //
        *pfHandled = TRUE;
        return S_OK;
    }
    
    //
    // Look for default load files
    // 
    
    hr = strDefaultFiles.Copy( *pMetaData->QueryDefaultLoadFiles() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    pszNextFile = strDefaultFiles.QueryStr();
    while ( pszNextFile != NULL && 
            *pszNextFile != L'\0' )
    {
        pszEndFile = wcschr( pszNextFile, L',' );
        if ( pszEndFile != NULL )
        {
            *pszEndFile = L'\0';
        }
        
        //
        // Append portion to directory to create a filename to check for
        //
        
        hr = strNextFile.Copy( *pstrPhysical );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Remove any query string
        //
        
        pszQuery = wcschr( pszNextFile, L'?' );
        if ( pszQuery != NULL )
        {
            hr = strNextFile.Append( pszNextFile,
                                     DIFF( pszQuery - pszNextFile ) );
        }
        else
        {
            hr = strNextFile.Append( pszNextFile );
        }
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Make a FS path
        //
        
        FlipSlashes( strNextFile.QueryStr() );
        
        //
        // Open the file
        //
        
        pW3Context->QueryFileCacheUser( &FileUser );
       
        DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
        
        hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                            strNextFile,
                                            pMetaData->QueryDirmonConfig(),
                                            &FileUser,
                                            !( pMetaData->QueryNoCache() ),
                                            &pOpenFile );
        if ( FAILED( hr ) )
        {
            DWORD           dwError = WIN32_FROM_HRESULT( hr );
            
            DBG_ASSERT( pOpenFile == NULL );
            
            //
            // If not found, or name invalid, that's ok -> proceed to next file
            //
            
            if ( dwError != ERROR_FILE_NOT_FOUND &&
                 dwError != ERROR_PATH_NOT_FOUND &&
                 dwError != ERROR_INVALID_NAME )
            {
                return hr;
            }
            
            hr = NO_ERROR;
        }
        else
        {
            DWORD           dwAttributes;

            //
            // Great, we can open the file.  We only need it for attributes.
            //
            
            DBG_ASSERT( pOpenFile != NULL );
            
            dwAttributes = pOpenFile->QueryAttributes();

            pOpenFile->DereferenceCacheEntry(); 
            
            if ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {   
                //
                // For legacy, if we see a directory, our default load file
                // search is over, and we act like we never found one
                //
            
                return NO_ERROR;
            }
            
            fFound = TRUE;
            break;
        }
        
        //
        // Goto next file
        //
        
        pszNextFile = pszEndFile ? pszEndFile + 1 : NULL;
    }
    
    //
    // Change the url and retrack
    //
   
    if ( fFound )
    {
        //
        // Ok.  We can change the URL and retrack.  Do so.
        //
        
        hr = pW3Context->QueryRequest()->GetUrl( &strNewUrl );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }
        
        hr = strNewUrl.Append( pszNextFile );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Change the URL
        //       
        
        hr = pW3Context->QueryRequest()->SetUrl( strNewUrl, FALSE );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = pW3Context->ExecuteChildRequest( pW3Context->QueryRequest(),
                                              FALSE,
                                              W3_FLAG_ASYNC );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        else
        {
            *pfHandled = TRUE;
            *pfAsyncPending = TRUE;
            return NO_ERROR;
        }
    } 
    else
    {
        //
        // If not found, the caller will continue since *pfHandled == FALSE
        // if we're here
        //
    }
    
    return NO_ERROR;
}

HRESULT
W3_STATIC_FILE_HANDLER::DirectoryDoWork(
    W3_CONTEXT *            pW3Context,
    BOOL *                  pfAsyncPending
)
/*++

Routine Description:

    Handle directories.  This means default loads and directory listings

Arguments:

    pW3Context - Context
    pfAsyncPending - Set to TRUE if async pending
    
Return Value:

    HRESULT

--*/
{
    DWORD               dwDirBrowseFlags;
    URL_CONTEXT *       pUrlContext;
    HRESULT             hr;
    BOOL                fHandled = FALSE;
    FILE_CACHE_USER     fileUser;
    BOOL                fImpersonated = FALSE;

    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pfAsyncPending != NULL );
    
    *pfAsyncPending = FALSE;

    W3_REQUEST *pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    W3_RESPONSE *pResponse = pW3Context->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    STRU *pstrPhysical = pUrlContext->QueryPhysicalPath();
    DBG_ASSERT( pstrPhysical != NULL );

    //
    // Get the directory browsing flags for this directory
    //
    dwDirBrowseFlags = pUrlContext->QueryMetaData()->QueryDirBrowseFlags();

    //
    // First check for a default load (by first checking whether we are 
    // allowed to serve default load)
    //
    if ( dwDirBrowseFlags & MD_DIRBROW_LOADDEFAULT )
    {
        //
        // OK.  Look for a default load
        //
        
        hr = HandleDefaultLoad( pW3Context,
                                &fHandled,
                                pfAsyncPending );
                                
        if ( FAILED( hr ) || fHandled || *pfAsyncPending )
        {
            return hr;
        }
    }
    
    //
    // If doing directory listing, first make sure it is a GET or a HEAD
    //
    HTTP_VERB VerbType = pRequest->QueryVerbType();
    if ( VerbType != HttpVerbGET &&
         VerbType != HttpVerbHEAD )
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
        hr = pW3Context->SetupAllowHeader();
        if ( FAILED( hr ) )
        {
            return hr;
        }

        return S_OK;
    }

    //
    // OK.  Check for whether directory listings are enabled
    //
    if ( dwDirBrowseFlags & MD_DIRBROW_ENABLED )
    {
        //
        // We may need to impersonate some other user to open the file
        //
    
        pW3Context->QueryFileCacheUser( &fileUser );

        if ( fileUser._hToken != NULL )
        {
            if ( !SetThreadToken( NULL, fileUser._hToken ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            fImpersonated = TRUE;
        }
    
        hr = HandleDirectoryListing( pW3Context,
                                     &fHandled );

        if( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }
        
        if ( FAILED( hr ) || fHandled )
        {
            return hr;
        }
    }
    
    //
    // If we are here, then neither browsing nor default loads are enabled.
    // There is nothing we can do but return a 403.
    //
    
    pW3Context->QueryResponse()->SetStatus( HttpStatusForbidden,
                                            Http403DirBrowsingDenied );
    return NO_ERROR;
}


HRESULT
GetTypeAndSubType(
    CHAR *                  pszType,
    STRA *                  pstrMainType,
    STRA *                  pstrSubType,
    BOOL *                  pfTypeOk
)
/*++

Routine Description:

    Given a mimetype of "foobar/barfoo", return "foobar" as the main type 
    and "barfoo" as the subtype.

Arguments:
    
    pszType - Whole mime type
    pstrMainType - Filled with main type
    pstrSubType - Filled with sub type
    pfTypeOk - Is this mime type ok?
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    CHAR * pszSlash = strchr( pszType, '/' );
    if (pszSlash == NULL)
    {
        *pfTypeOk = FALSE;
        return S_OK;
    }

    hr = pstrMainType->Copy( pszType,
                             DIFF( pszSlash - pszType ) );
    hr = pstrSubType->Copy( pszSlash + 1 );

    *pfTypeOk = TRUE;
    return hr;
}


HRESULT
IsAcceptable(
    CHAR *              pszContentType,
    CHAR *              pszAcceptHeader,
    BOOL *              pfIsAcceptAble
)
/*++

Routine Description:

    Return whether given content type is acceptable for the given
    Accept: header

Arguments:

    pszContentType - Content type
    pszAcceptHeader - Accept header to check    
    pfIsAcceptAble - Filled with bool indicating whether type is acceptable
    
Return Value:

    HRESULT

--*/
{
    HRESULT         hr;
    BOOL            fTypeOk;

    //
    // Quickly handle the */* case
    //
    
    if ( pszAcceptHeader[ 0 ] == '*' &&
         pszAcceptHeader[ 1 ] == '/' &&
         pszAcceptHeader[ 2 ] == '*' &&
         pszAcceptHeader[ 3 ] == '\0' )
    {
        *pfIsAcceptAble = TRUE;
        return S_OK;
    }

    //
    // Break the Content-Type into the main- and sub-content-type
    //
    STACK_STRA ( strMainContentType, 32);
    STACK_STRA ( strSubContentType, 32);
    if ( FAILED( hr = GetTypeAndSubType( pszContentType,
                                         &strMainContentType,
                                         &strSubContentType,
                                         &fTypeOk ) ) )
    {
        return hr;
    }
    if ( !fTypeOk )
    {
        *pfIsAcceptAble = FALSE;
        return S_OK;
    }

    //
    // Skip over any spaces
    //
    while ( *pszAcceptHeader == ' ' )
    {
        pszAcceptHeader++;
    }

    STACK_STRA (strAcceptType, 64);
    STACK_STRA (strMainAcceptType, 32);
    STACK_STRA (strSubAcceptType, 32);

    while (TRUE)
    {
        //
        // Multiple Acceptable Types are ',' separated, get the next one
        //
        CHAR * pszComma = strchr( pszAcceptHeader, L',' );
        if ( pszComma == NULL )
        {
            if ( FAILED( hr = strAcceptType.Copy( pszAcceptHeader ) ) )
            {
                return hr;
            }
        }
        else
        {
            if ( FAILED( hr = strAcceptType.Copy( pszAcceptHeader,
                                  DIFF( pszComma - pszAcceptHeader ) ) ) )
            {
                return hr;
            }
        }

        //
        // Trim out any quality specifier specified after a ';'
        //
        CHAR * pszQuality = strchr( strAcceptType.QueryStr(), ';' );
        if ( pszQuality != NULL )
        {
            strAcceptType.SetLen(DIFF(pszQuality - strAcceptType.QueryStr()));
        }

        //
        // Trim any spaces at the end
        //
        INT iSpace = strAcceptType.QueryCCH() - 1;
        while ( iSpace >= 0 &&
                strAcceptType.QueryStr()[iSpace] == ' ' )
        {
            iSpace--;
        }
        strAcceptType.SetLen( iSpace + 1 );

        //
        // Just check if this Type is */*
        //
        if ( !strcmp( strAcceptType.QueryStr(), "*/*" ) )
        {
            *pfIsAcceptAble = TRUE;
            return S_OK;
        }

        //
        // Get the main- and sub-Accept types for this type
        //
        if ( FAILED(hr = GetTypeAndSubType( strAcceptType.QueryStr(),
                                            &strMainAcceptType,
                                            &strSubAcceptType,
                                            &fTypeOk ) ) )
        {
            return hr;
        }
        if ( !fTypeOk )
        {
            *pfIsAcceptAble = TRUE;
            return S_OK;
        }

        //
        // Now actually find out if this type is acceptable
        //
        if ( !_stricmp( strMainAcceptType.QueryStr(),
                        strMainContentType.QueryStr() ) )
        {
            if ( !strcmp( strSubAcceptType.QueryStr(), "*" ) ||
                 !_stricmp( strSubAcceptType.QueryStr(),
                            strSubContentType.QueryStr() ) )
            {
                *pfIsAcceptAble = TRUE;
                return S_OK;
            }
        }

        //
        // Set AcceptHeader to the start of the next type
        //
        if (pszComma == NULL)
        {
            *pfIsAcceptAble = FALSE;
            return S_OK;
        }
        pszAcceptHeader = pszComma + 1;
        while ( *pszAcceptHeader == ' ' )
        {
            pszAcceptHeader++;
        }
    }
}


HRESULT
W3_STATIC_FILE_HANDLER::FileDoWork(
    W3_CONTEXT *                pW3Context,
    W3_FILE_INFO *              pOpenFile
)
/*++

Routine Description:

    Handle files (non-directories).

Arguments:

    pW3Context - Context
    pOpenFile - W3_FILE_INFO with the file to send
    
Return Value:

    HRESULT

--*/
{
    LARGE_INTEGER       liFileSize;
    W3_RESPONSE *       pResponse;
    W3_REQUEST  *       pRequest;
    W3_URL_INFO *       pUrlInfo;
    W3_METADATA *       pMetaData;
    BOOL                fRet;
    HRESULT             hr;
    STACK_STRU        ( strUrl, MAX_PATH );
    CHAR *              pszRange;
    BOOL                fHandled = FALSE;
    FILE_CACHE_USER     fileUser;

    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pOpenFile != NULL );
    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT( pResponse != NULL );
    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    pUrlInfo = pW3Context->QueryUrlContext()->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );
    pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );


    //
    // First make sure it a GET or a HEAD
    //
    HTTP_VERB VerbType = pRequest->QueryVerbType();
    if ( VerbType != HttpVerbGET &&
         VerbType != HttpVerbHEAD )
    {
        pW3Context->QueryResponse()->SetStatus( HttpStatusMethodNotAllowed );
        hr = pW3Context->SetupAllowHeader();
        if ( FAILED( hr ) )
        {
            return hr;
        }

        return S_OK;
    }

    //
    // If this an image-map file, do the image-map stuff
    //
    if (pUrlInfo->QueryGateway() == GATEWAY_MAP)
    {
        fHandled = FALSE;
        hr = MapFileDoWork(pW3Context, pOpenFile, &fHandled);
        if (FAILED(hr) ||
            fHandled)
        {
            return hr;
        }

        //
        // fHandled was false, so this is a .map file which wasn't really
        // an image-map file, handle it as any other static file
        //
    }

    //
    // Do compression, if so configured
    //
    if (pMetaData->QueryDoStaticCompression() &&
        !pW3Context->QueryDoneWithCompression())
    {
        //
        // If this file is compressible, don't let UL store the uncompressed
        // version in its cache
        //
        pW3Context->DisableUlCache();

        if (FAILED(hr = HTTP_COMPRESSION::DoStaticFileCompression(
                            pW3Context, &pOpenFile)))
        {
            return hr;
        }
        m_pOpenFile = pOpenFile;
    }

    //
    // First see if the Content-Type is acceptable to the client
    //

    STRA *pstrContentType = pUrlInfo->QueryContentType();
    CHAR * pszAccept      = pRequest->GetHeader( HttpHeaderAccept );
    if ( pszAccept != NULL && *pszAccept != L'\0' )
    {
        BOOL fIsAcceptAble;

        if ( FAILED( hr = IsAcceptable( pstrContentType->QueryStr(),
                                        pszAccept,
                                        &fIsAcceptAble ) ) )
        {
            return hr;
        }

        if ( !fIsAcceptAble )
        {
            pResponse->ClearHeaders();
            pResponse->SetStatus( HttpStatusNotAcceptable );
            return S_OK;
        }
    }

    //
    // Setup the response headers.  First ETag
    //

    hr = pResponse->SetHeaderByReference( HttpHeaderEtag,
                                          pOpenFile->QueryETag(),
                                          pOpenFile->QueryETagSize() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Next is Last-Modified
    //
    
    hr = pResponse->SetHeaderByReference( HttpHeaderLastModified,
                                          pOpenFile->QueryLastModifiedString(),
                                          GMT_STRING_SIZE - 1 );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Next is Content-Location.  We only need to send this header if 
    // we have internally changed the URL of the request.  In other words,
    // if this is a child execute
    //
    
    if ( pW3Context->QuerySendLocation() )
    {
        STACK_STRA (strContentLocation, MAX_PATH);
        STACK_STRA (strRawUrl, MAX_PATH);

        if (FAILED(hr = pRequest->GetRawUrl(&strRawUrl)) ||
            FAILED(hr = pRequest->BuildFullUrl(strRawUrl,
                                               &strContentLocation,
                                               FALSE)) ||
            FAILED(hr = pResponse->SetHeader(HttpHeaderContentLocation,
                                             strContentLocation.QueryStr(),
                                             strContentLocation.QueryCCH())))
        {
            return hr;
        }
    }
    
    //
    // Next is Accept-Ranges
    //
    if ( FAILED( hr = pResponse->SetHeaderByReference( HttpHeaderAcceptRanges,
                                                       "bytes", 5 ) ) )
    {
        goto Failure;
    }

    //
    // Handle the If-* (except If-Range) headers if present
    //
    fHandled = FALSE;
    if ( FAILED( hr = CacheValidationDoWork( pW3Context,
                                             pOpenFile,
                                             &fHandled ) ) )
    {
        goto Failure;
    }

    if ( fHandled )
    {
        return hr;
    }

    //
    // Now handle If-Range and Range headers
    //
    pszRange = pRequest->GetHeader( HttpHeaderRange );
    if ( ( pszRange != NULL ) &&
         ( !_strnicmp ( pszRange, "bytes", 5 ) ) )
    {
        //
        // Handle range request
        //
        fHandled = FALSE;
        if ( FAILED( hr = RangeDoWork( pW3Context, pOpenFile, &fHandled ) ) )
        {
            goto Failure;
        }

        if ( fHandled )
        {
            return hr;
        }
    }

    //
    // If we fell thru, then we are sending out the entire file
    //

    //
    // Setup Content-Type
    //
    if ( FAILED( hr = pResponse->SetHeaderByReference(
                          HttpHeaderContentType,
                          pstrContentType->QueryStr(),
                          pstrContentType->QueryCCH() ) ) )
    {
        goto Failure;
    }

    //
    // Setup the response chunks
    //
    pOpenFile->QuerySize( &liFileSize );

    if (liFileSize.QuadPart > 0)
    {
        if ( pOpenFile->QueryFileBuffer() != NULL &&
             liFileSize.HighPart == 0 )
        {
            hr = pResponse->AddMemoryChunkByReference( 
                                pOpenFile->QueryFileBuffer(),
                                liFileSize.LowPart );
        }
        else
        {
            hr = pResponse->AddFileHandleChunk( pOpenFile->QueryFileHandle(),
                                                0,
                                                liFileSize.QuadPart );
        }

        if ( FAILED( hr ) )
        {
            goto Failure;
        }
    }

    // perf ctr
    pW3Context->QuerySite()->IncFilesSent();

    // Setup the document footer
    if (pMetaData->QueryIsFooterEnabled())
    {
        if (!pMetaData->QueryFooterString()->IsEmpty() )
        {
            STRA *pFooterString = pMetaData->QueryFooterString();
            if (pFooterString->QueryCCH())
            {
                if (FAILED(hr = pResponse->AddMemoryChunkByReference(
                                               pFooterString->QueryStr(),
                                               pFooterString->QueryCCH())))
                {
                    goto Failure;
                }
            }
        }
        else if (!pMetaData->QueryFooterDocument()->IsEmpty() )
        {
            DBG_ASSERT( m_pFooterDocument == NULL );
            
            DBG_ASSERT( g_pW3Server->QueryFileCache() );
            
            hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                        *(pMetaData->QueryFooterDocument()),
                                        NULL,
                                        &fileUser,
                                        TRUE,
                                        &m_pFooterDocument );
            if ( SUCCEEDED( hr ) )
            {
                DBG_ASSERT( m_pFooterDocument != NULL );
                
                m_pFooterDocument->QuerySize( &liFileSize );

                if (liFileSize.QuadPart > 0)
                {
                    if ( m_pFooterDocument->QueryFileBuffer() != NULL &&
                         liFileSize.HighPart == 0 )
                    {
                        hr = pResponse->AddMemoryChunkByReference( 
                                        m_pFooterDocument->QueryFileBuffer(),
                                        liFileSize.LowPart );
                    }
                    else
                    {
                        hr = pResponse->AddFileHandleChunk(
                                        m_pFooterDocument->QueryFileHandle(),
                                        0,
                                        liFileSize.QuadPart );
                    }

                    if ( FAILED( hr ) )
                    {
                        goto Failure;
                    }
                }
            }
            else
            {
                //
                // Could not open the footer document.  Sub in a error string
                //

                CHAR achErrorString[ 512 ];
                DWORD cbErrorString = sizeof( achErrorString );

                hr = g_pW3Server->LoadString( IDS_ERROR_FOOTER,
                                              achErrorString,
                                              &cbErrorString );
                if ( FAILED( hr ) ) 
                {
                    goto Failure;
                }
                
                hr = m_strFooterString.Copy( achErrorString, cbErrorString );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                hr = pResponse->AddMemoryChunkByReference( 
                                        m_strFooterString.QueryStr(),
                                        m_strFooterString.QueryCCH() );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
            }
        }
    }
    
    return S_OK;
    
Failure:
    //
    // It is our responsibility to ensure that there is no incomplete response
    //
    
    pResponse->Clear();
    return hr;
}

CONTEXT_STATUS
W3_STATIC_FILE_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Execute the static file handler

Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT             hr = NO_ERROR;
    W3_RESPONSE *       pResponse = pW3Context->QueryResponse();
    W3_REQUEST *        pRequest = pW3Context->QueryRequest();
    W3_METADATA *       pMetaData;
    URL_CONTEXT *       pUrlContext;
    W3_FILE_INFO *      pOpenFile = NULL;
    BOOL                fRet;
    DWORD               dwFilePerms;
    BOOL                fAccess;
    BOOL                fAsyncPending = FALSE;
    FILE_CACHE_USER     fileUser;

    //
    // Get the metadata, in particular the cached W3_URL_INFO off which we
    // we attempt to open the file
    //
   
    pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Check web permissions.
    // Will fail, if no VROOT_MASK_READ, or if we forbid remote access and
    // the request is remote
    //
    
    dwFilePerms = pMetaData->QueryAccessPerms();

    if ( !IS_ACCESS_ALLOWED(pRequest, dwFilePerms, READ) )
    {
        pResponse->SetStatus( HttpStatusForbidden,
                              Http403ReadAccessDenied );
        goto Failure;
    }

    //
    // Now try to open the file
    //
    
    pW3Context->QueryFileCacheUser( &fileUser );

    hr = pUrlContext->OpenFile( &fileUser, &pOpenFile );
    if (FAILED(hr))
    {
        DWORD           dwError;

        IF_DEBUG( STATICFILE )
        {      
            DBGPRINTF(( DBG_CONTEXT,
                        "Error opening file %ws.  hr = %x\n",
                        pUrlContext->QueryPhysicalPath()->QueryStr(),
                        hr ));
        }
        
        dwError = WIN32_FROM_HRESULT( hr );
        switch( dwError )
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_INVALID_NAME:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusNotFound );
            break;
        
        case ERROR_LOGON_FAILURE:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_ACCESS_DENIED:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusUnauthorized,
                                  Http401Resource );
            break;
        
        case ERROR_INSUFFICIENT_BUFFER:
            hr = NO_ERROR;
            pResponse->SetStatus( HttpStatusUrlTooLong );
            break;
        }
        
        goto Failure;
    }
    
    DBG_ASSERT( pOpenFile != NULL );
    
    //
    // Is the file hidden?  If so, don't serve it out for legacy reasons
    // 
    
    if ( pOpenFile->QueryAttributes() & FILE_ATTRIBUTE_HIDDEN ) 
    {
        pOpenFile->DereferenceCacheEntry();
        pResponse->SetStatus( HttpStatusNotFound );
        goto Failure;
    }
    
    //
    // Is this a file or directory?  
    //
    
    if ( pOpenFile->QueryAttributes() & FILE_ATTRIBUTE_DIRECTORY )
    {
        //
        // At this point, we will do one of the following:
        // a) Send a directory listing
        // b) Send a default load file
        // c) Send a 302 (to redirect to a slash suffixed URL)
        // d) Send a 403 (forbidden)
        // 
        
        pOpenFile->DereferenceCacheEntry();
        pOpenFile = NULL;
        
        hr = DirectoryDoWork( pW3Context,
                              &fAsyncPending );
        if ( fAsyncPending )
        {
            return CONTEXT_STATUS_PENDING;
        }

        //
        // If access denied, then send the response now
        //
        
        if ( WIN32_FROM_HRESULT( hr ) == ERROR_ACCESS_DENIED )
        {
            pW3Context->SetErrorStatus( hr ); 
            pW3Context->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                    Http401Resource );

            hr = NO_ERROR;
        }                
    }
    else
    {
        //
        // This is just a regular file.  Serve it out
        //
        
        //
        // Save away the file now.  We will clean it up at the end of the
        // request when this current context is cleaned up
        //
        
        m_pOpenFile = pOpenFile;

        hr = FileDoWork( pW3Context,
                         pOpenFile );
    }

    //
    // If there was an error here, then generate a 500.  If successful, it
    // is assumed that the response status is already set
    //

Failure:

    if ( FAILED( hr ) )
    {
        pResponse->Clear();
        pW3Context->SetErrorStatus( hr ); 
        pResponse->SetStatus( HttpStatusServerError );
    }
    
    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        return CONTEXT_STATUS_CONTINUE;
    }
    
    return CONTEXT_STATUS_PENDING;
}

HRESULT
W3_STATIC_FILE_HANDLER::SetupUlCachedResponse(
    W3_CONTEXT *                pW3Context
)
/*++

Routine Description:

    Setup a response to be cached by UL.  In this case we will muck with
    the cached file object to 
    a) Remove its TTL
    b) Associate the current request's URL with the file object so that when
       the file object goes away, we will be called with enough info to
       flush the appropriate UL cache entry

Arguments:

    pW3Context - Context
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(             strFlushUrl, MAX_PATH );
    STACK_STRU(             strPhysicalPath, MAX_PATH );
    TOKEN_CACHE_ENTRY *     pToken;
    HRESULT                 hr;
    FILE_CACHE_USER         fileUser;
    W3_METADATA *           pMetaData;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( m_pOpenFile == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    
    //
    // If the file wasn't cached, then don't use UL cache
    //
    
    if ( m_pOpenFile->QueryCached() == FALSE )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    //
    // If this file was not accessed anonymously, then we need to do access
    // check anonymously before putting into cache
    //
    
    if ( pW3Context->QueryUserContext()->QueryAuthType() != MD_AUTH_ANONYMOUS )
    {
        pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL );
        
        pToken = pMetaData->QueryVrAccessToken();
        if ( pToken == NULL )
        {
            pToken = pMetaData->QueryAnonymousToken();
        }
        
        if ( pToken == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        }
        
        fileUser._hToken = pToken->QueryImpersonationToken();
        fileUser._pSid = pToken->QuerySid();
        
        hr = m_pOpenFile->DoAccessCheck( &fileUser );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Get the exact URL used to flush UL cache
    //
    
    hr = pW3Context->QueryMainContext()->QueryRequest()->GetOriginalFullUrl( 
                                                            &strFlushUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Get the physical path
    //
    
    hr = strPhysicalPath.Copy( m_pOpenFile->QueryPhysicalPath() );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Setup UL cache response token
    //
    
    DBG_ASSERT( g_pW3Server->QueryUlCache() != NULL );
    
    hr = g_pW3Server->QueryUlCache()->SetupUlCachedResponse( 
                                        pW3Context,
                                        strFlushUrl,
                                        strPhysicalPath );
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\responseheaderhash.h ===
#ifndef _RESPONSE_HEADERHASH_HXX_
#define _RESPONSE_HEADERHASH_HXX_

class RESPONSE_HEADER_HASH
    : public CTypedHashTable< RESPONSE_HEADER_HASH, 
                              HEADER_RECORD, 
                              CHAR * >
{
public:
    RESPONSE_HEADER_HASH() 
      : CTypedHashTable< RESPONSE_HEADER_HASH, 
                         HEADER_RECORD, 
                         CHAR * >
            ("RESPONSE_HEADER_HASH")
    {
    }
    
    static 
    CHAR *
    ExtractKey(
        const HEADER_RECORD * pRecord
    )
    {
        DBG_ASSERT( pRecord != NULL );
        return pRecord->_pszName;
    }
    
    static
    DWORD
    CalcKeyHash(
        CHAR *                 pszKey
    )
    {
        return HashStringNoCase( pszKey ); 
    }
     
    static
    bool
    EqualKeys(
        CHAR *                 pszKey1,
        CHAR *                 pszKey2
    )
    {
        return _stricmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        HEADER_RECORD *       pEntry,
        int                         nIncr
    )
    {
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );
    
    static
    ULONG
    GetIndex(
        CHAR *             pszName
    )
    {
        HEADER_RECORD *       pRecord = NULL;
        LK_RETCODE                  retCode;
        HRESULT                     hr;

        retCode = sm_pResponseHash->FindKey( pszName,
                                             &pRecord );
        if ( retCode == LK_SUCCESS )
        {
            DBG_ASSERT( pRecord != NULL );
            return pRecord->_ulHeaderIndex;
        }
        else
        {
            return UNKNOWN_INDEX;
        }
    }
    
    static
    CHAR *
    GetString(
        ULONG               ulIndex,
        DWORD *             pcchLength
    )
    {
        if ( ulIndex < HttpHeaderResponseMaximum )
        {
            *pcchLength = sm_rgHeaders[ ulIndex ]._cchName;
            return sm_rgHeaders[ ulIndex ]._pszName;
        }

        return NULL;
    }

private:

    static RESPONSE_HEADER_HASH *sm_pResponseHash;
    static HEADER_RECORD         sm_rgHeaders[];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\trace_handler.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    trace_handler.h

Abstract:

    Handler class for TRACE requests

Author:

    Anil Ruia (AnilR)           15-Mar-2000

Revision History:

--*/

#ifndef _TRACE_HANDLER_H_
#define _TRACE_HANDLER_H_

class W3_TRACE_HANDLER : public W3_HANDLER
{
public:
    W3_TRACE_HANDLER( W3_CONTEXT * pW3Context )
        : W3_HANDLER( pW3Context )
    {
    }

    WCHAR *
    QueryName(
        VOID
    )
    {
        return L"TraceHandler";
    }

    CONTEXT_STATUS
    DoWork(
        VOID
    );

    static
    HRESULT
    Initialize(
        VOID
    )
    {
        return NO_ERROR;
    }

    static
    VOID
    Terminate(
        VOID
    )
    {
    }
    
private:
    STRA   _strResponse;
};

#endif // _TRACE_HANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\requestheaderhash.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     headerhash.cxx

   Abstract:
     Header hash goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

REQUEST_HEADER_HASH *REQUEST_HEADER_HASH::sm_pRequestHash;

HEADER_RECORD REQUEST_HEADER_HASH::sm_rgHeaders[] = 
{
    //
    // The only consumer of this data is W3_REQUEST::GetHeader
    // GetServerVariable is handled by SERVER_VARIABLE_HASH, so we do
    // not need to store the HTTP_'ed and capitalized names here
    //

    { HttpHeaderCacheControl       , HEADER("Cache-Control") },
    { HttpHeaderConnection         , HEADER("Connection") },
    { HttpHeaderDate               , HEADER("Date") },
    { HttpHeaderKeepAlive          , HEADER("Keep-Alive") },
    { HttpHeaderPragma             , HEADER("Pragma") },
    { HttpHeaderTrailer            , HEADER("Trailer") },
    { HttpHeaderTransferEncoding   , HEADER("Transfer-Encoding") },
    { HttpHeaderUpgrade            , HEADER("Upgrade") },
    { HttpHeaderVia                , HEADER("Via") },
    { HttpHeaderWarning            , HEADER("Warning") },
    { HttpHeaderAllow              , HEADER("Allow") },
    { HttpHeaderContentLength      , HEADER("Content-Length") },
    { HttpHeaderContentType        , HEADER("Content-Type") },
    { HttpHeaderContentEncoding    , HEADER("Content-Encoding") },
    { HttpHeaderContentLanguage    , HEADER("Content-Language") },
    { HttpHeaderContentLocation    , HEADER("Content-Location") },
    { HttpHeaderContentMd5         , HEADER("Content-Md5") },
    { HttpHeaderContentRange       , HEADER("Content-Range") },
    { HttpHeaderExpires            , HEADER("Expires") },
    { HttpHeaderLastModified       , HEADER("Last-Modified") },
    { HttpHeaderAccept             , HEADER("Accept") },
    { HttpHeaderAcceptCharset      , HEADER("Accept-Charset") },
    { HttpHeaderAcceptEncoding     , HEADER("Accept-Encoding") },
    { HttpHeaderAcceptLanguage     , HEADER("Accept-Language") },
    { HttpHeaderAuthorization      , HEADER("Authorization") },
    { HttpHeaderCookie             , HEADER("Cookie") },
    { HttpHeaderExpect             , HEADER("Expect") },
    { HttpHeaderFrom               , HEADER("From") },
    { HttpHeaderHost               , HEADER("Host") },
    { HttpHeaderIfMatch            , HEADER("If-Match") },
    { HttpHeaderIfModifiedSince    , HEADER("If-Modified-Since") },
    { HttpHeaderIfNoneMatch        , HEADER("If-None-Match") },
    { HttpHeaderIfRange            , HEADER("If-Range") },
    { HttpHeaderIfUnmodifiedSince  , HEADER("If-Unmodified-Since") },
    { HttpHeaderMaxForwards        , HEADER("Max-Forwards") },
    { HttpHeaderProxyAuthorization , HEADER("Proxy-Authorization") },
    { HttpHeaderReferer            , HEADER("Referer") },
    { HttpHeaderRange              , HEADER("Range") },
    { HttpHeaderTe                 , HEADER("TE") },
    { HttpHeaderTranslate          , HEADER("Translate") },
    { HttpHeaderUserAgent          , HEADER("User-Agent") }
};

//static
HRESULT
REQUEST_HEADER_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global header hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HEADER_RECORD *     pRecord;
    LK_RETCODE          lkrc = LK_SUCCESS;
    DWORD               dwNumRecords;
    
    //
    // Add header index/name to hash table
    //
    
    sm_pRequestHash = new REQUEST_HEADER_HASH();
    if ( sm_pRequestHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Add every string->routine mapping
    //

    dwNumRecords = sizeof( sm_rgHeaders ) / sizeof( HEADER_RECORD );
    
    for ( DWORD i = 0; i < dwNumRecords; i++ )
    {
        pRecord = &(sm_rgHeaders[ i ]); 
        lkrc = sm_pRequestHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // BUGBUG
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
REQUEST_HEADER_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Global cleanup of header hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pRequestHash != NULL )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\trace_handler.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     trace_handler.cxx

   Abstract:
     Handle TRACE requests
 
   Author:
     Anil Ruia (AnilR)              15-Mar-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "trace_handler.h"

CONTEXT_STATUS 
W3_TRACE_HANDLER::DoWork(
    VOID
)
/*++

Routine Description:

    Do the TRACE thing

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    HRESULT             hr = S_OK;
    W3_REQUEST *        pRequest;
    W3_RESPONSE *       pResponse;
    STACK_STRA(         strTemp, 256 );
    DWORD               cbAlreadyAvailable;
    PVOID               pvAlreadyAvailable;
    
    pRequest = pW3Context->QueryRequest();
    DBG_ASSERT(pRequest != NULL);

    pResponse = pW3Context->QueryResponse();
    DBG_ASSERT(pResponse != NULL);

    //
    // If entity body with request, BAD request
    //
    
    pW3Context->QueryAlreadyAvailableEntity( &pvAlreadyAvailable,
                                             &cbAlreadyAvailable );
    
    if ( cbAlreadyAvailable ||
         pW3Context->QueryRemainingEntityFromUl() != 0 )
    {
        pResponse->SetStatus( HttpStatusBadRequest );
        goto Finished;
    }
    
    //
    // Build the request line
    //
    
    if ( FAILED( hr = pRequest->GetVerbString(&_strResponse) ) ||
         FAILED( hr = _strResponse.Append(" ") ) ||
         FAILED( hr = pRequest->GetRawUrl(&strTemp) ) ||
         FAILED( hr = _strResponse.Append(strTemp) ) ||
         FAILED( hr = _strResponse.Append(" ") ) ||
         FAILED( hr = pRequest->GetVersionString(&strTemp) ) ||
         FAILED( hr = _strResponse.Append(strTemp) ) ||
         FAILED( hr = _strResponse.Append("\r\n") ) )
    {
        goto Finished;
    }

    //
    // Echo the request headers (and trailing blank line)
    //
    
    if ( FAILED( hr = pRequest->GetAllHeaders( &_strResponse, FALSE ) ) ||
         FAILED( hr = _strResponse.Append("\r\n") ) )
    {
        goto Finished;
    }

    //
    // Set content type as message/http
    //
 
    hr = pResponse->SetHeader( HttpHeaderContentType, 
                               "message/http", 
                               12 );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = pResponse->AddMemoryChunkByReference( _strResponse.QueryStr(),
                                               _strResponse.QueryCCH() );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );
        pResponse->SetStatus( HttpStatusServerError );
    }
   
    hr = pW3Context->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pW3Context->SetErrorStatus( hr );  
        return CONTEXT_STATUS_CONTINUE;   
    }
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\sspiprovider.cxx ===
/*++
   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     sspiprovider.cxx

   Abstract:
     SSPI authentication provider
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "sspiprovider.hxx"
#include "uuencode.hxx"

ALLOC_CACHE_HANDLER * SSPI_SECURITY_CONTEXT::sm_pachSSPISecContext = NULL;

CRITICAL_SECTION     SSPI_CREDENTIAL::sm_csCredentials;
LIST_ENTRY           SSPI_CREDENTIAL::sm_CredentialListHead;

//static
HRESULT
SSPI_CREDENTIAL::Initialize(
    VOID
)
/*++

  Description:

    Credential cache initialization

  Arguments:

    None

  Returns:

    HRESULT

--*/
{
    InitializeListHead( &sm_CredentialListHead );
    INITIALIZE_CRITICAL_SECTION( &sm_csCredentials );
    return NO_ERROR;
}

//static
VOID
SSPI_CREDENTIAL::Terminate(
    VOID
)
/*++

  Description:

    Credential cache cleanup

  Arguments:

    None

  Returns:

    None

--*/
{
    SSPI_CREDENTIAL *           pCred = NULL;
    
    EnterCriticalSection( &sm_csCredentials );

    while ( !IsListEmpty( &sm_CredentialListHead ))
    {
        pCred = CONTAINING_RECORD( sm_CredentialListHead.Flink,
                                   SSPI_CREDENTIAL,
                                   m_ListEntry );

        RemoveEntryList( &pCred->m_ListEntry );
        
        pCred->m_ListEntry.Flink = NULL;

        delete pCred;
    }

    LeaveCriticalSection( &sm_csCredentials );

    DeleteCriticalSection( &sm_csCredentials );
}    

//static
HRESULT
SSPI_CREDENTIAL::GetCredential(
    CHAR *              pszPackage, 
    SSPI_CREDENTIAL **  ppCredential
)
/*++

  Description:

    Get SSPI credential handle from cache. If it does not exist 
    for the SSPI package, generates a new cache entry and adds 
    it to the credential cache

  Arguments:

    pszPackage      - SSPI package name, e.g NTLM
    ppCredential    - Set to cached credential if found

  Returns:

    HRESULT

--*/
{
    LIST_ENTRY *                pEntry;
    SSPI_CREDENTIAL *           pCred;
    SecPkgInfoA *               pSecPkg;
    TimeStamp                   LifeTime;
    SECURITY_STATUS             ss;
    HRESULT                     hr = S_OK;

    if ( pszPackage == NULL ||
         ppCredential == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCredential = NULL;

    EnterCriticalSection( &sm_csCredentials );

    for ( pEntry  = sm_CredentialListHead.Flink;
          pEntry != &sm_CredentialListHead;
          pEntry  = pEntry->Flink )
    {
        pCred = CONTAINING_RECORD( pEntry, 
                                   SSPI_CREDENTIAL, 
                                   m_ListEntry );

        if ( !strcmp( pszPackage, pCred->m_strPackageName.QueryStr() ) )
        {
            // 
            // Since we only need to read the credential info at this
            // point, leave the critical section first.
            // 
            
            LeaveCriticalSection( &sm_csCredentials );

            *ppCredential = pCred;
            return NO_ERROR;
        }
    }

    if ( ( pCred = new SSPI_CREDENTIAL ) == NULL )
    {
        LeaveCriticalSection( &sm_csCredentials );
        
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY ); 

        return hr;
    }

    hr = pCred->m_strPackageName.Copy( pszPackage );
    if ( FAILED( hr ) )
    {
        LeaveCriticalSection( &sm_csCredentials );

        delete pCred;
        pCred = NULL;

        return hr;
    }

    ss = AcquireCredentialsHandleA( NULL,             
                                    pszPackage,       
                                    SECPKG_CRED_INBOUND,
                                    NULL,             
                                    NULL,    
                                    NULL,             
                                    NULL,             
                                    &pCred->m_hCredHandle,
                                    &LifeTime );
    if ( ss != STATUS_SUCCESS )
    {
        LeaveCriticalSection( &sm_csCredentials );

        hr = HRESULT_FROM_WIN32( ss );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error acquiring credential handle, hr = %x\n",
                    hr ));

        delete pCred;
        pCred = NULL;

        return hr;
    }

    //
    //  Need to determine the max token size for this package
    //
    ss = QuerySecurityPackageInfoA( pszPackage,
                                    &pSecPkg );
    if ( ss != STATUS_SUCCESS )
    {
        LeaveCriticalSection( &sm_csCredentials );

        hr = HRESULT_FROM_WIN32( ss );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error querying security package info, hr = %x\n",
                    hr ));

        delete pCred;
        pCred = NULL;

        return hr;
    }

    pCred->m_cbMaxTokenLen = pSecPkg->cbMaxToken;
    pCred->m_fSupportsEncoding = !(pSecPkg->fCapabilities & SECPKG_FLAG_ASCII_BUFFERS); 

    //
    // Insert the credential handle to the list for future use
    //
    
    InsertHeadList( &sm_CredentialListHead, &pCred->m_ListEntry );

    LeaveCriticalSection( &sm_csCredentials );

    *ppCredential = pCred;

    FreeContextBuffer( pSecPkg );

    return hr;
}

HRESULT
SSPI_AUTH_PROVIDER::Initialize(
    DWORD dwInternalId
)
/*++

Routine Description:

    Initialize SSPI provider 

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;

    SetInternalId( dwInternalId );
    hr = SSPI_SECURITY_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = SSPI_CREDENTIAL::Initialize();
    if ( FAILED( hr ) )
    {
        SSPI_SECURITY_CONTEXT::Terminate();
        return hr;
    }
    
    return NO_ERROR;
}

VOID
SSPI_AUTH_PROVIDER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSPI provider

Arguments:

    None
    
Return Value:

    None

--*/
{
    SSPI_CREDENTIAL::Terminate();
    SSPI_SECURITY_CONTEXT::Terminate();
}

HRESULT
SSPI_AUTH_PROVIDER::DoesApply(
    W3_MAIN_CONTEXT *           pMainContext,
    BOOL *                      pfApplies
)
/*++

Routine Description:

    Does the given request have credentials applicable to the SSPI 
    provider

Arguments:

    pMainContext - Main context representing request
    pfApplies - Set to true if SSPI is applicable
    
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_METADATA *           pMetaData;
    SSPI_CONTEXT_STATE *    pContextState;
    STACK_STRA(             strPackage, 64 );
    CHAR *                  pszAuthHeader;
    
    if ( pMainContext == NULL ||
         pfApplies == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pfApplies = FALSE;

    //
    // Get the package name
    //
    
    hr = pMainContext->QueryRequest()->GetAuthType( &strPackage );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // No package, then this doesn't apply
    //
    
    if ( strPackage.IsEmpty() )
    {
        return NO_ERROR;
    }
    
    //
    // Check metabase for whether SSPI package is supported
    //

    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    if ( pMetaData->CheckAuthProvider( strPackage.QueryStr() ) )
    {
        pszAuthHeader = pMainContext->QueryRequest()->GetHeader( HttpHeaderAuthorization );
        DBG_ASSERT( pszAuthHeader != NULL );
        
        //
        // Save away the package so we don't have to calc again
        //
        
        DBG_ASSERT( !strPackage.IsEmpty() );
    
        pContextState = new (pMainContext) SSPI_CONTEXT_STATE( 
                                pszAuthHeader + strPackage.QueryCCH() + 1 );
        if ( pContextState == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        hr = pContextState->SetPackage( strPackage.QueryStr() );
        if ( FAILED( hr ) )
        {
            delete pContextState;
            return hr;
        }

        pMainContext->SetContextState( pContextState );

        *pfApplies = TRUE;
    }

    return NO_ERROR;
}

HRESULT
SSPI_AUTH_PROVIDER::DoAuthenticate(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

Description:

    Do authentication work (we will be called if we apply)

Arguments:

    pMainContext - Main context
    
Return Value:

    HRESULT

--*/
{
    SSPI_CONTEXT_STATE *        pContextState = NULL;
    W3_METADATA *               pMetaData = NULL;
    SSPI_SECURITY_CONTEXT *     pSecurityContext = NULL;
    SECURITY_STATUS             ss;
    TimeStamp                   Lifetime;
    SecBufferDesc               OutBuffDesc;
    SecBuffer                   OutSecBuff;
    SecBufferDesc               InBuffDesc;
    SecBuffer                   InSecBuff;
    ULONG                       ContextAttributes;
    SSPI_CREDENTIAL *           pCredentials = NULL;
    HRESULT                     hr;
    STACK_BUFFER              ( buffDecoded, 256 );
    CHAR *                      pszFinalBlob = NULL;
    DWORD                       cbFinalBlob;
    CtxtHandle                  hCtxtHandle;
    BOOL                        fNeedContinue = FALSE;
    SSPI_USER_CONTEXT *         pUserContext;
    BUFFER                      buffResponse;
    BOOL                        fNewConversation = TRUE;
    DWORD                       err;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pContextState = (SSPI_CONTEXT_STATE*) pMainContext->QueryContextState();
    DBG_ASSERT( pContextState != NULL );
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // If we got to here, then the package better be supported!
    //
    
    DBG_ASSERT( pMetaData->CheckAuthProvider( pContextState->QueryPackage() ) );
    
    //
    // Are we in the middle of a handshake?
    //
    
    pSecurityContext = 
         ( SSPI_SECURITY_CONTEXT * )  QueryConnectionAuthContext( pMainContext );

    //
    // If the security context indicates we are complete already, then
    // cleanup that context before proceeding to create a new one.  
    //
    
    if ( pSecurityContext != NULL &&
         pSecurityContext->QueryIsComplete() )
    {
        SetConnectionAuthContext( pMainContext,
                                  NULL );
        pSecurityContext = NULL;
    }

    if ( pSecurityContext != NULL )
    {
        DBG_ASSERT( pSecurityContext->CheckSignature() );

        pCredentials = pSecurityContext->QueryCredentials();

        fNewConversation = FALSE;
    }    
    else
    {
        //
        // Nope.  Need to create a new SSPI_SECURITY_CONTEXT and find 
        // credentials for this package
        //
        
        hr = SSPI_CREDENTIAL::GetCredential( pContextState->QueryPackage(),
                                             &pCredentials );
        
        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Error get credential handle. hr = 0x%x \n",
                      hr ));
            
            goto Failure;
        }
        
        pSecurityContext = new SSPI_SECURITY_CONTEXT( pCredentials );
        if ( pSecurityContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failure;
        }
        
        hr = SetConnectionAuthContext( pMainContext,
                                       pSecurityContext );
        if ( FAILED( hr ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                      "Failed to set Connection Auth Context. hr = 0x%x \n",
                      hr ));
            
            goto Failure;
        }

    }
    
    DBG_ASSERT( pCredentials != NULL );
    DBG_ASSERT( pSecurityContext != NULL );

    //
    // Process credential blob.
    //
    
    //
    // Should we uudecode this buffer?
    //
    
    if ( pCredentials->QuerySupportsEncoding() )
    {
        if ( !uudecode( pContextState->QueryCredentials(),
                        &buffDecoded,
                        &cbFinalBlob ) )
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                      Http401BadLogon );
            
            return NO_ERROR;
        }
        
        pszFinalBlob = (CHAR*) buffDecoded.QueryPtr();
    }
    else
    {
        pszFinalBlob = pContextState->QueryCredentials();
        cbFinalBlob = strlen(pContextState->QueryCredentials()) + 1;
    }

    //
    // Setup the response blob buffer 
    // 
    
    if ( !buffResponse.Resize( pCredentials->QueryMaxTokenSize() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }                                  

    //
    // Setup the call to AcceptSecurityContext()
    //
    
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = pCredentials->QueryMaxTokenSize();
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buffResponse.QueryPtr();

    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers  = 1;
    InBuffDesc.pBuffers  = &InSecBuff;

    InSecBuff.cbBuffer   = cbFinalBlob;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer   = pszFinalBlob;

    //
    // Let'r rip!
    //

    //
    // Set required context attributes ASC_REQ_EXTENDED_ERROR, this 
    // allows Negotiate/Kerberos to support time-skew recovery.  
    //

    ss = AcceptSecurityContext( pCredentials->QueryCredHandle(),
                                fNewConversation ? 
                                NULL :
                                pSecurityContext->QueryContextHandle(),
                                &InBuffDesc,
                                ASC_REQ_EXTENDED_ERROR,
                                SECURITY_NATIVE_DREP,
                                &hCtxtHandle,
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "AcceptSecurityContext failed, error %x\n",
                    ss ));

        if ( ss == SEC_E_LOGON_DENIED || 
             ss == SEC_E_INVALID_TOKEN )
        {
            err = GetLastError();
            if( err == ERROR_PASSWORD_MUST_CHANGE ||
                err == ERROR_PASSWORD_EXPIRED )
            {
                return HRESULT_FROM_WIN32( err );
            }

            //
            // Could not logon the user because of wrong credentials
            //
            
            pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                      Http401BadLogon );
                                                      
            pMainContext->SetErrorStatus( ss );
            hr = NO_ERROR;
        }
        else
        {
            hr = ss;
        }
        
        goto Failure;
    }

    pSecurityContext->SetContextHandle( hCtxtHandle );
    pSecurityContext->SetContextAttributes( ContextAttributes );

    if ( ss == SEC_I_CONTINUE_NEEDED ||
         ss == SEC_I_COMPLETE_AND_CONTINUE )
    {
        fNeedContinue = TRUE;
    }
    else if ( ( ss == SEC_I_COMPLETE_NEEDED ) ||
              ( ss == SEC_I_COMPLETE_AND_CONTINUE ) )
    {
        //
        // Now we just need to complete the token (if requested) and 
        // prepare it for shipping to the other side if needed
        //
        
        ss = CompleteAuthToken( &hCtxtHandle,
                                &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
        {
            hr = HRESULT_FROM_WIN32( ss );

            DBGPRINTF(( DBG_CONTEXT,
                       "Error on CompleteAuthToken, hr = 0x%x\n",
                        hr ));

            goto Failure;
        }
    }

    //
    // Format or copy to the output buffer if we need to reply
    //
    
    if ( OutSecBuff.cbBuffer != 0 && fNeedContinue )
    {
        STACK_BUFFER( buffAuthData, 256 );
        
        hr = pContextState->QueryResponseHeader()->Copy( 
                        pContextState->QueryPackage() );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying auth type, hr = 0x%x.\n",
                       hr ));
            
            goto Failure;
        }

        hr = pContextState->QueryResponseHeader()->Append( " ", 1 );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying auth header, hr = 0x%x.\n",
                       hr ));

            goto Failure;
        }

        DBG_ASSERT( pCredentials != NULL );

        if ( pCredentials->QuerySupportsEncoding() )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            (DWORD) OutSecBuff.cbBuffer,
                            &buffAuthData ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "Error uuencoding the output buffer.\n"
                         ));

                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Failure;
            }

            pszFinalBlob = (CHAR *)buffAuthData.QueryPtr();
        }
        else
        {
            pszFinalBlob = (CHAR *)OutSecBuff.pvBuffer;
        }
        
        hr = pContextState->QueryResponseHeader()->Append( pszFinalBlob );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error appending resp header, hr = 0x%x.\n",
                        hr ));

            goto Failure;
        }
        
        //
        // Add the WWW-Authenticate header
        //
        
        hr = pMainContext->QueryResponse()->SetHeader(
                          "WWW-Authenticate",
                          16, // number of chars in above string
                          pContextState->QueryResponseHeader()->QueryStr(),
                          pContextState->QueryResponseHeader()->QueryCCH() );
       
        if ( FAILED( hr ) )
        {
            goto Failure;
        }
        
        //
        // Don't let anyone else send back authentication headers when
        // the 401 is sent
        //
        
        pMainContext->SetProviderHandled( TRUE );
    }   
        
    if ( !fNeedContinue )
    {
        //
        // Create a user context and setup it up
        //
        
        pUserContext = new SSPI_USER_CONTEXT( this );
        if ( pUserContext == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Failure;
        } 
        
        hr = pUserContext->Create( pSecurityContext,
                                   pMainContext );
        if ( FAILED( hr ) )
        {
            pUserContext->DereferenceUserContext();
            pUserContext = NULL;
            goto Failure;
        }
        
        pMainContext->SetUserContext( pUserContext );
        
        //
        // Mark the security context is complete, so we can detect 
        // reauthentication on the same connection
        //
        // CODEWORK:  Can probably get away will just un-associating/deleting
        //            the SSPI_SECURITY_CONTEXT now!
        //
        
        pSecurityContext->SetIsComplete( TRUE );
    }
    else
    {
        //
        // We need to send a 401 response to continue the handshake.  
        // We have already setup the WWW-Authenticate header
        //
        
        pMainContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401BadLogon );
        
        pMainContext->SetFinishedResponse();
    }
    
    return NO_ERROR;

Failure:
    if ( pSecurityContext != NULL )
    {
         SetConnectionAuthContext( pMainContext,
                                   NULL );
         pSecurityContext = NULL;
    }

    return hr;
}

HRESULT
SSPI_AUTH_PROVIDER::OnAccessDenied(
    W3_MAIN_CONTEXT *       pMainContext
)
/*++

  Description:
    
    Add WWW-Authenticate headers

Arguments:

    pMainContext - main context
    
Return Value:

    HRESULT

--*/
{
    MULTISZA *              pProviders;
    W3_METADATA *           pMetaData;
    const CHAR *            pszProvider;
    HRESULT                 hr;
    
    if ( pMainContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pMetaData = pMainContext->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    pProviders = pMetaData->QueryAuthProviders();
    if ( pProviders != NULL )
    {
        pszProvider = pProviders->First();
        while ( pszProvider != NULL )
        {
            hr = pMainContext->QueryResponse()->SetHeader(
                                            "WWW-Authenticate",
                                            16,
                                            (CHAR *)pszProvider,
                                            strlen(pszProvider) );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pszProvider = pProviders->Next( pszProvider );
        }
    }
    
    return NO_ERROR;
}

//static
HRESULT
SSPI_SECURITY_CONTEXT::Initialize(
    VOID
)
/*++

  Description:
    
    Global SSPI_SECURITY_CONTEXT initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( SSPI_SECURITY_CONTEXT );

    DBG_ASSERT( sm_pachSSPISecContext == NULL );
    
    sm_pachSSPISecContext = new ALLOC_CACHE_HANDLER( 
                                     "SSPI_SECURITY_CONTEXT",  
                                     &acConfig );

    if ( sm_pachSSPISecContext == NULL )
    {
        HRESULT hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
               "Error initializing sm_pachSSPISecContext. hr = 0x%x\n",
               hr ));

        return hr;
    }
    
    return S_OK;

} // SSPI_SECURITY_CONTEXT::Initialize

//static
VOID
SSPI_SECURITY_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy SSPI_SECURITY_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT( sm_pachSSPISecContext != NULL );

    delete sm_pachSSPISecContext;
    sm_pachSSPISecContext = NULL;

}

HRESULT
SSPI_USER_CONTEXT::Create(
    SSPI_SECURITY_CONTEXT *         pSecurityContext,
    W3_MAIN_CONTEXT *               pMainContext
)
/*++

Routine Description:

    Create an SSPI user context

Arguments:

    pSecurityContext - container of important SSPI handles
    
Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS             ss;
    HANDLE                      hImpersonationToken;
    HRESULT                     hr;
    SecPkgContext_Names         CredNames;


    if ( pSecurityContext == NULL || 
         pMainContext == NULL )    
    {
        DBG_ASSERT( pSecurityContext != NULL );
        DBG_ASSERT( pMainContext != NULL );    

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the token
    // 
    
    ss = QuerySecurityContextToken( pSecurityContext->QueryContextHandle(), 
                                    &_hImpersonationToken );
    if ( ss == SEC_E_INVALID_HANDLE )
    {
        hr = ss;
            
        DBGPRINTF(( DBG_CONTEXT,
                   "Error QuerySecurityContextToken, hr = 0x%x.\n",
                   ss ));

        return hr;
    }

    //
    // Disable SeBackupPrivilege for impersonation token to get rid of the 
    // problem introduced by using FILE_FLAG_BACKUP_SEMANTICS in CreateFileW 
    // call in W3_FILE_INFO::OpenFile.
    //
    if ( W3_STATE_AUTHENTICATION::sm_pTokenPrivilege != NULL )
    {
        AdjustTokenPrivileges( 
                   _hImpersonationToken,
                   FALSE,
                   W3_STATE_AUTHENTICATION::sm_pTokenPrivilege,
                   NULL,
                   NULL,
                   NULL );
    }
        
    //
    // Next, the user name
    //
        
    ss = QueryContextAttributes( pSecurityContext->QueryContextHandle(),
                                 SECPKG_ATTR_NAMES,
                                 &CredNames );
    if ( !NT_SUCCESS( ss ) )
    {
        hr = ss;
          
        DBGPRINTF(( DBG_CONTEXT,
                    "QueryContextAttributes() failed with ss = 0x%x.\n",
                    ss ));

        return hr;
    }         
    else
    {
        //
        // Digest SSP may have a bug in it since the user name returned
        // is NULL, workaround here
        //

        if( CredNames.sUserName )
        {
            hr = _strUserName.Copy( CredNames.sUserName );
            FreeContextBuffer( CredNames.sUserName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }
    
    //
    // Get the package name
    //

    hr = _strPackageName.Copy( *(pSecurityContext->QueryCredentials()->QueryPackageName()));
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Is this token delegatable?
    //
    
    _fDelegatable = !!(pSecurityContext->QueryContextAttributes() & ASC_RET_DELEGATE);

    //
    // If password expiration notification is enabled
    // and Url is configured properly
    // then save expiration info
    //
    
    if( pMainContext->QuerySite()->IsAuthPwdChangeNotificationEnabled() && 
        pMainContext->QuerySite()->QueryAdvNotPwdExpUrl() != NULL )
    {
        SecPkgContext_PasswordExpiry   speExpiry;
        ss = QueryContextAttributes( 
                         pSecurityContext->QueryContextHandle(),
                         SECPKG_ATTR_PASSWORD_EXPIRY,
                         &speExpiry );

        if ( ss == STATUS_SUCCESS )
        {
            memcpy( &_AccountPwdExpiry,
                &speExpiry.tsPasswordExpires,
                sizeof(speExpiry.tsPasswordExpires) );
            _fSetAccountPwdExpiry = TRUE;
        }
    }
    
    //
    // Save a pointer to the security context
    //
    
    _pSecurityContext = pSecurityContext;
    
    return NO_ERROR;
}

HANDLE
SSPI_USER_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get primary token for this user

Arguments:

    None

Return Value:

    Token handle

--*/
{
    DBG_ASSERT( _hImpersonationToken != NULL );

    if ( _hPrimaryToken == NULL )
    {
        if ( DuplicateTokenEx( _hImpersonationToken,
                               TOKEN_ALL_ACCESS,
                               NULL,
                               SecurityImpersonation,
                               TokenPrimary,
                               &_hPrimaryToken ) )
        {
            DBG_ASSERT( _hPrimaryToken != NULL );
        }
    }
    
    return _hPrimaryToken;
}

LARGE_INTEGER *
SSPI_USER_CONTEXT::QueryExpiry(
    VOID
) 
/*++

Routine Description:

    User account expiry information
    
Arguments:

    None

Return Value:

    LARGE_INTEGER
    
--*/
{

    if ( _fSetAccountPwdExpiry )
    {
        return &_AccountPwdExpiry;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\servervar.cxx ===
/*++

   Copyright    (c)    2000   Microsoft Corporation

   Module Name :
     servervar.cxx

   Abstract:
     Server Variable evaluation goo
 
   Author:
     Bilal Alam (balam)             20-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// Hash table mapping variable name to a PFN_SERVER_VARIABLE_ROUTINE
//

SERVER_VARIABLE_HASH * SERVER_VARIABLE_HASH::sm_pRequestHash;

SERVER_VARIABLE_RECORD SERVER_VARIABLE_HASH::sm_rgServerRoutines[] =
{ 
    { "ALL_HTTP",             GetServerVariableAllHttp, NULL },
    { "ALL_RAW",              GetServerVariableAllRaw, NULL },
    { "APPL_MD_PATH",         GetServerVariableApplMdPath, GetServerVariableApplMdPathW },
    { "APPL_PHYSICAL_PATH",   GetServerVariableApplPhysicalPath, GetServerVariableApplPhysicalPathW  },
    { "AUTH_PASSWORD",        GetServerVariableAuthPassword, NULL },
    { "AUTH_TYPE",            GetServerVariableAuthType, NULL },
    { "AUTH_USER",            GetServerVariableRemoteUser, GetServerVariableRemoteUserW },
    { "CERT_COOKIE",          GetServerVariableClientCertCookie, NULL },
    { "CERT_FLAGS",           GetServerVariableClientCertFlags, NULL },
    { "CERT_ISSUER",          GetServerVariableClientCertIssuer, NULL },
    { "CERT_KEYSIZE",         GetServerVariableHttpsKeySize, NULL },
    { "CERT_SECRETKEYSIZE",   GetServerVariableHttpsSecretKeySize, NULL },
    { "CERT_SERIALNUMBER",    GetServerVariableClientCertSerialNumber, NULL },
    { "CERT_SERVER_ISSUER",   GetServerVariableHttpsServerIssuer, NULL },
    { "CERT_SERVER_SUBJECT",  GetServerVariableHttpsServerSubject, NULL },
    { "CERT_SUBJECT",         GetServerVariableClientCertSubject, NULL },
    { "CONTENT_LENGTH",       GetServerVariableContentLength, NULL },
    { "CONTENT_TYPE",         GetServerVariableContentType, NULL },
    { "GATEWAY_INTERFACE",    GetServerVariableGatewayInterface, NULL },
    { "LOGON_USER",           GetServerVariableLogonUser, GetServerVariableLogonUserW },
    { "HTTPS",                GetServerVariableHttps, NULL },
    { "HTTPS_KEYSIZE",        GetServerVariableHttpsKeySize, NULL },
    { "HTTPS_SECRETKEYSIZE",  GetServerVariableHttpsSecretKeySize, NULL },
    { "HTTPS_SERVER_ISSUER",  GetServerVariableHttpsServerIssuer, NULL },
    { "HTTPS_SERVER_SUBJECT", GetServerVariableHttpsServerSubject, NULL },
    { "INSTANCE_ID",          GetServerVariableInstanceId, NULL },
    { "INSTANCE_META_PATH",   GetServerVariableInstanceMetaPath, NULL },
    { "PATH_INFO",            GetServerVariablePathInfo, GetServerVariablePathInfoW },
    { "PATH_TRANSLATED",      GetServerVariablePathTranslated, GetServerVariablePathTranslatedW },
    { "QUERY_STRING",         GetServerVariableQueryString, NULL },
    { "REMOTE_ADDR",          GetServerVariableRemoteAddr, NULL },
    { "REMOTE_HOST",          GetServerVariableRemoteHost, NULL },
    { "REMOTE_USER",          GetServerVariableRemoteUser, GetServerVariableRemoteUserW },
    { "REQUEST_METHOD",       GetServerVariableRequestMethod, NULL },
    { "SCRIPT_NAME",          GetServerVariableUrl, GetServerVariableUrlW },
    { "SERVER_NAME",          GetServerVariableServerName, NULL },
    { "LOCAL_ADDR",           GetServerVariableLocalAddr, NULL },
    { "SERVER_PORT",          GetServerVariableServerPort, NULL },
    { "SERVER_PORT_SECURE",   GetServerVariableServerPortSecure, NULL },
    { "SERVER_PROTOCOL",      GetServerVariableHttpVersion, NULL },
    { "SERVER_SOFTWARE",      GetServerVariableServerSoftware, NULL },
    { "UNMAPPED_REMOTE_USER", GetServerVariableRemoteUser, GetServerVariableRemoteUserW },
    { "URL",                  GetServerVariableUrl, GetServerVariableUrlW },
    { "HTTP_URL",             GetServerVariableHttpUrl, NULL },
    { "HTTP_METHOD",          GetServerVariableRequestMethod, NULL },
    { "HTTP_VERSION",         GetServerVariableHttpVersion, NULL },
    { "APP_POOL_ID",          GetServerVariableAppPoolId, GetServerVariableAppPoolIdW },
    { "SCRIPT_TRANSLATED",    GetServerVariableScriptTranslated, GetServerVariableScriptTranslatedW },
    { "UNENCODED_URL",        GetServerVariableUnencodedUrl, NULL },
    { NULL,                   NULL, NULL }
};

//static
HRESULT
SERVER_VARIABLE_HASH::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize global server variable hash table

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SERVER_VARIABLE_RECORD *        pRecord;
    LK_RETCODE                      lkrc = LK_SUCCESS;
    
    sm_pRequestHash = new SERVER_VARIABLE_HASH;
    if ( sm_pRequestHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );        
    }
    
    //
    // Add every string->routine mapping
    //
    
    pRecord = sm_rgServerRoutines;
    while ( pRecord->_pszName != NULL )
    {
        lkrc = sm_pRequestHash->InsertRecord( pRecord );
        if ( lkrc != LK_SUCCESS )
        {
            break;
        }
        pRecord++;
    }
    
    //
    // If any insert failed, then fail initialization
    //
    
    if ( lkrc != LK_SUCCESS )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
        return HRESULT_FROM_WIN32( lkrc );        // ARGH
    }
    else
    {
        return NO_ERROR;
    }
}

//static
VOID
SERVER_VARIABLE_HASH::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global server variable hash table

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pRequestHash != NULL )
    {
        delete sm_pRequestHash;
        sm_pRequestHash = NULL;
    }
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariableRoutine(
    CHAR *                          pszName,
    PFN_SERVER_VARIABLE_ROUTINE   * ppfnRoutine,
    PFN_SERVER_VARIABLE_ROUTINE_W * ppfnRoutineW
)
/*++

Routine Description:

    Lookup the hash table for a routine to evaluate the given variable

Arguments:

    pszName - Name of server variable
    ppfnRoutine - Set to the routine if successful

Return Value:

    HRESULT

--*/
{
    LK_RETCODE              lkrc;
    SERVER_VARIABLE_RECORD* pServerVariableRecord = NULL;
   
    if ( pszName == NULL ||
         ppfnRoutine == NULL ||
         ppfnRoutineW == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    DBG_ASSERT( sm_pRequestHash != NULL );
    
    lkrc = sm_pRequestHash->FindKey( pszName,
                                     &pServerVariableRecord );
    if ( lkrc != LK_SUCCESS )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    else
    {
        DBG_ASSERT( pServerVariableRecord != NULL );
        
        *ppfnRoutine = pServerVariableRecord->_pfnRoutine;
        *ppfnRoutineW = pServerVariableRecord->_pfnRoutineW;
        
        return NO_ERROR;
    }
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariable(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    CHAR *                  pszBuffer,
    DWORD *                 pcbBuffer
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.
    pszVariable - Variable name to retrieve
    pszBuffer - Filled with variable on success
    pcbBuffer - On input, the size of input buffer.  On out, the required size

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    if (pszVariableName[0] == 'U' &&
        strncmp(pszVariableName, "UNICODE_", 8) == 0)
    {
        STACK_STRU (strValW, MAX_PATH);

        if (FAILED( hr = GetServerVariableW( pW3Context,
                                             pszVariableName + 8,
                                             &strValW ) ) ||
            FAILED( hr = strValW.CopyToBuffer( (LPWSTR)pszBuffer, 
                                               pcbBuffer ) ) )
        {
            return hr;
        }
    }
    else
    {
        STACK_STRA (strVal, MAX_PATH);

        if (FAILED( hr = GetServerVariable( pW3Context,
                                            pszVariableName,
                                            &strVal ) ) ||
            FAILED( hr = strVal.CopyToBuffer( pszBuffer, 
                                              pcbBuffer ) ) )
        {
            return hr;
        }
    }

    return S_OK;
}


//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariable(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    STRA *                  pstrVal
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.  If NULL, we will return an empty string (and success)
                 if the variable requested is valid.
    pszVariable - Variable name to retrieve
    pstrVal - Filled with variable on success

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = S_OK;
    PFN_SERVER_VARIABLE_ROUTINE     pfnRoutine = NULL;
    PFN_SERVER_VARIABLE_ROUTINE_W   pfnRoutineW = NULL;

    //
    // First:  Is this a server variable we know about?  If so handle it
    //         by calling the appropriate server variable routine
    //

    hr = SERVER_VARIABLE_HASH::GetServerVariableRoutine( pszVariableName,
                                                         &pfnRoutine,
                                                         &pfnRoutineW );
    if ( SUCCEEDED(hr) )
    {
        DBG_ASSERT( pfnRoutine != NULL );

        if ( pW3Context != NULL )
        {
            return pfnRoutine( pW3Context, pstrVal );
        }
        else
        {
            //
            // Just return empty string to signify that the variable is 
            // valid but we just don't know the value at this time
            //
            
            return pstrVal->Copy( "", 0 );
        }
    }

    //
    // Second:  Is this a header name (prefixed with HTTP_)
    //

    if ( pW3Context != NULL &&
         pszVariableName[ 0 ] == 'H' &&
         !strncmp( pszVariableName, "HTTP_" , 5 ) )
    {   
        STACK_STRA(        strVariable, 256 );

        hr = strVariable.Copy( pszVariableName + 5 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        // Change '_' to '-'
        PCHAR pszCursor = strchr( strVariable.QueryStr(), '_' );
        while ( pszCursor != NULL )
        {
            *pszCursor++ = '-';
            pszCursor = strchr( pszCursor, '_' );
        }

        return pW3Context->QueryRequest()->GetHeader( strVariable,
                                                      pstrVal );
    }

    return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
}

//static
HRESULT
SERVER_VARIABLE_HASH::GetServerVariableW(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszVariableName,
    STRU *                  pstrVal
)
/*++

Routine Description:

    Get server variable

Arguments:

    pW3Context - W3_CONTEXT with request state.  Can be NULL if we are
                 just determining whether the server variable requested is
                 valid.  If NULL, we will return an empty string (and success)
                 if the variable requested is valid.
    pszVariable - Variable name to retrieve
    pstrVal - Filled with variable on success

Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = S_OK;
    PFN_SERVER_VARIABLE_ROUTINE  pfnRoutine = NULL;
    PFN_SERVER_VARIABLE_ROUTINE_W   pfnRoutineW = NULL;

    hr = SERVER_VARIABLE_HASH::GetServerVariableRoutine( pszVariableName,
                                                         &pfnRoutine,
                                                         &pfnRoutineW );
    if ( SUCCEEDED(hr) )
    {
        if (pW3Context == NULL)
        {
            //
            // Just return empty string to signify that the variable is 
            // valid but we just don't know the value at this time
            //

            return pstrVal->Copy( L"", 0 );
        }

        if (pfnRoutineW != NULL)
        {
            //
            // This server-variable contains real unicode data and there
            // is a unicode ServerVariable routine for this
            //

            return pfnRoutineW( pW3Context, pstrVal );
        }
        else
        {
            //
            // No unicode version, use the ANSI version and just wide'ize it
            //
            STACK_STRA( straVal, 256);

            DBG_ASSERT( pfnRoutine != NULL );

            if (FAILED(hr = pfnRoutine( pW3Context, &straVal )) ||
                FAILED(hr = pstrVal->CopyA( straVal.QueryStr(),
                                            straVal.QueryCCH() )))
            {
                return hr;
            }

            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
}

//
// Server variable functions
//

HRESULT
GetServerVariableQueryString(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    return pW3Context->QueryRequest()->GetQueryStringA(pstrVal);
}

HRESULT
GetServerVariableAllHttp(   
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetAllHeaders( pstrVal, TRUE );
}

HRESULT
GetServerVariableAllRaw(   
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetAllHeaders( pstrVal, FALSE );
}

HRESULT
GetServerVariableContentLength(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    PCHAR   pszContentLength;
    CHAR    szMinusOne[33];  // Max documented size of _ultoa

    if ( pW3Context->QueryRequest()->IsChunkedRequest() )
    {
        _ultoa( (unsigned long) -1, szMinusOne, 10 );
        pszContentLength = szMinusOne;
    }
    else
    {
        pszContentLength = pW3Context->QueryRequest()->
            GetHeader( HttpHeaderContentLength );
    }

    if ( pszContentLength == NULL )
    {
        pszContentLength = "0";
    }   

    return pstrVal->Copy( pszContentLength );
}

HRESULT
GetServerVariableContentType(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    PCHAR pszContentType = pW3Context->QueryRequest()->
        GetHeader( HttpHeaderContentType );
    if ( pszContentType == NULL )
    {
        pszContentType = "";
    }   

    return pstrVal->Copy( pszContentType );
}

HRESULT
GetServerVariableInstanceId(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    CHAR      pszId[16];
    _itoa( pW3Context->QueryRequest()->QuerySiteId(), pszId, 10 );

    return pstrVal->Copy( pszId );
}

HRESULT
GetServerVariableRemoteHost(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    HRESULT         hr;
    
    DBG_ASSERT( pW3Context != NULL );

    //
    // If we have a resolved DNS name, then use it.  Otherwise just
    // return the address
    //

    hr = pW3Context->QueryMainContext()->GetRemoteDNSName( pstrVal );
    if ( hr == HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ) )
    {
        hr = GetServerVariableRemoteAddr( pW3Context, pstrVal );
    }
    
    return hr;
}

HRESULT
GetServerVariableRemoteAddr(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    DWORD dwAddr = pW3Context->QueryRequest()->QueryRemoteAddress();

    //
    // The dwAddr is reverse order from in_addr...
    //

    in_addr     inAddr;
    inAddr.S_un.S_un_b.s_b1 = (u_char)(( dwAddr & 0xff000000 ) >> 24);
    inAddr.S_un.S_un_b.s_b2 = (u_char)(( dwAddr & 0x00ff0000 ) >> 16);
    inAddr.S_un.S_un_b.s_b3 = (u_char)(( dwAddr & 0x0000ff00 ) >> 8);
    inAddr.S_un.S_un_b.s_b4 = (u_char) ( dwAddr & 0x000000ff );

    LPSTR pszAddr = inet_ntoa( inAddr );
    if ( pszAddr == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return pstrVal->Copy( pszAddr );
}

HRESULT
GetServerVariableServerName(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    //
    // If the client send a host name, use it.
    //

    CHAR *szHost = pW3Context->QueryRequest()->GetHeader( HttpHeaderHost );

    if ( szHost )
    {
        CHAR *pszColon = strchr( szHost, ':' );

        if (pszColon == NULL)
        {
            return pstrVal->Copy( szHost );
        }
        else
        {
            return pstrVal->Copy( szHost,
                                  DIFF( pszColon - szHost ) );
        }
    }

    //
    // No host from the client, so populate the buffer with
    // the IP address.
    //

    DWORD dwAddr = pW3Context->QueryRequest()->QueryLocalAddress();

    //
    // The dwAddr is reverse order from in_addr...
    //

    in_addr inAddr;
    inAddr.S_un.S_un_b.s_b1 = (u_char)(( dwAddr & 0xff000000 ) >> 24);
    inAddr.S_un.S_un_b.s_b2 = (u_char)(( dwAddr & 0x00ff0000 ) >> 16);
    inAddr.S_un.S_un_b.s_b3 = (u_char)(( dwAddr & 0x0000ff00 ) >> 8);
    inAddr.S_un.S_un_b.s_b4 = (u_char) ( dwAddr & 0x000000ff );

    LPSTR pszAddr = inet_ntoa( inAddr );
    if ( pszAddr == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return pstrVal->Copy( pszAddr );
}

HRESULT
GetServerVariableServerPort(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    USHORT port = pW3Context->QueryRequest()->QueryLocalPort();

    CHAR szPort[8];
    _itoa( port, szPort, 10 );

    return pstrVal->Copy( szPort );
}

HRESULT
GetServerVariablePathInfo(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    //
    // We might be called in an early filter where URL context isn't available
    //

    if ( pUrlContext == NULL )
    {
        pstrVal->Reset();
        return NO_ERROR;
    }

    W3_URL_INFO *pUrlInfo;
    DBG_REQUIRE( pUrlInfo = pUrlContext->QueryUrlInfo() );

    W3_SITE *pSite;
    DBG_REQUIRE( pSite = pW3Context->QuerySite() );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    HRESULT hr;

    //
    // In the case of script maps, if AllowPathInfoForScriptMappings
    // is not set for the site, we ignore path info, it is
    // just the URL
    //

    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        STACK_STRU (strUrl, MAX_PATH);
        if (FAILED(hr = pW3Context->QueryRequest()->GetUrl( &strUrl )) ||
            FAILED(hr = pstrVal->CopyW( strUrl.QueryStr() )))
        {
            return hr;
        }

        return S_OK;
    }
    else
    {
        // BUGBUG: do real conversion?
        return pstrVal->CopyW( pUrlInfo->QueryPathInfo()->QueryStr() );
    }
}

HRESULT
GetServerVariablePathInfoW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    //
    // We might be called in an early filter where URL context isn't available
    //

    if ( pUrlContext == NULL )
    {
        pstrVal->Reset();
        return NO_ERROR;
    }

    W3_URL_INFO *pUrlInfo;
    DBG_REQUIRE( pUrlInfo = pUrlContext->QueryUrlInfo() );

    W3_SITE *pSite;
    DBG_REQUIRE( pSite = pW3Context->QuerySite() );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    //
    // In the case of script maps, if AllowPathInfoForScriptMappings
    // is not set for the site, we ignore path info, it is
    // just the URL
    //

    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        return pW3Context->QueryRequest()->GetUrl( pstrVal );
    }
    else
    {
        return pstrVal->Copy( pUrlInfo->QueryPathInfo()->QueryStr() );
    }
}

HRESULT
GetServerVariablePathTranslated(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    HRESULT hr;

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    W3_URL_INFO *pUrlInfo;
    DBG_REQUIRE( pUrlInfo = pUrlContext->QueryUrlInfo() );

    W3_SITE *pSite;
    DBG_REQUIRE( pSite = pW3Context->QuerySite() );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    BOOL fUsePathInfo;
    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        fUsePathInfo = FALSE;
    }
    else
    {
        fUsePathInfo = TRUE;
    }

    STACK_STRU (struPathTranslated, 256);
    //
    // This is a new virtual path to have filters map
    //

    hr = pUrlInfo->GetPathTranslated( pW3Context,
                                      fUsePathInfo,
                                      &struPathTranslated );

    if (SUCCEEDED(hr))
    {
        // BUGBUG: do proper conversion?
        hr = pstrVal->CopyW( struPathTranslated.QueryStr() );
    }

    return hr;
}

HRESULT
GetServerVariablePathTranslatedW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext;
    pUrlContext = pW3Context->QueryUrlContext();

    W3_URL_INFO *pUrlInfo;
    DBG_REQUIRE( pUrlInfo = pUrlContext->QueryUrlInfo() );

    W3_SITE *pSite;
    DBG_REQUIRE( pSite = pW3Context->QuerySite() );

    W3_HANDLER *pHandler;
    pHandler = pW3Context->QueryHandler();

    BOOL fUsePathInfo;
    if ( pHandler != NULL &&
         pHandler->QueryScriptMapEntry() &&
         !pSite->QueryAllowPathInfoForScriptMappings() )
    {
        fUsePathInfo = FALSE;
    }
    else
    {
        fUsePathInfo = TRUE;
    }

    //
    // This is a new virtual path to have filters map
    //

    return pUrlInfo->GetPathTranslated( pW3Context,
                                        fUsePathInfo,
                                        pstrVal );
}

HRESULT
GetServerVariableRequestMethod(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    return pW3Context->QueryRequest()->GetVerbString( pstrVal );
}

HRESULT
GetServerVariableServerPortSecure(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    if ( pW3Context->QueryRequest()->IsSecureRequest() )
    {
        return pstrVal->Copy("1", 1);
    }

    return pstrVal->Copy("0", 1);
}

HRESULT
GetServerVariableServerSoftware(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    //
    // BUGBUG - probably don't want this hardcoded...
    //
    return pstrVal->Copy( SERVER_SOFTWARE_STRING );
}

HRESULT
GetServerVariableUrl(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    STACK_STRU(         strUrl, 256 );
    HRESULT             hr;
    
    DBG_ASSERT( pW3Context != NULL );
    
    //
    // URL context can be NULL if an early filter is called GetServerVar()
    //
    
    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        pUrlInfo = pUrlContext->QueryUrlInfo();
        DBG_ASSERT( pUrlInfo != NULL );
        
        return pstrVal->CopyW( pUrlInfo->QueryProcessedUrl()->QueryStr() );
    }
    else
    {
        hr = pW3Context->QueryRequest()->GetUrl( &strUrl );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        return pstrVal->CopyW( strUrl.QueryStr() );
    }
}

HRESULT
GetServerVariableUrlW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    URL_CONTEXT *       pUrlContext;
    W3_URL_INFO *       pUrlInfo;
    
    DBG_ASSERT( pW3Context != NULL );
    
    //
    // URL context can be NULL if an early filter is called GetServerVar()
    //
    
    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext != NULL )
    {
        pUrlInfo = pUrlContext->QueryUrlInfo();
        DBG_ASSERT( pUrlInfo != NULL );
        
        return pstrVal->Copy( pUrlInfo->QueryProcessedUrl()->QueryStr() );
    }
    else
    {
        return pW3Context->QueryRequest()->GetUrl( pstrVal );
    }
}

HRESULT
GetServerVariableInstanceMetaPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    STRU *pstrMetaPath = pW3Context->QuerySite()->QueryMBPath();
    DBG_ASSERT( pstrMetaPath );

    // BUGBUG: do proper conversion?
    return pstrVal->CopyW( pstrMetaPath->QueryStr() );
}

HRESULT
GetServerVariableLogonUser(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    W3_USER_CONTEXT *pUserContext;
    pUserContext = pW3Context->QueryUserContext();
    
    if ( pUserContext == NULL )
    {
        return pW3Context->QueryRequest()->GetRequestUserName( pstrVal );
    }
    else
    {
        return pstrVal->CopyW( pUserContext->QueryUserName() );
    }
}

HRESULT
GetServerVariableLogonUserW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    W3_USER_CONTEXT *pUserContext;
    pUserContext = pW3Context->QueryUserContext();
    
    if ( pUserContext == NULL )
    {
        return pstrVal->CopyA( pW3Context->QueryRequest()->QueryRequestUserName()->QueryStr() );
    }
    else
    {
        return pstrVal->Copy( pUserContext->QueryUserName() );
    }

    return S_OK;
}

HRESULT
GetServerVariableRemoteUser(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    HRESULT                     hr;
    
    DBG_ASSERT( pW3Context != NULL );
    
    hr = pW3Context->QueryRequest()->GetRequestUserName( pstrVal );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( pstrVal->IsEmpty() )
    {
        W3_USER_CONTEXT *pUserContext;
        pUserContext = pW3Context->QueryUserContext();
        
        if ( pUserContext != NULL )
        {
            hr = pstrVal->CopyW( pUserContext->QueryRemoteUserName() );
        }
        else
        {
            hr = NO_ERROR;
        }
    }

    return hr;
}

HRESULT
GetServerVariableRemoteUserW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    
    STRA *pstrUserName = pW3Context->QueryRequest()->QueryRequestUserName();
    
    if ( pstrUserName->IsEmpty() )
    {
        W3_USER_CONTEXT *pUserContext;
        pUserContext = pW3Context->QueryUserContext();
        
        if ( pUserContext != NULL )
        {
            return pstrVal->Copy( pUserContext->QueryRemoteUserName() );
        }
    }
    else
    {
        return pstrVal->CopyA( pstrUserName->QueryStr() );
    }

    return S_OK;
}

HRESULT
GetServerVariableAuthType(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal != NULL );

    HRESULT hr = S_OK;

    W3_USER_CONTEXT *pUserContext = pW3Context->QueryUserContext();

    if ( pUserContext != NULL )
    {
        if ( pUserContext->QueryAuthType() == MD_ACCESS_MAP_CERT )
        {
            pstrVal->Copy( "SSL/PCT" );
        }
        else if ( pUserContext->QueryAuthType() == MD_AUTH_ANONYMOUS )
        {
            pstrVal->Copy( "" );
        }
        else
        {
            hr = pW3Context->QueryRequest()->GetAuthType( pstrVal );
        }
    }
    else
    {
        DBG_ASSERT ( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    return hr;
}

HRESULT
GetServerVariableAuthPassword(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    W3_USER_CONTEXT *           pUserContext;
    
    DBG_ASSERT( pW3Context != NULL );
    pUserContext = pW3Context->QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );

    return pstrVal->CopyW( pUserContext->QueryPassword() );
}

//
// CODEWORK
//
// GetServerVariableApplMdPath & GetServerVariableApplPhysicalPath
// both try to deal with missing or invalid MD_APP_PATH data. In IIS5
// they never had to, because MD_APP_PATH was used by wam when
// initiallizing the CWamInfo object. If/When we include applications
// into the isapi handler, these functions should be simplified.
// 
// TaylorW 3-27-00
//


HRESULT
GetServerVariableApplMdPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    //
    // CODEWORK - Child Execute
    //
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    if (pUrlContext == NULL)
    {
        return E_FAIL;
    }

    W3_METADATA *pMetaData = pUrlContext->QueryMetaData();
    if (pMetaData == NULL)
    {
        return E_FAIL;
    }

    STRU *  pstrAppMetaPath = pMetaData->QueryAppMetaPath();
    HRESULT hr;

    if( pstrAppMetaPath->IsEmpty() )
    {
        //
        // This really shouldn't be necessary, because we should not
        // even start up if there is no application defined, but we
        // do right now and stress does not property call AppCreate.
        //

        W3_SITE * pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU * pstrSiteMetaRoot = pSite->QueryMBRoot();
        
        hr = pstrVal->CopyW( pstrSiteMetaRoot->QueryStr() );
    }
    else
    {
        hr = pstrVal->CopyW( pstrAppMetaPath->QueryStr() );
    }

    return hr;
}

HRESULT
GetServerVariableApplMdPathW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    if (pUrlContext == NULL)
    {
        return E_FAIL;
    }

    W3_METADATA *pMetaData = pUrlContext->QueryMetaData();
    if (pMetaData == NULL)
    {
        return E_FAIL;
    }

    STRU *  pstrAppMetaPath = pMetaData->QueryAppMetaPath();
    HRESULT hr;

    if( pstrAppMetaPath->IsEmpty() )
    {
        //
        // This really shouldn't be necessary, because we should not
        // even start up if there is no application defined, but we
        // do right now and stress does not property call AppCreate.
        //

        W3_SITE * pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU * pstrSiteMetaRoot = pSite->QueryMBRoot();
        
        hr = pstrVal->Copy( pstrSiteMetaRoot->QueryStr() );
    }
    else
    {
        hr = pstrVal->Copy( pstrAppMetaPath->QueryStr() );
    }

    return hr;
}

HRESULT
GetServerVariableApplPhysicalPath(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal );

    STACK_STRA( strAppMetaPath, MAX_PATH );
    STACK_STRU( strAppUrl, MAX_PATH );
    HRESULT     hr = E_FAIL;

    hr = GetServerVariableApplMdPath( pW3Context, &strAppMetaPath );

    if( SUCCEEDED(hr) )
    {
        //
        // pstrAppMetaPath is a full metabase path:
        //      /LM/W3SVC/<site>/Root/...
        //
        // To convert it to a physical path we will use 
        // W3_STATE_URLINFO::MapPath, but this requires 
        // that we remove the metabase prefixes and build 
        // a Url string.
        //

        //
        // Get the metabase path for the site root
        //

        W3_SITE *pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU *pstrSiteRoot = pSite->QueryMBRoot();
        DBG_ASSERT( pstrSiteRoot );

        //
        // Make some assumptions about the site path and the AppMetaPath 
        // being well-formed. The AppMetaPath may not have a terminating 
        // /, but the site root will.
        //
    
        DBG_ASSERT( pstrSiteRoot->QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 1 
                    );

        if( strAppMetaPath.QueryCCH() < pstrSiteRoot->QueryCCH() - 1 )
        {
            //
            // This indicates an invalid value for MD_APP_ROOT is sitting
            // around. We need to bail if this is the case.
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid MD_APP_ROOT detected (%s)\n",
                        strAppMetaPath.QueryStr()
                        ));
            
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DBG_ASSERT( strAppMetaPath.QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 2 
                    );

        //
        // The AppUrl will be the metabase path - 
        // all the /LM/W3SVC/1/ROOT goo
        //

        CHAR * pszStartAppUrl = strAppMetaPath.QueryStr() + 
            (pstrSiteRoot->QueryCCH() - 1);

        //
        // The AppMetaPath may not have a terminating /, so if it is 
        // a site root pszStartAppUrl will be empty.
        //
    
        if( *pszStartAppUrl != '\0' )
        {
            if( *pszStartAppUrl != '/' )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Invalid MD_APP_ROOT detected (%s)\n",
                            strAppMetaPath.QueryStr()
                            ));
            
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            hr = strAppUrl.CopyA(
                    pszStartAppUrl,
                    strAppMetaPath.QueryCCH() - (pstrSiteRoot->QueryCCH() - 1)
                    );
        }
        else
        {
            hr = strAppUrl.Copy( L"/", 1 );
        }

        if( SUCCEEDED(hr) )
        {
            STACK_STRU (strAppPath, MAX_PATH);
            //
            // Convert to a physical path
            //

            hr = W3_STATE_URLINFO::MapPath( pW3Context,
                                            strAppUrl,
                                            &strAppPath,
                                            NULL,
                                            NULL,
                                            NULL
                                            );
            if (SUCCEEDED(hr))
            {
                hr = pstrVal->CopyW(strAppPath.QueryStr());

                //
                // Ensure that the last character in the path
                // is '\\'.  There are legacy scripts that will
                // concatenate filenames to this path, and many
                // of them will break if we don't do this.
                //

                if ( SUCCEEDED( hr ) &&
                     *(pstrVal->QueryStr()+pstrVal->QueryCCH()-1) != '\\' )
                {
                    hr = pstrVal->Append( "\\" );
                }
            }
        }
    }

    return hr;
}

HRESULT
GetServerVariableApplPhysicalPathW(
    W3_CONTEXT *pW3Context,
    STRU       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pstrVal );

    STACK_STRU( strAppMetaPath, MAX_PATH );
    STACK_STRU( strAppUrl, MAX_PATH );
    HRESULT     hr = E_FAIL;

    hr = GetServerVariableApplMdPathW( pW3Context, &strAppMetaPath );

    if( SUCCEEDED(hr) )
    {
        //
        // pstrAppMetaPath is a full metabase path:
        //      /LM/W3SVC/<site>/Root/...
        //
        // To convert it to a physical path we will use 
        // W3_STATE_URLINFO::MapPath, but this requires 
        // that we remove the metabase prefixes and build 
        // a Url string.
        //

        //
        // Get the metabase path for the site root
        //

        W3_SITE *pSite = pW3Context->QuerySite();
        DBG_ASSERT( pSite );

        STRU *pstrSiteRoot = pSite->QueryMBRoot();
        DBG_ASSERT( pstrSiteRoot );

        //
        // Make some assumptions about the site path and the AppMetaPath 
        // being well-formed. The AppMetaPath may not have a terminating 
        // /, but the site root will.
        //
    
        DBG_ASSERT( pstrSiteRoot->QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 1 
                    );

        if( strAppMetaPath.QueryCCH() < pstrSiteRoot->QueryCCH() - 1 )
        {
            //
            // This indicates an invalid value for MD_APP_ROOT is sitting
            // around. We need to bail if this is the case.
            //

            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid MD_APP_ROOT detected (%S)\n",
                        strAppMetaPath.QueryStr()
                        ));
            
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        DBG_ASSERT( strAppMetaPath.QueryCCH() >= 
                    sizeof("/LM/W3SVC/1/Root/") - 2 
                    );

        //
        // The AppUrl will be the metabase path - 
        // all the /LM/W3SVC/1/ROOT goo
        //

        WCHAR * pszStartAppUrl = strAppMetaPath.QueryStr() + 
            (pstrSiteRoot->QueryCCH() - 1);

        //
        // The AppMetaPath may not have a terminating /, so if it is 
        // a site root pszStartAppUrl will be empty.
        //
    
        if( *pszStartAppUrl != L'\0' )
        {
            if( *pszStartAppUrl != L'/' )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Invalid MD_APP_ROOT detected (%s)\n",
                            strAppMetaPath.QueryStr()
                            ));
            
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            hr = strAppUrl.Copy(
                    pszStartAppUrl,
                    strAppMetaPath.QueryCCH() - (pstrSiteRoot->QueryCCH() - 1)
                    );
        }
        else
        {
            hr = strAppUrl.Copy( L"/", 1 );
        }

        if( SUCCEEDED(hr) )
        {
            hr =  W3_STATE_URLINFO::MapPath( pW3Context,
                                              strAppUrl,
                                              pstrVal,
                                              NULL,
                                              NULL,
                                              NULL
                                              );

            //
            // Ensure that the last character in the path
            // is '\\'.  There are legacy scripts that will
            // concatenate filenames to this path, and many
            // of them will break if we don't do this.
            //

            if ( SUCCEEDED( hr ) &&
                 *(pstrVal->QueryStr()+pstrVal->QueryCCH()-1) != L'\\' )
            {
                hr = pstrVal->Append( L"\\" );
            }
        }
    }

    return hr;
}

HRESULT
GetServerVariableGatewayInterface(
    W3_CONTEXT *pW3Context,
    STRA       *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    return pstrVal->Copy("CGI/1.1", 7);
}

HRESULT GetServerVariableLocalAddr(
    W3_CONTEXT *pW3Context,
    STRA *pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    DWORD dwAddr = pW3Context->QueryRequest()->QueryLocalAddress();

    //
    // The dwAddr is reverse order from in_addr...
    //

    in_addr inAddr;
    inAddr.S_un.S_un_b.s_b1 = (u_char)(( dwAddr & 0xff000000 ) >> 24);
    inAddr.S_un.S_un_b.s_b2 = (u_char)(( dwAddr & 0x00ff0000 ) >> 16);
    inAddr.S_un.S_un_b.s_b3 = (u_char)(( dwAddr & 0x0000ff00 ) >> 8);
    inAddr.S_un.S_un_b.s_b4 = (u_char) ( dwAddr & 0x000000ff );

    LPSTR pszAddr = inet_ntoa( inAddr );
    if ( pszAddr == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return pstrVal->Copy( pszAddr );
}

HRESULT GetServerVariableHttps(
    W3_CONTEXT *pW3Context,
    STRA *pstrVal)
{
    DBG_ASSERT( pW3Context != NULL );

    if (pW3Context->QueryRequest()->IsSecureRequest())
    {
        return pstrVal->Copy("on", 2);
    }

    return pstrVal->Copy("off", 3);
}

HRESULT
GetServerVariableHttpsKeySize(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR                    achNum[ 64 ];
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        achNum[ 0 ] = '\0';
    }
    else
    {
        _itoa( pSslInfo->ConnectionKeySize,
               achNum,
               10 );
    }
    
    return pstrVal->Copy( achNum );
}

HRESULT
GetServerVariableClientCertIssuer(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetIssuer( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertSubject(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetSubject( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertCookie(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetCookie( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertSerialNumber(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "", 0 ); 
    }
    else
    {
        return pCertContext->GetSerialNumber( pstrVal );
    }
}

HRESULT
GetServerVariableClientCertFlags(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    CERTIFICATE_CONTEXT *       pCertContext;
    
    pCertContext = pW3Context->QueryMainContext()->QueryCertificateContext();
    if ( pCertContext == NULL )
    {
        return pstrVal->Copy( "0", 1 ); 
    }
    else
    {
        return pCertContext->GetFlags( pstrVal );
    }
}

HRESULT
GetServerVariableHttpsSecretKeySize(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR                    achNum[ 64 ];

    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        achNum[ 0 ] = '\0';
    }
    else
    {
        _itoa( pSslInfo->ServerCertKeySize,
              achNum,
              10 );
    }
    
    return pstrVal->Copy( achNum );
}

HRESULT
GetServerVariableHttpsServerIssuer(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR *                  pszVariable;
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        pszVariable = "";
    }
    else
    {
        DBG_ASSERT( pSslInfo->pServerCertIssuer != NULL );
        pszVariable = pSslInfo->pServerCertIssuer;
    }
    
    return pstrVal->Copy( pszVariable );
}

HRESULT
GetServerVariableHttpsServerSubject(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    HTTP_SSL_INFO *         pSslInfo;
    CHAR *                  pszVariable;
    
    pSslInfo = pW3Context->QueryRequest()->QuerySslInfo();
    if ( pSslInfo == NULL )
    {
        pszVariable = "";
    }
    else
    {
        DBG_ASSERT( pSslInfo->pServerCertSubject != NULL );
        pszVariable = pSslInfo->pServerCertSubject;
    }
    
    return pstrVal->Copy( pszVariable );
}

HRESULT
GetServerVariableHttpUrl(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    //
    // HTTP_URL gets the raw url for the request. If a filter has
    // modified the url the request object handles redirecting the
    // RawUrl variable 
    //

    DBG_ASSERT( pW3Context != NULL );
        
    return pW3Context->QueryRequest()->GetRawUrl( pstrVal );
}

HRESULT
GetServerVariableHttpVersion(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    //
    // HTTP_VERSION returns the client version string
    //

    DBG_ASSERT( pW3Context != NULL );

    return pW3Context->QueryRequest()->GetVersionString( pstrVal );
}

HRESULT
GetServerVariableAppPoolId(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    //
    // APP_POOL_ID returns the AppPoolId WAS started us with
    //

    DBG_ASSERT( pW3Context != NULL );

    return pstrVal->CopyW( (LPWSTR)UlAtqGetContextProperty(NULL,
                                                           ULATQ_PROPERTY_APP_POOL_ID) );
}

HRESULT
GetServerVariableAppPoolIdW(
    W3_CONTEXT *            pW3Context,
    STRU *                  pstrVal
)
{
    //
    // APP_POOL_ID returns the AppPoolId WAS started us with
    //

    DBG_ASSERT( pW3Context != NULL );

    return pstrVal->Copy( (LPWSTR)UlAtqGetContextProperty(NULL,
                                                          ULATQ_PROPERTY_APP_POOL_ID) );
}

HRESULT
GetServerVariableScriptTranslated(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    return pstrVal->CopyW( pUrlContext->QueryPhysicalPath()->QueryStr() );
}

HRESULT
GetServerVariableScriptTranslatedW(
    W3_CONTEXT *            pW3Context,
    STRU *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    URL_CONTEXT *pUrlContext = pW3Context->QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    return pstrVal->Copy( *pUrlContext->QueryPhysicalPath() );
}

HRESULT
GetServerVariableUnencodedUrl(
    W3_CONTEXT *            pW3Context,
    STRA *                  pstrVal
)
{
    DBG_ASSERT( pW3Context != NULL );

    W3_REQUEST *pW3Request = pW3Context->QueryRequest();
    DBG_ASSERT( pW3Request != NULL );

    return pW3Request->GetRawUrl(pstrVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\ulcache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     ulcache.cxx

   Abstract:
     UL cache entries
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    UL_RESPONSE_CACHE_ENTRY::sm_pachUlResponseCache;

HRESULT
UL_RESPONSE_CACHE_KEY::CreateCacheKey(
    WCHAR *                 pszKey,
    DWORD                   cchKey,
    BOOL                    fCopy
)
/*++

  Description:

    Setup a UL response cache key

  Arguments:

    pszKey - URL of cache key
    cchKey - size of URL
    fCopy - Set to TRUE if we should copy the URL, else we just keep a ref
    
  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if ( fCopy )
    {
        hr = _strKey.Copy( pszKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszKey = _strKey.QueryStr();
        _cchKey = _strKey.QueryCCH();
    }
    else
    {
        _pszKey = pszKey;
        _cchKey = cchKey;
    }

    return NO_ERROR;
}

//static
HRESULT
UL_RESPONSE_CACHE_ENTRY::Initialize(
    VOID
)
/*++

  Description:

    UL_RESPONSE_CACHE_ENTRY lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( UL_RESPONSE_CACHE_ENTRY );

    DBG_ASSERT( sm_pachUlResponseCache == NULL );
    
    sm_pachUlResponseCache = new ALLOC_CACHE_HANDLER( "UL_RESPONSE_CACHE_ENTRY",  
                                                      &acConfig );

    if ( sm_pachUlResponseCache == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachUlResponseCache. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
UL_RESPONSE_CACHE_ENTRY::Terminate(
    VOID
)
/*++

  Description:

    UL_RESPONSE_CACHE_ENTRY lookaside cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachUlResponseCache != NULL )
    {
        delete sm_pachUlResponseCache;
        sm_pachUlResponseCache = NULL;
    }
}

UL_RESPONSE_CACHE_ENTRY::~UL_RESPONSE_CACHE_ENTRY()
{
    _dwSignature = UL_RESPONSE_CACHE_ENTRY_SIGNATURE_FREE;
 
    DBGPRINTF(( DBG_CONTEXT,
                "Invalidating URL %ws\n",
                _strInvalidationUrl.QueryStr() ));

    UlAtqFlushUlCache( _strInvalidationUrl.QueryStr() );
}

HRESULT
UL_RESPONSE_CACHE_ENTRY::Create(
    STRU &                  strMetadataPath,
    STRU &                  strPhysicalPath,
    STRU &                  strInvalidationUrl
)
/*++

Routine Description:

    Initialize a ul response cache entry

Arguments:

    strMetadataPath - Metadata path associated with this response
    strPhysicalPath - Physical path to dir monitor
    strInvalidationUrl - Exact URL used to flush the UL response cache

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    
    hr = _cacheKey.CreateCacheKey( strMetadataPath.QueryStr(),
                                   strMetadataPath.QueryCCH(),
                                   TRUE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strPhysicalPath.Copy( strPhysicalPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strInvalidationUrl.Copy( strInvalidationUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

BOOL
UL_RESPONSE_CACHE_ENTRY::QueryIsOkToFlushDirmon(
    WCHAR *                 pszPath,
    DWORD                   cchPath
)
/*++

  Description:

    Is it OK to flush this entry based on the given file which has changed

  Arguments:

    pszPath - Path that changed
    cchPath - Length of path 
    
  Return:

    TRUE if we should flush, else FALSE

--*/
{
    if ( _wcsnicmp( _strPhysicalPath.QueryStr(),
                    pszPath,
                    cchPath ) == 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

UL_RESPONSE_CACHE::UL_RESPONSE_CACHE()
    : _fUlCacheEnabled( TRUE )
{
}

UL_RESPONSE_CACHE::~UL_RESPONSE_CACHE()
{
}

HRESULT
UL_RESPONSE_CACHE::SetupUlCachedResponse(
    W3_CONTEXT *                pW3Context,
    STRU &                      strFullUrl,
    STRU &                      strPhysicalPath
)
/*++

Routine Description:

    Build (if necessary) a cache entry which controls the invalidation of
    a UL cached response

Arguments:

    pW3Context - Context
    strFullUrl - Exact URL used to flush the UL response cache
    strPhysicalPath - Physical path to dir monitor

Return Value:

    HRESULT (if FAILED, then we should not UL cache the response)

--*/
{
    UL_RESPONSE_CACHE_KEY           ulKey;
    UL_RESPONSE_CACHE_ENTRY *       pEntry = NULL;
    HRESULT                         hr;
    W3_METADATA *                   pMetaData;
    W3_URL_INFO *                   pUrlInfo;
    
    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( pW3Context->QueryUrlContext() != NULL );
    
    pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    pUrlInfo = pW3Context->QueryUrlContext()->QueryUrlInfo();
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Setup key to lookup whether we already have this response cached
    //
    
    hr = ulKey.CreateCacheKey( pUrlInfo->QueryMetadataPath()->QueryStr(),
                               pUrlInfo->QueryMetadataPath()->QueryCCH(),
                               FALSE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Find a response entry
    //
    
    hr = FindCacheEntry( &ulKey, 
                         (CACHE_ENTRY**) &pEntry );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pEntry != NULL );
        
        //
        // Ok.  We already have a UL cached entry.  Just release it
        // and return success
        //
        
        pEntry->DereferenceCacheEntry();
        
        return NO_ERROR;
    }
    
    //
    // Ok.  Try to add an entry
    //
    
    pEntry = new UL_RESPONSE_CACHE_ENTRY( this );
    if ( pEntry == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = pEntry->Create( *(pUrlInfo->QueryMetadataPath()),
                         strPhysicalPath,
                         strFullUrl );
    if ( FAILED( hr ) )
    {
        pEntry->DereferenceCacheEntry();
        return hr;
    }

    //
    // Start monitoring the appropriate directory for changes
    //
    
    hr = pEntry->AddDirmonInvalidator( pMetaData->QueryDirmonConfig() );
    if ( FAILED( hr ) )
    {
        pEntry->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // Add the cache entry
    //
    
    hr = AddCacheEntry( pEntry );
    if ( FAILED( hr ) )
    {
        pEntry->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // Hash table owns a reference now.  Just release and return success
    //
    
    pEntry->DereferenceCacheEntry();
    
    return NO_ERROR;
}

BOOL
UL_RESPONSE_CACHE::CheckUlCacheability(
    W3_CONTEXT *        pW3Context
)
/*++

Routine Description:

    Determine whether the response for the given context appears cacheable
    in UL.  

Arguments:

    pW3Context - Context describing request

Return Value:

    TRUE if response seems ul cachable

--*/
{
    HRESULT             hr = NO_ERROR;
    W3_METADATA *       pMetaData = NULL;
    URL_CONTEXT *       pUrlContext = NULL;
    
    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }
    
    pUrlContext = pW3Context->QueryUrlContext();
    if ( pUrlContext == NULL )
    {
        //
        // We have no metadata (must be a fatal error)
        //
        
        return FALSE;
    }
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // If UL cache is disabled, then response is not UL cacheable (duh!)
    // 
    
    if ( !QueryUlCacheEnabled() )
    {
        return FALSE;
    }
    
    if ( !pW3Context->QueryIsUlCacheable() )
    {
        return FALSE;
    }
    
    //
    // Only UL cache 200 responses
    //
    
    if ( pW3Context->QueryResponse()->QueryStatusCode() !=
         HttpStatusOk.statusCode )
    {
        return FALSE;
    }
    
    //
    // Is either dynamic compression enabled?  Since dynamic compression
    // is done later in W3_RESPONSE object, we need to do check now
    //
    
    if ( pMetaData->QueryDoDynamicCompression() )
    {
        return FALSE;
    }
    
    //
    // Is this a child request?
    //
    
    if ( pW3Context->QueryParentContext() != NULL )
    {
        return FALSE;
    }
    
    //
    // Is there a current handler which is UL friendly?
    //
    
    if ( pW3Context->QueryHandler() == NULL ||
         !pW3Context->QueryHandler()->QueryIsUlCacheable() )
    {
        return FALSE;
    }
    
    //
    // Are there filters installed which are not cache aware?
    //
    
    if ( !pW3Context->QuerySite()->QueryFilterList()->QueryIsUlFriendly() )
    {
        return FALSE;
    }
    
    //
    // Is this request accessible anonymously?
    //
    
    if ( !( pMetaData->QueryAuthentication() & MD_AUTH_ANONYMOUS ) )
    {
        return FALSE;
    }
    
    //
    // Are we doing custom logging?
    //
    
    if ( pW3Context->QueryDoCustomLogging() ) 
    {
        return FALSE;
    }
    
    //
    // Do we have special SSL requirements?
    //
    
    if ( pMetaData->QueryAccessPerms() & 
         ( VROOT_MASK_NEGO_CERT |
           VROOT_MASK_NEGO_MANDATORY |
           VROOT_MASK_MAP_CERT |
           VROOT_MASK_SSL128 ) )
    {
        return FALSE;
    }
    
    //
    // Is compression enabled?
    //
    
    if ( pMetaData->QueryDoStaticCompression() )
    {
        return FALSE;
    }
    
    //
    // If we got to here, then we believe we can use the UL cache
    //

    return TRUE;
}

HRESULT
UL_RESPONSE_CACHE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the cache managing invalidation of the UL cache

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    HKEY                hKey;

    //
    // First determine how UL is configured by reading UL registry config
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\http\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Is the UL cache enabled?
        //
        
        if ( RegQueryValueEx( hKey,
                              L"UriEnableCache",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            _fUlCacheEnabled = !!dwData;
        }

        RegCloseKey( hKey );
    }                      
    
    //
    // Setup cache configuration
    // 
    
    hr = SetCacheConfiguration( 60 * 1000, 
                                INFINITE,
                                CACHE_INVALIDATION_METADATA |
                                CACHE_INVALIDATION_DIRMON_FLUSH,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return UL_RESPONSE_CACHE_ENTRY::Initialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\urlinfo.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     urlinfo.cxx

   Abstract:
     Implementation of URL cache
 
   Author:
     Bilal Alam (balam)             8-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// This is the maximum size for a script map extension
//

#define MAX_EXT_LEN 128

ALLOC_CACHE_HANDLER *   W3_URL_INFO::sm_pachW3UrlInfo;
DWORD                   W3_URL_INFO::sm_cMaxDots;

HRESULT
W3_URL_INFO_KEY::CreateCacheKey(
    WCHAR *                 pszKey,
    DWORD                   cchKey,
    DWORD                   cchSitePrefix,
    BOOL                    fCopy
)
/*++

  Description:

    Setup a URI cache key

  Arguments:

    pszKey - URL of cache key
    cchKey - size of URL
    cchSitePrefix - Size of site prefix ("LM/W3SVC/<n>")
    fCopy - Set to TRUE if we should copy the URL, else we just keep a ref
    
  Return:

    HRESULT

--*/
{
    HRESULT             hr;
   
    _cchSitePrefix = cchSitePrefix;
    
    if ( fCopy )
    {
        hr = _strKey.Copy( pszKey );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pszKey = _strKey.QueryStr();
        _cchKey = _strKey.QueryCCH();
    }
    else
    {
        _pszKey = pszKey;
        _cchKey = cchKey;
    }

    return NO_ERROR;
}

//static
HRESULT
W3_URL_INFO::Initialize(
    VOID
)
/*++

  Description:

    URI entry lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    
    DWORD                       dwError;
    HKEY                        hKey = NULL;
    DWORD                       cbData;
    DWORD                       dwType;
    DWORD                       dwValue;

    //
    // Default max dots is 100
    //

    sm_cMaxDots = 100;
        
    //
    // Look for a registry override to the max dot value
    // (one of the more useful configurable options in IIS)
    //
    
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
    
        //
        // Should we be file caching at all?
        //
    
        cbData = sizeof( DWORD );
        dwError = RegQueryValueEx( hKey,
                                   L"MaxDepthDots",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwValue,
                                   &cbData );
        if ( dwError == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            sm_cMaxDots = dwValue;
        }
    }

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_URL_INFO );

    DBG_ASSERT( sm_pachW3UrlInfo == NULL );
    
    sm_pachW3UrlInfo = new ALLOC_CACHE_HANDLER( "W3_URL_INFO",  
                                                &acConfig );

    if ( sm_pachW3UrlInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3UrlInfo. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_URL_INFO::Terminate(
    VOID
)
/*++

  Description:

    URI cache cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachW3UrlInfo != NULL )
    {
        delete sm_pachW3UrlInfo;
        sm_pachW3UrlInfo = NULL;
    }
}

HRESULT
W3_URL_INFO::Create(
    STRU &              strUrl,
    STRU &              strMetadataPath
)
/*++

  Description:

    Initialize a W3_URL_INFO

  Arguments:

    strUrl - Url key for this entry
    strMetadataPath - Full metadata path used for key

  Return:

    HRESULT

--*/
{
    HRESULT         hr;
    
    hr = _cacheKey.CreateCacheKey( strMetadataPath.QueryStr(),
                                   strMetadataPath.QueryCCH(),
                                   strMetadataPath.QueryCCH() - strUrl.QueryCCH(),
                                   TRUE );
    if ( FAILED( hr ) )
    {
        return hr;
    } 
    
    //
    // Process the URL for execution info (and splitting path_info/url)
    //
    
    hr = ProcessUrl( strUrl );
    if( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now create physical path
    //

    hr = _pMetaData->BuildPhysicalPath( _strProcessedUrl,
                                        &_strPhysicalPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now create translation of the whole URL.  Note: this is not always
    // PathTranslated, so we do not name it so
    //

    hr = _pMetaData->BuildPhysicalPath( strUrl,
                                        &_strUrlTranslated );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_URL_INFO::GetPathTranslated(
    W3_CONTEXT *                pW3Context,
    BOOL                        fUsePathInfo,
    STRU *                      pstrPathTranslated
)
/*++

Routine Description:

    Given the PATH_INFO of this cached entry, determine PATH_TRANSLATED.
    This involves:
        1) Mapping PATH_INFO to a physical path
        2) Calling filters if necessary for this path

    We cache the output of step 1)

Arguments:

    pW3Context - W3Context
    pstrPathTranslated - Filled with physical path on success

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = S_OK;
    W3_URL_INFO *       pUrlInfo = NULL;
    
    if ( pW3Context == NULL ||
         pstrPathTranslated == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Check for cached path translated entry.  If its there and flushed,
    // then release it (and try again)
    //
    
    if ( _pUrlInfoPathTranslated != NULL )
    {
        LockCacheEntry();
        
        if ( _pUrlInfoPathTranslated != NULL )
        {
            if ( _pUrlInfoPathTranslated->QueryIsFlushed() )
            {
                _pUrlInfoPathTranslated->DereferenceCacheEntry();
                _pUrlInfoPathTranslated = NULL;
            }
            else
            {
                _pUrlInfoPathTranslated->ReferenceCacheEntry();
                pUrlInfo = _pUrlInfoPathTranslated;
            }
        }
        
        UnlockCacheEntry();
    }

    //
    // Use the cached translated entry if there
    //

    if ( pUrlInfo == NULL )
    {
        //
        // Get and keep the metadata and urlinfo for this path
        //
    
        DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );

        if ( fUsePathInfo )
        {
            hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( pW3Context,
                                                               _strPathInfo,
                                                               &pUrlInfo );
        }
        else
        {
            pUrlInfo = this;
            pUrlInfo->ReferenceCacheEntry();
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( pUrlInfo != NULL );

        //
        // Store away the URL info, provided it is an empty string.
        //
        // Basically, we're trying to optimize the case of "/foobar.dll".  
        // In this case, path info is empty, and we want to avoid doing the
        // extra URL lookup for empty string.
        //
        
        if ( pUrlInfo->QueryCached() && 
             pUrlInfo->QueryUrl()[0] == L'\0' )
        {
            LockCacheEntry();
            
            if ( _pUrlInfoPathTranslated == NULL )
            {
                _pUrlInfoPathTranslated = pUrlInfo;
            }
            else
            {
                pUrlInfo->DereferenceCacheEntry();
                pUrlInfo = _pUrlInfoPathTranslated;
            }

            pUrlInfo->ReferenceCacheEntry();
      
            UnlockCacheEntry();
        }
    }        
    
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Now call into the filter
    //
    
    hr = W3_STATE_URLINFO::FilterMapPath( pW3Context,     
                                          pUrlInfo,
                                          pstrPathTranslated );
    
    pUrlInfo->DereferenceCacheEntry();
    
    return hr;
}

HRESULT
W3_URL_INFO::GetFileInfo(
    FILE_CACHE_USER *       pOpeningUser,
    BOOL                    fDoCache,
    W3_FILE_INFO **         ppFileInfo
)
/*++

Routine Description:

    Get file info associated with this cache entry.  If it doesn't exist,
    then go to file cache directly to open the file

Arguments:

    pOpeningUser - Opening user
    fDoCache - Should we cache the file
    ppFileInfo - Set to file cache entry on success

Return Value:

    HRESULT

--*/
{
    W3_FILE_INFO *          pFileInfo = NULL;
    BOOL                    fCleanup = FALSE;
    HRESULT                 hr;
    
    if ( ppFileInfo == NULL || 
         pOpeningUser == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppFileInfo = NULL;
    
    //
    // Do we already have a file entry associated?  If so use it, if it was
    // not already flushed
    //
    
    LockCacheEntry();
   
    if ( _pFileInfo != NULL )
    {
        if ( _pFileInfo->Checkout() )
        {
            pFileInfo = _pFileInfo;
        }
        else
        {
            _pFileInfo->DereferenceCacheEntry();
            _pFileInfo = NULL;
        }
    }
    
    UnlockCacheEntry();

    //
    // If we got a file entry, we're done, assuming access check is ok
    //
    
    if ( pFileInfo != NULL )
    {
        hr = pFileInfo->DoAccessCheck( pOpeningUser );
        if ( SUCCEEDED( hr ) )
        {
            *ppFileInfo = pFileInfo;
            return NO_ERROR;
        }
        else
        {
            pFileInfo->DereferenceCacheEntry();
            return hr;
        }
    }
    
    //
    // We'll have to go to file cache directly
    //
    
    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
    
    hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                    _strPhysicalPath,
                                    _pMetaData->QueryDirmonConfig(),
                                    pOpeningUser,
                                    fDoCache,
                                    &pFileInfo );
    if ( FAILED( hr ) )
    {
        return hr;
    }             
    
    DBG_ASSERT( pFileInfo != NULL );

    //
    // Now try to stuff the file descriptor into this object (bearing in mind
    // that another thread may try to do the same thing for this W3_URL_INFO)
    //
   
    if ( pFileInfo->QueryCached() )
    {
        LockCacheEntry();
        
        if ( _pFileInfo == NULL )
        {
            pFileInfo->ReferenceCacheEntry();
            _pFileInfo = pFileInfo;
        }
    
        UnlockCacheEntry();
    }

    //
    // It is OK if this thread was not able to associate the file entry.
    //
    
    *ppFileInfo = pFileInfo;
    
    return NO_ERROR;
}

HRESULT
W3_URL_INFO::ProcessUrl( 
    STRU &                  strUrl
)
/*++

Routine Description:

    Process the URL and assocate execution information with
    the W3_URL_INFO.

    Called before adding a new URL info to the cache.

    Look through the url for script-mapped or executable extensions
    and update the W3_URL_INFO with the actual URL to execute,
    path-info, gateway type, etc.

Arguments:

    strUrl - Original requested URL

Return Value:

    SUCCEEDED()/FAILED()

CODEWORK 

1. Handle wildcard mappings

--*/
{
    HRESULT hr = NOERROR;
    DWORD   cDots = 0;

    DBG_ASSERT( _pMetaData );

    STACK_STRU( strExtension, MAX_EXT_LEN );

    //
    // Reference the URL_INFO's data
    //

    STRU *  pstrProcessedUrl = &_strProcessedUrl;
    STRU *  pstrPathInfo     = &_strPathInfo;

    //
    // Iterate over pstrProcessedUrl. These always point at the
    // pstrProcessedUrl string.
    //

    WCHAR * pszExtensionIter = NULL;
    WCHAR * pszPathInfoIter = NULL;

    //
    // Make a working copy of the URL, this will be modified if an 
    // exectuable extension is found before the terminal node in the 
    // path.
    //

    hr = pstrProcessedUrl->Copy( strUrl );
    if( FAILED(hr) )
    {
        goto failure;
    }

    //
    // Search the URL for an extension that matches something
    // we know how to execute.
    //

    pszExtensionIter = pstrProcessedUrl->QueryStr();
    while( pszExtensionIter = wcschr( pszExtensionIter, L'.' ) )
    {
        //
        // Maintain a count of the dots we encounter, any more than
        // sm_cMaxDots and we fail the request
        //
        
        cDots++;
        if ( cDots > sm_cMaxDots )
        {
            break;
        }        
        
        //
        // Save the extension string
        //

        hr = strExtension.Copy( pszExtensionIter );
        if( FAILED(hr) )
        {
            goto failure;
        }
        
        //
        // Find the end of the string or the beginning of the path info
        //

        pszPathInfoIter = wcschr( pszExtensionIter, L'/' );
        if( pszPathInfoIter != NULL )
        {
            DBG_REQUIRE( 
                strExtension.SetLen( 
                    DIFF(pszPathInfoIter - pszExtensionIter) 
                    )
                );
        }
        
        //
        // Lowercase the extension string to allow case-insensitive 
        // comparisons.
        //
        _wcslwr( strExtension.QueryStr() );

        //
        // Try to find a matching script map entry
        //

        META_SCRIPT_MAP *       pScriptMap;
        META_SCRIPT_MAP_ENTRY * pScriptMapEntry;

        pScriptMap = _pMetaData->QueryScriptMap();
        DBG_ASSERT( pScriptMap );
        
        if( pScriptMap->FindEntry( strExtension, &pScriptMapEntry ) )
        {
            DBG_ASSERT( pScriptMapEntry );

            _pScriptMapEntry = pScriptMapEntry;

            if( pszPathInfoIter )
            {
                hr = pstrPathInfo->Copy( pszPathInfoIter );
                if( FAILED(hr) )
                {
                    goto failure;
                }

                //
                // Make sure that we truncate the URL so that we don't end
                // up downloading a source file by mistake.
                //

                DBG_REQUIRE( 
                    pstrProcessedUrl->SetLen( 
                        DIFF(pszPathInfoIter - pstrProcessedUrl->QueryStr()) 
                        )
                    );
            }
            else
            {
                pstrPathInfo->Reset();
            }

            //
            // Since we found the entry, we are done
            //
            break;
        }

        //
        // No matching script map, so check if this is a wellknown
        // Gateway type.
        //

        DBG_ASSERT( pScriptMapEntry == NULL );
        DBG_ASSERT( _pScriptMapEntry == NULL );

        //
        // Avoid all the string comps if we will never match.
        //
        if( strExtension.QueryCCH() == 4 )
        {
            GATEWAY_TYPE Gateway;
            Gateway = GATEWAY_UNKNOWN;
            
            //
            // Test extension against known gateway extensions.
            // 
            // Does it make sense to allow the known extensions to be
            // configured?
            //

            if( wcscmp( L".dll", strExtension.QueryStr() ) == 0 ||
                wcscmp( L".isa", strExtension.QueryStr() ) == 0
                )
            {
                Gateway = GATEWAY_ISAPI;
            }
            else if( !wcscmp( L".exe", strExtension.QueryStr() ) ||
                     !wcscmp( L".cgi", strExtension.QueryStr() ) ||
                     !wcscmp( L".com", strExtension.QueryStr() ) )
            {
                Gateway = GATEWAY_CGI;
            }
            else if( wcscmp( L".map", strExtension.QueryStr() ) == 0 )
            {
                Gateway = GATEWAY_MAP;
            }
            
            //
            // OK.  Before we continue, if the request was a GATEWAY_ISAPI
            // or GATEWAY_CGI and we do NOT have EXECUTE permissions, then
            // this really isn't a ISA/CGI after all
            //
            
            if ( Gateway == GATEWAY_CGI ||
                 Gateway == GATEWAY_ISAPI )
            {
                if ( !( _pMetaData->QueryAccessPerms() & VROOT_MASK_EXECUTE ) )
                {
                    Gateway = GATEWAY_UNKNOWN;
                }
            } 
            
            //
            // The gateway is specified in the URL and we recognize it.
            //
            if( Gateway != GATEWAY_UNKNOWN )
            {
                _Gateway = Gateway;

                //
                // Save everthing after the matching extension as
                // path-info and truncate the URL so that it doesn't
                // include the path info
                //
                if( pszPathInfoIter )
                {

                    hr = pstrPathInfo->Copy( pszPathInfoIter );
                    if( FAILED(hr) )
                    {
                        goto failure;
                    }

                    DBG_REQUIRE( 
                        pstrProcessedUrl->SetLen( 
                            DIFF(pszPathInfoIter - pstrProcessedUrl->QueryStr()) 
                            )
                        );
                }
                else
                {
                    pstrPathInfo->Reset();
                }
                
                //
                // We have a match so exit the loop
                //
                break;
            }
        }
            
        //
        // We do not have a matching entry, so continue to look for an
        // executable extension.
        //
        pszExtensionIter++;
        
    
    } // while (pszExtensionIter)

    //
    // Now associate the ContentType for this entry
    //
    if (FAILED(hr = SelectMimeMappingForFileExt(pstrProcessedUrl->QueryStr(),
                                                _pMetaData->QueryMimeMap(),
                                                &_strContentType)))
    {
        goto failure;
    }
    
    return S_OK;

failure:

    DBG_ASSERT( FAILED(hr) );
    return FAILED(hr) ? hr : E_FAIL;
}

HRESULT
W3_URL_INFO_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize URI cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    DWORD               csecTTL = DEFAULT_W3_URL_INFO_CACHE_TTL;
    HKEY                hKey;

    //
    // What is the TTL for the URI cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        if ( RegQueryValueEx( hKey,
                              L"ObjectCacheTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }
        
        RegCloseKey( hKey );
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_METADATA,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return W3_URL_INFO::Initialize();
}

HRESULT
W3_URL_INFO_CACHE::GetUrlInfo(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    W3_URL_INFO **              ppUrlInfo
)
/*++

Routine Description:

    Retrieve a W3_URL_INFO, creating it if necessary

Arguments:

    pW3Context - W3 context
    strUrl - Url to lookup
    ppUrlInfo - Filled with cache entry if successful
    
Return Value:

    HRESULT

--*/
{
    W3_URL_INFO_KEY           uriKey;
    W3_URL_INFO *             pUrlInfo;
    STACK_STRU(               strUpperKey, MAX_PATH );
    STRU *                    pstrMBRoot;
    HRESULT                   hr;
    
    if ( pW3Context == NULL ||
         ppUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppUrlInfo = NULL;
    
    //
    // The key is the full metadata path.  Start with the site prefix minus
    // the trailing '/'
    //

    pstrMBRoot = pW3Context->QuerySite()->QueryMBRoot();
    DBG_ASSERT( pstrMBRoot != NULL );
    
    hr = strUpperKey.Copy( pstrMBRoot->QueryStr(),
                           pstrMBRoot->QueryCCH() - 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now add the URL and upper case it to avoid insensitive compares later 
    //
    
    hr = strUpperKey.Append( strUrl );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    _wcsupr( strUpperKey.QueryStr() );
    
    //
    // Setup a key to lookup
    // 
    
    
    hr = uriKey.CreateCacheKey( strUpperKey.QueryStr(),
                                strUpperKey.QueryCCH(),
                                pW3Context->QuerySite()->QueryMBRoot()->QueryCCH(),
                                FALSE );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Look it up
    //
    
    hr = FindCacheEntry( &uriKey,
                         (CACHE_ENTRY**) &pUrlInfo );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pUrlInfo != NULL );
        
        *ppUrlInfo = pUrlInfo;
        
        return NO_ERROR;
    }
    
    //
    // We need to create a URI cache entry
    //
    
    hr = CreateNewUrlInfo( pW3Context,
                           strUrl,
                           strUpperKey,
                           &pUrlInfo );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pUrlInfo != NULL );
    
    //
    // Add to the cache
    //
    
    AddCacheEntry( pUrlInfo );
    
    *ppUrlInfo = pUrlInfo;
    
    return NO_ERROR;
}

HRESULT
W3_URL_INFO_CACHE::CreateNewUrlInfo(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU &                  strMetadataPath,
    W3_URL_INFO **          ppUrlInfo
)
/*++

Routine Description:

    Create a new URI cache entry

Arguments:

    pW3Context - Main context
    strUrl - Url
    strMetadataPath - Full metadata path used as key
    ppUrlInfo - Set to URI cache entry
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA *           pMetaData = NULL;
    W3_URL_INFO *           pUrlInfo = NULL;
    HRESULT                 hr;
    
    if ( pW3Context == NULL ||
         ppUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppUrlInfo = NULL;
    
    //
    // Find a metacache entry
    //
    
    DBG_ASSERT( g_pW3Server->QueryMetaCache() != NULL );
    
    hr = g_pW3Server->QueryMetaCache()->GetMetaData( pW3Context,
                                                     strUrl,
                                                     &pMetaData );
    if ( FAILED( hr ) )
    {
        return hr;
    }                  
    
    DBG_ASSERT( pMetaData != NULL );

    //
    // Create a W3_URL_INFO
    //
    
    pUrlInfo = new W3_URL_INFO( this, pMetaData );
    if ( pUrlInfo == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        pMetaData->DereferenceCacheEntry();
        
        return hr;
    }

    hr = pUrlInfo->Create( strUrl,
                           strMetadataPath );
    if ( FAILED( hr ) )
    {
        pUrlInfo->DereferenceCacheEntry();
        return hr;
    }

    *ppUrlInfo = pUrlInfo;
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\urlcontext.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     urlinfo.cxx

   Abstract:
     Gets metadata for URL
 
   Author:
     Bilal Alam (balam)             8-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include <stringau.hxx>

ALLOC_CACHE_HANDLER *   URL_CONTEXT::sm_pachUrlContexts;

//
// Utility to guard against ~ inconsistency
//

DWORD
CheckIfShortFileName(
    IN WCHAR *          pszPath,
    IN HANDLE           hImpersonation,
    OUT BOOL *          pfShort
);

W3_STATE_URLINFO::W3_STATE_URLINFO()
{
    _hr = URL_CONTEXT::Initialize();
}

W3_STATE_URLINFO::~W3_STATE_URLINFO()
{
    URL_CONTEXT::Terminate();
}

CONTEXT_STATUS
W3_STATE_URLINFO::OnCompletion(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle URLINFO completions.  CheckAccess() is called in DoWork() and this
    call is asynchronous.

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    CONTEXT_STATUS              contextStatus;
    BOOL                        fAccessAllowed;
    
    contextStatus = pMainContext->CheckAccess( TRUE,   // this is a completion
                                               dwCompletionStatus,
                                               &fAccessAllowed );
                                 
    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }
    
    //
    // If access is not allowed, then just finish state machine (
    // response has already been sent)
    //
    
    if ( !fAccessAllowed )
    {
        pMainContext->SetFinishedResponse();
    }
    
    return CONTEXT_STATUS_CONTINUE;
}

CONTEXT_STATUS
W3_STATE_URLINFO::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Handle retrieving the metadata for this request

Arguments:

    pMainContext - W3_MAIN_CONTEXT representing execution of state machine
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_CONTINUE - if we should continue in state machine
    else stop executing the machine and free up the current thread

--*/
{
    URL_CONTEXT *           pUrlContext = NULL;
    BOOL                    fFinished = FALSE;
    HRESULT                 hr = NO_ERROR;
    W3_METADATA *           pMetaData = NULL;
    CONTEXT_STATUS          contextStatus = CONTEXT_STATUS_CONTINUE;
    W3_REQUEST *            pHttpRequest = pMainContext->QueryRequest();
    W3_RESPONSE *           pResponse = pMainContext->QueryResponse();
    BOOL                    fAccessAllowed = FALSE;

    DBG_ASSERT( pHttpRequest != NULL );
    DBG_ASSERT( pResponse != NULL );

    //
    // Set the context state
    //
    
    hr = URL_CONTEXT::RetrieveUrlContext( pMainContext,
                                          pMainContext->QueryRequest(),
                                          &pUrlContext,
                                          &fFinished );
    if ( FAILED( hr ) )
    {
        goto Failure;
    } 
    
    DBG_ASSERT( fFinished || ( pUrlContext != NULL ) );
    pMainContext->SetUrlContext( pUrlContext );

    //
    // From now on, errors in this function should not cleanup the URL
    // context since it is owned by the main context
    //

    pUrlContext = NULL;

    //
    // If filter wants out, leave
    //

    if ( fFinished )
    {
        pMainContext->SetDone();
        return CONTEXT_STATUS_CONTINUE;
    }
    
    //
    // Check access now.  That means checking for IP/SSL/Certs.  We will 
    // avoid the authentication type check since the others (IP/SSL/Certs)
    // take priority.
    //
    
    contextStatus = pMainContext->CheckAccess( FALSE,     // not a completion
                                               NO_ERROR,
                                               &fAccessAllowed );
    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }
    
    //
    // If we don't have access, then the appropriate error response was
    // already sent.  Just finish the state machine
    //
    
    if ( !fAccessAllowed )
    {
        pMainContext->SetFinishedResponse();
    }   
    
    return CONTEXT_STATUS_CONTINUE;

Failure:

    if ( pUrlContext != NULL )
    {
        delete pUrlContext;
    }

    if ( !pMainContext->QueryResponseSent() )
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // For the non-8dot3 case
            pMainContext->QueryResponse()->SetStatus( HttpStatusNotFound );
        }
        else
        {
            pMainContext->QueryResponse()->SetStatus( HttpStatusServerError );
        }

        pMainContext->SetFinishedResponse();
        pMainContext->SetErrorStatus( hr );
    }

    return CONTEXT_STATUS_CONTINUE;
}

//static
HRESULT
URL_CONTEXT::RetrieveUrlContext(
    W3_CONTEXT *            pW3Context,
    W3_REQUEST *            pRequest,
    OUT URL_CONTEXT **      ppUrlContext,
    BOOL *                  pfFinished
)
/*++

Routine Description:

    For a given request, get a URL_CONTEXT which represents the 
    metadata and URI-specific info for that request

Arguments:

    pW3Context - W3_CONTEXT for the request
    pRequest - New request to lookup
    ppUrlContext - Set to point to new URL_CONTEXT
    pfFinished - Set to true if isapi filter said we're finished

Return Value:

    HRESULT

--*/
{
    STACK_STRU(         strUrl, MAX_PATH );
    W3_URL_INFO *       pUrlInfo = NULL;
    W3_METADATA *       pMetaData = NULL;
    URL_CONTEXT *       pUrlContext = NULL;
    HRESULT             hr = NO_ERROR;
    HANDLE              hToken = NULL;

    if ( pW3Context == NULL ||
         pRequest == NULL ||
         ppUrlContext == NULL ||
         pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppUrlContext = NULL;

    hr = pRequest->GetUrl( &strUrl );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Lookup the URI info for this request
    //
    
    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );
    
    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( 
                                        pW3Context,
                                        strUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    //
    // Now, create a URL_CONTEXT object which contains the W3_URL_INFO and
    // W3_METADATA pointers as well as state information for use on cleanup
    //
    
    DBG_ASSERT( pUrlInfo != NULL );

    pMetaData = (W3_METADATA*) pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUrlContext = new URL_CONTEXT( pMetaData, pUrlInfo );
    if ( pUrlContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    
    //
    // Now notify URL_MAP filters
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_URL_MAP ) )
    {
        STACK_STRA(         straPhys, MAX_PATH + 1 );
        STACK_STRA(         straUrl, MAX_PATH + 1 );
        BOOL                fRet;
        HTTP_FILTER_URL_MAP filterMap;
        STACK_STRU(         strPhysicalPath, MAX_PATH );
        
        hr = straPhys.CopyW( pUrlInfo->QueryPhysicalPath()->QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }
        
        hr = straUrl.CopyW( strUrl.QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }

        filterMap.pszURL = straUrl.QueryStr();
        filterMap.pszPhysicalPath = straPhys.QueryStr();
        filterMap.cbPathBuff = MAX_PATH + 1;
       
        fRet = pW3Context->NotifyFilters( SF_NOTIFY_URL_MAP,
                                          &filterMap,
                                          pfFinished );

        //
        // If the filter is done, then we're done
        // 

        if ( *pfFinished )
        {
            hr = NO_ERROR;
            goto Failure;
        }
        
        //
        // If the physical path was changed, remember it here
        //
        
        hr = strPhysicalPath.CopyA( (CHAR*) filterMap.pszPhysicalPath );
        if ( FAILED( hr ) )
        {
            goto Failure;
        }
        
        if ( pUrlInfo->QueryPhysicalPath()->QueryCCH() != strPhysicalPath.QueryCCH() ||
             wcscmp( pUrlInfo->QueryPhysicalPath()->QueryStr(),
                     strPhysicalPath.QueryStr() ) != 0 )
        {
            hr = pUrlContext->SetPhysicalPath( strPhysicalPath );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
        }
    }
    
    //
    // We don't accept short filename since they can break metabase
    // equivalency
    //

    if ( wcschr( pUrlContext->QueryPhysicalPath()->QueryStr(),
                 L'~' ) )
    {
        BOOL fShort = FALSE;
        
        if ( pMetaData->QueryVrAccessToken() != NULL )
        {
            hToken = pMetaData->QueryVrAccessToken()->QueryImpersonationToken();
        }
        else
        {
            hToken = NULL;
        }
        
        
        DWORD dwError = CheckIfShortFileName( 
                                pUrlContext->QueryPhysicalPath()->QueryStr(),
                                hToken,
                                &fShort );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError ); 
            goto Failure;
        }

        if ( fShort )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            goto Failure;
        }
    }
    
    *ppUrlContext = pUrlContext;
    return S_OK;

Failure:
    if ( pUrlContext != NULL )
    {
        delete pUrlContext;
    }
    else
    {
        if ( pUrlInfo != NULL )
        {
            pUrlInfo->DereferenceCacheEntry();
        }
    }
   
    return hr; 
}

//static
HRESULT
W3_STATE_URLINFO::MapPath(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU *                  pstrPhysicalPath,
    DWORD *                 pcchDirRoot,
    DWORD *                 pcchVRoot,
    DWORD *                 pdwMask
)
/*++

Routine Description:

    Send a URL/Physical-Path pair to a filter for processing

Arguments:

    pW3Context - W3_CONTEXT for the request
    strUrl - The URL to be mapped
    pstrPhysicalPath - Filled with the mapped path upon return.  Set with
                       metadata physical path on entry
    pcchDirRoot - Set to point to number of characters in found physical path
    pcchVRoot - Set to point to number of characters in found virtual path
    pdwMask - Set to point to the access perms mask of virtual path

Return Value:

    SUCCEEDED()/FAILED()

--*/
{
    HRESULT         hr = S_OK;
    W3_URL_INFO *   pUrlInfo = NULL;
    W3_METADATA *   pMetaData = NULL;

    DBG_ASSERT( pstrPhysicalPath );
    
    //
    // Get and keep the metadata and urlinfo for this path
    //
    
    DBG_ASSERT( g_pW3Server->QueryUrlInfoCache() != NULL );
    
    hr = g_pW3Server->QueryUrlInfoCache()->GetUrlInfo( 
                                        pW3Context,
                                        strUrl,
                                        &pUrlInfo );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }
    
    DBG_ASSERT( pUrlInfo != NULL );

    //
    // Call the filters
    //
    
    hr = FilterMapPath( pW3Context,
                        pUrlInfo,
                        pstrPhysicalPath );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }
                        
    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // Return the other goodies
    //
    
    if ( pcchDirRoot != NULL )
    {
        *pcchDirRoot = pMetaData->QueryVrPath()->QueryCCH();
    }
    
    if ( pcchVRoot != NULL )
    {
        if (strUrl.QueryCCH())
        {
            *pcchVRoot = pMetaData->QueryVrLen();
        }
        else
        {
            *pcchVRoot = 0;
        }
    }
    
    if ( pdwMask != NULL )
    {
        *pdwMask = pMetaData->QueryAccessPerms();
    }

Exit:

    if ( pUrlInfo != NULL )
    {
        pUrlInfo->DereferenceCacheEntry();
        pUrlInfo = NULL;
    }
    
    return hr;
}

// static
HRESULT
W3_STATE_URLINFO::FilterMapPath(
    W3_CONTEXT *            pW3Context,
    W3_URL_INFO *           pUrlInfo,
    STRU *                  pstrPhysicalPath
    )
/*++

Routine Description:

    Have URL_MAP filters do their thing

Arguments:

    pW3Context - Context
    pUrlInfo - Contains virtual/physical path
    pstrPhysicalPath - Filled with physical path

Return Value:

    SUCCEEDED()/FAILED()

--*/
{
    HRESULT         hr = S_OK;
    BOOL            fFinished = FALSE;
    W3_METADATA *   pMetaData = NULL;
    STACK_STRU(     strFilterPath, MAX_PATH );
    STRU *          pstrFinalPhysical = NULL;

    if ( pW3Context == NULL ||
         pUrlInfo == NULL ||
         pstrPhysicalPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pMetaData = pUrlInfo->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // We now have the metadata physical path.  Let filters change it here
    //

    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_URL_MAP ) )
    {
        STACK_STRA(         straPhys, MAX_PATH + 1 );
        STACK_STRA(         straUrl, MAX_PATH + 1 );
        BOOL                fRet;
        HTTP_FILTER_URL_MAP filterMap;
        
        hr = straPhys.CopyW( pUrlInfo->QueryUrlTranslated()->QueryStr() );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }
        
        hr = straUrl.CopyW( pUrlInfo->QueryUrl() );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }

        filterMap.pszURL = straUrl.QueryStr();
        filterMap.pszPhysicalPath = straPhys.QueryStr();
        filterMap.cbPathBuff = MAX_PATH + 1;
       
        fRet = pW3Context->NotifyFilters( SF_NOTIFY_URL_MAP,
                                          &filterMap,
                                          &fFinished );

        //
        // Ignore finished flag in this case since we really can't do much
        // to advance to finish (since an ISAPI is calling this)
        // 
        
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        //
        // Remember the mapped path
        //
        
        hr = strFilterPath.CopyA( (CHAR*) filterMap.pszPhysicalPath );
        if ( FAILED( hr ) )
        {
            goto Exit;
        }
        
        pstrFinalPhysical = &strFilterPath;
    }
    else
    {
        //
        // No filter is mapping, therefore just take the URL_INFO's physical
        // path
        //   
        
        pstrFinalPhysical = pUrlInfo->QueryUrlTranslated();
        
        DBG_ASSERT( pstrFinalPhysical != NULL );
    }

    //
    // We don't accept short filename since they can break metabase
    // equivalency
    //

    if ( wcschr( pstrFinalPhysical->QueryStr(),
                 L'~' ) )
    {
        BOOL fShort = FALSE;
        DWORD dwError = CheckIfShortFileName( 
                                pstrFinalPhysical->QueryStr(),
                                pW3Context->QueryImpersonationToken(),
                                &fShort );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError ); 
            goto Exit;
        }

        if ( fShort )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            goto Exit;
        }
    }
    
    //
    // Copy the physical path is requested
    //
    
    hr = pstrPhysicalPath->Copy( *pstrFinalPhysical );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

Exit:

    return hr;
}

DWORD
CheckIfShortFileName(
    IN WCHAR *          pszPath,
    IN HANDLE           hImpersonation,
    OUT BOOL *          pfShort
)
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    WCHAR *            psz;
    BOOL               fUNC;

    psz = wcschr( pszPath, L'~' );
    *pfShort = FALSE;
    fUNC = (*pszPath == L'\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= L'0' && *psz <= L'9' )
        {
            WCHAR   achTmp[MAX_PATH];
            WCHAR * pchEndSeg;
            WCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //
            
            pchEndSeg = wcschr( psz, L'\\' );
            if ( !pchEndSeg )
            {
                pchEndSeg = psz + wcslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= MAX_PATH )
            {
                return NO_ERROR;
            }

            memcpy( achTmp, 
                    pszPath, 
                    (INT) (pchEndSeg - pszPath) * sizeof( WCHAR ) );
            achTmp[pchEndSeg - pszPath] = L'\0';

            if ( fUNC && hImpersonation )
            {
                if ( !SetThreadToken( NULL, hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFileW( achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = wcsrchr( achTmp, L'\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //
            
            if ( _wcsicmp( FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = wcschr( psz, L'~' );
    }

    return err;
}

HRESULT
URL_CONTEXT::OpenFile(
    FILE_CACHE_USER *       pFileUser,
    W3_FILE_INFO **         ppOpenFile
)
/*++

Routine Description:

    Open the physical path for this request.  If a map path filter did some
    redirecting, we will use that path.  Otherwise we will just use the 
    path determined by metadata and cached in the W3_URL_INFO 

Arguments:

    pFileUser - User to open file as
    ppOpenFile - Set to file cache entry on success

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    BOOL                fDoCache;
    
    DBG_ASSERT( QueryMetaData() != NULL );
    
    fDoCache = !QueryMetaData()->QueryNoCache();
    
    //
    // If an ISAPI filter changed the physical path, then we need to go 
    // directly to the file cache.  Otherwise, we can go thru the 
    // W3_URL_INFO which may already have the cached file associated
    //
    
    if ( _strPhysicalPath.IsEmpty() )
    {
        //
        // No filter.  Fast path :-)
        //
        
        DBG_ASSERT( _pUrlInfo != NULL );
        
        hr = _pUrlInfo->GetFileInfo( pFileUser,
                                     fDoCache,
                                     ppOpenFile );
    }
    else
    {
        //
        // Filter case.  Must lookup in file cache :-(
        //
        
        DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
        
        hr = g_pW3Server->QueryFileCache()->GetFileInfo( 
                                        _strPhysicalPath,
                                        QueryMetaData()->QueryDirmonConfig(),
                                        pFileUser,
                                        fDoCache,
                                        ppOpenFile );
    }
    
    return hr;
}

//static
HRESULT
URL_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize URL_CONTEXT lookaside

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( URL_CONTEXT );

    DBG_ASSERT( sm_pachUrlContexts == NULL );
    
    sm_pachUrlContexts = new ALLOC_CACHE_HANDLER( "URL_CONTEXT",  
                                                  &acConfig );

    if ( sm_pachUrlContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
URL_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Clean up URL_CONTEXT lookaside

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    if ( sm_pachUrlContexts != NULL )
    {
        delete sm_pachUrlContexts;
        sm_pachUrlContexts = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\ulw3.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     ulw3.cxx

   Abstract:
     W3 Handler Driver
 
   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"

/************************************************************
 *  Declarations
 ************************************************************/

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3core";



DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

/************************************************************
 *  Type Definitions  
 ************************************************************/

W3_SERVER *             g_pW3Server = NULL;

HRESULT
UlW3Start(
    INT                     argc,
    LPWSTR                  argv[],
    BOOL                    fCompatibilityMode
)
/*++
Description:

    Perform one time initialization, including ULATQ setup.
    Wait on shutdown. Then clean up.

    Assumes that this startup thread is CoInitialized MTA.

--*/
{
    HRESULT                 hr = NO_ERROR;

    CREATE_DEBUG_PRINT_OBJECT("w3core");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    DBG_ASSERT( g_pW3Server == NULL );

    //
    // Create the global W3_SERVER object
    // 
    
    g_pW3Server = new W3_SERVER( fCompatibilityMode );
    if ( g_pW3Server == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }
    
    //
    // Do global initialization (but no listen)
    //

    hr = g_pW3Server->Initialize( argc, argv );
    if ( FAILED( hr ) )
    {    
        goto Finished;
    }
    
    //
    // Start listening
    //
    
    hr = g_pW3Server->StartListen();
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

Finished:
    
    //
    // Cleanup
    //
    
    if ( g_pW3Server != NULL )
    {
        g_pW3Server->Terminate( hr );
        delete g_pW3Server;
        g_pW3Server = NULL;
    }

    DELETE_DEBUG_PRINT_OBJECT();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\ulparse.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     ulparse.cxx

   Abstract:
     Rip some useful UL code
     
   Author:
     (RIPPED from UL driver code (HenrySa, PaulMcd)

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

typedef enum _URL_PART
{
    Scheme,
    HostName,
    AbsPath,
    QueryString

} URL_PART;

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)

NTSTATUS
Unescape(
    IN  PUCHAR pChar,
    OUT PUCHAR pOutChar
    )

{
    UCHAR Result, Digit;

    if (pChar[0] != '%' ||
        SAFEIsXDigit(pChar[1]) == FALSE ||
        SAFEIsXDigit(pChar[2]) == FALSE)
    {
        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined
    //

    // uppercase #1
    //
    if (isalpha(pChar[1]))
        Digit = (UCHAR) toupper(pChar[1]);
    else
        Digit = pChar[1];

    Result = ((Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0')) << 4;

    // uppercase #2
    //
    if (isalpha(pChar[2]))
        Digit = (UCHAR) toupper(pChar[2]);
    else
        Digit = pChar[2];

    Result |= (Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0');

    *pOutChar = Result;

    return STATUS_SUCCESS;

}   // Unescape


NTSTATUS
PopChar(
    IN URL_PART UrlPart,
    IN PUCHAR pChar,
    OUT WCHAR * pUnicodeChar,
    OUT PULONG pCharToSkip
    )
{
    NTSTATUS Status;
    WCHAR   UnicodeChar;
    UCHAR   Char;
    UCHAR   Trail1;
    UCHAR   Trail2;
    ULONG   CharToSkip;

    //
    // need to unescape ?
    //
    // can't decode the query string.  that would be lossy decodeing
    // as '=' and '&' characters might be encoded, but have meaning
    // to the usermode parser.
    //

    if (UrlPart != QueryString && pChar[0] == '%')
    {
        Status = Unescape(pChar, &Char);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;
        CharToSkip = 3;
    }
    else
    {
        Char = pChar[0];
        CharToSkip = 1;
    }

    //
    // convert to unicode, checking for utf8 .
    //
    // 3 byte runs are the largest we can have.  16 bits in UCS-2 =
    // 3 bytes of (4+4,2+6,2+6) where it's code + char.
    // for a total of 6+6+4 char bits = 16 bits.
    //

    //
    // NOTE: we'll only bother to decode utf if it was escaped
    // thus the (CharToSkip == 3)
    //
    if ((CharToSkip == 3) && ((Char & 0xf0) == 0xe0))
    {
        // 3 byte run
        //

        // Unescape the next 2 trail bytes
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        Status = Unescape(pChar+CharToSkip, &Trail2);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE ||
            IS_UTF8_TRAILBYTE(Trail2) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        // handle three byte case
        // 1110xxxx 10xxxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x0f) << 12) |
                                ((Trail1 & 0x3f) << 6) |
                                (Trail2 & 0x3f));

    }
    else if ((CharToSkip == 3) && ((Char & 0xe0) == 0xc0))
    {
        // 2 byte run
        //

        // Unescape the next 1 trail byte
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        // handle two byte case
        // 110xxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x1f) << 6) |
                                (Trail1 & 0x3f));

    }

    // now this can either be unescaped high-bit (bad)
    // or escaped high-bit.  (also bad)
    //
    // thus not checking CharToSkip
    //

    else if ((Char & 0x80) == 0x80)
    {
        // high bit set !  bad utf!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;

    }
    //
    // Normal character (again either escaped or unescaped)
    //
    else
    {
        //
        // Simple conversion to unicode, it's 7-bit ascii.
        //

        UnicodeChar = (USHORT)Char;
    }

    //
    // turn backslashes into forward slashes
    //

    if (UrlPart != QueryString && UnicodeChar == L'\\')
    {
        UnicodeChar = L'/';
    }
    else if (UnicodeChar == 0)
    {
        //
        // we pop'd a NULL.  bad!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;
    }

    *pCharToSkip  = CharToSkip;
    *pUnicodeChar = UnicodeChar;

    Status = STATUS_SUCCESS;

end:
    return Status;

}   // PopChar

//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000

//
// Private globals
//

//
// this table says what to do based on the current state and the current
// character
//
ULONG  pActionTable[16] =
{
    //
    // state 0 = fresh, seen nothing exciting yet
    //
    ACTION_EMIT_CH,         // other = emit it                      state = 0
    ACTION_EMIT_CH,         // "."   = emit it                      state = 0
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_EMIT_CH,         // "/"   = we saw the "/", emit it      state = 1

    //
    // state 1 = we saw a "/" !
    //
    ACTION_EMIT_CH,         // other = emit it,                     state = 0
    ACTION_NOTHING,         // "."   = eat it,                      state = 2
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = extra slash, eat it,         state = 1

    //
    // state 2 = we saw a "/" and ate a "." !
    //
    ACTION_EMIT_DOT_CH,     // other = emit the dot we ate.         state = 0
    ACTION_NOTHING,         // "."   = eat it, a ..                 state = 3
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = we ate a "/./", swallow it   state = 1

    //
    // state 3 = we saw a "/" and ate a ".." !
    //
    ACTION_EMIT_DOT_DOT_CH, // other = emit the "..".               state = 0
    ACTION_EMIT_DOT_DOT_CH, // "."   = 3 dots, emit the ".."        state = 0
    ACTION_BACKUP,          // EOS   = we have a "/..\0", backup!   state = 4
    ACTION_BACKUP           // "/"   = we have a "/../", backup!    state = 1
};

//
// this table says which newstate to be in given the current state and the
// character we saw
//
ULONG  pNextStateTable[16] =
{
    // state 0
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    //  state 1
    0 ,              // other
    2 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 2
    0 ,             // other
    3 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 3
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1               // "\"
};

//
// this says how to index into pNextStateTable given our current state.
//
// since max states = 4, we calculate the index by multiplying with 4.
//
#define IndexFromState( st)   ( (st) * 4)




/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode

Arguments:

Return Value:

    HRESULT 


--***************************************************************************/
HRESULT
UlCleanAndCopyUrl(
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR       pDestination,
    OUT     PWSTR *     ppQueryString OPTIONAL
    )
{
    NTSTATUS Status;
    PWSTR   pDest;
    PUCHAR  pChar;
    ULONG   CharToSkip;
    UCHAR   Char;
    ULONG   BytesCopied;
    PWSTR   pQueryString;
    ULONG   StateIndex;
    WCHAR   UnicodeChar;
    BOOLEAN MakeCanonical;
    URL_PART UrlPart = AbsPath;

//
// a cool local helper macro
//

#define EMIT_CHAR(ch)                                   \
    do {                                                \
        pDest[0] = (ch);                                \
        pDest += 1;                                     \
        BytesCopied += 2;                               \
    } while (0)


    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    StateIndex = 0;

    MakeCanonical = (UrlPart == AbsPath) ? TRUE : FALSE;

    while (SourceLength > 0)
    {
        //
        // advance !  it's at the top of the loop to enable ANSI_NULL to
        // come through ONCE
        //

        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        //
        // well?  have we hit the end?
        //

        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
        }
        else
        {
            //
            // Nope.  Peek briefly to see if we hit the query string
            //

            if (UrlPart == AbsPath && pChar[0] == '?')
            {
                DBG_ASSERT(pQueryString == NULL);

                //
                // remember it's location
                //

                pQueryString = pDest;

                //
                // let it fall through ONCE to the canonical
                // in order to handle a trailing "/.." like
                // "http://foobar:80/foo/bar/..?v=1&v2"
                //

                UnicodeChar = L'?';
                CharToSkip = 1;

                //
                // now we are cleaning the query string
                //

                UrlPart = QueryString;
            }
            else
            {
                //
                // grab the next char
                //

                Status = PopChar(UrlPart, pChar, &UnicodeChar, &CharToSkip);
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
            }
        }

        if (MakeCanonical)
        {
            //
            // now use the state machine to make it canonical .
            //

            //
            // from the old value of StateIndex, figure out our new base StateIndex
            //
            StateIndex = IndexFromState(pNextStateTable[StateIndex]);

            //
            // did we just hit the query string?  this will only happen once
            // that we take this branch after hitting it, as we stop
            // processing after hitting it.
            //

            if (UrlPart == QueryString)
            {
                //
                // treat this just like we hit a NULL, EOS.
                //

                StateIndex += 2;
            }
            else
            {
                //
                // otherwise based the new state off of the char we
                // just popped.
                //

                switch (UnicodeChar)
                {
                case UNICODE_NULL:      StateIndex += 2;    break;
                case L'.':              StateIndex += 1;    break;
                case L'/':              StateIndex += 3;    break;
                default:                StateIndex += 0;    break;
                }
            }

        }
        else
        {
            StateIndex = (UnicodeChar == UNICODE_NULL) ? 2 : 0;
        }

        //
        //  Perform the action associated with the state.
        //

        switch (pActionTable[StateIndex])
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_CH:

            EMIT_CHAR(UnicodeChar);

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest currently points 1 past the last '/'.  backup over it and
            // find the preceding '/', set pDest to 1 past that one.
            //

            //
            // backup to the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            DBG_ASSERT(pDest[0] == L'/');

            //
            // are we at the start of the string?  that's bad, can't go back!
            //

            if (pDest == pDestination)
            {
                DBG_ASSERT(BytesCopied == 0);
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                goto end;
            }

            //
            // back up over the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            DBG_ASSERT(pDest > pDestination);

            //
            // now find the previous slash
            //

            while (pDest > pDestination && pDest[0] != L'/')
            {
                pDest       -= 1;
                BytesCopied -= 2;
            }

            //
            // we already have a slash, so don't have to store 1.
            //

            DBG_ASSERT(pDest[0] == L'/');

            //
            // simply skip it, as if we had emitted it just now
            //

            pDest       += 1;
            BytesCopied += 2;

            break;

        default:
            DBG_ASSERT(!"w3core!UlpCleanAndCopyUrl: Invalid action code in state table!");
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        //
        // Just hit the query string ?
        //

        if (MakeCanonical && UrlPart == QueryString)
        {
            //
            // Stop canonical processing
            //

            MakeCanonical = FALSE;

            //
            // Need to emit the '?', it wasn't emitted above
            //

            DBG_ASSERT(pActionTable[StateIndex] != ACTION_EMIT_CH);

            EMIT_CHAR(L'?');

        }

    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    DBG_ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;

    *pBytesCopied = BytesCopied;
    if (ppQueryString != NULL)
    {
        *ppQueryString = pQueryString;
    }

    Status = STATUS_SUCCESS;


end:
    return HRESULT_FROM_WIN32( RtlNtStatusToDosError( Status ) );

} // UlCleanAndCopyUrl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3conn.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3conn.cxx

   Abstract:
     Http Connection management
 
   Author:
     Bilal Alam (balam)             6-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

ALLOC_CACHE_HANDLER *    W3_CONNECTION::sm_pachW3Connections;
W3_CONNECTION_HASH *     W3_CONNECTION::sm_pConnectionTable;

W3_CONNECTION::W3_CONNECTION( 
    HTTP_CONNECTION_ID           connectionId
)
    : _cRefs( 1 ),
      _pUserContext( NULL ),
      _fConnected( TRUE )
{
    LK_RETCODE              lkrc;
    
    _connId = connectionId;
    _dwSignature = W3_CONNECTION_SIGNATURE;
    
    ZeroMemory( _rgConnectionState, sizeof( _rgConnectionState ) );

    IF_DEBUG( CONN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "New W3_CONNECTION '%p' created\n",
                    this ));
    }
                    
}

W3_CONNECTION::~W3_CONNECTION()
{
    IF_DEBUG( CONN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "W3_CONNECTION '%p' deleted\n",
                    this ));
    }
    
    //
    // Cleanup state associated with connection
    //
    
    for ( DWORD i = 0; i < STATE_COUNT; i++ )
    {
        if ( _rgConnectionState[ i ] != NULL )
        {
            _rgConnectionState[ i ]->Cleanup();
            _rgConnectionState[ i ] = NULL;
        }
    }
    
    //
    // Release the user context associated
    //
    
    if ( _pUserContext != NULL )
    {
        _pUserContext->DereferenceUserContext();
        _pUserContext = NULL;
    }

    _dwSignature = W3_CONNECTION_SIGNATURE_FREE;
}

HRESULT
W3_CONNECTION::Initialize(
    VOID
)
/*++

Routine Description:
    
    Global W3_CONNECTION initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                         hr = NO_ERROR;
    ALLOC_CACHE_CONFIGURATION       acConfig;

    //
    // Initialize allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CONNECTION );

    DBG_ASSERT( sm_pachW3Connections == NULL );
    
    sm_pachW3Connections = new ALLOC_CACHE_HANDLER( "W3_CONNECTION",  
                                                    &acConfig );

    if ( sm_pachW3Connections == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Allocate table
    //
    
    sm_pConnectionTable = new W3_CONNECTION_HASH;
    if ( sm_pConnectionTable == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return hr;
}

VOID
W3_CONNECTION::Terminate(
    VOID
)
/*++

Routine Description:

    Destroy W3_CONNECTION globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pConnectionTable != NULL )
    {
        delete sm_pConnectionTable;
        sm_pConnectionTable = NULL;
    }

    delete sm_pachW3Connections;
    sm_pachW3Connections = NULL;
}

HRESULT
W3_CONNECTION::RetrieveConnection(
    HTTP_CONNECTION_ID              ConnectionId,
    BOOL                            fCreateIfNotFound,
    W3_CONNECTION **                ppConnection
)
/*++

Routine Description:

    Given, a UL_HTTP_REQUEST (and thus a UL_HTTP_CONNECTION_ID), determine
    whether there is an associated W3_CONNECTION with that ID.  If not, 
    create a new W3_CONNECTION.  This function will also call into ULATQ to
    get an asynchronous notification when the connection goes away.

Arguments:

    ConnectionId - Connection ID
    fCreateIfNotFound - Create if not found in hash table
    ppConnection - Receives a pointer to a W3_CONNECTION for this request
    
Return Value:

    HRESULT

--*/
{
    W3_CONNECTION *         pNewConnection;
    HRESULT                 hr;
    LK_RETCODE              lkrc;
     
    DBG_ASSERT( ppConnection != NULL );

    *ppConnection = NULL;

    lkrc = sm_pConnectionTable->FindKey( ConnectionId,
                                         ppConnection );
    if ( lkrc != LK_SUCCESS )
    {
        if ( !fCreateIfNotFound )
        {
            //
            // Just return out now since the caller doesn't want us to create
            // the connection object
            //
            
            return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        
        //
        // Create a new connection object
        //
        
        pNewConnection = new W3_CONNECTION( ConnectionId );
        if ( pNewConnection == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Insert the object into connection table
        //
        
        lkrc = sm_pConnectionTable->InsertRecord( pNewConnection );
        if ( lkrc != LK_SUCCESS )
        {
            delete pNewConnection;
            return HRESULT_FROM_WIN32( lkrc );
        } 
      
        //
        // Monitor when the connection goes away
        //
        
        hr = UlAtqWaitForDisconnect( ConnectionId,
                                     TRUE,
                                     pNewConnection );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error waiting for disconnect of connection '%p'.  hr = %x\n",
                        pNewConnection,
                        hr ));

            //
            // OK.  The connection must have gone away from under us.  This
            // is not fatal.  It just means that once the state machine has
            // completed, we should immediately destroy the connection
            // object.
            //
            
            pNewConnection->RemoveConnection();
        }
        
        *ppConnection = pNewConnection;
    } 
    else
    {
        IF_DEBUG( CONN )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Request on existing W3_CONNECTION '%p'\n",
                        *ppConnection ));
        }
    }
    
    return NO_ERROR;
}

VOID
OnUlDisconnect(
    VOID *                  pvContext
)
/*++

Routine Description:

    Completion routine called when a connection is closed

Arguments:

    pvContext - Points to the W3_CONNECTION which was closed
    
Return Value:

    None

--*/
{
    W3_CONNECTION *         pConnection;
    
    DBG_ASSERT( pvContext != NULL );
    
    pConnection = (W3_CONNECTION*) pvContext;
    
    DBG_ASSERT( pConnection->CheckSignature() );
   
    pConnection->RemoveConnection();
    
}

VOID
W3_CONNECTION::ReferenceConnection(
    VOID
)
/*++

Routine Description:

    Reference the connection (duh)

Arguments:

    None
    
Return Value:

    None

--*/
{
    InterlockedIncrement( &_cRefs );
}
    
VOID 
W3_CONNECTION::DereferenceConnection( 
    VOID 
)
/*++

Routine Description:

    Dereference and possibly cleanup the connection

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( InterlockedDecrement( &_cRefs ) == 0 )
    {
        delete this;    
    }
}

VOID
W3_CONNECTION::RemoveConnection(    
    VOID
)
/*++

Routine Description:

    Remove the connection from the hash table.  This will indirectly
    dereference the connection so that it can await final cleanup

Arguments:

    None
    
Return Value:

    None

--*/
{
    _fConnected = FALSE;
    sm_pConnectionTable->DeleteRecord( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3context.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3context.cxx

   Abstract:
     Drive the state machine
 
   Author:
     Bilal Alam (balam)             10-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "anonymousprovider.hxx"
#include "customprovider.hxx"
#include "staticfile.hxx"
#include "isapi_handler.h"
#include "cgi_handler.h"
#include "trace_handler.h"
#include "dav_handler.h"
#include "options_handler.hxx"
#include "generalhandler.hxx"

//
// Global context list
//

CHAR                    W3_CONTEXT::sm_achRedirectMessage[ 512 ];
DWORD                   W3_CONTEXT::sm_cbRedirectMessage;
CHAR *                  W3_CONTEXT::sm_pszAccessDeniedMessage;

ALLOC_CACHE_HANDLER *   EXECUTE_CONTEXT::sm_pachExecuteContexts;

HRESULT
EXECUTE_CONTEXT::InitializeFromExecUrlInfo(
    HSE_EXEC_URL_INFO *     pExecUrlInfo
)
/*++

Routine Description:

    Initialize an execution context from an HSE_EXEC_URL_INFO structure. 
    This function does the necessary copying

Arguments:

    pExecUrlInfo - Describes the child request to execute

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Copy entity if (any)
    //
    
    if ( pExecUrlInfo->pEntity != NULL )
    {
        _EntityInfo.cbAvailable = pExecUrlInfo->pEntity->cbAvailable;
        _EntityInfo.lpbData = pExecUrlInfo->pEntity->lpbData;
        _ExecUrlInfo.pEntity = &_EntityInfo;
    }
    
    //
    // Copy user (if any)
    //
    
    if ( pExecUrlInfo->pUserInfo != NULL )
    {
        _UserInfo.hImpersonationToken = pExecUrlInfo->pUserInfo->hImpersonationToken;
       
        hr = _HeaderBuffer.AllocateSpace( 
                        pExecUrlInfo->pUserInfo->pszCustomUserName,
                        strlen( pExecUrlInfo->pUserInfo->pszCustomUserName ),
                        &( _UserInfo.pszCustomUserName ) );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = _HeaderBuffer.AllocateSpace( 
                        pExecUrlInfo->pUserInfo->pszCustomAuthType,
                        strlen( pExecUrlInfo->pUserInfo->pszCustomAuthType ),
                        &( _UserInfo.pszCustomAuthType ) );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _ExecUrlInfo.pUserInfo = &_UserInfo;
    }
    
    //
    // Copy URL (if any)
    //
    
    if ( pExecUrlInfo->pszUrl != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace( 
                            pExecUrlInfo->pszUrl,
                            strlen( pExecUrlInfo->pszUrl ),
                            &( _ExecUrlInfo.pszUrl ) );
    
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy method (if any)
    //
    
    if ( pExecUrlInfo->pszMethod != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace(
                            pExecUrlInfo->pszMethod,
                            strlen( pExecUrlInfo->pszMethod ),
                            &( _ExecUrlInfo.pszMethod ) );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Copy child headers
    //
    
    if ( pExecUrlInfo->pszChildHeaders != NULL )
    {
        hr = _HeaderBuffer.AllocateSpace(
                            pExecUrlInfo->pszChildHeaders,
                            strlen( pExecUrlInfo->pszChildHeaders ),
                            &( _ExecUrlInfo.pszChildHeaders ) );

        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    _ExecUrlInfo.dwExecUrlFlags = pExecUrlInfo->dwExecUrlFlags;
    
    return NO_ERROR;
}

//static
HRESULT
EXECUTE_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize execute_context lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( EXECUTE_CONTEXT );

    DBG_ASSERT( sm_pachExecuteContexts == NULL );
    
    sm_pachExecuteContexts = new ALLOC_CACHE_HANDLER( "EXECUTE_CONTEXT",
                                                       &acConfig );
    if ( sm_pachExecuteContexts == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
EXECUTE_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup execute_context lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachExecuteContexts != NULL )
    {
        delete sm_pachExecuteContexts;
        sm_pachExecuteContexts = NULL;
    }
}

HRESULT
W3_CONTEXT::IsapiExecuteUrl(
    HSE_EXEC_URL_INFO *     pExecUrlInfo
)
/*++

Routine Description:

    Do an ISAPI execute URL request.  
    
    SO WHY THE HELL IS THIS CODE NOT IN THE ISAPI_CORE?

    Because I don't want to preclude the same child execute API exposed to
    ISAPI filters (though of course just the synchronous version)

Arguments:

    pExecUrlInfo - Describes the child request to execute

Return Value:

    HRESULT

--*/
{
    DWORD               dwExecFlags = 0;
    WCHAR *             pszRequiredAppPool = NULL;
    BOOL                fIgnoreValidation = FALSE;
    W3_REQUEST *        pChildRequest = NULL;
    W3_CHILD_CONTEXT *  pChildContext = NULL;
    HRESULT             hr = NO_ERROR;
    DWORD               dwCloneRequestFlags = 0;
    BOOL                fFinished = FALSE;
    STACK_STRU(         strNewUrl, 256 );
    STACK_STRA(         strNewVerb, 10 );
    BOOL                fIsSSICommandExecution = FALSE;
    W3_HANDLER *        pSSICommandHandler = NULL;
    HANDLE              hImpersonationToken = NULL;
    CUSTOM_USER_CONTEXT* pCustomUser = NULL;
    STACK_STRA(         strAuthorization, 24 );
    STACK_STRA(         strCustomAuthType, 32 );
    STACK_STRA(         strCustomUserName, 64 );
    BOOL                fEnableWildcardMapping = TRUE;
   
    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    
    //
    // Is this a crappy SSI hack
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_SSI_CMD )
    {
        //
        // Issue-10-11-2000-BAlam
        //
        // This is a really dangerous code path (executing a raw command)
        // so verify that SSI is calling us
        //
        
        fIsSSICommandExecution = TRUE;
    }
    
    //
    // Should we execute the request synchronously?
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_SYNC )
    {
        dwExecFlags |= W3_FLAG_SYNC;
    }
    else
    {
        dwExecFlags |= W3_FLAG_ASYNC;
    }
    
    //
    // Should we suppress headers in the response (useful for SSI)
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_NO_HEADERS )
    {
        dwExecFlags |= W3_FLAG_NO_HEADERS;
    }
    
    //
    // Should we disable custom errors
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_DISABLE_CUSTOM_ERROR )
    {
        dwExecFlags |= W3_FLAG_NO_ERROR_BODY;
    }
    
    //
    // Should we disable * script map?
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR )
    {
        fEnableWildcardMapping = FALSE;
        dwCloneRequestFlags |= W3_REQUEST_CLONE_NO_DAV;
    }
    
    //
    // In every case we will clone the basics
    //
    
    dwCloneRequestFlags = W3_REQUEST_CLONE_BASICS;
    
    //
    // If the client specified headers, then we don't want to clone any
    // headers
    //
    
    if ( pExecUrlInfo->pszChildHeaders == NULL )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_HEADERS;
    }

    //
    // Now, should we also clone the precondition headers?
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_NO_PRECONDITION;
    }
    
    //
    // Now, should we also clone the preloaded entity?
    //

    if ( pExecUrlInfo->pEntity == NULL )
    {
        dwCloneRequestFlags |= W3_REQUEST_CLONE_ENTITY;
    }
    
    //
    // OK.  Start the fun by cloning the current request (as much as needed)
    // 
    
    DBG_ASSERT( QueryRequest() != NULL );
    
    hr = QueryRequest()->CloneRequest( dwCloneRequestFlags,
                                       &pChildRequest );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pChildRequest != NULL );

    //
    // If the parent specified headers, add them now
    //
    
    if ( pExecUrlInfo->pszChildHeaders != NULL )
    {
        hr = pChildRequest->SetHeadersByStream( pExecUrlInfo->pszChildHeaders );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }   
    
    //
    // If we have entity to stuff in, do so now
    //
    
    if ( pExecUrlInfo->pEntity != NULL )
    {
        hr = pChildRequest->AppendEntityBody( pExecUrlInfo->pEntity->lpbData,
                                              pExecUrlInfo->pEntity->cbAvailable );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // Setup the URL for the request, if specified (it can contain a 
    // query string)
    // 
    // If this is a command execution, then ignore the URL since it really
    // isn't a URL in this case (it is a command to execute)
    //
    
    if ( pExecUrlInfo->pszUrl != NULL &&
         !fIsSSICommandExecution )
    {
        hr = strNewUrl.CopyA( pExecUrlInfo->pszUrl );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Now set the new URL/Querystring
        //
        
        hr = pChildRequest->SetUrl( strNewUrl );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // Set the verb for this request if specified
    //
    
    if ( pExecUrlInfo->pszMethod != NULL )
    {
        hr = strNewVerb.Copy( pExecUrlInfo->pszMethod );
        if ( FAILED( hr ) )
        {
            goto Finished;
        } 
        
        hr = pChildRequest->SetVerb( strNewVerb );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // If a user context was set for this child request, then create a
    // custom user context and do the necessary hookup
    //
    
    if ( pExecUrlInfo->pUserInfo != NULL )
    {
        if ( pExecUrlInfo->pUserInfo->hImpersonationToken != NULL )
        {
            hImpersonationToken = pExecUrlInfo->pUserInfo->hImpersonationToken;
        }
        else
        {
            hImpersonationToken = QueryImpersonationToken();
        }
        
        DBG_ASSERT( hImpersonationToken != NULL );
        
        //
        // Create the user context
        //
        
        pCustomUser = new CUSTOM_USER_CONTEXT(
                            W3_STATE_AUTHENTICATION::QueryCustomProvider() ); 
        if ( pCustomUser == NULL )
        {
            goto Finished;
        }
        
        hr = pCustomUser->Create( hImpersonationToken,
                                  pExecUrlInfo->pUserInfo->pszCustomUserName,
                                  QueryUserContext()->QueryAuthType() );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Make sure REMOTE_USER is calculated properly
        //
        
        hr = strCustomUserName.Copy( pExecUrlInfo->pUserInfo->pszCustomUserName );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        hr = pChildRequest->SetRequestUserName( strCustomUserName );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Note that AUTH_TYPE server variable is a request'ism.  So stuff it
        // into the request now indirectly by setting authorization header
        //
        
        hr = strAuthorization.Copy( "Authorization" );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        hr = strCustomAuthType.Copy( pExecUrlInfo->pUserInfo->pszCustomAuthType );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        hr = pChildRequest->SetHeader( strAuthorization,
                                       strCustomAuthType,
                                       FALSE );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }        
    else
    {
        //
        // No custom user
        //
        
        pCustomUser = NULL;
    }
    
    //
    // Now we can create a child context
    //
    
    pChildContext = new W3_CHILD_CONTEXT( QueryMainContext(),
                                          this,             // parent
                                          pChildRequest,
                                          TRUE,             // child owns
                                          pCustomUser,
                                          dwExecFlags );
    if ( pChildContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Get the URL context for this new context
    //
    
    hr = pChildContext->RetrieveUrlContext( &fFinished );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    if ( fFinished )
    {
        //
        // Filter wants to bail.
        //
        
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Finished;
    }

    //
    // Now validate that the app pool name is correct, if necessary
    //
    
    if ( !( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_IGNORE_APPPOOL ) )
    {
        if ( QueryUrlContext() == NULL )
        {
            DBG_ASSERT( FALSE );
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Finished;
        }
        
        DBG_ASSERT( QueryUrlContext()->QueryMetaData() );
        
        pszRequiredAppPool = QueryUrlContext()->QueryMetaData()->QueryAppPoolId();
        
        if ( wcscmp( pszRequiredAppPool,
                     pChildContext->QueryUrlContext()->QueryMetaData()->QueryAppPoolId() ) )
        {
            //
            // App pool name doesn't match. Bail
            //
            
            hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto Finished;
        }
    }
    
    //
    // ULTRA-GROSS.  If this is an explicit command execution from SSI, then
    // we explicitly setup the CGI handler.  Otherwise, we determine the 
    // handler using sane rules
    // 
    
    if ( fIsSSICommandExecution )
    {
        pSSICommandHandler = new W3_CGI_HANDLER( pChildContext,
                                                 NULL,
                                                 pExecUrlInfo->pszUrl );
        if ( pSSICommandHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }    
        
        pChildContext->SetSSICommandHandler( pSSICommandHandler );
    }
    else
    {
        //
        // Properly find a handler for this request
        //
    
        hr = pChildContext->DetermineHandler( fEnableWildcardMapping );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    DBG_ASSERT( pChildContext->QueryHandler() != NULL );

    hr = pChildContext->ExecuteHandler( dwExecFlags );
    
    //
    // If we failed, then we should just cleanup and report the error.
    //
    // NOTE:  Failure means failure to spawn the child request.  Not that
    //        the child request encountered a failure.
    //
    
Finished:

    //
    // If we spawned this async, and there was no failure, then return out
    //

    if ( !FAILED( hr ) && ( dwExecFlags & W3_FLAG_ASYNC ) )
    {
        return NO_ERROR;
    }
    
    //
    // If we're here, we either failed, or succeeded synchronously
    //
    
    //
    // If the urlcontext/child-request was attached to the child context, 
    // the child context will clean it up
    //
    
    if ( pChildContext != NULL )
    {   
        delete pChildContext;
    }
    else
    {
        if ( pChildRequest != NULL )
        {
            delete pChildRequest;
        }
        
        if ( pCustomUser != NULL )
        {
            pCustomUser->DereferenceUserContext();
            pCustomUser = NULL;
        }
    }
    
    return hr;
}

HRESULT
W3_CONTEXT::ExecuteChildRequest(
    W3_REQUEST *            pNewRequest,
    BOOL                    fOwnRequest,
    DWORD                   dwFlags
)
/*++

Routine Description:

    Execute a child request (for internal W3CORE use only)

Arguments:

    pNewRequest - W3_REQUEST * representing the new request
    fOwnRequest - Should the child context be responsible for cleaning up
                  request? 
    dwFlags - W3_FLAG_ASYNC async
              W3_FLAG_SYNC sync 
              W3_FLAG_MORE_DATA caller needs to send data too,
              W3_FLAG_NO_CUSTOM_ERROR do not execute custom errors

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    W3_CHILD_CONTEXT *      pChildContext = NULL;
    BOOL                    fFinished = FALSE;

    if ( !VALID_W3_FLAGS( dwFlags ) )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Ignore the fFinished value on a child
    //

    pChildContext = new W3_CHILD_CONTEXT( QueryMainContext(),
                                          this,
                                          pNewRequest,
                                          fOwnRequest,
                                          NULL,
                                          dwFlags );
    if ( pChildContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    
    //
    // First read the metadata for this new request
    //
    
    hr = pChildContext->RetrieveUrlContext( &fFinished );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    if ( fFinished )
    {
        //
        // Filter wants to bail.
        //
        
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto Finished;
    }
        
    //
    // Find handler
    //
    
    hr = pChildContext->DetermineHandler( TRUE );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pChildContext->QueryHandler() );

    //
    // Execute the handler and take the error in any non-pending case
    // (we can't get the status on pending since the value we would be
    // getting is instable)
    //
    
    hr = pChildContext->ExecuteHandler( dwFlags );

Finished:

    //
    // If we spawned this async, and there was no failure, then return out
    //
    
    if ( !FAILED( hr ) && ( dwFlags & W3_FLAG_ASYNC ) )
    {
        return NO_ERROR;
    }
    
    //
    // If we got here, then either something bad happened OR a synchronous
    // child execute is complete.  Either way, we can delete the context
    // here
    //
   
    if ( pChildContext != NULL )
    {
        delete pChildContext;
    }
    else
    {
        if ( pNewRequest && fOwnRequest )
        {
            delete pNewRequest;
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::SetupAllowHeader(
    VOID
)
/*++

Routine Description:
    
    Setup a 405 response.  This means setting the response status as well
    as setting up an appropriate Allow: header

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    STACK_STRA(             strAllowHeader, 256 );
    URL_CONTEXT *           pUrlContext;
    HRESULT                 hr;
    W3_URL_INFO *           pUrlInfo;
    W3_METADATA *           pMetaData;
    MULTISZA *              pAllowedVerbs;
    const CHAR *            pszAllowedVerb;
    
    pUrlContext = QueryUrlContext();
    if ( pUrlContext == NULL )
    {
        //
        // If we have no metadata, then don't send an Allow: header.  The 
        // only case this would happen is if a filter decided to send the
        // response and in that case it is up to it to send an appropriate
        // Allow: header
        //
        
        return NO_ERROR;
    }    
    
    pUrlInfo = pUrlContext->QueryUrlInfo();
    if ( pUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pMetaData = pUrlContext->QueryMetaData();
    if ( pMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // We always support OPTIONS and TRACE
    //
    
    hr = strAllowHeader.Append( "OPTIONS, TRACE" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Is this URL script mapped?  If so, then the verbs allowed is equal to
    // to the verbs specified in the script map, provided that we have 
    // script execute permissions
    //
    
    if ( pUrlInfo->QueryScriptMapEntry() != NULL )
    {
        if ( IS_ACCESS_ALLOWED( QueryRequest(),
                                pMetaData->QueryAccessPerms(), 
                                SCRIPT ) )
        {
            pAllowedVerbs = pUrlInfo->QueryScriptMapEntry()->QueryAllowedVerbs();
            DBG_ASSERT( pAllowedVerbs != NULL );
        
            pszAllowedVerb = pAllowedVerbs->First();
            while ( pszAllowedVerb != NULL )
            {
                hr = strAllowHeader.Append( ", " );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                hr = strAllowHeader.Append( pszAllowedVerb );
                if (FAILED(hr))
                {
                    return hr;
                }

                pszAllowedVerb = pAllowedVerbs->Next( pszAllowedVerb );
            }
        }
    }
    else
    {
        //
        // Must be a static file or a explicit gateway
        //
        
        switch( pUrlInfo->QueryGateway() )
        {
        case GATEWAY_UNKNOWN:
        case GATEWAY_MAP:
            hr = strAllowHeader.Append( ", GET, HEAD" );
            break;
        case GATEWAY_CGI:
        case GATEWAY_ISAPI:
            hr = strAllowHeader.Append( ", GET, HEAD, POST" );
            break;
        }
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Now add some DAV verbs (man, this is broken)
    // 
    
    if ( IS_ACCESS_ALLOWED( QueryRequest(),
                            pMetaData->QueryAccessPerms(),
                            WRITE ) &&
         !pMetaData->QueryIsDavDisabled() )
    {
        hr = strAllowHeader.Append( ", DELETE, PUT" );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Finally, set the header
    //
    
    hr = QueryResponse()->SetHeader( HttpHeaderAllow,
                                     strAllowHeader.QueryStr(),
                                     strAllowHeader.QueryCCH() );

    return hr;
}

HRESULT
W3_CONTEXT::SetupCustomErrorFileResponse(
    STRU &                  strErrorFile
)
/*++

Routine Description:

    Open the custom error file (nor URL) from cache if possible and setup
    the response (which means, fill in entity body with file)

Arguments:

    strErrorFile - Custom Error File

Return Value:

    HRESULT (HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND) to indicate to caller
    that it should just generate hard coded custom error.

--*/
{
    W3_FILE_INFO *          pOpenFile = NULL;
    HRESULT                 hr = NO_ERROR;
    DWORD                   dwFlags;
    W3_RESPONSE *           pResponse = QueryResponse();
    FILE_CACHE_USER         fileUser;
    LARGE_INTEGER           liFileSize;
    W3_METADATA *           pMetaData;
    URL_CONTEXT *           pUrlContext;
    STACK_STRA(             strContentType, 32 );
    
    DBG_ASSERT( pResponse != NULL );
    DBG_ASSERT( !pResponse->QueryEntityExists() ); 
    DBG_ASSERT( pResponse->QueryStatusCode() >= 400 );
    
    //
    // Get the file from the cache.  We will enable deferred directory
    // monitor changes.  This means that we will register for the appropriate
    // parent directory changes as needed and remove as the cached file
    // object goes away.
    //
    
    DBG_ASSERT( g_pW3Server->QueryFileCache() != NULL );
    
    hr = g_pW3Server->QueryFileCache()->GetFileInfo( strErrorFile,
                                                     NULL,
                                                     &fileUser,
                                                     TRUE,
                                                     &pOpenFile );          
    if ( FAILED( hr ) )
    {
        //
        // Switch some known errors back to file not found
        //
        
        switch( hr )
        {
        case HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ):
        case HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ):
       
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            break;
        }
        
        return hr;
    }
    
    DBG_ASSERT( pOpenFile != NULL );
    
    //
    // We might already have a custom error file IF we encountered an error
    // setting up the last custom error response
    //
    
    if ( _pCustomErrorFile != NULL )
    {
        _pCustomErrorFile->DereferenceCacheEntry();    
        _pCustomErrorFile = NULL;
    }
    
    DBG_ASSERT( pOpenFile != NULL );
    _pCustomErrorFile = pOpenFile;

    //
    // Determine the content-type and set the header
    //
    
    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );

    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    hr = SelectMimeMappingForFileExt( strErrorFile.QueryStr(),
                                      pMetaData->QueryMimeMap(),
                                      &strContentType );
    if ( SUCCEEDED( hr ) )
    {
        hr = pResponse->SetHeader( HttpHeaderContentType,
                                   strContentType.QueryStr(),
                                   strContentType.QueryCCH() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Now setup the response chunk
    //
    
    pOpenFile->QuerySize( &liFileSize );
    
    if ( pOpenFile->QueryFileBuffer() != NULL )
    {
        hr = pResponse->AddMemoryChunkByReference( 
                                pOpenFile->QueryFileBuffer(),
                                liFileSize.LowPart );
    }
    else
    {
        hr = pResponse->AddFileHandleChunk(pOpenFile->QueryFileHandle(),
                                           0,
                                           liFileSize.LowPart );
    }
    
    return hr; 
}

HANDLE
W3_CONTEXT::QueryImpersonationToken(
    BOOL *  pfIsVrToken
)
/*++

Routine Description:

    Get the impersonation token for this request.  This routine will 
    choose correctly based on whether there is a VRoot token, passthru is
    enabled, etc.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    W3_METADATA *           pMetaData;
    TOKEN_CACHE_ENTRY *     pVrToken;
    W3_USER_CONTEXT *       pUserContext;
    
    DBG_ASSERT( QueryUrlContext() != NULL );
    
    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUserContext = QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );
    
    pVrToken = pMetaData->QueryVrAccessToken();
    if ( pVrToken == NULL ||
         ( pMetaData->QueryVrPassThrough() && 
           pUserContext->QueryDelegatable() ) )
    {
        if ( pfIsVrToken )
        {
            *pfIsVrToken = FALSE;
        }

        return pUserContext->QueryImpersonationToken();
    }
    else
    {
        DBG_ASSERT( pVrToken != NULL );

        if ( pfIsVrToken )
        {
            *pfIsVrToken = TRUE;
        }

        return pVrToken->QueryImpersonationToken();
    }
}

VOID
W3_CONTEXT::QueryFileCacheUser(
    FILE_CACHE_USER *           pFileCacheUser
)
/*++

Routine Description:

    Get a user descriptor suitable for use with file cache

Arguments:

    pFileCacheUser - Filled with file cache user information

Return Value:

    None

--*/
{
    W3_METADATA *           pMetaData;
    TOKEN_CACHE_ENTRY *     pVrToken;
    W3_USER_CONTEXT *       pUserContext;
    HANDLE                  hReturnToken = NULL;
    PSID                    pReturnSid = NULL;

    DBG_ASSERT( pFileCacheUser != NULL );
    
    DBG_ASSERT( QueryUrlContext() != NULL );
    
    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUserContext = QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );
    
    pVrToken = pMetaData->QueryVrAccessToken();
    if ( pVrToken == NULL ||
         ( pMetaData->QueryVrPassThrough() && 
           pUserContext->QueryDelegatable() ) )
    {
        hReturnToken = pUserContext->QueryImpersonationToken();
        pReturnSid = pUserContext->QuerySid();
    }
    else
    {
        DBG_ASSERT( pVrToken != NULL );
        
        pReturnSid = pVrToken->QuerySid();
        hReturnToken = pVrToken->QueryImpersonationToken();
    }
    
    //
    // Setup the file cache user
    //

    pFileCacheUser->_hToken = hReturnToken;
    pFileCacheUser->_pSid = pReturnSid;
}

HANDLE
W3_CONTEXT::QueryPrimaryToken(
    VOID
)
/*++

Routine Description:

    Get the primary token for this request.  This routine will 
    choose correctly based on whether there is a VRoot token, passthru is
    enabled, etc.

Arguments:

    None

Return Value:

    HANDLE

--*/
{
    W3_METADATA *           pMetaData;
    TOKEN_CACHE_ENTRY *     pVrToken;
    W3_USER_CONTEXT *       pUserContext;
    
    DBG_ASSERT( QueryUrlContext() != NULL );
    
    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    pUserContext = QueryUserContext();
    DBG_ASSERT( pUserContext != NULL );
    
    pVrToken = pMetaData->QueryVrAccessToken();
    if ( pVrToken == NULL ||
         ( pMetaData->QueryVrPassThrough() && 
           pUserContext->QueryDelegatable() ) )
    {
        return pUserContext->QueryPrimaryToken();
    }
    else
    {
        DBG_ASSERT( pVrToken != NULL );
        return pVrToken->QueryPrimaryToken();
    }
}

HRESULT
W3_CONTEXT::GetCertificateInfoEx(
    IN  DWORD           cbAllocated,
    OUT DWORD *         pdwCertEncodingType,
    OUT unsigned char * pbCertEncoded,
    OUT DWORD *         pcbCertEncoded,
    OUT DWORD *         pdwCertificateFlags
)
/*++

Routine Description:

    Retrieve certificate info if available

Arguments:

Return Value:

    HRESULT

--*/
{
    CERTIFICATE_CONTEXT *       pCertContext = NULL;
    DWORD                       cbCert = 0;
    PVOID                       pvCert = NULL;
    
    if ( pdwCertEncodingType == NULL ||
         pbCertEncoded == NULL ||
         pcbCertEncoded == NULL ||
         pdwCertificateFlags == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pCertContext = QueryCertificateContext();
    
    if ( pCertContext == NULL )
    {
        //
        // If we don't have a certificate, then just succeed with nothing
        // to keep in line with IIS 5 behaviour
        //
        
        *pbCertEncoded = NULL;
        *pcbCertEncoded = 0;
        return NO_ERROR;
    }
    
    pCertContext->QueryEncodedCertificate( &pvCert, &cbCert );
    DBG_ASSERT( pvCert != NULL );
    DBG_ASSERT( cbCert != 0 );
    
    //
    // Fill in the parameters
    //

    *pcbCertEncoded = cbCert;
    
    if ( cbAllocated < *pcbCertEncoded )
    {
        //
        // Not enough space
        //
        
        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ); 
    }
    else
    {
        memcpy( pbCertEncoded,
                pvCert,
                *pcbCertEncoded );
        
        *pdwCertificateFlags = pCertContext->QueryFlags();
        *pdwCertEncodingType = X509_ASN_ENCODING;
        
        return NO_ERROR;
    }
}

HRESULT
W3_CONTEXT::SendResponse(
    DWORD                   dwFlags
)
/*++

Routine Description:

    Sends a response to the client thru ULATQ.  

Arguments:

    dwFlags - Flags 
              W3_FLAG_ASYNC - Send response asynchronously
              W3_FLAG_SYNC - Send response synchronously
              W3_FLAG_MORE_DATA - Send more data 
              W3_FLAG_NO_ERROR_BODY - Don't generate error body
              W3_FLAG_GENERATE_CONTENT_LENGTH - generate content length

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    BOOL                    fIsFileError = FALSE;
    BOOL                    fFinished = FALSE;
    DWORD                   cbSent = 0;
    BOOL                    fAddContentLength = FALSE;
    BOOL                    fSendHeaders = FALSE;
    BOOL                    fHandlerManagesHead = FALSE;
    BOOL                    fEnableUlCache = FALSE;
    BOOL                    fSuppressEntity = FALSE;
    DWORD                   dwResponseFlags = 0;
    AUTH_PROVIDER *         pAnonymousProvider = NULL;
    W3_RESPONSE *           pResponse;
    W3_FILTER_CONTEXT *     pFilterContext;

    if ( !VALID_W3_FLAGS( dwFlags ) )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pResponse = QueryResponse();
    DBG_ASSERT( pResponse != NULL );    
    
    //
    // Should we be sending headers at all?
    //
    
    fSendHeaders = QuerySendHeaders();
    
    //
    // Do a quick precheck to see whether we require an END_OF_REQUEST
    // notification.  If so, then this won't be our last send
    //
    
    if ( fSendHeaders &&
         ( IsNotificationNeeded( SF_NOTIFY_END_OF_REQUEST ) ||
           IsNotificationNeeded( SF_NOTIFY_LOG ) ) )
    {
        if ( !( dwFlags & W3_FLAG_MORE_DATA ) &&
             !QueryNeedFinalDone() )
        {
            //
            // If the only reason this is NOT the final send is because of
            // an END_OF_REQUEST or LOG filter, then act like IIS 5.0 and
            // still send a content length
            //
            
            fAddContentLength = TRUE;
        }
        
        dwFlags |= W3_FLAG_MORE_DATA;  
    }

    //
    // Remember whether we need to send an empty done on our own at the end
    //

    if ( dwFlags & W3_FLAG_MORE_DATA )
    {
        SetNeedFinalDone();
    }

    //
    // Was this an access denial not handled by an authentication provider?
    //

    if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode &&
         !QueryProviderHandled() && 
         QueryUrlContext() != NULL )
    {
        //
        // First call access denied filters
        //

        if ( IsNotificationNeeded( SF_NOTIFY_ACCESS_DENIED ) )
        {
            STACK_STRA( straUrl, 256 );
            STACK_STRA( straPhys, 256 );
            STACK_STRU( strUrl, 256 );
            STRU *      pstrPhysicalPath;

            hr = QueryRequest()->GetUrl( &strUrl );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pstrPhysicalPath = QueryUrlContext()->QueryPhysicalPath();
            DBG_ASSERT( pstrPhysicalPath != NULL );

            if (FAILED(hr = straUrl.CopyW(strUrl.QueryStr())) ||
                FAILED(hr = straPhys.CopyW(pstrPhysicalPath->QueryStr())))
            {
                return hr;
            }

            if ( !QueryFilterContext()->NotifyAccessDenied(
                                        straUrl.QueryStr(),
                                        straPhys.QueryStr(),
                                        &fFinished ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( fFinished )
            {
                if ( dwFlags & W3_FLAG_ASYNC )
                {
                    ThreadPoolPostCompletion( 0,
                                              W3_MAIN_CONTEXT::OnPostedCompletion,
                                              (LPOVERLAPPED) QueryMainContext() ); 
                }

                return NO_ERROR;
            }
        }

        //
        // Now, notify all authentication providers so they can add headers
        // if necessary
        //

        hr = W3_STATE_AUTHENTICATION::CallAllAccessDenied( QueryMainContext() );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // Send a custom error for this response if all of following are true:
    //
    // a) The caller wants an error body
    // b) This request (and all children) actually allow an error body
    // c) The response code is greater than 400 (error)
    //

    if ( !(dwFlags & W3_FLAG_NO_ERROR_BODY ) &&
         QuerySendErrorBody() &&
         pResponse->QueryStatusCode() >= 400 )
    {
        STACK_STRU(             strError, 64 );
        STACK_STRU(             strFullUrl, 64 );
        WCHAR                   achNum[ 32 ];
        HTTP_SUB_ERROR          subError;
        W3_REQUEST *            pChildRequest = NULL;

        pResponse->Clear( TRUE );

        DisableUlCache();

        //
        // Get the sub error for this response (if any)
        //

        hr = pResponse->QuerySubError( &subError );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Check for a configured custom error.  This check is only possible
        // if we have read metadata.  We may not have read metadata if
        // some fatal error occurred early in the pipeline (for example,
        // an out-of-mem error in the URLINFO state)
        //

        if ( QueryUrlContext() != NULL && 
             QuerySendCustomError() )
        {
            W3_METADATA *           pMetaData = NULL;
            
            pMetaData = QueryUrlContext()->QueryMetaData();
            DBG_ASSERT( pMetaData != NULL );

            hr = pMetaData->FindCustomError( pResponse->QueryStatusCode(),
                                             subError.mdSubError,
                                             &fIsFileError,
                                             &strError );

            //
            // If this is a file error, check for file existence now.  If it
            // does not exist, then act as if there is no custom error set
            //

            if ( SUCCEEDED( hr ) )
            {
                if ( fIsFileError )
                {
                    hr = SetupCustomErrorFileResponse( strError );
                }
                else
                {
                    //
                    // This is a custom error URL
                    //
                    
                    //
                    // If there is no user context, then executing a child
                    // request would be tough.  
                    //
                    // But we can still try to get the anonymous token, if 
                    // it exists and use it
                    //  
            
                    if ( QueryUserContext() == NULL )
                    {
                        pAnonymousProvider = W3_STATE_AUTHENTICATION::QueryAnonymousProvider();
                        DBG_ASSERT( pAnonymousProvider != NULL );
        
                        hr = pAnonymousProvider->DoAuthenticate( QueryMainContext() );
                        if ( FAILED( hr ) ||
                             QueryMainContext()->QueryUserContext() == NULL )
                        {
                            //
                            // Ok.  We really can't get anonymous user.
                            // No custom error URL
                            //
                            
                            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
                        }
                    }
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        
        if ( SUCCEEDED( hr ) )
        {   
            //
            // Great.  Send the configured custom error
            //

            if ( !fIsFileError )
            {
                //
                // This is a custom error URL.  Reset and launch custom URL
                //
                // The URL is of the form:
                //
                // /customerrorurl?<status>;http://<server>/<original url>
                //
                
                hr = QueryRequest()->CloneRequest( 
                                    W3_REQUEST_CLONE_BASICS |
                                    W3_REQUEST_CLONE_HEADERS |
                                    W3_REQUEST_CLONE_NO_PRECONDITION |
                                    W3_REQUEST_CLONE_NO_DAV,
                                    &pChildRequest );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                DBG_ASSERT( pChildRequest != NULL );
                
                hr = strError.Append( L"?" );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                _itow( pResponse->QueryStatusCode(), achNum, 10 );
                
                hr = strError.Append( achNum );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                hr = strError.Append( L";" );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                hr = QueryRequest()->GetFullUrl( &strFullUrl );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                hr = strError.Append( strFullUrl );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                //
                // Change the URL and verb of the request
                //
                
                hr = pChildRequest->SetUrl( strError );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                //
                // Remove DAVFS'ness
                //
                
                pChildRequest->RemoveDav();
                
                //
                // All custom error URLs are GET/HEADs
                //
                
                if ( pChildRequest->QueryVerbType() == HttpVerbHEAD )
                {
                    pChildRequest->SetVerbType( HttpVerbHEAD );
                }
                else
                {
                    pChildRequest->SetVerbType( HttpVerbGET );
                }
                
                pResponse->SetStatus( HttpStatusOk );
                
                hr = ExecuteChildRequest( pChildRequest,
                                          TRUE,    // child context cleans up
                                          dwFlags | W3_FLAG_NO_CUSTOM_ERROR );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                return NO_ERROR;
            }
        }
        else 
        {
            //
            // Not finding a custom error is OK, but any other error is
            // fatal
            //

            DBG_ASSERT( FAILED( hr ) );

            if ( hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
            {
                return hr;
            }

            CHAR  *achImageError;
            DWORD cbImageError = 512;

            if (FAILED(hr = QueryHeaderBuffer()->AllocateSpace(
                                cbImageError,
                                &achImageError)))
            {
                return hr;
            }
            
            //
            // Check the image for a resource string which may apply.
            //
            
            if ( subError.dwStringId != 0 )
            {
                hr = g_pW3Server->LoadString( subError.dwStringId,
                                              achImageError,
                                              &cbImageError );
            }
            else if ( pResponse->QueryStatusCode() == 
                          HttpStatusUnauthorized.statusCode &&
                      sm_pszAccessDeniedMessage != NULL )
            {
                //
                // Note: 401 message is actually configured in the registry
                //
            
                strncpy( achImageError,
                         sm_pszAccessDeniedMessage,
                         cbImageError - 1 );
                
                achImageError[ cbImageError - 1 ] = '\0';
                cbImageError = strlen( achImageError );
                hr = NO_ERROR;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            if (FAILED(hr) &&
                FAILED(QueryErrorStatus()))
            {
                cbImageError = 512;
                //
                // If there is a particular error status set, find the
                // message for that error and send it.  This is that last
                // thing we can do to attempt to send a useful message to
                // client
                //

                cbImageError = FormatMessageA(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    QueryErrorStatus(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    achImageError,
                    cbImageError,
                    NULL);

                if (cbImageError == 0)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                else
                {
                    hr = S_OK;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //
                // Add content type
                //
                
                hr = pResponse->SetHeader( HttpHeaderContentType,
                                           "text/html",
                                           9 );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
                
                hr = pResponse->AddMemoryChunkByReference(
                                           achImageError,
                                           cbImageError );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
        }
    }
    
    //
    // Send custom headers if any
    //

    if ( fSendHeaders && 
         QueryUrlContext() != NULL )
    {
        W3_METADATA *pMetaData = QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL );

        // 
        // Add Custom HTTP Headers if defined in the metabase.
        //
        
        if ( !pMetaData->QueryCustomHeaders()->IsEmpty() )
        {
            hr = pResponse->AppendResponseHeaders( *(pMetaData->QueryCustomHeaders()) );
            if ( FAILED( hr ) )
            {
                pResponse->Clear();
                return hr;
            }
        }

        //
        // Add Cache-Control and Expires header if so configured
        //
        STRA *pstrCacheControlHeader = pMetaData->QueryCacheControlHeader();
        if (!pstrCacheControlHeader->IsEmpty())
        {
            if (FAILED(hr = pResponse->SetHeader(
                                HttpHeaderCacheControl,
                                pstrCacheControlHeader->QueryStr(),
                                pstrCacheControlHeader->QueryCCH(),
                                TRUE)))
            {
                pResponse->Clear();
                return hr;
            }
        }

        if (pMetaData->QueryExpireMode() == EXPIRE_MODE_STATIC)
        {
            STRA *pstrExpireHeader = pMetaData->QueryExpireHeader();

            if (FAILED(hr = pResponse->SetHeaderByReference(
                                HttpHeaderExpires,
                                pstrExpireHeader->QueryStr(),
                                pstrExpireHeader->QueryCCH())))
            {
                pResponse->Clear();
                return hr;
            }
        }
    }
    
    //
    // Does the current handler manage content length on its own?
    // We'll assume (i.e. the choice which means we do nothing to supply
    // a content-length header or suppress HEADs)
    //
    
    if ( QueryHandler() != NULL )
    {
        fHandlerManagesHead = QueryHandler()->QueryManagesOwnHead();        
    }
    
    //
    // Should we be adding a content-length header?  
    // 
    // Note we get the original verb (not the current request's verb).
    // This is because the original verb determines whether or not UL
    // will be sending a content-length for us.  
    //
    
    if ( ( QueryMainContext()->QueryShouldGenerateContentLength() &&
           !fHandlerManagesHead &&
           !QueryNeedFinalDone() ) ||
         fAddContentLength ||
         (dwFlags & W3_FLAG_GENERATE_CONTENT_LENGTH) )
    {  
        CHAR                   achNum[ 32 ];

        //
        // If there is already a Content-Length header, then no need to
        // make one (this must mean the handler handled HEAD themselves)
        //
            
        if ( pResponse->GetHeader( HttpHeaderContentLength ) == NULL )
        {
            _ui64toa( pResponse->QueryContentLength(),
                      achNum,
                      10 );
    
            hr = pResponse->SetHeader( HttpHeaderContentLength, 
                                       achNum,
                                       strlen( achNum ) );
            if ( FAILED( hr ) )
            {
                SetErrorStatus( hr );
                pResponse->SetStatus( HttpStatusServerError );
                return hr;
            }
        }
    }
    
    //
    // Should we be suppressing entity.  This should be done if this is a 
    // HEAD request and the current handler doesn't take responsibility
    // to handle HEADs
    //
    
    if ( QueryRequest()->QueryVerbType() == HttpVerbHEAD &&
         !fHandlerManagesHead )
    {
        DisableUlCache();
        fSuppressEntity = TRUE;
    }
    
    //
    // Remember what type of operation this is, so that the completion 
    // can do the proper book keeping
    //

    if ( dwFlags & W3_FLAG_ASYNC )
    {
        SetLastIOPending( LOG_WRITE_IO );
    }

    //
    // Setup logging information
    //
    
    BOOL fDoLogging = FALSE;
    if ( fSendHeaders &&
         !QueryNeedFinalDone() && 
         QueryDoUlLogging() )
    {
        fDoLogging = TRUE;
        if ( FAILED( hr = QueryMainContext()->CollectLoggingData( TRUE ) ) )
        {
            return hr;
        }
    }

    //
    // If a filter added response headers (either for regular responses or
    // for denial responses), then add them now
    //
    
    pFilterContext = QueryFilterContext( FALSE );
    if ( pFilterContext != NULL )
    {
        //
        // Add denial headers if this is a denial
        //
        
        if ( pResponse->QueryStatusCode() == HttpStatusUnauthorized.statusCode )
        {
            //
            // Add filter denied headers
            // 
            
            hr = pResponse->AppendResponseHeaders(
                                    *pFilterContext->QueryAddDenialHeaders() );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            pFilterContext->QueryAddDenialHeaders()->Reset();
        }
        
        //
        // Add regular headers
        //
        
        hr = pResponse->AppendResponseHeaders(
                                *pFilterContext->QueryAddResponseHeaders() );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        pFilterContext->QueryAddResponseHeaders()->Reset();
    }
    
    //
    // Notify Response header filters
    //
    
    if ( fSendHeaders && 
         IsNotificationNeeded( SF_NOTIFY_SEND_RESPONSE ) )
    {
        HTTP_FILTER_SEND_RESPONSE           sendResponse;
        
        sendResponse.GetHeader = GetSendHeader;
        sendResponse.SetHeader = SetSendHeader;
        sendResponse.AddHeader = AddSendHeader;
        sendResponse.HttpStatus = pResponse->QueryStatusCode();
        
        if ( !NotifyFilters( SF_NOTIFY_SEND_RESPONSE,
                             &sendResponse,
                             &fFinished ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );  // BUGBUG
        }
        
        if ( fFinished )
        {
            if ( dwFlags & W3_FLAG_ASYNC )
            {
                ThreadPoolPostCompletion( 0,
                                          W3_MAIN_CONTEXT::OnPostedCompletion,
                                          (LPOVERLAPPED) QueryMainContext() ); 
            }
            
            return NO_ERROR;
        }
    }

    // perf ctr
    if (QuerySite() != NULL)
    {
        if ( pResponse->QueryStatusCode() == HttpStatusNotFound.statusCode )
        {
            QuerySite()->IncNotFound();
        }
        else if ( pResponse->QueryStatusCode() == HttpStatusLockedError.statusCode )
        {
            QuerySite()->IncLockedError();
        }
    }

    //
    // If any one sees a reason why this response and this kernel mode cache
    // should not be together, speak now or forever hold your peace (or 
    // at least until the UL cache flushes the response)
    //
    
    DBG_ASSERT( g_pW3Server->QueryUlCache() != NULL );
    
    if ( g_pW3Server->QueryUlCache()->CheckUlCacheability( this ) )
    {
        //
        // The response is UL cacheable, so setup a ul cache entry token
        //
        
        if ( _pHandler != NULL )
        {
            DBG_ASSERT( _pHandler->QueryIsUlCacheable() );
            
            hr = _pHandler->SetupUlCachedResponse( this );
            if ( SUCCEEDED( hr ) )
            {
                fEnableUlCache = TRUE;
            }
        }
    }
    
    //
    // Generate response flags now
    //
    
    if ( QueryNeedFinalDone() )
    {
        dwResponseFlags |= W3_RESPONSE_MORE_DATA;
    }
    
    if ( QueryDisconnect() )
    {
        dwResponseFlags |= W3_RESPONSE_DISCONNECT;
    }
    
    if ( fEnableUlCache )
    {
        dwResponseFlags |= W3_RESPONSE_UL_CACHEABLE;
    }
    
    if ( !fSendHeaders )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_HEADERS;
    }
    
    if ( fSuppressEntity )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_ENTITY;
    }
    
    if ( dwFlags & W3_FLAG_ASYNC )
    {
        dwResponseFlags |= W3_RESPONSE_ASYNC;
    }
    
    //
    // Send out the full response now
    //

    hr = pResponse->SendResponse( this,
                                  dwResponseFlags,
                                  &cbSent,
                                  fDoLogging ? QueryUlLogData() : NULL );
    
    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesSent(cbSent);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendResponse failed: no handler, hr %x\n",
                       hr));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendResponse failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::SendEntity(
    DWORD               dwFlags
)
/*++

Routine Description:

    Sends a response entity to the client thru ULATQ.  

Arguments:

    dwFlags - Flags 
              W3_FLAG_ASYNC - Send response asynchronously
              W3_FLAG_SYNC - Send response synchronously
              W3_FLAG_PAST_END_OF_REQ - Send after END_OF_REQUEST notification
                  to let UL know we are done

Return Value:

    HRESULT

--*/
{
    DWORD               dwResponseFlags = 0;
    
    if ( !VALID_W3_FLAGS( dwFlags ) ||
         ( dwFlags & W3_FLAG_NO_CUSTOM_ERROR ) )
    
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Set the final send just in case we never did a SendResponse (which
    // would normally have set this).
    //
    SetNeedFinalDone();

    if (dwFlags & W3_FLAG_ASYNC)
    {
        SetLastIOPending(LOG_WRITE_IO);
    }

    BOOL fDoLogging = FALSE;
    HRESULT hr;
    if ((dwFlags & W3_FLAG_PAST_END_OF_REQ) &&
        QueryDoUlLogging())
    {
        fDoLogging = TRUE;
        if (FAILED(hr = QueryMainContext()->CollectLoggingData(TRUE)))
        {
            return hr;
        }
    }
    
    //
    // Setup response flags
    //
    
    if ( !( dwFlags & W3_FLAG_PAST_END_OF_REQ ) )
    {
        dwResponseFlags |= W3_RESPONSE_MORE_DATA;
    }
    
    if ( dwFlags & W3_FLAG_ASYNC )
    {
        dwResponseFlags |= W3_RESPONSE_ASYNC;
    }
    
    if ( QueryDisconnect() )
    {
        dwResponseFlags |= W3_RESPONSE_DISCONNECT;
    }

    if ( QueryRequest()->QueryVerbType() == HttpVerbHEAD &&
         ( QueryHandler() == NULL ||
           !QueryHandler()->QueryManagesOwnHead() ) )
    {
        dwResponseFlags |= W3_RESPONSE_SUPPRESS_ENTITY;
    }

    //
    // Do the send now
    //
    DWORD cbSent = 0;
    hr = QueryResponse()->SendEntity(
           this, 
           dwResponseFlags,
           &cbSent,
           fDoLogging ? QueryUlLogData() : NULL);

    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesSent(cbSent);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendEntity failed: no handler, hr %x\n",
                       hr));
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "SendEntity failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

DWORD
W3_CONTEXT::QueryRemainingEntityFromUl(
    VOID
)
/*++

Routine Description:

    Returns how much entity can be read from UL

Arguments:

    None

Return Value:

    Number of bytes available (INFINITE if chunked)

--*/
{
    return QueryMainContext()->QueryRemainingEntityFromUl();
}

VOID
W3_CONTEXT::SetRemainingEntityFromUl(
    DWORD cbRemaining
)
/*++

Routine Description:

    Sets how much entity can be read from UL

Arguments:

    DWORD

Return Value:

    None

--*/
{
    QueryMainContext()->SetRemainingEntityFromUl(cbRemaining);
}
    
VOID
W3_CONTEXT::QueryAlreadyAvailableEntity(
    VOID **                 ppvBuffer,
    DWORD *                 pcbBuffer
)
/*++

Routine Description:

    Returns the already preloaded entity found in the current request

Arguments:

    ppvBuffer - filled with pointer to available entity
    pcbBuffer - filled with size of buffer pointed to by *ppvBuffer

Return Value:

    None 

--*/
{
    W3_REQUEST *            pRequest;
    
    DBG_ASSERT( ppvBuffer != NULL );
    DBG_ASSERT( pcbBuffer != NULL );
    
    pRequest = QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    *ppvBuffer = pRequest->QueryEntityBody();
    *pcbBuffer = pRequest->QueryAvailableBytes();
}

HRESULT
W3_CONTEXT::ReceiveEntity(
    DWORD                   dwFlags,
    VOID *                  pBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pBytesReceived
)
/*++

Routine Description:

    Receives request entity from the client thru ULATQ.  

Arguments:

    dwFlags - W3_FLAG_ASYNC or W3_FLAG_SYNC
    pBuffer - Buffer to contain the data
    cbBuffer - The size of the buffer
    pBytesReceived - Upon return, the number of bytes
                     copied to the buffer

Return Value:

    HRESULT

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    HRESULT                     hr;
    
    if (dwFlags & W3_FLAG_ASYNC)
    {
        SetLastIOPending(LOG_READ_IO);
    }
    
    pMainContext = QueryMainContext();
    DBG_ASSERT( pMainContext != NULL );

    hr = pMainContext->ReceiveEntityBody( !!(dwFlags & W3_FLAG_ASYNC),
                                          pBuffer,
                                          cbBuffer,
                                          pBytesReceived );

    if (!(dwFlags & W3_FLAG_ASYNC))
    {
        IncrementBytesRecvd(*pBytesReceived);
    }

    if (FAILED(hr))
    {
        if (_pHandler == NULL)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReceiveEntity failed: no handler, hr %x\n",
                       hr));
        }
        else if (hr != HRESULT_FROM_WIN32(ERROR_HANDLE_EOF))
        {
            DBGPRINTF((DBG_CONTEXT,
                       "ReceiveEntity failed: handler %S, hr %x\n",
                       _pHandler->QueryName(),
                       hr));
        }
    }

    return hr;
}

HRESULT
W3_CONTEXT::CleanIsapiExecuteUrl(
    HSE_EXEC_URL_INFO * pExecUrlInfo
)
/*++

Routine Description:

    Wrapper for IsapiExecuteUrl() which insured it is called on a clean
    thread (non-coinited).  COM bites

Arguments:

    pExecUrlInfo - HSE_EXEC_URL_INFO

Return Value:

    HRESULT

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    HRESULT                     hr;
    BOOL                        fRet;
    
    if ( pExecUrlInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pExecuteContext = new EXECUTE_CONTEXT( this );
    if ( pExecuteContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = pExecuteContext->InitializeFromExecUrlInfo( pExecUrlInfo );
    if ( FAILED( hr ) )
    {
        delete pExecuteContext;
        return hr;
    }
    
    fRet = ThreadPoolPostCompletion( 0,
                                     W3_CONTEXT::OnCleanIsapiExecuteUrl,
                                     (LPOVERLAPPED) pExecuteContext );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        delete pExecuteContext;
        return hr;
    }

    return NO_ERROR;
}        

HRESULT
W3_CONTEXT::CleanIsapiSendCustomError(
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
)
/*++

Routine Description:

    Wrapper for IsapiSendCustomError() which insured it is called on a clean
    thread (non-coinited).  COM bites

Arguments:

    pCustomErrorInfo - Custom error info

Return Value:

    HRESULT

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    HRESULT                     hr;
    HANDLE                      hEvent = NULL;
    BOOL                        fRet;
    W3_RESPONSE *               pResponse = QueryResponse();
    W3_METADATA *               pMetaData = NULL;
    STACK_STRU(                 strError, 256 );
    BOOL                        fIsFileError;
    HTTP_SUB_ERROR              subError;

    if ( pCustomErrorInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( pResponse != NULL );

    //
    // If we're already sending a custom error, then stop the recursion
    //
    
    if ( !QuerySendCustomError() )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    pResponse->Clear();

    //
    // We don't expect an empty status line here (we expect an error)
    //
    
    if ( pCustomErrorInfo->pszStatus == NULL || 
         pCustomErrorInfo->pszStatus[ 0 ] == '\0' )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Setup the response status/substatus
    //
    
    hr = pResponse->BuildStatusFromIsapi( pCustomErrorInfo->pszStatus );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    subError.mdSubError = pCustomErrorInfo->uHttpSubError;
    subError.dwStringId = 0;
    pResponse->SetSubError( &subError );

    //
    // An error better have been sent
    //

    if ( pResponse->QueryStatusCode() < 400 )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    //
    // Now try to find a custom error for the given response.  If it doesn't
    // exist then we error our
    //

    DBG_ASSERT( QueryUrlContext() != NULL );

    pMetaData = QueryUrlContext()->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    hr = pMetaData->FindCustomError( QueryResponse()->QueryStatusCode(),
                                     subError.mdSubError,
                                     &fIsFileError,
                                     &strError );
    if ( FAILED( hr ) )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }
    
    //
    // Now start executing the custom error
    //
    
    if ( pCustomErrorInfo->fAsync == FALSE )
    {
        hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( hEvent == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    pExecuteContext = new EXECUTE_CONTEXT( this );
    if ( pExecuteContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    pExecuteContext->SetCompleteEvent( hEvent );
    
    //
    // Post the call
    //
    
    fRet = ThreadPoolPostCompletion( 0,
                                     W3_CONTEXT::OnCleanIsapiSendCustomError,
                                     (LPOVERLAPPED) pExecuteContext );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        CloseHandle( hEvent );
        pExecuteContext->SetCompleteEvent( NULL );
        delete pExecuteContext;
        return hr;
    }
    

    if ( pCustomErrorInfo->fAsync == FALSE )
    {
        WaitForSingleObject( hEvent, INFINITE );
        CloseHandle( hEvent );
    }
        
    return NO_ERROR;
}        

HRESULT
W3_CONTEXT::ExecuteHandler(
    DWORD               dwFlags,
    BOOL *              pfDidImmediateFinish
)
/*++

Routine Description:

    Run the context's handler

Arguments:

    dwFlags - W3_FLAG_ASYNC async
              W3_FLAG_SYNC sync 
              W3_FLAG_MORE_DATA caller needs to send data too

    pfDidImmediateFinish - If the caller sets this value (i.e. non NULL) AND
                           the callers asks for async execution, then in the
                           case where the handler executes synchronously, we
                           will set *pfDidImmediateFinish to TRUE and not
                           bother with faking a completion.  This is an 
                           optimization to handle the synchronous ISAPI
                           execution (non-child) case.

Return Value:

    HRESULT

--*/
{
    CONTEXT_STATUS              status;
    W3_HANDLER *                pHandler;
    HTTP_SUB_ERROR              subError;
    HRESULT                     hr;

    if ( pfDidImmediateFinish != NULL )
    {
        *pfDidImmediateFinish = FALSE;
    }
   
    //
    // If this is synchronous execution, then setup an event to signal
    // upon the handler completion
    //
    
    if ( dwFlags & W3_FLAG_SYNC )
    {
        SetupCompletionEvent(); 
    }
    
    //
    // Clear any response lingering
    //
    
    hr = QueryResponse()->Clear();
    if ( FAILED( hr ) )
    {
        return hr;
    }
  
    //
    // Redirect all completions to the current context (this)
    //
    
    QueryMainContext()->PushCurrentContext( this );
   
    //
    // Execute the handler
    //

    status = ExecuteCurrentHandler();

    if ( status == CONTEXT_STATUS_CONTINUE )
    {
        //
        // Remember not to execute completion routine for handler
        //
        
        DBG_ASSERT( _pHandler != NULL );

        //
        // We don't need the handler any more
        //
        
        delete _pHandler;
        _pHandler = NULL;

        //
        // The handler completed synchronously.  If async call was required
        // then post a fake completion, unless the caller set
        // pfDidImmediateFinish in which case we'll finish now and set the
        // flag to TRUE
        //
        
        if ( dwFlags & W3_FLAG_ASYNC &&
             pfDidImmediateFinish == NULL )
        {
            if ( ThreadPoolPostCompletion( 0,
                                           W3_MAIN_CONTEXT::OnPostedCompletion,
                                           (LPOVERLAPPED) QueryMainContext() ) )
            {
                return NO_ERROR;
            }         
            
            DBG_ASSERT( FALSE );
        }
        else
        {
            //
            // We indicate the "success/failure" of this child context
            // to the parent context, so that the parent can send this
            // info to ISAPIs if needed
            //
            
            if ( QueryParentContext() != NULL )
            {
                QueryResponse()->QuerySubError( &subError );

                QueryParentContext()->SetChildStatusAndError(
                                         QueryResponse()->QueryStatusCode(),
                                         subError.mdSubError,
                                         QueryErrorStatus() );
            }
            
            //
            // Don't both signalling completion event since there is nothing
            // to wait for.  (Might revisit this decision later)
            //
            
            //
            // Current context is no longer needed in completion stack
            //
            
            QueryMainContext()->PopCurrentContext();
            
            //
            // If caller wanted status, tell them now
            //
            
            if ( pfDidImmediateFinish != NULL )
            {
                *pfDidImmediateFinish = TRUE;
            }
        }
    }
    else 
    {   
        DBG_ASSERT( status == CONTEXT_STATUS_PENDING );
        
        //
        // The handler will complete asynchronsouly.  But we are asked for
        // synchronous execution.  So wait here until complete
        //
        
        if ( dwFlags & W3_FLAG_SYNC )
        {
            WaitForCompletion();
        }
    }
    
    return NO_ERROR;
}

CONTEXT_STATUS
W3_CONTEXT::ExecuteCurrentHandler(
    VOID
)
/*++

Routine Description:

    Execute the handler for this context

Arguments:

    None

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    HRESULT                     hr;
    
    DBG_ASSERT( _pHandler != NULL );

    //
    // Now check if we should be doing redirection for this request
    //
    if (QueryRequest()->QueryVerbType() != HttpVerbTRACE &&
        QueryRequest()->QueryVerbType() != HttpVerbTRACK)
    {
        BOOL fRedirected = FALSE;
        if (FAILED(DoUrlRedirection(&fRedirected)) ||
            fRedirected)
        {
            return CONTEXT_STATUS_CONTINUE;
        }
    }
    
    //
    // Access is allowed and no URL redirection.  Let'r rip!
    //
    
    return _pHandler->MainDoWork();
}

CONTEXT_STATUS
W3_CONTEXT::ExecuteHandlerCompletion(
    DWORD               cbCompletion,
    DWORD               dwCompletionStatus
)
/*++

Routine Description:

    Execute the current handler's completion.

Arguments:

    cbCompletion - Completion bytes
    dwCompletionStatus - Completion error

Return Value:

    CONTEXT_STATUS_PENDING if async pending, else CONTEXT_STATUS_CONTINUE

--*/
{
    CONTEXT_STATUS          status;
    W3_HANDLER *            pHandler;
    W3_CONTEXT *            pParentContext;
    DWORD                   dwChildStatus;
    BOOL                    fAccessAllowed = FALSE;
    HRESULT                 hr;
    HTTP_SUB_ERROR          subError;
    
    //
    // This is a completion for the handler.
    //
    // If this is a faked completion, the handler is already cleaned up
    //
        
    if ( _pHandler != NULL )
    {    
        status = _pHandler->MainOnCompletion( cbCompletion,
                                              dwCompletionStatus );
        
    }
    else
    {
        status = CONTEXT_STATUS_CONTINUE;
    }
    
    if ( status == CONTEXT_STATUS_PENDING )
    {
        return status;
    }
    else
    { 
        //
        // Cleanup the current context if necessary
        //
        
        DBG_ASSERT( status == CONTEXT_STATUS_CONTINUE );

        //
        // Current handler execute is complete.  Delete it
        //
        
        if ( _pHandler != NULL )
        {
            delete _pHandler;
            _pHandler = NULL;
        }

        //
        // The current handler is complete.  But if this is a child 
        // request we must first indicate handler completion to the caller
        //
        
        pParentContext = QueryParentContext();
        if ( pParentContext != NULL )
        {   
            //
            // We indicate the "success/failure" of this child context
            // to the parent context, so that the parent can send this
            // info to ISAPIs if needed
            //
                
            QueryResponse()->QuerySubError( &subError );

            pParentContext->SetChildStatusAndError(
                                     QueryResponse()->QueryStatusCode(),
                                     subError.mdSubError,
                                     QueryErrorStatus() );
        
            //
            // Setup all future completions to indicate to parent
            //
            
            QueryMainContext()->PopCurrentContext();
            
            //
            // We are a child execute
            //
            
            if ( QueryIsSynchronous() )
            {
                IndicateCompletion();
                
                //
                // We assume the thread waiting on completion will be
                // responsible for advancing the state machine
                //
                
                //
                // The waiting thread will also cleanup the child context
                //
                
                return CONTEXT_STATUS_PENDING;
            }
            else
            {
                dwChildStatus = WIN32_FROM_HRESULT( QueryErrorStatus() );

                //
                // We can destroy the current context now.  In the case of
                // synchronous execution, it is the caller that cleans up
                // the new context
                //
                
                delete this;
                    
                return pParentContext->ExecuteHandlerCompletion( 
                                0,
                                dwChildStatus );
            }
        }
        
        return CONTEXT_STATUS_CONTINUE;
    }
}

W3_CONTEXT::W3_CONTEXT( DWORD dwExecFlags )
    : _pHandler                  ( NULL ),
      _hCompletion               ( NULL ),
      _errorStatus               ( S_OK ),
      _pCustomErrorFile          ( NULL ),
      _dwExecFlags               ( dwExecFlags ),
      _accessState               ( ACCESS_STATE_START ),
      _fDNSRequiredForAccess     ( FALSE ),
      _fAuthAccessCheckRequired  ( TRUE ), 
      _childStatusCode           ( 200 ),
      _childSubErrorCode         ( 0 ),
      _childError                ( S_OK )
{
    _dwSignature = W3_CONTEXT_SIGNATURE;
}

W3_CONTEXT::~W3_CONTEXT()
{
    _dwSignature = W3_CONTEXT_SIGNATURE_FREE;
    
    if ( _pHandler != NULL )
    {
        delete _pHandler;
        _pHandler = NULL;
    }
    
    if ( _hCompletion != NULL )
    {
        CloseHandle( _hCompletion );
        _hCompletion = NULL;
    }
    
    if ( _pCustomErrorFile != NULL )
    {
        _pCustomErrorFile->DereferenceCacheEntry();
        _pCustomErrorFile = NULL;
    }
}

// static
HRESULT
W3_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for W3_CONTEXTs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    HKEY                hKey = NULL;
    DWORD               dwError;
    DWORD               dwType;
    DWORD               cbBuffer;
    BYTE                bUnused;
    
    //
    // Read in the 302 message once
    //
    
    DBG_ASSERT( g_pW3Server != NULL );

    sm_cbRedirectMessage = sizeof( sm_achRedirectMessage );

    hr = g_pW3Server->LoadString( IDS_URL_MOVED,
                                  sm_achRedirectMessage,
                                  &sm_cbRedirectMessage );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( sm_cbRedirectMessage > 0 );

    //
    // Read the Access-Denied message from registry
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            W3_PARAMETERS_KEY,
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        cbBuffer = 0;
        dwType = 0;
        
        dwError = RegQueryValueExA( hKey,
                                    "AccessDeniedMessage",
                                    NULL,
                                    &dwType,
                                    &bUnused,
                                    &cbBuffer );

        if ( dwError == ERROR_MORE_DATA && dwType == REG_SZ )
        {
            DBG_ASSERT( cbBuffer > 0 );
            
            sm_pszAccessDeniedMessage = (CHAR*) LocalAlloc( LPTR, cbBuffer );
            if ( sm_pszAccessDeniedMessage == NULL )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            dwError = RegQueryValueExA( hKey,
                                        "AccessDeniedMessage",
                                        NULL,
                                        NULL,
                                        (LPBYTE) sm_pszAccessDeniedMessage,
                                        &cbBuffer );
                
            if ( dwError != ERROR_SUCCESS )
            {
                DBG_ASSERT( FALSE );
                
                LocalFree( sm_pszAccessDeniedMessage );
                sm_pszAccessDeniedMessage = NULL;
            }
        }
    }    
                                  
    //
    // Setup child contexts
    //
    
    hr = W3_CHILD_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Setup main contexts
    //
    
    hr = W3_MAIN_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        W3_CHILD_CONTEXT::Terminate();
        return hr;
    }
    
    //
    // Setup execute contexts
    //
    
    hr = EXECUTE_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        W3_MAIN_CONTEXT::Terminate();
        W3_CHILD_CONTEXT::Terminate();
        return hr;
    }
   
    return NO_ERROR;
}

// static
VOID
W3_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate W3_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    EXECUTE_CONTEXT::Terminate();
    
    W3_CHILD_CONTEXT::Terminate();

    W3_MAIN_CONTEXT::Terminate();    
    
    if ( sm_pszAccessDeniedMessage != NULL )
    {
        LocalFree( sm_pszAccessDeniedMessage );
        sm_pszAccessDeniedMessage = NULL;
    }
}

//static
VOID
W3_CONTEXT::OnCleanIsapiExecuteUrl(
    DWORD                   dwCompletionStatus,
    DWORD                   cbWritten,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    Actually calls ExecuteHandler() on behalf of a thread which may have
    already been CoInited().  The thread this this guy runs on should not 
    have been (COM sucks)

Arguments:

    dwCompletionStatus - Completion status (ignored)
    cbWritten - Bytes written (ignored)
    lpo - Pointer to EXECUTE_CONTEXT which contains info needed for
          ExecuteHandler() call

Return Value:

    None

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    W3_CONTEXT *                pW3Context;
    HRESULT                     hr;
    
    DBG_ASSERT( lpo != NULL );
    
    pExecuteContext = (EXECUTE_CONTEXT*) lpo;
    DBG_ASSERT( pExecuteContext->CheckSignature() );
   
    pW3Context = pExecuteContext->QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pW3Context->CheckSignature() );
    
    //
    // Make the call (this is an async call)
    //
    
    hr = pW3Context->IsapiExecuteUrl( pExecuteContext->QueryExecUrlInfo() );
    
    delete pExecuteContext;
    
    if ( FAILED( hr ) )
    {
        //
        // We failed before posting async operation.  It is up to us to
        // fake a completion
        //
       
        DBG_ASSERT( pW3Context->QueryHandler() != NULL );

        pW3Context->SetErrorStatus( hr );
        
        pW3Context->QueryHandler()->MainOnCompletion( 0, 
                                                      WIN32_FROM_HRESULT( hr ) );
    }
}

//static
VOID
W3_CONTEXT::OnCleanIsapiSendCustomError(
    DWORD                   dwCompletionStatus,
    DWORD                   cbWritten,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    Actually calls ExecuteHandler() on behalf of a thread which may have
    already been CoInited().  The thread this this guy runs on should not 
    have been (COM sucks)

Arguments:

    dwCompletionStatus - Completion status (ignored)
    cbWritten - Bytes written (ignored)
    lpo - Pointer to SEND_CUSTOM_ERROR_CONTEXT which contains info needed for
          ExecuteHandler() call

Return Value:

    None

--*/
{
    EXECUTE_CONTEXT *           pExecuteContext;
    W3_CONTEXT *                pW3Context;
    HRESULT                     hr;
    BOOL                        fAsync;
    
    DBG_ASSERT( lpo != NULL );
    
    pExecuteContext = (EXECUTE_CONTEXT*) lpo;
    DBG_ASSERT( pExecuteContext->CheckSignature() );
   
    pW3Context = pExecuteContext->QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    DBG_ASSERT( pW3Context->CheckSignature() );

    fAsync = pExecuteContext->QueryCompleteEvent() == NULL;

    hr = pW3Context->SendResponse( fAsync ? W3_FLAG_ASYNC : W3_FLAG_SYNC );
    
    delete pExecuteContext;
    
    if ( FAILED( hr ) )
    {
        if ( fAsync )
        {
            //
            // We failed before posting async operation.  It is up to us to
            // fake a completion
            //
       
            DBG_ASSERT( pW3Context->QueryHandler() != NULL );

            pW3Context->SetErrorStatus( hr );
        
            pW3Context->QueryHandler()->MainOnCompletion( 0, 
                                                          WIN32_FROM_HRESULT( hr ) );
        }
    }
}

CHUNK_BUFFER *
W3_CONTEXT::QueryHeaderBuffer(
    VOID
)
/*++

Routine Description:

    Get header buffer to store data which must be around until 
    request is finished

Arguments:

    None

Return Value:

    CHUNK_BUFFER pointer

--*/
{
    DBG_ASSERT( QueryMainContext() != NULL );
    return QueryMainContext()->QueryHeaderBuffer();
}

CONTEXT_STATUS
W3_CONTEXT::CheckAccess(
    BOOL                    fCompletion,
    DWORD                   dwCompletionStatus,
    BOOL *                  pfAccessAllowed
)
/*++

Routine Description:

    Check whether the given request is allowed for the current metadata
    settings.  In particular check:
    1) Is SSL required?
    2) Are IP address restrictions in force?
    3) Is a client certificate required?
    4) Is the authentication mechanism allowed?  Optionally

    If access is not allowed, then this routine will send the appropriate
    response asychronously

Arguments:

    fCompletion - Are we being called on a completion (i.e. 
                  is this a subsequent call to CheckAccess())
    dwCompletionStatus - Completion status (if fCompletion is TRUE)
    pfAccessAllowed - Set to TRUE if access is allowed, else FALSE

Return Value:

    CONTEXT_STATUS_PENDING if we're not finished the check yet
    CONTEXT_STATUS_CONTINUE if we are finished.

--*/
{
    W3_METADATA *               pMetaData;
    URL_CONTEXT *               pUrlContext;
    HTTP_SSL_INFO *             pSslInfo;
    HTTP_SSL_CLIENT_CERT_INFO * pClientCertInfo = NULL;
    DWORD                       dwAccessPerms;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fAccessAllowed = TRUE;
    ADDRESS_CHECK *             pAddressCheck = NULL;
    AC_RESULT                   acResult;
    BOOL                        fSyncDNS = FALSE;
    LPSTR                       pszTemp;
    sockaddr_in                 remoteAddress;
    BOOL                        fDoCertMap;
    
    if ( pfAccessAllowed == NULL )
    {
        DBG_ASSERT( FALSE );
        SetErrorStatus( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) );
        return CONTEXT_STATUS_CONTINUE;
    }
    *pfAccessAllowed = FALSE;

    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );
    
    dwAccessPerms = pMetaData->QueryAccessPerms();

    switch ( _accessState )
    {
    case ACCESS_STATE_SENDING_ERROR:

        //
        // We have sent an error.  Just chill
        //
        
        fAccessAllowed = FALSE;
        break;
        
    case ACCESS_STATE_START:

        //
        // Is SSL required?
        //
    
        if ( dwAccessPerms & VROOT_MASK_SSL && 
             !QueryRequest()->IsSecureRequest() )
        {
            QueryResponse()->SetStatus( HttpStatusForbidden,
                                        Http403SSLRequired );
            goto AccessDenied;
        }

        //
        // Is 128bit required?
        // 
        
        if ( dwAccessPerms & VROOT_MASK_SSL128 )
        {
            pSslInfo = QueryRequest()->QuerySslInfo();
            
            if ( pSslInfo == NULL ||
                 pSslInfo->ConnectionKeySize < 128 )
            {
                QueryResponse()->SetStatus( HttpStatusForbidden,
                                            Http403SSL128Required );
                goto AccessDenied;
            } 
        }
        
              
        //
        // Fall through to next phase in access check
        //
    
    case ACCESS_STATE_CLIENT_CERT:    

        _accessState = ACCESS_STATE_CLIENT_CERT;

        //
        // Is a client certificate possible?  First check is we even allow
        // a client cert to be negotiated and that this is a secure request
        //
    
        if ( dwAccessPerms & VROOT_MASK_NEGO_CERT &&
             QueryRequest()->IsSecureRequest() )
        {
            //
            // Try for a client cert if we don't already have one associated
            // with the request
            //
            
            if ( QueryCertificateContext() == NULL )
            {
                if ( fCompletion )
                {
                    fCompletion = FALSE;
                    
                    //
                    // If we got an error, that's OK.  We will fall thru
                    // and check whether we actually need a client cert
                    //
                    
                    if ( dwCompletionStatus == NO_ERROR )
                    {
                        //
                        // Are we cert mapping?
                        // 
                        
                        fDoCertMap = !!(dwAccessPerms & VROOT_MASK_MAP_CERT);
                        
                        //
                        // All is well.  Make a synchronous call to get
                        // the certificate
                        //
                        
                        hr = UlAtqReceiveClientCertificate(
                                            QueryUlatqContext(),
                                            FALSE,              // sync
                                            fDoCertMap,
                                            &pClientCertInfo );
                        if ( FAILED( hr ) )
                        {
                            QueryResponse()->SetStatus( HttpStatusServerError );
                            goto AccessDenied;
                        }
                        
                        DBG_ASSERT( pClientCertInfo != NULL );

                        //
                        // Setup a client cert context for this request
                        //

                        hr = QueryMainContext()->SetupCertificateContext( pClientCertInfo );
                        if ( FAILED( hr ) )
                        {
                            QueryResponse()->SetStatus( HttpStatusServerError );
                            goto AccessDenied;
                        }

                        //
                        // Just because we got a client cert, doesn't mean
                        // it is acceptable.  It might be revoked, time
                        // expired, etc.  The policy of what to do when
                        // certs are non-totally-valid is metabase driven.
                        // (in case you are wondering why the stream filter
                        // doesn't do these checks and just fail the 
                        // renegotiation)
                        //

                        if ( !CheckClientCertificateAccess() )
                        {
                            goto AccessDenied;
                        }
                    }
                }
                else
                {
                    //
                    // Are we cert mapping?
                    // 
                        
                    fDoCertMap = !!(dwAccessPerms & VROOT_MASK_MAP_CERT);
                        
                    //
                    // First time asking for a client cert.  Do it 
                    // async
                    //
                    
                    fCompletion = FALSE;
                    
                    hr = UlAtqReceiveClientCertificate( 
                                            QueryUlatqContext(),
                                            TRUE,               // async
                                            fDoCertMap,
                                            &pClientCertInfo );
                    if ( FAILED( hr ) )
                    {
                        QueryResponse()->SetStatus( HttpStatusServerError );
                        goto AccessDenied;
                    }
                
                    return CONTEXT_STATUS_PENDING;
                }
            }
        }
        
        //
        // Ok.  We're done the certificate crud.  If we needed a client 
        // cert and didn't get it, then setup 403.7
        //
        
        if ( dwAccessPerms & VROOT_MASK_NEGO_MANDATORY &&
             QueryCertificateContext() == NULL )
        {
            QueryResponse()->SetStatus( HttpStatusForbidden,
                                        Http403CertRequired );
            goto AccessDenied;
        }
        
        //
        // Fall through to next phase in access check
        //
        
    case ACCESS_STATE_RDNS:

        _accessState = ACCESS_STATE_RDNS;

        pAddressCheck = QueryMainContext()->QueryAddressCheck();
        DBG_ASSERT( pAddressCheck != NULL );

        if ( !fCompletion )
        {
            if ( pMetaData->QueryIpAccessCheckSize() != 0 ||
                 pMetaData->QueryDoReverseDNS() )
            {
                //
                // Setup the RDNS crud (joy)
                //
    
                remoteAddress.sin_family = AF_INET;
                remoteAddress.sin_port = QueryRequest()->QueryRemotePort();
                remoteAddress.sin_addr.s_addr = ntohl( QueryRequest()->QueryRemoteAddress() );
                ZeroMemory( remoteAddress.sin_zero, sizeof( remoteAddress.sin_zero ) ); 
        
                pAddressCheck->BindAddr( (sockaddr*) &remoteAddress );
            }

            //
            // Ok.  If there is an access check set in metabase, then
            // do the check.
            //
            
            if ( pMetaData->QueryIpAccessCheckSize() != 0 )
            {
                //
                // Set the metadata IP blob
                //

                pAddressCheck->BindCheckList( 
                                    pMetaData->QueryIpAccessCheckBuffer(),
                                    pMetaData->QueryIpAccessCheckSize() );
            
                //
                // Check access
                //

                acResult = pAddressCheck->CheckIpAccess( &_fDNSRequiredForAccess );

                if ( !_fDNSRequiredForAccess )
                {
                    pAddressCheck->UnbindCheckList();
                }
            }
            else
            {
                //
                // Fake a valid access check since there was no checks
                // configured in metabase
                //
                
                acResult = AC_NO_LIST;
            }
            
            //
            // Check if we now know our access status now
            //
            
            if ( acResult == AC_IN_DENY_LIST ||
                 ( acResult == AC_NOT_IN_GRANT_LIST && 
                   !_fDNSRequiredForAccess ) )
            {
                //
                // We know we're rejected
                //
                
                QueryResponse()->SetStatus( HttpStatusForbidden,
                                            Http403IPAddressReject );
                goto AccessDenied;
            }
            
            //
            // Do we need to do a DNS check to determine access?
            // Do we need to do DNS check for logging/servervar purposes?
            //
            // In either case, we will do an async DNS check
            //
            
            if ( _fDNSRequiredForAccess ||
                 pMetaData->QueryDoReverseDNS() )
            {
                fSyncDNS = TRUE;
                
                if ( !pAddressCheck->QueryDnsName( &fSyncDNS,
                                                   W3_MAIN_CONTEXT::AddressResolutionCallback,
                                                   QueryMainContext(),
                                                   &pszTemp ) )
                {
                    //
                    // Only error if DNS was required for access check
                    // purposes
                    //
                    
                    if ( _fDNSRequiredForAccess )
                    {
                        QueryResponse()->SetStatus( HttpStatusForbidden,
                                                    Http403IPAddressReject );
                        goto AccessDenied;
                    }
                }
                
                if ( fSyncDNS )
                {
                    //
                    // Fake a completion if needed.  This just prevents us from
                    // posting one more time to the thread pool
                    //
                
                    fCompletion = TRUE;
                }
                else
                {
                    return CONTEXT_STATUS_PENDING;
                }
            }
        }

        if ( fCompletion )
        {
            fCompletion = FALSE;
            
            //
            // This is the completion for DNS check
            //
            
            if ( _fDNSRequiredForAccess )
            {
                _fDNSRequiredForAccess = FALSE;
                
                acResult = pAddressCheck->CheckDnsAccess();

                pAddressCheck->UnbindCheckList();
                
                if ( acResult == AC_NOT_CHECKED ||
                     acResult == AC_IN_DENY_LIST ||
                     acResult == AC_NOT_IN_GRANT_LIST )
                {
                    QueryResponse()->SetStatus( HttpStatusForbidden,
                                                Http403IPAddressReject );
                    goto AccessDenied;
                }
            }
        }
        //
        // Fall through to next phase in access check
        //

    case ACCESS_STATE_AUTHENTICATION:    

        //
        // Is the authentication method valid?  We may not have a user
        // context available at this point if this was an early 
        // custom error URL invocation
        //
        
        _accessState = ACCESS_STATE_AUTHENTICATION;
        
        if ( QueryAuthAccessCheckRequired() &&
             QueryUserContext() != NULL )
        {
            if ( !( pMetaData->QueryAuthentication() & 
                    QueryUserContext()->QueryAuthType() ) )
            {
                QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                            Http401Config );
                goto AccessDenied;
            }
        }

    }

    //
    // We know the access status (allowed or denied)
    //
    
    _accessState = ACCESS_STATE_DONE;
    *pfAccessAllowed = fAccessAllowed;
    return CONTEXT_STATUS_CONTINUE;

AccessDenied:
    *pfAccessAllowed = FALSE;
    _accessState = ACCESS_STATE_SENDING_ERROR;

    //
    // Send back the bad access response
    //

    hr = SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        _accessState = ACCESS_STATE_DONE;
        return CONTEXT_STATUS_CONTINUE;
    }    
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}

CERTIFICATE_CONTEXT *
W3_CONTEXT::QueryCertificateContext(
    VOID
)
/*++

Routine Description:

    Get client cert info object.  We get it from the main context

Arguments:

    None

Return Value:

    Pointer to client cert object

--*/
{
    return QueryMainContext()->QueryCertificateContext();
}
    
BOOL
W3_CONTEXT::CheckClientCertificateAccess(
    VOID
)
/*++

Routine Description:

    Check the context's certificate for validity 

Arguments:

    None

Return Value:

    TRUE if the cert is valid, else FALSE

--*/
{
    W3_MAIN_CONTEXT *           pMainContext;
    CERTIFICATE_CONTEXT *       pCertificateContext;
    DWORD                       dwCertFlags;
    
    pMainContext = QueryMainContext();
    DBG_ASSERT( pMainContext != NULL );
    
    pCertificateContext = pMainContext->QueryCertificateContext();
    if ( pCertificateContext == NULL )
    {
        return FALSE;
    }
    
    dwCertFlags = pCertificateContext->QueryFlags();
        
    if ( dwCertFlags & CERT_TRUST_IS_UNTRUSTED_ROOT ||
         dwCertFlags & CERT_TRUST_IS_NOT_SIGNATURE_VALID ||
         dwCertFlags & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ||
         dwCertFlags & CERT_TRUST_IS_NOT_VALID_FOR_USAGE )
    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertInvalid ); 
        return FALSE;
    }
    else if ( dwCertFlags & CERT_TRUST_IS_NOT_TIME_VALID ||
              dwCertFlags & CERT_TRUST_CTL_IS_NOT_TIME_VALID )
    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertTimeInvalid );
        return FALSE;
    }
    else if ( dwCertFlags & CERT_TRUST_IS_REVOKED )
    {
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertRevoked );
        return FALSE;
    }
    else if ( dwCertFlags != 0 )
    {
        //
        // this case is to prevent new error flags added by CAPI to be ignored by IIS
        // if there is a flag IIS doesn't explicitly recognize, let's return Http403CertInvalid
        //
        
        QueryResponse()->SetStatus( HttpStatusForbidden,
                                    Http403CertInvalid ); 
        return FALSE;
    }
    
    return TRUE;
}

HRESULT
W3_CONTEXT::CheckPathInfoExists(
    W3_HANDLER **               ppHandler
)
/*++

Routine Description:

    Utility to check whether path info exists.  If it does exist, this 
    function succeeds without setting the handler.  
    
    If the file doesn't exist, this function succeeds but sets a general
    handler to send the error
    
Arguments:

    ppHandler - Set to handler

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    W3_FILE_INFO *      pOpenFile = NULL;
    W3_HANDLER *        pHandler = NULL;
    URL_CONTEXT *       pUrlContext;
    FILE_CACHE_USER     fileUser;

    if ( ppHandler == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppHandler = NULL;
    
    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    QueryFileCacheUser( &fileUser );
    
    hr = pUrlContext->OpenFile( &fileUser, &pOpenFile );
    if ( FAILED( hr ) )
    {
        DBG_ASSERT( pOpenFile == NULL );
                    
        switch ( WIN32_FROM_HRESULT( hr ) )
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusNotFound );
            break;
                
        case ERROR_INVALID_PARAMETER:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusUrlTooLong );
            break;
                        
        case ERROR_ACCESS_DENIED:
        case ERROR_ACCOUNT_DISABLED:
        case ERROR_LOGON_FAILURE:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusUnauthorized,
                                               Http401Application );
            break;
                    
        default:
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusServerError );
            break;
        }
                    
        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
        else
        {
            hr = NO_ERROR;
        }
    }
    else
    {
        DBG_ASSERT( pOpenFile != NULL );
        
        pOpenFile->DereferenceCacheEntry();
    }
    
    *ppHandler = pHandler;
    return hr;
}

HRESULT
W3_CONTEXT::DetermineHandler(
    BOOL                    fEnableWildcardMapping
)
/*++

Routine Description:

    Determine the handler for a given request, and setup it.

    How to determine handler is driven by the Magic Flow Chart (TM)

Arguments:
    
    fEnableWildcardMapping - Enable wildcard mapping
    
Return Value:

    HRESULT

--*/
{
    W3_REQUEST *                pRequest;
    URL_CONTEXT *               pUrlContext;
    W3_METADATA *               pMetaData;
    HRESULT                     hr = NO_ERROR;
    W3_HANDLER *                pHandler = NULL;
    META_SCRIPT_MAP_ENTRY *     pScriptMapEntry = NULL;
    STACK_STRA(                 strHeaderValue, 10 );
    STACK_STRA(                 strVerb, 10 );
    HTTP_VERB                   VerbType;
    BOOL                        fKnownVerb = FALSE;
    DWORD                       dwFilePerms;
    GATEWAY_TYPE                GatewayType;
    BOOL                        fAccessAllowed = FALSE;
    BOOL                        fSuspectUrl = FALSE;
    CHAR *                      szHeaderValue =  NULL;

    //
    // We shouldn't have a handler set for this request
    //
    
    DBG_ASSERT( _pHandler == NULL );
    
    pRequest = QueryRequest();
    DBG_ASSERT( pRequest != NULL );
    
    pUrlContext = QueryUrlContext();
    DBG_ASSERT( pUrlContext != NULL );
    
    pMetaData = pUrlContext->QueryMetaData();
    DBG_ASSERT( pMetaData != NULL );

    //
    // First check for a * script map.  If one exists, use it if allowed
    //

    VerbType = pRequest->QueryVerbType();

    if ( VerbType == HttpVerbTRACE || 
         VerbType == HttpVerbTRACK )
    {
        pHandler = new W3_TRACE_HANDLER( this );

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        goto Finished;
    }

    pScriptMapEntry = pMetaData->QueryScriptMap()->QueryStarScriptMap();
    if ( pScriptMapEntry != NULL &&
         fEnableWildcardMapping )
    {
        //
        // If there is a ./ in the URL, then always check for existence.  This
        // prevents a trailing . metabase equivilency problem
        //
        
        fSuspectUrl = pRequest->IsSuspectUrl();
        
        if ( pScriptMapEntry->QueryCheckPathInfoExists() ||
             fSuspectUrl )
        {
            hr = CheckPathInfoExists( &pHandler );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
                
            if ( pHandler != NULL )
            {
                //
                // We already have an error handler for this request.
                // That means path info didn't really exist
                //
                    
                goto Finished;
            }
        }
        
        //
        // Create the appropriate handler for the script mapping
        //
        
        if ( pScriptMapEntry->QueryGateway() == GATEWAY_CGI )
        {
            pHandler = new W3_CGI_HANDLER( this, pScriptMapEntry );
        }
        else
        {
            DBG_ASSERT( pScriptMapEntry->QueryGateway() == GATEWAY_ISAPI );
            pHandler = new W3_ISAPI_HANDLER( this, pScriptMapEntry );
        }
        
        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        
        goto Finished;
    }
    
    //
    // Check for Translate: f
    //
    // If there, it goes to DAVFS unless DAV is disabled
    //

    if (!pMetaData->QueryIsDavDisabled())
    {
        szHeaderValue = pRequest->GetHeader( HttpHeaderTranslate );
        if ( szHeaderValue &&
             toupper( szHeaderValue[ 0 ] ) == 'F' &&
             szHeaderValue[ 1 ] == '\0' &&
             !pMetaData->QueryIgnoreTranslate() ) 
        {
            //
            // This is a DAV request
            //

            pHandler = new W3_DAV_HANDLER( this );

            if ( pHandler == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            goto Finished;
        }
    }
    
    //
    // Does this request map to an extension
    //
    // Map can mean one of two things
    // a) A script map (as in MD_SCRIPT_MAP)
    // b) An explicit .DLL/.EXE/.COM/etc.
    // 
    
    pScriptMapEntry = pUrlContext->QueryUrlInfo()->QueryScriptMapEntry();
    if ( pScriptMapEntry != NULL ||
         pUrlContext->QueryUrlInfo()->QueryGateway() == GATEWAY_ISAPI ||
         pUrlContext->QueryUrlInfo()->QueryGateway() == GATEWAY_CGI )
    {
        dwFilePerms = pMetaData->QueryAccessPerms(); 
       
        if ( pScriptMapEntry != NULL )
        {
            GatewayType = pScriptMapEntry->QueryGateway();

            //
            // We have a script map.  Check access rights
            //
            
            if ( pScriptMapEntry->QueryAllowScriptAccess() && 
                 IS_ACCESS_ALLOWED( pRequest, dwFilePerms, SCRIPT ) )
            {
                fAccessAllowed = TRUE;
            }
            
            if ( !fAccessAllowed &&
                 IS_ACCESS_ALLOWED( pRequest, dwFilePerms, EXECUTE ) )
            {
                fAccessAllowed = TRUE;
            }
            
            if ( !fAccessAllowed )
            {
                pHandler = new W3_GENERAL_HANDLER( this,
                                                   HttpStatusForbidden,
                                                   Http403ExecAccessDenied );
                if ( pHandler == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                goto Finished;
            }

            //
            // If there is a ./ in the URL, then always check for existence.  This
            // prevents a trailing . metabase equivilency problem
            //
        
            fSuspectUrl = pRequest->IsSuspectUrl();
            
            //
            // Should we verify that path info does exist?
            //
            
            if ( pScriptMapEntry->QueryCheckPathInfoExists() ||
                 fSuspectUrl )
            {
                hr = CheckPathInfoExists( &pHandler );
                if ( FAILED( hr ) )
                {
                    goto Finished;
                }
                
                if ( pHandler != NULL )
                {
                    //
                    // We already have an error handler for this request.
                    // That means path info didn't really exist
                    //
                    
                    goto Finished;
                }
            }
            
            //
            // Does the script map support the verb?
            //
        
            hr = pRequest->GetVerbString( &strVerb );
            if ( FAILED( hr ) )
            {
                goto Finished;
            }
        
            if ( !pScriptMapEntry->IsVerbAllowed( strVerb ) )
            {   
                pHandler = new W3_GENERAL_HANDLER( this,
                                                   HttpStatusForbidden,
                                                   Http403ExecAccessDenied );
                if ( pHandler == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }
                goto Finished;
            }
        }
        else
        {
            GatewayType = pUrlContext->QueryUrlInfo()->QueryGateway();
        }
        
        //
        // OK.  If we got to here, we can setup an executable handler
        //
        
        if ( GatewayType == GATEWAY_CGI )
        {
            pHandler = new W3_CGI_HANDLER( this, pScriptMapEntry );
        }
        else
        {
            DBG_ASSERT( GatewayType == GATEWAY_ISAPI );
            pHandler = new W3_ISAPI_HANDLER( this, pScriptMapEntry );
        }
        
        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }

        goto Finished;
    }
    
    //
    // Ok.  No script map applied.  Is this an unknown verb?
    // (i.e. not GET, HEAD, POST, TRACE, TRACK)
    //
    
    if ( VerbType == HttpVerbGET ||
         VerbType == HttpVerbPOST ||
         VerbType == HttpVerbHEAD )
    {
        fKnownVerb = TRUE;
    }
    else
    {
        fKnownVerb = FALSE;
    }
    
    //
    // If this verb is unknown, then it goes to DAV
    //
    
    if ( fKnownVerb == FALSE )
    {
        if (!pMetaData->QueryIsDavDisabled())
        {
            pHandler = new W3_DAV_HANDLER( this );
        }
        else if ( VerbType == HttpVerbOPTIONS )
        {
            //
            // We handle OPTIONS if DAV is disabled
            //
            pHandler = new W3_OPTIONS_HANDLER( this );
        }
        else
        {
            pHandler = new W3_GENERAL_HANDLER( this,
                                               HttpStatusNotImplemented );
        }

        if ( pHandler == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        
        goto Finished;
    }

    //
    // If there are special DAV verbs like If: and Lock-Token:, then it also
    // go to DAV unless it is disabled
    //

    if (!pMetaData->QueryIsDavDisabled())
    {
        if ( SUCCEEDED( pRequest->GetHeader( "If",
                                             2,
                                             &strHeaderValue,
                                             TRUE ) ) ||
             SUCCEEDED( pRequest->GetHeader( "Lock-Token",
                                             10,
                                             &strHeaderValue,
                                             TRUE ) ) )
        {
            pHandler = new W3_DAV_HANDLER( this );

            if ( pHandler == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            goto Finished;
        }
    }
    
    //
    // OK.  Exchange/DAV-providers have had their chance.  Now its our turn!
    //
    
    //
    // Call the static file handler
    //

    pHandler = new W3_STATIC_FILE_HANDLER( this );
    
    if ( pHandler == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Finished;
    }
    
Finished:
    if ( FAILED( hr ) )
    {
        DBG_ASSERT( pHandler == NULL );
    }

    _pHandler = pHandler;

    return hr;
}

HRESULT
W3_CONTEXT::SetupHttpRedirect(
    STRA &              strPath,
    BOOL                fIncludeParameters,
    HTTP_STATUS &       httpStatus
)
/*++

Routine Description:

    Do an HTTP redirect (301 or 302)

Arguments:

    strPath - New path component of destination
    fIncludeParameters - Include query string in Location: header
    httpStatus - Status for redirect (i.e. HttpStatusRedirect)

Return Value:

    HRESULT

--*/
{
    HRESULT      hr;
    STACK_STRA(  strRedirect, MAX_PATH);
    STRA        *pstrRedirect;

    W3_RESPONSE *pResponse = QueryResponse();
    W3_REQUEST  *pRequest  = QueryRequest();

    //
    // If it an absolute path add the protocol, host name and QueryString
    // if specified, otherwise just assume it is a fully qualified URL.
    //
    if (strPath.QueryStr()[0] == '/')
    {
        // build the redirect URL (with http://) into strRedirect
        hr = pRequest->BuildFullUrl( strPath,
                                     &strRedirect,
                                     fIncludeParameters );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        pstrRedirect = &strRedirect;
    }
    else
    {
        pstrRedirect = &strPath;
    }

    //
    // Setup the response, starting with status and location: 
    //
    
    pResponse->SetStatus( httpStatus );
   
    //
    // Be careful to reset the response on subsequent failures so we don't
    // end up with an incomplete response!
    //
    
    hr = pResponse->SetHeader( HttpHeaderLocation,
                               pstrRedirect->QueryStr(),
                               pstrRedirect->QueryCCH() );
    if ( FAILED( hr ) )
    {
        pResponse->Clear();
        return hr;
    }

    pResponse->SetHeaderByReference( HttpHeaderContentType,
                                     "text/html", 9 );

    //
    // Now add any metabase configured "redirect" headers (lame)
    //
    
    STRA *pstrRedirectHeaders = QueryUrlContext()->QueryMetaData()->QueryRedirectHeaders();
    if ( pstrRedirectHeaders != NULL )
    {
        hr = pResponse->AppendResponseHeaders( *pstrRedirectHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }    
    
    //
    // Add the canned redirect body.  This means taking the format string,
    // and inserting the URL into it
    //

    CHAR *pvRedirect;
    DWORD cbRedirect = sm_cbRedirectMessage + pstrRedirect->QueryCCH();

    //
    // Keep a buffer around
    //

    hr = QueryHeaderBuffer()->AllocateSpace( cbRedirect + 1,
                                             &pvRedirect );
    if ( FAILED( hr ) )
    {
        return hr;
    }                                                                
    
    cbRedirect = _snprintf( pvRedirect,
                            cbRedirect,
                            sm_achRedirectMessage,
                            pstrRedirect->QueryStr() );
   
    //
    // Setup the response
    //
    
    hr = pResponse->AddMemoryChunkByReference( pvRedirect,
                                               cbRedirect );
    if ( FAILED( hr ) )
    {
        pResponse->Clear();
        return hr;
    }
    
    return S_OK;
}

HRESULT
W3_CONTEXT::SetupHttpRedirect(
    STRU &              strPath,
    BOOL                fIncludeParameters,
    HTTP_STATUS &       httpStatus
)
/*++

Routine Description:

    Do an HTTP redirect (301 or 302)

Arguments:

    strPath - New path component of destination
    fIncludeParameters - Include query string in Location: header
    httpStatus - Status for redirect (i.e. HttpStatusRedirect)

Return Value:

    HRESULT

--*/
{
    //
    // Convert the unicode path to ansi
    //
    HRESULT hr;
    STACK_STRA (straPath, MAX_PATH);
    if (FAILED(hr = straPath.CopyWToUTF8Unescaped(strPath)))
    {
        return hr;
    }

    return SetupHttpRedirect(straPath,
                             fIncludeParameters,
                             httpStatus);
}

BOOL W3_CONTEXT::QueryDoUlLogging()
{
    if (QuerySite() == NULL ||
        !QuerySite()->QueryDoUlLogging())
    {
        return FALSE;
    }

    if (QueryUrlContext() == NULL ||
        QueryUrlContext()->QueryMetaData() == NULL)
    {
        return TRUE;
    }

    return !QueryUrlContext()->QueryMetaData()->QueryDontLog();
}

BOOL W3_CONTEXT::QueryDoCustomLogging()
{
    if (QuerySite() == NULL ||
        !QuerySite()->QueryDoCustomLogging())
    {
        return FALSE;
    }

    if (QueryUrlContext() == NULL ||
        QueryUrlContext()->QueryMetaData() == NULL)
    {
        return TRUE;
    }

    return !QueryUrlContext()->QueryMetaData()->QueryDontLog();
}

VOID
W3_CONTEXT::SetSSICommandHandler(
    W3_HANDLER *            pHandler
)
/*++

Routine Description:

    Explicitly sets the CGI_HANDLER for this request.  This is the handler
    which executes explicit command lines on behalf of SSI
    
    The function is named SetSSICommandHandler (instead of just SetHandler())
    to discourage others from using this function.  

Arguments:

    pHandler - Handler to set.  Must be the CGI handler

Return Value:

    None

--*/
{
    DBG_ASSERT( pHandler != NULL );
    DBG_ASSERT( _pHandler == NULL );
    DBG_ASSERT( wcscmp( pHandler->QueryName(), L"CGIHandler" ) == 0 );
        
    _pHandler = pHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3filter.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3filter.cxx

   Abstract:
     ISAPI Filter Support
 
   Author:
     Bilal Alam (balam)             8-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "iisextp.h"

//
// Filter globals
//

LIST_ENTRY              HTTP_FILTER_DLL::sm_FilterHead;
CRITICAL_SECTION        HTTP_FILTER_DLL::sm_csFilterDlls;

FILTER_LIST *           FILTER_LIST::sm_pGlobalFilterList;
ALLOC_CACHE_HANDLER *   W3_FILTER_CONTEXT::sm_pachFilterContexts;

//
// Standard HTTP_FILTER_CONTEXT entry points
//

BOOL
WINAPI
FilterServerSupportFunction(
    struct _HTTP_FILTER_CONTEXT * pfc,
    enum SF_REQ_TYPE              SupportFunction,
    void *                        pData,
    ULONG_PTR                     ul,
    ULONG_PTR                     ul2
)
/*++

Routine Description:

    Filter ServerSupportFunction implementation

Arguments:

    pfc - Used to get back the W3_FILTER_CONTEXT and W3_MAIN_CONTEXT pointers
    SupportFunction - SSF to invoke (see ISAPI docs)
    pData, ul, ul2 - Function specific data
    
Return Value:

    BOOL (use GetLastError() for error)

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    CERT_CONTEXT_EX *           pCertContext;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() != NULL )
    {
        pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
        DBG_ASSERT( pContext != NULL );
        DBG_ASSERT( pContext->CheckSignature() );
    }
    else
    {
        pContext = NULL;
    }

    switch ( SupportFunction )
    {
    case SF_REQ_SEND_RESPONSE_HEADER:
   
        if ( pContext == NULL )
        {   
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto Finished;
        }
        
        pContext->SetNeedFinalDone();
    
        //
        // Parse the status line
        //
        
        if ( pData == NULL )
        {
            pData = "200 OK";
        }
        
        hr = pContext->QueryResponse()->BuildResponseFromIsapi( pContext,
                                                                (CHAR*) pData,
                                                                (CHAR*) ul,
                                                                ul ? strlen( (CHAR*)ul ) : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Is the status is access denied, then set the sub status to 
        // "Denied by Filter"
        // 
    
        if ( pContext->QueryResponse()->QueryStatusCode() == 
             HttpStatusUnauthorized.statusCode )
        {
            pContext->QueryResponse()->SetStatus( HttpStatusUnauthorized,
                                                  Http401Filter );
        }

        hr = pContext->SendResponse( W3_FLAG_SYNC |
                                     W3_FLAG_NO_ERROR_BODY |
                                     W3_FLAG_MORE_DATA );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        break;

    case HSE_REQ_GET_CERT_INFO_EX:

        if ( pContext == NULL )
        {   
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
            goto Finished;
        }
        
        pCertContext = (CERT_CONTEXT_EX*) pData;

        hr = pContext->GetCertificateInfoEx(
                pCertContext->cbAllocated,
                &( pCertContext->CertContext.dwCertEncodingType ),
                pCertContext->CertContext.pbCertEncoded,
                &( pCertContext->CertContext.cbCertEncoded ),
                &( pCertContext->dwCertificateFlags ) );
        break;
    
    case SF_REQ_NORMALIZE_URL:
    
        if ( pData )
        {
            STACK_STRU( strUrlOutput, MAX_PATH );
            STACK_STRA( strUrlA, MAX_PATH );
            LPWSTR      szQueryString;
            DWORD       cchData;
            DWORD       cbOutput;

            cchData = strlen( (LPSTR)pData );

            hr = strUrlOutput.SetLen( cchData );

            if ( FAILED( hr ) )
            {
                break;
            }

            //
            // Normalize it
            //

            hr = UlCleanAndCopyUrl(
                (PUCHAR)pData,
                strlen( (LPSTR)pData ),
                &cbOutput,
                strUrlOutput.QueryStr(),
                &szQueryString
                );

            if ( FAILED( hr ) )
            {
                break;
            }

            //
            // Terminate the string at the query so that the
            // query string doesn't appear in the output.  IIS 5
            // truncated in this way.
            //

            if ( szQueryString )
            {
                strUrlOutput.SetLen( wcslen( strUrlOutput.QueryStr() ) - wcslen( szQueryString ) );
            }

            //
            // Write the normalized URL over the input data
            //

            hr = strUrlA.CopyW( strUrlOutput.QueryStr() );

            if ( FAILED( hr ) )
            {
                break;
            }

            DBG_ASSERT( strUrlA.QueryCCH() <= cchData );

            strcpy( reinterpret_cast<LPSTR>( pData ), strUrlA.QueryStr() );
        }
        else
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }

        hr = NO_ERROR;
        break;
        
    case SF_REQ_ADD_HEADERS_ON_DENIAL:
  
        hr = pFilterContext->AddDenialHeaders( (LPSTR) pData );
        break; 
        
    case SF_REQ_DISABLE_NOTIFICATIONS:

        hr = pFilterContext->DisableNotification( (DWORD) ul );
        break;

    case SF_REQ_GET_PROPERTY:
    
        if ( ul == SF_PROPERTY_INSTANCE_NUM_ID )
        {
            if ( pContext != NULL )
            {
                *((DWORD*)pData) = pContext->QueryRequest()->QuerySiteId();
            }
            else
            {
                *((DWORD*)pData) = 0;
            }
            
            hr = NO_ERROR;
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        }
        break;
    
    default:
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }    

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }    
    return TRUE;
}

BOOL
WINAPI
FilterGetServerVariable(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszVariableName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Filter GetServerVariable() implementation

Arguments:

    pfc - Filter context
    lpszVariableName - Variable name
    lpvBuffer - Buffer to receive the server variable
    lpdwSize - On input, the size of the buffer, on output, the sized needed
    
    
Return Value:

    BOOL (use GetLastError() for error).  
    ERROR_INSUFFICIENT_BUFFER if larger buffer needed
    ERROR_INVALID_INDEX if the server variable name requested is invalid

--*/
{
    PFN_SERVER_VARIABLE_ROUTINE     pfnRoutine;
    W3_FILTER_CONTEXT *             pFilterContext;
    HRESULT                         hr;
    W3_CONTEXT *                    pContext;
    
    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpdwSize == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() != NULL )
    {
        pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
        DBG_ASSERT( pContext != NULL );
        DBG_ASSERT( pContext->CheckSignature() );
    }
    else
    {
        pContext = NULL;
    }

    //
    // Get the variable (duh)
    //

    hr = SERVER_VARIABLE_HASH::GetServerVariable( pContext,
                                                  lpszVariableName,
                                                  (CHAR*) lpvBuffer,
                                                  lpdwSize );

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
FilterWriteClient(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPVOID                        Buffer,
    LPDWORD                       lpdwBytes,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Synchronous WriteClient() for filters

Arguments:

    pfc - Filter context
    Buffer - buffer to write to client
    lpdwBytes - On input, the size of the input buffer.  On output, the number
                of bytes sent
    dwReserved - Reserved
    
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    W3_RESPONSE *               pResponse;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         Buffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pResponse = pContext->QueryResponse();
    DBG_ASSERT( pResponse->CheckSignature() );

    //
    // Just like an extension which calls WriteClient(), a filter doing so
    // requires us to do a final send
    //
    
    pContext->SetNeedFinalDone();

    //
    // Now send the data non-intrusively
    //
    
    hr = pResponse->FilterWriteClient( pContext,
                                       Buffer,
                                       *lpdwBytes );
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

VOID *
WINAPI
FilterAllocateMemory(
    struct _HTTP_FILTER_CONTEXT * pfc,
    DWORD                         cbSize,
    DWORD                         dwReserved
)
/*++

Routine Description:

    Used by filters to allocate memory freed on connection close

Arguments:

    pfc - Filter context
    cbSize - Amount to allocate
    dwReserved - Reserved
    
    
Return Value:

    A pointer to the allocated memory

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    return pFilterContext->AllocateFilterMemory( cbSize );
}

BOOL
WINAPI
FilterAddResponseHeaders(
    HTTP_FILTER_CONTEXT * pfc,
    LPSTR                 lpszHeaders,
    DWORD                 dwReserved
)
/*++

Routine Description:

    Add response headers to whatever response eventually gets sent

Arguments:

    pfc - Filter context
    lpszHeaders - Headers to send (\r\n delimited)
    dwReserved - Reserved
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    HRESULT                     hr;
    W3_CONTEXT *                pContext;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL || 
         lpszHeaders == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );

    //
    // It is OK for the maincontext to be NULL (in the case of a
    // END_OF_NET_SESSION) notification
    //
   
    if ( pFilterContext->QueryMainContext() == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    hr = pFilterContext->AddResponseHeaders( lpszHeaders );
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

//
// Preproc headers entry points
//

BOOL
WINAPI
GetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to get request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to get (suffixed with ':' unless special
               case of 'url', 'version', method'
    lpvBuffer - Filled with header value
    lpdwSize - on input, size of input buffer, on output, size needed
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    STACK_STRA(                 strValue, 128 );
    HRESULT                     hr;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strName, 64 );
    DWORD                       cbNeeded;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT *) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    //
    // Aargh.  Handle the "URL", "METHOD", "VERSION" cases here
    //
    
    if ( _stricmp( lpszName, "url" ) == 0 )
    {
        hr = pContext->QueryRequest()->GetRawUrl( &strValue );
    }
    else if ( _stricmp( lpszName, "method" ) == 0 )
    {
        hr = pContext->QueryRequest()->GetVerbString( &strValue );
    }
    else if ( _stricmp( lpszName, "version" ) == 0 )
    {
        hr = pContext->QueryRequest()->GetVersionString( &strValue );
    }
    else 
    { 
        //
        // A real header
        //
    
        hr = strName.Copy( (CHAR*) lpszName, 
                           *lpszName ? strlen( lpszName ) - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pContext->QueryRequest()->GetHeader( strName,
                                                  &strValue );
    }
    
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Did caller provide enough space for value
    //

    hr = strValue.CopyToBuffer( (CHAR*) lpvBuffer, lpdwSize );

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
SetFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to set request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to set (suffixed with ':' unless special
               case of 'url', 'version', method'
    lpszValue - Value of header being set (old value will be replaced)
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    //
    // Get the new header value
    //
    
    hr = strHeaderValue.Copy( lpszValue ? lpszValue : "" );
    if ( FAILED( hr ) ) 
    {
        goto Finished;
    }
   
    //
    // Check for "URL", "METHOD", and "VERSION
    //

    if ( _stricmp( lpszName, "url" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetUrlA( strHeaderValue );
    } 
    else if ( _stricmp( lpszName, "method" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetVerb( strHeaderValue );
    }
    else if ( _stricmp( lpszName, "version" ) == 0 )
    {
        hr = pContext->QueryRequest()->SetVersion( strHeaderValue );
    }
    else
    {
        //
        // A real header
        //
        
        hr = strHeaderName.Copy( lpszName, 
                                 *lpszName ? strlen( lpszName ) - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        pContext->QueryRequest()->DeleteHeader( strHeaderName.QueryStr() );
        
        if ( lpszValue != NULL && *lpszValue != '\0' )
        {
            hr = pContext->QueryRequest()->SetHeader( strHeaderName,
                                                      strHeaderValue );
        }
    }

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
AddFilterHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Used by PREPROC_HEADER filters to append request headers

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header being set (old value will be replaced)
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );
   
    //
    // Get the new header value
    //
    
    hr = strHeaderValue.Copy( lpszValue );
    if ( FAILED( hr ) ) 
    {
        goto Finished;
    }
    
    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? strlen( lpszName ) - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
        
    hr = pContext->QueryRequest()->SetHeader( strHeaderName,
                                              strHeaderValue,
                                              TRUE );

Finished:    
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

//
// SEND_RESPONSE notification helpers
//

BOOL
WINAPI
GetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPVOID                        lpvBuffer,
    LPDWORD                       lpdwSize
)
/*++

Routine Description:

    Get a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to get
    lpvBuffer - Filled with header
    lpdwSize - On input the size of the buffer, on output, the size needed
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    if ( strcmp( lpszName, "status" ) == 0 )
    {
        hr = pContext->QueryResponse()->GetStatusLine( &strHeaderValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    else
    {
        hr = strHeaderName.Copy( lpszName, 
                                 *lpszName ? strlen( lpszName ) - 1 : 0 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        hr = pContext->QueryResponse()->GetHeader( strHeaderName.QueryStr(),
                                                   &strHeaderValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    
    //
    // Copy into ANSI buffer
    //
    
    hr = strHeaderValue.CopyToBuffer( (CHAR*) lpvBuffer,
                                      lpdwSize );

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
SetSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Set a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header to set
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? strlen( lpszName ) - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;   
    } 
    
    //
    // First delete existing header, then add new one
    //
    
    hr = pContext->QueryResponse()->DeleteHeader( strHeaderName.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    if ( lpszValue != NULL && *lpszValue != '\0' )
    {
        hr = strHeaderValue.Copy( lpszValue );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    
        hr = pContext->QueryResponse()->SetHeader( strHeaderName.QueryStr(),
                                                   strHeaderName.QueryCCH(),
                                                   strHeaderValue.QueryStr(),
                                                   strHeaderValue.QueryCCH(),
                                                   FALSE );
    }

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
AddSendHeader(
    struct _HTTP_FILTER_CONTEXT * pfc,
    LPSTR                         lpszName,
    LPSTR                         lpszValue
)
/*++

Routine Description:

    Add a response header

Arguments:

    pfc - Filter context
    lpszName - Name of header to set
    lpszValue - Value of header to set
    
Return Value:

    BOOL (use GetLastError() for error).  

--*/
{
    W3_FILTER_CONTEXT *         pFilterContext;
    W3_CONTEXT *                pContext;
    STACK_STRA(                 strHeaderName, 128 );
    STACK_STRA(                 strHeaderValue, 128 );
    HRESULT                     hr;

    //
    // Primitive parameter validation
    //

    if ( pfc == NULL ||
         pfc->ServerContext == NULL ||
         lpszName == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    hr = strHeaderName.Copy( lpszName, 
                             *lpszName ? strlen( lpszName ) - 1 : 0 );
    if ( FAILED( hr ) )
    {
        goto Finished;   
    } 
    
    hr = strHeaderValue.Copy( lpszValue );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = pContext->QueryResponse()->SetHeader( strHeaderName.QueryStr(),
                                               strHeaderName.QueryCCH(),
                                               strHeaderValue.QueryStr(),
                                               strHeaderValue.QueryCCH(),
                                               TRUE,
                                               FALSE,
                                               TRUE );

Finished:
    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
GetUserToken(
    struct _HTTP_FILTER_CONTEXT * pfc,
    HANDLE *                      phToken
)
/*++

Routine Description:

    Get impersonated user token

Arguments:

    pfc - Filter context
    phToken - Filled with impersonation token
    
Return Value:

    TRUE on success, FALSE on failure

--*/
{
    W3_FILTER_CONTEXT *    pFilterContext;
    W3_CONTEXT *           pContext;
    W3_USER_CONTEXT *      pW3UserContext;

    //
    // Primitive parameter validation
    //
    if ( !pfc ||
         !pfc->ServerContext ||
         !phToken )
    {
        DBGPRINTF(( DBG_CONTEXT,
              "[GetUserToken] Extension passed invalid parameters\r\n"));

        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pFilterContext = (W3_FILTER_CONTEXT*) pfc->ServerContext;
    DBG_ASSERT( pFilterContext->CheckSignature() );
    
    pContext = pFilterContext->QueryMainContext()->QueryCurrentContext();
    DBG_ASSERT( pContext != NULL );
    DBG_ASSERT( pContext->CheckSignature() );

    pW3UserContext = pContext->QueryUserContext();
    DBG_ASSERT( pW3UserContext != NULL );
    DBG_ASSERT( pW3UserContext->CheckSignature() );

    *phToken = pW3UserContext->QueryImpersonationToken();
    
    return TRUE;
}

//
// Connection filter context
//

W3_FILTER_CONNECTION_CONTEXT::W3_FILTER_CONNECTION_CONTEXT(
    VOID
) : _pFilterContext( NULL )
{
    InitializeListHead( &_PoolHead );
    
    ZeroMemory( _rgContexts, sizeof( _rgContexts ) );
}

W3_FILTER_CONNECTION_CONTEXT::~W3_FILTER_CONNECTION_CONTEXT(
    VOID
)
{
    FILTER_POOL_ITEM *          pfpi;

    //
    // OK.  The connection is going away, we need to notify 
    // SF_NOTIFY_END_OF_NET_SESSION filters, if a filter context was
    // associated with this connection
    //
    
    if ( _pFilterContext != NULL )
    {
        if ( _pFilterContext->IsNotificationNeeded( SF_NOTIFY_END_OF_NET_SESSION ) )
        {
            _pFilterContext->NotifyEndOfNetSession();
        }
    
        _pFilterContext->DereferenceFilterContext();
        _pFilterContext = NULL;
    }

    //
    // Free pool items
    //

    while ( !IsListEmpty( &_PoolHead ) ) 
    {
        pfpi = CONTAINING_RECORD( _PoolHead.Flink,
                                  FILTER_POOL_ITEM,
                                  _ListEntry );

        RemoveEntryList( &pfpi->_ListEntry );

        delete pfpi;
    }
}

VOID
W3_FILTER_CONNECTION_CONTEXT::AddFilterPoolItem(
    FILTER_POOL_ITEM *          pFilterPoolItem
)
/*++

Routine Description:

    Add given filter pool item to this list

Arguments:

    pFilterPoolItem - Filter item to add

Return Value:

    None

--*/
{
    DBG_ASSERT( pFilterPoolItem != NULL );
    DBG_ASSERT( pFilterPoolItem->CheckSignature() );
    
    InsertHeadList( &_PoolHead, &(pFilterPoolItem->_ListEntry) );
}

VOID
W3_FILTER_CONNECTION_CONTEXT::AssociateFilterContext(
    W3_FILTER_CONTEXT *         pFilterContext
)
/*++

Routine Description:

    Called once per request to associate the current W3_FILTER_CONTEXT
    with the filter connection context.  This is the context that will be
    used when the connection dies and we need to determine which filters
    have registered for the END_OF_NET_SESSION notification

Arguments:

    pFilterContext - Current W3_FILTER_CONTEXT of the connection
    
Return Value:

    None

--*/
{
    //
    // Dereference the old context -> let it go away on its own
    //
        
    if ( _pFilterContext != NULL )
    {
        _pFilterContext->DereferenceFilterContext();
        _pFilterContext = NULL;
    }

    //
    // Attach to the new filter context
    //
    
    pFilterContext->ReferenceFilterContext();
    _pFilterContext = pFilterContext;
}

//
// Filter list, dll, and context implementations
//

HRESULT
HTTP_FILTER_DLL::LoadDll(
    MB *                        pMB,
    LPWSTR                      pszKeyName,
    BOOL *                      pfOpened,
    LPWSTR                      pszRelFilterPath,
    LPWSTR                      pszFilterDll
)
/*++

Routine Description:

    Load an ISAPI filter and add it to our filter cache

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_VERSION             ver;
    DWORD                           dwError;
    HRESULT                         hr = NO_ERROR;
    STACK_STRU(                     strDescription, 256 );

    if ( pMB == NULL ||
         pszKeyName == NULL ||
         pfOpened == NULL ||
         pszRelFilterPath == NULL ||
         pszFilterDll == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    hr = _strName.Copy( pszFilterDll );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Load the actual DLL
    //
    
    _hModule = LoadLibraryEx( _strName.QueryStr(),
                              NULL,
                              LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( _hModule == NULL )
    {
        dwError = GetLastError();
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Unable to LoadLibrary ISAPI filter '%ws'.  Error = %d\n",
                    _strName.QueryStr(),
                    dwError ));
                    
        return HRESULT_FROM_WIN32( dwError );
    }
    
    //
    // Retrieve the entry points
    //
    
    _pfnSFVer = (PFN_SF_VER_PROC) GetProcAddress( _hModule,
                                                  SF_VERSION_ENTRY );
    
    _pfnSFProc = (PFN_SF_DLL_PROC) GetProcAddress( _hModule,
                                                   SF_DEFAULT_ENTRY );
                                                   
    _pfnSFTerm = (PFN_SF_TERM_PROC) GetProcAddress( _hModule,
                                                    SF_TERM_ENTRY );

    //
    // We require at least the FilterInit and HttpFilterProc exports
    //

    if ( !_pfnSFProc || !_pfnSFVer )
    {
        //
        // On HTTP_FILTER_DLL cleanup, don't call TerminateFilter
        //
        
        _pfnSFTerm = NULL;
        
        return HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );
    }
    
    //
    // Call the initialization routine
    //

    ver.dwServerFilterVersion = HTTP_FILTER_REVISION;
    ver.lpszFilterDesc[ 0 ] = '\0';

    if ( !_pfnSFVer( &ver ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Write out the returned description, notifications to the metabase
    // for consumption by the UI
    //
    
    hr = strDescription.CopyA( (CHAR*) ver.lpszFilterDesc );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( *pfOpened ||
         pMB->Open( pszKeyName,
                    METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
    {
        *pfOpened = TRUE;
        
        if ( !pMB->SetString( pszRelFilterPath,
                              MD_FILTER_DESCRIPTION,
                              IIS_MD_UT_SERVER,
                              strDescription.QueryStr(),
                              0 ) ||
             !pMB->SetDword( pszRelFilterPath,
                             MD_FILTER_FLAGS,
                             IIS_MD_UT_SERVER,
                             ver.dwFlags,
                             0 ))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            return hr;
        }
    }

    //
    // If the client didn't specify any of the secure port notifications,
    // supply them with the default of both
    //

    if ( !(ver.dwFlags & (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT)))
    {
        ver.dwFlags |= (SF_NOTIFY_SECURE_PORT | SF_NOTIFY_NONSECURE_PORT);
    }

    _dwVersion      = ver.dwFilterVersion;
    
    _dwFlags        = (ver.dwFlags & SF_NOTIFY_NONSECURE_PORT) ? ver.dwFlags : 0;
    _dwSecureFlags  = (ver.dwFlags & SF_NOTIFY_SECURE_PORT) ? ver.dwFlags : 0;

    //
    // Put the new dll on the filter dll list
    //

    InsertHeadList( &sm_FilterHead, &_ListEntry );

    return NO_ERROR;
}

//static
HRESULT
HTTP_FILTER_DLL::OpenFilter(
    MB *                        pMB,
    LPWSTR                      pszKeyName,
    BOOL *                      pfOpened,
    LPWSTR                      pszRelFilterPath,
    LPWSTR                      pszFilterDll,
    BOOL                        fUlFriendly,
    HTTP_FILTER_DLL **          ppFilter
)
/*++

Routine Description:

    Checkout an ISAPI filter from cache.  If necessary load it for the 
    first time

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    fUlFriendly - Is this filter friendly with the UL cache?
    ppFilter - Set to point to an HTTP_FILTER_DLL on success
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll = NULL;
    HRESULT                     hr = NO_ERROR;
    LIST_ENTRY *                pEntry;
    
    if ( pMB == NULL ||
         pszKeyName == NULL ||
         pfOpened == NULL ||
         pszRelFilterPath == NULL ||
         pszFilterDll == NULL ||
         ppFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Hold the global lock while we iterate thru loaded ISAPI filters
    // 
   
    EnterCriticalSection( &sm_csFilterDlls );

    for ( pEntry = sm_FilterHead.Flink;
          pEntry != &sm_FilterHead;
          pEntry = pEntry->Flink )
    {
        pFilterDll = CONTAINING_RECORD( pEntry, HTTP_FILTER_DLL, _ListEntry );

        DBG_ASSERT( pFilterDll->CheckSignature() );

        if ( _wcsicmp( pszFilterDll, pFilterDll->QueryName()->QueryStr() ) == 0 )
        {
            pFilterDll->Reference();
            break;
        }
        
        pFilterDll = NULL;
    }
    
    //
    // If pFilterDll is still NULL, then we haven't already loaded it
    //
    
    if ( pFilterDll == NULL )
    {
        //
        // Try to add it
        //
        
        pFilterDll = new HTTP_FILTER_DLL( fUlFriendly );
        if ( pFilterDll == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Finished;
        }
        
        hr = pFilterDll->LoadDll( pMB,
                                  pszKeyName,
                                  pfOpened,
                                  pszRelFilterPath, 
                                  pszFilterDll );
        if ( FAILED( hr ) )
        {
            // Log the failure
            LPCWSTR apsz[1];
            apsz[0] = pszFilterDll;
            g_pW3Server->LogEvent(W3_EVENT_FILTER_DLL_LOAD_FAILED,
                                  1,
                                  apsz,
                                  WIN32_FROM_HRESULT(hr));

            delete pFilterDll;
            pFilterDll = NULL;
            goto Finished;
        }
    }
    
Finished:
    LeaveCriticalSection( &sm_csFilterDlls );
    
    *ppFilter = pFilterDll;
    return hr;
}

//static
HRESULT
HTTP_FILTER_DLL::Initialize(
    VOID
)
/*++

Routine Description:

    Global HTTP_FILTER_DLL cache initialization

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    InitializeListHead( &sm_FilterHead );
    
    InitializeCriticalSectionAndSpinCount( &sm_csFilterDlls, 200 );
    
    return NO_ERROR;
}

//static
VOID
HTTP_FILTER_DLL::Terminate(
    VOID
)
/*++

Routine Description:

    Global HTTP_FILTER_DLL cache cleanup.
    The actual HTTP_FILTER_DLL will get cleaned up as sites go away.  Sites
    hold references to HTTP_FILTER_DLLs thru filter lists

Arguments:

    None
    
Return Value:

    None

--*/
{
    DBG_ASSERT(IsListEmpty(&sm_FilterHead));

    DeleteCriticalSection( &sm_csFilterDlls );
}

HRESULT
FILTER_LIST::LoadFilter(
    MB *                    pMB,
    LPWSTR                  pszKeyName,
    BOOL *                  pfOpened,
    LPWSTR                  pszRelativeMBPath,
    LPWSTR                  pszFilterDll,
    BOOL                    fAllowRawRead,
    BOOL                    fUlFriendly
)
/*++

Routine Description:

    Add a filter to the the current filter list

Arguments:

    pMB - Used to write diagnostics to the metabase 
    pszKeyName - Metabase path "lm/w3svc/1/filters" or "lm/w3svc/filters"
    pfOpened - *pfOpened TRUE if MB has been opened yet
    pszRelFilterPath - The path segment with the filter name 
    pszFilterDll - Physical path of ISAPI filter to load
    fUlFriendly - Is this filter usable with the UL cache
    
Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *       pFilterDll = NULL;
    HRESULT                 hr = NO_ERROR;
    
    //
    // Get a pointer to the filter (either by loading or checking out)
    //
    
    hr = HTTP_FILTER_DLL::OpenFilter( pMB,
                                      pszKeyName,
                                      pfOpened,
                                      pszRelativeMBPath,
                                      pszFilterDll,
                                      fUlFriendly,
                                      &pFilterDll );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cannot load filter dll '%ws'.  hr = %x\n",
                    pszFilterDll,
                    hr ));
    
        if ( *pfOpened ||
             pMB->Open( pszKeyName,
                        METADATA_PERMISSION_READ |
                        METADATA_PERMISSION_WRITE ) )
        {
            *pfOpened = TRUE;
            
            pMB->SetDword( pszRelativeMBPath,
                           MD_WIN32_ERROR,
                           IIS_MD_UT_SERVER,
                           WIN32_FROM_HRESULT( hr ),
                           METADATA_VOLATILE );
            
            pMB->SetDword( pszRelativeMBPath,
                           MD_FILTER_STATE,
                           IIS_MD_UT_SERVER,
                           MD_FILTER_STATE_UNLOADED,
                           0 );
        }
        
        return hr;
    }
    
    DBG_ASSERT( pFilterDll != NULL );

    //
    // Check that we do not accept any per-site read-raw filter
    //
    if (!fAllowRawRead &&
        (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_READ_RAW_DATA))
    {
        LPCWSTR apsz[1];
        DWORD dwMessageId;
        apsz[0] = pszFilterDll;
        
        //
        // We could be disallowing read filters for two reasons
        // 1) The filter is not global
        // 2) We are running in Dedicated Application Mode
        //
        
        if ( g_pW3Server->QueryInBackwardCompatibilityMode() )
        {
            dwMessageId = W3_MSG_READ_RAW_MUST_BE_GLOBAL;
        }
        else
        {
            dwMessageId = W3_MSG_READ_RAW_MUST_USE_STANDARD_APPLICATION_MODE;
        }
    
        g_pW3Server->LogEvent( dwMessageId,
                               1,
                               apsz);

        DBGPRINTF((DBG_CONTEXT,
                   "Refusing READ_RAW filter on site (%S)\n",
                   pszFilterDll));

        if (*pfOpened ||
            pMB->Open(pszKeyName,
                      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE))
        {
            *pfOpened = TRUE;

            pMB->SetDword(pszRelativeMBPath,
                          MD_WIN32_ERROR,
                          IIS_MD_UT_SERVER,
                          ERROR_INVALID_PARAMETER,
                          METADATA_VOLATILE);
            pMB->SetDword(pszRelativeMBPath,
                          MD_FILTER_STATE,
                          IIS_MD_UT_SERVER,
                          MD_FILTER_STATE_UNLOADED,
                          0);
        }

        pFilterDll->Dereference();
        return S_OK;
    }

    //
    // Write out that we successfully loaded the filter
    //
    
    if ( *pfOpened ||
         pMB->Open( pszKeyName, 
                    METADATA_PERMISSION_READ | 
                    METADATA_PERMISSION_WRITE ) )
    {
        *pfOpened = TRUE;

        pMB->SetDword( pszRelativeMBPath,
                       MD_WIN32_ERROR,
                       IIS_MD_UT_SERVER,
                       NO_ERROR,
                       METADATA_VOLATILE );
                       
        pMB->SetDword( pszRelativeMBPath,
                       MD_FILTER_STATE,
                       IIS_MD_UT_SERVER,
                       MD_FILTER_STATE_LOADED,
                       0 );
    }
    
    //
    // Now insert into array
    //

    hr = AddFilterToList( pFilterDll );
    if ( FAILED( hr ) )
    {
        pFilterDll->Dereference();
    }

    return hr;
}

HRESULT
FILTER_LIST::AddFilterToList(
    HTTP_FILTER_DLL *           pFilterDll
)
/*++

Routine Description:

    Do the filter list insertion

Arguments:

    pFilterDll - Filter to insert
    
Return Value:

    HRESULT

--*/
{
    //
    // Make sure there's a free entry in the filter list array, and
    // the secure/non-secure notification arrays (the latter two are used
    // in conjunction with filters disabling themselves per request
    //

    if ( (_cFilters+1) > (_buffFilterArray.QuerySize() / sizeof(PVOID)))
    {
        if ( !_buffFilterArray.Resize( (_cFilters + 5) * sizeof(PVOID)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( !_buffSecureArray.Resize( (_cFilters + 5) * sizeof(DWORD)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        if ( !_buffNonSecureArray.Resize( (_cFilters + 5) * sizeof(DWORD)) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }
    
    //    
    // Find where pFilterDll goes in the list
    //

    for ( ULONG i = 0; i < _cFilters; i++ )
    {
        if ( (QueryDll(i)->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK)
           <  (pFilterDll->QueryNotificationFlags() & SF_NOTIFY_ORDER_MASK) )
        {
            break;
        }
    }

    //
    // And insert it into the array
    //

    memmove( (PVOID *) _buffFilterArray.QueryPtr() + i + 1,
             (PVOID *) _buffFilterArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(PVOID) );

    (((HTTP_FILTER_DLL * *) (_buffFilterArray.QueryPtr())))[i] = pFilterDll;

    //
    // Add notification DWORDS to secure/non-secure arrays
    //

    memmove( (DWORD *) _buffSecureArray.QueryPtr() + i + 1,
             (DWORD *) _buffSecureArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) _buffSecureArray.QueryPtr())[i] = pFilterDll->QuerySecureFlags();

    memmove( (DWORD *) _buffNonSecureArray.QueryPtr() + i + 1,
             (DWORD *) _buffNonSecureArray.QueryPtr() + i,
             (_cFilters - i) * sizeof(DWORD) );

    ((DWORD*) _buffNonSecureArray.QueryPtr())[i] = pFilterDll->QueryNonsecureFlags();

    _cFilters++;

    //
    // Segregate the secure and non-secure port notifications
    //
    
    _dwSecureNotifications |= pFilterDll->QuerySecureFlags();
    _dwNonSecureNotifications |= pFilterDll->QueryNonsecureFlags();
   
    //
    // Check the UL friendliness of the filter and reflect that for the
    // list's UL friendliness
    //
    
    if ( !pFilterDll->QueryIsUlFriendly() )
    {
        _fUlFriendly = FALSE;
    }
    
    return NO_ERROR;
}

HRESULT
FILTER_LIST::LoadFilters(
    LPWSTR                  pszMDPath,
    BOOL                    fAllowRawRead
)
/*++

Routine Description:

    The high level filter list routine to grok the metabase and load all
    appropriate filters.  This routine is called globally and once for each
    server instance (site)

Arguments:

    pszMDPath - Metabase path (either lm/w3svc or lm/w3svc/<n>)
    
Return Value:

    HRESULT

--*/
{
    STACK_STRU(     strFilterKey, MAX_PATH );
    DWORD           cb;
    DWORD           fEnabled;
    WCHAR           achLoadOrder[ 1024 ];
    WCHAR           achDllName[ MAX_PATH + 1 ];
    LPWSTR          pszFilter;
    LPWSTR          pszComma;
    MB              mb( g_pW3Server->QueryMDObject() );
    BOOL            fOpened = FALSE;
    HRESULT         hr;
    DWORD           dwUlFriendly = 0;

    //
    // Add the obligatory "/filters"
    //

    hr = strFilterKey.Copy( pszMDPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = strFilterKey.Append( TEXT( IIS_MD_ISAPI_FILTERS ) );
    if ( FAILED( hr ) ) 
    {
        return hr;
    } 

    //
    // Loop through filter keys, if we can't access the metabase, we assume
    // success and continue
    //

    if ( mb.Open( strFilterKey.QueryStr(),
                  METADATA_PERMISSION_READ ) )
    {
        fOpened = TRUE;

        //
        // Get the filter load order.  This is a comma delimited 
        // list of filter subkey names.  Here, we parse thru the list
        //

        cb = sizeof( achLoadOrder );
        *achLoadOrder = L'\0';

        if ( mb.GetString( L"",
                           MD_FILTER_LOAD_ORDER,
                           IIS_MD_UT_SERVER,
                           achLoadOrder,
                           &cb,
                           0 ) )
        {
            pszFilter = achLoadOrder;

            while ( *pszFilter != L'\0' )
            {
                dwUlFriendly = 0;
                
                if ( !fOpened &&
                     !mb.Open( strFilterKey.QueryStr(),
                               METADATA_PERMISSION_READ ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "CreateFilterList: Cannot open path %ws, error %lu\n",
                                strFilterKey.QueryStr(), 
                                GetLastError() ));
                    break;
                }

                fOpened = TRUE;

                pszComma = wcschr( pszFilter, L',' );
                if ( pszComma != NULL )
                {
                    *pszComma = L'\0';
                }

                while ( iswspace( *pszFilter ) )
                {
                    pszFilter++;
                }

                fEnabled = TRUE;

                mb.GetDword( pszFilter,
                             MD_FILTER_ENABLED,
                             IIS_MD_UT_SERVER,
                             &fEnabled );

                if ( fEnabled ) 
                {
                    //
                    // Is the filter friendly with the UL cache?
                    //
                    // If the read fails, we'll assume it is not
                    // (i.e. fUlFriendly is by default FALSE)
                    //

                    mb.GetDword( pszFilter,
                                 MD_FILTER_ENABLE_CACHE,
                                 IIS_MD_UT_SERVER,
                                 &dwUlFriendly );

                    cb = sizeof( achDllName );

                    if ( mb.GetString( pszFilter,
                                       MD_FILTER_IMAGE_PATH,
                                       IIS_MD_UT_SERVER,
                                       achDllName,
                                       &cb,
                                       0 ) )
                    {
                        mb.Close();
                        fOpened = FALSE;

                        LoadFilter( &mb,
                                    strFilterKey.QueryStr(),
                                    &fOpened,
                                    pszFilter,
                                    achDllName,
                                    fAllowRawRead,
                                    !!dwUlFriendly );
                    }
                }

                if ( pszComma != NULL )
                {
                    pszFilter = pszComma + 1;
                }
                else
                {
                    break;
                }
            }
        }
    }

    return NO_ERROR;
}

HRESULT
FILTER_LIST::InsertGlobalFilters(
    VOID
)
/*++

Routine Description:

    Transfers all of the global filters to the per-instance filter list

Parameters:

    None

Return Value:

    HRESULT

--*/
{
    DWORD               i;
    HTTP_FILTER_DLL *   pFilterDll;
    BOOL                fOpened;
    HRESULT             hr = NO_ERROR;

    for ( i = 0; i < sm_pGlobalFilterList->QueryFilterCount(); i++ )
    {
        //
        // Ignore the return code, an event gets logged in LoadFilter()
        // We allow raw read filters here as we're just duplicating the
        // global filter list
        //
        
        pFilterDll = sm_pGlobalFilterList->QueryDll( i );
        DBG_ASSERT( pFilterDll != NULL );
        
        pFilterDll->Reference();

        hr = AddFilterToList( sm_pGlobalFilterList->QueryDll( i ) );
        if ( FAILED( hr ) )
        {
            pFilterDll->Dereference();
            return hr;
        }
    }
    
    return NO_ERROR;
}

//static
HRESULT
FILTER_LIST::Initialize(
    VOID
)
/*++

Routine Description:

    Global FILTER_LIST initialization

Parameters:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    DBG_ASSERT( sm_pGlobalFilterList == NULL );

    //
    // We keep one global list of filters
    //

    sm_pGlobalFilterList = new FILTER_LIST();
    if ( sm_pGlobalFilterList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failure;
    }
    
    //
    // Load global filters configured at the W3SVC level
    //

    //
    // Only load RawRead filters if we are in old mode
    //
    BOOL fLoadRawRead = g_pW3Server->QueryInBackwardCompatibilityMode();
    hr = sm_pGlobalFilterList->LoadFilters( L"/LM/W3SVC",
                                            fLoadRawRead );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error load global ISAPI filters.  hr = %x\n",
                    hr ));
        goto Failure;
    }
    
    return NO_ERROR;
    
Failure:
    if ( sm_pGlobalFilterList != NULL )
    {
        sm_pGlobalFilterList->Dereference();
        sm_pGlobalFilterList = NULL;
    }
    
    return hr;
}

//static
VOID
FILTER_LIST::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global FILTER_LIST

Parameters:

    None

Return Value:
    
    None

--*/
{
    DBG_ASSERT( sm_pGlobalFilterList != NULL );
    
    //
    // We cleanup the global filter list just like any other list.  We 
    // dereference and let it cleanup "naturally"
    //
    
    sm_pGlobalFilterList->Dereference();
    sm_pGlobalFilterList = NULL;
}

//
// W3_FILTER_CONTEXT goo
//

W3_FILTER_CONTEXT::W3_FILTER_CONTEXT(
    BOOL                            fIsSecure,
    FILTER_LIST *                   pFilterList
) 
  : _pMainContext( NULL ),
    _dwSecureNotifications( 0 ),
    _dwNonSecureNotifications( 0 ),
    _dwDeniedFlags( 0 ),
    _fNotificationsDisabled( FALSE ),
    _fInAccessDeniedNotification( FALSE ),
    _cRefs( 1 ),
    _pConnectionContext( NULL ),
    _dwCurrentFilter( INVALID_DLL )
{
    _pFilterList = pFilterList;
    if (_pFilterList != NULL)
    {
        _pFilterList->Reference();
    }

    _hfc.cbSize             = sizeof( _hfc );
    _hfc.Revision           = HTTP_FILTER_REVISION;
    _hfc.ServerContext      = (void *) this;
    _hfc.ulReserved         = 0;
    _hfc.fIsSecurePort      = fIsSecure;

    _hfc.ServerSupportFunction = FilterServerSupportFunction;
    _hfc.GetServerVariable     = FilterGetServerVariable;
    _hfc.AddResponseHeaders    = FilterAddResponseHeaders;
    _hfc.WriteClient           = FilterWriteClient;
    _hfc.AllocMem              = FilterAllocateMemory;

    _dwSignature = W3_FILTER_CONTEXT_SIGNATURE;
}

W3_FILTER_CONTEXT::~W3_FILTER_CONTEXT()
{
    if (_pFilterList)
    {
        _pFilterList->Dereference();
        _pFilterList = NULL;
    }

    _dwSignature = W3_FILTER_CONTEXT_SIGNATURE_FREE;
}

VOID
W3_FILTER_CONTEXT::SetMainContext(
    W3_MAIN_CONTEXT *           pMainContext
)
/*++

Routine Description:

    Associate a main context with a filter context so that we can get 
    at the request state in filter notifications

Arguments:

    pMainContext - Main context to associate

Return Value:

    VOID

--*/
{
    _pMainContext = pMainContext;
}

W3_FILTER_CONNECTION_CONTEXT *
W3_FILTER_CONTEXT::QueryConnectionContext(
    BOOL                    fCreateIfNotFound
)
/*++

Routine Description:

    Find an connection context associated with this filter contxt.  
    Optionally create one if necessary

Arguments:

    fCreateIfNotFound - Create if not found (default TRUE)

Return Value:

    A W3_FILTER_CONNECTION_CONTEXT or NULL

--*/
{
    W3_CONNECTION *         pConnection = NULL;
    
    if ( _pConnectionContext == NULL )
    {
        //
        // If _pMainContext is NULL, then this being called in a
        // END_OF_NET_SESSION notification, which is kinda busted.
        //
        
        DBG_ASSERT( _pMainContext != NULL );
        
        pConnection = _pMainContext->QueryConnection( fCreateIfNotFound );
        if ( pConnection != NULL )
        {
            _pConnectionContext = pConnection->QueryFilterConnectionContext();
            
            _pConnectionContext->AssociateFilterContext( this );
        }
    }
    
    return _pConnectionContext;
}

BOOL
W3_FILTER_CONTEXT::NotifyAccessDenied(
    const CHAR *  pszURL,
    const CHAR *  pszPhysicalPath,
    BOOL *        pfFinished
    )
/*++

Routine Description:

    This method handles notification of all filters that handle the
    access denied notification

Arguments:

    pszURL - URL that was target of request
    pszPath - Physical path the URL mapped to
    pfFinished - Set to TRUE if no further processing is required

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    HTTP_FILTER_ACCESS_DENIED   hfad;
    BOOL                        fRet;
    HRESULT                     hr;
    HTTP_SUB_ERROR              subError;

    //
    //  If these flags are not set, then somebody hasn't indicated the 
    //  filter flags yet.  We can do so now based on the set error response
    //

    if ( QueryDeniedFlags() == 0 )
    {
        DBG_ASSERT( QueryMainContext() != NULL );

        hr = QueryMainContext()->QueryResponse()->QuerySubError( &subError );
        if ( FAILED( hr ) )
        {
            return FALSE; 
        }
            
        if ( subError.mdSubError == MD_ERROR_SUB401_LOGON )
        {
            SetDeniedFlags( SF_DENIED_LOGON );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_LOGON_CONFIG )
        {
            SetDeniedFlags( SF_DENIED_BY_CONFIG | SF_DENIED_LOGON );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_LOGON_ACL )
        {
            SetDeniedFlags( SF_DENIED_RESOURCE );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_APPLICATION )
        {
            SetDeniedFlags( SF_DENIED_APPLICATION );
        }
        else if ( subError.mdSubError == MD_ERROR_SUB401_FILTER )
        {
            SetDeniedFlags( SF_DENIED_FILTER );
        }
    }

    //
    //  Ignore the notification of a send "401 ..." if this notification
    //  generated it
    //

    if ( _fInAccessDeniedNotification )
    {
        return TRUE;
    }

    _fInAccessDeniedNotification = TRUE;

    //
    //  Fill out the url map structure
    //

    hfad.pszURL          = pszURL;
    hfad.pszPhysicalPath = pszPhysicalPath;
    hfad.dwReason        = QueryDeniedFlags();

    fRet = NotifyFilters( SF_NOTIFY_ACCESS_DENIED,
                          &hfad,
                          pfFinished );

    _fInAccessDeniedNotification = FALSE;

    return fRet;
}

BOOL
W3_FILTER_CONTEXT::NotifyFilters(
    DWORD                   dwNotificationType,
    PVOID                   pNotificationData,
    BOOL *                  pfFinished
)
/*++

Routine Description:

    Notify all filters for this context

Arguments:

    dwNotificationType - SF_NOTIFY*
    pNotificationData - Notification specific data
    pfFinished - Set to TRUE if we are done and should disconnect

Return Value:

    BOOL

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    BOOL                        fRet = TRUE;

    if ( pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    
    *pfFinished = FALSE;

    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = _pFilterList;
    DBG_ASSERT( pFilterList != NULL );

    for ( i = 0; i < pFilterList->QueryFilterCount(); i++ )
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( dwNotificationType,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               dwNotificationType ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        if ( pFilterDll->QueryHasSetContextBefore() )
        {
            _hfc.pFilterContext = QueryClientContext( i );
        }
        else
        {
            _hfc.pFilterContext = NULL;
        }

        pvtmp = _hfc.pFilterContext;

        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  dwNotificationType,
                                                  pNotificationData );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            fRet = FALSE;
            goto Exit;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            if ( _pMainContext != NULL )
            {
                _pMainContext->SetDisconnect( TRUE );
            }
            *pfFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }

Exit:
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    _dwCurrentFilter = INVALID_DLL;
    
    return fRet;
}

BOOL
W3_FILTER_CONTEXT::NotifySendRawFilters(
    HTTP_FILTER_RAW_DATA *      pRawData,
    BOOL *                      pfFinished
)
/*++

Routine Description:

    Notify raw write filters.  Done differently than the other filter 
    notifications since we must call in opposite priority order

Arguments:

    pRawData - Raw data structure to be munged
    pfFinished - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_DLL *           pFilterDll;
    DWORD                       err;
    SF_STATUS_TYPE              sfStatus;
    DWORD                       i;
    PVOID                       pvtmp;
    PVOID                       pvCurrentClientContext;
    FILTER_LIST *               pFilterList;
    HTTP_FILTER_RAW_DATA        hfrd;
    DWORD                       dwOriginalFilter;
    BOOL                        fRet = TRUE;

    if ( pRawData == NULL ||
         pfFinished == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }
    
    *pfFinished = FALSE;

    hfrd.pvInData = pRawData->pvInData;
    hfrd.cbInData = pRawData->cbInData;
    hfrd.cbInBuffer = pRawData->cbInBuffer;
    
    //
    // In certain cases, we can send a notification to a filter while we're still
    // processing another filter's notification. In that case, we need to make sure
    // we restore the current filter's context when we're done with the notifications
    //
    
    pvCurrentClientContext = _hfc.pFilterContext;
    
    pFilterList = QueryFilterList();
    DBG_ASSERT( pFilterList != NULL );

    //
    // Determine which filter to start notifying at.  If the current filter
    // is INVALID_DLL, then start at the least priority, else start at the
    // least priority filter less than the current filter
    //

    dwOriginalFilter = _dwCurrentFilter;
    if ( _dwCurrentFilter == INVALID_DLL )
    {
        i = pFilterList->QueryFilterCount() - 1;
    }
    else if ( _dwCurrentFilter > 0 )
    {
        i = _dwCurrentFilter - 1;
    }
    else
    {
        //
        // There are no more filters of lower priority.  Bail.
        //
        
        return TRUE;
    }

    do
    {
        pFilterDll = pFilterList->QueryDll( i ); 

        //
        // Notification flags are cached in the HTTP_FILTER object, but they're
        // only copied from the actual HTTP_FILTER_DLL object if a filter dll
        // disables a particular notification [sort of a copy-on-write scheme].
        // If a filter dll disables/changes a notification, we need to check the flags
        // in the HTTP_FILTER object, not those in the HTTP_FILTER_DLL object
        //
        
        if ( !QueryNotificationChanged() )
        {
            if ( !pFilterDll->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA,
                                                    _hfc.fIsSecurePort ) )
            {
                continue;
            }
        }
        else
        {
            if ( !IsDisableNotificationNeeded( i,
                                               SF_NOTIFY_SEND_RAW_DATA ) )
            {
                continue;
            }
        }

        //
        // Another slimy optimization.  If this filter has never associated
        // context with connection, then we don't have to do the lookup
        //
        
        _hfc.pFilterContext = QueryClientContext( i );

        pvtmp = _hfc.pFilterContext;

        //
        // Keep track of the current filter so that we know which filters
        // to notify when a raw filter does a write client
        //
       
        _dwCurrentFilter = i;
        
        sfStatus = (SF_STATUS_TYPE)
                   pFilterDll->QueryEntryPoint()( &_hfc,
                                                  SF_NOTIFY_SEND_RAW_DATA,
                                                  &hfrd );

        if ( pvtmp != _hfc.pFilterContext )
        {
            SetClientContext( i, _hfc.pFilterContext );
            pFilterDll->SetHasSetContextBefore(); 
        }

        switch ( sfStatus )
        {
        default:
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown status code from filter %d\n",
                        sfStatus ));
            //
            //  Fall through
            //

        case SF_STATUS_REQ_NEXT_NOTIFICATION:
            continue;

        case SF_STATUS_REQ_ERROR:
            
            _hfc.pFilterContext = pvCurrentClientContext;
            fRet = FALSE;
            goto Exit;

        case SF_STATUS_REQ_FINISHED:
        case SF_STATUS_REQ_FINISHED_KEEP_CONN:  // Not supported at this point

            *pfFinished = TRUE;
            goto Exit;

        case SF_STATUS_REQ_HANDLED_NOTIFICATION:

            //
            //  Don't notify any other filters
            //

            goto Exit;
        }
    }
    while ( i-- > 0 );

Exit:

    pRawData->pvInData = (BYTE*) hfrd.pvInData;
    pRawData->cbInData = hfrd.cbInData;
    pRawData->cbInBuffer = hfrd.cbInBuffer;
    
    //
    // Reset the filter context we came in with
    //
    
    _hfc.pFilterContext = pvCurrentClientContext;
    
    _dwCurrentFilter = dwOriginalFilter;
    
    return fRet;
}

HRESULT
W3_FILTER_CONTEXT::DisableNotification(
    DWORD                   dwNotification
)
/*++

Routine Description:

    Initialize W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( QueryFilterList() != NULL );

    if ( !_fNotificationsDisabled )
    {
        //
        // All subsequent calls to IsNotificationNeeded() and NotifyFilter() must
        // use local copy of flags to determine action.
        //

        _fNotificationsDisabled = TRUE;

        //
        // Copy notification tables created in the FILTER_LIST objects
        //

        if ( !_BuffSecureArray.Resize( QueryFilterList()->QuerySecureArray()->QuerySize() ) ||
             !_BuffNonSecureArray.Resize( QueryFilterList()->QueryNonSecureArray()->QuerySize() ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        memcpy( _BuffSecureArray.QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QueryPtr(),
                QueryFilterList()->QuerySecureArray()->QuerySize() );

        memcpy( _BuffNonSecureArray.QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QueryPtr(),
                QueryFilterList()->QueryNonSecureArray()->QuerySize() );

    }

    //
    // Disable the appropriate filter in our local table
    //

    ((DWORD*)_BuffSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                        ~dwNotification;
    ((DWORD*)_BuffNonSecureArray.QueryPtr())[ _dwCurrentFilter ] &=
                                                        ~dwNotification;

    //
    // Calculate the aggregate notification status for our local scenario
    // NYI:  Might want to defer this operation?
    //

    _dwSecureNotifications = 0;
    _dwNonSecureNotifications = 0;

    for( DWORD i = 0; i < QueryFilterList()->QueryFilterCount(); i++ )
    {
        _dwSecureNotifications |= ((DWORD*)_BuffSecureArray.QueryPtr())[i];
        _dwNonSecureNotifications |= ((DWORD*)_BuffNonSecureArray.QueryPtr())[i];
    }

    return NO_ERROR;
}

//static
HRESULT
W3_FILTER_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_FILTER_CONTEXT );

    DBG_ASSERT( sm_pachFilterContexts == NULL );
    
    sm_pachFilterContexts = new ALLOC_CACHE_HANDLER( "W3_FILTER_CONTEXT",  
                                                     &acConfig );

    if ( sm_pachFilterContexts == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
W3_FILTER_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate W3_FILTER_CONTEXT lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachFilterContexts != NULL )
    {
        delete sm_pachFilterContexts;
        sm_pachFilterContexts = NULL;
    }
}

HRESULT
GlobalFilterInitialize(
    VOID
)
/*++

Routine Description:

    Overall global filter initialization

Parameters:

    None

Return Value:
    
    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
   
    //
    // Initialize ISAPI filter cache
    //
    
    hr = HTTP_FILTER_DLL::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize HTTP_FILTER_DLL globals.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // Initialize global filter list
    //
    
    hr = FILTER_LIST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize global filter list.  hr = %x\n",
                    hr ));
        HTTP_FILTER_DLL::Terminate();
        
        return hr;
    }
    
    //
    // Initialize W3_FILTER_CONTEXT lookaside
    //
    
    hr = W3_FILTER_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize W3_FILTER_CONTEXT globals.  hr = %x\n",
                    hr ));
        FILTER_LIST::Terminate();
        HTTP_FILTER_DLL::Terminate();
        
        return hr;
    }
    
    return NO_ERROR;
}

VOID
GlobalFilterTerminate(
    VOID
)
/*++

Routine Description:

    Global filter termination

Parameters:

    None

Return Value:
    
    None

--*/
{
    W3_FILTER_CONTEXT::Terminate();
    
    FILTER_LIST::Terminate();
    
    HTTP_FILTER_DLL::Terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3handler.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3handler.cxx

   Abstract:
     Common functionality of all handlers
 
   Author:
     Bilal Alam (balam)             Sept-29-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

CONTEXT_STATUS
W3_HANDLER::MainDoWork(
    VOID
)
/*++

Routine Description:

    Checks access and then calls handler routine

Return Value:

    CONTEXT_STATUS_PENDING if async pending,
    else CONTEXT_STATUS_CONTINUE

--*/
{
    CONTEXT_STATUS          contextStatus;
    BOOL                    fAccessAllowed = FALSE;

    W3_CONTEXT *pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );

    //
    // Check access
    //
    
    contextStatus = pW3Context->CheckAccess( FALSE,     // not a completion
                                             NO_ERROR,
                                             &fAccessAllowed );

    if ( contextStatus == CONTEXT_STATUS_PENDING )
    {
        return CONTEXT_STATUS_PENDING;
    }
    
    //
    // Access check must be complete if we're here
    //
    
    DBG_ASSERT( pW3Context->QueryAccessChecked() );

    if ( !fAccessAllowed )
    {
        //
        // CheckAccess already sent error
        //
        
        return CONTEXT_STATUS_CONTINUE;
    }    
    
    //
    // Now we can execute the handler
    //
    
    return DoWork();
} 

CONTEXT_STATUS
W3_HANDLER::MainOnCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Continue access check if needed, then then when finished, call into
    the handler start
    
    If handler is already started, funnel the completion to the handler

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Status of completion

Return Value:

    CONTEXT_STATUS_PENDING if async pending,
    else CONTEXT_STATUS_CONTINUE

--*/
{
    W3_CONTEXT *            pW3Context;
    CONTEXT_STATUS          contextStatus;
    BOOL                    fAccessAllowed = FALSE;
    
    pW3Context = QueryW3Context();
    DBG_ASSERT( pW3Context != NULL );
    
    if ( !pW3Context->QueryAccessChecked() )
    {
        //
        // If access hasn't been checked completely yet, then we should resume
        // it
        //
        
        contextStatus = pW3Context->CheckAccess( TRUE,      // completion
                                                 dwCompletionStatus,
                                                 &fAccessAllowed );
        
        if ( contextStatus == CONTEXT_STATUS_PENDING )
        {
            return CONTEXT_STATUS_PENDING;
        }
        
        DBG_ASSERT( pW3Context->QueryAccessChecked() );
        
        if ( !fAccessAllowed )
        {
            //
            // CheckAccess already sent error
            //
            
            return CONTEXT_STATUS_CONTINUE;
        }
        
        //
        // Now we can execute the original handler
        //
        
        return DoWork();
    }
    else
    {
        //
        // Access checks have already been made.  This must be a completion
        // for the handler itself
        //
        
        return OnCompletion( cbCompletion,
                             dwCompletionStatus );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3metadata.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3metadata.cxx

   Abstract:
     Code to read metadata and generate W3_METADATA objects
 
   Author:
     Bilal Alam (balam)             23-Jan-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "redirect.hxx"

ALLOC_CACHE_HANDLER * W3_METADATA::sm_pachW3MetaData;

W3_METADATA::W3_METADATA( OBJECT_CACHE * pObjectCache )
    : CACHE_ENTRY            ( pObjectCache ),
      _dwAccessPerm          ( MD_ACCESS_READ ),
      _dwSslAccessPerm       ( 0 ),
      _cbIpAccessCheck       ( 0 ),
      _dwLogonMethod         ( LOGON32_LOGON_INTERACTIVE ),
      _dwVrLevel             ( 0 ),
      _dwVrLen               ( 0 ),
      _pRedirectBlob         ( NULL ),
      _dwDirBrowseFlags      ( MD_DIRBROW_LOADDEFAULT ),
      _dwAuthentication      ( 0 ),
      _dwAuthPersistence     ( 0 ),
      _strUserName           ( _rgUserName, sizeof( _rgUserName ) ),
      _strPasswd             ( _rgPasswd, sizeof( _rgPasswd ) ),
      _strDomainName         ( _rgDomainName, sizeof( _rgDomainName ) ),
      _strRealm              ( _rgRealm, sizeof( _rgRealm ) ),
      _pctVrToken            ( NULL ),
      _pctAnonymousToken     ( NULL ),
      _fCreateProcessAsUser  ( TRUE ),
      _fCreateProcessNewConsole ( FALSE ),
      _fDoStaticCompression  ( HTTP_COMPRESSION::QueryDoStaticCompression() ),
      _fDoDynamicCompression ( HTTP_COMPRESSION::QueryDoDynamicCompression() ),
      _dwCGIScriptTimeout    ( DEFAULT_SCRIPT_TIMEOUT ),
      _ScriptMap             (),
      _pMimeMap              ( NULL ),
      _fIgnoreTranslate      ( FALSE ),
      _fSSIExecDisabled      ( FALSE ),
      _fVrPassThrough        ( FALSE ),
      _fDontLog              ( FALSE ),
      _fFooterEnabled        ( FALSE ),
      _dwExpireMode          ( EXPIRE_MODE_NONE ),
      _fHaveNoCache          ( FALSE ),
      _fHaveMaxAge           ( FALSE ),
      _fDoReverseDNS         ( FALSE ),
      _cbEntityReadAhead     ( DEFAULT_ENTITY_READ_AHEAD ),
      _fNoCache              ( FALSE ),
      _fDisableDav           ( FALSE ),
      _dwAppIsolated         ( 0 ),
      _dwAppOopRecoverLimit  ( 0 )
{
    //
    // Hmmm, since most of these values aren't getting initialized, if
    // somebody went and deleted all the metadata items from the tree, 
    // then bad things could happen.  We should initialize with defaults 
    // things that might screw us
    //
    
    _dirmonConfig.hToken = NULL;
    _dirmonConfig.pszDirPath = NULL;
}

W3_METADATA::~W3_METADATA()
{
    if ( _pctVrToken != NULL )
    {
        _pctVrToken->DereferenceCacheEntry();
        _pctVrToken = NULL;
    }   
    
    if ( _pctAnonymousToken != NULL )
    {
        _pctAnonymousToken->DereferenceCacheEntry();
        _pctAnonymousToken = NULL;
    }

    if ( _pMimeMap )
    {
        delete _pMimeMap;
        _pMimeMap = NULL;
    }

    if (_pRedirectBlob)
    {
        delete _pRedirectBlob;
        _pRedirectBlob = NULL;
    }

    DBG_ASSERT(CheckSignature());
}

//static
HRESULT
W3_METADATA::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize metadata lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( W3_METADATA );

    DBG_ASSERT( sm_pachW3MetaData == NULL );
    
    sm_pachW3MetaData = new ALLOC_CACHE_HANDLER( "W3_METADATA",  
                                                  &acConfig );

    if ( sm_pachW3MetaData == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachW3MetaData. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_METADATA::Terminate(
    VOID
)
{
    if ( sm_pachW3MetaData != NULL )
    {
        delete sm_pachW3MetaData;
        sm_pachW3MetaData = NULL;
    }
}

//
//  Private constants.
//

#define DEFAULT_MD_RECORDS          40
#define DEFAULT_RECORD_SIZE         50

# define DEF_MD_REC_SIZE   ((1 + DEFAULT_MD_RECORDS) * \
                            (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))

HRESULT
W3_METADATA::ReadMetaData(
    const STRU & strMetabasePath,
    const STRU & strURL
)
/*++

Routine Description:

    Reads the metabase (directly) to get the metadata for the given URL

Arguments:

    strMetabasePath - The preceding service/instance goo (like "LM/W3SVC/1/ROOT" )
    strURL - URL in question
    
Return Value:

    HRESULT

--*/
{
    PMETADATA_GETALL_RECORD    pMDRecord;
    DWORD               dwNumMDRecords;
    DWORD               dwNumWamRecords;
    BYTE                tmpBuffer[ DEF_MD_REC_SIZE];
    BYTE                tmpWamBuffer[ DEF_MD_REC_SIZE];
    BUFFER              TempBuff( tmpBuffer, DEF_MD_REC_SIZE);
    BUFFER              WamBuff( tmpWamBuffer, DEF_MD_REC_SIZE);
    DWORD               i;
    DWORD               dwDataSetNumber;
    DWORD               dwWamDataSetNumber;
    WCHAR               ch;
    LPWSTR              pszInVr;
    LPWSTR              pszMinInVr;
    LPWSTR              pszURL;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    BYTE                tmpPrivateBuffer[ 20 ];
    BUFFER              PrivateBuffer( tmpPrivateBuffer, 20 );
    DWORD               dwPrivateBufferUsed;
    MB                  mb( g_pW3Server->QueryMDObject() );
    MB *                pmb = &mb;
    HRESULT             hr = NO_ERROR;
    WCHAR *             pszVrUserName = NULL;
    WCHAR *             pszVrPasswd = NULL;
    HANDLE              hVrToken = NULL;
    WCHAR *             pszStart = NULL;
    DWORD               cchLength = 0;

    //
    // We lie about modifying the input path
    //
    pszURL = (LPWSTR)strURL.QueryStr();
    DBG_ASSERT( pszURL != NULL );

    DBG_ASSERT( TempBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))
                );

    DBG_ASSERT( WamBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_GETALL_RECORD) + DEFAULT_RECORD_SIZE))
                );

    //
    // Read the metabase
    //

    if ( !pmb->Open( strMetabasePath.QueryStr() ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    //
    // Get the UT_FILE info
    //

    if ( !pmb->GetAll( pszURL,
                       METADATA_INHERIT | METADATA_PARTIAL_PATH,
                       IIS_MD_UT_FILE,
                       &TempBuff,
                       &dwNumMDRecords,
                       &dwDataSetNumber ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    //
    // Get the UT_WAM info
    //

    if ( !pmb->GetAll( pszURL,
                       METADATA_INHERIT | METADATA_PARTIAL_PATH,
                       IIS_MD_UT_WAM,
                       &WamBuff,
                       &dwNumWamRecords,
                       &dwWamDataSetNumber ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failure;
    }

    //
    // Both sets of data better have the same data set number
    //

    DBG_ASSERT( dwDataSetNumber == dwWamDataSetNumber );

    //
    // Set the data set number, so that this object is metadata cachable
    //
    
    _cacheKey.SetDataSetNumber( dwDataSetNumber );
   
    //
    // Grok the buffer containing all the records
    //

    pMDRecord = (PMETADATA_GETALL_RECORD)TempBuff.QueryPtr();

    i = 0;

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + wcslen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = L'\0';
            dwNeed = 0;
            if ( !pmb->GetString( pszURL, 
                                  MD_VR_PATH, 
                                  IIS_MD_UT_FILE, 
                                  NULL, 
                                  &dwNeed, 
                                  0 ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                *pszInVr = ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = ch;

            if ( ch )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr--;
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != L'/' && *pszInVr != L'\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr--;
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    // Close this now to minimize lock contention.
    DBG_REQUIRE(pmb->Close());

    for ( dwL = 0 ; pszMinInVr < pszInVr - 1 ; pszMinInVr++ )
    {
        if ( *pszMinInVr == L'/' || *pszMinInVr == L'\\' )
        {
            ++dwL;
        }
    }
    
    //
    // Now walk through the array of returned metadata objects and format
    // each one into our predigested form.
    //
    
    _dwVrLevel = dwL;
    _dwVrLen = dwVRLen;
    
    dwPrivateBufferUsed = 0;

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;

        pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch ( pMDRecord->dwMDIdentifier )
        {

        case MD_DAV_ENABLED:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDisableDav = !*((DWORD *) pDataPointer );
            break;

        case MD_FOOTER_DOCUMENT:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (FAILED(hr = ReadCustomFooter((WCHAR *)pDataPointer)))
            {
                goto Failure;
            }

            break;

        case MD_FOOTER_ENABLED:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fFooterEnabled = !!*((DWORD *) pDataPointer );

            if ( _fFooterEnabled )
            {
                //
                // If we have footers for a static file, we cannot do static
                // compression on it
                //
                
                _fDoStaticCompression = FALSE;
            }
            break;

        case MD_HTTP_EXPIRES:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (FAILED(hr = SetExpire((WCHAR *)pDataPointer)))
            {
                goto Failure;
            }
            break;

        case MD_CC_NO_CACHE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (*(BOOL *)pDataPointer)
            {
                _fHaveNoCache = TRUE;
            }
            break;

        case MD_CC_MAX_AGE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _dwMaxAge = *(DWORD *)pDataPointer;
            _fHaveMaxAge = TRUE;
            break;

        case MD_CC_OTHER:
            if (pMDRecord->dwMDDataType != STRING_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (FAILED(hr = _strCacheControlHeader.CopyWTruncate((WCHAR *)pDataPointer)))
            {
                goto Failure;
            }
            break;

        case MD_HTTP_REDIRECT:
        {
            if (pMDRecord->dwMDDataType != STRING_METADATA && 
                pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            STACK_STRU( strRealSource, MAX_PATH );
            STACK_STRU( strDestination, MAX_PATH );

            if (FAILED(hr = strDestination.Copy((WCHAR *)pDataPointer)) ||
                FAILED(hr = GetTrueRedirectionSource(
                                pszURL,
                                strMetabasePath.QueryStr(),
                                (WCHAR *)pDataPointer,
                                pMDRecord->dwMDDataType == STRING_METADATA,
                                &strRealSource)) ||
                FAILED(hr = SetRedirectionBlob(strRealSource,
                                               strDestination)))
            {
                goto Failure;
            }

            if (pMDRecord->dwMDDataType == MULTISZ_METADATA)
            {
                //
                // Have some conditional headers, add them now.
                //

                if (FAILED(hr = QueryRedirectionBlob()->SetConditionalHeaders(
                    (WCHAR *)pDataPointer + wcslen((WCHAR *)pDataPointer) + 1)
                    ))
                {
                    goto Failure;
                }

            }

            break;
        }

        case MD_DONT_LOG:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDontLog = *(BOOL *)pDataPointer;
            break;

        case MD_CREATE_PROCESS_AS_USER:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fCreateProcessAsUser = *(BOOL *)pDataPointer;
            break;

        case MD_CREATE_PROC_NEW_CONSOLE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fCreateProcessNewConsole = *(BOOL *)pDataPointer;
            break;

        case MD_SCRIPT_TIMEOUT:
            if (pMDRecord->dwMDDataType != DWORD_METADATA) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _dwCGIScriptTimeout = *(DWORD *)pDataPointer;
            break;

        case MD_MIME_MAP:
            if (pMDRecord->dwMDDataType != MULTISZ_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            if (*(WCHAR *)pDataPointer)
            {
                _pMimeMap = new MIME_MAP((WCHAR *)pDataPointer);
                if (_pMimeMap == NULL)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                    goto Failure;
                }
            }
            break;

        case MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDoDynamicCompression = *(BOOL *)pDataPointer;
            break;

        case MD_HC_DO_NAMESPACE_STATIC_COMPRESSION:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fDoStaticCompression = *(BOOL *)pDataPointer;
            break;

        case MD_VR_IGNORE_TRANSLATE:
            if (pMDRecord->dwMDDataType != DWORD_METADATA)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Failure;
            }

            _fIgnoreTranslate = *(DWORD*) pDataPointer;
            break;

        case MD_ANONYMOUS_USER_NAME:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strUserName.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_ANONYMOUS_PWD:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strPasswd.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }
            break;

        case MD_DEFAULT_LOGON_DOMAIN:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strDomainName.Copy(
                                   (WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }
            break;

        case MD_HTTP_PICS:
        case MD_HTTP_CUSTOM:

            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            // 
            // Copy all the specified headers into our header buffer
            //
            
            pszStart = (WCHAR*) pDataPointer;
            while ( *pszStart != L'\0' )
            {
                cchLength = wcslen( pszStart );
                
                hr = _strCustomHeaders.AppendW( pszStart );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                hr = _strCustomHeaders.Append( "\r\n", 2 );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                pszStart += ( cchLength + 1 );
            }
            break;

        case MD_LOGON_METHOD:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            //
            // The MD_LOGON_METHOD values in the metabase don't match 
            // the NT logon values, so we'll convert them
            //
            switch ( *((DWORD *) pDataPointer ) )
            {
            case MD_LOGON_BATCH:
                _dwLogonMethod = LOGON32_LOGON_BATCH;
                break;

            case MD_LOGON_INTERACTIVE:
                _dwLogonMethod = LOGON32_LOGON_INTERACTIVE;
                break;

            case MD_LOGON_NETWORK:
                _dwLogonMethod = LOGON32_LOGON_NETWORK;
                break;
                
            case MD_LOGON_NETWORK_CLEARTEXT:
                _dwLogonMethod = LOGON32_LOGON_NETWORK_CLEARTEXT;
                break;

            default:
                break;
            }

            break;

        case MD_AUTHORIZATION:
            if( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAuthentication = *((DWORD *) pDataPointer );            
            break;

        case MD_REALM:
            if( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            if( FAILED( hr = _strRealm.Copy( ( WCHAR* )pDataPointer ) ) )
            {
                goto Failure;
            }

            break;

        case MD_NTAUTHENTICATION_PROVIDERS:
            if( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = BuildProviderList( ( WCHAR* )pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            break;

        case MD_AUTHORIZATION_PERSISTENCE:
            if( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAuthPersistence = *((DWORD *) pDataPointer );
            break;

        case MD_IP_SEC:
            if( pMDRecord->dwMDDataType != BINARY_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            if ( pMDRecord->dwMDDataLen )
            { 
                hr = SetIpAccessCheck( pDataPointer,
                                       pMDRecord->dwMDDataLen );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
            }

            break;

        case MD_ACCESS_PERM:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwAccessPerm = *((DWORD*) pDataPointer);
            break;

        case MD_SSL_ACCESS_PERM:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _dwSslAccessPerm = *((DWORD*)pDataPointer) & MD_SSL_ACCESS_MASK;
            break;

        case MD_VR_PATH:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strVrPath.Copy((WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }
            break;

        case MD_APP_ROOT:
            
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            if ( FAILED( hr = _strAppMetaPath.Copy((WCHAR *)pDataPointer) ) )
            {
                goto Failure;
            }

            break;

        case MD_VR_USERNAME:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            pszVrUserName = ( WCHAR * )pDataPointer;

            break;

        case MD_VR_PASSWORD:
            if ( pMDRecord->dwMDDataType != STRING_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            pszVrPasswd = ( WCHAR * )pDataPointer;

            break;

        case MD_VR_PASSTHROUGH:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fVrPassThrough = !!*((DWORD *) pDataPointer );

            break;

        case MD_REDIRECT_HEADERS:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA ) 
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
           
            // 
            // Copy all the specified headers into our header buffer
            //
            
            pszStart = (WCHAR*) pDataPointer;
            while ( *pszStart != L'\0' )
            {
                cchLength = wcslen( pszStart );
                
                hr = _strRedirectHeaders.AppendW( pszStart );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                hr = _strRedirectHeaders.Append( "\r\n", 2 );
                if ( FAILED( hr ) )
                {
                    goto Failure;
                }
                
                pszStart += ( cchLength + 1 );
            }
            break;
            
        case MD_DIRECTORY_BROWSING:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            _dwDirBrowseFlags = *((DWORD *) pDataPointer );
            break;
            
        case MD_DEFAULT_LOAD_FILE:
            if ( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            hr = _strDefaultLoad.Copy( (WCHAR*) pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
            break;
        
        case MD_SCRIPT_MAPS:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = _ScriptMap.Initialize( (WCHAR *)pDataPointer );

            if( FAILED(hr) )
            {
                goto Failure;
            }
            break;
        
        case MD_CUSTOM_ERROR:
            if ( pMDRecord->dwMDDataType != MULTISZ_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            //
            // An empty string means use hard-coded errors
            //
            
            if ( *((WCHAR*)pDataPointer) == L'\0' )
            {
                break; 
            }
            
            hr = _customErrorTable.BuildTable( (WCHAR*) pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }
            break;

        case MD_SSI_EXEC_DISABLED:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fSSIExecDisabled = !!*( ( DWORD * ) pDataPointer );
            break;

        case MD_DO_REVERSE_DNS:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fDoReverseDNS = !!*((DWORD*)pDataPointer);
            break;
           
        case MD_UPLOAD_READAHEAD_SIZE:
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _cbEntityReadAhead = *(DWORD*)pDataPointer;
            break;
            
        case MD_APPPOOL_APPPOOL_ID:
            
            if ( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            hr = _strAppPoolId.Copy( (WCHAR*) pDataPointer );
            if ( FAILED( hr ) )
            {
                goto Failure;
            }

            break;

        case MD_VR_NO_CACHE:
        
            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }
            
            _fNoCache = !!*((DWORD*)pDataPointer);
            break;
            
        default:
            // BUGBUGBUG
            DBG_ASSERT(CheckSignature());
            break;
        }
    }

    //
    // Walk through the WAM data
    //

    pMDRecord = (PMETADATA_GETALL_RECORD)WamBuff.QueryPtr();

    i = 0;

    for ( ; i < dwNumWamRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;

        pDataPointer = (PVOID) ((PCHAR)WamBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        DBG_ASSERT(pMDRecord->dwMDDataTag == 0);

        switch ( pMDRecord->dwMDIdentifier )
        {
        case MD_APP_ISOLATED:

            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            _dwAppIsolated = *(DWORD*)pDataPointer;

            break;

        case MD_APP_WAM_CLSID:

            if ( pMDRecord->dwMDDataType != STRING_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            hr = _strWamClsId.Copy( (WCHAR*)pDataPointer );

            break;

        case MD_APP_OOP_RECOVER_LIMIT:

            if ( pMDRecord->dwMDDataType != DWORD_METADATA )
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
                goto Failure;
            }

            _dwAppOopRecoverLimit = *(DWORD*)pDataPointer;

            break;

        default:
            break;
        }
    }

    //
    // If no-cache, max-age or a dynamic expires directive is present, add
    // it to Cache-Control header
    //
    if (FAILED(hr = SetCacheControlHeader()))
    {
        goto Failure;
    }

    if ( _strVrPath.IsEmpty() )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReadMetaData] Virtual Dir Path mapping not found\n" ));
                    
        hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );    
        goto Failure;
    }

    //
    // If this is an UNC share, logon using associated credentials
    // keep a reference to this access token in the cache
    //
    
    if ( _strVrPath.QueryStr()[0] == L'\\' &&
         _strVrPath.QueryStr()[1] == L'\\' )
    {
        if ( pszVrUserName != NULL && pszVrPasswd != NULL &&
             pszVrUserName[0] )
        {
            hr = CreateUNCVrToken( pszVrUserName, pszVrPasswd );
            if( FAILED( hr ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                       "Error logging on the UNC account. hr = 0x%x.\n",
                       hr ));

                goto Failure;
            }
        }
    }
    
    //
    // Setup the dirmon configuration
    //

    if ( _pctVrToken != NULL )
    {
        _dirmonConfig.hToken = _pctVrToken->QueryImpersonationToken();
    }
    else
    {
        _dirmonConfig.hToken = NULL;
    }   
    _dirmonConfig.pszDirPath = _strVrPath.QueryStr();
    
    //
    // Get anonymous user token
    //
    
    hr = CreateAnonymousToken( _strUserName.QueryStr(),
                               _strPasswd.QueryStr() );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    DBG_ASSERT( CheckSignature() );

    return S_OK;

Failure:
    return hr;
}

HRESULT
W3_METADATA::BuildPhysicalPath(
    STRU &          strUrl,
    STRU *          pstrPhysicalPath
)
/*++

Routine Description:

    From the current metadata, convert a URL to a physical path 
    (using the MD_VR_ROOT property and inheritance level calculated on read)

Arguments:

    strUrl - Virtual path
    pstrPhysicalPath - String filled with physical path of strURL
    
Return Value:

    BOOL

--*/
{
    LPWSTR              pszInVr;
    DWORD               dwL;
    WCHAR               ch;
    HRESULT             hr = S_OK;

    DBG_ASSERT(CheckSignature());

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //


    //
    // skip the URI components used to locate the virtual root
    //

    pszInVr = strUrl.QueryStr();
    dwL = _dwVrLevel;
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == L'/' || *pszInVr == L'\\' );

            ++pszInVr;

            while ( (ch = *pszInVr) && ch != L'/' && ch !=L'\\' )
            {
                pszInVr++;
            }
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );

    if ( FAILED(hr = pstrPhysicalPath->Copy( _strVrPath ) ) )
    {
        return hr;
    }

    //
    // Add a path delimiter char between virtual root mount point & significant part of URI
    //

    if ( pstrPhysicalPath->QueryCCH() )
    {
        ch = pstrPhysicalPath->QueryStr()[ pstrPhysicalPath->QueryCCH() - 1 ];
        if ( (ch == L'/' || ch == L'\\') && *pszInVr )
        {
            ++pszInVr;
        }
    }

    if ( FAILED(hr = pstrPhysicalPath->Append( pszInVr ) ) )
    {
        return hr;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrPhysicalPath->QueryStr() );

    return NO_ERROR;
}

HRESULT
W3_METADATA::BuildProviderList(
    IN WCHAR *                  pszProviders
    )
/*++

  Description:

    Builds a name array of SSPI Authentication providers

  Arguments:

    pszProviders - Comma separated list of providers

  Returns:

    HRESULT

--*/
{
    WCHAR *             pszCursor; 
    WCHAR *             pszEnd;
    HRESULT             hr;
    BOOL                fFinished = FALSE;
    
    DBG_ASSERT(CheckSignature());

    if ( pszProviders == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Parse comma delimited list of providers, removing white space
    //
    
    pszCursor = SkipWhite( pszProviders );
    for( ; ; )
    {
        pszEnd = wcschr( pszCursor, L',' );
        if ( pszEnd == NULL )
        {
            fFinished = TRUE;
            pszEnd = pszCursor + wcslen( pszCursor );
        }
        
        while ( pszEnd > pszCursor )
        {
            if ( !ISWHITEW( *pszEnd ) )
            {
                break;
            }
            pszEnd--;
        }
        
        *pszEnd = L'\0';
        
        if ( !_mstrAuthProviders.AppendW( pszCursor ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        if ( fFinished )
        {
            break;
        }
        
        //
        // Advance to next provider
        //
        
        pszCursor = SkipWhite( pszEnd + 1 );
    }

    return NO_ERROR;
}    
     
BOOL 
W3_METADATA::CheckAuthProvider(
    IN CHAR *              pszPkgName
    ) 
/*++

  Description:

    Check if we support the SSP package of name pszPkgName

  Arguments:

    pszPkgName - Name of the package we check against 

  Returns:

    TRUE if we support the package, FALSE if we don't.

--*/
{
    const CHAR *          pszProvider;
    
    DBG_ASSERT( CheckSignature() );
    
    if ( pszPkgName == NULL )
    {
        DBG_ASSERT( FALSE );
        return FALSE;
    }

    pszProvider = _mstrAuthProviders.First();
    while ( pszProvider != NULL )
    {
        if ( _stricmp( pszPkgName, pszProvider ) == 0 )
        {
            return TRUE;
        }
        pszProvider = _mstrAuthProviders.Next( pszProvider );
    }
    
    return FALSE;
} 
    
HRESULT
W3_METADATA::CreateUNCVrToken( 
    IN LPWSTR       pszUserName,
    IN LPWSTR       pszPasswd
    )
/*++

  Description:

    Logon the user account for the UNC virtual path

  Arguments:

    pszUserName - User name of the account in format domain\username
    pszPasswd   - Passwd of the account

  Returns:

    HRESULT

--*/
{
    STACK_STRU(             strUserName, UNLEN + 1 );
    STACK_STRU(             strDomainName, IIS_DNLEN + 1 );
    // add 1 to strUserDomain for separator "\"
    STACK_STRU(             strUserDomain, UNLEN + IIS_DNLEN + 1 + 1);
    HRESULT                 hr;
    DWORD                   dwError;
    BOOL                    fPossibleUPNLogon = FALSE;
    
    hr = strUserDomain.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomain,
                                                   &strUserName,
                                                   &strDomainName,
                                                   QueryDomainName(),
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken( 
                                                    strUserName.QueryStr(),
                                                    strDomainName.QueryStr(),
                                                    pszPasswd,
                                                    QueryLogonMethod(),
                                                    fPossibleUPNLogon,
                                                    &_pctVrToken,
                                                    &dwError );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_METADATA::CreateAnonymousToken( 
    IN LPWSTR       pszUserName,
    IN LPWSTR       pszPasswd
    )
/*++

  Description:

    Logon the user account for the UNC virtual path

  Arguments:

    pszUserName - User name of the account in format domain\username
    pszPasswd   - Passwd of the account

  Returns:

    HRESULT

--*/
{
    STACK_STRU(             strUserName, UNLEN );
    STACK_STRU(             strDomainName, IIS_DNLEN );
    // add 1 to strUserDomain for separator "\"
    STACK_STRU(             strUserDomain, UNLEN + IIS_DNLEN + 1 );
    HRESULT                 hr;
    DWORD                   dwLogonError;
    BOOL                    fPossibleUPNLogon = FALSE;
    
    hr = strUserDomain.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_STATE_AUTHENTICATION::SplitUserDomain( strUserDomain,
                                                   &strUserName,
                                                   &strDomainName,
                                                   QueryDomainName(),
                                                   &fPossibleUPNLogon );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    DBG_ASSERT( g_pW3Server->QueryTokenCache() != NULL );
    
    hr = g_pW3Server->QueryTokenCache()->GetCachedToken( 
                                                    strUserName.QueryStr(),
                                                    strDomainName.QueryStr(),
                                                    pszPasswd,
                                                    QueryLogonMethod(),
                                                    fPossibleUPNLogon,
                                                    &_pctAnonymousToken,
                                                    &dwLogonError );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_METADATA::SetIpAccessCheck( 
    LPVOID   pMDData, 
    DWORD    dwDataLen
)
/*++

  Description:

    Store away the IP DNS list

  Arguments:

    pMDData - Beginning of binary blob to store
    dwDataLen - Length of binary data

  Returns:

    HRESULT

--*/
{
    if ( !_buffIpAccessCheck.Resize( dwDataLen ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    memcpy( _buffIpAccessCheck.QueryPtr(),
            pMDData,
            dwDataLen );
   
    _cbIpAccessCheck = dwDataLen;
    
    return NO_ERROR;
}

HRESULT 
W3_METADATA::ReadCustomFooter(
    WCHAR *                 pszFooter
)
/*++

Routine Description:

    Process a footer string, either reading the file or copying the string
    to the buffer.

Arguments:

    pszFooter - The footer string, which may be a string or a file name.
    It looks like "STRING : some-string" or "FILE : file-name"

Returns:

    HRESULT

--*/
{
    HRESULT             hr;
    STACK_STRU(         strFooter, MAX_PATH );
    BOOL                fFooterIsString = FALSE;
    
    // First thing to do is to determine if this is a string or a file name.
    // Skip preceding whitespace and then strcmp.

    while (iswspace(*pszFooter))
    {
        pszFooter++;
    }

    if (!_wcsnicmp(pszFooter, L"STRING", 6))
    {
        fFooterIsString = TRUE;
        pszFooter += 6;
    }
    else if (!_wcsnicmp(pszFooter, L"FILE", 4))
    {
        fFooterIsString = FALSE;
        pszFooter += 4;
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // Now we look for 0 or more white space, followed by a colon, followed by
    // more white space.

    while (iswspace(*pszFooter))
    {
        pszFooter++;
    }

    if (*pszFooter != L':')
    {
        // No colon seperator, error.
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    pszFooter++;

    //
    // OK, now if this is a string we take everything after the colon to the
    // end for the string. If this is a file name then we'll open and read the
    // file.
    //
    if (fFooterIsString)
    {
        return _strFooterString.CopyW(pszFooter);
    }
    else
    {
        //
        // For files, we'll skip any more white space before the name.
        //
        while (iswspace(*pszFooter))
        {
            pszFooter++;
        }
        
        hr = _strFooterDocument.Copy( pszFooter );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT W3_METADATA::SetExpire(WCHAR *pszExpire)
/*++

Routine Description:

    Set the expire header to be used on all responses

Arguments:

    pszExpire: the string containing the description.  It could have the form
    "n" : no expire
    "s, some-date" : expire on this date"
    "d, some-number" : expire after this many seconds

Returns:

    HRESULT

--*/
{
    while (iswspace(*pszExpire))
    {
        pszExpire++;
    }

    LPWSTR pszParam;
    if ((pszParam = wcschr(pszExpire, L',')) == NULL)
    {
        if (*pszExpire == L'\0' ||
            *pszExpire == L'n' ||
            *pszExpire == L'N')
        {
            _dwExpireMode = EXPIRE_MODE_OFF;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    pszParam++;
    while (iswspace(*pszParam))
    {
        pszParam++;
    }

    HRESULT hr;
    switch (*pszExpire)
    {
    case L's':
    case L'S':
        if (FAILED(hr = _strExpireHeader.CopyWTruncate(pszParam)))
        {
            return hr;
        }
        _dwExpireMode = EXPIRE_MODE_STATIC;
        break;

    case L'd':
    case L'D':
        LPWSTR endPtr;
        DWORD dwExpire;

        if (pszParam[0] == L'0' && pszParam[1] == L'x')
        {
            dwExpire = wcstoul(pszParam + 2, &endPtr, 16);
        }
        else
        {
            dwExpire = wcstoul(pszParam, &endPtr, 10);
        }

        if (!iswspace(*endPtr) &&
            *endPtr != L'\0')
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        if (dwExpire != ULONG_MAX)
        {
            if (dwExpire > MAX_GLOBAL_EXPIRE)
            {
                dwExpire = MAX_GLOBAL_EXPIRE;
            }

            _dwExpireMode = EXPIRE_MODE_DYNAMIC;
            _dwExpireDelta = dwExpire;
        }
        break;

    case L'n':
    case L'N':
        _dwExpireMode = EXPIRE_MODE_OFF;
        break;

    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return S_OK;
}

HRESULT W3_METADATA::SetCacheControlHeader()
/*++

Routine Description:

    If no-cache, max-age or a dynamic expires directive is present, add
    it to Cache-Control header

Arguments:

    None

Returns:

    HRESULT

--*/
{
    switch (QueryExpireMode())
    {
    case EXPIRE_MODE_NONE:
        _fHaveNoCache = FALSE;
        _fHaveMaxAge = FALSE;
        break;

    case EXPIRE_MODE_DYNAMIC:
        // If we have a dynamic Expires header, create a max-age directive
        if (_dwExpireDelta != 0)
        {
            _fHaveNoCache = FALSE;
            if (!_fHaveMaxAge)
            {
                _fHaveMaxAge = TRUE;
                _dwMaxAge = _dwExpireDelta;
            }
        }
        else
        {
            _fHaveNoCache = TRUE;
            _fHaveMaxAge = FALSE;
        }
        break;

    default:
        break;
    }

    BOOL fHaveCCHeader = !_strCacheControlHeader.IsEmpty();
    HRESULT hr;
    if (_fHaveNoCache)
    {
        if (FAILED(hr = _strCacheControlHeader.Append(
                             fHaveCCHeader ? ",no-cache" : "no-cache")))
        {
            return hr;
        }
    }
    else if (_fHaveMaxAge)
    {
        CHAR pszMaxAgeBuffer[16];
        _itoa(_dwMaxAge, pszMaxAgeBuffer, 10);

        if (FAILED(hr = _strCacheControlHeader.Append(
                             fHaveCCHeader ? ",max-age=" : "max-age=")) ||
            FAILED(hr = _strCacheControlHeader.Append(pszMaxAgeBuffer)))
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT
META_SCRIPT_MAP::Initialize( 
    IN WCHAR * szScriptMapData
    )
/*++

Routine Description:

    Initialize the collection of META_SCRIPT_MAP_ENTRIES from the 
    metadata.

    This routine will modify the multisz it works with (by replacing 
    some ',' with '\0' ).
    
    Currently it modifies the in parameter, which is kindof icky. 
    We could avoid this by copying the buffer.

Arguments:
    
    szScriptMapData - A multi-sz of script map entries. 

    
Return Value:

Notes:

    Script map is a multi-sz with each string being a comma separated list
    <extension>,<executable>,<flags>,<verb list>

    <extension>:
      .xyz  - Maximum of 128 characters
      *     - Star script map - routes all requests though the executable

    <executable>
        - Extension to invoke

    <flags>:
      1     - Allow run in script access directory ( MD_SCRIPTMAPFLAG_SCRIPT )
      4 - Check for pathinfo file ( MD_SCRIPTMAPFLAG_CHECK_PATH_INFO )

    <verb list>:
      <verb>,<verb>,<verb>
        - Allowed verbs
        - If no verbs are listed, a value of "all verbs" is assumed. 

--*/
{
    DBG_ASSERT( szScriptMapData );

    HRESULT     hr = NOERROR;

    // Iterate over multisz
    WCHAR *     pszEntryIterator;
    
    // Current mapping
    WCHAR *     pszExtension;
    WCHAR *     pszExecutable;
    WCHAR *     pszFlags;
    DWORD       Flags;
    WCHAR *     pszVerbs;
    DWORD       cchVerbs;

    //
    // Iterate over each mapping
    //

    pszEntryIterator = szScriptMapData;
    while( *pszEntryIterator != L'\0' )
    {
        //
        // Get the extension
        //

        pszExtension = pszEntryIterator;

        //
        // Get the executable
        //
        
        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        *pszEntryIterator++ = L'\0';

        pszExecutable = pszEntryIterator;

        if( pszExecutable == L'\0' )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        //
        // Get the flags
        //
        
        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator == NULL )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            return hr;
        }

        *pszEntryIterator++ = L'\0';

        //
        // We don't need pszFlags here, but we will need it if
        // there is an empty verb list, to reset our iterator.
        //
        pszFlags = pszEntryIterator;

        Flags = wcstoul( pszFlags, NULL, 10 );

        //
        // Get the verbs
        //

        pszEntryIterator = wcschr( pszEntryIterator, L',' );
        if( pszEntryIterator != NULL )
        {
            //
            // There is a list of verbs
            //

            *pszEntryIterator++ = L'\0';

            pszVerbs = pszEntryIterator;
        
            //
            // Format verb list as a multi-sz for each entry
            //

            cchVerbs = 1;

            while( *pszEntryIterator != L'\0')
            {
                if( *pszEntryIterator == L',' )
                {
                    *pszEntryIterator = L'\0';
                }

                cchVerbs++;

                pszEntryIterator++;
            }
        }
        else
        {
            //
            // Empty Verb List
            //

            //
            // We've lost our iterator so we need to get it back.
            // Point to the terminator.
            //
            pszEntryIterator = pszFlags + wcslen( pszFlags );
            
            pszVerbs = pszEntryIterator;
            cchVerbs = 1;
        }


        //
        // Create and add the entry object to our list
        //
    
        META_SCRIPT_MAP_ENTRY * 
            pNewEntry = new META_SCRIPT_MAP_ENTRY();

        if( pNewEntry == NULL )
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        hr = pNewEntry->Create( pszExtension,
                                pszExecutable,
                                Flags,
                                pszVerbs,
                                cchVerbs
                                );
        if( FAILED(hr) )
        {
            delete pNewEntry;
            return hr;
        }

        if (pNewEntry->QueryIsStarScriptMap())
        {
            if (m_StarScriptMapEntry != NULL)
            {
                delete m_StarScriptMapEntry;
            }
            m_StarScriptMapEntry = pNewEntry;
        }
        else
        {
            InsertTailList( &m_ListHead, &pNewEntry->m_ListEntry );       
        }
        
        //
        // Move to the next entry.
        //
        pszEntryIterator++;      
    }

    return hr;
}

BOOL
META_SCRIPT_MAP::FindEntry(
    IN  const STRU &              strExtension,
    OUT META_SCRIPT_MAP_ENTRY * * ppScriptMapEntry
    )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    *ppScriptMapEntry = NULL;

    PLIST_ENTRY             pEntry;
    META_SCRIPT_MAP_ENTRY * pScriptMapEntry = NULL;

    for( pEntry  = m_ListHead.Flink;
         pEntry != &m_ListHead;
         pEntry  = pEntry->Flink )
    {
        pScriptMapEntry = CONTAINING_RECORD( pEntry, 
                                             META_SCRIPT_MAP_ENTRY, 
                                             m_ListEntry 
                                             );

        if( strExtension.Equals( pScriptMapEntry->m_strExtension ) )
        {
            *ppScriptMapEntry = pScriptMapEntry;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
META_SCRIPT_MAP::Terminate( VOID )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    if (m_StarScriptMapEntry != NULL)
    {
        delete m_StarScriptMapEntry;
        m_StarScriptMapEntry = NULL;
    }

    META_SCRIPT_MAP_ENTRY * pScriptMapEntry;

    while( !IsListEmpty( &m_ListHead ) )
    {
        pScriptMapEntry = CONTAINING_RECORD(  m_ListHead.Flink,
                                              META_SCRIPT_MAP_ENTRY,
                                              m_ListEntry );

        RemoveEntryList( &pScriptMapEntry->m_ListEntry );

        delete pScriptMapEntry;
    }
}

HRESULT
META_SCRIPT_MAP_ENTRY::Create(
    IN const WCHAR * szExtension,
    IN const WCHAR * szExecutable,
    IN DWORD         Flags,
    IN const WCHAR * szVerbs,
    IN DWORD         cchVerbs
    )
/*++

Routine Description:

Arguments:
    
Return Value:

--*/
{
    HRESULT hr = NOERROR;
    DWORD cchExecutable;

    //
    // Capture initialization parameters
    //

    m_Flags = Flags;

    hr = m_strExtension.Copy( szExtension );
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Lower-case to allow for case insensitive comparisons
    //
    _wcslwr( m_strExtension.QueryStr() );
    
    if (szExtension[0] == L'*' && szExtension[1] == L'\0')
    {
        m_fIsStarScriptMapEntry = TRUE;
    }

    //
    // We treat the executable name as an ExpandSz, so expand it
    //
    WCHAR szExpand[MAX_PATH + 1];
    if (!ExpandEnvironmentStrings(szExecutable,
                                  szExpand,
                                  sizeof szExpand/sizeof WCHAR))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (FAILED(hr = m_strExecutable.Copy( szExpand )))
    {
        return hr;
    }
    
    //
    // If the executable is quoted, remove the quotes now
    //
    if ( m_strExecutable.QueryStr()[ 0 ] == L'"' &&
         m_strExecutable.QueryStr()[ m_strExecutable.QueryCCH() - 1 ] == L'"' )
    {
        cchExecutable = m_strExecutable.QueryCCH();
        
        memmove( m_strExecutable.QueryStr(),
                 m_strExecutable.QueryStr() + 1,
                 cchExecutable * sizeof( WCHAR ) );
        
        m_strExecutable.SetLen( cchExecutable - 2 );
    }

    if (m_strExecutable.QueryCCH() > 4)
    {
        if (!_wcsicmp(
                 m_strExecutable.QueryStr() + m_strExecutable.QueryCCH() - 4,
                 L".dll"))
        {
            m_Gateway = GATEWAY_ISAPI;
        }
        else
        {
            m_Gateway = GATEWAY_CGI;
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    if (!m_Verbs.AppendW( szVerbs, cchVerbs ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    return S_OK;
}

HRESULT
W3_METADATA_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize metadata cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    DWORD               csecTTL = DEFAULT_W3_METADATA_CACHE_TTL;
    HKEY                hKey;

    //
    // What is the TTL for the URI cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\w3svc\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        if ( RegQueryValueEx( hKey,
                              L"MetadataCacheTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }

        RegCloseKey( hKey );
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000, 
                                csecTTL * 1000,
                                CACHE_INVALIDATION_METADATA,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return W3_METADATA::Initialize();
}

HRESULT
W3_METADATA_CACHE::GetMetaData(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    W3_METADATA **              ppMetaData
)
/*++

Routine Description:

    Retrieve a W3_METADATA, creating if necessary

Arguments:

    pW3Context - W3 context
    strUrl - Url
    ppMetaData - Set to point to metadata on success
    
Return Value:

    HRESULT

--*/
{
    W3_METADATA_KEY           metaKey;
    W3_METADATA *             pMetaData;
    DWORD                     dwDataSetNumber;
    HRESULT                   hr;
    STACK_STRU(               strFullPath, 128 );
    MB                        mb( g_pW3Server->QueryMDObject() );
    HANDLE                    hToken = NULL;
    
    if ( pW3Context == NULL ||
         ppMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Failed;
    }
    
    *ppMetaData = NULL;
    
    //
    // Setup a key to lookup by determining data set number
    // 
    
    hr = GetFullMetadataPath( pW3Context,
                              strUrl,
                              &strFullPath );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    //
    // If the caller is coming from an ISAPI, then the thread may
    // be impersonating.  Temporarily discard the impersonation
    // token until we get the metadata.
    //

    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          &hToken ) )
    {
        DBG_ASSERT( hToken != NULL );
        DBG_REQUIRE( RevertToSelf() );
    }

    if ( !mb.GetDataSetNumber( strFullPath.QueryStr(),
                               &dwDataSetNumber ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    } 
    
    metaKey.SetDataSetNumber( dwDataSetNumber );
    
    //
    // Look it up
    //
    
    hr = FindCacheEntry( &metaKey, (CACHE_ENTRY**) &pMetaData );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( pMetaData != NULL );
       
        *ppMetaData = pMetaData;
        
        goto Succeeded;
    }
    
    //
    // We need to create a metadata entry and add it
    //
    
    hr = CreateNewMetaData( pW3Context,
                            strUrl,
                            strFullPath,
                            &pMetaData );
    if ( FAILED( hr ) )
    {
        goto Failed;
    }
    
    DBG_ASSERT( pMetaData != NULL );
    
    //
    // Add to the cache
    //
    
    AddCacheEntry( pMetaData );
    
    *ppMetaData = pMetaData;
    
Succeeded:

    DBG_ASSERT( SUCCEEDED( hr ) );

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    return NO_ERROR;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
        hToken = NULL;
    }

    return hr;

}

HRESULT
W3_METADATA_CACHE::CreateNewMetaData(
    W3_CONTEXT *            pW3Context,
    STRU &                  strUrl,
    STRU &                  strFullMetadataPath,
    W3_METADATA **          ppMetaData
)
/*++

Routine Description:

    Create a new W3_METADATA and initializes it

Arguments:

    pW3Context - context
    strUrl - URL
    strFullMetadataPath - Full metabase path to open
    ppMetaData - Set to new metadata entry on success

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr;
    W3_METADATA *               pMetaData = NULL;
    
    if ( pW3Context == NULL ||
         ppMetaData == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppMetaData = NULL;
    
    //
    // Create the metadata object
    //
    
    pMetaData = new W3_METADATA( this );
    if ( pMetaData == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Set full URL for flushing purposes
    //
    
    hr = pMetaData->QueryMetadataPath()->Copy( strFullMetadataPath );
    if ( FAILED( hr ) )
    {
        pMetaData->DereferenceCacheEntry();
        return hr;
    }
    
    //
    // Initialize it
    //

    hr = pMetaData->ReadMetaData( *(pW3Context->QuerySite()->QueryMBRoot()),
                                  strUrl );
    if( FAILED(hr) )
    {
        pMetaData->DereferenceCacheEntry();
        return hr;
    }

    *ppMetaData = pMetaData;

    return NO_ERROR;
}

HRESULT
W3_METADATA_CACHE::GetFullMetadataPath(
    W3_CONTEXT *                pW3Context,
    STRU &                      strUrl,
    STRU *                      pstrFullPath
)
/*++

Routine Description:

    Get the full metadata given the URL and site

Arguments:

    pW3Context - Used to get the site
    strUrl - Url
    pstrFullPath - Filled with full path on success
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    WCHAR *             pszSource;
    DWORD               cchSource;

    if ( pW3Context == NULL ||
         pstrFullPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Build up full metabase path (including instance)
    //
    
    hr = pstrFullPath->Copy( *(pW3Context->QuerySite()->QueryMBRoot()) );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Don't copy two slashes
    //
    
    if ( strUrl.QueryStr()[ 0 ] == L'/' ) 
    {
        pszSource = strUrl.QueryStr() + 1;
        cchSource = strUrl.QueryCCH() - 1;
    }
    else
    {
        pszSource = strUrl.QueryStr();
        cchSource = strUrl.QueryCCH();
    }
    
    hr = pstrFullPath->Append( pszSource, cchSource );
    if ( FAILED( hr ) )
    {
        return hr;
    }
   
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3server.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3server.cxx

Abstract:

    W3_SERVER object holds global state for ULW3.DLL

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#include "precomp.hxx"
#include "rawconnection.hxx"
#include "cgi_handler.h"

/*++

class MB_LISTENER

    Implements a metabase change listener for W3_SERVER.

--*/
class MB_LISTENER
    : public MB_BASE_NOTIFICATION_SINK
{
public:

    MB_LISTENER( W3_SERVER * pParent )
        : m_pParent( pParent )
    {
    }

    STDMETHOD( SynchronizedSinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
    {
        return m_pParent->MetabaseChangeNotification( dwMDNumElements, pcoChangeList );
    }

private:
    
    W3_SERVER * m_pParent;

};

W3_SERVER::W3_SERVER( BOOL fCompatibilityMode ) 
  : m_Signature                   (W3_SERVER_SIGNATURE),
    m_pMetaBase                   (NULL),
    m_InitStatus                  (INIT_NONE),
    m_fInBackwardCompatibilityMode(fCompatibilityMode),
    m_fUseDigestSSP               (FALSE),
    m_EventLog                    (L"W3SVC"),
    m_pCounterDataBuffer          (NULL),
    m_dwCounterDataBuffer         (0),
    m_cSites                      (0),
    m_pTokenCache                 (NULL),
    m_pUlCache                    (NULL),
    m_pUrlInfoCache               (NULL),
    m_pFileCache                  (NULL),
    m_pMetaCache                  (NULL)
{
}

W3_SERVER::~W3_SERVER()
{
    if (m_pCounterDataBuffer != NULL)
    {
        LocalFree(m_pCounterDataBuffer);
        m_pCounterDataBuffer = NULL;
    }

    m_Signature = W3_SERVER_FREE_SIGNATURE;
}

// static
DWORD W3_SITE_LIST::ExtractKey(const W3_SITE *site)
{
    return site->QueryId();
}

// static
VOID W3_SITE_LIST::AddRefRecord(W3_SITE *site, int nIncr)
{
    if (nIncr > 0)
    {
        site->AddRef();
    }
    else if (nIncr < 0)
    {
        site->Release();
    }
    else
    {
        DBG_ASSERT( !"Invalid reference");
    }
}

HRESULT FakeCollectCounters(PBYTE *ppCounterData,
                            DWORD *pdwCounterData)
{
    return g_pW3Server->CollectCounters(ppCounterData,
                                        pdwCounterData);
}

HRESULT
W3_SERVER::Initialize(
    INT                 argc,
    LPWSTR              argv[]
)
/*++

Routine Description:

    Initialize ULW3.DLL but do not begin listening for requests

Arguments:

    argc - Command line argument count
    argv[] - Command line arguments (from WAS)
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NOERROR;
    ULATQ_CONFIG            ulatqConfig;
    INT                     iRet;
    WSADATA                 wsaData;

    DBGPRINTF((
        DBG_CONTEXT, 
        "Initializing the W3 Server Started CTC = %d \n",
        GetTickCount()
        ));
    //
    // Keep track of how much we have initialized so that we can cleanup
    // only that which is necessary
    //

    //
    // Initialize Computer name, trivial so doesn't need its own state
    //

    DWORD cbSize = sizeof m_pszComputerName;
    if (!GetComputerNameA(m_pszComputerName, &cbSize))
    {
        strcpy(m_pszComputerName, "<Server>");
    }
    m_cchComputerName = strlen(m_pszComputerName);
    
    m_InitStatus = INIT_NONE;
   
    //
    // Initialize IISUTIL
    //

    if ( !InitializeIISUtil() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing IISUTIL.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_IISUTIL;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server initializing WinSock.  CTC = %d \n",
        GetTickCount()
        ));
    
    //
    // Initialize WinSock
    //
    
    if ( WSAStartup( MAKEWORD( 1, 1 ), &wsaData ) != 0 )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing WinSock.  hr = %x\n",
                    hr ));
        goto exit;
    } 
    m_InitStatus = INIT_WINSOCK;
    
    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server WinSock initialized.  CTC = %d \n",
        GetTickCount()
        ));

    //
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *)&(m_pMetaBase)
                           );

    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto exit;
    }
    
    hr = ReadUseDigestSSP();
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error reading UseDigestSSP property.  hr = %x\n",
                    hr ));
        goto exit;
    }
    
    
    m_pMetaBase->GetSystemChangeNumber( &m_dwSystemChangeNumber );

    m_InitStatus = INIT_METABASE;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server Metabase initialized.  CTC = %d \n",
        GetTickCount()
        ));
        
    //
    // Initialize metabase change notification mechanism
    //
    
    m_pMetabaseListener = new MB_LISTENER( this );
    if ( m_pMetabaseListener == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto exit;
    }
    m_InitStatus = INIT_MB_LISTENER;
    
    //
    // Initialize global filter list
    //
    
    hr = GlobalFilterInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error doing global filter initialization.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_FILTERS;

    //
    // Initialize W3_SITE
    //

    hr = W3_SITE::W3SiteInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error doing global W3_SITE initialization.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_SITE;
    
    //
    // Initialize site list
    //
    
    m_pSiteList = new W3_SITE_LIST();
    if ( m_pSiteList == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto exit;
    }
    m_InitStatus = INIT_SITE_LIST;

    //
    // Initialize ULATQ
    //

    ulatqConfig.pfnNewRequest = W3_MAIN_CONTEXT::OnNewRequest;
    ulatqConfig.pfnIoCompletion = W3_MAIN_CONTEXT::OnIoCompletion;
    ulatqConfig.pfnDisconnect = OnUlDisconnect;
    ulatqConfig.pfnOnShutdown = W3_SERVER::OnShutdown;
    ulatqConfig.pfnCollectCounters = FakeCollectCounters;

    hr = UlAtqInitialize( argc, 
                          argv,
                          &ulatqConfig );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing ULATQ.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_ULATQ;

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3 Server UlAtq initialized (ipm has signalled).  CTC = %d \n",
        GetTickCount()
        ));

    //
    // Initialize caches
    //

    hr = InitializeCaches();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing caches.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_CACHES;

    //
    // Initialize connection table
    //
    
    hr = W3_CONNECTION::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing connection table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_CONNECTION;

    //
    // Initialize W3_CONTEXTs
    //    
    
    hr = W3_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_CONTEXT;

    //
    // Initialize W3_REQUEST
    //
    
    hr = W3_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_REQUEST globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_REQUEST;
    
    //
    // Initialize W3_RESPONSE
    //
    
    hr = W3_RESPONSE::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing W3_RESPONSE globals.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_W3_RESPONSE;
    
    //
    // Initialize server variables
    //
    
    hr = SERVER_VARIABLE_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing server variable hash table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_SERVER_VARIABLES;

    //
    // Initialize Mime-mappings
    //
    hr = InitializeMimeMap(INET_INFO_PARAMETERS_KEY);
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing mime map table.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_MIME_MAP;

    //
    // Initialize logging
    //
    if (FAILED(hr = LOGGING::Initialize()))
    {
        goto exit;
    }
    m_InitStatus = INIT_LOGGING;
    
    //
    // If we are in backward compatibility mode, then initialize stream 
    // filter here
    //

    if (m_fInBackwardCompatibilityMode)
    {
        hr = RAW_CONNECTION::Initialize();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error initialize ISAPI raw data filter support.  hr = %x\n",
                        hr ));
            goto exit;
        }
    }
    m_InitStatus = INIT_RAW_CONNECTION;

    //
    // Client certificate object wrapper
    // 
    
    hr = CERTIFICATE_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing certificate contexts.  hr = %x\n",
                    hr ));
        goto exit;
    }
    m_InitStatus = INIT_CERTIFICATE_CONTEXT;
    
    //
    // Initialize Http Compression
    // Ignore failure but remember if we Initialized.
    //
    hr = HTTP_COMPRESSION::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing Http Compression.  hr = %x\n",
                    hr ));
        hr = S_OK;
    }
    else
    {
        m_InitStatus = INIT_HTTP_COMPRESSION;
    }
    
exit:
    return hr;
}

VOID
W3_SERVER::Terminate(
    HRESULT hrReason
)
/*++

Routine Description:

    Terminate ULW3 globals.  This should be done after we have stopped 
    listening for new requests (duh)

Arguments:
    
    None
    
Return Value:

    TRUE if successful, else FALSE

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "Terminating W3_SERVER object\n" ));

    //
    // Wait for all threads doing W3CORE stuff to drain
    //
    
    W3_MAIN_CONTEXT::WaitForThreadDrain();

        
    switch( m_InitStatus )
    {
    case INIT_HTTP_COMPRESSION:
        HTTP_COMPRESSION::Terminate();

    case INIT_CERTIFICATE_CONTEXT:
        CERTIFICATE_CONTEXT::Terminate();

    case INIT_RAW_CONNECTION:
        if (m_fInBackwardCompatibilityMode)
        {
            RAW_CONNECTION::Terminate();
        }

    case INIT_LOGGING:
        LOGGING::Terminate();

    case INIT_MIME_MAP:
        CleanupMimeMap();
        
    case INIT_SERVER_VARIABLES:
        SERVER_VARIABLE_HASH::Terminate();
        
    case INIT_W3_RESPONSE:
        W3_RESPONSE::Terminate();
        
    case INIT_W3_REQUEST:
        W3_REQUEST::Terminate();
        
    case INIT_W3_CONTEXT:
        W3_CONTEXT::Terminate();
        
    case INIT_W3_CONNECTION:
        W3_CONNECTION::Terminate();

    case INIT_CACHES:
        TerminateCaches();

    case INIT_ULATQ:
        UlAtqTerminate( hrReason );

    case INIT_SITE_LIST:
        delete m_pSiteList;
        m_pSiteList = NULL;

    case INIT_W3_SITE:
        W3_SITE::W3SiteTerminate();

    case INIT_FILTERS:
        GlobalFilterTerminate();

    case INIT_MB_LISTENER:
        if ( m_pMetabaseListener != NULL )
        {
            m_pMetabaseListener->Release();
            m_pMetabaseListener = NULL;
        }

    case INIT_METABASE:
        if ( m_pMetaBase )
        {
            m_pMetaBase->Release();
        }

    case INIT_WINSOCK:
        WSACleanup();

    case INIT_IISUTIL:
        TerminateIISUtil();


    }

    m_InitStatus = INIT_NONE;
}

HRESULT
W3_SERVER::LoadString(
    DWORD                       dwStringID,
    CHAR *                      pszString,
    DWORD *                     pcbString
)
/*++

Routine Description:

    Load a resource string from W3CORE.DLL

Arguments:
    
    dwStringID - String ID
    pszString - Filled with string
    pcbString - On input the size of the buffer pszString, on successful 
                output, the length of the string copied to pszString
   
Return Value:

    HRESULT

--*/
{
    DWORD           cbCopied;
    
    if ( pszString == NULL || 
         pcbString == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 
    
    cbCopied = LoadStringA( GetModuleHandleA( "W3CORE.DLL" ),
                            dwStringID,
                            pszString,
                            *pcbString );
    if ( cbCopied == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    *pcbString = cbCopied;
    return NO_ERROR;
}

HRESULT
W3_SERVER::StartListen(
    VOID
)
/*++

Routine Description:

    Begin listening for requests.  This function will return once we have 
    stopped listening for requests (due to WAS stopping us for some reason)

    Listen for metabase changes.

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( m_pMetabaseListener );

    //
    // Starting getting metabase changes
    //

    hr = m_pMetabaseListener->StartListening( m_pMetaBase );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error trying to listen for metabase changes.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    //
    // Listen for the stream filter
    //

    if (m_fInBackwardCompatibilityMode)
    {
        hr = RAW_CONNECTION::StartListening();
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error listening on filter channel.  hr = %x\n",
                        hr ));

            m_pMetabaseListener->StopListening( m_pMetaBase );

            return hr;
        }
    }
    
    //
    // Start listening for requests
    //
    
    hr = UlAtqStartListen();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error listening for HTTP requests.  hr = %x\n",
                    hr ));
        
        if (m_fInBackwardCompatibilityMode)
        {
            RAW_CONNECTION::StopListening();
        }

        m_pMetabaseListener->StopListening( m_pMetaBase );
        
        return hr;
    }
    
    //
    // StartListen() will return when we are to shutdown.
    //
    
    m_pMetabaseListener->StopListening( m_pMetaBase );

    return NO_ERROR;
}

W3_SITE *
W3_SERVER::FindSite(
    DWORD               dwInstance
)
{
    W3_SITE *site = NULL;
    LK_RETCODE lkrc = m_pSiteList->FindKey(dwInstance, &site);
    if (site != NULL)
    {
        DBG_ASSERT(lkrc == LK_SUCCESS);
    }

    return site;
}

BOOL W3_SERVER::AddSite(W3_SITE *site,
                        bool fOverWrite)
{
    if (m_pSiteList->InsertRecord(site, fOverWrite) == LK_SUCCESS)
    {
        if (!fOverWrite)
        {
            InterlockedIncrement((LPLONG)&m_cSites);
        }
        return TRUE;
    }

    return FALSE;
}

BOOL W3_SERVER::RemoveSite(W3_SITE *pInstance)
{
    if (m_pSiteList->DeleteRecord(pInstance) == LK_SUCCESS)
    {
        InterlockedDecrement((LPLONG)&m_cSites);
        return TRUE;
    }

    return FALSE;
}

void W3_SERVER::DestroyAllSites()
{
    m_pSiteList->Clear();
}

HRESULT 
W3_SERVER::MetabaseChangeNotification( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
/*++

Routine Description:

    This is the entry point for metabase changes.
    It just loops through pcoChangeList and passes
    the change to the handler method.

Arguments:
    
    dwMDNumElements - Number of change objects
    pcoChangeList - Array of change objects
    
Return Value:

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "MetabaseChangeNotification called.\n" 
                ));

    //
    // Verify that the change is for /LM/W3SVC/ or lower
    // and dispatch the change.
    //

    HRESULT hr = NOERROR;
    
    for( DWORD i = 0; i < dwMDNumElements; ++i )
    {
        if( _wcsnicmp( pcoChangeList[i].pszMDPath,
                      W3_SERVER_MB_PATH,
                      W3_SERVER_MB_PATH_CCH ) == 0 )
        {
            hr = HandleMetabaseChange( pcoChangeList[i] );
        }
    }
    //
    // Update system change number for use by file cache (etags)
    //

    m_pMetaBase->GetSystemChangeNumber( &m_dwSystemChangeNumber );

    return hr;
}

VOID
W3_SERVER::TerminateCaches(
    VOID
)
/*++

Routine Description:

    Cleanup all the caches

Arguments:
    
    None
    
Return Value:

    None

--*/
{
    //
    // First flush all caches (only references which should remain on cached
    // objects should be thru the hash tables themselves).  Once we have
    // flushed all the caches, all the cached objects should go away.
    //
    // If they don't that's a bug and ACache assert will fire
    //
    
    W3CacheFlushAllCaches();
    
    //
    // Now just unregister and cleanup the caches
    //
    
    if ( m_pMetaCache != NULL )
    {
        W3CacheUnregisterCache( m_pMetaCache );
        m_pMetaCache->Terminate();
        delete m_pMetaCache;
        m_pMetaCache = NULL;
    }
    
    if ( m_pFileCache != NULL )
    {
        W3CacheUnregisterCache( m_pFileCache );
        m_pFileCache->Terminate();
        delete m_pFileCache;
        m_pFileCache = NULL;
    }
    
    if ( m_pTokenCache != NULL )
    {
        W3CacheUnregisterCache( m_pTokenCache );
        m_pTokenCache->Terminate();
        delete m_pTokenCache;
        m_pTokenCache = NULL;
    }
    
    if ( m_pUrlInfoCache != NULL )
    {
        W3CacheUnregisterCache( m_pUrlInfoCache );
        m_pUrlInfoCache->Terminate();
        delete m_pUrlInfoCache;
        m_pUrlInfoCache = NULL;
    }
    
    if ( m_pUlCache != NULL )
    {
        W3CacheUnregisterCache( m_pUlCache );
        m_pUlCache->Terminate();
        delete m_pUlCache;
        m_pUlCache = NULL;    
    }
    
    W3CacheTerminate();
}

HRESULT
W3_SERVER::InitializeCaches(
    VOID
)
/*++

Routine Description:

    Initialize caches

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    BOOL                fCacheInit = FALSE;
    
    //
    // Url cache
    //
    
    m_pUrlInfoCache = new W3_URL_INFO_CACHE;
    if ( m_pUrlInfoCache != NULL )
    {
        hr = m_pUrlInfoCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pUrlInfoCache;
            m_pUrlInfoCache = NULL;
        }    
    }
    
    if ( m_pUrlInfoCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Token cache
    //
    
    m_pTokenCache = new TOKEN_CACHE;
    if ( m_pTokenCache != NULL )
    {
        hr = m_pTokenCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pTokenCache;
            m_pTokenCache = NULL;
        }
    }
    
    if ( m_pTokenCache == NULL )
    {
        goto Failure;
    }
    
    //
    // File cache
    //

    m_pFileCache = new W3_FILE_INFO_CACHE;
    if ( m_pFileCache != NULL )
    {
        hr = m_pFileCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pFileCache;
            m_pFileCache = NULL;
        }
    }
    
    if ( m_pFileCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Metacache
    //
    
    m_pMetaCache = new W3_METADATA_CACHE;
    if ( m_pMetaCache != NULL )
    {
        hr = m_pMetaCache->Initialize();
        if ( FAILED( hr ) )
        {
            delete m_pMetaCache;
            m_pMetaCache = NULL;
        }
    }
    
    if ( m_pMetaCache == NULL )
    {
        goto Failure;
    }
    
    //
    // UL response cache
    //
    
    m_pUlCache = new UL_RESPONSE_CACHE;
    if ( m_pUlCache != NULL )
    {
        hr = m_pUlCache->Initialize();
        if ( FAILED( hr ) ) 
        {
            delete m_pUlCache;
            m_pUlCache = NULL;
        }
    }
    
    if ( m_pUlCache == NULL )
    {
        goto Failure;
    }
    
    //
    // Now initialize the manager and register the caches
    //
    
    DBG_ASSERT( m_pMetaBase != NULL );
    
    hr = W3CacheInitialize( m_pMetaBase );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    fCacheInit = TRUE;
    
    hr = W3CacheRegisterCache( m_pMetaCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pFileCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pTokenCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pUrlInfoCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = W3CacheRegisterCache( m_pUlCache );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
   
    return NO_ERROR;

Failure:

    if ( fCacheInit )
    {
        W3CacheTerminate();
    }

    if ( m_pMetaCache != NULL )
    {
        delete m_pMetaCache;
        m_pMetaCache = NULL;
    }
    
    if ( m_pFileCache != NULL )
    {
        delete m_pFileCache;
        m_pFileCache = NULL;
    }
    
    if ( m_pTokenCache != NULL )
    {
        delete m_pTokenCache;
        m_pTokenCache = NULL;
    }
    
    if ( m_pUrlInfoCache != NULL )
    {
        delete m_pUrlInfoCache;
        m_pUrlInfoCache = NULL;
    }
    
    if ( m_pUlCache != NULL )
    {
        delete m_pUlCache;
        m_pUlCache = NULL;
    }
    
    return hr;
}

HRESULT
W3_SERVER::HandleMetabaseChange(
    const MD_CHANGE_OBJECT & ChangeObject
    )
/*++

Routine Description:

    Handle change notifications from the metabase.
    The change object will contain a change to
    /LM/W3SVC/ or lower in the metabase tree.

    Changes to /LM/W3SVC/ may alter W3_SERVER and
    are passed to all sites in the site list.

    Changes to /LM/W3SVC/{site id}/ or lower will
    affect only one site so are just passed on.

Arguments:
    
    ChangeObject
    
Return Value:

CODEWORK - Partial implementation 1/26/00 - TaylorW

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3_SERVER Notfied - Path(%S) Type(%d) NumIds(%08x)\n",
                ChangeObject.pszMDPath,
                ChangeObject.dwMDChangeType,
                ChangeObject.dwMDNumDataIDs 
                ));

    HRESULT hr = NOERROR;
    BOOL    IsPathW3 = FALSE;
    BOOL    IsPathSite = FALSE;

    //
    // Find the instance id if present
    //
    
    DWORD   SiteId;
    LPWSTR  SiteIdString = ChangeObject.pszMDPath + W3_SERVER_MB_PATH_CCH;
    LPWSTR  StringEnd;


    if( SiteIdString[0] == L'\0' )
    {
        IsPathW3 = TRUE;
    }
    else
    {
        SiteId = wcstoul( SiteIdString, &StringEnd, 10 );

        if( SiteId != 0 )
        {
            IsPathSite = TRUE;
        }
    }

    W3_SITE *   Site = NULL;
    LK_RETCODE  lkrc;

    if( IsPathSite )
    {
        //
        // We just need to notify a specific site
        //
        DBG_ASSERT( SiteId );

        Site = FindSite(SiteId);
        if (Site != NULL)
        {
            hr = Site->HandleMetabaseChange( ChangeObject );
            Site->Release();
        }
    }
    else if( IsPathW3 )
    {
        //
        // We need to notify every site
        //

        m_pSiteList->WriteLock();

        W3_SITE_LIST TempSiteList;

        for (W3_SITE_LIST::iterator iter = m_pSiteList->begin();
             iter != m_pSiteList->end();
             ++iter)
        {
            Site = iter.Record();
            
            Site->HandleMetabaseChange( ChangeObject, &TempSiteList );
        }

        m_pSiteList->Clear();
        m_cSites = 0;

        for (W3_SITE_LIST::iterator iter = TempSiteList.begin();
             iter != TempSiteList.end();
             ++iter)
        {
            Site = iter.Record();
            
            AddSite(Site);
        }

        m_pSiteList->WriteUnlock();

        //
        // Handle changes to this object's data
        //
        // At this point all we care about is data changes
        //

        if( (ChangeObject.dwMDChangeType & MD_CHANGE_TYPE_DELETE_DATA) ||
            (ChangeObject.dwMDChangeType & MD_CHANGE_TYPE_SET_DATA) )
        {
            //
            // CODEWORK: Handle changes to W3_SERVER metadata
            // Probably this is just the inprocess isapi list
            //

            
        }
    }
    
    // BUGBUG - Ignore Errors
    return S_OK;
}

//static
VOID
W3_SERVER::OnShutdown(
    BOOL fDoImmediate
)
/*++

Routine Description:

    Called right after IPM indication of shutdown (but before drain)

Arguments:

    None    
    
Return Value:

    None

--*/
{
    if (g_pW3Server->m_fInBackwardCompatibilityMode)
    {
        RAW_CONNECTION::StopListening();
    }

    if (fDoImmediate)
    {
        W3_CGI_HANDLER::KillAllCgis();
    }
}

HRESULT W3_SERVER::CollectCounters(PBYTE *ppCounterData,
                                   DWORD *pdwCounterData)
{
    //
    // Initialize to null
    //
    *ppCounterData = NULL;
    *pdwCounterData = 0;

    //
    // Make sure we have enough memory
    //
    DWORD dwCounterBufferNeeded = sizeof(IISWPSiteCounters) * m_cSites +
        sizeof(IISWPGlobalCounters) + sizeof(ULONGLONG);
    if (m_pCounterDataBuffer == NULL)
    {
        m_pCounterDataBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwCounterBufferNeeded);
        if (m_pCounterDataBuffer == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        m_dwCounterDataBuffer = dwCounterBufferNeeded;
    }
    else if (m_dwCounterDataBuffer < dwCounterBufferNeeded)
    {
        m_pCounterDataBuffer = (PBYTE)LocalReAlloc(m_pCounterDataBuffer,
                                                   dwCounterBufferNeeded,
                                                   LMEM_MOVEABLE);
        if (m_pCounterDataBuffer == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        m_dwCounterDataBuffer = dwCounterBufferNeeded;
    }

    m_pSiteList->ReadLock();

    //
    // Get the Site counters
    //
    DWORD i = 0;
    for (W3_SITE_LIST::iterator iter = m_pSiteList->begin();
         iter != m_pSiteList->end();
         ++iter, ++i)
    {
        //
        // In case some more new sites got added in between, skip them for now
        //
        if ((i+1)*sizeof(IISWPSiteCounters) + sizeof(IISWPGlobalCounters) >=
            m_dwCounterDataBuffer)
        {
            break;
        }

        W3_SITE *pSite = iter.Record();

        pSite->GetStatistics((IISWPSiteCounters *)
            (m_pCounterDataBuffer +
             i*sizeof(IISWPSiteCounters) + sizeof(DWORD)));
    }

    m_pSiteList->ReadUnlock();

    //
    // Set the number of sites
    //
    *(DWORD *)m_pCounterDataBuffer = i;

    //
    // Get the Global counters
    //

    IISWPGlobalCounters *pCacheCtrs = (IISWPGlobalCounters *)
        (m_pCounterDataBuffer + i*sizeof(IISWPSiteCounters) + sizeof(DWORD));

    //
    // This contains some ULONGLONG values so align it, this is how WAS
    // expects it
    //
    pCacheCtrs = (IISWPGlobalCounters *)(((DWORD_PTR)pCacheCtrs + 7) & ~7);
    GetCacheStatistics(pCacheCtrs);

    *ppCounterData = m_pCounterDataBuffer;
    *pdwCounterData = DIFF((LPBYTE)pCacheCtrs - m_pCounterDataBuffer) + sizeof(IISWPGlobalCounters);

    return S_OK;
}

VOID
W3_SERVER::GetCacheStatistics(
    IISWPGlobalCounters *           pCacheCtrs
)
/*++

  Routine Description:

    Get cache statistics for perfmon purposes

  Arguments:

    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    None
    
--*/
{
    //
    // Get file cache statistics
    //
    
    if ( m_pFileCache != NULL )
    {
        pCacheCtrs->CurrentFilesCached = m_pFileCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalFilesCached   = m_pFileCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->FileCacheHits      = m_pFileCache->PerfQueryHits();
        pCacheCtrs->FileCacheMisses    = m_pFileCache->PerfQueryMisses();
        pCacheCtrs->FileCacheFlushes   = m_pFileCache->PerfQueryFlushCalls();
        pCacheCtrs->ActiveFlushedFiles = m_pFileCache->PerfQueryActiveFlushedEntries();
        pCacheCtrs->TotalFlushedFiles  = m_pFileCache->PerfQueryFlushes();
        pCacheCtrs->CurrentFileCacheMemoryUsage = m_pFileCache->PerfQueryCurrentMemCacheSize();
        pCacheCtrs->MaxFileCacheMemoryUsage = m_pFileCache->PerfQueryMaxMemCacheSize();
    }
    
    //
    // Get URI cache statistics
    //
    
    if ( m_pUrlInfoCache != NULL )
    {
        pCacheCtrs->CurrentUrisCached = m_pUrlInfoCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalUrisCached   = m_pUrlInfoCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->UriCacheHits      = m_pUrlInfoCache->PerfQueryHits();
        pCacheCtrs->UriCacheMisses    = m_pUrlInfoCache->PerfQueryMisses();
        pCacheCtrs->UriCacheFlushes   = m_pUrlInfoCache->PerfQueryFlushCalls();
        pCacheCtrs->TotalFlushedUris  = m_pUrlInfoCache->PerfQueryFlushes();
    }
    
    //
    // BLOB cache counters (actually since there is no blob cache we will
    // sub in the metacache counters which are more interesting since 
    // metacache misses are really painful
    //

    if ( m_pMetaCache != NULL )
    {
        pCacheCtrs->CurrentBlobsCached = m_pMetaCache->PerfQueryCurrentEntryCount();
        pCacheCtrs->TotalBlobsCached   = m_pMetaCache->PerfQueryTotalEntriesCached();
        pCacheCtrs->BlobCacheHits      = m_pMetaCache->PerfQueryHits();
        pCacheCtrs->BlobCacheMisses    = m_pMetaCache->PerfQueryMisses();
        pCacheCtrs->BlobCacheFlushes   = m_pMetaCache->PerfQueryFlushCalls();
        pCacheCtrs->TotalFlushedBlobs  = m_pMetaCache->PerfQueryFlushes();
    }
}

HRESULT
W3_SERVER::ReadUseDigestSSP(
    VOID
)
/*++
  Routine description:
    Read the UseDigestSSP property from the metabase

  Arguments:
    none

  Return Value:
    HRESULT
--*/
{
    MB mb( QueryMDObject() );

    if ( !mb.Open( QueryMDPath() ) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword( L"",
                       MD_USE_DIGEST_SSP,
                       IIS_MD_UT_SERVER,
                       ( DWORD * )&m_fUseDigestSSP,
                       0 ) )
    {
        m_fUseDigestSSP = TRUE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3request.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3request.cxx

   Abstract:
     Friendly wrapper for UL_HTTP_REQUEST
 
   Author:
     Bilal Alam (balam)             13-Dec-1999

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

//
// LocalHost address used to determining whether request is local/remote
// 

#define LOCAL127            0x0100007F  // 127.0.0.1

#define DEFAULT_PORT        80
#define DEFAULT_PORT_SECURE 443

PHOSTENT                    W3_REQUEST::sm_pHostEnt;

ALLOC_CACHE_HANDLER *       W3_CLONE_REQUEST::sm_pachCloneRequests;

DWORD
W3_REQUEST::QueryLocalAddress(
    VOID
) const
/*++

Routine Description:

    Get the local IP address connected to (assumes IPV4)

Arguments:

    None

Return Value:

    Address

--*/
{
    HTTP_NETWORK_ADDRESS_IPV4 *   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.LocalAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
    pAddress = (HTTP_NETWORK_ADDRESS_IPV4 *)_pUlHttpRequest->Address.pLocalAddress;
    return pAddress->IpAddress;
}

VOID
W3_REQUEST::RemoveDav(
    VOID
)
/*++

Routine Description:

    Remove DAV'ness of request

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Remove translate header
    //

    DeleteHeader( "Translate" );
    DeleteHeader( "If" );
    DeleteHeader( "Lock-Token" );
}

BOOL
W3_REQUEST::IsSuspectUrl(
    VOID
)
/*++

Routine Description:
    
    Is the URL for this request look suspect?  
    
    Suspect means there is a ./ pattern in it which could cause a metabase
    equivilency issue.

Arguments:

    None

Return Value:

    TRUE if the URL is suspect, else FALSE

--*/
{
    WCHAR *             pszDotSlash;
    WCHAR *             pszUrl;
    WCHAR               chTemp;
    
    pszUrl = _pUlHttpRequest->CookedUrl.pAbsPath;
    
    //
    // URL UL gives us has backslashes flipped.  But it is not 0 terminated
    //
    
    chTemp = pszUrl[ _pUlHttpRequest->CookedUrl.AbsPathLength / 2 ];
    pszUrl[ _pUlHttpRequest->CookedUrl.AbsPathLength / 2 ] = L'\0';
    
    pszDotSlash = wcsstr( pszUrl, L"./" );
    
    pszUrl[ _pUlHttpRequest->CookedUrl.AbsPathLength / 2 ] = chTemp;
    
    if ( pszDotSlash != NULL )
    {
        return TRUE;
    }
    
    //
    // If the URL ends with a ., it is also suspect
    //
    
    if ( pszUrl[ _pUlHttpRequest->CookedUrl.AbsPathLength / 2 - 1 ] == L'.' )
    {
        return TRUE;
    }
    
    return FALSE;
}

BOOL
W3_REQUEST::QueryClientWantsDisconnect(
    VOID
)
/*++

Routine Description:

    Returns whether the client wants to disconnect, based on its version and
    connection: headers

Arguments:

    None

Return Value:

    TRUE if client wants to disconnect

--*/
{
    HTTP_VERSION            version;
    CHAR *                  pszConnection;
    
    version = QueryVersion();
    
    //
    // If 0.9, then disconnect
    //
    
    if ( HTTP_EQUAL_VERSION( version, 0, 9 ) )
    {
        return TRUE;
    }
    
    //
    // If 1.0 and Connection: keep-alive isn't present
    //
    
    if ( HTTP_EQUAL_VERSION( version, 1, 0 ) )
    {
        pszConnection = GetHeader( HttpHeaderConnection );
        if ( pszConnection == NULL ||
             _stricmp( pszConnection, "Keep-Alive" ) != 0 )
        {
            return TRUE;
        }
    }
    
    //
    // If 1.1 and Connection: Close is present
    //
    
    if ( HTTP_EQUAL_VERSION( version, 1, 1 ) )
    {
        pszConnection = GetHeader( HttpHeaderConnection );
        if ( pszConnection != NULL &&
             _stricmp( pszConnection, "Close" ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT
W3_REQUEST::SetHeadersByStream(
    CHAR *              pszStream
)
/*++

Routine Description:

    Set request headers based on given stream    

Arguments:

    pszHeaderStream - Stream to parse and set headers off

Return Value:

    HRESULT

--*/
{
    CHAR *              pszCursor;
    CHAR *              pszEnd;
    CHAR *              pszColon;
    HRESULT             hr = NO_ERROR;
    STACK_STRA(         strHeaderLine, 128 );
    STACK_STRA(         strHeaderName, 32 );
    STACK_STRA(         strHeaderValue, 64 );
    
    if ( pszStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // \r\n delimited
    //
    
    pszCursor = pszStream;
    while ( pszCursor != NULL && *pszCursor != '\0' )
    {
        if ( *pszCursor == '\r' && *(pszCursor + 1) == '\n' )
        {
            break;
        }
        
        pszEnd = strstr( pszCursor, "\r\n" );
        if ( pszEnd == NULL )
        {
            break;
        }
        //
        // Split out a line
        //
         
        hr = strHeaderLine.Copy( pszCursor, 
                                 DIFF(pszEnd - pszCursor) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }        

        //
        // Advance the cursor the right after the \r\n
        //

        pszCursor = pszEnd + 2;
        
        //
        // Split the line above into header:value
        //
        
        pszColon = strchr( strHeaderLine.QueryStr(), ':' );
        if ( pszColon == NULL )
        {
            //
            // Expecting name:value.  Just skip for now
            //
            
            continue;
        }
        
        hr = strHeaderName.Copy( strHeaderLine.QueryStr(),
                                 DIFF(pszColon - strHeaderLine.QueryStr()) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Skip the first space after the : if there is one
        //
        
        if ( pszColon[ 1 ] == ' ' )
        {
            pszColon++;
        }
        
        hr = strHeaderValue.Copy( pszColon + 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Add the header to the response
        //

        hr = SetHeader( strHeaderName,
                        strHeaderValue,
                        FALSE );           
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

Finished:
    return hr;
}

DWORD
W3_REQUEST::QueryRemoteAddress(
    VOID
) const
/*++

Routine Description:

    Get the remote IP address connecting to us (assumes IPV4)

Arguments:

    None

Return Value:

    Address

--*/
{
    HTTP_NETWORK_ADDRESS_IPV4 *   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.RemoteAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
    pAddress = (HTTP_NETWORK_ADDRESS_IPV4*) _pUlHttpRequest->Address.pRemoteAddress;
    return pAddress->IpAddress;
}

USHORT
W3_REQUEST::QueryLocalPort(
    VOID
) const
{
    HTTP_NETWORK_ADDRESS_IPV4 *   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.LocalAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
    pAddress = (HTTP_NETWORK_ADDRESS_IPV4*) _pUlHttpRequest->Address.pLocalAddress;
    return pAddress->Port;
}

USHORT
W3_REQUEST::QueryRemotePort(
    VOID
) const
{
    HTTP_NETWORK_ADDRESS_IPV4 *   pAddress;

    DBG_ASSERT( _pUlHttpRequest->Address.RemoteAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
    pAddress = (HTTP_NETWORK_ADDRESS_IPV4*) _pUlHttpRequest->Address.pRemoteAddress;
    return pAddress->Port;
}

BOOL
W3_REQUEST::IsProxyRequest(
    VOID
)
/*++
    Description:

        Check if request was issued by a proxy, as determined by following rules :
        - "Via:" header is present (HTTP/1.1)
        - "Forwarded:" header is present (some HTTP/1.0 implementations)
        - "User-Agent:" contains "via ..." (CERN proxy)

    Arguments:
        None

    Returns:
        TRUE if client request was issued by proxy

--*/
{
    CHAR *   pUserAgent;
    UINT     cUserAgent;
    CHAR *   pEnd;

    if ( GetHeader( HttpHeaderVia ) || GetHeader( "Forward" ) )
    {
        return TRUE;
    }

    if ( pUserAgent = GetHeader( HttpHeaderUserAgent ) )
    {
        cUserAgent = strlen( pUserAgent );
        pEnd = pUserAgent + cUserAgent - 3;

        //
        // scan for "[Vv]ia[ :]" in User-Agent: header
        //

        while ( pUserAgent < pEnd )
        {
            if ( *pUserAgent == 'V' || *pUserAgent == 'v' )
            {
                if ( pUserAgent[1] == 'i' &&
                     pUserAgent[2] == 'a' &&
                     (pUserAgent[3] == ' ' || pUserAgent[3] == ':') )
                {
                    return TRUE;
                }
            }
            ++pUserAgent;
        }
    }

    return FALSE;
}

BOOL
W3_REQUEST::IsChunkedRequest(
    VOID
)
/*++
    Description:

        Check if request is chunk transfer encoded.

    Arguments:
        None

    Returns:
        TRUE if client request has a "transfer-encoding: chunked"
        header.

--*/
{
    CHAR *   pTransferEncoding;
    UINT     cTransferEncoding;
    BOOL     fRet = FALSE;

    if ( pTransferEncoding = GetHeader( HttpHeaderTransferEncoding ) )
    {
        fRet = ( _stricmp( pTransferEncoding, "chunked" ) == 0 );
    }

    return fRet;
}

HRESULT
W3_REQUEST::GetAuthType(
    STRA *              pstrAuthType
)
/*++

Routine Description:

    Determine the auth type for this request.  Auth type is the string
    after the authorization header (and before the space if there).
    
    Eg. Authorization: Basic FOOBAR     ==> AuthType is Basic
        Authorization: NTLM             ==> AuthType is NTLM

    And of course if client cert mapping happened, type is "SSL/PCT"

Arguments:

    pstrAuthType - Filled with auth type

Return Value:

    HRESULT

--*/
{
    CHAR *              pszAuthType;
    CHAR *              pszSpace;
    HRESULT             hr;
    
    if ( pstrAuthType == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check for client cert mapping
    //
    
    if ( QueryClientCertInfo() != NULL &&
         QueryClientCertInfo()->Token != NULL )
    {
        return pstrAuthType->Copy( "SSL/PCT" );
    }
    
    //
    // Now check for the Authorization: header
    //
    
    pszAuthType = GetHeader( HttpHeaderAuthorization );
    if ( pszAuthType == NULL )
    {
        pstrAuthType->Reset();
        hr = NO_ERROR;
    }
    else
    {
        pszSpace = strchr( pszAuthType, ' ' );
        
        if ( pszSpace == NULL )
        {
            hr = pstrAuthType->Copy( pszAuthType );
        }
        else
        {
            hr = pstrAuthType->Copy( pszAuthType,
                                     DIFF( pszSpace - pszAuthType ) );
        }
    }
    
    return hr;
}

BOOL
W3_REQUEST::IsLocalRequest(
    VOID
) const
/*++

Routine Description:

    Determines whether current request is a local request.  This is used
    since certain vroot permissions can be specified for remote/local

Arguments:

    None

Return Value:

    TRUE if this is a local request

--*/
{
    DWORD               localAddress = QueryLocalAddress();
    DWORD               remoteAddress = QueryRemoteAddress();
    CHAR**              list;
    PIN_ADDR            p;
    
    //
    // Are the remote/local addresses the same?  
    //
    
    if ( localAddress == remoteAddress )
    {
        return TRUE;
    }
    
    //
    // Are either equal to 127.0.0.1
    //
    
    if ( localAddress == LOCAL127 ||
         remoteAddress == LOCAL127 )
    {
        return TRUE;
    }
    
    //
    // Is the remote address equal to one of the host addresses
    // 
    
    list = sm_pHostEnt->h_addr_list;

    while ( (p = (PIN_ADDR)*list++) != NULL ) 
    {
        if ( p->s_addr == remoteAddress ) 
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

HRESULT
W3_REQUEST::BuildFullUrl(
    STRU&               strPath,
    STRU *              pstrRedirect,
    BOOL                fIncludeParameters
)
/*++

Routine Description:

    Create a new URL while maintaining host/port/protocol/query-string of
    original request

Arguments:

    strPath - New path portion of URL
    pstrRedirect - String filled with new full URL
    fIncludeParameters - TRUE if original query string should be copied too

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NO_ERROR;

    if ( pstrRedirect == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 

    hr = pstrRedirect->Copy( IsSecureRequest() ? L"https://" : L"http://" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    LPWSTR pszColon = wcschr( _pUlHttpRequest->CookedUrl.pHost, ':' );
    if ((pszColon != NULL) &&
        ((IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT_SECURE) ||
         (!IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT)))
    {
        hr = pstrRedirect->Append( _pUlHttpRequest->CookedUrl.pHost,
                                   DIFF(pszColon - _pUlHttpRequest->CookedUrl.pHost) );
    }
    else
    {
        hr = pstrRedirect->Append( _pUlHttpRequest->CookedUrl.pHost,
                                   _pUlHttpRequest->CookedUrl.HostLength / sizeof( WCHAR ) );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrRedirect->Append( strPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( fIncludeParameters &&
         _pUlHttpRequest->CookedUrl.pQueryString != NULL )
    {
        //
        // UL_HTTP_REQUEST::QueryString already contains the '?'
        //

        hr = pstrRedirect->Append(
                 _pUlHttpRequest->CookedUrl.pQueryString,
                 _pUlHttpRequest->CookedUrl.QueryStringLength / sizeof(WCHAR));
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

HRESULT
W3_REQUEST::BuildFullUrl(
    STRA&               strPath,
    STRA *              pstrRedirect,
    BOOL                fIncludeParameters
)
/*++

Routine Description:

    Create a new URL while maintaining host/port/protocol/query-string of
    original request

Arguments:

    strPath - New path portion of URL
    pstrRedirect - String filled with new full URL
    fIncludeParameters - TRUE if original query string should be copied too

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NO_ERROR;

    if ( pstrRedirect == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    } 

    hr = pstrRedirect->Copy( IsSecureRequest() ? "https://" : "http://" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    LPWSTR pszColon = wcschr( _pUlHttpRequest->CookedUrl.pHost, ':' );
    if ((pszColon != NULL) &&
        ((IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT_SECURE) ||
         (!IsSecureRequest() && _wtoi(pszColon + 1) == DEFAULT_PORT)))
    {
        hr = pstrRedirect->AppendW( _pUlHttpRequest->CookedUrl.pHost,
                                    DIFF(pszColon - _pUlHttpRequest->CookedUrl.pHost) );
    }
    else
    {
        hr = pstrRedirect->AppendW( _pUlHttpRequest->CookedUrl.pHost,
                                    _pUlHttpRequest->CookedUrl.HostLength / sizeof( WCHAR ) );
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrRedirect->Append( strPath );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( fIncludeParameters &&
         _pUlHttpRequest->CookedUrl.pQueryString != NULL )
    {
        //
        // UL_HTTP_REQUEST::QueryString already contains the '?'
        //

        hr = pstrRedirect->AppendW(
                 _pUlHttpRequest->CookedUrl.pQueryString,
                 _pUlHttpRequest->CookedUrl.QueryStringLength / sizeof(WCHAR));
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

CHAR *
W3_REQUEST::GetHeader(
    CHAR *         pszHeaderName
) 
/*++

Routine Description:

    Get a request header and copy it into supplied buffer

Arguments:

    pszHeaderName - Name of header to get

Return Value:

    WCHAR pointer pointed to the header, NULL if no such header 

--*/
{
    ULONG                       ulHeaderIndex = UNKNOWN_INDEX;
    HTTP_REQUEST_HEADERS    *   pHeaders = &(_pUlHttpRequest->Headers);
    HRESULT                     hr = HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );

    DBG_ASSERT( pszHeaderName != NULL );

    //
    // First check whether this header is a known header
    //

    ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Need to iterate thru unknown headers
        //

        for ( DWORD i = 0; 
              i < pHeaders->UnknownHeaderCount;
              i++ )
        {
            if ( _stricmp( pszHeaderName,
                           pHeaders->pUnknownHeaders[ i ].pName ) == 0 )
            {
                return pHeaders->pUnknownHeaders[ i ].pRawValue;
            }
        }

        return NULL;
    }
    else
    {   
        //
        // Known header
        //
    
        DBG_ASSERT( ulHeaderIndex < HttpHeaderRequestMaximum );
        
        return pHeaders->pKnownHeaders[ ulHeaderIndex ].pRawValue; 
    }
}

HRESULT
W3_REQUEST::GetHeader(
    CHAR *              pszHeaderName,
    DWORD               cchHeaderName,
    STRA *              pstrHeaderValue,
    BOOL                fIsUnknownHeader
)
/*++

Routine Description:

    Get a request header and copy it into supplied buffer

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pstrHeaderValue - Filled with header value
    fIsUnknownHeader - (optional) set to TRUE if header is unknown 
                 and we can avoid doing header hash lookup

Return Value:

    HRESULT

--*/
{
    ULONG                       ulHeaderIndex = UNKNOWN_INDEX;
    HTTP_REQUEST_HEADERS *      pHeaders = &(_pUlHttpRequest->Headers);
    HRESULT                     hr = HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
    
    if ( pszHeaderName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check whether this header is a known header
    //
    
    if ( !fIsUnknownHeader )
    {
        ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    }
    
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Need to iterate thru unknown headers
        //
        
        for ( DWORD i = 0; 
              i < pHeaders->UnknownHeaderCount;
              i++ )
        {
            if ( cchHeaderName == pHeaders->pUnknownHeaders[ i ].NameLength &&
                 _stricmp( pszHeaderName,
                           pHeaders->pUnknownHeaders[ i ].pName ) == 0 )
            {
                hr = pstrHeaderValue->Copy( 
                       pHeaders->pUnknownHeaders[ i ].pRawValue, 
                       pHeaders->pUnknownHeaders[ i ].RawValueLength );
                break;
            }
        }
    }
    else
    {   
        //
        // Known header
        //
    
        DBG_ASSERT( ulHeaderIndex < HttpHeaderRequestMaximum );
        
        if ( pHeaders->pKnownHeaders[ ulHeaderIndex ].pRawValue != NULL )
        {
            hr = pstrHeaderValue->Copy(
                   pHeaders->pKnownHeaders[ ulHeaderIndex ].pRawValue,
                   pHeaders->pKnownHeaders[ ulHeaderIndex ].RawValueLength);
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
    
    return hr;
}

HRESULT
W3_REQUEST::DeleteHeader(
    CHAR *             pszHeaderName
)
/*++

Routine Description:
    
    Delete a request header

Arguments:

    pszHeaderName - Header to delete
    
Return Value:

    HRESULT

--*/
{
    ULONG                   ulHeaderIndex;
    HRESULT                 hr;
    HTTP_UNKNOWN_HEADER   * pUnknownHeader;
    
    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    // 

    ulHeaderIndex = REQUEST_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex != UNKNOWN_INDEX && 
         ulHeaderIndex < HttpHeaderResponseMaximum )
    {
       _pUlHttpRequest->Headers.pKnownHeaders[ ulHeaderIndex ].pRawValue = NULL;
       _pUlHttpRequest->Headers.pKnownHeaders[ ulHeaderIndex ].RawValueLength = 0;
    }
    else
    {
        //
        // Unknown header.  First check if it exists
        //
            
        for ( DWORD i = 0;
              i < _pUlHttpRequest->Headers.UnknownHeaderCount;
              i++ )
        {
            pUnknownHeader = &(_pUlHttpRequest->Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pUnknownHeader->pName, pszHeaderName ) == 0 )
            {
                break;
            }
        }
        
        if ( i < _pUlHttpRequest->Headers.UnknownHeaderCount )
        {
            //
            // Now shrink the array to remove the header
            //
        
            memmove( _pUlHttpRequest->Headers.pUnknownHeaders + i,
                     _pUlHttpRequest->Headers.pUnknownHeaders + i + 1,
                     ( _pUlHttpRequest->Headers.UnknownHeaderCount - i - 1 ) * 
                     sizeof( HTTP_UNKNOWN_HEADER ) );
        
            _pUlHttpRequest->Headers.UnknownHeaderCount--;
        }
    }
    
    return NO_ERROR;
}

    
HRESULT
W3_REQUEST::SetHeader(
    STRA &                  strHeaderName,
    STRA &                  strHeaderValue,
    BOOL                    fAppend
)
/*++

Routine Description:

    Set a request header

Arguments:

    strHeaderName - Name of header to set
    strHeaderValue - New header value to set
    fAppend - If TRUE, the existing header value is appended to, else it is
              replaced

Return Value:

    HRESULT

--*/
{
    CHAR *                  pszNewName = NULL;
    CHAR *                  pszNewValue = NULL;
    STACK_STRA(             strOldHeaderValue, 256 );
    STRA *                  pstrNewHeaderValue = NULL;
    HRESULT                 hr;
    ULONG                   index;

    //
    // If we're appending, then get the old header value (if any) and 
    // append the new value (with a comma delimiter)
    //

    if ( fAppend )
    {
        hr = GetHeader( strHeaderName, &strOldHeaderValue );
        if ( FAILED( hr ) )
        {
            pstrNewHeaderValue = &strHeaderValue;
            hr = NO_ERROR;
        }
        else 
        {
            hr = strOldHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strOldHeaderValue.Append( strHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            pstrNewHeaderValue = &strOldHeaderValue;
        }
    }
    else
    {
        pstrNewHeaderValue = &strHeaderValue;
    }
    
    DBG_ASSERT( pstrNewHeaderValue != NULL );

    //
    // pstrNewHeaderValue will point to either "old,new" or "new"
    //
    
    hr = _HeaderBuffer.AllocateSpace( pstrNewHeaderValue->QueryStr(),
                                      pstrNewHeaderValue->QueryCCH(),
                                      &pszNewValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Is this a known header?
    //
    
    index = REQUEST_HEADER_HASH::GetIndex( strHeaderName.QueryStr() );
    if ( index == UNKNOWN_INDEX )
    {
        hr = _HeaderBuffer.AllocateSpace( strHeaderName.QueryStr(),
                                          strHeaderName.QueryCCH(),
                                          &pszNewName );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Find the header in the unknown list
        // 
        
        for ( DWORD i = 0;
              i < _pUlHttpRequest->Headers.UnknownHeaderCount;
              i++ )
        {
            if ( _strnicmp( strHeaderName.QueryStr(),
                            _pUlHttpRequest->Headers.pUnknownHeaders[ i ].pName,
                            strHeaderName.QueryCCH() ) == 0 )
            {
                break;
            }
        }
        
        //
        // If we found the unknown header, then this is much simpler
        //
        
        if ( i < _pUlHttpRequest->Headers.UnknownHeaderCount )
        {
            _pUlHttpRequest->Headers.pUnknownHeaders[i].pRawValue = 
                                    pszNewValue;
            _pUlHttpRequest->Headers.pUnknownHeaders[i].RawValueLength = 
                                    (USHORT) pstrNewHeaderValue->QueryCB();
        }
        else
        {
            HTTP_UNKNOWN_HEADER *pUnknownHeaders;
            DWORD                cCount;

            //
            // Fun.  Need to add a new unknown header
            //

            cCount = _pUlHttpRequest->Headers.UnknownHeaderCount;

            //
            // BUGBUG: are we leaking this memory?
            //
            pUnknownHeaders = (HTTP_UNKNOWN_HEADER *) LocalAlloc( 
                                    LPTR,
                                    sizeof( HTTP_UNKNOWN_HEADER ) * 
                                    ( cCount+1 ) );
            if ( pUnknownHeaders == NULL )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            memcpy( pUnknownHeaders,
                    _pUlHttpRequest->Headers.pUnknownHeaders,
                    sizeof( HTTP_UNKNOWN_HEADER ) * (cCount) );
           
            pUnknownHeaders[ cCount ].pName = pszNewName;
            pUnknownHeaders[ cCount ].NameLength = (USHORT)strHeaderName.QueryCB();

            pUnknownHeaders[ cCount ].pRawValue = pszNewValue;
            pUnknownHeaders[ cCount ].RawValueLength = (USHORT) pstrNewHeaderValue->QueryCB();

            //
            // Patch in the new array
            //
            
            if ( _pExtraUnknown != NULL )
            {
                LocalFree( _pExtraUnknown );
            }
            
            _pExtraUnknown = pUnknownHeaders;
            _pUlHttpRequest->Headers.pUnknownHeaders = pUnknownHeaders;
            _pUlHttpRequest->Headers.UnknownHeaderCount++;
        }
    }
    else
    {
        //
        // The easy case.  Known header
        //
        
        _pUlHttpRequest->Headers.pKnownHeaders[ index ].pRawValue = pszNewValue;
        _pUlHttpRequest->Headers.pKnownHeaders[ index ].RawValueLength = (USHORT) pstrNewHeaderValue->QueryCB();
    }
    
    return S_OK;
}

HRESULT
W3_REQUEST::GetVersionString(
    STRA *              pstrVersion
)
/*++

Routine Description:

    Get version string of request (like "HTTP/1.1")

Arguments:

    pstrVersion - Filled in with version

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    CHAR   pszMajorVersion[6];
    CHAR   pszMinorVersion[6];

    _itoa(_pUlHttpRequest->Version.MajorVersion, pszMajorVersion, 10);
    _itoa(_pUlHttpRequest->Version.MinorVersion, pszMinorVersion, 10);

    if (FAILED(hr = pstrVersion->Copy("HTTP/", 5)) ||
        FAILED(hr = pstrVersion->Append(pszMajorVersion)) ||
        FAILED(hr = pstrVersion->Append(".", 1)) ||
        FAILED(hr = pstrVersion->Append(pszMinorVersion)))
    {
        return hr;
    }

    return S_OK;
}

HRESULT
W3_REQUEST::GetVerbString(
    STRA *              pstrVerb
)
/*++

Routine Description:

    Get the HTTP verb from the request

Arguments:

    pstrVerb - Filled in with verb

Return Value:

    HRESULT

--*/
{
    USHORT cchVerb;
    CHAR *pszVerb = METHOD_HASH::GetString(_pUlHttpRequest->Verb, &cchVerb);
    if (pszVerb != NULL)
    {
        return pstrVerb->Copy(pszVerb, cchVerb);
    }
    else
    {
        return pstrVerb->Copy(_pUlHttpRequest->pUnknownVerb,
                              _pUlHttpRequest->UnknownVerbLength);
    }
}

VOID
W3_REQUEST::QueryVerb(
    CHAR  **ppszVerb,
    USHORT *pcchVerb)
/*++
    Get the HTTP verb from the request
--*/
{
    *ppszVerb = METHOD_HASH::GetString(_pUlHttpRequest->Verb, pcchVerb);
    if (*ppszVerb == NULL)
    {
        *ppszVerb = _pUlHttpRequest->pUnknownVerb;
        *pcchVerb = _pUlHttpRequest->UnknownVerbLength;
    }
}

HRESULT
W3_REQUEST::SetVerb(
    STRA &              strVerb
)
/*++

Routine Description:

    Change the request verb (done in PREPROC_HEADER ISAPI filters)

Arguments:

    strVerb - New verb

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    CHAR *pszNewVerb;

    HTTP_VERB Verb = (HTTP_VERB)METHOD_HASH::GetIndex(strVerb.QueryStr());
    _pUlHttpRequest->Verb = Verb;
    
    if ( Verb == HttpVerbUnknown )
    {
        //
        // Handle unknown verbs
        //

        hr = _HeaderBuffer.AllocateSpace( strVerb.QueryStr(),
                                          strVerb.QueryCCH(),
                                          &pszNewVerb );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _pUlHttpRequest->pUnknownVerb = pszNewVerb;
        _pUlHttpRequest->UnknownVerbLength = (USHORT) strVerb.QueryCCH();
    }
    else
    {
        _pUlHttpRequest->pUnknownVerb = NULL;
        _pUlHttpRequest->UnknownVerbLength = 0;
    }
    
    return S_OK;
}

HRESULT
W3_REQUEST::SetVersion(
    STRA&               strVersion
)
/*++

Routine Description:

    strVersion - Set the request version (done by PREPROC_HEADER filters)

Arguments:

    strVersion - Version string

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = S_OK;
    
    //
    // BUGBUG: Probably not the fastest way to do this
    //
    
    if ( strcmp( strVersion.QueryStr(), "HTTP/1.1" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 1;
        _pUlHttpRequest->Version.MinorVersion = 1;
    }
    else if ( strcmp( strVersion.QueryStr(), "HTTP/1.0" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 1;
        _pUlHttpRequest->Version.MinorVersion = 0;
    }
    else if ( strcmp( strVersion.QueryStr(), "HTTP/0.9" ) == 0 )
    {
        _pUlHttpRequest->Version.MajorVersion = 0;
        _pUlHttpRequest->Version.MinorVersion = 9;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    return hr;
}        

HRESULT
W3_REQUEST::SetNewPreloadedEntityBody(
    VOID *              pvBuffer,
    DWORD               cbBuffer
)
/*++

Routine Description:

    Change the preloaded entity body for this request

Arguments:

    pvBuffer - the buffer
    cbBuffer - the size of the buffer

Return Value:

    HRESULT

--*/
{
    _InsertedEntityBodyChunk.DataChunkType = HttpDataChunkFromMemory;
    _InsertedEntityBodyChunk.FromMemory.pBuffer = pvBuffer;
    _InsertedEntityBodyChunk.FromMemory.BufferLength = cbBuffer;
    _pUlHttpRequest->EntityChunkCount = 1;
    _pUlHttpRequest->pEntityChunks = &_InsertedEntityBodyChunk;
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::AppendEntityBody(
    VOID *            pvBuffer,
    DWORD             cbBuffer
)
/*
  Description
    Add the given entity to (any) entity already present

  Arguments
    pvBuffer - the buffer
    cbBuffer - the size of the buffer

  Return Value
    HRESULT
*/
{
    DWORD cbAlreadyPresent = QueryAvailableBytes();

    if ( cbAlreadyPresent == 0 )
    {
        return SetNewPreloadedEntityBody(pvBuffer, cbBuffer);
    }
    else
    {
        PVOID pbAlreadyPresent = QueryEntityBody();

        if (!_buffEntityBodyPreload.Resize(cbBuffer + cbAlreadyPresent))
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        memcpy(_buffEntityBodyPreload.QueryPtr(),
               pbAlreadyPresent,
               cbAlreadyPresent);

        memcpy((PBYTE)_buffEntityBodyPreload.QueryPtr() + cbAlreadyPresent,
               pvBuffer,
               cbBuffer);
    }

    return S_OK;
}

HRESULT
W3_REQUEST::SetUrl(
    STRU &              strNewUrl,
    BOOL                fResetQueryString // = TRUE
)
/*++

Routine Description:

    Change the URL of the request

Arguments:

    strNewUrl - New URL
    fResetQueryString - TRUE if we should expect query string in strNewUrl

Return Value:

    HRESULT

--*/
{
    STACK_STRA        ( straUrl, MAX_PATH );
    HRESULT             hr = S_OK;

    DWORD lenToConvert = 0;

    WCHAR * pFirstQuery = wcschr(strNewUrl.QueryStr(), L'?');
    if (NULL == pFirstQuery)
    {
        lenToConvert = strNewUrl.QueryCCH();
    }
    else
    {
        lenToConvert = DIFF(pFirstQuery - strNewUrl.QueryStr());
    }

    if (FAILED(hr = straUrl.CopyWToUTF8(strNewUrl.QueryStr(), lenToConvert)))
    {
        return hr;
    }

    straUrl.AppendW(strNewUrl.QueryStr() + lenToConvert);

    //
    // SetUrlA does the canonicalization, unescaping
    //
    
    return SetUrlA( straUrl, fResetQueryString );
}

HRESULT
W3_REQUEST::SetUrlA(
    STRA &              strNewUrl,
    BOOL                fResetQueryString // = TRUE
)
/*++

Routine Description:

    Change the URL of the request.  Takes in an ANSI URL

Arguments:

    strNewUrl - RAW version of URL which is also stored away
    fResetQueryString - Should we expect query string in strNewUrl

Return Value:

    HRESULT

--*/
{
    DWORD               cchNewUrl;
    HRESULT             hr = NO_ERROR;
    ULONG               cbBytesCopied;
    LPWSTR              pszQueryString;
    CHAR *              pszNewRawUrl;
    LPWSTR              pszNewFullUrl;
    LPWSTR              pszNewAbsPath;
    STACK_STRU        ( strFullUrl, MAX_PATH);
    STACK_STRU        ( strAbsPath, MAX_PATH);
    
    //
    // Need to process the URL ourselves.  This means:
    // -Unescaping, canonicalizing, and query-string-ilizing
    //

    //
    // BUGBUG.  Probably need to handle HTTP:// and HTTPS:// preceded URLs
    // so that MS proxy can still work
    //
    
    hr = _HeaderBuffer.AllocateSpace( strNewUrl.QueryStr(),
                                      strNewUrl.QueryCCH(),
                                      &pszNewRawUrl );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Need to patch the UL_HTTP_REQUEST raw URL
    //
    
    _pUlHttpRequest->pRawUrl = pszNewRawUrl;
    _pUlHttpRequest->RawUrlLength = (USHORT) strNewUrl.QueryCCH();

    hr = _HeaderBuffer.AllocateSpace( (strNewUrl.QueryCCH() + 1)*sizeof(WCHAR),
                                      &pszNewAbsPath );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Call into a UL ripped helper to do the parsing
    //
    
    hr = UlCleanAndCopyUrl( (PUCHAR)pszNewRawUrl,
                            strNewUrl.QueryCCH(),
                            &cbBytesCopied,
                            pszNewAbsPath,
                            &pszQueryString );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }

    //
    // Need to patch the UL_HTTP_REQUEST AbsPath and QueryString
    //

    _pUlHttpRequest->CookedUrl.pAbsPath = pszNewAbsPath;

    if ( pszQueryString != NULL )
    {
        _pUlHttpRequest->CookedUrl.pQueryString = pszQueryString;
        _pUlHttpRequest->CookedUrl.AbsPathLength = DIFF(pszQueryString - pszNewAbsPath) * sizeof(WCHAR);
        _pUlHttpRequest->CookedUrl.QueryStringLength = (USHORT)(cbBytesCopied - _pUlHttpRequest->CookedUrl.AbsPathLength);
    }
    else
    {
        if ( fResetQueryString )
        {
            _pUlHttpRequest->CookedUrl.pQueryString = NULL;
            _pUlHttpRequest->CookedUrl.QueryStringLength = 0;
        }
        
        _pUlHttpRequest->CookedUrl.AbsPathLength = (USHORT) cbBytesCopied;
    }

    hr = strAbsPath.Copy(pszNewAbsPath);
    if (FAILED(hr))
    {
        goto Finished;
    }

    //
    // Need to patch up the Full Url.
    //

    BuildFullUrl( strAbsPath, &strFullUrl, FALSE);
    hr = _HeaderBuffer.AllocateSpace( strFullUrl.QueryStr(),
                                      strFullUrl.QueryCCH(),
                                      &pszNewFullUrl );
    if (FAILED(hr))
    {
        goto Finished;
    }

    _pUlHttpRequest->CookedUrl.pFullUrl = pszNewFullUrl;
    _pUlHttpRequest->CookedUrl.FullUrlLength = (USHORT) strFullUrl.QueryCB();

Finished:
    return hr;
}

HRESULT
W3_REQUEST::BuildISAPIHeaderLine(
    CHAR *          pszHeaderName,
    DWORD           cchHeaderName,
    CHAR *          pszHeaderValue,
    DWORD           cchHeaderValue,
    STRA *          pstrHeaderLine
)
/*++

Routine Description:

    Private utility to build a header line as such:
    
    pszHeaderName = "this-is-a-header", pszHeaderValue = "foobar"
    
    PRODUCES
    
    "HTTP_THIS_IS_A_HEADER:foobar\n"

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pszHeaderValue - Header value
    cchHeaderValue - Length of header value
    pstrHeaderLine - Header line is appended

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    CHAR *              pszCursor;
    DWORD               currHeaderLength = pstrHeaderLine->QueryCCH();
    
    //
    // Convert header name "a-b-c" into "HTTP_A_B_C"
    //

    hr = pstrHeaderLine->Append( "HTTP_", 5 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderName, cchHeaderName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
            
    //
    // Convert - to _
    //
            
    pszCursor = strchr( pstrHeaderLine->QueryStr() + currHeaderLength + 5,
                        '-' );
    while ( pszCursor != NULL )
    {
        *pszCursor++ = '_';
        pszCursor = strchr( pszCursor, L'-' );
    }
            
    //
    // Uppercase it
    //

    _strupr( pstrHeaderLine->QueryStr() + currHeaderLength + 5 );
            
    //
    // Now finish the header line by adding ":<header value>\n"
    //
    // Note that raw HTTP looks like ": <header value>", but earlier
    // versions of IIS did not include the space, and there are
    // legacy ISAPI's that depend on the space after the colon
    // not being there.
    //

    hr = pstrHeaderLine->Append( ":", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderValue, cchHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( "\n", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::BuildRawHeaderLine(
    CHAR *          pszHeaderName,
    DWORD           cchHeaderName,
    CHAR *          pszHeaderValue,
    DWORD           cchHeaderValue,
    STRA *          pstrHeaderLine
)
/*++

Routine Description:

    Private utility to build a header line as such:
    
    pszHeaderName = "this-is-a-header", pszHeaderValue = "foobar"
    
    PRODUCES

    this-is-a-header: foobar\r\n

Arguments:

    pszHeaderName - Header name
    cchHeaderName - Length of header name
    pszHeaderValue - Header value
    cchHeaderValue - Length of header value
    pstrHeaderLine - Header line is appended

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    CHAR *              pszCursor;

    hr = pstrHeaderLine->Append( pszHeaderName );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Now finish the header line by adding ": <header value>\n"
    //

    hr = pstrHeaderLine->Append( ": ", 2 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( pszHeaderValue, cchHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrHeaderLine->Append( "\r\n" );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    return NO_ERROR;
}
    
HRESULT
W3_REQUEST::GetAllHeaders(
    STRA *          pstrHeaders,
    BOOL            fISAPIStyle
)
/*++

Routine Description:

    Get all headers in one string, delimited by \r\n

Arguments:

    pstrHeaders - Filled with headers
    fISAPIStyle - 
        If TRUE, format is: HTTP_CONTENT_LENGTH: 245\nHTTP_CONTENT_TYPE: t\n
        If FALSE, format is: CONTENT-LENGTH: 245\r\nCONTENT-TYPE: t\r\n

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    DWORD                       cCounter;
    HTTP_KNOWN_HEADER *         pKnownHeader;
    CHAR *                      pszName;
    DWORD                       cchName;
    HTTP_UNKNOWN_HEADER *       pUnknownHeader; 
    
    if ( pstrHeaders == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Copy known headers
    //
    
    for ( cCounter = 0;
          cCounter < HttpHeaderRequestMaximum;
          cCounter++ )
    {
        pKnownHeader = &(_pUlHttpRequest->Headers.pKnownHeaders[ cCounter ]);
        if ( pKnownHeader->RawValueLength != 0 )
        {
            pszName = REQUEST_HEADER_HASH::GetString( cCounter, &cchName );
            if ( pszName == NULL )
            {
                DBG_ASSERT( FALSE );
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            }

            if ( fISAPIStyle )
            {
                hr = BuildISAPIHeaderLine( pszName,
                                           cchName,
                                           pKnownHeader->pRawValue,
                                           pKnownHeader->RawValueLength,
                                           pstrHeaders );
            }
            else
            {
                hr = BuildRawHeaderLine( pszName,
                                         cchName,
                                         pKnownHeader->pRawValue,
                                         pKnownHeader->RawValueLength,
                                         pstrHeaders );
            }
            
            if ( FAILED( hr ) )
            {
                return hr;
            }            
        }
    }
    
    //
    // Copy unknown headers
    //
    
    for ( cCounter = 0;
          cCounter < _pUlHttpRequest->Headers.UnknownHeaderCount;
          cCounter++ )
    {   
        pUnknownHeader = &(_pUlHttpRequest->Headers.pUnknownHeaders[ cCounter ]);
        
        pszName = pUnknownHeader->pName;
        cchName = pUnknownHeader->NameLength;        

        if ( fISAPIStyle )
        {        
            hr = BuildISAPIHeaderLine( pszName,
                                       cchName,
                                       pUnknownHeader->pRawValue,
                                       pUnknownHeader->RawValueLength,
                                       pstrHeaders );
        }
        else
        {
            hr = BuildRawHeaderLine( pszName,
                                     cchName,
                                     pUnknownHeader->pRawValue,
                                     pUnknownHeader->RawValueLength,
                                     pstrHeaders );
        }
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_REQUEST::CloneRequest(
    DWORD               dwCloneFlags,
    W3_REQUEST **       ppRequest
)
/*++

Routine Description:

    Clone request.  Used to setup a child request to execute

Arguments:

    dwCloneFlags - Flags controlling how much of the current request to clone.
                   Without any flag, we will copy only the bare minimum

                   W3_REQUEST_CLONE_BASICS - clone URL/querystring/Verb
                   W3_REQUEST_CLONE_HEADERS - clone request headers
                   W3_REQUEST_CLONE_ENTITY - clone the entity body
                   W3_REQUEST_CLONE_NO_PRECONDITION - remove range/if-*
                   W3_REQUEST_CLONE_NO_DAV - remove DAV requests

    ppRequest - Set to point to a new W3_REQUEST on success

Return Value:

    HRESULT

--*/
{
    W3_CLONE_REQUEST *          pCloneRequest = NULL;
    HRESULT                     hr = NO_ERROR;
    
    if ( ppRequest == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppRequest = NULL;
    
    //
    // Allocate a new cloned request
    //
    
    pCloneRequest = new W3_CLONE_REQUEST();
    if ( pCloneRequest == NULL )
    {   
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Copy the bare minimum
    //
    
    hr = pCloneRequest->CopyMinimum( _pUlHttpRequest );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we copy the request basics (URL/querystring/Verb)?
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_BASICS )
    {
        hr = pCloneRequest->CopyBasics( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyBasics( NULL );
    }
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we copy the headers?
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_HEADERS )
    {
        hr = pCloneRequest->CopyHeaders( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyHeaders( NULL );
    }

    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Should we also reference the parent's entity body
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_ENTITY )
    {
        hr = pCloneRequest->CopyEntity( _pUlHttpRequest );
    }
    else
    {
        hr = pCloneRequest->CopyEntity( NULL );
    }
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    //
    // Remove conditionals if requested
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_NO_PRECONDITION )
    {
        pCloneRequest->RemoveConditionals();
    }
    
    //
    // Remove DAV'ness if requested
    //
    
    if ( dwCloneFlags & W3_REQUEST_CLONE_NO_DAV  )
    {
        pCloneRequest->RemoveDav();
    }
    
    *ppRequest = pCloneRequest;
    
Finished:
    if ( FAILED( hr ) )
    {
        if ( pCloneRequest != NULL )
        {
            delete pCloneRequest;
            pCloneRequest = NULL;
        }
    }
    
    return hr;
}
  
//static
HRESULT
W3_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Global initalization for utilities used by W3_REQUEST object

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CHAR                achName[ MAX_PATH + 1 ];
    INT                 err;
    HRESULT             hr;
    
    //
    // Get the host name for use in remote/local determination
    //
    
    err = gethostname( achName, sizeof( achName ) );
    if ( err != 0 )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting host name.  hr = %x\n",
                    hr ));
        return hr;
    }
    
    sm_pHostEnt = gethostbyname( achName );
    if ( sm_pHostEnt == NULL )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error getting host.  hr = %x\n",
                    hr ));
        return hr;
    }

    hr = REQUEST_HEADER_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = METHOD_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = W3_CLONE_REQUEST::Initialize();
    if ( FAILED( hr ) )
    {
        REQUEST_HEADER_HASH::Terminate();
        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
W3_REQUEST::Terminate(
    VOID
)
{
    W3_CLONE_REQUEST::Terminate();
    
    REQUEST_HEADER_HASH::Terminate();

    METHOD_HASH::Terminate();
}

HRESULT
W3_CLONE_REQUEST::CopyEntity(
    HTTP_REQUEST *       pRequestToClone
)
/*++

Routine Description:

    Reference the parents entity body if required

Arguments:

    pRequestToClone - UL_HTTP_REQUEST to clone.  NULL if we shouldn't clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        _ulHttpRequest.MoreEntityBodyExists = FALSE;
        _ulHttpRequest.EntityChunkCount = 0;
        _ulHttpRequest.pEntityChunks = NULL;
    }
    else
    {
        _ulHttpRequest.MoreEntityBodyExists = pRequestToClone->MoreEntityBodyExists;
        _ulHttpRequest.EntityChunkCount = pRequestToClone->EntityChunkCount;
        _ulHttpRequest.pEntityChunks = pRequestToClone->pEntityChunks;
    }
    
    return S_OK;
}

HRESULT
W3_CLONE_REQUEST::CopyBasics(
    HTTP_REQUEST *           pRequestToClone
)
/*++

Routine Description:

    Copy the URL/query-string/Verb if required

Arguments:

    pRequestToClone - HTTP_REQUEST to clone.  NULL if we shouldn't clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        _ulHttpRequest.Verb = HttpVerbUnparsed;

        _ulHttpRequest.UnknownVerbLength = 0;
        _ulHttpRequest.pUnknownVerb = NULL;
        
        _ulHttpRequest.RawUrlLength = 0;
        _ulHttpRequest.pRawUrl = NULL;
        
        _ulHttpRequest.CookedUrl.FullUrlLength = 0;
        _ulHttpRequest.CookedUrl.pFullUrl = NULL;
        
        _ulHttpRequest.CookedUrl.HostLength = 0;
        _ulHttpRequest.CookedUrl.pHost = NULL;
        
        _ulHttpRequest.CookedUrl.AbsPathLength = 0;
        _ulHttpRequest.CookedUrl.pAbsPath = NULL;
        
        _ulHttpRequest.CookedUrl.QueryStringLength = 0;
        _ulHttpRequest.CookedUrl.pQueryString = NULL;
    }
    else
    {
        _ulHttpRequest.Verb = pRequestToClone->Verb;

        _ulHttpRequest.UnknownVerbLength = pRequestToClone->UnknownVerbLength;
        _ulHttpRequest.pUnknownVerb = pRequestToClone->pUnknownVerb;
        
        _ulHttpRequest.RawUrlLength = pRequestToClone->RawUrlLength;
        _ulHttpRequest.pRawUrl = pRequestToClone->pRawUrl;
        
        _ulHttpRequest.CookedUrl.FullUrlLength = pRequestToClone->CookedUrl.FullUrlLength;
        _ulHttpRequest.CookedUrl.pFullUrl = pRequestToClone->CookedUrl.pFullUrl;
        
        _ulHttpRequest.CookedUrl.HostLength = pRequestToClone->CookedUrl.HostLength;
        _ulHttpRequest.CookedUrl.pHost = pRequestToClone->CookedUrl.pHost;
        
        _ulHttpRequest.CookedUrl.AbsPathLength = pRequestToClone->CookedUrl.AbsPathLength;
        _ulHttpRequest.CookedUrl.pAbsPath = pRequestToClone->CookedUrl.pAbsPath;
        
        _ulHttpRequest.CookedUrl.QueryStringLength = pRequestToClone->CookedUrl.QueryStringLength;
        _ulHttpRequest.CookedUrl.pQueryString = pRequestToClone->CookedUrl.pQueryString;
    }
    
    return S_OK;
}

HRESULT
W3_CLONE_REQUEST::CopyMinimum(
    HTTP_REQUEST *           pRequestToClone
)
/*++

Routine Description:

    Copies the bare minimum from the clonee.  Bare minimums includes
    remote/local port/address, version, etc.

Arguments:

    pRequestToClone - UL_HTTP_REQUEST to clone

Return Value:

    HRESULT

--*/
{
    if ( pRequestToClone == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Miscellaneous UL goo
    //
    
    _ulHttpRequest.ConnectionId = pRequestToClone->ConnectionId;
    _ulHttpRequest.RequestId = pRequestToClone->RequestId;
    _ulHttpRequest.UrlContext = pRequestToClone->UrlContext;
    _ulHttpRequest.Version = pRequestToClone->Version;

    //
    // Local/Remote address
    //
    
    _ulHttpRequest.Address.RemoteAddressLength = pRequestToClone->Address.RemoteAddressLength;
    _ulHttpRequest.Address.RemoteAddressType = pRequestToClone->Address.RemoteAddressType;
    _ulHttpRequest.Address.LocalAddressLength = pRequestToClone->Address.LocalAddressLength;
    _ulHttpRequest.Address.LocalAddressType = pRequestToClone->Address.LocalAddressType;
    _ulHttpRequest.Address.pRemoteAddress = pRequestToClone->Address.pRemoteAddress;
    _ulHttpRequest.Address.pLocalAddress = pRequestToClone->Address.pLocalAddress;

    //
    // Other stuff
    // 
    
    _ulHttpRequest.RawConnectionId = pRequestToClone->RawConnectionId;
    _ulHttpRequest.pSslInfo = pRequestToClone->pSslInfo;

    return NO_ERROR;
}

HRESULT
W3_CLONE_REQUEST::CopyHeaders(
    HTTP_REQUEST *       pRequestToClone
)
/*++

Routine Description:
    
    Copies request headers from pRequestToClone into the current cloned
    request

Arguments:

    pRequestToClone - HTTP_REQUEST to clone, NULL if there should be no
                      headers

Return Value:

    HRESULT

--*/
{
    DWORD                   cUnknownHeaders;

    if ( pRequestToClone == NULL )
    {
        //
        // No headers.  
        //

        ZeroMemory( &( _ulHttpRequest.Headers ),
                    sizeof( _ulHttpRequest.Headers ) );
    }
    else
    {
        //
        // Copy all the headers
        //
        
        //
        // Start with the known headers.  Note that we can just copy 
        // the Headers member directly.  The memory being referenced by
        // the pointers are guaranteed to be around for the life of this
        // request.  (the memory is either off the UL_NATIVE_REQUEST or
        // it is off a CHUNK_BUFFER from the main parent request)
        //

        memcpy( _ulHttpRequest.Headers.pKnownHeaders,
                pRequestToClone->Headers.pKnownHeaders,
                sizeof( _ulHttpRequest.Headers.pKnownHeaders ) );

        //
        // Copy the unknown headers.  For this case, we will have to 
        // allocate our own buffer since the unknown header array can be 
        // resized.  But as before, the memory referenced by the 
        // unknown headers is OK to reference again.  
        //

        cUnknownHeaders = pRequestToClone->Headers.UnknownHeaderCount;

        if ( cUnknownHeaders > 0 )
        {   
            _pExtraUnknown = (HTTP_UNKNOWN_HEADER*) LocalAlloc( 
                                            LPTR,
                                            sizeof( HTTP_UNKNOWN_HEADER)*
                                            cUnknownHeaders );
            if ( _pExtraUnknown == NULL )
            {   
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
            memcpy( _pExtraUnknown,
                    pRequestToClone->Headers.pUnknownHeaders,
                    cUnknownHeaders * sizeof( HTTP_UNKNOWN_HEADER ) );
        }
            
        _ulHttpRequest.Headers.UnknownHeaderCount = cUnknownHeaders;
        _ulHttpRequest.Headers.pUnknownHeaders = _pExtraUnknown;
    }
    
    return NO_ERROR;
}

VOID
W3_CLONE_REQUEST::RemoveConditionals(
    VOID
)
/*++

Routine Description:

    Remove conditional/range headers from request.  Used to allow a custom
    error URL to work correctly

Arguments:

    None

Return Value:

    None

--*/
{
    HTTP_REQUEST_HEADERS *   pHeaders;

    pHeaders = &(_pUlHttpRequest->Headers);

    //
    // Remove Range:
    //

    pHeaders->pKnownHeaders[ HttpHeaderRange ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderRange ].RawValueLength = 0;

    //
    // Remove If-Modified-Since:
    //

    pHeaders->pKnownHeaders[ HttpHeaderIfModifiedSince ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderIfModifiedSince ].RawValueLength = 0;

    //
    // Remove If-Match:
    //

    pHeaders->pKnownHeaders[ HttpHeaderIfMatch ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderIfMatch ].RawValueLength = 0;

    //
    // Remove If-Unmodifed-Since:
    //

    pHeaders->pKnownHeaders[ HttpHeaderIfUnmodifiedSince ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderIfUnmodifiedSince ].RawValueLength = 0;

    //
    // Remove If-Range:
    //

    pHeaders->pKnownHeaders[ HttpHeaderIfRange ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderIfRange ].RawValueLength = 0;

    //
    // Remove If-None-Match:
    //

    pHeaders->pKnownHeaders[ HttpHeaderIfNoneMatch ].pRawValue = NULL;
    pHeaders->pKnownHeaders[ HttpHeaderIfNoneMatch ].RawValueLength = 0;
}

//static
HRESULT
W3_CLONE_REQUEST::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize clone request lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
    DBG_ASSERT( sm_pachCloneRequests == NULL );

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( W3_CLONE_REQUEST );
    
    sm_pachCloneRequests = new ALLOC_CACHE_HANDLER( "W3_CLONE_REQUEST",
                                                    &acConfig );
    
    if ( sm_pachCloneRequests == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
W3_CLONE_REQUEST::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate clone request lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachCloneRequests != NULL )
    {
        delete sm_pachCloneRequests;
        sm_pachCloneRequests = NULL;
    }
}    

HRESULT
W3_REQUEST::PreloadEntityBody(
    W3_CONTEXT *pW3Context,
    BOOL       *pfComplete
    )
/*++

Routine Description:

    Preload entity body for this request if appropriate

Arguments:

    cbConfiguredReadAhead - Amount to preload
    pfComplete - Set to TRUE if preload is complete

Return Value:

    HRESULT

--*/
{
    DWORD                   cbConfiguredReadAhead;
    DWORD                   cbAvailableAlready = 0;
    PVOID                   pbAvailableAlready = NULL;
    DWORD                   cbAmountToPreload = 0;
    HRESULT                 hr;

    W3_METADATA *pMetadata = pW3Context->QueryUrlContext()->QueryMetaData();
    cbConfiguredReadAhead = pMetadata->QueryEntityReadAhead();

    *pfComplete = FALSE;
    
    //
    // How much entity do we already have available to us?  If it is more
    // than the preload size then we are finished
    //
    
    pbAvailableAlready = QueryEntityBody();
    cbAvailableAlready = QueryAvailableBytes();

    if ( cbAvailableAlready >= cbConfiguredReadAhead )
    {
        *pfComplete = TRUE;
        return S_OK;
    }

    //
    // OK.  We don't have the configured preload-size number of bytes 
    // currently available. 
    // 
    // Do we know how many bytes of entity are available from UL still.
    //

    cbAmountToPreload = pW3Context->QueryRemainingEntityFromUl();
    if ( cbAmountToPreload == INFINITE )
    {
        //
        // Must be a chunked request.  Cap at configured read ahead
        //
        
        cbAmountToPreload = cbConfiguredReadAhead;
    }
    else if ( cbAmountToPreload == 0 )
    {
        //
        // There is no more data available from UL.  
        //
        
        *pfComplete = TRUE;
        return S_OK;
    }
    else
    {
        //
        // There is still data to be read from UL
        //
        
        cbAmountToPreload += cbAvailableAlready;
        cbAmountToPreload = min( cbAmountToPreload, cbConfiguredReadAhead );
    }
    
    //
    // Allocate the buffer
    //
    
    if ( !_buffEntityBodyPreload.Resize( cbAmountToPreload ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Copy any data already available to us
    //

    if ( cbAvailableAlready > 0 &&
         pbAvailableAlready != _buffEntityBodyPreload.QueryPtr())
    {
        DBG_ASSERT( pbAvailableAlready != NULL );

        memcpy( _buffEntityBodyPreload.QueryPtr(),
                pbAvailableAlready,
                cbAvailableAlready );
    }    
    
    //
    // Now read the read from UL asychronously
    //
    
    hr = pW3Context->ReceiveEntity( W3_FLAG_ASYNC,
                                    (PBYTE) _buffEntityBodyPreload.QueryPtr() + cbAvailableAlready,
                                    cbAmountToPreload - cbAvailableAlready,
                                    NULL );                                 

    if ( FAILED( hr ) )
    {
        //
        // In the chunked case, we do not know how many bytes there were so
        // we can hit EOF.  However, if the client sent content-length, then
        // it is an error
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) &&
            pW3Context->QueryRemainingEntityFromUl() == INFINITE)
        {
            pW3Context->SetRemainingEntityFromUl(0);
            *pfComplete = TRUE;
            return S_OK;
        }

        return hr;
    }
    
    *pfComplete = FALSE;
    return S_OK;
}

HRESULT W3_REQUEST::PreloadCompletion(W3_CONTEXT *pW3Context,
                                      DWORD cbRead,
                                      DWORD dwStatus,
                                      BOOL *pfComplete)
{
    if ( dwStatus )
    {
        //
        // In the chunked case, we do not know how many bytes there were so
        // we can hit EOF.  However, if the client sent content-length, then
        // it is an error
        //
        if (dwStatus == ERROR_HANDLE_EOF &&
            pW3Context->QueryRemainingEntityFromUl() == INFINITE)
        {
            pW3Context->SetRemainingEntityFromUl(0);
            *pfComplete = TRUE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(dwStatus);
    }
    
    SetNewPreloadedEntityBody(_buffEntityBodyPreload.QueryPtr(),
                              QueryAvailableBytes() + cbRead);

    return PreloadEntityBody(pW3Context, pfComplete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3site.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    w3site.cxx

Abstract:

    W3_SITE object holds state for each site

Author:

    Anil Ruia (AnilR)              18-Jan-2000

Revision History:

--*/

#include "precomp.hxx"

// 
// No advance notification
//
#define DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS   14

//
// OWA change flags
//
#define DEFAULT_W3_AUTH_CHANGE_FLAGS          6

//
// In seconds
//
#define DEFAULT_W3_ADV_CACHE_TTL              ( 10 * 60 ) 

//static
CRITICAL_SECTION   W3_SITE::sm_csIISCertMapLock;

W3_SITE::W3_SITE( 
    DWORD           SiteId 
) : m_SiteId                          ( SiteId ),
    m_cRefs                           ( 1 ),
    m_pInstanceFilterList             ( NULL ),
    m_pLogging                        ( NULL ),
    m_fAllowPathInfoForScriptMappings ( FALSE ),
    m_fUseDSMapper                    ( FALSE ),
    m_dwAuthChangeFlags               ( 0 ),
    m_dwAdvNotPwdExpInDays            ( DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS ),
    m_dwAdvCacheTTL                   ( DEFAULT_W3_ADV_CACHE_TTL ),
    m_fSSLSupported                   ( FALSE ),
    m_pIISCertMap                     ( NULL ),
    m_fAlreadyAttemptedToLoadIISCertMap    ( FALSE ),
    m_Signature                       ( W3_SITE_SIGNATURE )
{
    ZeroMemory(&m_PerfCounters, sizeof m_PerfCounters);
}

W3_SITE::~W3_SITE()
{
    if (m_pInstanceFilterList != NULL)
    {
        m_pInstanceFilterList->Dereference();
        m_pInstanceFilterList = NULL;
    }
    
    if (m_pLogging != NULL)
    {
        m_pLogging->Release();
        m_pLogging = NULL;
    }

    if ( m_pIISCertMap != NULL )
    {
        m_pIISCertMap->DereferenceCertMapping();
        m_pIISCertMap = NULL;
    }
    m_Signature = W3_SITE_SIGNATURE_FREE;
}

HRESULT
W3_SITE::Initialize(LOGGING *pLogging,
                    FILTER_LIST *pFilterList)
/*++

Routine Description:

    Initialize W3_SITE.  Should be called after constructor

Arguments:
    
    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NO_ERROR;
    WCHAR       idToStr[MAX_SITEID_LENGTH + 6];
    CHAR        idToStrA[MAX_SITEID_LENGTH + 6];

    //
    // Setup Site Name like "W3SVC1"
    //

    sprintf(idToStrA, "W3SVC%u", m_SiteId);
    if (FAILED(hr = m_SiteName.Copy(idToStrA)))
    {
        goto Failure;
    }

    //
    // Setup site path (like "/LM/W3SVC/1")
    //

    hr = m_SiteMBPath.Copy(g_pW3Server->QueryMDPath());
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    _itow(m_SiteId, idToStr, 10);

    hr = m_SiteMBPath.Append( idToStr );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Setup site root (like "/LM/W3SVC/1/ROOT/")
    //

    hr = m_SiteMBRoot.Copy( m_SiteMBPath );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    hr = m_SiteMBRoot.Append( L"/Root/" );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }

    //
    // Read the per-site properties from the metabase
    //
    if (FAILED(hr = ReadPrivateProperties()))
    {
        goto Failure;
    }

    //
    // Initialize instance filters
    //
    if (pFilterList)
    {
        pFilterList->Reference();
        m_pInstanceFilterList = pFilterList;
    }
    else
    {
        m_pInstanceFilterList = new FILTER_LIST();
        if (m_pInstanceFilterList == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Failure;
        }

        hr = m_pInstanceFilterList->InsertGlobalFilters();
        if (FAILED(hr))
        {
            goto Failure;
        }

        hr = m_pInstanceFilterList->LoadFilters(m_SiteMBPath.QueryStr(),
                                                FALSE);
        if (FAILED(hr))
        {
            goto Failure;
        }
    }
    
    //
    // Initialize logging
    //
    if (pLogging)
    {
        pLogging->AddRef();
        m_pLogging = pLogging;
    }
    else
    {
        m_pLogging = new LOGGING;
        if (m_pLogging == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Failure;
        }

        if(FAILED(hr = m_pLogging->ActivateLogging(m_SiteName.QueryStr(),
                                                   m_SiteMBPath.QueryStr(),
                                                   g_pW3Server->QueryMDObject())))
        {
            goto Failure;
        }
    }
    
    return S_OK;
    
Failure:
    return hr;
}

HRESULT W3_SITE::ReadPrivateProperties()
/*++
  Routine description:
    Read the site specific properties from the metabase

  Arguments:
    none

  Return Value:
    HRESULT
--*/
{
    MB mb( g_pW3Server->QueryMDObject() );
    MULTISZ mszSecureBindings;

    //
    // Read per-site properties from the metabase
    //
    if ( !mb.Open(m_SiteMBPath.QueryStr()) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword(L"",
                     MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS,
                     IIS_MD_UT_FILE,
                     (DWORD *)&m_fAllowPathInfoForScriptMappings,
                     0) )
    {
        m_fAllowPathInfoForScriptMappings = FALSE;
    }

    mb.GetStr( L"",
               MD_AUTH_CHANGE_URL,
               IIS_MD_UT_SERVER,
               &m_strAuthChangeUrl );

    mb.GetStr( L"",
               MD_AUTH_EXPIRED_URL,
               IIS_MD_UT_SERVER,
               &m_strAuthExpiredUrl );

    mb.GetStr( L"",
               MD_AUTH_NOTIFY_PWD_EXP_URL,
               IIS_MD_UT_SERVER,
               &m_strAdvNotPwdExpUrl );

    mb.GetStr( L"",
               MD_AUTH_EXPIRED_UNSECUREURL,
               IIS_MD_UT_SERVER,
               &m_strAuthExpiredUnsecureUrl );

    mb.GetStr( L"",
               MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL,
               IIS_MD_UT_SERVER,
               &m_strAdvNotPwdExpUnsecureUrl );

    if ( !mb.GetDword( L"",
                       MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,
                       IIS_MD_UT_SERVER,
                       &m_dwAdvNotPwdExpInDays ) )
    {
        m_dwAdvNotPwdExpInDays = DEFAULT_W3_ADV_NOT_PWD_EXP_IN_DAYS;
    }

    if ( !mb.GetDword( L"",
                       MD_AUTH_CHANGE_FLAGS,
                       IIS_MD_UT_SERVER,
                       &m_dwAuthChangeFlags ) )
    {
        m_dwAuthChangeFlags = DEFAULT_W3_AUTH_CHANGE_FLAGS;
    }

    if ( !mb.GetDword( L"",
                       MD_ADV_CACHE_TTL,
                       IIS_MD_UT_SERVER,
                       &m_dwAdvCacheTTL ) )
    {
        m_dwAdvCacheTTL = DEFAULT_W3_ADV_CACHE_TTL;
    }

    //
    // Read the secure bindings.
    //
    
    if ( mb.GetMultisz( L"",
                        MD_SECURE_BINDINGS,
                        IIS_MD_UT_SERVER,
                        &mszSecureBindings ) )
    {
        if( !mszSecureBindings.IsEmpty() )
        {
            m_fSSLSupported = TRUE;
        }
    }

    DBG_REQUIRE( mb.Close() );

    //
    // Read global properties from the metabase that affect site config
    //

    if ( !mb.Open(g_pW3Server->QueryMDPath()) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( !mb.GetDword( L"",
                       MD_SSL_USE_DS_MAPPER,
                       IIS_MD_UT_SERVER,
                       (DWORD*) &m_fUseDSMapper,
                       0 ))
    {
        m_fUseDSMapper = FALSE;
    }

    DBG_REQUIRE( mb.Close() );

    return S_OK;
}

HRESULT
W3_SITE::HandleMetabaseChange(
    const MD_CHANGE_OBJECT &ChangeObject,
    IN    W3_SITE_LIST     *pTempSiteList
    )
/*++

Routine Description:

    Handle metabase changes. The change may be to
    either the /LM/W3SVC/ node or they may be
    changes to this site or one of its children.

    This routine needs to perform cache flushes
    and reget site metadata if necessary.


Arguments:
    
    ChangeObject
    
Return Value:

See W3_SERVER_INSTANCE::MDChangeNotify and
    IIS_SERVER_INSTANCE::MDChangeNotify for
    implemenation details

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3_SITE Notified - Path(%S) Type(%d) NumIds(%08x)\n",
                ChangeObject.pszMDPath,
                ChangeObject.dwMDChangeType,
                ChangeObject.dwMDNumDataIDs 
                ));

    //
    // Let the cache manager invalidate the various cache entries dependent
    // on metadata
    //

    W3CacheDoMetadataInvalidation( ChangeObject.pszMDPath, 
                                   wcslen( ChangeObject.pszMDPath ) );

    //
    // Handle any site level change
    // That means any changes at /LM/w3svc/n or /LM/w3svc/n/Filters
    //
    if ((_wcsnicmp(ChangeObject.pszMDPath,
                   m_SiteMBPath.QueryStr(),
                   m_SiteMBPath.QueryCCH()) == 0) &&
        ((wcscmp(ChangeObject.pszMDPath + m_SiteMBPath.QueryCCH(),
                 L"/") == 0) ||
         (_wcsicmp(ChangeObject.pszMDPath + m_SiteMBPath.QueryCCH(),
                  L"/Filters/") == 0)))
    {
        //
        // If the site (or its root application) has been deleted, remove it
        // unless we are in the iterator in which case it will anyway be
        // removed
        //
        if (ChangeObject.dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT)
        {
            if (pTempSiteList == NULL)
            {
                g_pW3Server->RemoveSite(this);
            }

            return S_OK;
        }

        //
        // Now handle any property changes.
        //

        BOOL fLoggingHasChanged = FALSE;
        BOOL fFiltersHaveChanged = FALSE;

        //
        // Find out if we would need to handle any logging or filter changes
        //
        for (DWORD i = 0; i < ChangeObject.dwMDNumDataIDs; i++)
        {
            DWORD PropertyID = ChangeObject.pdwMDDataIDs[i];

            if (((PropertyID >= IIS_MD_LOG_BASE) &&
                 (PropertyID <= IIS_MD_LOG_LAST)) ||
                ((PropertyID >= IIS_MD_LOGCUSTOM_BASE) &&
                 (PropertyID <= IIS_MD_LOGCUSTOM_LAST)))
            {
                fLoggingHasChanged = TRUE;
            }
            else if (PropertyID == MD_FILTER_LOAD_ORDER)
            {
                fFiltersHaveChanged = TRUE;
            }
        }

        //
        // Create a new site
        //
        W3_SITE *site = new W3_SITE(m_SiteId);
        if (site == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Copy over the cache context, and also logging and filter info
        // if applicable
        //
        HRESULT hr;
        if (FAILED(hr = site->Initialize(
                            fLoggingHasChanged ? NULL : m_pLogging,
                            fFiltersHaveChanged ? NULL : m_pInstanceFilterList)))
        {
            site->Release();
            return hr;
        }

        //
        // Depending on whether we are in the iterator, either replace the
        // site in the site list or add it to the temp list which will replace
        // the real list later
        //
        if (pTempSiteList == NULL)
        {
            g_pW3Server->AddSite(site, true);
        }
        else
        {
            pTempSiteList->InsertRecord(site);
        }

        // Release the extra reference
        site->Release();
    }

    return S_OK;
}


HRESULT
W3_SITE::GetIISCertificateMapping(
    IIS_CERTIFICATE_MAPPING ** ppIISCertificateMapping
    )
/*++

Routine Description:


Arguments:
    
    ppIISCertificateMapping - returns found iis cert mapping object

    m_pIISCertMap is created on demand. It will not be
    created when W3_SITE is created, only when first request that requires
    certificate mappings
    
Return Value:

    HRESULT

--*/


{
    HRESULT hr = E_FAIL;
    
    DBG_ASSERT( ppIISCertificateMapping != NULL );
        
    
    if ( m_fAlreadyAttemptedToLoadIISCertMap )
    {
        *ppIISCertificateMapping = m_pIISCertMap;
        hr = S_OK;
        goto Finished;
    }
    else
    {
        IIS_CERTIFICATE_MAPPING * pCertMap = NULL;

        //
        // This lock only applies when certmapping was not yet read
        // Global lock will only apply for reading certmapper for site
        // on the very first attempt to fetch file that enables 
        // IIS certmapping 
        //
        
        GlobalLockIISCertMap();

        //
        // try again to prevent loading of mapping multiple times
        //
        if ( m_fAlreadyAttemptedToLoadIISCertMap )
        {
            hr = S_OK;
        }
        else
        {
            //
            // build IIS Certificate mapping structure and
            // add update W3_SITE structure
            //
            if ( m_fUseDSMapper )
            {
                m_pIISCertMap = NULL;
                hr = S_OK;
            }
            else
            {
                hr = IIS_CERTIFICATE_MAPPING::GetCertificateMapping( m_SiteId,
                                                                     &pCertMap );
                if ( SUCCEEDED( hr ) )
                {
                    m_pIISCertMap = pCertMap;
                }
            }
            
            //
            // always set m_fAlreadyAttemptedToLoadIISCertMap to TRUE (regardless of error)
            // that would prevent reading mappings for each request in the case of failure
            // it is valid for m_pIISCertMap to be NULL (regardless of m_fAlreadyAttemptedToLoadIISCertMap)
            //
            
            InterlockedExchange( reinterpret_cast<LONG *>(&m_fAlreadyAttemptedToLoadIISCertMap),
                                 TRUE );
        }        
        GlobalUnlockIISCertMap();
        
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }
    *ppIISCertificateMapping = m_pIISCertMap;
    hr = S_OK;
Finished:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3server.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3server.h

Abstract:

    Type definition for worker process implementation of IIS.

Author:

    Taylor Weiss (TaylorW)       16-Dec-1999

Revision History:

At this point - the following features of the IIS5 code base are
considered obsolete (ie never to be part of IIS+):

1. Service control manager goo
2. RPC administration support
3. Down-level admin support
4. Socket/Endpoint goo
5. Direct handling of site - start/stop/pause/etc
6. Password change support (ie. .htr hooks).


--*/

#ifndef _W3SERVER_H_
#define _W3SERVER_H_

/************************************************************
 *  Include Headers
 ************************************************************/

#include "mb_notify.h"

/************************************************************
 *  Type Definitions  
 ************************************************************/

#define W3_SERVER_MB_PATH       L"/LM/W3SVC/"
#define W3_SERVER_MB_PATH_CCH   10

class   W3_SITE;

/*++

class W3_SERVER

    Encapsulates global settings for an HTTP server run in
    a duct-tape worker process.

    Condenses the relevant functionality exposed in IIS 
    through the IIS_SERVICE and W3_IIS_SERVICE.

--*/

#define W3_SERVER_SIGNATURE             'VRSW'
#define W3_SERVER_FREE_SIGNATURE        'fRSW'

/*++

  class W3_SITE_LIST

    The list of sites serviced by a W3_SERVER.

--*/

class W3_SITE_LIST :
    public CTypedHashTable<W3_SITE_LIST, W3_SITE, DWORD>
{

 public: 

    W3_SITE_LIST() :
        CTypedHashTable<W3_SITE_LIST, W3_SITE, DWORD>("W3_SITE_LIST")
    {}

    static DWORD 
    ExtractKey(const W3_SITE *site);

    static DWORD 
    CalcKeyHash(const DWORD key)
    { 
        return key; 
    }

    static bool 
    EqualKeys(DWORD key1, DWORD key2)
    { 
        return key1 == key2; 
    }

    static VOID
    AddRefRecord(W3_SITE *site, int nIncr);
};

class W3_METADATA_CACHE;
class W3_URL_INFO_CACHE;
class UL_RESPONSE_CACHE;

class W3_SERVER
{
    //
    // CODEWORK
    // Using friends to keep the public interface of this
    // class as clean as possible. It's pretty sleazy so
    // we definitely should undo if it isn't valuable.
    //
    friend class MB_LISTENER;

public:
    
    W3_SERVER( BOOL fCompatibilityMode );

    ~W3_SERVER();

    HRESULT
    Initialize(
        INT             argc,
        LPWSTR          argv[]
    );

    VOID
    Terminate(
        HRESULT hrReason
    );

    HRESULT
    StartListen(
        VOID
    );
    
    IMSAdminBase *
    QueryMDObject(
        VOID
    ) const
    {
        // This is only valid if all are threads are CoInited
        // in the MTA
        return m_pMetaBase;
    }

    LPCWSTR
    QueryMDPath(
        VOID
    ) const
    {
        return W3_SERVER_MB_PATH;
    }

    TOKEN_CACHE *
    QueryTokenCache(
        VOID
    ) const
    {
        return m_pTokenCache;
    }

    W3_FILE_INFO_CACHE *
    QueryFileCache(
        VOID
    ) const
    {
        return m_pFileCache;
    }

    W3_URL_INFO_CACHE *
    QueryUrlInfoCache(
        VOID
    ) const
    {
        return m_pUrlInfoCache;
    }

    W3_METADATA_CACHE *
    QueryMetaCache(
        VOID
    ) const
    {
        return m_pMetaCache;
    }

    UL_RESPONSE_CACHE *
    QueryUlCache(
        VOID
    ) const
    {
        return m_pUlCache;
    }

    DWORD
    QuerySystemChangeNumber(
        VOID
    ) const
    {
        return m_dwSystemChangeNumber;
    }

    W3_SITE *
    FindSite( 
        IN DWORD dwInstance 
        );

    BOOL
    AddSite(
        IN W3_SITE * pInstance,
        IN bool      fOverWrite = false
        );

    BOOL
    RemoveSite(
        IN W3_SITE * pInstance
        );

    VOID
    DestroyAllSites(
        VOID
    );

    VOID WriteLockSiteList()
    {
        m_pSiteList->WriteLock();
    }

    VOID WriteUnlockSiteList()
    {
        m_pSiteList->WriteUnlock();
    }

    HRESULT CollectCounters(
        PBYTE *         ppCounterData,
        DWORD *         pdwCounterData
    );

    HRESULT
    LoadString(
        DWORD               dwStringID,
        CHAR *              pszString,
        DWORD *             pcbString
    );

    VOID
    GetCacheStatistics(
        IISWPGlobalCounters *   pCacheCtrs
    );

    BOOL
    QueryInBackwardCompatibilityMode(
        VOID
    )
    {
        return m_fInBackwardCompatibilityMode;
    }

    HRESULT
    ReadUseDigestSSP(
        VOID
    );

    BOOL
    QueryUseDigestSSP(
        VOID
        )
    {
        return m_fUseDigestSSP;
    }

    CHAR *
    QueryComputerName()
    {
        return m_pszComputerName;
    }

    USHORT
    QueryComputerNameLength()
    {
        return m_cchComputerName;
    }

    void LogEvent(IN DWORD idMessage,
                  IN WORD cSubStrings,
                  IN const WCHAR *apszSubStrings[],
                  IN DWORD errCode = 0)
    {
        m_EventLog.LogEvent(idMessage,
                            cSubStrings,
                            apszSubStrings,
                            errCode);
    }

    static
    VOID
    OnShutdown(
        BOOL fDoImmediate
    );

    static
    VOID
    FlushUlResponses(
        MULTISZ *           pmszUrls
    );

private:

    //
    // Metabase change handlers
    //

    HRESULT 
    MetabaseChangeNotification( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
    );

    HRESULT
    HandleMetabaseChange(
        const MD_CHANGE_OBJECT & ChangeObject
    );

    HRESULT
    InitializeCaches(
        VOID
    );

    VOID
    TerminateCaches(
        VOID
    );
 
    //
    // Internal Types
    //

    enum INIT_STATUS {
        INIT_NONE,
        INIT_SHUTDOWN_EVENT,
        INIT_IISUTIL,
        INIT_WINSOCK,
        INIT_METABASE,
        INIT_MB_LISTENER,
        INIT_FILTERS,
        INIT_W3_SITE,
        INIT_SITE_LIST,
        INIT_ULATQ,
        INIT_CACHES,
        INIT_W3_CONNECTION,
        INIT_W3_CONTEXT,
        INIT_W3_REQUEST,
        INIT_W3_RESPONSE,
        INIT_SERVER_VARIABLES,
        INIT_MIME_MAP,
        INIT_LOGGING,
        INIT_RAW_CONNECTION,
        INIT_CERTIFICATE_CONTEXT,
        INIT_HTTP_COMPRESSION,
        INIT_SERVER
    };

    DWORD               m_Signature;

    //
    // How far have we initialized?
    //
    
    INIT_STATUS         m_InitStatus;

    //
    // All important pointer to ABO 
    //
    
    IMSAdminBase *      m_pMetaBase;

    //
    // Site list
    //
    
    W3_SITE_LIST *      m_pSiteList;

    //
    // Metabase change nofication object
    //

    MB_LISTENER *       m_pMetabaseListener;

    //
    // event log
    //
    EVENT_LOG           m_EventLog;

    //
    // Are we in backward compatibility mode?
    //
    BOOL                m_fInBackwardCompatibilityMode;

    //
    // Do we use new Digest SSP?
    //
    BOOL                m_fUseDigestSSP;

    //
    // Number of current sites
    //
    DWORD               m_cSites;

    //
    // The buffer used to put in all the site and global counters in to
    // pass to WAS
    //
    PBYTE               m_pCounterDataBuffer;
    DWORD               m_dwCounterDataBuffer;

    //
    // The server's name
    //
    CHAR                m_pszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    USHORT              m_cchComputerName;

    //
    // All our caches
    //

    TOKEN_CACHE *       m_pTokenCache;
    W3_FILE_INFO_CACHE* m_pFileCache;
    W3_METADATA_CACHE * m_pMetaCache;
    W3_URL_INFO_CACHE * m_pUrlInfoCache;
    UL_RESPONSE_CACHE * m_pUlCache;

    //
    // :-( System change number.  Tie it to sink for perf reasons
    //

    DWORD               m_dwSystemChangeNumber;
};

extern W3_SERVER *      g_pW3Server;

#endif // _W3SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3response.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :

        w3response.cxx

   Abstract:

        W3_RESPONSE object (a friendly wrapper of UL_HTTP_RESPONSE)
        
   Author:

        Bilal Alam (BAlam)      10-Dec-99

   Project:

        ULW3.DLL
--*/

#include "precomp.hxx"

//
// HTTP Status codes
//

HTTP_STATUS HttpStatusOk                = { 200, REASON("OK") };
HTTP_STATUS HttpStatusPartialContent    = { 206, REASON("Partial Content") };
HTTP_STATUS HttpStatusMultiStatus       = { 207, REASON("Multi Status") };
HTTP_STATUS HttpStatusMovedPermanently  = { 301, REASON("Moved Permanently") };
HTTP_STATUS HttpStatusRedirect          = { 302, REASON("Redirect") };
HTTP_STATUS HttpStatusMovedTemporarily  = { 307, REASON("Moved Temporarily") };
HTTP_STATUS HttpStatusNotModified       = { 304, REASON("Not Modified") };
HTTP_STATUS HttpStatusBadRequest        = { 400, REASON("Bad Request") };
HTTP_STATUS HttpStatusUnauthorized      = { 401, REASON("Unauthorized") };
HTTP_STATUS HttpStatusForbidden         = { 403, REASON("Forbidden") };
HTTP_STATUS HttpStatusNotFound          = { 404, REASON("Not Found") };
HTTP_STATUS HttpStatusMethodNotAllowed  = { 405, REASON("Method Not Allowed") };
HTTP_STATUS HttpStatusNotAcceptable     = { 406, REASON("Not Acceptable") };
HTTP_STATUS HttpStatusProxyAuthRequired = { 407, REASON("Proxy Authorization Required") };
HTTP_STATUS HttpStatusPreconditionFailed= { 412, REASON("Precondition Failed") };
HTTP_STATUS HttpStatusUrlTooLong        = { 414, REASON("URL Too Long") };
HTTP_STATUS HttpStatusRangeNotSatisfiable={ 416, REASON("Requested Range Not Satisfiable") };
HTTP_STATUS HttpStatusLockedError       = { 423, REASON("Locked Error") };
HTTP_STATUS HttpStatusServerError       = { 500, REASON("Internal Server Error") };
HTTP_STATUS HttpStatusNotImplemented    = { 501, REASON("Not Implemented") };
HTTP_STATUS HttpStatusBadGateway        = { 502, REASON("Bad Gateway") };
HTTP_STATUS HttpStatusServiceUnavailable= { 503, REASON("Service Unavailable") };
HTTP_STATUS HttpStatusGatewayTimeout    = { 504, REASON("Gateway Timeout") };

//
// HTTP SubErrors.  This goo is used in determining the proper default error
// message to send to the client when an applicable custom error is not 
// configured
// 
// As you can see, some sub errors have no corresponding resource string. 
// (signified by a 0 index) 
//

HTTP_SUB_ERROR HttpNoSubError           = { 0, 0 };
HTTP_SUB_ERROR Http401BadLogon          = { MD_ERROR_SUB401_LOGON, 0 };
HTTP_SUB_ERROR Http401Config            = { MD_ERROR_SUB401_LOGON_CONFIG, 0 };
HTTP_SUB_ERROR Http401Resource          = { MD_ERROR_SUB401_LOGON_ACL, 0 };
HTTP_SUB_ERROR Http401Filter            = { MD_ERROR_SUB401_FILTER, 0 };
HTTP_SUB_ERROR Http401Application       = { MD_ERROR_SUB401_APPLICATION, 0 };
HTTP_SUB_ERROR Http403ExecAccessDenied  = { MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED, IDS_EXECUTE_ACCESS_DENIED };
HTTP_SUB_ERROR Http403ReadAccessDenied  = { MD_ERROR_SUB403_READ_ACCESS_DENIED, IDS_READ_ACCESS_DENIED };
HTTP_SUB_ERROR Http403WriteAccessDenied = { MD_ERROR_SUB403_WRITE_ACCESS_DENIED, IDS_WRITE_ACCESS_DENIED };
HTTP_SUB_ERROR Http403SSLRequired       = { MD_ERROR_SUB403_SSL_REQUIRED, IDS_SSL_REQUIRED };
HTTP_SUB_ERROR Http403SSL128Required    = { MD_ERROR_SUB403_SSL128_REQUIRED, IDS_SSL128_REQUIRED };
HTTP_SUB_ERROR Http403IPAddressReject   = { MD_ERROR_SUB403_ADDR_REJECT, IDS_ADDR_REJECT };
HTTP_SUB_ERROR Http403CertRequired      = { MD_ERROR_SUB403_CERT_REQUIRED, IDS_CERT_REQUIRED };
HTTP_SUB_ERROR Http403SiteAccessDenied  = { MD_ERROR_SUB403_SITE_ACCESS_DENIED, IDS_SITE_ACCESS_DENIED };      
HTTP_SUB_ERROR Http403TooManyUsers      = { MD_ERROR_SUB403_TOO_MANY_USERS, IDS_TOO_MANY_USERS };          
HTTP_SUB_ERROR Http403PasswordChange    = { MD_ERROR_SUB403_PWD_CHANGE, IDS_PWD_CHANGE };
HTTP_SUB_ERROR Http403MapperDenyAccess  = { MD_ERROR_SUB403_MAPPER_DENY_ACCESS, IDS_MAPPER_DENY_ACCESS };     
HTTP_SUB_ERROR Http403CertRevoked       = { MD_ERROR_SUB403_CERT_REVOKED, IDS_CERT_REVOKED };
HTTP_SUB_ERROR Http403DirBrowsingDenied = { MD_ERROR_SUB403_DIR_LIST_DENIED, IDS_DIR_LIST_DENIED };        
HTTP_SUB_ERROR Http403CertInvalid       = { MD_ERROR_SUB403_CERT_BAD, IDS_CERT_BAD };               
HTTP_SUB_ERROR Http403CertTimeInvalid   = { MD_ERROR_SUB403_CERT_TIME_INVALID, IDS_CERT_TIME_INVALID };
HTTP_SUB_ERROR Http502Timeout           = { MD_ERROR_SUB502_TIMEOUT, IDS_CGI_APP_TIMEOUT };
HTTP_SUB_ERROR Http502PrematureExit     = { MD_ERROR_SUB502_PREMATURE_EXIT, IDS_BAD_CGI_APP };

ALLOC_CACHE_HANDLER * SEND_RAW_BUFFER::sm_pachSendRawBuffers;

HRESULT
W3_RESPONSE::SetHeader(
    DWORD           ulResponseHeaderIndex,
    CHAR *          pszHeaderValue,
    DWORD           cchHeaderValue,
    BOOL            fAppend
)
/*++

Routine Description:
    
    Set a response based on known header index

Arguments:

    ulResponseHeaderIndex - index
    pszHeaderValue - Header value
    cchHeaderValue - Number of characters (without \0) in pszHeaderValue
    
Return Value:

    HRESULT

--*/
{
    STACK_STRA    ( strNewHeaderValue, 32);
    CHAR *        pszNewHeaderValue = NULL;
    HRESULT       hr;

    //
    // If value is too long, reject now
    //
    if (cchHeaderValue > MAXUSHORT)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    DBG_ASSERT( ulResponseHeaderIndex < HttpHeaderResponseMaximum );

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return NULL;
        }
            
        DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    }
    
    if ( fAppend )
    {
        CHAR * headerValue = GetHeader( ulResponseHeaderIndex );
        if ( headerValue == NULL )
        {
            fAppend = FALSE;
        }
        else 
        {
            hr = strNewHeaderValue.Append( headerValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = strNewHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = strNewHeaderValue.Append( pszHeaderValue,
                                           cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            cchHeaderValue = strNewHeaderValue.QueryCCH();
        }
    }

    //
    // Regardless of the "known"osity of the header, we will have to 
    // copy the value.  Do so now.
    //

    hr = _HeaderBuffer.AllocateSpace( fAppend ? strNewHeaderValue.QueryStr() :
                                                pszHeaderValue,
                                      cchHeaderValue,
                                      &pszNewHeaderValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Set the header
    //
    
    return SetHeaderByReference( ulResponseHeaderIndex,
                                 pszNewHeaderValue,
                                 cchHeaderValue );
}

HRESULT
W3_RESPONSE::SetHeader(
    CHAR *              pszHeaderName,
    DWORD               cchHeaderName,
    CHAR *              pszHeaderValue,
    DWORD               cchHeaderValue,
    BOOL                fAppend,
    BOOL                fForceParsed,
    BOOL                fAlwaysAddUnknown
)
/*++

Routine Description:
    
    Set a response based on header name

Arguments:

    pszHeaderName - Points to header name
    cchHeaderName - Number of characters (without \0) in pszHeaderName
    pszHeaderValue - Points to the header value
    cchHeaderValue - Number of characters (without \0) in pszHeaderValue
    fAppend - Should we remove any existing value
    fForceParsed - Regardless of mode, set the header structurally
    fAlwaysAddUnknown - Add as a unknown header always
    
Return Value:

    HRESULT

--*/
{
    DWORD                   cHeaders;
    HTTP_UNKNOWN_HEADER*    pHeader;
    CHAR *                  pszNewName = NULL;
    CHAR *                  pszNewValue = NULL;
    HRESULT                 hr;
    ULONG                   ulHeaderIndex;
    STACK_STRA(             strOldHeaderValue, 128 );

    //
    // If name/value is too long, reject now
    //
    if (cchHeaderName > MAXUSHORT ||
        cchHeaderValue > MAXUSHORT)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Try to stay in raw mode if we're already in that mode
    // 
    // If we are not appending, that means we are just adding a new header
    // so we can just append 
    //
    
    if ( !fForceParsed )
    {
        if ( _responseMode == RESPONSE_MODE_RAW &&
             !fAppend )
        {
            DBG_ASSERT( QueryChunks()->DataChunkType == HttpDataChunkFromMemory );
            DBG_ASSERT( QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() );
        
            hr = _strRawCoreHeaders.Append( pszHeaderName, cchHeaderName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( ": ", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( pszHeaderValue, cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            hr = _strRawCoreHeaders.Append( "\r\n", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            //
            // Patch the headers back in
            //
            
            QueryChunks()->FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
            QueryChunks()->FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
        
            return NO_ERROR;
        }
        else 
        {
            //
            // No luck.  We'll have to parse the headers and switch into parsed
            // mode.
            //
        
            if ( _responseMode == RESPONSE_MODE_RAW )
            {
                hr = SwitchToParsedMode();
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
            
            DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
        }
    }

    //
    // If we're appending, then get the old header value (if any) and 
    // append the new value (with a comma delimiter)
    //

    if ( fAppend )
    {
        hr = GetHeader( pszHeaderName,
                        &strOldHeaderValue );
        if ( FAILED( hr ) )
        {
            fAppend = FALSE;
            hr = NO_ERROR;
        }
        else 
        {
            hr = strOldHeaderValue.Append( ",", 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = strOldHeaderValue.Append( pszHeaderValue,
                                           cchHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            cchHeaderValue = strOldHeaderValue.QueryCCH();
            
            DeleteHeader( pszHeaderName );
        }
    }

    //
    // Regardless of the "known"osity of the header, we will have to 
    // copy the value.  Do so now.
    //
    
    hr = _HeaderBuffer.AllocateSpace( fAppend ? strOldHeaderValue.QueryStr() :
                                                pszHeaderValue,
                                      cchHeaderValue,
                                      &pszNewValue );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    // 

    if ( !fAlwaysAddUnknown )
    {
        ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
        if ( ulHeaderIndex != UNKNOWN_INDEX )
        {
            DBG_ASSERT( ulHeaderIndex < HttpHeaderResponseMaximum );
    
            return SetHeaderByReference( ulHeaderIndex,
                                         pszNewValue,
                                         cchHeaderValue,
                                         fForceParsed );
        }
    }
    
    //
    // OK.  This is an unknown header.  Make a copy of the header name as
    // well and proceed the long way.
    //
    
    hr = _HeaderBuffer.AllocateSpace( pszHeaderName,
                                      cchHeaderName,
                                      &pszNewName );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    cHeaders = ++_ulHttpResponse.Headers.UnknownHeaderCount;
    
    if ( cHeaders * sizeof( HTTP_UNKNOWN_HEADER ) 
          > _bufUnknownHeaders.QuerySize() )
    {
        if ( !_bufUnknownHeaders.Resize( cHeaders * 
                                         sizeof( HTTP_UNKNOWN_HEADER ),
                                         512 ) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }
    _ulHttpResponse.Headers.pUnknownHeaders = (HTTP_UNKNOWN_HEADER*)
                                              _bufUnknownHeaders.QueryPtr();
    
    //
    // We should have a place to put the header now!
    //
    
    pHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ cHeaders - 1 ]);
    pHeader->pName = pszNewName;
    pHeader->NameLength = cchHeaderName;
    pHeader->pRawValue = pszNewValue;
    pHeader->RawValueLength = (USHORT)cchHeaderValue;
    
    _fResponseTouched = TRUE;
    
    return S_OK;
}

HRESULT
W3_RESPONSE::SetHeaderByReference(
    DWORD           ulResponseHeaderIndex,
    CHAR *          pszHeaderValue,
    DWORD           cchHeaderValue,
    BOOL            fForceParsed
)
/*++

Routine Description:
    
    Set a header value by reference.  In other words, the caller takes the
    reponsibility of managing the memory referenced.  The other setheader
    methods copy the header values to a private buffer.

Arguments:

    ulResponseHeaderIndex - index
    pszHeaderValue - Header value
    cbHeaderValue - Size of header value in characters (without 0 terminator)
    fForceParsed - Set to TRUE if we should always used parsed
    
Return Value:

    HRESULT

--*/
{
    HTTP_KNOWN_HEADER *         pHeader;
    HRESULT                     hr;

    //
    // If value is too long, reject now
    //
    if (cchHeaderValue > MAXUSHORT)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    DBG_ASSERT( ulResponseHeaderIndex < HttpHeaderResponseMaximum );
    DBG_ASSERT( pszHeaderValue != NULL || cchHeaderValue == 0 );

    if ( !fForceParsed )
    {
        if ( _responseMode == RESPONSE_MODE_RAW )
        {
            hr = SwitchToParsedMode();
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
        }
    }

    //
    // Set the header
    //
    
    pHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ ulResponseHeaderIndex ]);

    if ( cchHeaderValue == 0 )
    {
        pHeader->pRawValue = NULL;
    }
    else
    {
        pHeader->pRawValue = pszHeaderValue;
        _fResponseTouched = TRUE;
    }
    pHeader->RawValueLength = (USHORT)cchHeaderValue;

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::DeleteHeader(
    CHAR *             pszHeaderName
)
/*++

Routine Description:
    
    Delete a response header

Arguments:

    pszHeaderName - Header to delete
    
Return Value:

    HRESULT

--*/
{
    ULONG                   ulHeaderIndex;
    HRESULT                 hr;
    HTTP_UNKNOWN_HEADER *   pUnknownHeader;
    DWORD                   i;

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    
    //
    // Is this a known header?  If so, we can just set by reference now
    // since we have copied the header value
    // 
    
    ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex != UNKNOWN_INDEX && 
         ulHeaderIndex < HttpHeaderResponseMaximum )
    {
        _ulHttpResponse.Headers.pKnownHeaders[ ulHeaderIndex ].pRawValue = "";
        _ulHttpResponse.Headers.pKnownHeaders[ ulHeaderIndex ].RawValueLength = 0;
    }
    else
    {
        //
        // Unknown header.  First check if it exists
        //
            
        for ( i = 0;
              i < _ulHttpResponse.Headers.UnknownHeaderCount;
              i++ )
        {
            pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pUnknownHeader->pName, pszHeaderName ) == 0 )
            {
                break;
            }
        }
        
        if ( i < _ulHttpResponse.Headers.UnknownHeaderCount )
        {
            //
            // Now shrink the array to remove the header
            //
            
            memmove( _ulHttpResponse.Headers.pUnknownHeaders + i,
                     _ulHttpResponse.Headers.pUnknownHeaders + i + 1,
                     ( _ulHttpResponse.Headers.UnknownHeaderCount - i - 1 ) * 
                     sizeof( HTTP_UNKNOWN_HEADER ) );
        
            _ulHttpResponse.Headers.UnknownHeaderCount--;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::SetStatus(
    USHORT              statusCode,
    STRA &              strReason,
    HTTP_SUB_ERROR &    subError
)
/*++

Routine Description:
    
    Set the status/reason of the response

Arguments:

    status - Status code
    strReason - Reason string
    subError - Optional (default 0)
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    CHAR *              pszNewStatus;
    
    hr = _HeaderBuffer.AllocateSpace( strReason.QueryStr(),
                                      strReason.QueryCCH(),
                                      &pszNewStatus );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _ulHttpResponse.StatusCode = statusCode;
    _ulHttpResponse.pReason = pszNewStatus;
    _ulHttpResponse.ReasonLength = strReason.QueryCCH();
    _subError = subError;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::GetStatusLine(
    STRA *              pstrStatusLine
)
/*++

Routine Description:
    
    What a stupid little function.  Here we generate what the response's
    status line will be

Arguments:

    pstrStatusLine - Filled with status like

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CHAR                achNum[ 32 ];
    
    if ( pstrStatusLine == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    // BUGBUG
    hr = pstrStatusLine->Copy( "HTTP/1.1 " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _itoa( _ulHttpResponse.StatusCode, achNum, 10 );
    
    hr = pstrStatusLine->Append( achNum );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = pstrStatusLine->Append( " ", 1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    hr = pstrStatusLine->Append( _ulHttpResponse.pReason,
                                 _ulHttpResponse.ReasonLength );

    return hr;
} 

HRESULT
W3_RESPONSE::GetHeader(
    CHAR *                  pszHeaderName,
    STRA *                  pstrHeaderValue
)
/*++

Routine Description:
    
    Get a response header

Arguments:

    pszHeaderName - Header to retrieve
    pstrHeaderValue - Filled with header value
    
Return Value:

    HRESULT

--*/
{
    ULONG                       ulHeaderIndex;
    HTTP_UNKNOWN_HEADER *       pUnknownHeader;
    HTTP_KNOWN_HEADER *         pKnownHeader;
    HRESULT                     hr;
    BOOL                        fFound = FALSE;

    if ( pstrHeaderValue == NULL ||
         pszHeaderName == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        hr = SwitchToParsedMode();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );

    ulHeaderIndex = RESPONSE_HEADER_HASH::GetIndex( pszHeaderName );
    if ( ulHeaderIndex == UNKNOWN_INDEX )
    {
        //
        // Unknown header
        //
        
        for ( DWORD i = 0; i < _ulHttpResponse.Headers.UnknownHeaderCount; i++ )
        {
            pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);
            DBG_ASSERT( pUnknownHeader != NULL );
            
            if ( _stricmp( pszHeaderName,
                           pUnknownHeader->pName ) == 0 )
            {
                fFound = TRUE;
                break;
            } 
        }

        if ( fFound )
        {
            return pstrHeaderValue->Copy( pUnknownHeader->pRawValue,
                                          pUnknownHeader->RawValueLength );
        }
        else
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
    else
    {
        //
        // Known header
        //
        // If a filter wanted the Content-Length response header, then we should
        // generate it now (lazily)
        //
        
        if ( ulHeaderIndex == HttpHeaderContentLength )
        {
            CHAR           achNum[ 32 ];

            _ui64toa( QueryContentLength(),
                      achNum,
                      10 );

            hr = SetHeader( HttpHeaderContentLength,
                            achNum,
                            strlen( achNum ) );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        pKnownHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ ulHeaderIndex ]);
        if ( pKnownHeader->pRawValue != NULL &&
             pKnownHeader->RawValueLength != 0 )
        {
            return pstrHeaderValue->Copy( pKnownHeader->pRawValue,
                                          pKnownHeader->RawValueLength );
        }
        else
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_INDEX );
        }
    }
}

VOID
W3_RESPONSE::ClearHeaders(
    VOID
)
/*++

Routine Description:
    
    Clear headers

Arguments:
    
    None
    
Return Value:

    None

--*/
{
    memset( &(_ulHttpResponse.Headers),
            0,
            sizeof( _ulHttpResponse.Headers ) );
}

HRESULT
W3_RESPONSE::AddFileHandleChunk(
    HANDLE                  hFile,
    ULONGLONG               cbOffset,
    ULONGLONG               cbLength
)
/*++

Routine Description:
    
    Add file handle chunk to response

Arguments:
    
    hFile - File handle
    cbOffset - Offset in file
    cbLength - Length of chunk
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         DataChunk;
    HRESULT                 hr;

    _fResponseTouched = TRUE;
    
    DataChunk.DataChunkType = HttpDataChunkFromFileHandle;
    DataChunk.FromFileHandle.ByteRange.StartingOffset.QuadPart = cbOffset;
    DataChunk.FromFileHandle.ByteRange.Length.QuadPart = cbLength;
    DataChunk.FromFileHandle.FileHandle = hFile;
    
    hr = InsertDataChunk( &DataChunk, -1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Update content length count
    //
    
    _cbContentLength += cbLength;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::AddMemoryChunkByReference(
    PVOID                   pvBuffer,
    DWORD                   cbBuffer
)
/*++

Routine Description:
    
    Add memory chunk to W3_RESPONSE.  Don't copy the memory -> we assume
    the caller will manage the memory lifetime

Arguments:
   
    pvBuffer - Memory buffer
    cbBuffer - Size of memory buffer 
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         DataChunk;
    HRESULT                 hr;

    _fResponseTouched = TRUE;
    
    DataChunk.DataChunkType = HttpDataChunkFromMemory;
    DataChunk.FromMemory.pBuffer = pvBuffer;
    DataChunk.FromMemory.BufferLength = cbBuffer;
    
    hr = InsertDataChunk( &DataChunk, -1 );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Update content length count
    //
    
    _cbContentLength += cbBuffer;

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::GetChunks(
    OUT BUFFER *chunkBuffer,
    OUT DWORD  *pdwNumChunks)
{
    if ( !chunkBuffer->Resize( _cChunks * sizeof( HTTP_DATA_CHUNK ) ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    memcpy( chunkBuffer->QueryPtr(),
            _bufChunks.QueryPtr(),
            _cChunks * sizeof( HTTP_DATA_CHUNK ) );

    *pdwNumChunks = _cChunks;

    Clear( TRUE );

    return S_OK;
}

HRESULT
W3_RESPONSE::Clear(
    BOOL                    fClearEntityOnly
)
/*++

Routine Description:
    
    Clear response

Arguments:

    fEntityOnly - Set to TRUE to clear only entity
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    
    if ( !fClearEntityOnly )
    {
        //
        // Must we send the response in raw mode?
        //
    
        _fIncompleteHeaders = FALSE;

        //
        // Raw mode management
        //    
    
        _strRawCoreHeaders.Reset();
        _cFirstEntityChunk  = 0;
    
        //
        // Always start in parsed mode
        //
    
        _responseMode = RESPONSE_MODE_PARSED;

        //
        // Clear headers/status
        //
        
        ClearHeaders();
    }

    _cChunks = _cFirstEntityChunk;
    _cbContentLength = 0;    
    
    return hr;
}

HRESULT
W3_RESPONSE::SwitchToParsedMode(
    VOID
)
/*++

Routine Description:

    Switch to parsed mode

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    CHAR *                  pszHeaders;
    HTTP_DATA_CHUNK *       pCurrentChunk;
    DWORD                   i;
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );
   
    //
    // Loop thru all header chunks and parse them out
    //
    
    for ( i = 0;
          i < _cFirstEntityChunk;
          i++ )
    {
        pCurrentChunk = &(QueryChunks()[ i ]);
        
        DBG_ASSERT( pCurrentChunk->DataChunkType == HttpDataChunkFromMemory );
        
        pszHeaders = (CHAR*) pCurrentChunk->FromMemory.pBuffer;        
        
        if ( i == 0 )
        {
            //
            // The first header chunk contains core headers plus status line
            //
            // (remember to skip the status line)
            //
            
            pszHeaders = strstr( pszHeaders, "\r\n" );
            DBG_ASSERT( pszHeaders != NULL );
            
            pszHeaders += 2;
            DBG_ASSERT( *pszHeaders != '\0' );
        }
        
        hr = ParseHeadersFromStream( pszHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    _strRawCoreHeaders.Reset();
    
    //
    // Any chunks in the response which are actually headers should be 
    // removed
    //
    
    if ( _cFirstEntityChunk != 0 )
    {
        memmove( QueryChunks(),
                 QueryChunks() + _cFirstEntityChunk,
                 ( _cChunks - _cFirstEntityChunk ) * sizeof( HTTP_DATA_CHUNK ) );
        
        _cChunks -= _cFirstEntityChunk;
        _cFirstEntityChunk = 0;
    }
    
    //
    // Cool.  Now we are in parsed mode
    //
    
    _responseMode = RESPONSE_MODE_PARSED;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::SwitchToRawMode(
    W3_CONTEXT *            pW3Context,
    CHAR *                  pszAdditionalHeaders,
    DWORD                   cchAdditionalHeaders
)
/*++

Routine Description:

    Switch into raw mode.
    Builds a raw response for use by raw data filters and/or ISAPI.  This
    raw response will be a set of chunks which contact the entire response
    including serialized headers.
    
Arguments:

    pW3Context - W3 context
    pszAdditionalHeaders - Additional raw headers to add
    cchAdditionalHeaders - Size of additional headers
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    HTTP_DATA_CHUNK         dataChunk;
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );

    //
    // Generate raw core headers
    // 
    
    hr = BuildRawCoreHeaders( pW3Context );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Now fix up the chunks so the raw stream headers are in the right place
    //
    
    //
    // First chunk is the raw core headers (includes the status line)
    //
    
    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
    dataChunk.FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
    
    hr = InsertDataChunk( &dataChunk, 0 );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Remember the beginning of real entity
    //
    
    _cFirstEntityChunk = 1;

    //
    // Now add any additional header stream
    // 
    
    if ( cchAdditionalHeaders != 0 )
    {
        dataChunk.DataChunkType = HttpDataChunkFromMemory;
        dataChunk.FromMemory.pBuffer = pszAdditionalHeaders;
        dataChunk.FromMemory.BufferLength = cchAdditionalHeaders;
        
        hr = InsertDataChunk( &dataChunk, 1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _cFirstEntityChunk++;
    }
    
    //
    // We're now in raw mode
    //
    
    _responseMode = RESPONSE_MODE_RAW;
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::SendResponse(
    W3_CONTEXT *            pW3Context,
    DWORD                   dwResponseFlags,
    DWORD *                 pcbSent,
    HTTP_LOG_FIELDS_DATA *  pUlLogData
)
/*++

Routine Description:
    
    Send a W3_RESPONSE to the client.  This is a very simple wrapper
    of UlAtqSendHttpResponse.

Arguments:

    pW3Context - W3 context (contains amongst other things ULATQ context)
    dwResponseFlags - W3_RESPONSE* flags
    pcbSent - Filled with number of bytes sent (if sync)
    pUlLogData - Log data
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    DWORD                   dwFlags = 0;
    HTTP_CACHE_POLICY       cachePolicy;
    HTTP_DATA_CHUNK *       pStartChunk;
    BOOL                    fFinished = FALSE;
    BOOL                    fAsync;

    DBG_ASSERT( CheckSignature() );

    if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_HEADERS )
    {
        if (_responseMode == RESPONSE_MODE_RAW)
        {
            _cChunks -= _cFirstEntityChunk;

            memmove( QueryChunks(),
                     QueryChunks() + _cFirstEntityChunk,
                     _cChunks * sizeof( HTTP_DATA_CHUNK ) );

            _cFirstEntityChunk = 0;
        }

        return SendEntity( pW3Context,
                           dwResponseFlags,
                           pcbSent,
                           pUlLogData );
    }
    
    if ( dwResponseFlags & W3_RESPONSE_MORE_DATA )
    {
        //
        // More data follows this response?
        //

        dwFlags |= HTTP_SEND_RESPONSE_FLAG_MORE_DATA;
    }
    
    //
    // UL needs to see the disconnect flag on the initial response
    // so that it knows to send the proper connection header to the
    // client.  This needs to happen even if the more data flag is
    // set.
    //

    if ( dwResponseFlags & W3_RESPONSE_DISCONNECT )
    {
        //
        // Disconnect or not?
        // 
    
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }
    
    //
    // Setup cache policy
    //

    if ( dwResponseFlags & W3_RESPONSE_UL_CACHEABLE )
    {
        cachePolicy.Policy = HttpCachePolicyUserInvalidates;
    }    
    else
    {
        cachePolicy.Policy = HttpCachePolicyNocache;
    }

    //
    // Convert to raw if filtering is needed 
    //
    // OR if an ISAPI once gave us incomplete headers and thus we need to
    // go back to raw mode (without terminating headers) 
    //
    // OR an ISAPI has called WriteClient() before sending a response
    //
    
    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) || 
         _fIncompleteHeaders ||
         _fResponseSent )
    {
        if ( _responseMode == RESPONSE_MODE_PARSED )
        {
            hr = GenerateAutomaticHeaders( pW3Context,
                                           dwFlags );
            if ( FAILED( hr ) )
            {
                return hr;
            }

            hr = SwitchToRawMode( pW3Context, 
                                  _fIncompleteHeaders ? "" : "\r\n",
                                  _fIncompleteHeaders ? 0 : 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

        //
        // OK.  This is a little lame.  But the _strRawCoreHeaders may have
        // changed a bit since we last setup the chunks for the header
        // stream.  Just adjust it here
        //

        pStartChunk = QueryChunks();
        pStartChunk[0].FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
        pStartChunk[0].FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();

        //
        // If we're going to be kill entity and/or headers, do so now before
        // calling into the filter
        //

        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = _cFirstEntityChunk;
        }

        //
        // Filter the chunks if needed
        //

        if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
        {
            hr = ProcessRawChunks( pW3Context, &fFinished );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            if ( fFinished )
            {
                dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
                _cChunks = 0;
            }
        }
    }

    //
    // Take care of any compression now
    //

    if ( !_fIncompleteHeaders &&
         pW3Context->QueryUrlContext() != NULL )
    {
        W3_METADATA *           pMetaData;

        pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL );

        if ( !pW3Context->QueryDoneWithCompression() &&
             pMetaData->QueryDoDynamicCompression() )
        {
            if (FAILED(hr = HTTP_COMPRESSION::OnSendResponse(
                    pW3Context,
                    !!( dwResponseFlags & W3_RESPONSE_MORE_DATA ) ) ) )   
            {
                return hr;
            }
        }
    }
    
    //
    // From now on, we must send any future responses raw
    //
    
    _fResponseSent = TRUE;
    
    //
    // Async?
    //
    
    fAsync = dwResponseFlags & W3_RESPONSE_ASYNC ? TRUE : FALSE;

    if ( _responseMode == RESPONSE_MODE_RAW )
    {
        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = _cFirstEntityChunk;
        }

        hr = UlAtqSendEntityBody( pW3Context->QueryUlatqContext(),
                                  fAsync,
                                  dwFlags | HTTP_SEND_RESPONSE_FLAG_RAW_HEADER,
                                  _cChunks,                                  
                                  _cChunks ? QueryChunks() : NULL,
                                  pcbSent,
                                  pUlLogData );
    }
    else
    {
        if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
        {
            _cChunks = 0;
        } 

        _ulHttpResponse.EntityChunkCount = _cChunks;
        _ulHttpResponse.pEntityChunks = _cChunks ? QueryChunks() : NULL;

        hr = UlAtqSendHttpResponse( pW3Context->QueryUlatqContext(),
                                    fAsync,
                                    dwFlags,
                                    &(_ulHttpResponse),
                                    &cachePolicy,
                                    pcbSent,
                                    pUlLogData );
    }

    if ( FAILED( hr ) )
    {
        //
        // If we couldn't send the response thru UL, then this is really bad.
        // Do not reset _fSendRawData since no response will get thru
        //
    }
        
    return hr;
}

HRESULT
W3_RESPONSE::SendEntity(
    W3_CONTEXT *            pW3Context,
    DWORD                   dwResponseFlags,
    DWORD *                 pcbSent,
    HTTP_LOG_FIELDS_DATA *  pUlLogData
)
/*++

Routine Description:
    
    Send entity to the client

Arguments:

    pMainContext - Main context (contains amongst other things ULATQ context)
    dwResponseFlags - W3_REPSONSE flags
    pcbSent - Number of bytes sent (when sync)
    pUlLogData - Log data for the response (this entity is part of response)
    
Return Value:

    Win32 Error indicating status

--*/
{
    HRESULT                 hr = NO_ERROR;
    DWORD                   dwFlags = 0;
    BOOL                    fAsync;
    BOOL                    fFinished = FALSE;

    DBG_ASSERT( CheckSignature() );
    
    //
    // If we get to here and a response hasn't yet been sent, then we must
    // call HttpSendEntity first (not that HTTP.SYS lets us do that)
    //
    
    if ( !_fResponseSent )
    {
        _fResponseSent = TRUE;
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;
    }
    
    //
    // Note that both HTTP_SEND_RESPONSE_FLAG_MORE_DATA and 
    // HTTP_SEND_RESPONSE_FLAG_DISCONNECT cannot be set at the same time
    //

    if ( dwResponseFlags & W3_RESPONSE_MORE_DATA )
    {
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_MORE_DATA;
    }
    else if ( dwResponseFlags & W3_RESPONSE_DISCONNECT )
    {
        dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }

    //
    // Send chunks to be processed if filtering if needed (and there are
    // chunks available)
    //
        
    if ( _cChunks &&
         !( dwFlags & W3_RESPONSE_SUPPRESS_ENTITY ) &&
         pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
    {
        hr = ProcessRawChunks( pW3Context, &fFinished );
        if ( FAILED( hr ) )
        {
            return hr;
        }
            
        if ( fFinished )
        {
            dwFlags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
            _cChunks = 0;
        }
    }
    
    //
    // Take care of any compression now
    //
    if ( pW3Context->QueryUrlContext() != NULL )
    {
        W3_METADATA *pMetaData;
        pMetaData = pW3Context->QueryUrlContext()->QueryMetaData();
        DBG_ASSERT( pMetaData != NULL);

        if (!pW3Context->QueryDoneWithCompression() &&
            pMetaData->QueryDoDynamicCompression())
        {
            if (FAILED(hr = HTTP_COMPRESSION::DoDynamicCompression(
                            pW3Context,
                            dwResponseFlags & W3_RESPONSE_MORE_DATA ? TRUE : FALSE )))
            {
                return hr;
            }
        }
    }

    //
    // If we are suppressing entity (in case of HEAD for example) do it
    // now by clearing the chunk count
    //

    if ( dwResponseFlags & W3_RESPONSE_SUPPRESS_ENTITY )
    {
        _cChunks = 0;
    }
    
    fAsync = ( dwResponseFlags & W3_RESPONSE_ASYNC ) ? TRUE : FALSE;

    //
    // Finally, send stuff out
    //

    hr = UlAtqSendEntityBody(pW3Context->QueryUlatqContext(),
                             fAsync,
                             dwFlags,
                             _cChunks,
                             _cChunks ? QueryChunks() : NULL,
                             pcbSent,
                             pUlLogData);

    return hr;
}

HRESULT
W3_RESPONSE::GenerateAutomaticHeaders(
    W3_CONTEXT *                pW3Context,
    DWORD                       dwFlags
)
/*++

Routine Description:

    Parse-Mode only function
    
    Generate headers which UL normally generates on our behalf.  This means
    
    Server:
    Connection:
    Content-Length:
    Date:

Arguments:

    pW3Context - Helps us build the core headers (since we need to look at 
                 the request).  Can be NULL to indicate to use defaults
    dwFlags - Flags we would have passed to UL
    
Return Value:

    HRESULT

--*/
{
    HTTP_KNOWN_HEADER *         pHeader;
    CHAR *                      pszHeaderValue;
    CHAR                        achDate[ 128 ];
    CHAR                        achNum[ 64 ];
    DWORD                       cchDate;
    DWORD                       cchNum;
    SYSTEMTIME                  systemTime;
    HTTP_VERSION                httpVersion;
    HRESULT                     hr;
    BOOL                        fCreateContentLength;
    BOOL                        fDisconnecting = FALSE;
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_PARSED );
    
    //
    // Server:
    //
    
    pHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ HttpHeaderServer ]);
    if ( pHeader->pRawValue == NULL )
    {
        pHeader->pRawValue = SERVER_SOFTWARE_STRING;
        pHeader->RawValueLength = sizeof( SERVER_SOFTWARE_STRING ) - 1;
    }
    
    //
    // Date:
    //
    
    pHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ HttpHeaderDate ]);
    if ( pHeader->pRawValue == NULL )
    {
        
        if(!IISGetCurrentTimeAsSystemTime(&systemTime))
        {
            GetSystemTime( &systemTime );
        }
        if ( !SystemTimeToGMT( systemTime, 
                               achDate, 
                               sizeof(achDate) ) ) 
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
 
        
        cchDate = strlen( achDate );
        
        hr = _HeaderBuffer.AllocateSpace( achDate,
                                          cchDate,
                                          &pszHeaderValue );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        DBG_ASSERT( pszHeaderValue != NULL );
        
        pHeader->pRawValue = pszHeaderValue;
        pHeader->RawValueLength = cchDate;
    }
    
    //
    // Are we going to be disconnecting?
    //
    
    if ( pW3Context != NULL &&
         ( pW3Context->QueryDisconnect() ||
           pW3Context->QueryRequest()->QueryClientWantsDisconnect() ) )
    {
        fDisconnecting = TRUE;
    }    

    //
    // Connection:
    //
    
    pHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ HttpHeaderConnection ] );
    if ( pHeader->pRawValue == NULL )
    {
        if ( pW3Context == NULL )
        {
            HTTP_SET_VERSION( httpVersion, 1, 0 );
        }
        else
        {
            httpVersion = pW3Context->QueryRequest()->QueryVersion();
        }
    
        if ( fDisconnecting )
        {
            if ( HTTP_GREATER_EQUAL_VERSION( httpVersion, 1, 0 ) )
            {
                pHeader->pRawValue = "close";
                pHeader->RawValueLength = sizeof( "close" ) - 1;
            }   
        }
        else
        {
            if ( HTTP_EQUAL_VERSION( httpVersion, 1, 0 ) )
            {
                pHeader->pRawValue = "keep-alive";
                pHeader->RawValueLength = sizeof( "keep-alive" ) - 1;
            }
        }
    }
    
    //
    // Should we generate content length?
    //
    
    fCreateContentLength = TRUE;
    
    if ( dwFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA )
    {
        fCreateContentLength = FALSE;
    }
    
    if ( fCreateContentLength &&
         QueryStatusCode() / 100 == 1 ||
         QueryStatusCode() == 204 ||
         QueryStatusCode() == 304 )
    {
        fCreateContentLength = FALSE;
    }
    
    if ( fCreateContentLength &&
         pW3Context != NULL &&
         pW3Context->QueryMainContext()->QueryShouldGenerateContentLength() )
    {
        fCreateContentLength = FALSE;
    }
    
    //
    // Now generate if needed
    //
    
    if ( fCreateContentLength )
    {
        //
        // Generate a content length header if needed
        //
    
        pHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ HttpHeaderContentLength ]);
        if ( pHeader->pRawValue == NULL )
        {
            _ui64toa( QueryContentLength(),
                      achNum,
                      10 );

            cchNum = strlen( achNum );
             
            pszHeaderValue = NULL;
                  
            hr = _HeaderBuffer.AllocateSpace( achNum,
                                              cchNum,
                                              &pszHeaderValue );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        
            DBG_ASSERT( pszHeaderValue != NULL );
            
            pHeader->pRawValue = pszHeaderValue;
            pHeader->RawValueLength = cchNum;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::BuildRawCoreHeaders(
    W3_CONTEXT *                pW3Context
)
/*++

Routine Description:

    Build raw header stream for the core headers that UL normally generates
    on our behalf.  This means structured headers and some special 
    "automatic" ones like Connection:, Date:, Server:, etc.

Arguments:

    pW3Context - Helps us build core header (in particular the Connection:)
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    CHAR                    achNumber[ 32 ];
    HTTP_KNOWN_HEADER *     pKnownHeader;
    HTTP_UNKNOWN_HEADER *   pUnknownHeader;
    CHAR *                  pszHeaderName;
    DWORD                   cchHeaderName;
    DWORD                   i;

    if ( pW3Context == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    _strRawCoreHeaders.Reset();
    
    //
    // Build a status line
    //
    
    hr = _strRawCoreHeaders.Copy( "HTTP/1.1 " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _itoa( _ulHttpResponse.StatusCode,
           achNumber,
           10 );
    
    hr = _strRawCoreHeaders.Append( achNumber );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( " " );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( _ulHttpResponse.pReason );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = _strRawCoreHeaders.Append( "\r\n" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Iterate thru all the headers in our structured response and set
    // append them to the stream.  
    //
    // Start with the known headers
    //

    for ( i = 0;
          i < HttpHeaderResponseMaximum;
          i++ )
    {
        pKnownHeader = &(_ulHttpResponse.Headers.pKnownHeaders[ i ]);
        
        if ( pKnownHeader->pRawValue != NULL &&
             pKnownHeader->pRawValue[ 0 ] != '\0' )
        {
            pszHeaderName = RESPONSE_HEADER_HASH::GetString( i, &cchHeaderName );
            DBG_ASSERT( pszHeaderName != NULL );
            
            hr = _strRawCoreHeaders.Append( pszHeaderName, cchHeaderName );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( ": ", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( pKnownHeader->pRawValue,
                                            pKnownHeader->RawValueLength );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            hr = _strRawCoreHeaders.Append( "\r\n", 2 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            //
            // Now clear the header
            //
            
            pKnownHeader->pRawValue = NULL;
            pKnownHeader->RawValueLength = 0;
        }
    }   
    
    //
    // Next, the unknown headers
    //
    
    for ( i = 0;
          i < _ulHttpResponse.Headers.UnknownHeaderCount;
          i++ )
    {
        pUnknownHeader = &(_ulHttpResponse.Headers.pUnknownHeaders[ i ]);

        hr = _strRawCoreHeaders.Append( pUnknownHeader->pName,
                                        pUnknownHeader->NameLength );
        if ( FAILED( hr ) )
        {
            return hr;
        } 
        
        hr = _strRawCoreHeaders.Append( ": ", 2 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = _strRawCoreHeaders.Append( pUnknownHeader->pRawValue,
                                        pUnknownHeader->RawValueLength );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        hr = _strRawCoreHeaders.Append( "\r\n", 2 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Clear the unknown headers
    //
    
    _ulHttpResponse.Headers.UnknownHeaderCount = 0;
        
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::AppendResponseHeaders(
    STRA &                  strHeaders
)
/*++

Routine Description:

    Add response headers (an ISAPI filter special)

Arguments:

    strHeaders - Additional headers to add
                 (may contain entity -> LAAAAAAMMMMME)
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    LPSTR               pszEntity;
    HTTP_DATA_CHUNK     DataChunk;

    if ( strHeaders.IsEmpty() )
    {
        return NO_ERROR;
    }

    if ( _responseMode == RESPONSE_MODE_RAW && 
         QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() )
    {
        DBG_ASSERT( QueryChunks()->DataChunkType == HttpDataChunkFromMemory );
        DBG_ASSERT( QueryChunks()->FromMemory.pBuffer == _strRawCoreHeaders.QueryStr() );
        
        hr = _strRawCoreHeaders.Append( strHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // Patch first chunk since point may have changed
        //
        
        QueryChunks()->FromMemory.pBuffer = _strRawCoreHeaders.QueryStr();
        QueryChunks()->FromMemory.BufferLength = _strRawCoreHeaders.QueryCB();
    }
    else
    {
        hr = ParseHeadersFromStream( strHeaders.QueryStr() );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // Look for entity body in headers
        //

        pszEntity = strstr( strHeaders.QueryStr(), "\r\n\r\n" );
        if ( pszEntity != NULL )
        {
            DataChunk.DataChunkType = HttpDataChunkFromMemory;
            DataChunk.FromMemory.pBuffer = pszEntity + ( sizeof( "\r\n\r\n" ) - 1 );
            DataChunk.FromMemory.BufferLength = strlen( (LPSTR) DataChunk.FromMemory.pBuffer );

            hr = InsertDataChunk( &DataChunk, 0 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    return NO_ERROR;
}

HRESULT
W3_RESPONSE::BuildStatusFromIsapi(
    CHAR *              pszStatus
)
/*++

Routine Description:

    Build up status for response given raw status line from ISAPI

Arguments:

    pszStatus - Status line for response
    
Return Value:

    HRESULT

--*/
{
    USHORT                  status;
    STACK_STRA(             strReason, 32 );
    CHAR *                  pszCursor = NULL;
    HRESULT                 hr = NO_ERROR;
    
    DBG_ASSERT( pszStatus != NULL );
    
    status = (USHORT) atoi( pszStatus );
    if ( status >= 100 &&
         status <= 999 )
    {
        //
        // Need to find the reason string
        //
        
        pszCursor = pszStatus;
        while ( isdigit( *pszCursor ) ) 
        {
            pszCursor++;
        }
            
        if ( *pszCursor == ' ' )
        {
            hr = strReason.Copy( pszCursor + 1 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
        
        hr = SetStatus( (USHORT)status, strReason );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::FilterWriteClient(
    W3_CONTEXT *                pW3Context,
    PVOID                       pvData,
    DWORD                       cbData
)
/*++

Routine Description:

    A non-intrusive WriteClient() for use with filters.  Non-intrusive means
    the current response structure (chunks/headers) is not reset/effected
    by sending this data (think of a WriteClient() done in a SEND_RESPONSE
    filter notification)
    
Arguments:
    
    pW3Context - W3 Context used to help build core response header
    pvData - Pointer to data sent
    cbData - Size of data to send
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK         dataChunk;
    DWORD                   cbSent;
    HTTP_FILTER_RAW_DATA    rawStream;
    BOOL                    fRet;
    BOOL                    fFinished = FALSE;
    DWORD                   dwFlags = HTTP_SEND_RESPONSE_FLAG_MORE_DATA |
                                      HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;
    
    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = pvData;
    dataChunk.FromMemory.BufferLength = cbData;
    
    _fResponseTouched = TRUE;
    
    _fResponseSent = TRUE;

    //
    // If there are send raw filters to be notified, do so now
    //
    
    if ( pW3Context->IsNotificationNeeded( SF_NOTIFY_SEND_RAW_DATA ) )
    {
        rawStream.pvInData = pvData;
        rawStream.cbInData = cbData;
        rawStream.cbInBuffer = cbData;

        fRet = pW3Context->NotifyFilters( SF_NOTIFY_SEND_RAW_DATA,
                                          &rawStream,
                                          &fFinished );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        if ( fFinished )
        {
            rawStream.cbInData = 0;
            rawStream.cbInBuffer = 0;
            dwFlags = HTTP_SEND_RESPONSE_FLAG_DISCONNECT |
                      HTTP_SEND_RESPONSE_FLAG_RAW_HEADER;
        }
        
        dataChunk.FromMemory.pBuffer = rawStream.pvInData;
        dataChunk.FromMemory.BufferLength = rawStream.cbInData;
    }
    
    return UlAtqSendEntityBody( pW3Context->QueryUlatqContext(),
                                FALSE,          // sync
                                dwFlags,
                                1,
                                &dataChunk,
                                &cbSent,
                                NULL ); 
}

HRESULT
W3_RESPONSE::BuildResponseFromIsapi(
    W3_CONTEXT *            pW3Context,
    LPSTR                   pszStatusStream,
    LPSTR                   pszHeaderStream,
    DWORD                   cchHeaderStream
)
/*++

Routine Description:
    
    Shift this response into raw mode since we want to hold onto the
    streams from ISAPI and use them for the response if possible

Arguments:
    
    pW3Context - W3 Context used to help build core response header
                 (can be NULL)
    pszStatusStream - Status stream
    pszHeaderStream - Header stream
    cchHeaderStream - Size of above
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CHAR *              pszEndOfHeaders = NULL;
    CHAR *              pszCursor;
    CHAR *              pszRawAdditionalIsapiHeaders = NULL;
    DWORD               cchRawAdditionalIsapiHeaders = 0;
    CHAR *              pszRawAdditionalIsapiEntity = NULL;
    DWORD               cchRawAdditionalIsapiEntity = 0;
    HTTP_DATA_CHUNK     DataChunk;

    _fResponseTouched = TRUE;

    //
    // First parse the status line.  We do this before switching into raw
    // mode because we want the _strRawCoreHeader string to contain the 
    // correct status line and reason
    //
    
    if ( pszStatusStream != NULL &&
         *pszStatusStream != '\0' )
    {
        hr = BuildStatusFromIsapi( pszStatusStream );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    // If there is no ISAPI header stream set, then we're done
    //
    
    if ( pszHeaderStream == NULL )
    {
        return NO_ERROR;
    }

    //
    // Create automatic headers if necessary (but no content-length)
    //
    
    hr = GenerateAutomaticHeaders( pW3Context,
                                   HTTP_SEND_RESPONSE_FLAG_MORE_DATA );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // The ISAPI set some headers.  Store them now
    //
    
    pszRawAdditionalIsapiHeaders = pszHeaderStream;
    cchRawAdditionalIsapiHeaders = cchHeaderStream;
    
    //
    // If there is additional entity body (after ISAPI headers), then add it
    // Look for a complete set of additional headers.  Complete means that
    // we can find a "\r\n\r\n".  
    //
    
    pszEndOfHeaders = strstr( pszHeaderStream, "\r\n\r\n" );
    if ( pszEndOfHeaders != NULL )
    {
        pszEndOfHeaders += 4;       // go past the \r\n\r\n

        //
        // Update the header length since there is entity tacked on
        //
        
        cchRawAdditionalIsapiHeaders = DIFF( pszEndOfHeaders - pszHeaderStream );
        
        if ( *pszEndOfHeaders != '\0' )
        {
            pszRawAdditionalIsapiEntity = pszEndOfHeaders;
            cchRawAdditionalIsapiEntity = cchHeaderStream - cchRawAdditionalIsapiHeaders;
        }
    }  
    else
    {
        //
        // ISAPI didn't complete the headers.  That means the ISAPI will
        // be completing the headers later.  What this means for us is we 
        // must send the headers in the raw form with out adding our own
        // \r\n\r\n
        //
        
        _fIncompleteHeaders = TRUE;
    }
    
    //
    // Switch into raw mode if we're not already in it
    //
    
    if ( _responseMode == RESPONSE_MODE_PARSED )
    {
        hr = SwitchToRawMode( pW3Context,
                              pszRawAdditionalIsapiHeaders,
                              cchRawAdditionalIsapiHeaders );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
 
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

    //
    // Now add the additional ISAPI entity
    //
    
    if ( cchRawAdditionalIsapiEntity != 0 )
    {
        DataChunk.DataChunkType = HttpDataChunkFromMemory;
        DataChunk.FromMemory.pBuffer = pszRawAdditionalIsapiEntity;
        DataChunk.FromMemory.BufferLength = cchRawAdditionalIsapiEntity;
     
        hr = InsertDataChunk( &DataChunk, -1 );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::GetRawResponseStream(
    STRA *                  pstrResponseStream
)
/*++

Routine Description:

    Fill in the raw response stream for use by raw data filter code
    
Arguments:

    pstrResponseStream - Filled with response stream
    
Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               i;
    CHAR *              pszChunk;
    HTTP_DATA_CHUNK *   pChunks;
    
    if ( pstrResponseStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( _responseMode == RESPONSE_MODE_RAW );

    pChunks = QueryChunks();

    for ( i = 0;
          i < _cFirstEntityChunk;
          i++ )
    {
        DBG_ASSERT( pChunks[ i ].DataChunkType == HttpDataChunkFromMemory );
        
        pszChunk = (CHAR*) pChunks[ i ].FromMemory.pBuffer;
        
        DBG_ASSERT( pszChunk != NULL );
        
        hr = pstrResponseStream->Append( pszChunk );
        if ( FAILED( hr ) ) 
        {
            return hr;
        }
    }
    
    return NO_ERROR;
}

VOID
W3_RESPONSE::Reset(
    VOID
)
/*++

Routine Description:
    
    Initialization of a W3_RESPONSE

Arguments:

    None
    
Return Value:

    None

--*/
{
    _ulHttpResponse.Flags       = 0;

    Clear();

    //
    // Set status to 200 (default)
    //
    SetStatus( HttpStatusOk );

    //
    // Keep track of whether the response has been touched (augmented).  This
    // is useful when determining whether an response was intended
    //
    
    _fResponseTouched   = FALSE;
    
    //
    // This response hasn't been sent yet
    //
    
    _fResponseSent      = FALSE;
}

HRESULT
W3_RESPONSE::InsertDataChunk(
    HTTP_DATA_CHUNK *   pNewChunk,
    LONG                cPosition
)
/*++

Routine Description:

    Insert given data chunk into list of chunks.  The position is determined
    by cPosition.  If a chunk occupies the given spot, it (along with all
    remaining) are shifted forward.

Arguments:
    
    pNewChunk - Chunk to insert
    cPosition - Position of new chunk (0 prepends, -1 appends)
    
Return Value:

    HRESULT

--*/
{
    HTTP_DATA_CHUNK *           pChunks = NULL;
    DWORD                       cOriginalChunkCount;
    
    if ( pNewChunk == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Must be real position or -1
    //
    
    DBG_ASSERT( cPosition >= -1 );
    
    //
    // Allocate the new chunk if needed
    //
    
    cOriginalChunkCount = _cChunks;
    _cChunks += 1;
    
    if ( !_bufChunks.Resize( _cChunks * sizeof( HTTP_DATA_CHUNK ),
                             512 ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    pChunks = QueryChunks();
        
    //
    // If we're appending then this is simple.  Otherwise we must shift
    // 
    
    if ( cPosition == -1 )
    {
        memcpy( pChunks + cOriginalChunkCount,
                pNewChunk,
                sizeof( HTTP_DATA_CHUNK ) );
    }
    else
    {
        if ( cOriginalChunkCount > cPosition )
        {
            memmove( pChunks + cPosition + 1,
                     pChunks + cPosition,
                     sizeof( HTTP_DATA_CHUNK ) * ( cOriginalChunkCount - cPosition ) );
        }                    

        memcpy( pChunks + cPosition,
                pNewChunk,
                sizeof( HTTP_DATA_CHUNK ) );
    }
    
    return NO_ERROR;
}

HRESULT
W3_RESPONSE::ParseHeadersFromStream(
    CHAR *                  pszStream
)
/*++

Routine Description:

    Parse raw headers from ISAPI into the HTTP_RESPONSE

Arguments:

    pszStream - Stream of headers in form (Header: Value\r\nHeader2: value2\r\n)
    
Return Value:

    HRESULT

--*/
{
    CHAR *              pszCursor;
    CHAR *              pszEnd;
    CHAR *              pszColon;
    HRESULT             hr = NO_ERROR;
    STACK_STRA(         strHeaderLine, 128 );
    STACK_STRA(         strHeaderName, 32 );
    STACK_STRA(         strHeaderValue, 64 );
    
    if ( pszStream == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // \r\n delimited
    //
    
    pszCursor = pszStream;
    while ( pszCursor != NULL && *pszCursor != '\0' )
    {
        //
        // Check to see if pszCursor points to the "\r\n"
        // that separates the headers from the entity body
        // of the response and add a memory chunk for any
        // data that exists after it.
        //
        // This is to support ISAPI's that do something like
        // SEND_RESPONSE_HEADER with "head1: value1\r\n\r\nEntity"
        //

        if ( *pszCursor == '\r' && *(pszCursor + 1) == '\n' )
        {
            break;
        }
        
        pszEnd = strstr( pszCursor, "\r\n" );
        if ( pszEnd == NULL )
        {
            break;
        }
        
        //
        // Split out a line and convert to unicode
        //
         
        hr = strHeaderLine.Copy( pszCursor, 
                                 DIFF(pszEnd - pszCursor) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }        

        //
        // Advance the cursor the right after the \r\n
        //

        pszCursor = pszEnd + 2;
        
        //
        // Split the line above into header:value
        //
        
        pszColon = strchr( strHeaderLine.QueryStr(), ':' );
        if ( pszColon == NULL )
        {
            continue;
        }
        else
        {
            if ( pszColon == strHeaderLine.QueryStr() )
            {
                strHeaderName.Reset();
            }
            else
            {
                hr = strHeaderName.Copy( strHeaderLine.QueryStr(),
                                         DIFF(pszColon - strHeaderLine.QueryStr()) );
            }
        }
        
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        //
        // Skip the first space after the : if there is one
        //
        
        if ( pszColon[ 1 ] == ' ' )
        {
            pszColon++;
        }
        
        hr = strHeaderValue.Copy( pszColon + 1 );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        //
        // Add the header to the response
        //

        hr = SetHeader( strHeaderName.QueryStr(),
                        strHeaderName.QueryCCH(),
                        strHeaderValue.QueryStr(),
                        strHeaderValue.QueryCCH(),
                        FALSE,
                        TRUE );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
    }

Finished:

    if ( FAILED( hr ) )
    {
        //
        // Don't allow the response to get into a quasi-bogus-state
        //

        Clear();
    }
    return hr;
}

//static
HRESULT
W3_RESPONSE::ReadFileIntoBuffer(
    HANDLE                  hFile,
    SEND_RAW_BUFFER *       pSendBuffer,
    ULONGLONG               cbCurrentFileOffset
)
/*++

Routine Description:

    Read contents of file into buffer

Arguments:

    hFile - File to read 
    pSendBuffer - Buffer to read into
    cbCurrentFileOffset - Offset to read from
    
Return Value:

    HRESULT

--*/
{
    OVERLAPPED              overlapped;
    LARGE_INTEGER           liOffset;
    BOOL                    fRet;
    DWORD                   cbRead;
    DWORD                   dwError;
    
    if ( hFile == NULL ||
         pSendBuffer == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pSendBuffer->SetLen( 0 );
    
    liOffset.QuadPart = cbCurrentFileOffset;
    
    //
    // Setup overlapped with offset
    //

    ZeroMemory( &overlapped, sizeof( overlapped ) );
    
    overlapped.Offset = liOffset.LowPart;
    overlapped.OffsetHigh = liOffset.HighPart;

    //
    // Do the read
    //
    
    fRet = ReadFile( hFile,
                     pSendBuffer->QueryPtr(),
                     pSendBuffer->QuerySize(),
                     &cbRead,
                     &overlapped );
    if ( !fRet )
    {
        dwError = GetLastError();
        
        if ( dwError == ERROR_IO_PENDING )
        {
            fRet = GetOverlappedResult( hFile,
                                        &overlapped,
                                        &cbRead,
                                        TRUE );
    
            if ( !fRet )
            {
                dwError = GetLastError();
                
                if ( dwError == ERROR_HANDLE_EOF )
                {
                    fRet = TRUE;
                }
            }
        }
        else if ( dwError == ERROR_HANDLE_EOF )
        {
            fRet = TRUE;
        }
    }
    
    //
    // If there was an error, bail
    //
    
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( dwError );
    }
    else
    {
        pSendBuffer->SetLen( cbRead );
        return NO_ERROR;
    }
}

HRESULT
W3_RESPONSE::ProcessRawChunks(
    W3_CONTEXT *                pW3Context,
    BOOL *                      pfFinished
)
/*++

Routine Description:

    Iterate thru chunks, serializing and filtering as needed

Arguments:

    pW3Context - Context used to filter with
    pfFinished - Set to TRUE if filter wanted to finish
    
Return Value:

    HRESULT

--*/
{
    DWORD                   cCurrentChunk = 0;
    DWORD                   cCurrentInsertPos = 0;
    DWORD                   cFileChunkCount = 0;
    HTTP_DATA_CHUNK *       pChunk;
    HTTP_DATA_CHUNK         DataChunk;
    HTTP_FILTER_RAW_DATA    origStream;
    HTTP_FILTER_RAW_DATA    currStream;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fRet;
    LONGLONG                cbCurrentFileOffset;
    LONGLONG                cbTarget;
    SEND_RAW_BUFFER *       pSendBuffer = NULL;
    HANDLE                  hFile;
    
    DBG_ASSERT( pfFinished != NULL );
    DBG_ASSERT( pW3Context != NULL );
    
    *pfFinished = FALSE;
    
    //
    // Start iterating thru chunks
    //
    
    for ( cCurrentChunk = 0;
          cCurrentChunk < _cChunks;
          cCurrentChunk++ )
    {
        pChunk = &(QueryChunks()[ cCurrentChunk ]);

        //
        // First remember this chunk incase filter changed it
        //
        
        //
        // If memory chunk, this is easy.  Otherwise we need to read the file
        // handle and build up memory chunks
        //
        
        if ( pChunk->DataChunkType == HttpDataChunkFromMemory )
        {
            origStream.pvInData = pChunk->FromMemory.pBuffer;
            origStream.cbInData = pChunk->FromMemory.BufferLength;
            origStream.cbInBuffer = pChunk->FromMemory.BufferLength;
       
            memcpy( &currStream, &origStream, sizeof( currStream ) );
       
            fRet = pW3Context->NotifyFilters( SF_NOTIFY_SEND_RAW_DATA,
                                              &currStream,
                                              pfFinished );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
            
            if ( *pfFinished )
            {
                goto Finished;
            }
            
            if ( currStream.pvInData == origStream.pvInData )
            {
                //
                // Just adjust the chunk
                //
                
                pChunk->FromMemory.BufferLength = currStream.cbInData;
            }
            else
            {
                //
                // Allocate new buffer and tweak chunk to refer to it
                //
                
                pSendBuffer = new SEND_RAW_BUFFER;
                if ( pSendBuffer == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                hr = pSendBuffer->Resize( currStream.cbInData );
                if ( FAILED( hr ) )
                {
                    break;
                }
                
                memcpy( pSendBuffer->QueryPtr(),
                        currStream.pvInData,
                        currStream.cbInData );
                        
                pChunk->FromMemory.BufferLength = currStream.cbInData;
                pChunk->FromMemory.pBuffer = pSendBuffer->QueryPtr();
                
                InsertHeadList( &_SendRawBufferHead, 
                                &(pSendBuffer->_listEntry) );
                
                pSendBuffer = NULL;            
            }
        }
        else if ( pChunk->DataChunkType == HttpDataChunkFromFileHandle )
        {
            //
            // Reset file offsets
            //
            
            cbCurrentFileOffset = 0;
            
            //
            // How many bytes are we reading?
            // 
            
            cbTarget = pChunk->FromFileHandle.ByteRange.Length.QuadPart;
            
            //
            // Remember where to start inserting memory chunks
            //
            
            cCurrentInsertPos = cCurrentChunk;

            //
            // First memory replacement chunk can use file handle chunk
            //
            
            cFileChunkCount = 0; 
            
            //
            // Remember the handle now since we will be overwriting this
            // chunk with a memory chunk
            //
            
            hFile = pChunk->FromFileHandle.FileHandle;
            
            while ( cbCurrentFileOffset < cbTarget )
            {
                //
                // Allocate a buffer
                //
                
                pSendBuffer = new SEND_RAW_BUFFER;
                if ( pSendBuffer == NULL )
                {   
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                //
                // Read some of the file into buffer
                //
                
                hr = ReadFileIntoBuffer( hFile,
                                         pSendBuffer,
                                         cbCurrentFileOffset );
                
                if ( FAILED( hr ) )
                {
                    break;
                }
                
                //
                // Update offset
                //
                
                cbCurrentFileOffset += pSendBuffer->QueryCB();
                
                //
                // Setup memory chunk to filter
                //
                
                origStream.pvInData = pSendBuffer->QueryPtr();
                origStream.cbInBuffer = pSendBuffer->QuerySize();
                origStream.cbInData = pSendBuffer->QueryCB();

                memcpy( &currStream, &origStream, sizeof( currStream ) );

                //
                // Filter the data
                //
                
                fRet = pW3Context->NotifyFilters( SF_NOTIFY_SEND_RAW_DATA,
                                                  &currStream,
                                                  pfFinished );
                
                if ( !fRet )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }
                
                if ( *pfFinished )
                {
                    goto Finished;
                }
                
                //
                // Should we keep the file content chunk
                //
                
                if ( currStream.pvInData != origStream.pvInData )
                {   
                    //
                    // We have a new memory address containing data
                    //
                    
                    if ( currStream.cbInData > pSendBuffer->QuerySize() )
                    {
                        hr = pSendBuffer->Resize( currStream.cbInData );
                        if ( FAILED( hr ) )
                        {
                            break;
                        }
                    }
                        
                    memcpy( pSendBuffer->QueryPtr(),
                            currStream.pvInData,
                            currStream.cbInData );
                }
                
                //
                // Add the chunk.  If the first chunk, we can replace
                // the original file handle chunk
                //
                
                if ( cFileChunkCount == 0 )
                {
                    pChunk->DataChunkType = HttpDataChunkFromMemory;
                    pChunk->FromMemory.pBuffer = pSendBuffer->QueryPtr();
                    pChunk->FromMemory.BufferLength = currStream.cbInData;
                    
                    cCurrentInsertPos++;
                }
                else
                {
                    DataChunk.DataChunkType = HttpDataChunkFromMemory;
                    DataChunk.FromMemory.pBuffer = pSendBuffer->QueryPtr();
                    DataChunk.FromMemory.BufferLength = currStream.cbInData;

                    hr = InsertDataChunk( &DataChunk,
                                          cCurrentInsertPos++ );
                    if ( FAILED( hr ) )
                    {
                        break;
                    }
                }
                
                InsertHeadList( &_SendRawBufferHead, 
                                &(pSendBuffer->_listEntry) );
                
                pSendBuffer = NULL;            
                
                cFileChunkCount++;
            }
            
            //
            // If we're here because of failure, bail
            //
            
            if ( FAILED( hr ) )
            {
                break;
            }
            
            //
            // Update current chunk to be processed
            //
            
            cCurrentChunk = cCurrentInsertPos;
        }
        else
        {
            //
            // Only support file-handle and memory chunks
            //
            
            DBG_ASSERT( FALSE );
        }
    }

Finished:

    if ( pSendBuffer != NULL )
    {
        delete pSendBuffer;
    }
    
    return hr;
}

//static
HRESULT
W3_RESPONSE::Initialize(
    VOID
)
/*++

Routine Description:

    Enable W3_RESPONSE globals

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    
    hr = RESPONSE_HEADER_HASH::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = SEND_RAW_BUFFER::Initialize();
    if ( FAILED( hr ) )
    {
        RESPONSE_HEADER_HASH::Terminate();
    }
   
    return hr;
}

//static
VOID
W3_RESPONSE::Terminate(
    VOID
)
{
    SEND_RAW_BUFFER::Terminate();

    RESPONSE_HEADER_HASH::Terminate();
}

CONTEXT_STATUS
W3_STATE_RESPONSE::DoWork(
    W3_MAIN_CONTEXT *       pMainContext,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    This state is responsible for ensuring that a response does get sent
    back to the client.  We hope/expect that the handlers will do their
    thing -> but if they don't we will catch that here and send a response

Arguments:

    pMainContext - Context
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    W3_RESPONSE*            pResponse;
    DWORD                   dwOldState;
    HRESULT                 hr;
    
    pResponse = pMainContext->QueryResponse();
    DBG_ASSERT( pResponse != NULL );
    
    //
    // Has a response been sent?  If not, bail
    //
    
    if ( pMainContext->QueryResponseSent() )
    {
        return CONTEXT_STATUS_CONTINUE;
    }
    
    //
    // If the response has been touched, then just send that response.  Else
    // send a 500 error
    //
    
    if ( !pResponse->QueryResponseTouched() )
    {
        pResponse->SetStatus( HttpStatusServerError );
    }

    //
    // Send it out
    //

    hr = pMainContext->SendResponse( W3_FLAG_ASYNC );
    if ( FAILED( hr ) )
    {
        pMainContext->SetErrorStatus( hr );
        return CONTEXT_STATUS_CONTINUE;
    }
    else
    {
        return CONTEXT_STATUS_PENDING;
    }
}

CONTEXT_STATUS
W3_STATE_RESPONSE::OnCompletion(
    W3_MAIN_CONTEXT *       pW3Context,
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Subsequent completions in this state

Arguments:

    pW3Context - Context
    cbCompletion - Number of bytes in an async completion
    dwCompletionStatus - Error status of a completion
    
Return Value:

    CONTEXT_STATUS_PENDING or CONTEXT_STATUS_CONTINUE

--*/
{
    //
    // We received an IO completion.  Just advance since we have nothing to
    // cleanup
    //
    
    return CONTEXT_STATUS_CONTINUE;
}  

//static
HRESULT
SEND_RAW_BUFFER::Initialize(
    VOID
)
/*++

Routine Description:

    Global initialization routine for SEND_RAW_BUFFERs

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;

    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( SEND_RAW_BUFFER );

    DBG_ASSERT( sm_pachSendRawBuffers == NULL );
    
    sm_pachSendRawBuffers = new ALLOC_CACHE_HANDLER( "SEND_RAW_BUFFER",  
                                                      &acConfig );

    if ( sm_pachSendRawBuffers == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
SEND_RAW_BUFFER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate MAIN_CONTEXT globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachSendRawBuffers != NULL )
    {
        delete sm_pachSendRawBuffers;
        sm_pachSendRawBuffers = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachedir.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachedir.cxx

   Abstract:
     Dir monitor for cache manager
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)

BOOL
CacheDirMonitorEntry::ActOnNotification(
    DWORD               dwStatus,
    DWORD               dwBytesWritten
)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    dwStatus - Win32 status for dirmon completion
    dwBytesWritten - Bytes written in dir change buffer

Return Value:

    TRUE if directory should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *   pNotify = NULL;
    FILE_NOTIFY_INFORMATION *   pNextNotify = NULL;
    STACK_STRU(                 strFileChanged, MAX_PATH );
    DWORD                       cch = 0;
    HANDLE                      hDir;
    BOOL                        fContinueMonitoring = TRUE;
    HRESULT                     hr = NO_ERROR;

    //
    // If there was an error monitoring directory, then flush the entire
    // directory
    //
    
    if ( dwStatus != ERROR_SUCCESS )
    {
        //
        // Access denied means directory either was deleted or secured
        // Stop monitoring in that case
        //
        
        if ( dwStatus == ERROR_ACCESS_DENIED )
        {
            fContinueMonitoring = FALSE;
        }  
        else
        {
            _cNotificationFailures++;
            
            if ( _cNotificationFailures > MAX_NOTIFICATION_FAILURES )
            {
                fContinueMonitoring = FALSE;
            }
        }
    }
    else
    {   
        _cNotificationFailures = 0;
    }
    
    //
    // If no bytes were written, then take the conservative approach and flush
    // everything for this physical prefix
    //
    
    if ( dwBytesWritten == 0 )
    {
        FileChanged( L"", TRUE );
    }
    else 
    {
        pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

        while ( pNextNotify != NULL )
        {
            BOOL bDoFlush = TRUE;

            pNotify = pNextNotify;
            pNextNotify = (FILE_NOTIFY_INFORMATION*) ((PCHAR) pNotify + pNotify->NextEntryOffset);

            //
            // Get the unicode file name from the notification struct
            // pNotify->FileNameLength returns the wstr's length in **bytes** not wchars
            //

            hr = strFileChanged.Copy( pNotify->FileName,
                                      pNotify->FileNameLength / 2 );
            if ( FAILED( hr ) )
            {
                SetLastError( WIN32_FROM_HRESULT( hr ) );
                return FALSE;
            }

            // Take the appropriate action for the directory change
            switch (pNotify->Action)
            {
                case FILE_ACTION_MODIFIED:
                    //
                    // Since this change won't change the pathname of
                    // any files, we don't have to do a flush.
                    //
                    bDoFlush = FALSE;
                case FILE_ACTION_REMOVED:
                case FILE_ACTION_RENAMED_OLD_NAME:
                    FileChanged(strFileChanged.QueryStr(), bDoFlush);
                    break;
                case FILE_ACTION_ADDED:
                case FILE_ACTION_RENAMED_NEW_NAME:
                default:
                    break;
            }

            if( pNotify == pNextNotify )
            {
                break;
            }
        }
    }
    
    return fContinueMonitoring;
}

VOID
CacheDirMonitorEntry::FileChanged(
    const WCHAR *               pszScriptName, 
    BOOL                        bDoFlush
)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName - Name of file that changed
    bDoFlush - Should we flush all entries prefixed wih pszScriptName

Return Value:

    None

--*/
{
    STACK_STRU(         strLongName, MAX_PATH );
    STACK_STRU(         strFullPath, MAX_PATH );
    const WCHAR *       pszLongName;
    DWORD               cchLongName;
    HRESULT             hr;

    //
    // Convert any short file names
    //
    
    if ( wcschr( pszScriptName, L'~' ) != NULL )
    {
        cchLongName = GetLongPathName( pszScriptName,
                                       strLongName.QueryStr(),
                                       MAX_PATH );
        if ( cchLongName == 0 || cchLongName > MAX_PATH )
        {
            pszLongName = L"";
        }
        else
        {
            pszLongName = strLongName.QueryStr();
        }
    }
    else
    {
        pszLongName = pszScriptName;
    }
    
    //
    // Create full path of file changed
    //

    hr = strFullPath.Copy( m_pszPath );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    hr = strFullPath.Append( L"\\", 1 );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    hr = strFullPath.Append( pszLongName );
    if ( FAILED( hr ) )
    {
        return;
    }
    
    _wcsupr( strFullPath.QueryStr() );

    //
    // Now call the caches
    //
    
    g_pCacheManager->HandleDirMonitorInvalidation( strFullPath.QueryStr(),
                                                   bDoFlush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_OPLOCKS             0x00010000
# define    DEBUG_DIRECTORY_CHANGE    0x00020000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\wam_process.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     wam_process.cxx

   Abstract:
     Manages OOP ISAPI processes
 
   Author:
     Wade Hilmo (wadeh)             10-Oct-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL

--*/

#include <initguid.h>
#include "precomp.hxx"
#include "isapi_handler.h"
#include "iwam_i.c"
#include "wam_process.hxx"

WAM_PROCESS::WAM_PROCESS(
    LPCWSTR                 szWamClsid,
    WAM_PROCESS_MANAGER *   pWamProcessManager,
    LPCSTR                  szIsapiHandlerInstance
    )
    : _cCurrentRequests( 0 ),
      _cTotalRequests( 0 ),
      _cRefs( 1 ),
      _pWamProcessManager( pWamProcessManager ),
      _pIWam( NULL ),
      _bstrInstanceId( NULL ),
      _cMaxRequests( 0 ),
      _dwProcessId( 0 ),
      _hProcess( NULL ),
      _fGoingAway( FALSE )
/*++

Routine Description:

    Constructor

Arguments:

    szWamClsid             - The CLSID of the WAM application to create
    pWamProcessManager     - A pointer to the WAM process manager
    szIsapiHandlerInstance - The instance ID of the ISAPI handler
                             that's creating this object.  Used for
                             debugging purposes

Return Value:

    None

--*/
{
    _pWamProcessManager->AddRef();

    InitializeListHead( &_RequestListHead );
    
    wcsncpy(
        _szWamClsid,
        szWamClsid,
        SIZE_CLSID_STRING
        );

    _szWamClsid[SIZE_CLSID_STRING - 1] = L'\0';

    strncpy(
        _szIsapiHandlerInstance,
        szIsapiHandlerInstance,
        SIZE_CLSID_STRING
        );

    _szIsapiHandlerInstance[SIZE_CLSID_STRING - 1] = '\0';

    INITIALIZE_CRITICAL_SECTION( &_csRequestList );
};

HRESULT
WAM_PROCESS::Create(
    VOID
    )
/*++

Routine Description:

    Initializes the parts of the WAM_PROCESS object not
    appropriate to the constructor.  This includes starting
    up the remote process via CoCreateInstance and collecting
    data about the process once it's running

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CLSID   clsid;
    HRESULT hr = NOERROR;
    LPWSTR  szIsapiModule;
    DWORD   cbIsapiModule;

    STACK_STRA( strClsid, SIZE_CLSID_STRING );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating WAM_PROCESS %p, CLSID=%S.\r\n",
            this,
            _szWamClsid
            ));
    }

    //
    // Get some info about the ISAPI module
    //

    DBG_REQUIRE( szIsapiModule = _pWamProcessManager->QueryIsapiModule() );
    cbIsapiModule = ( wcslen( szIsapiModule ) + 1 ) * sizeof( WCHAR );

    //
    // Get the CLSID for this WAM_PROCESS
    //

    hr = CLSIDFromString(
        (LPOLESTR)_szWamClsid,
        &clsid
        );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    hr = strClsid.CopyW( _szWamClsid );

    if ( FAILED( hr ) )
    {
        goto ErrorExit;
    }

    //
    // CoCreate it
    //

    hr = CoCreateInstance(
        clsid,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IWam,
        (void**)&_pIWam
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to CoCreate WAM.\r\n",
            this
            ));

        _pIWam = NULL;

        goto ErrorExit;
    }

    //
    // Now initialize it.
    //

    _dwProcessId = 0;
    _hProcess = NULL;

    hr = _pIWam->WamInitProcess(
        (BYTE*)szIsapiModule,
        cbIsapiModule,
        &_dwProcessId,
        strClsid.QueryStr(),
        _szIsapiHandlerInstance,
        GetCurrentProcessId()
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  WamInitProcess failed.\r\n",
            this
            ));

        goto ErrorExit;
    }

    //
    // Get a handle to the new process
    //

    _hProcess = OpenProcess(
        PROCESS_DUP_HANDLE | PROCESS_TERMINATE,
        FALSE,
        _dwProcessId
        );

    if ( !_hProcess )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to get process handle.\r\n",
            this
            ));

        goto ErrorExit;
    }

    hr = _pWamProcessManager->QueryCatalog()->GetApplicationInstanceIDFromProcessID(
        _dwProcessId,
        &_bstrInstanceId
        );

    if ( FAILED( hr ) )
    {
        //
        // If we've made it this far, then it's not reasonable for the
        // above GetApplicationInstanceIDFromProcessID call to fail.
        //

        DBG_ASSERT( FALSE && "GetApplicationInstanceIDFromProcessID failed on running app." );

        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p.  Failed to get instance ID.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Attempt to create WAM_PROCESS %p failed.  CLSID=%S, HRESULT=%08x.\r\n",
        this,
        _szWamClsid,
        hr
        ));

    if ( _bstrInstanceId )
    {
        SysFreeString( _bstrInstanceId );
        _bstrInstanceId = NULL;
    }

    if ( _pIWam )
    {
        _pIWam->Release();
        _pIWam = NULL;
    }

    //
    // Since COM can sometimes return bogus failures when
    // we try and get the instance ID, we need to check to
    // see if the process was really created and terminate
    // it if so.
    //

    if ( _hProcess )
    {
        TerminateProcess( _hProcess, 0 );

        CloseHandle( _hProcess );

        _hProcess = NULL;
        _dwProcessId = 0;
    }

    return hr;
}

HRESULT
WAM_PROCESS::ProcessRequest(
    ISAPI_REQUEST *     pIsapiRequest,
    ISAPI_CORE_DATA *   pIsapiCoreData,
    DWORD *             pdwHseResult
    )
/*++

Routine Description:

    Processes a request by passing the necessary data
    to the OOP host.

Arguments:

    pIsapiRequest  - The ISAPI_REQUEST for this request
    pIsapiCoreData - The core data for the request
    pdwHseResult   - Upon return, the return code from HttpExtensionProc

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;
    DWORD       dwHseResult;
    
    //
    // Bump the counters for this process and
    // Add a reference for the request to both
    // the process object and to the ISAPI request
    // object.
    //

    InterlockedIncrement( &_cTotalRequests );
    InterlockedIncrement( &_cCurrentRequests );

/*
    //
    // We need to keep a list of outstanding requests so that we
    // can clean everything up in the case of shutdown or an OOP
    // crash.
    //

    LockRequestList();
    InsertHeadList( &_RequestListHead, &pIsapiRequest->_leRequest );
    UnlockRequestList();
*/
    //
    // Associate the WAM process with the ISAPI_REQUEST and call
    // out to the OOP host.  This essentially causes the ISAPI_REQUEST
    // to take a reference on this object until it's destroyed.
    //

    pIsapiRequest->SetAssociatedWamProcess( this );

    hr = _pIWam->WamProcessIsapiRequest(
        (BYTE*)pIsapiCoreData,
        pIsapiCoreData->cbSize,
        pIsapiRequest,
        &dwHseResult
        );

    //
    // Check for failure.
    //

    if ( FAILED( hr ) )
    {
        //
        // Need to check for special case failures that result
        // from OOP process crashes.
        //
        // RPC_S_CALL_FAILED        - indicates OOP process crashed
        //                            during the call.
        // RPC_S_CALL_FAILED_DNE    - indicates OOP process crashed
        //                            before the call.
        // RPC_S_SERVER_UNAVAILABLE - The OOP process was just not there
        //                             (ie. previously crashed, etc.)
        //

        if ( WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED_DNE ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_SERVER_UNAVAILABLE )
        {
            //
            // WARNING - HandleCrash can potentially cause this object
            //           to be destroyed.  Don't do anything except
            //           return after calling it!
            //
            
            HandleCrash();
            return hr;
        }
    }

    *pdwHseResult = dwHseResult;

    return hr;
}

HRESULT
WAM_PROCESS::ProcessCompletion(
    ISAPI_REQUEST *     pIsapiRequest,
    DWORD64             IsapiContext,
    DWORD               cbCompletion,
    DWORD               dwCompletionStatus
    )
/*++

Routine Description:

    Processes a completion by passing the necessary data
    to the OOP host.

Arguments:

    pIsapiRequest      - The ISAPI_REQUEST for this request
    IsapiContext       - The ISAPI_CONTEXT that identifies the request (opaque)
    cbCompletion       - The number of bytes associated with the completion
    dwCompletionStatus - The result code for the completion

Return Value:

    HRESULT

--*/
{
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiRequest );
    DBG_ASSERT( IsapiContext != 0 );

    hr = pIsapiRequest->PreprocessIoCompletion( cbCompletion );

    pIsapiRequest->ResetIsapiContext();

    //
    // Let the OOP process handle the completion
    //
    
    hr = _pIWam->WamProcessIsapiCompletion(
        IsapiContext,
        cbCompletion,
        dwCompletionStatus
        );

    //
    // This release balances the release taken when the ISAPI_REQUEST
    // made the async call into the server core.
    //

    pIsapiRequest->Release();

    //
    // Check for failure.
    //

    if ( FAILED( hr ) )
    {
        //
        // Need to check for special case failures that result
        // from OOP process crashes.
        //
        // RPC_S_CALL_FAILED        - indicates OOP process crashed
        //                            during the call.
        // RPC_S_CALL_FAILED_DNE    - indicates OOP process crashed
        //                            before the call.
        // RPC_S_SERVER_UNAVAILABLE - The OOP process was just not there
        //                             (ie. previously crashed, etc.)
        //

        if ( WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_CALL_FAILED_DNE ||
             WIN32_FROM_HRESULT( hr ) == RPC_S_SERVER_UNAVAILABLE )
        {
            //
            // WARNING - HandleCrash can potentially cause this object
            //           to be destroyed.  Don't do anything except
            //           return after calling it!
            //
            
            HandleCrash();
            return hr;
        }
    }

    return hr;
}

VOID
WAM_PROCESS::DecrementRequestCount(
    VOID
    )
/*++

Routine Description:

    Hmmm.  Let me think for a minute...

    Oh yeah, this function decrements the request count.

Arguments:

    None

Return Value:

    None

--*/
{
/*    
    //
    // Remove this request from the active request list
    //

    LockRequestList();
    RemoveEntryList( &pIsapiRequest->_leRequest );
    UnlockRequestList();

    //
    // Release the ISAPI_REQUEST object.
    //

    pIsapiRequest->Release();

    //
    // Release this requests reference on the WAM_PROCESS object.
    //

    Release();
*/

    InterlockedDecrement( &_cCurrentRequests );
}

VOID
WAM_PROCESS::HandleCrash(
    VOID
    )
/*++

Routine Description:

    Handles a crashed request

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT hr;

    //
    // If we get here, then we have to assume that the OOP host
    // process has crashed.  When this happens, COM is going to
    // release the references on any ISAPI_REQUEST objects held
    // by the process.  As these ISAPI_REQUEST's drop to zero,
    // they will be releasing references on this object.
    //
    // At this time, there's not much we can do, except call
    // TerminateProcess on it to make sure it's dead and pull
    // it off the hash table so no new requests are routed to
    // it.
    //
    // The Disable call that pulls it from the hash table could
    // very well release the final reference on this object.
    // We cannot touch any members after that.
    //
    // We need to make sure that we only call Disable once!
    //
    // CODEWORK: We should log an event and bump any crash count
    //           (to support AppOopRecoverLimit) before calling
    //           Disable.
    //

    if ( InterlockedExchange( &_fGoingAway, 1 ) == 0 )
    {
        TerminateProcess( _hProcess, 0 );

        //
        // Don't leak the handle...
        //

        CloseHandle( _hProcess );
        _hProcess = NULL;

        //
        // Force COM to release any references it's holding
        // to ISAPI_REQUEST objects.
        //

        DisconnectIsapiRequests();

        Disable( TRUE );
    }
}

HRESULT
WAM_PROCESS::Disable(
    BOOL    fRemoveFromProcessHash
    )
/*++

Routine Description:

    Disables the WAM_PROCESS.  Any new requests for the application
    associated with this process will cause a new process to start
    after this function is called.

Arguments:

    fRemoveFromProcessHash - If TRUE, then this function should remove
                             the WAM_PROCESS from the hash table.  This
                             flag will be FALSE when this function is
                             called from the WAM process manager's
                             shutdown.  In that case, the LKRHash 
                             DeleteIf function will handle removing the
                             object from the hash.

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = NOERROR;

    _fGoingAway = TRUE;

    //
    // Remove the process from the hash if directed.
    //

    if ( fRemoveFromProcessHash )
    {
        _pWamProcessManager->LockWamProcessHash();
        hr = _pWamProcessManager->RemoveWamProcessFromHash( this );
    }

    //
    // Once we remove the process from the hash, we should recycle it.
    // This will force COM to start a new process in the case where
    // new requests arrive for this AppWamClsid before the shutdown
    // code has a chance to kill off this instance.
    //

    VARIANT varInstanceId = {0};
    varInstanceId.vt = VT_BSTR;
    varInstanceId.bstrVal = _bstrInstanceId;
    hr = _pWamProcessManager->QueryCatalog()->RecycleApplicationInstances( &varInstanceId, 0 );

    //
    // This code could potentially fail under a number of circumstances.
    // For example, if we are disabling this application because it
    // crashed, we don't really expect to be able to recycle it.
    //
    // This is not a big deal.  We'll just do some debug spew and get
    // on with it.
    //

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Error 0x%08x occured attempting to recycle disabled "
            "application %S\r\n",
            hr, _szWamClsid
            ));
    }

    if ( fRemoveFromProcessHash )
    {
        _pWamProcessManager->UnlockWamProcessHash();
    }

    return hr;
}

HRESULT
WAM_PROCESS::CleanupRequests(
    DWORD   dwDrainTime
    )
/*++

Routine Description:

    This function is basically just a timer that allows time
    to pass until either the supplied timeout is reached, or
    all requests are completed, whichever is first.

Arguments:

    dwDrainTime - The timeout in milliseconds

Return Value:

    HRESULT

--*/
{
    DWORD   dwWaitSoFar = 0;
    
    //
    // We will loop here until either the specified time has
    // passed, or until all requests are done.
    
    while ( _cCurrentRequests )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p waiting for %d requests.\r\n",
            this,
            _cCurrentRequests
            ));
        
        Sleep( 200 );

        if ( dwDrainTime < ( dwWaitSoFar += 200 ) )
        {
            break;
        }
    }

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS %p done draining with %d requests "
        "still outstanding.\r\n",
        this,
        _cCurrentRequests
        ));

    return NOERROR;
}

HRESULT
WAM_PROCESS::Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the WAM_PROCESS and associated OOP host process

    Note that we make the assumption that the caller of this
    function has taken steps to ensure that new requests are
    properly routed.  In the typical case, this means that
    somebody has called Disable to pull us off the hash table.
    In the special case where LKRHash calls this function when
    the WAM process has is being deleted, we assume that the
    web service is in shutdown state and no new requests are
    arriving.

    Also note that it's up to the caller to hold a reference
    if necessary to ensure that this object doesn't get
    destroyed while this function is running.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ISAPI_REQUEST * pIsapiRequest;
    HRESULT         hr = NOERROR;

    //
    // If we get here, we expect that this object has been pulled off
    // the hash table (and that the _fGoingAway flag is set).
    //

    DBG_ASSERT( _fGoingAway );

    //
    // If there are no requests running, then we can gracefully unload
    // any extensions in the OOP host.  Otherwise, we're basically
    // going to crash the OOP host by terminating it with requests in
    // flight.
    //
    // This latter case should only happen if we are being demand
    // unloaded, through the UI, via ADSI, or via IMSAdminBase.
    //

    if ( _cCurrentRequests == 0 )
    {
        _pIWam->WamUninitProcess();
    }

    //
    // Time to kill the process.  We could potentially use the COM
    // ShutdownProcess API, but it doesn't really buy us anything.
    // We're just gonna terminate it.
    //

    DBG_ASSERT( _hProcess );

    if ( _hProcess )
    {
        TerminateProcess( _hProcess, 0 );

        CloseHandle( _hProcess );
        _hProcess = NULL;
    }

    //
    // Force COM to release any references it's holding
    // to ISAPI_REQUEST objects.
    //

    DisconnectIsapiRequests();

    //
    // Now that the process is gone, COM will clean up any
    // References on ISAPI_REQUEST objects that were held in
    // it.  It is also possible that there are threads
    // unwinding in the core that are doing work on behalf
    // of the OOP host, and there may even be I/O completions
    // that will occur for this process.
    //
    // As these objects reach zero references, they will
    // release their references on this object.  This object
    // will be destroyed when the last reference is released.
    //

    return hr;
}

HRESULT
WAM_PROCESS::Unload(
    DWORD   dwDrainTime
    )
/*++

Routine Description:

    Unloads the WAM_PROCESS, allowing for a timeout that allows
    outstanding requests to complete before killing them off.

Arguments:

    dwDrainTime - The timeout in milliseconds before requests are killed

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    //
    // We'd better not do this more than once.
    //

    if ( InterlockedExchange( &_fGoingAway , 1 ) == 0 )
    {
        //
        // WARNING - Calling Disable can potentially cause this object
        //           to be destroyed.  We need to take a reference until
        //           the Shutdown function returns.
        //

        AddRef();

        hr = Disable();

        hr = CleanupRequests( dwDrainTime );

        hr = Shutdown();

        Release();
    }

    return hr;
}

VOID
WAM_PROCESS::AddIsapiRequestToList(
    ISAPI_REQUEST * pIsapiRequest
    )
{
    pIsapiRequest->AddRef();
    LockRequestList();
    InsertHeadList(
        &_RequestListHead,
        &pIsapiRequest->_leRequest
        );
    UnlockRequestList();
}

VOID
WAM_PROCESS::RemoveIsapiRequestFromList(
    ISAPI_REQUEST * pIsapiRequest
    )
{
    LockRequestList();
    RemoveEntryList( &pIsapiRequest->_leRequest );
    InitializeListHead( &pIsapiRequest->_leRequest );
    UnlockRequestList();

    pIsapiRequest->Release();
}

VOID
WAM_PROCESS::DisconnectIsapiRequests(
    VOID
    )
{
    LIST_ENTRY *    pleTemp;
    ISAPI_REQUEST * pIsapiRequest;
    HRESULT         hr;

    LockRequestList();
    
    pleTemp = _RequestListHead.Flink;

    while ( pleTemp != &_RequestListHead )
    {
        pIsapiRequest = CONTAINING_RECORD(
            pleTemp,
            ISAPI_REQUEST,
            _leRequest
            );

        DBG_ASSERT( pIsapiRequest );

        pIsapiRequest->AddRef();

        hr = CoDisconnectObject( pIsapiRequest, 0 );

        if ( FAILED( hr ) )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Failed to disconnect ISAPI_REQUEST %p.  HRESULT=%08x.\r\n",
                pIsapiRequest,
                hr
                ));

            DBG_ASSERT( FALSE && "Error disconnecting ISAPI_REQUEST." );
        }

        pleTemp = pleTemp->Flink;

        pIsapiRequest->Release();
    }

    UnlockRequestList();
}

WAM_PROCESS::~WAM_PROCESS()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{    
    DBG_ASSERT( _cCurrentRequests == 0 );

    if (_bstrInstanceId)
    {
        SysFreeString(_bstrInstanceId);
        _bstrInstanceId = NULL;
    }

    DeleteCriticalSection( &_csRequestList );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS %p has been destroyed.\r\n",
            this
            ));
    }

    _pWamProcessManager->Release();
}

HRESULT
WAM_PROCESS_MANAGER::Create(
    VOID
    )
/*++

Routine Description:

    Initializes the parts of the WAM_PROCESS_MANAGER object not
    appropriate to the constructor.  This includes instantiating
    the COM+ admin catalog interface.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Creating WAM_PROCESS_MANAGER %p.\r\n",
            this
            ));
    }
    
    //
    // Need to get the COM admin interface
    //

    hr = CoCreateInstance(
        CLSID_COMAdminCatalog,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICOMAdminCatalog2,
        (void**)&_pCatalog
        );

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS_MANAGER %p. Failed to CoCreate ICOMAdminCatalog2.\r\n",
            this
            ));

        goto ErrorExit;
    }

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "WAM_PROCESS_MANAGER %p created successfully.\r\n",
            this
            ));
    }

    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    DBGPRINTF((
        DBG_CONTEXT,
        "Attempt to create WAM_PROCESS_MANAGER %p has failed.  HRESULT=%08x.\r\n",
        this,
        hr
        ));

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::GetWamProcess(
    LPCWSTR         szWamClsid,
    WAM_PROCESS **  ppWamProcess,
    LPCSTR          szIsapiHandlerInstance
    )
/*++

Routine Description:

    Returns a WAM_PROCESS pointer associated with the specified
    CLSID.  If no corresponding WAM_PROCESS exists, one will be
    started.

Arguments:

    szWamClsid             - The CLSID of the desired WAM_PROCESS
    ppWamProcess           - Upon return, contains the WAM_PROCESS pointer
    szIsapiHandlerInstance - The instance ID of the W3_ISAPI_HANDLER
                             that's looking for a WAM_PROCESS.  This
                             is used for debugging purposes.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    WAM_PROCESS *   pWamProcess = NULL;
    
    //
    // Look to see if the WAM_PROCESS has already been
    // loaded.  If so, then we can just return it.
    //
    // This is the common path, and we want to avoid
    // taking a lock for this case.
    //

    _WamProcessHash.FindKey( szWamClsid, &pWamProcess );

    if ( pWamProcess != NULL )
    {
        *ppWamProcess = pWamProcess;

        return hr;
    }

    //
    // Ok, so we didn't already find it.  Now, let's
    // lock the hash table and load it.
    //

    LockWamProcessHash();

    //
    // Better check once more now that we have the lock just
    // in case someone got to it since our initial check
    // above.
    //

    _WamProcessHash.FindKey( szWamClsid, &pWamProcess );

    if ( pWamProcess != NULL )
    {
        *ppWamProcess = pWamProcess;
        goto ExitDone;
    }

    pWamProcess = new WAM_PROCESS(
        szWamClsid,
        this,
        szIsapiHandlerInstance
        );

    if ( !pWamProcess )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto ExitDone;
    }

    //
    // Create the WAM_PROCESS object.  This will start the
    // host process.
    //

    hr = pWamProcess->Create();

    if ( FAILED( hr ) )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Failed to create WAM_PROCESS %p. Error 0x%08x\r\n",
            pWamProcess, hr
            ));

        pWamProcess->Release();
        goto ExitDone;
    }

    DBGPRINTF((
        DBG_CONTEXT,
        "WAM_PROCESS_MANAGER has created WAM_PROCESS %p.\r\n",
        pWamProcess
        ));

    //
    // Add the newly created WAM_PROCESS to the hash table
    // 

    if ( _WamProcessHash.InsertRecord( pWamProcess ) != LK_SUCCESS )
    {
        pWamProcess->Release();
        hr = E_FAIL; // CODEWORK - Consider passing lkreturn to caller
        goto ExitDone;
    }

    //
    // Finally, set the return object for the caller
    //

    *ppWamProcess = pWamProcess;

ExitDone:

    UnlockWamProcessHash();

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::GetWamProcessInfo(
    LPCWSTR         szAppPath,
    WAM_APP_INFO ** ppWamAppInfo,
    BOOL *          pfIsLoaded
    )
/*++

Routine Description:

    Retrieves the app info associated with the provided metabase path
    and indicates whether the application is currently loaded or not.

    Note that this function is expensive because it reads the metabase
    on each call.  It is currently only called when an application is
    unloaded or changed via the UI or an administrative API.

    Don't call this function if you care about performance.

Arguments:

    szAppPath    - The metabase path (ie. "/LM/W3SVC/1/ROOT") to retrieve
    ppWamAppInfo - Upon return, contains a pointer to the app info
    pfIsLoaded   - Upon return, indicates if the application is loaded

Return Value:

    HRESULT

--*/
{
    MB              mb( g_pW3Server->QueryMDObject() );
    WAM_APP_INFO *  pWamAppInfo = NULL;
    WAM_PROCESS *   pWamProcess = NULL;
    DWORD           dwRequiredLen;
    DWORD           dwAppIsolated;
    WCHAR           szClsid[MAX_PATH];
    HRESULT         hr = NOERROR;

    DBG_ASSERT( szAppPath );
    DBG_ASSERT( ppWamAppInfo );

    //
    // Get the info from the metabase
    //

    if ( !mb.Open( szAppPath ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Done;
    }

    //
    // Get the AppIsolated value
    //

    if (!mb.GetDword(L"", MD_APP_ISOLATED, IIS_MD_UT_WAM, &dwAppIsolated, METADATA_INHERIT))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Done;
    }

    //
    // Set the CLSID
    //

    switch ( dwAppIsolated )
    {
    case APP_ISOLATED:

        //
        // Read it from the metabase
        //

        dwRequiredLen= SIZE_CLSID_STRING * sizeof(WCHAR);

        if (!mb.GetString(L"", MD_APP_WAM_CLSID, IIS_MD_UT_WAM, szClsid, &dwRequiredLen, METADATA_INHERIT))
        {
            DBG_ASSERT(dwRequiredLen <= SIZE_CLSID_STRING * sizeof(WCHAR));
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Done;
        }

        break;

    case APP_POOL:

        //
        // Set it from the hardcoded pool clsid
        //

        wcsncpy( szClsid, POOL_WAM_CLSID, SIZE_CLSID_STRING );

        break;

    case APP_INPROC:
    default:

        //
        // Set it to an emptry string
        //

        szClsid[0] = L'\0';

        break;
    }

    //
    // Allocate a new WAM_APP_INFO
    //

    pWamAppInfo = new WAM_APP_INFO( (LPWSTR)szAppPath, szClsid, dwAppIsolated );

    if ( !pWamAppInfo )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Done;
    }

    //
    // Return the new object
    //

    *ppWamAppInfo = pWamAppInfo;

    //
    // Finally, check to see if the application is loaded
    //

    if ( pWamAppInfo->_dwAppIsolated != APP_INPROC )
    {
        _WamProcessHash.FindKey( pWamAppInfo->_szClsid,
                                 &pWamProcess );
    }

    if ( pWamProcess != NULL )
    {
        *pfIsLoaded = TRUE;
        pWamProcess->Release();
        pWamProcess = NULL;
    }
    else
    {
        *pfIsLoaded = FALSE;
    }

Done:

    mb.Close();

    return hr;
}

HRESULT
WAM_PROCESS_MANAGER::RemoveWamProcessFromHash(
    WAM_PROCESS *   pWamProcess
    )
/*++

Routine Description:

    Removes a WAM_PROCESS from the hash

Arguments:

    pWamProcess - The WAM_PROCESS to remove

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    
    if ( _WamProcessHash.DeleteRecord( pWamProcess ) != LK_SUCCESS )
    {
        hr = E_FAIL; // CODEWORK - Consider passing lkreturn to caller
    }

    return hr;
}

// static
LK_PREDICATE
WAM_PROCESS_MANAGER::UnloadWamProcess(
    WAM_PROCESS *   pWamProcess,
    void *          pvState
    )
/*++

Routine Description:

    Unloads a WAM_PROCESS.  This function is exclusively called by
    LKRHash's DeleteIf function during WAM_PROCESS_MANAGER shutdown
    just before the hash table is deleted.

Arguments:

    pWamProcess - The WAM_PROCESS to shut down
    pvState     - Required by LKRHash - we don't use it

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( pWamProcess );

    DBGPRINTF((
        DBG_CONTEXT,
        "Unloading application %S.\r\n",
        pWamProcess->QueryClsid()
        ));

    hr = pWamProcess->Disable( FALSE );
    hr = pWamProcess->CleanupRequests( 0 );
    hr = pWamProcess->Shutdown();

    DBG_ASSERT( SUCCEEDED( hr ) );

    return LKP_PERFORM;
}

HRESULT
WAM_PROCESS_MANAGER::Shutdown(
    VOID
    )
/*++

Routine Description:

    Shuts down the WAM_PROCESS_MANAGER

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    DBGPRINTF((
        DBG_CONTEXT,
        "Shutting down WAM_PROCESS_MANAGER.\r\n"
        ));

    _WamProcessHash.DeleteIf( UnloadWamProcess, NULL );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulw3\w3site.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    w3site.h

Abstract:

    Type definition for worker process implementation of IIS.

Author:

    Taylor Weiss (TaylorW)       16-Dec-1999

Revision History:

--*/

#ifndef _W3SITE_H_
#define _W3SITE_H_

/************************************************************
 *  Include Headers
 ************************************************************/

/************************************************************
 *  Type Definitions  
 ************************************************************/

/*++

class W3_SITE

    Encapsulates site level settings for an HTTP server run in
    a duct-tape worker process.

    Condenses the relevant functionality exposed in IIS 
    through the IIS_SERVER_INSTANCE and W3_SERVER_INSTANCE.

--*/

#define W3_SITE_SIGNATURE            (DWORD)' ISW'
#define W3_SITE_SIGNATURE_FREE       (DWORD)'fISW'

#define MAX_SITEID_LENGTH            10

class FILTER_LIST;

class W3_SITE
{

public:

    //
    // Construction and Initialization
    //

    W3_SITE(DWORD SiteId);

    // global initialization and cleanup
    static HRESULT W3SiteInitialize()
    {
        INITIALIZE_CRITICAL_SECTION( &sm_csIISCertMapLock );
        return S_OK;
    }
    
    static VOID W3SiteTerminate()
    {
        DeleteCriticalSection( &sm_csIISCertMapLock );        
    }

    // global lock & unlock for iis certmap

    VOID GlobalLockIISCertMap()
    {
        EnterCriticalSection( &sm_csIISCertMapLock );
    }
    
    VOID GlobalUnlockIISCertMap()
    {
        LeaveCriticalSection( &sm_csIISCertMapLock );
    }

    HRESULT Initialize(LOGGING *pLogging = NULL,
                       FILTER_LIST *pFilterList = NULL);

    DWORD QueryId() const
    {
        return m_SiteId;
    }

    BOOL QueryUseDSMapper() const
    {
        return m_fUseDSMapper;
    }

    void AddRef()
    {
        InterlockedIncrement( &m_cRefs );
    }

    void Release()
    {
        DBG_ASSERT( m_cRefs > 0 );

        if ( InterlockedDecrement( &m_cRefs ) == 0 )
        {
            delete this;
        }
    }

    FILTER_LIST *QueryFilterList() const
    {
        return m_pInstanceFilterList;
    }

    STRA *QueryName()
    {
        return &m_SiteName;
    }

    STRU *QueryMBRoot()
    {
        return &m_SiteMBRoot;
    }

    STRU *QueryMBPath()
    {
        return &m_SiteMBPath;
    }
    
    HRESULT
    HandleMetabaseChange(
        const MD_CHANGE_OBJECT &ChangeObject,
        IN    W3_SITE_LIST     *pTempSiteList = NULL);

    BOOL QueryDoUlLogging() const
    {
        return m_pLogging->QueryDoUlLogging();
    }

    BOOL QueryDoCustomLogging() const
    {
        return m_pLogging->QueryDoCustomLogging();
    }

    BOOL IsRequiredExtraLoggingFields() const
    {
        return m_pLogging->IsRequiredExtraLoggingFields();
    }

    const MULTISZA *QueryExtraLoggingFields() const
    {
        return m_pLogging->QueryExtraLoggingFields();
    }

    void LogInformation(LOG_CONTEXT *pLogData)
    {
        m_pLogging->LogInformation(pLogData);
    }

    BOOL QueryAllowPathInfoForScriptMappings() const
    {
        return m_fAllowPathInfoForScriptMappings;
    }

    VOID GetStatistics(IISWPSiteCounters *pCounterData)
    {
        PBYTE pSrc = (PBYTE)&m_PerfCounters;
        PBYTE pDest = (PBYTE)pCounterData;

        //
        // Set the site id for the counters we
        // are sending.
        //
        pCounterData->SiteID = m_SiteId;

        for (DWORD i=0; i< WPSiteCtrsMaximum; i++)
        {
            // I am assuming all WP site counters are DWORDs and will
            // remain so, if not this code needs changing at that point
            DBG_ASSERT(aIISWPSiteDescription[i].Size == sizeof(DWORD));

            if (aIISWPSiteDescription[i].WPZeros)
            {
                //
                // For the total counters, we pass on the increment since
                // the last collection, so we need to zero them
                //

                *(DWORD *)(pDest + aIISWPSiteDescription[i].Offset) =
                    InterlockedExchange(
                        (LPLONG)(pSrc + aIISWPSiteDescription[i].Offset),
                        0);
            }
            else
            {
                *(DWORD *)(pDest + aIISWPSiteDescription[i].Offset) =
                    *(DWORD *)(pSrc + aIISWPSiteDescription[i].Offset);
            }
        }
    }

    VOID IncFilesSent()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesSent);
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesTransferred);
    }

    VOID IncFilesRecvd()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesReceived);
        InterlockedIncrement((LPLONG)&m_PerfCounters.FilesTransferred);
    }

    VOID IncAnonUsers()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.AnonUsers);
        DWORD currAnons = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentAnonUsers);

        DWORD currMaxAnons;
        while ((currMaxAnons = m_PerfCounters.MaxAnonUsers) <
               currAnons)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxAnonUsers,
                                       currAnons,
                                       currMaxAnons);
        }
    }

    VOID DecAnonUsers()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentAnonUsers);
    }

    VOID IncNonAnonUsers()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.NonAnonUsers);
        DWORD currNonAnons = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentNonAnonUsers);

        DWORD currMaxNonAnons;
        while ((currMaxNonAnons = m_PerfCounters.MaxNonAnonUsers) <
               currNonAnons)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxNonAnonUsers,
                                       currNonAnons,
                                       currMaxNonAnons);
        }
    }

    VOID DecNonAnonUsers()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentNonAnonUsers);
    }

    VOID IncLogonAttempts()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.LogonAttempts);
    }

    VOID IncReqType(HTTP_VERB VerbType)
    {
        switch (VerbType)
        {
        case HttpVerbGET:
            InterlockedIncrement((LPLONG)&m_PerfCounters.GetReqs);
            return;

        case HttpVerbPUT:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PutReqs);
            IncFilesRecvd();
            return;

        case HttpVerbHEAD:
            InterlockedIncrement((LPLONG)&m_PerfCounters.HeadReqs);
            return;

        case HttpVerbPOST:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PostReqs);
            return;

        case HttpVerbDELETE:
            InterlockedIncrement((LPLONG)&m_PerfCounters.DeleteReqs);
            return;

        case HttpVerbTRACE:
        case HttpVerbTRACK:
            InterlockedIncrement((LPLONG)&m_PerfCounters.TraceReqs);
            return;

        case HttpVerbOPTIONS:
            InterlockedIncrement((LPLONG)&m_PerfCounters.OptionsReqs);
            return;

        case HttpVerbMOVE:
            InterlockedIncrement((LPLONG)&m_PerfCounters.MoveReqs);
            return;

        case HttpVerbCOPY:
            InterlockedIncrement((LPLONG)&m_PerfCounters.CopyReqs);
            return;

        case HttpVerbPROPFIND:
            InterlockedIncrement((LPLONG)&m_PerfCounters.PropfindReqs);
            return;

        case HttpVerbPROPPATCH:
            InterlockedIncrement((LPLONG)&m_PerfCounters.ProppatchReqs);
            return;

        case HttpVerbMKCOL:
            InterlockedIncrement((LPLONG)&m_PerfCounters.MkcolReqs);
            return;

        case HttpVerbLOCK:
            InterlockedIncrement((LPLONG)&m_PerfCounters.LockReqs);
            return;

        default:
            InterlockedIncrement((LPLONG)&m_PerfCounters.OtherReqs);
            return;
        }
    }

    VOID IncCgiReqs()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.CgiReqs);
        DWORD currCgis = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentCgiReqs);

        DWORD currMaxCgis;
        while ((currMaxCgis = m_PerfCounters.MaxCgiReqs) <
               currCgis)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxCgiReqs,
                                       currCgis,
                                       currMaxCgis);
        }
    }

    VOID DecCgiReqs()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentCgiReqs);
    }

    VOID IncIsapiExtReqs()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.IsapiExtReqs);
        DWORD currIsapiExts = InterlockedIncrement((LPLONG)&m_PerfCounters.CurrentIsapiExtReqs);

        DWORD currMaxIsapiExts;
        while ((currMaxIsapiExts = m_PerfCounters.MaxIsapiExtReqs) <
               currIsapiExts)
        {
            InterlockedCompareExchange((LPLONG)&m_PerfCounters.MaxIsapiExtReqs,
                                       currIsapiExts,
                                       currMaxIsapiExts);
        }
    }

    VOID DecIsapiExtReqs()
    {
        InterlockedDecrement((LPLONG)&m_PerfCounters.CurrentIsapiExtReqs);
    }

    VOID IncNotFound()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.NotFoundErrors);
    }

    VOID IncLockedError()
    {
        InterlockedIncrement((LPLONG)&m_PerfCounters.LockedErrors);
    }

    BOOL 
    IsAuthPwdChangeEnabled(
        VOID
        )
    {
        return !( m_dwAuthChangeFlags & MD_AUTH_CHANGE_DISABLE );
    }
    BOOL 
    IsAuthPwdChangeNotificationEnabled(
        VOID
        )
    {
        return !( m_dwAuthChangeFlags & MD_AUTH_ADVNOTIFY_DISABLE );
    }

    STRU *
    QueryAuthChangeUrl(
        VOID
        )
    {
        return &m_strAuthChangeUrl;
    }

    STRU * 
    QueryAuthExpiredUrl(
        VOID
        )
    {
        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_DISABLE )
        {
            return NULL;
        }

        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_UNSECURE )
        {
            return &m_strAuthExpiredUnsecureUrl;
        }
        else
        {
            return &m_strAuthExpiredUrl;
        }
    }

    STRU * 
    QueryAdvNotPwdExpUrl( 
        VOID
        )
    {
        if ( m_dwAuthChangeFlags & MD_AUTH_ADVNOTIFY_DISABLE )
        {
            return NULL;
        }

        if ( m_dwAuthChangeFlags & MD_AUTH_CHANGE_UNSECURE )
        {
            return &m_strAdvNotPwdExpUnsecureUrl;
        }
        else
        {
            return &m_strAdvNotPwdExpUrl;
        }
    }

    DWORD
    QueryAdvNotPwdExpInDays(
        VOID
        )
    {
        return m_dwAdvNotPwdExpInDays;
    }

    DWORD 
    QueryAdvCacheTTL(
        VOID
        )
    {
        return m_dwAdvCacheTTL;
    }

    BOOL
    QuerySSLSupported(
        VOID
        )
    {
        return m_fSSLSupported;
    }
    
    HRESULT
    GetIISCertificateMapping(
        IIS_CERTIFICATE_MAPPING ** ppIISCertificateMapping
    );

private:

    ~W3_SITE();

    HRESULT ReadPrivateProperties();

    DWORD               m_Signature;
    LONG                m_cRefs;
    DWORD               m_SiteId;
    STRA                m_SiteName;
    STRU                m_SiteMBPath;
    STRU                m_SiteMBRoot;

    FILTER_LIST        *m_pInstanceFilterList;

    LOGGING            *m_pLogging;

    BOOL                m_fAllowPathInfoForScriptMappings;
    BOOL                m_fUseDSMapper;
    IISWPSiteCounters   m_PerfCounters;

    //
    // OWA related variables 
    //

    STRU                m_strAuthChangeUrl;
    STRU                m_strAuthExpiredUrl;
    STRU                m_strAdvNotPwdExpUrl;
    STRU                m_strAuthExpiredUnsecureUrl;
    STRU                m_strAdvNotPwdExpUnsecureUrl;
    DWORD               m_dwAdvNotPwdExpInDays;
    DWORD               m_dwAuthChangeFlags;
    DWORD               m_dwAdvCacheTTL;

    //
    // Does this site support SSL
    //
    BOOL                m_fSSLSupported;

    //
    // IIS certificate mapping
    // It is loaded on demand on first request to content
    // that enable IIS cert mapping
    //
    
    IIS_CERTIFICATE_MAPPING * m_pIISCertMap;
    BOOL                      m_fAlreadyAttemptedToLoadIISCertMap;
    static CRITICAL_SECTION   sm_csIISCertMapLock;

}; // W3_SITE

#endif // _W3SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3dirmon\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_DIRMON               0x00010000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachehint.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachehint.cxx

   Abstract:
     Provides hint to caches about whether or not to cache an entry, based
     on usage patterns
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "cachehint.hxx"

BOOL
CACHE_HINT_ENTRY::QueryIsOkToCache(
    DWORD               tickCountNow,
    DWORD               cmsecActivityWindow
)
/*++

Routine Description:

    Is it OK to cache entry, given recent activity

Arguments:

    tickCountNow - Current tick count
    cmsecActivityWindow - Maximum window between access to cause caching

Return Value:

    TRUE to cache, FALSE to not cache

--*/
{
    DWORD               lastUsageTime;
    DWORD               timeBetweenUsage;
    
    lastUsageTime = InterlockedExchange( (LPLONG) &_cLastUsageTime,
                                         tickCountNow );
    
    if ( lastUsageTime > tickCountNow )
    {   
        timeBetweenUsage = tickCountNow + ( UINT_MAX - lastUsageTime );
    } 
    else
    {
        timeBetweenUsage = tickCountNow - lastUsageTime;
    }
    
    if ( timeBetweenUsage < cmsecActivityWindow )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

CACHE_HINT_MANAGER::CACHE_HINT_MANAGER()
    : _cConfiguredTTL( 0 ),
      _cmsecActivityWindow( 0 ),
      _hTimer( NULL )
{
}

CACHE_HINT_MANAGER::~CACHE_HINT_MANAGER()
{
    if ( _hTimer )
    {
        DeleteTimerQueueTimer( NULL, 
                               _hTimer,
                               INVALID_HANDLE_VALUE );
        _hTimer = NULL;
    }
}

//static
VOID
WINAPI
CACHE_HINT_MANAGER::ScavengerCallback(
    PVOID                   pParam,
    BOOLEAN                 TimerOrWaitFired
)
{
    CACHE_HINT_MANAGER *    pHintManager;
    
    pHintManager = (CACHE_HINT_MANAGER*) pParam;

    pHintManager->FlushByTTL();
}

//static
LK_PREDICATE
CACHE_HINT_MANAGER::HintFlushByTTL(
    CACHE_HINT_ENTRY *      pHintEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to TTL

Arguments:

    pCacheEntry - Cache hint entry to check
    pvState - Unused

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    DBG_ASSERT( pHintEntry != NULL );
    
    if ( pHintEntry->QueryIsOkToFlushTTL() )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

VOID
CACHE_HINT_MANAGER::FlushByTTL(
    VOID
)
/*++

Routine Description:

    Flush hint entries which have expired

Arguments:

    None
    
Return Value:
    
    None

--*/
{
    _hintTable.DeleteIf( HintFlushByTTL, NULL );
}

HRESULT
CACHE_HINT_MANAGER::Initialize(
    CACHE_HINT_CONFIG *     pConfig
)
/*++

Routine Description:

    Initialize cache hint table

Arguments:

    pConfig - Cache hint config table
    
Return Value:
    
    HRESULT

--*/
{
    BOOL            fRet;
    
    if ( pConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    _cConfiguredTTL = pConfig->cmsecTTL / pConfig->cmsecScavengeTime + 1;
    _cmsecActivityWindow = pConfig->cmsecActivityWindow;
    
    fRet = CreateTimerQueueTimer( &_hTimer,
                                  NULL,
                                  CACHE_HINT_MANAGER::ScavengerCallback,
                                  this,
                                  pConfig->cmsecScavengeTime,
                                  pConfig->cmsecScavengeTime,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

HRESULT
CACHE_HINT_MANAGER::ShouldCacheEntry(
    CACHE_KEY *             pCacheEntryKey,
    BOOL *                  pfShouldCache
)
/*++

Routine Description:

    Determine whether we the given entry should be cached

Arguments:

    pCacheEntryKey - Entry key in question (must implement QueryHintKey())
    pfShouldCache - Set to TRUE if we should cache
    
Return Value:
    
    HRESULT

--*/
{
    LK_RETCODE              lkrc;
    CACHE_HINT_ENTRY *      pHintEntry = NULL;
    DWORD                   tickCount;
    HRESULT                 hr;
    
    if ( pCacheEntryKey == NULL ||
         pfShouldCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
   
    *pfShouldCache = FALSE;

    DBG_ASSERT( pCacheEntryKey->QueryHintKey() != NULL );
    
    lkrc = _hintTable.FindKey( pCacheEntryKey->QueryHintKey(),
                               &pHintEntry );
    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pHintEntry != NULL );
        
        tickCount = GetTickCount();
        
        if ( pHintEntry->QueryIsOkToCache( tickCount,
                                           _cmsecActivityWindow ) )
        {
            //
            // We can delete this hint entry now
            //
            
            _hintTable.DeleteRecord( pHintEntry );
            
            *pfShouldCache = TRUE;
        }

        //
        // Release corresponding to the FindKey
        //
        pHintEntry->Release();
    }
    else
    {
        pHintEntry = new CACHE_HINT_ENTRY( _cConfiguredTTL,
                                           GetTickCount() );
        if ( pHintEntry == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        hr = pHintEntry->SetKey( pCacheEntryKey->QueryHintKey() );
        if ( FAILED( hr ) )
        {
            pHintEntry->Release();
            return hr;
        }
        
        lkrc = _hintTable.InsertRecord( pHintEntry );

        //
        // Release the extra reference
        //
        pHintEntry->Release();
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\cachemanager.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     cachemanager.cxx

   Abstract:
     Manages a list of all the caches and handles invalidation of them
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)

CACHE_MANAGER *         g_pCacheManager;

CACHE_MANAGER::CACHE_MANAGER()
{
    _pDirMonitor = NULL;
    ZeroMemory( &_Caches, sizeof( _Caches ) );
}

CACHE_MANAGER::~CACHE_MANAGER()
{
}

HRESULT
CACHE_MANAGER::Initialize(
    IMSAdminBase *          pAdminBase
)
/*++

Routine Description:

    Initialize cache manager

Arguments:

    pAdminBase - Admin base object pointer

Return Value:

    HRESULT

--*/
{
    //
    // Initialize dir monitor
    //
    
    DBG_ASSERT( _pDirMonitor == NULL );
    
    _pDirMonitor = new CDirMonitor;
    if ( _pDirMonitor == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Keep a pointer to the admin base object
    //
    
    _pAdminBase = pAdminBase;
    _pAdminBase->AddRef();
    
    return NO_ERROR;
}

VOID
CACHE_MANAGER::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup the cache manager

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( _pAdminBase != NULL )
    {
        _pAdminBase->Release();
        _pAdminBase = NULL;
    }
    
    if ( _pDirMonitor != NULL )
    {
        delete _pDirMonitor;
        _pDirMonitor = NULL;
    }
}

HRESULT
CACHE_MANAGER::AddNewCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Add new cache to be managed

Arguments:

    pObjectCache - Object cache to add

Return Value:

    HRESULT

--*/
{
    DWORD               dwInsertPos;
    
    if ( pObjectCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First the first non-NULL entry
    //
   
    for ( dwInsertPos = 0; _Caches[ dwInsertPos ] != NULL; dwInsertPos++ )
    {
    } 
    
    //
    // Add the new cache
    //
    
    _Caches[ dwInsertPos ] = pObjectCache;
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::RemoveCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Cache to remove from list of managed caches

Arguments:

    pObjectCache - Object cache to remove

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    BOOL                fFound = FALSE;

    if ( pObjectCache == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }    
    
    //
    // First find the cache to remove
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        if ( _Caches[ dwPos ] == pObjectCache )
        {
            memmove( _Caches + dwPos,
                     _Caches + dwPos + 1,
                     ( MAX_CACHE_COUNT - dwPos - 1 ) * sizeof( OBJECT_CACHE*) );

            fFound = TRUE;
            
            break;
        }
    }

    if ( !fFound )
    {
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }    
    
    return NO_ERROR;
}

VOID
CACHE_MANAGER::FlushAllCaches(
    VOID
)
/*++

Routine Description:

    Flush all caches

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD               dwPos;
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        _Caches[ dwPos ]->Clear();
    }

    //
    // Cleanup any dirmon dependencies now since we're about to kill the 
    // caches
    //

    _pDirMonitor->Cleanup();
}

HRESULT
CACHE_MANAGER::HandleDirMonitorInvalidation(
    WCHAR *                 pszFilePath,
    BOOL                    fFlushAll
)
/*++

Routine Description:

    Invalidate any caches which are interested in dir monitor invalidation

Arguments:

    pszFilePath - File name changed
    fFlushAll - Should we flush all items prefixed with pszFilePath?

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    OBJECT_CACHE *      pCache;

    if ( pszFilePath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Iterate thru all the caches which support dirmon invalidation
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        pCache = _Caches[ dwPos ];

        //
        // If this cache doesn't support dirmon at all, continue
        //
        
        if ( !pCache->QuerySupportsDirmonSpecific() &&
             !pCache->QuerySupportsDirmonFlush() )
        {
            continue;
        }

        //
        // If this is a specific invalidation, check whether the cache 
        // supports it.  If it doesn't, but does support flush, the do a 
        // flush instead
        //
        
        if ( !fFlushAll )
        {
            if ( pCache->QuerySupportsDirmonSpecific() )
            {
                pCache->DoDirmonInvalidationSpecific( pszFilePath );
            }
            else
            {
                pCache->DoDirmonInvalidationFlush( pszFilePath );
            }
        }
        else
        {
            pCache->DoDirmonInvalidationFlush( pszFilePath );
        }
    } 
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::HandleMetadataInvalidation(
    WCHAR *                 pszMetaPath
)
/*++

Routine Description:

    Invalidate any caches which are interested in metadata invalidation

Arguments:

    pszMetaPath - Metabase path which changed

Return Value:

    HRESULT

--*/
{
    DWORD               dwPos;
    OBJECT_CACHE *      pCache;

    if ( pszMetaPath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Iterate thru all the caches which support metadata invalidation
    //
    
    for ( dwPos = 0; _Caches[ dwPos ] != NULL; dwPos++ )
    {
        pCache = _Caches[ dwPos ];
        
        if ( pCache->QuerySupportsMetadataFlush() )
        {   
            pCache->DoMetadataInvalidationFlush( pszMetaPath );
        }
    } 
    
    return NO_ERROR;
}

HRESULT
CACHE_MANAGER::MonitorDirectory(
    DIRMON_CONFIG *             pDirmonConfig,
    CDirMonitorEntry **         ppDME
)
/*++

Routine Description:

    Monitor given directory

Arguments:

    pDirmonConfig - Name of directory and token to impersonate with
    ppDME - Set to monitor entry on success

Return Value:

    HRESULT

--*/
{
    CacheDirMonitorEntry *      pDME = NULL;
    HRESULT                     hr = NO_ERROR;
    BOOL                        fRet;
    BOOL                        fImpersonated = FALSE;
    
    if ( ppDME == NULL ||
         pDirmonConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First check if we are already monitoring this directory
    //
    
    pDME = (CacheDirMonitorEntry*) _pDirMonitor->FindEntry( pDirmonConfig->pszDirPath );
    if ( pDME == NULL )
    {
        //
        // It is not.  We'll have to start monitoring
        //
    
        pDME = new CacheDirMonitorEntry;
        if ( pDME == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    
        pDME->AddRef();

        if ( pDirmonConfig->hToken != NULL )
        {
            fRet = SetThreadToken( NULL, pDirmonConfig->hToken );
            if ( !fRet )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                pDME->Release();
                return hr;   
            }
            
            fImpersonated = TRUE;
        }

        
        fRet = _pDirMonitor->Monitor( pDME,
                                      pDirmonConfig->pszDirPath,
                                      TRUE,
                                      DIR_CHANGE_FILTER );

        if ( fImpersonated )
        {
            RevertToSelf();
            fImpersonated = FALSE;
        }

        if ( !fRet )
        {
            //
            // Note:  It is OK if we can't monitor the directory.  The error
            // will trickle up and the caller will not cache the entry
            //
            
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            pDME->Release();
            pDME = NULL;

            return hr;
        }
    }
    
    DBG_ASSERT( pDME != NULL );
    
    *ppDME = (CDirMonitorEntry*) pDME;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\usercache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     usercache.cxx

   Abstract:
     Implements the common code shared by all the caches
     (file, meta, uri, token, ul-cached-response, etc)
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"
#include "usercache.hxx"
#include "cachehint.hxx"

//static 
void
CACHE_ENTRY_HASH::AddRefRecord(
    CACHE_ENTRY *           pCacheEntry,
    int                     nIncr 
)
/*++

Routine Description:

    Dereference and possibly delete the cache entry.  Note the destructor
    for the cache entry is private.  Only this code should ever delete
    the cache entry

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT( pCacheEntry->CheckSignature() );
        
    if ( nIncr == +1 )
    {
        pCacheEntry->ReferenceCacheEntry();
    }
    else if ( nIncr == -1 )
    {
        pCacheEntry->SetFlushed();
        pCacheEntry->QueryCache()->IncFlushes();
        pCacheEntry->QueryCache()->DecEntriesCached();
        pCacheEntry->DereferenceCacheEntry();
    }
    else 
    {
        DBG_ASSERT( FALSE );
    }
}

//
// CACHE_ENTRY definitions
//

CACHE_ENTRY::CACHE_ENTRY(
    OBJECT_CACHE *      pObjectCache
)
{
    _cRefs = 1;
    _fFlushed = FALSE;
    _fCached = FALSE;
    _cConfiguredTTL = pObjectCache->QueryConfiguredTTL();
    _cTTL = _cConfiguredTTL;
    _pObjectCache = pObjectCache;
    _pDirmonInvalidator = NULL;
    
    _dwSignature = CACHE_ENTRY_SIGNATURE;
}

CACHE_ENTRY::~CACHE_ENTRY(
    VOID
)
{
    DBG_ASSERT( _cRefs == 0 );

    if ( _pDirmonInvalidator != NULL )
    {
        _pDirmonInvalidator->Release();
        _pDirmonInvalidator = NULL;
    }
    
    if ( _fFlushed )
    {
        DBG_ASSERT( QueryCache() != NULL );

        QueryCache()->DecActiveFlushedEntries();
    }
    
    _dwSignature = CACHE_ENTRY_SIGNATURE_FREE;
}

VOID
CACHE_ENTRY::ReferenceCacheEntry(
    VOID
)
/*++

Routine Description:

    Reference the given entry (duh)

Arguments:

    None

Return Value:

    None

--*/
{
    LONG                cRefs;
    
    cRefs = InterlockedIncrement( &_cRefs );
    
    DBG_ASSERT( QueryCache() != NULL );
    QueryCache()->DoReferenceTrace( this, cRefs );
}

VOID
CACHE_ENTRY::DereferenceCacheEntry(
    VOID
)
/*++

Routine Description:

    Dereference and possibly delete the cache entry.  Note the destructor
    for the cache entry is private.  Only this code should ever delete
    the cache entry

Arguments:

    None

Return Value:

    None

--*/
{
    LONG                cRefs;
    OBJECT_CACHE *      pObjectCache = QueryCache();
    
    DBG_ASSERT( pObjectCache != NULL );
    
    cRefs = InterlockedDecrement( &_cRefs );

    pObjectCache->DoReferenceTrace( this, cRefs );
    
    if ( cRefs == 0 )
    {
        delete this;
    }
}

HRESULT
CACHE_ENTRY::AddDirmonInvalidator(
    DIRMON_CONFIG *     pDirmonConfig
)
/*++

Routine Description:

    Setup dirmon invalidation for this cache entry        

Arguments:

    pDirmonConfig - path/token for use in monitoring directory

Return Value:

    HRESULT 

--*/
{
    CDirMonitorEntry *          pDME = NULL;
    HRESULT                     hr;
    
    hr = QueryCache()->AddDirmonInvalidator( pDirmonConfig, &pDME );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( pDME != NULL );

    //
    // Cleanup any old dir monitor entry
    //
   
    if ( _pDirmonInvalidator != NULL )
    {
        _pDirmonInvalidator->Release();
    }
    
    _pDirmonInvalidator = pDME;
    
    return NO_ERROR;
}

BOOL
CACHE_ENTRY::Checkout(
    VOID
)
/*++

Routine Description:

    Checkout a cache entry
        
Arguments:

    None

Return Value:

    TRUE if the checkout was successful, else FALSE 

--*/
{
    ReferenceCacheEntry();
    
    if ( QueryIsFlushed() )
    {
        DereferenceCacheEntry();
        QueryCache()->IncMisses(); 
        return FALSE;
    }
    else
    {
        QueryCache()->IncHits();
        return TRUE;
    }
}

BOOL
CACHE_ENTRY::QueryIsOkToFlushTTL(
    VOID
)
/*++

Routine Description:
        
    Called when the cache scavenger is invoked.  This routine returns whether
    it is OK to flush this entry due to TTL

Arguments:

    None

Return Value:

    TRUE if it is OK to flush by TTL, else FALSE

--*/
{
    //
    // Only do the TTL thing if the hash table holds the only reference to
    // the cache entry.  We can be loose with this check as this is just an
    // optimization to prevent overzealous flushing
    //
    
    if ( _cRefs > 1 )
    {
        return FALSE;
    }
    
    if ( InterlockedDecrement( &_cTTL ) == 0 ) 
    {
        //
        // TTL has expired.  However, we let the cache entry override this
        // expiry it wants to.  Check that now
        //
            
        //
        // Entry be gone!
        //
         
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CACHE_ENTRY::QueryIsOkToFlushMetadata(
    WCHAR *                     pszMetaPath,
    DWORD                       cchMetaPath
)
/*++

Routine Description:

    Called whem metadata has changed.  This routine returns whether the
    current cache entry should be flushed        

Arguments:

    pszMetaPath - Metabase path which changed
    cchMetaPath - Size of metabase path

Return Value:

    TRUE if we should flush

--*/
{
    BOOL                fRet;

    DBG_ASSERT( pszMetaPath != NULL );
    DBG_ASSERT( cchMetaPath != 0 );
    
    if ( pszMetaPath[ cchMetaPath - 1 ] == L'/' )
    {
        cchMetaPath--;
    }
    
    DBG_ASSERT( QueryCache()->QuerySupportsMetadataFlush() );

    if ( QueryMetadataPath() == NULL )
    {
        fRet = TRUE;
    }
    else if ( QueryMetadataPath()->QueryCCH() < cchMetaPath )
    {
        fRet = FALSE;
    }
    else if ( _wcsnicmp( QueryMetadataPath()->QueryStr(),
              pszMetaPath,
              cchMetaPath ) == 0 )
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

//
// OBJECT_CACHE definitions
//

OBJECT_CACHE::OBJECT_CACHE(
    VOID
)
/*++

Routine Description:

    Create an object cache.  Obviously all the app-specific goo will be 
    initialized in the derived class

Arguments:

    None

Return Value:

    None

--*/
{
    _hTimer = NULL;
    _pHintManager = NULL;
    _cmsecScavengeTime = 0;
    _cmsecTTL = 0;
    _dwSupportedInvalidation = 0;

    _cCacheHits = 0;
    _cCacheMisses = 0;
    _cCacheFlushes = 0;
    _cActiveFlushedEntries = 0;
    _cFlushCalls = 0;
    _cEntriesCached = 0;
    _cTotalEntriesCached = 0;

    _cPerfCacheHits = 0;
    _cPerfCacheMisses = 0;
    _cPerfCacheFlushes = 0;
    _cPerfFlushCalls = 0;
    _cPerfTotalEntriesCached = 0;
    
#if DBG
    _pTraceLog = CreateRefTraceLog( 2000, 0 );
#else
    _pTraceLog = NULL;
#endif
    
    InitializeListHead( &_listEntry );
    
    _dwSignature = OBJECT_CACHE_SIGNATURE;
}

OBJECT_CACHE::~OBJECT_CACHE(
    VOID
)
{
    if ( _hTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                               _hTimer,
                               INVALID_HANDLE_VALUE );
        
        _hTimer = NULL;
    }
    
    //
    // So why do I set the free sig here instead of at the top?  Because
    // waiting for the timer queue to go away may cause a timer completion
    // to fire and we don't want an assert there.
    //

    _dwSignature = OBJECT_CACHE_SIGNATURE_FREE;
   
    if ( _pHintManager != NULL )
    {
        delete _pHintManager;
        _pHintManager = NULL;
    }
    
    if ( _pTraceLog != NULL )
    {
        DestroyRefTraceLog( _pTraceLog );
        _pTraceLog = NULL;
    }
}

//static
VOID
WINAPI
OBJECT_CACHE::ScavengerCallback(
    PVOID                   pParam,
    BOOLEAN                 TimerOrWaitFired
)
{
    OBJECT_CACHE *          pObjectCache;
    
    pObjectCache = (OBJECT_CACHE*) pParam;
    DBG_ASSERT( pObjectCache != NULL );
    DBG_ASSERT( pObjectCache->CheckSignature() );
    
    pObjectCache->FlushByTTL(); 
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByTTL(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to TTL

Arguments:

    pCacheEntry - Cache entry to check
    pvState - Pointer to cache

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    OBJECT_CACHE *  pCache = (OBJECT_CACHE*) pvState;
    
    DBG_ASSERT( pCache != NULL );
    DBG_ASSERT( pCache->CheckSignature() );
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushTTL() )
    {   
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByDirmon(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to dir mon

Arguments:

    pCacheEntry - Cache entry to check
    pvState - STRU of path which changed

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    STRU *          pstrPath = (STRU*) pvState;
    OBJECT_CACHE *  pCache;
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    pCache = pCacheEntry->QueryCache();
    DBG_ASSERT( pCache->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushDirmon( pstrPath->QueryStr(),
                                              pstrPath->QueryCCH() ) )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

//static
LK_PREDICATE
OBJECT_CACHE::CacheFlushByMetadata(
    CACHE_ENTRY *           pCacheEntry,
    VOID *                  pvState
)
/*++

Routine Description:

    Determine whether given entry should be deleted due to metadata change

Arguments:

    pCacheEntry - Cache entry to check
    pvState - STRU with metapath which changed

Return Value:

    LKP_PERFORM - do the delete,
    LKP_NO_ACTION - do nothing

--*/
{
    STRU *          pstrPath = (STRU*) pvState;
    OBJECT_CACHE *  pCache;
    
    DBG_ASSERT( pCacheEntry != NULL );
    DBG_ASSERT( pCacheEntry->CheckSignature() );
    
    pCache = pCacheEntry->QueryCache();
    DBG_ASSERT( pCache->CheckSignature() );
    
    if ( pCacheEntry->QueryIsOkToFlushMetadata( pstrPath->QueryStr(),
                                                pstrPath->QueryCCH() ) )
    {
        return LKP_PERFORM;
    }
    else
    {
        return LKP_NO_ACTION;
    }
}

VOID
OBJECT_CACHE::FlushByTTL(
    VOID
)
/*++

Routine Description:

    Flush any inactive cache entries who have outlived they TTL

Arguments:

    None

Return Value:

    None

--*/
{
    IncFlushCalls();
    
    //
    // Iterate the hash table, deleting expired itmes
    //
    
    _hashTable.DeleteIf( CacheFlushByTTL, this );
}

VOID
OBJECT_CACHE::DoDirmonInvalidationFlush(
    WCHAR *             pszPath
)
/*++

Routine Description:

    Flush all appropriate entries due to dirmon change notification

Arguments:

    pszPath - Path that changed

Return Value:

    None

--*/
{
    STACK_STRU(             strPath, 256 );
    
    IncFlushCalls();
    
    if ( SUCCEEDED( strPath.Copy( pszPath ) ) )
    {
        _hashTable.DeleteIf( CacheFlushByDirmon, (VOID*) &strPath );
    }
}

VOID
OBJECT_CACHE::DoMetadataInvalidationFlush(
    WCHAR *             pszMetaPath
)
/*++

Routine Description:

    Flush all appropriate entries due to metadata change notification

Arguments:

    pszMetaPath - Metabase path which changed

Return Value:

    None

--*/
{
    STACK_STRU(             strPath, 256 );
    
    IncFlushCalls();
    
    if ( SUCCEEDED( strPath.Copy( pszMetaPath ) ) )
    {
        _hashTable.DeleteIf( CacheFlushByMetadata, (VOID*) &strPath );
    }
}

HRESULT
OBJECT_CACHE::SetCacheConfiguration(
    DWORD                   cmsecScavengeTime,
    DWORD                   cmsecTTL,
    DWORD                   dwSupportedInvalidation,
    CACHE_HINT_CONFIG *     pCacheHintConfig
)
/*++

Routine Description:

    Do the general cache initialization here

Arguments:

    cmsecScavengeTime - How often should a scavenger be run for this cache
                        (should be no larger than the TTL expected for 
                        entries in this cache)
    cmsecTTL - TTL for entries in this cache
    dwSupportedInvalidation - How can the cache be invalidated?
    pCacheHintConfig - Cache hint configuration (NULL for no cache hints)
    
Return Value:
    
    HRESULT

--*/
{
    BOOL                    fRet;
    HRESULT                 hr;

    DBG_ASSERT( cmsecTTL >= cmsecScavengeTime );
    
    //
    // Create a timer which fires every cmsecScavengeTime
    // 
   
    DBG_ASSERT( cmsecScavengeTime != 0 );
    
    _cmsecScavengeTime = cmsecScavengeTime;
    
    fRet = CreateTimerQueueTimer( &_hTimer,
                                  NULL,
                                  OBJECT_CACHE::ScavengerCallback,
                                  this,
                                  _cmsecScavengeTime,
                                  _cmsecScavengeTime,
                                  WT_EXECUTELONGFUNCTION );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    _cmsecTTL = cmsecTTL;
    
    _dwSupportedInvalidation = dwSupportedInvalidation;

    //
    // Should we setup a cache hint table
    //
    
    if ( pCacheHintConfig != NULL )
    {
        _pHintManager = new CACHE_HINT_MANAGER;
        if ( _pHintManager == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            DeleteTimerQueueTimer( NULL,
                                   _hTimer,
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
            
            return hr;
        }

        hr = _pHintManager->Initialize( pCacheHintConfig );
        if ( FAILED( hr ) )
        {   
             delete _pHintManager;
             _pHintManager = NULL;

            DeleteTimerQueueTimer( NULL,
                                   _hTimer,
                                   INVALID_HANDLE_VALUE );
            _hTimer = NULL;
        
            return hr;
        }
    }    

    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::FindCacheEntry(
    CACHE_KEY *                 pCacheKey,
    CACHE_ENTRY **              ppCacheEntry,
    BOOL *                      pfShouldCache
)
/*++

Routine Description:

    Lookup key in cache

Arguments:

    pCacheKey - Cache key to lookup
    ppCacheEntry - Points to cache entry on success
    pfShouldCache - Provides a hint if possible on whether we should cache
                    (can be NULL indicating no hint is needed)

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    HRESULT                     hr;
    CACHE_ENTRY *               pCacheEntry = NULL;
    
    if ( ppCacheEntry == NULL ||
         pCacheKey == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCacheEntry = NULL;

    //
    // First do a lookup
    //    
    
    lkrc = _hashTable.FindKey( pCacheKey, &pCacheEntry );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // If this entry has been flushed, then it really isn't a hit
        //
        
        if ( pCacheEntry->QueryIsFlushed() )
        {
            pCacheEntry->DereferenceCacheEntry();
        }
        else
        {
            IncHits();
            
            DBG_ASSERT( pCacheEntry != NULL );
        
            *ppCacheEntry = pCacheEntry;
            
            return NO_ERROR;
        }
    }
   
    IncMisses(); 
    
    //
    // Is a hint requested?
    //
    
    if ( pfShouldCache != NULL )
    {
        *pfShouldCache = TRUE;
        
        if ( _pHintManager != NULL )
        {
            hr = _pHintManager->ShouldCacheEntry( pCacheKey,
                                                  pfShouldCache );
            
            //
            // Ignore error
            //
        }        
    }

    return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
}

HRESULT
OBJECT_CACHE::FlushCacheEntry(
    CACHE_KEY *             pCacheKey
)
/*++

Routine Description:

    Flush given cache key 

Arguments:

    pCacheKey - Key to flush

Return Value:

    HRESULT

--*/
{
    LK_RETCODE                  lkrc;
    HRESULT                     hr;
    CACHE_ENTRY *               pCacheEntry;
        
    if ( pCacheKey == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First do a lookup
    //    
    
    lkrc = _hashTable.FindKey( pCacheKey, &pCacheEntry );
    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pCacheEntry != NULL );
        
        if ( !pCacheEntry->QueryIsFlushed() )
        {
            _hashTable.DeleteRecord( pCacheEntry );
        }
        
        pCacheEntry->DereferenceCacheEntry();
    }
    
    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::AddCacheEntry(
    CACHE_ENTRY *              pCacheEntry
)
/*++

Routine Description:

    Lookup key in cache

Arguments:

    pCacheEntry - Points to cache entry on success

Return Value:

    HRESULT

--*/
{
    LK_RETCODE          lkrc;
    
    if ( pCacheEntry == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( pCacheEntry->QueryCached() == FALSE );
    
    //
    // Now try to insert into hash table
    //

    pCacheEntry->SetCached( TRUE );

    lkrc = _hashTable.InsertRecord( pCacheEntry );
    if ( lkrc == LK_SUCCESS )
    {
        IncEntriesCached();
    }
    else
    {
        pCacheEntry->SetCached( FALSE );
    }

    return NO_ERROR;
}

HRESULT
OBJECT_CACHE::AddDirmonInvalidator(
    DIRMON_CONFIG *         pDirmonConfig,
    CDirMonitorEntry **     ppDME
)
/*++

Routine Description:

    Add dirmon invalidator for this cache

Arguments:

    pDirmonConfig - Configuration of dir monitor
    ppDME - filled with dir monitor entry to be attached to cache entry

Return Value:

    HRESULT

--*/
{
    HRESULT                     hr = NO_ERROR;
    
    if ( !QuerySupportsDirmonSpecific() &&
         !QuerySupportsDirmonFlush() )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    //
    // Start monitoring
    //
    
    DBG_ASSERT( g_pCacheManager != NULL );
    
    hr = g_pCacheManager->MonitorDirectory( pDirmonConfig,
                                            ppDME );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( *ppDME != NULL );
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3cache\w3cache.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3cache.cxx

   Abstract:
     Exposes the cache manager (and thus cache) to everyone
 
   Author:
     Bilal Alam (balam)             11-Nov-2000

   Environment:
     Win32 - User Mode

   Project:
     ULW3.DLL
--*/

#include "precomp.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

HRESULT
W3CacheInitialize(
    IMSAdminBase *          pAdminBase
)
/*++

Routine Description:

    Initialize cache manager

Arguments:

    pAdminBase - Admin base object used for stuff

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    
    DBG_ASSERT( g_pCacheManager == NULL );
    
    //
    // Allocate an initialize the cache manager (there is only one manager)
    //
    
    g_pCacheManager = new CACHE_MANAGER;
    if ( g_pCacheManager == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = g_pCacheManager->Initialize( pAdminBase );
    if ( FAILED( hr ) )
    {
        delete g_pCacheManager;
        g_pCacheManager = NULL;
        return hr;
    }
    
    return NO_ERROR;
}

VOID
W3CacheTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup the cache manager

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pCacheManager != NULL )
    {
        g_pCacheManager->Terminate();
        delete g_pCacheManager;
        g_pCacheManager = NULL;
    }
}

HRESULT
W3CacheRegisterCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Register a cache with the manager

Arguments:

    pObjectCache - Object cache to register

Return Value:

    HRESULT

--*/
{
    if ( g_pCacheManager == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    return g_pCacheManager->AddNewCache( pObjectCache );
}

HRESULT
W3CacheUnregisterCache(
    OBJECT_CACHE *          pObjectCache
)
/*++

Routine Description:

    Unregister a cache with the manager

Arguments:

    pObjectCache - Object cache to unregister

Return Value:

    HRESULT

--*/
{
    if ( g_pCacheManager == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }
    
    return g_pCacheManager->RemoveCache( pObjectCache );
}

HRESULT
W3CacheDoMetadataInvalidation(
    WCHAR *                 pszMetabasePath,
    DWORD                   cchMetabasePath
)
/*++

Routine Description:

    Drive invalidation of caches based on metadata changing

Arguments:

    pszMetabasePath - Metabase path which changed (includes the "LM/W3SVC/<>" stuff)
    cchMetabasePath - Size of path in characters

Return Value:

    HRESULT

--*/
{
    if ( pszMetabasePath == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( g_pCacheManager != NULL )
    {
        g_pCacheManager->HandleMetadataInvalidation( pszMetabasePath );
    }
    
    return NO_ERROR; 
}

VOID
W3CacheFlushAllCaches(
    VOID
)
/*++

Routine Description:

    Flush all caches

Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT( g_pCacheManager != NULL );
    
    g_pCacheManager->FlushAllCaches();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3dirmon\dirmon.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       dirmon.cxx

   Abstract:
       This module includes definitions of functions and variables
        for CDirMonitor and CDirMonitorEntry object

   Author:

       Charles Grant       ( cgrant   )     April-1997

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <iis.h>
#include "dbgutil.h"
#include "dirmon.h"

//
// CDirMonitorEntry
//

#define DEFAULT_BUFFER_SIZE 512

VOID
WINAPI
DirMonOverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
)
{
    CDirMonitor::OverlappedCompletionRoutine( dwErrorCode,
                                              dwNumberOfBytesTransfered,
                                              lpOverlapped );
}

VOID
CDirMonitor::OverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
)
{
    PVOID               pvContext;
   
    pvContext = CONTAINING_RECORD( lpOverlapped,
                                   CDirMonitorEntry,
                                   m_ovr );
                                   
    DBG_ASSERT( pvContext != NULL );

    CDirMonitor::DirMonitorCompletionFunction( pvContext,
                                               dwNumberOfBytesTransfered,
                                               dwErrorCode,
                                               lpOverlapped );
}

CDirMonitorEntry::CDirMonitorEntry() :
                    m_cDirRefCount(0),
                    m_cIORefCount(0),
                    m_hDir(INVALID_HANDLE_VALUE),
                    m_dwNotificationFlags(0),
                    m_pszPath(NULL),
                    m_cPathLength(0),
                    m_pDirMonitor(NULL),
                    m_cBufferSize(0),
                    m_pbBuffer(NULL),
                    m_fInCleanup(FALSE),
                    m_fWatchSubdirectories(FALSE)
/*++

Routine Description:

    CDirMonitorEntry constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


CDirMonitorEntry::~CDirMonitorEntry(
    VOID
    )
/*++

Routine Description:

    CDirMonitorEntry destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    HANDLE              hDir;
    
    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Destructor\n"));
    }

    // We should only be destroyed when
    // our ref counts have gone to 0

    DBG_ASSERT(m_cDirRefCount == 0);
    DBG_ASSERT(m_cIORefCount == 0);

    //
    // We really ought to have closed the handle by now
    //
    if (m_hDir != INVALID_HANDLE_VALUE) {
        
        DBGPRINTF(( DBG_CONTEXT, "~CDirMonitorEntry: open handle %p\n",
                    m_hDir ));

        hDir = m_hDir;

        m_hDir = INVALID_HANDLE_VALUE;
        
        CloseHandle( hDir );
    }

    if (m_pDirMonitor != NULL)
    {
        m_pDirMonitor->RemoveEntry(this);
        m_pDirMonitor = NULL;
    }

    m_cPathLength = 0;

    if ( m_pszPath != NULL )
    {
        LocalFree( m_pszPath );
        m_pszPath = NULL;
    }

    if (m_pbBuffer != NULL)
    {
        LocalFree(m_pbBuffer);
        m_cBufferSize = 0;
    }
}

BOOL
CDirMonitorEntry::Init(
    DWORD cBufferSize = DEFAULT_BUFFER_SIZE
)
/*++

Routine Description:

    Initialize the dir montior entry.

Arguments:

    cBufferSize  - Initial size of buffer used to store change notifications

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    // Don't allow a 0 length buffer
    if (cBufferSize == 0)
    {
         return FALSE;
    }

    DBG_ASSERT( m_pbBuffer == NULL );

    m_pbBuffer = (BYTE *) LocalAlloc( LPTR, cBufferSize );

    if (m_pbBuffer != NULL)
    {
        m_cBufferSize = cBufferSize;
        return TRUE;
    }
    else
    {
        // Unable to allocate buffer
        return FALSE;
    }
}

BOOL
CDirMonitorEntry::RequestNotification(
    VOID
)
/*++

Routine Description:

    Request ATQ to monitor directory changes for the directory handle
    associated with this entry

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL        fResult = FALSE;
    DWORD       cbRead = 0;
    
    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Request change notification\n"));
    }


    DBG_ASSERT(m_pDirMonitor);

    // Reset the overlapped io structure

    memset(&m_ovr, 0, sizeof(m_ovr));

    // Increase the ref count in advance

    IOAddRef();

    // Request notification of directory changes

    fResult = ReadDirectoryChangesW( m_hDir,
                                     m_pbBuffer,
                                     m_cBufferSize,
                                     m_fWatchSubdirectories,
                                     m_dwNotificationFlags,
                                     &cbRead,
                                     &m_ovr,
                                     NULL );

    if (!fResult)
    {
        // ReadDirChanges failed so
        // release the ref count we did in advance
        // Might cause IO ref count to go to 0

        IORelease();
    }

    return fResult;

}

BOOL
CDirMonitorEntry::Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up resource and determines if the caller need to delete
    the Directory Monitor Entry instance.

Arguments:

    None

Return Value:

    TRUE if the caller is responsible for deleting the object
    This will be the case if there are no pending Asynch IO requests

--*/
{
    BOOL            fDeleteNeeded = FALSE;
    BOOL            fHandleClosed = FALSE;
    HANDLE          hDir = INVALID_HANDLE_VALUE;
    
    DBG_ASSERT(m_cDirRefCount == 0);

    BOOL fInCleanup = (BOOL) InterlockedExchange((long *) &m_fInCleanup, TRUE);
    DBG_ASSERT(fInCleanup == FALSE);

    // Get the IO ref count BEFORE we close the handle

    DWORD cIORefCount = m_cIORefCount;

    if (m_hDir != INVALID_HANDLE_VALUE)
    {
        // If we have a pending AtqReadDirectoryChanges,
        // closing the directory handle will cause a call back from ATQ.
        // The call back should relase the final refcount on the object
        // which should result in its deletion

        hDir = m_hDir;

        m_hDir = INVALID_HANDLE_VALUE;

        fHandleClosed = CloseHandle( hDir );
    }

    // If there were no pending Asynch IO operations or if we failed
    // to close the handle, then the caller will be responsible for
    // deleting this object.

    if (cIORefCount == 0 || fHandleClosed == FALSE)
    {
        fDeleteNeeded = TRUE;
    }

    return fDeleteNeeded;
}

BOOL
CDirMonitorEntry::ResetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Opens a new directory handle for the path,
    and closes the old ones. We want to be able to do this so we
    can change the size of the buffer passed in ReadDirectoryChangesW.

Arguments:

    None

Return Value:

    TRUE if the handles were succesfully reopened
    FALSE otherwise

--*/
{
    // BUGBUG - Beta2 HACK

    return FALSE;

    // We'd better have a directory path available to try this
      
    if (m_pszPath == NULL)
    {
        return FALSE;
    }
        
    // Get a new handle to the directory

    HANDLE hDir = CreateFileW( m_pszPath,
                               FILE_LIST_DIRECTORY,
                                    FILE_SHARE_READ |
                                    FILE_SHARE_WRITE |
                                    FILE_SHARE_DELETE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS |
                                    FILE_FLAG_OVERLAPPED,
                               NULL );

    if ( hDir == INVALID_HANDLE_VALUE )
    {
        // We couldn't open another handle on the directory,
        // leave the current handle and ATQ context alone

        return FALSE;
    }
    
    //
    // Associate handle with thread pool's completion port
    //
    
    if ( !ThreadPoolBindIoCompletionCallback( hDir,
                                              DirMonOverlappedCompletionRoutine,
                                              0 ) )
    {
        // We couldn't get a new ATQ context. Close our new handle.
        // We leave the objects current handle and ATQ context alone
        CloseHandle(hDir);
        return FALSE;
    }

    // We have the new handle and ATQ context so we close
    // and replace the old ones.


    if ( m_hDir != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hDir );
    }

    m_hDir = hDir;
    
    return TRUE;
}

BOOL
CDirMonitorEntry::SetBufferSize(
    DWORD cBufferSize
    )
/*++

Routine Description:

    Sets the size of the buffer used for storing change notification records

Arguments:

    cBufferSize         new size for the buffer.

Return Value:

    TRUE        if the size of the buffer was succesfully set
    FALSE       otherwise

Note

    When a call to ReadDirectoryChangesW is made, the size of the buffer is set in
    the data associated with the directory handle and is not changed on subsequent
    calls to ReadDirectoryChangesW. To make use of the new buffer size the directory
    handle must be closed and a new handle opened (see ResetDirectoryHandle())
        
--*/
{
    // We should never be called if the buffer doesn't already exist
       
    DBG_ASSERT(m_pbBuffer);
        
    // Don't allow the buffer to be set to 0
       
    if (cBufferSize == 0)
    {
        return FALSE;
    }

    VOID *pbBuffer = LocalReAlloc( m_pbBuffer, 
                                   cBufferSize,
                                   LMEM_MOVEABLE );

    if (pbBuffer == NULL)
    {
        // Re-allocation failed, stuck with the same size buffer
         
        return FALSE;
    }
    else
    {
        // Re-allocation succeded, update the member variables
                
        m_pbBuffer = (BYTE *) pbBuffer;
        m_cBufferSize = cBufferSize;
        return TRUE;
    }
}

//
// CDirMonitor
//

CDirMonitor::CDirMonitor()
    : CTypedHashTable<CDirMonitor, CDirMonitorEntry, const WCHAR*>("DirMon")
/*++

Routine Description:

    CDirMonitor constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    ThreadPoolInitialize();
    INITIALIZE_CRITICAL_SECTION( &m_csSerialComplLock );
    m_cRefs = 1;
    m_fShutdown = FALSE;
}


CDirMonitor::~CDirMonitor()
/*++

Routine Description:

    CDirMonitor destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection(&m_csSerialComplLock);
    ThreadPoolTerminate();
}

BOOL
CDirMonitor::Monitor(
    CDirMonitorEntry *                  pDME,
    LPWSTR                              pszDirectory,
    BOOL                                fWatchSubDirectories,
    DWORD                               dwNotificationFlags
    )
/*++

Routine Description:

    Create a monitor entry for the specified path

Arguments:

    pszDirectory - directory to monitor
    pCtxt - Context of path is being monitored
    pszDirectory - name of directory to monitor
    fWatchSubDirectories - whether to get notifications for subdirectories
    dwNotificationFlags - which activities to be notified of

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Caller should have a lock on the CDirMonitor
    Not compatible with WIN95

--*/
{
    LIST_ENTRY  *pEntry;
    HANDLE      hDirectoryFile = INVALID_HANDLE_VALUE;
    BOOL        fRet = TRUE;
    DWORD       dwDirLength = 0;
    LK_RETCODE  lkrc;

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Monitoring new CDirMonitorEntry\n"));
    }

    // Must have a directory monitor entry and a string
    // containing the directory path

    if (!pDME || !pszDirectory)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Make copy of pszDirectory for the entry to hang on to


    pDME->m_cPathLength = wcslen(pszDirectory);
    if ( !(pDME->m_pszPath = (LPWSTR)LocalAlloc( LPTR,
                                                 ( pDME->m_cPathLength + 1 ) * sizeof( WCHAR ) )) )
    {
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    memcpy( pDME->m_pszPath, 
            pszDirectory, 
            ( pDME->m_cPathLength + 1 ) * sizeof( WCHAR ) );

    pDME->Init();

    // Open the directory handle

    hDirectoryFile = CreateFileW(
                           pszDirectory,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDirectoryFile == INVALID_HANDLE_VALUE )
    {
        // Cleanup
        LocalFree(pDME->m_pszPath);
        pDME->m_pszPath = NULL;
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    else
    {
        // Store the handle so we can close it on cleanup

        pDME->m_hDir = hDirectoryFile;

        // Set the flags for the type of notifications we want
        // and if we should watch subdirectories or just the root

        pDME->m_dwNotificationFlags = dwNotificationFlags;
        pDME->m_fWatchSubdirectories = fWatchSubDirectories;

        // Get an ATQ context for this handle
        // and register our completion call back function

        if ( ThreadPoolBindIoCompletionCallback( 
                                        hDirectoryFile,
                                        DirMonOverlappedCompletionRoutine,
                                        0 ) )
        {
            // Insert this entry into the list of active entries

            lkrc = InsertEntry(pDME);
            if (lkrc == LK_SUCCESS)
            {

                // Ask for notification if this directory has changes

                if (!pDME->RequestNotification())
                {
                    // Couldn't register for change notification
                    // Clean up resources
                    RemoveEntry(pDME);
                    
                    pDME->m_hDir = INVALID_HANDLE_VALUE;
                    
                    CloseHandle( hDirectoryFile );
                    
                    LocalFree(pDME->m_pszPath);
                    pDME->m_pszPath = NULL;
                    pDME->m_cPathLength = 0;
                    return FALSE;
                }
            }
            else
            {
                //
                // Could not add to hash table.  Cleanup 
                //
                
                CloseHandle(hDirectoryFile);
                pDME->m_hDir = INVALID_HANDLE_VALUE;
                LocalFree(pDME->m_pszPath);
                pDME->m_pszPath = NULL;
                pDME->m_cPathLength = 0;
               
                //
                // If it has been added from underneath us, indicate so
                // 
                
                if ( lkrc == LK_KEY_EXISTS )
                {
                    SetLastError( ERROR_ALREADY_EXISTS );
                }
                
                return FALSE;
            }
        }
        else
        {
           
            // Failed to add handle to ATQ, clean up

            CloseHandle(hDirectoryFile);
            pDME->m_hDir = INVALID_HANDLE_VALUE;
            LocalFree(pDME->m_pszPath);
            pDME->m_pszPath = NULL;
            pDME->m_cPathLength = 0;
            return FALSE;
        }

    }

    return TRUE;
}

VOID
CDirMonitor::DirMonitorCompletionFunction(
    PVOID                       pCtxt,
    DWORD                       dwBytesWritten,
    DWORD                       dwCompletionStatus,
    OVERLAPPED *                pOvr
    )
/*++

Routine Description:

Static member function called by ATQ to signal directory changes

Arguments:

    pCtxt - CDirMonitorEntry*
    dwBytesWritten - # bytes returned by ReadDirectoryChanges
    dwCompletionStatus - status of request to ReadDirectoryChanges
    pOvr - OVERLAPPED as specified in call to ReadDirectoryChanges

Return Value:

    Nothing

--*/
{
    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back begining. Status %d\n", dwCompletionStatus));
    }

    CDirMonitorEntry*  pDirMonitorEntry = reinterpret_cast<CDirMonitorEntry*>(pCtxt);

    DBG_ASSERT(pDirMonitorEntry);

    // Safety add ref, this should guarentee that the DME is not deleted
    // while we are still processing the callback

    pDirMonitorEntry->IOAddRef();

    // Release for the current Asynch operation
    // Should not send IO ref count to 0

    DBG_REQUIRE(pDirMonitorEntry->IORelease());

    BOOL fRequestNotification = FALSE;

    // There has been a change in the directory we were monitoring
    // carry out whatever work we need to do.

    if (!pDirMonitorEntry->m_fInCleanup)
    {
        pDirMonitorEntry->m_pDirMonitor->SerialComplLock();
        // BUGBUG Under stress ActOnNotification has been initiating a chain
        // of events leading to an AV. For Beta 3 we think we can ignore
        // these AV. For the final product we need to rework the critical
        // sections for the template manager and
        // the include file table.

        __try
        {
            fRequestNotification = pDirMonitorEntry->ActOnNotification(dwCompletionStatus, dwBytesWritten);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            // We should never get here
            DBG_ASSERT(FALSE);
        }

        // If ActOnNotification returned TRUE, then make another Asynch
        // notification request.

        if (fRequestNotification)
        {
            fRequestNotification = pDirMonitorEntry->RequestNotification();
        }

        pDirMonitorEntry->m_pDirMonitor->SerialComplUnlock();
    }

    // Remove safety ref count, may cause IO ref count to go to 0

    pDirMonitorEntry->IORelease();

    IF_DEBUG( DIRMON )
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back ending\n"));
    }
}


CDirMonitorEntry *
CDirMonitor::FindEntry(
    LPWSTR                  pszPath
    )
/*++

Routine Description:

    Searches the list of entries for the specified path

Arguments:

    pszPath - file path, including file name

Return Value:

    pointer to the entry, allready addref'd

--*/
{
    DBG_ASSERT(pszPath);

    CDirMonitorEntry *pDME = NULL;

    //
    // Lock to prevent aga finding an entry that could be deleted by someone
    //
    ReadLock();

    FindKey(pszPath, &pDME);

    if (pDME != NULL)
    {
        if (pDME->m_fInCleanup)
        {
            // Don't hand back a DME that is being shutdown
            pDME = NULL;
        }
        else
        {
            // We found a valid DME which we are going to hand to the caller
            pDME->AddRef();
        }
    }

    ReadUnlock();

    return pDME;
}

LK_RETCODE
CDirMonitor::InsertEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Insert an entry into the list of entries for the monitor

Arguments:

    pDME - entry to insert

Return Value:

    LK returncode 

--*/
{
    DBG_ASSERT(pDME);
    LK_RETCODE  lkResult;

    //
    // If we're cleaning up the table, don't let anyone else add stuff to
    // it
    //

    if ( m_fShutdown )
    {
        return LK_NOT_INITIALIZED;
    }

    pDME->m_pDirMonitor = this;

    lkResult = InsertRecord(pDME, false);
    
    if (lkResult == LK_SUCCESS) 
    {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Inserting directory (DME %08x) %ws\n", pDME, pDME->m_pszPath));

        AddRef();
    }
    else
    {
        pDME->m_pDirMonitor = NULL;
    }
       
    return lkResult;
}

LK_RETCODE
CDirMonitor::RemoveEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Deletes an entry from the list of entries for the monitor

Arguments:

    pDME - entry to delete

Return Value:

    None

--*/
{
    DBG_ASSERT(pDME);

    //
    // Delete the entry from the hash table
    //

    LK_RETCODE lkResult = DeleteRecord(pDME);
    pDME->m_pDirMonitor = NULL;

    DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Removed DME(%08x), directory %ws\n", pDME, pDME->m_pszPath));

    //
    // Release the DME's reference on the DirMonitor object.
    //
    // It seems obvious, but we must have the Release() occur AFTER the
    // removal of the hash-table entry.  This is because the loop check
    // in CDirMonitor::Cleanup() can complete while DeleteKey() is still
    // doing stuff to the table.  I mention this since DirMon cleanup is an 
    // often-butchered code path.  
    //

    Release();

    return lkResult;
}

VOID
CDirMonitor::Cleanup(
    VOID
    )
/*++

Routine Description:

    Pauses while all entries are cleaned up

Arguments:

    None

Return Value:

    None

--*/
{   
    //
    // Don't let anyone else try to insert into the hashtable
    //
    
    m_fShutdown = TRUE;

    //
    // Sleep until the hash table is empty and all contained
    // CDirMonitorEntry's are destroyed
    //

    while (Size() > 0 || m_cRefs != 1)
    {
        //
        // At least one DME is still active, sleep and try again
        //
        
        Sleep(200);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dbgutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_DLL_MANAGER              0x80000000
#define DEBUG_ISAPI                    0x08000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\server_support.cxx ===
/*++

   Copyright    (c)    1999-2001    Microsoft Corporation

   Module Name :
     server_support.cxx

   Abstract:
     IIS Plus ServerSupportFunction command implementations
 
   Author:
     Wade Hilmo (wadeh)             05-Apr-2000

   Project:
     w3isapi.dll

--*/

#include "precomp.hxx"
#include "isapi_context.hxx"
#include "server_support.hxx"

//
// BUGBUG - stristr is declared in iisrearc\core\inc\irtlmisc.h,
// but doesn't appear to be implemented anywhere.  Because of the
// way it's declared in that file, we have to use a different
// function name here...
//

const char*
stristr2(
    const char* pszString,
    const char* pszSubString
    );

HRESULT
SSFSendResponseHeader(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szStatus,
    LPSTR           szHeaders
    )
/*++

Routine Description:

    Sends HTTP status and headers to the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szStatus - The status to send to the client (ie. "200 OK")
    szHeaders - Headers to send to the client (ie. foo1: value1\r\n\r\n")
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We need validate the fKeepConn status for the request now,
    // since http.sys will generate the connection response
    // header based on it.
    //
    // If we're going to support keep-alive, then the
    // ISAPI must return either a content-length header,
    // or use chunked transfer encoding.  We'll check for
    // that here.
    //

    if ( pIsapiContext->QueryClientKeepConn() )
    {
        if ( szHeaders != NULL &&
             ( stristr2( szHeaders, "content-length: " ) != NULL ||
               stristr2( szHeaders, "transfer-encoding: chunked" ) != NULL ) )
        {
            pIsapiContext->SetKeepConn( TRUE );
        }
    }

    //
    // Note that NULL is valid for both szStatus and szHeaders,
    // so there's no need to validate them.
    //

    return pIsapiCore->SendResponseHeaders(
        !pIsapiContext->QueryKeepConn(),
        szStatus,
        szHeaders,
        HSE_IO_SYNC
        );
}

HRESULT
SSFSendResponseHeaderEx(
    ISAPI_CONTEXT *             pIsapiContext,
    HSE_SEND_HEADER_EX_INFO *   pHeaderInfo
    )
/*++

Routine Description:

    Sends HTTP status and headers to the client, and offers
    explicit control over keep-alive for this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pHeaderInfo   - The response info to be passed to the client
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         pHeaderInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Set the keep connection flag.  It can only be TRUE if the
    // ISAPI and the client both want keep alive.
    //
    // Note that we are trusting the ISAPI to provide some kind
    // of content length in the case where it's setting fKeepConn
    // to TRUE.  This is the same behavior as IIS 5 which, for
    // performance reasons, doesn't try to parse the headers from
    // the ISAPI.
    //

    if ( pHeaderInfo->fKeepConn &&
         pIsapiContext->QueryClientKeepConn() )
    {
        pIsapiContext->SetKeepConn( TRUE );
    }

    return pIsapiCore->SendResponseHeaders(
        !pIsapiContext->QueryKeepConn(),
        const_cast<LPSTR>( pHeaderInfo->pszStatus ),
        const_cast<LPSTR>( pHeaderInfo->pszHeader ),
        HSE_IO_SYNC
        );
}

HRESULT
SSFMapUrlToPath(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Maps a URL into a physical path

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szBuffer      - On entry, contains the URL to map.  On return,
                    contains the mapped physical path.
    pcbBuffer     - On entry, the size of szBuffer.  On successful
                    return, the number of bytes copied to szUrl.  On
                    failed return, the number of bytes needed for the
                    physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         szBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->MapPath(
        reinterpret_cast<BYTE*>( szBuffer ),
        *pcbBuffer,
        pcbBuffer,
        FALSE
        );
}

HRESULT
SSFMapUrlToPathEx(
    ISAPI_CONTEXT *         pIsapiContext,
    LPSTR                   szUrl,
    HSE_URL_MAPEX_INFO *    pHseMapInfo,
    LPDWORD                 pcbMappedPath
    )
/*++

Routine Description:

    Maps a URL to a physical path and returns some metadata
    metrics for the URL to the caller.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The URL to map
    pHseMapInfo   - Upon return, contains the mapped URL info
    pcbMappedPath - If non-NULL, contains the buffer size needed
                    to store the mapped physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbMapped;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Additional parameter validation
    //

    if ( pIsapiCore == NULL ||
         szUrl == NULL ||
         pHseMapInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // The inline buffer within the HSE_URL_MAPEX_INFO structure
    // is defined as being MAX_PATH size.
    //

    cbMapped = MAX_PATH;

    pHseMapInfo->dwReserved1 = 0;
    pHseMapInfo->dwReserved2 = 0;

    return pIsapiCore->MapPathEx(
        reinterpret_cast<BYTE*>( szUrl ),
        strlen(szUrl) + 1,
        reinterpret_cast<BYTE*>( pHseMapInfo->lpszPath ),
        cbMapped,
        pcbMappedPath ? pcbMappedPath : &cbMapped,
        &pHseMapInfo->cchMatchingPath,
        &pHseMapInfo->cchMatchingURL,
        &pHseMapInfo->dwFlags,
        FALSE
        );
}

HRESULT
SSFMapUnicodeUrlToPath(
    ISAPI_CONTEXT * pIsapiContext,
    LPWSTR          szBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Maps a URL into a physical path

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szBuffer      - On entry, contains the URL to map.  On return,
                    contains the mapped physical path.
    pcbBuffer     - On entry, the size of szBuffer.  On successful
                    return, the number of bytes copied to szUrl.  On
                    failed return, the number of bytes needed for the
                    physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         szBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->MapPath(
        reinterpret_cast<BYTE*>( szBuffer ),
        *pcbBuffer,
        pcbBuffer,
        TRUE
        );
}

HRESULT
SSFMapUnicodeUrlToPathEx(
    ISAPI_CONTEXT *             pIsapiContext,
    LPWSTR                      szUrl,
    HSE_UNICODE_URL_MAPEX_INFO *pHseMapInfo,
    LPDWORD                     pcbMappedPath
    )
/*++

Routine Description:

    Maps a URL to a physical path and returns some metadata
    metrics for the URL to the caller.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The URL to map
    pHseMapInfo   - Upon return, contains the mapped URL info
    pcbMappedPath - If non-NULL, contains the buffer size needed
                    to store the mapped physical path.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbMapped;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Additional parameter validation
    //

    if ( pIsapiCore == NULL ||
         szUrl == NULL ||
         pHseMapInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // The inline buffer within the HSE_URL_MAPEX_INFO structure
    // is defined as being MAX_PATH size.
    //

    cbMapped = MAX_PATH * sizeof(WCHAR);

    return pIsapiCore->MapPathEx(
        reinterpret_cast<BYTE*>( szUrl ),
        (wcslen(szUrl) + 1)*sizeof(WCHAR),
        reinterpret_cast<BYTE*>( pHseMapInfo->lpszPath ),
        cbMapped,
        pcbMappedPath ? pcbMappedPath : &cbMapped,
        &pHseMapInfo->cchMatchingPath,
        &pHseMapInfo->cchMatchingURL,
        &pHseMapInfo->dwFlags,
        TRUE
        );
}

HRESULT
SSFGetImpersonationToken(
    ISAPI_CONTEXT * pIsapiContext,
    HANDLE *        phToken
    )
/*++

Routine Description:

    Returns a (non-duplicated) copy of the token that the server
    is using to impersonate the client for this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    phToken       - Upon return, contains a copy of the token.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    //
    // Validate parameters
    //

    if ( phToken == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *phToken = pIsapiContext->QueryToken();

    return NO_ERROR;
}

HRESULT
SSFIsKeepConn(
    ISAPI_CONTEXT * pIsapiContext,
    BOOL *          pfIsKeepAlive
    )
/*++

Routine Description:

    Returns information about whether the client wants us to keep
    the connection open or not at completion of this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pfIsKeepAlive - Upon return, TRUE if IIS will be keeping the
                    connection alive, else FALSE.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    //
    // Validate parameters
    //

    if ( pfIsKeepAlive == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pfIsKeepAlive = pIsapiContext->QueryClientKeepConn();

    return NO_ERROR;
}

HRESULT
SSFDoneWithSession(
    ISAPI_CONTEXT * pIsapiContext,
    DWORD *         pHseResult
    )
/*++

Routine Description:

    Notifies the server that the calling ISAPI is done with the
    ECB (and ISAPI_CONTEXT) for this request and that the server
    can clean up.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pHseResult    - A pointer to the HSE_STATUS code that the extension
                    wants to use.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    DBG_REQUIRE( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() );

    //
    // If the caller wants to do STATUS_SUCCESS_AND_KEEP_CONN,
    // then we need to do that now.
    //
    // Note that this overrides our own determination of whether
    // the client can support keep-alive or not.  We are trusting
    // the caller to have returned the right headers to make this
    // work with the client.
    //

    if ( pHseResult &&
         *pHseResult == HSE_STATUS_SUCCESS_AND_KEEP_CONN )
    {
        if ( pIsapiContext->QueryClientKeepConn() )
        {
            pIsapiContext->SetKeepConn( TRUE );
            pIsapiCore->SetConnectionClose( !pIsapiContext->QueryKeepConn() );

        }
    }

    //
    // We'll just release the reference on IsapiContext.
    // Its destructor will do the rest.
    //

    pIsapiContext->DereferenceIsapiContext();
    pIsapiContext = NULL;

    return NO_ERROR;
}

HRESULT
SSFGetCertInfoEx(
    ISAPI_CONTEXT *     pIsapiContext,
    CERT_CONTEXT_EX *   pCertContext
    )
/*++

Routine Description:

    Returns certificate information about the client associated
    with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pCertContext  - Upon return, contains info about the client cert.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //
    
    if ( pIsapiCore == NULL ||
         pCertContext == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->GetCertificateInfoEx(
            pCertContext->cbAllocated,
            &( pCertContext->CertContext.dwCertEncodingType ),
            pCertContext->CertContext.pbCertEncoded,
            &( pCertContext->CertContext.cbCertEncoded ),
            &( pCertContext->dwCertificateFlags ) );
}

HRESULT
SSFIoCompletion(
    ISAPI_CONTEXT *         pIsapiContext,
    PFN_HSE_IO_COMPLETION   pCompletionRoutine,
    LPVOID                  pHseIoContext
    )
/*++

Routine Description:

    Establishes the I/O completion routine and user-defined context
    to be used for asynchronous operations associated with this
    request.

Arguments:

    pIsapiContext      - The ISAPI_CONTEXT associated with this command.
    pCompletionRoutine - The function to call upon I/O completion
    pHseIoContext      - The user-defined context to be passed to the
                         completion routine.
    
Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    //
    // Validate parameters
    //

    if ( pCompletionRoutine == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pIsapiContext->SetPfnIoCompletion( pCompletionRoutine );
    pIsapiContext->SetExtensionContext( pHseIoContext );

    return NO_ERROR;
}

HRESULT
SSFAsyncReadClient(
    ISAPI_CONTEXT * pIsapiContext,
    LPVOID          pBuffer,
    LPDWORD         pcbBuffer
    )
/*++

Routine Description:

    Queues an asynchronous read of data from the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pBuffer       - Buffer to be filled with read data.
    pcbBuffer     - The size of pBuffer
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    DWORD           cbBuffer;
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         pIsapiContext->QueryPfnIoCompletion() == NULL ||
         pBuffer == NULL ||
         pcbBuffer == NULL ||
         *pcbBuffer == 0 )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Do the async ReadClient call
    //

    if ( pIsapiContext->TryInitAsyncIo( AsyncReadPending ) == FALSE )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // Since we're never actually reading any data in the async
    // case, we want to prevent pIsapiCore->ReadClient() from
    // modifying the buffer size we report back to the caller,
    // so we'll use a local for cbBuffer.
    //

    cbBuffer = *pcbBuffer;

    //
    // If this call will be going OOP, save a pointer to the
    // read buffer so that the core can fill it when the
    // operation completes.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        DBG_ASSERT( pIsapiContext->QueryAsyncIoBuffer() == NULL );
        pIsapiContext->SetAsyncIoBuffer( pBuffer );
    }

    hr = pIsapiCore->ReadClient(
        reinterpret_cast<DWORD64>( pIsapiContext ),
        pIsapiContext->QueryIsOop() ? NULL : reinterpret_cast<unsigned char*>( pBuffer ),
        pIsapiContext->QueryIsOop() ? 0 : cbBuffer,
        cbBuffer,
        &cbBuffer,
        HSE_IO_ASYNC
        );

    if ( FAILED( hr ) )
    {
        pIsapiContext->SetAsyncIoBuffer( NULL );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFTransmitFile(
    ISAPI_CONTEXT * pIsapiContext,
    HSE_TF_INFO *   pTfInfo
    )
/*++

Routine Description:

    Transmits a file, a portion of a file, or some other data
    (in the event on a NULL file handle) to the client.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pTfInfo       - Describes the desired transmit file action.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    LARGE_INTEGER   cbFileSize;
    HRESULT         hr;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();


    //
    // Validate parameters - For TRANSMIT_FILE, this means:
    //
    // - We must have an ISAPI core interface to call through
    // - We must have an HSE_TF_INFO structure
    // - The HSE_IO_ASYNC flag must be set
    // - If HeadLength is set, pHead cannot be NULL
    // - If TailLength is set, pTail cannot be NULL
    // - We must have either a completion routine already set
    //   in the ISAPI_CONTEXT, or the HSE_TF_INFO must provide
    //   one
    // - There can be no other async operations in progress
    //

    if ( pIsapiCore == NULL ||
         pTfInfo == NULL ||
         ( pTfInfo->dwFlags & HSE_IO_ASYNC ) == 0 ||
         pTfInfo->hFile == INVALID_HANDLE_VALUE ||
         ( pTfInfo->HeadLength != 0 && pTfInfo->pHead == NULL ) ||
         ( pTfInfo->TailLength != 0 && pTfInfo->pTail == NULL ) ||
         ( pIsapiContext->QueryPfnIoCompletion() == NULL &&
           pTfInfo->pfnHseIO == NULL ) ||
         pIsapiContext->TryInitAsyncIo( AsyncWritePending ) == FALSE )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    //
    // We'll do some extra validation in the case where we've been
    // provided a file handle.
    //
    // Specifically, we'll check to make sure that the offset and
    // bytes-to-write are valid for the file.
    //
    // CODEWORK - Do we really need to do this, or can http.sys handle
    //            it?  Also, does http.sys treat zero bytes to write
    //            the same as TransmitFile (ie. send the whole file?)
    //

    if ( pTfInfo->hFile != NULL )
    {
        if (!GetFileSizeEx(pTfInfo->hFile,
                           &cbFileSize))
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Done;
        }

        if ( pTfInfo->Offset >= cbFileSize.QuadPart ||
             pTfInfo->Offset + pTfInfo->BytesToWrite > cbFileSize.QuadPart )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Done;
        }
    }
    else
    {
        //
        // No file handle, so initialize the size to zero
        //

        cbFileSize.QuadPart = 0;
    }

    //
    // If the HSE_TF_INFO includes I/O completion or context
    // information, override the existing settings.
    //

    if ( pTfInfo->pfnHseIO )
    {
        pIsapiContext->SetPfnIoCompletion( pTfInfo->pfnHseIO );
    }

    if ( pTfInfo->pContext )
    {
        pIsapiContext->SetExtensionContext( pTfInfo->pContext );
    }

    //
    // If the extension is setting HSE_IO_SEND_HEADERS, then we need
    // to determine if it's sending some kind of content length.  If
    // it's not, then we need to set _fKeepConn to FALSE.
    //
    // CODEWORK
    // Note that we're making a bold assumption here that if
    // HSE_IO_SEND_HEADERS is set, then pHead points to a NULL
    // terminated string.
    //

    if ( pIsapiContext->QueryClientKeepConn() &&
         pTfInfo->pHead &&
         ( pTfInfo->dwFlags & HSE_IO_SEND_HEADERS ) &&
         !( pTfInfo->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND ) )
    {
        if ( stristr2( (LPSTR)pTfInfo->pHead, "content-length: " ) != NULL ||
             stristr2( (LPSTR)pTfInfo->pHead, "transfer-encoding: chunked" ) != NULL )
        {
            pIsapiContext->SetKeepConn( TRUE );
        }
    }

    if ( pIsapiContext->QueryKeepConn() == FALSE )
    {
        pTfInfo->dwFlags |= HSE_IO_DISCONNECT_AFTER_SEND;
    }

    //
    // Save the BytesToWrite part as _cbLastAsyncIo, since the size of
    // pHead and pTail confuses ISAPI's that examine the cbWritten
    // value on completion.
    //

    ULARGE_INTEGER cbToWrite;

    if ( pTfInfo->BytesToWrite )
    {
        cbToWrite.QuadPart = pTfInfo->BytesToWrite;
    }
    else
    {
        cbToWrite.QuadPart = cbFileSize.QuadPart - pTfInfo->Offset;
    }

    //
    // Note that ISAPI doesn't support large integer values, so the
    // best we can do here is to store the low bits.
    //

    pIsapiContext->SetLastAsyncIo( cbToWrite.LowPart );

    hr = pIsapiCore->TransmitFile(
        reinterpret_cast<DWORD64>( pIsapiContext ),
        reinterpret_cast<DWORD_PTR>( pTfInfo->hFile ),
        pTfInfo->Offset,
        cbToWrite.QuadPart,
        (pTfInfo->dwFlags & HSE_IO_SEND_HEADERS) ? const_cast<LPSTR>( pTfInfo->pszStatusCode ) : NULL,
        reinterpret_cast<LPBYTE>( pTfInfo->pHead ),
        pTfInfo->HeadLength,
        reinterpret_cast<LPBYTE>( pTfInfo->pTail ),
        pTfInfo->TailLength,
        pTfInfo->dwFlags
        );

Done:

    if ( FAILED( hr ) )
    {
        pIsapiContext->SetLastAsyncIo( 0 );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFSendRedirect(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szUrl
    )
/*++

Routine Description:

    Sends a 302 redirect to the client associated with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szUrl         - The target URL for the redirection.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiContext == NULL ||
         szUrl == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    pIsapiContext->SetKeepConn( TRUE );

    return pIsapiCore->SendRedirect(
        szUrl
        );
}

HRESULT
SSFIsConnected(
    ISAPI_CONTEXT * pIsapiContext,
    BOOL *          pfIsConnected
    )
/*++

Routine Description:

    Returns the connection state (connected or not connected)
    of the client associated with this request.

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pfIsConnected - TRUE upon return if the client is connected,
                    else FALSE.
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         pfIsConnected == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->TestConnection( pfIsConnected );
}

HRESULT
SSFAppendLog(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szExtraParam
    )
/*++

Routine Description:

    Appends the string passed to the QueryString that will be logged

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    szExtraParam  - The extra parameter to be logged
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate parameters
    //

    if ( pIsapiCore == NULL ||
         szExtraParam == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->AppendLog( szExtraParam );
}

HRESULT
SSFExecuteUrl(
    ISAPI_CONTEXT *     pIsapiContext,
    HSE_EXEC_URL_INFO * pExecUrlInfo
    )
/*++

Routine Description:

    Execute a child request

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pExecUrlInfo  - Description of child request to execute
    
Return Value:

    HRESULT

--*/
{
    HSE_EXEC_URL_ENTITY_INFO    Entity;
    IIsapiCore *                pIsapiCore;
    BOOL                        fSync;
    HRESULT                     hr;
    
    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL ||
         pExecUrlInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Must be async (no sync)
    //
    
    if ( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_SYNC )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    if ( !( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_ASYNC ) )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    fSync = FALSE;
    
    //
    // If any of the optional parameters are not NULL, then ensure they are
    // not empty
    //
    
    if ( pExecUrlInfo->pszUrl != NULL )
    {
        if ( pExecUrlInfo->pszUrl[ 0 ] == '\0' ) 
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }
    
    if ( pExecUrlInfo->pszMethod != NULL )
    {
        if ( pExecUrlInfo->pszMethod[ 0 ] == '\0' )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }
    
    if ( pExecUrlInfo->pszChildHeaders != NULL )
    {
        if ( pExecUrlInfo->pszChildHeaders[ 0 ] == '\0' )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }
    
    if ( pExecUrlInfo->pUserInfo != NULL )
    {
        if ( pExecUrlInfo->pUserInfo->pszCustomUserName == NULL ||
             pExecUrlInfo->pUserInfo->pszCustomUserName[ 0 ] == '\0' )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
        
        if ( pExecUrlInfo->pUserInfo->pszCustomAuthType == NULL ||
             pExecUrlInfo->pUserInfo->pszCustomAuthType[ 0 ] == '\0' )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // If we are being told that there is available entity, ensure
    // that the buffer is not NULL
    //

    if ( pExecUrlInfo->pEntity != NULL )
    {
        if ( pExecUrlInfo->pEntity->cbAvailable != 0 &&
             pExecUrlInfo->pEntity->lpbData == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }
    
    //
    // Are we executing the URL synchronously?
    //

    fSync = !!( pExecUrlInfo->dwExecUrlFlags & HSE_EXEC_URL_SYNC );
    
    //
    // If no entity body was set for this child execute, then we should
    // duplicate the original entity body.  This means we will need to bring
    // over the preloaded entity for the ISAPI which calls this routine.
    //
    
    if ( pExecUrlInfo->pEntity == NULL )
    {
        Entity.cbAvailable = pIsapiContext->QueryECB()->cbAvailable;
        Entity.lpbData = pIsapiContext->QueryECB()->lpbData;
        
        pExecUrlInfo->pEntity = &Entity;
    }

    //
    // If this is an async call, then make sure a completion routine is set
    //
    
    if ( !fSync )
    {
        if ( pIsapiContext->QueryPfnIoCompletion() == NULL ||
             pIsapiContext->TryInitAsyncIo( AsyncExecPending ) == FALSE )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // All the heavy lifting is in W3CORE.DLL
    //
    
    hr = pIsapiCore->ExecuteUrl(
        fSync ? NULL : reinterpret_cast<DWORD64>( pIsapiContext ),
        reinterpret_cast<EXEC_URL_INFO*>( pExecUrlInfo )
        );

    if ( FAILED( hr ) && !fSync )
    {
        pIsapiContext->UninitAsyncIo();
    }
    
    return hr;
}

HRESULT
SSFGetExecuteUrlStatus(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_EXEC_URL_STATUS*    pExecUrlStatus
    )
/*++

Routine Description:

    Get status of last child execute

Arguments:

    pIsapiContext  - The ISAPI_CONTEXT associated with this command.
    pExecUrlStatus - Filled with status
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL ||
         pExecUrlStatus == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->GetExecuteUrlStatus( 
        &(pExecUrlStatus->uHttpStatusCode),
        &(pExecUrlStatus->uHttpSubStatus),
        &(pExecUrlStatus->dwWin32Error)
        );
}

HRESULT
SSFSendCustomError(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
    )
/*++

Routine Description:

    Send custom error to client

Arguments:

    pIsapiContext - The ISAPI_CONTEXT associated with this command.
    pCustomErrorInfo - Describes the custom error to send
    
Return Value:

    HRESULT

--*/
{
    IIsapiCore *    pIsapiCore;
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL ||
         pCustomErrorInfo == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Ensure status is not empty
    //
    
    if ( pCustomErrorInfo->pszStatus != NULL )
    {
        if ( pCustomErrorInfo->pszStatus[ 0 ] == '\0' )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    //
    // If this is an async call, then make sure a completion routine is set
    //
    
    if ( pCustomErrorInfo->fAsync )
    {
        if ( pIsapiContext->TryInitAsyncIo( AsyncExecPending ) == FALSE )
        {
            return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        }
    }

    hr = pIsapiCore->SendCustomError(
        pCustomErrorInfo->fAsync ? reinterpret_cast<DWORD64>( pIsapiContext ) : NULL,
        pCustomErrorInfo->pszStatus,
        pCustomErrorInfo->uHttpSubError );

    if ( FAILED( hr ) && pCustomErrorInfo->fAsync )
    {
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFVectorSend(
    ISAPI_CONTEXT *         pIsapiContext,
    HSE_RESPONSE_VECTOR *   pResponseVector
    )
{
    IIsapiCore *    pIsapiCore;
    ULONGLONG       cbTotalSend = 0;
    STACK_BUFFER(   buffResp, 512);
    HRESULT         hr = NOERROR;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // verify the data passed in
    //

    if ( pIsapiCore == NULL ||
         pResponseVector == NULL ||
         ( pResponseVector->dwFlags & HSE_IO_ASYNC ) != 0 &&
           pIsapiContext->TryInitAsyncIo( AsyncVectorPending ) == FALSE )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ((pResponseVector->dwFlags & HSE_IO_SYNC) &&
        (pResponseVector->dwFlags & HSE_IO_ASYNC))
    {
        hr =  HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Failed;
    }

    if (pResponseVector->dwFlags & HSE_IO_SEND_HEADERS)
    {
        if ((pResponseVector->pszStatus == NULL) ||
            (pResponseVector->pszHeaders == NULL))
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
    }
    else
    {
        if ((pResponseVector->pszStatus != NULL) ||
            (pResponseVector->pszHeaders != NULL))
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
            goto Failed;
        }
    }

    if (!buffResp.Resize(pResponseVector->nElementCount * sizeof(VECTOR_ELEMENT)))
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Failed;
    }
    ZeroMemory(buffResp.QueryPtr(),
               pResponseVector->nElementCount * sizeof(VECTOR_ELEMENT));

    VECTOR_ELEMENT *pVectorElement = (VECTOR_ELEMENT *)buffResp.QueryPtr();
    HSE_VECTOR_ELEMENT *pHseVectorElement;
    LARGE_INTEGER liFileSize;

    for (int i=0; i<pResponseVector->nElementCount; i++)
    {
        pHseVectorElement = &pResponseVector->lpElementArray[i];

        //
        // Only one of the hFile and pBuffer should be non-null
        //
        if (pHseVectorElement->pBuffer != NULL)
        {
            if (pHseVectorElement->hFile != NULL ||
                pHseVectorElement->cbSize > MAXULONG)
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Failed;
            }

            pVectorElement[i].pBuffer = (BYTE *)pHseVectorElement->pBuffer;
            cbTotalSend += ( pVectorElement[i].cbBufSize = pHseVectorElement->cbSize );
        }
        else
        {
            if (pHseVectorElement->hFile == NULL ||
                pHseVectorElement->hFile == INVALID_HANDLE_VALUE)
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
                goto Failed;
            }

            if (!GetFileSizeEx(pHseVectorElement->hFile,
                               &liFileSize))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Failed;
            }

            if (pHseVectorElement->cbOffset >= liFileSize.QuadPart ||
                pHseVectorElement->cbOffset + pHseVectorElement->cbSize > liFileSize.QuadPart)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
                goto Failed;
            }

            //
            // Treat 0 as "send the rest of the file" - same as TransmitFile
            //
            if (pHseVectorElement->cbSize == 0)
            {
                pHseVectorElement->cbSize = liFileSize.QuadPart - pHseVectorElement->cbOffset;
            }

            pVectorElement[i].hFile = (DWORD_PTR)pHseVectorElement->hFile;
            pVectorElement[i].cbOffset = pHseVectorElement->cbOffset;
            cbTotalSend += ( pVectorElement[i].cbFileSize = pHseVectorElement->cbSize );
        }
    }

    //
    // Set up the total number of bytes we are trying to send so that ISAPIs
    // are not confused
    //
    pIsapiContext->SetLastAsyncIo( (cbTotalSend > MAXULONG) ? MAXULONG : cbTotalSend );
   
    if ( pIsapiContext->QueryClientKeepConn() &&
         ( pResponseVector->dwFlags & HSE_IO_DISCONNECT_AFTER_SEND ) == 0 )
    {
        pIsapiContext->SetKeepConn( TRUE );
    }

    hr = pIsapiCore->VectorSend(
        pResponseVector->dwFlags & HSE_IO_ASYNC ? reinterpret_cast<DWORD64>( pIsapiContext ) : NULL,
        !pIsapiContext->QueryKeepConn(),
        pResponseVector->pszStatus,
        pResponseVector->pszHeaders,
        pVectorElement,
        pResponseVector->nElementCount
        );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    return hr;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    if ( pResponseVector->dwFlags & HSE_IO_ASYNC )
    {
        pIsapiContext->SetLastAsyncIo( 0 );
        pIsapiContext->UninitAsyncIo();
    }

    return hr;
}

HRESULT
SSFGetCustomErrorPage(
    ISAPI_CONTEXT *                 pIsapiContext,
    HSE_CUSTOM_ERROR_PAGE_INFO *    pInfo
    )
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    //
    // Validate arguments
    //

    if ( pIsapiCore == NULL || 
         pInfo == NULL || 
         ( pInfo->dwBufferSize != 0 && pInfo->pBuffer == NULL ) ||
         pInfo->pdwBufferRequired == NULL ||
         pInfo->pfIsFileError == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->GetCustomError(
        pInfo->dwError,
        pInfo->dwSubError,
        pInfo->dwBufferSize,
        reinterpret_cast<BYTE*>( pInfo->pBuffer ),
        pInfo->pdwBufferRequired,
        pInfo->pfIsFileError
        );
}

HRESULT
SSFIsInProcess(
    ISAPI_CONTEXT * pIsapiContext,
    DWORD *         pdwAppFlag
    )
{
    LPWSTR  szClsid;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );

    if ( pdwAppFlag == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    szClsid = pIsapiContext->QueryClsid();

    DBG_ASSERT( szClsid != NULL );

    if ( wcslen( szClsid ) == 0 )
    {
        *pdwAppFlag = HSE_APP_FLAG_IN_PROCESS;
    }
    else if ( _wcsicmp( szClsid, W3_OOP_POOL_WAM_CLSID ) == NULL )
    {
        *pdwAppFlag = HSE_APP_FLAG_POOLED_OOP;
    }
    else
    {
        *pdwAppFlag = HSE_APP_FLAG_ISOLATED_OOP;
    }

    return NO_ERROR;
}

HRESULT
SSFGetSspiInfo(
    ISAPI_CONTEXT * pIsapiContext,
    CtxtHandle *    pCtxtHandle,
    CredHandle *    pCredHandle
    )
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() );

    //
    // The CtxtHandle and CredHandle are only valid in their
    // local process.  There is no way to duplicate them into
    // a dllhost.  As a result, this function is inproc only.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_FUNCTION );
    }

    //
    // Validate parameters
    //

    if ( pCtxtHandle == NULL || pCredHandle == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->GetSspiInfo(
        reinterpret_cast<BYTE*>( pCredHandle ),
        sizeof( CredHandle ),
        reinterpret_cast<BYTE*>( pCtxtHandle ),
        sizeof( CtxtHandle )
        );
}

HRESULT
SSFGetVirtualPathToken(
    ISAPI_CONTEXT * pIsapiContext,
    LPSTR           szUrl,
    HANDLE *        pToken,
    BOOL            fUnicode
    )
{
    IIsapiCore *    pIsapiCore;

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->CheckSignature() );
    DBG_REQUIRE( pIsapiCore = pIsapiContext->QueryIsapiCoreInterface() );

    //
    // Validate parameters
    //

    if ( szUrl == NULL || pToken == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return pIsapiCore->QueryVrToken(
        reinterpret_cast<BYTE*>( szUrl ),
        fUnicode ? (wcslen( (LPWSTR)szUrl ) + 1 ) * sizeof(WCHAR) : strlen( szUrl ) + 1,
        reinterpret_cast<DWORD64*>( pToken ),
        fUnicode
        );
}

// stristr (stolen from fts.c, wickn)
//
// case-insensitive version of strstr.
// stristr returns a pointer to the first occurrence of
// pszSubString in pszString.  The search does not include
// terminating nul characters.
//
// BUGBUG: is this DBCS-safe?

const char*
stristr2(
    const char* pszString,
    const char* pszSubString
    )
{
    const char *cp1 = (const char*) pszString, *cp2, *cp1a;
    char first;

    // get the first char in string to find
    first = pszSubString[0];

    // first char often won't be alpha
    if (isalpha(first))
    {
        first = (char) tolower(first);
        for ( ; *cp1  != '\0'; cp1++)
        {
            if (tolower(*cp1) == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }
    else
    {
        for ( ; *cp1 != '\0' ; cp1++)
        {
            if (*cp1 == first)
            {
                for (cp1a = &cp1[1], cp2 = (const char*) &pszSubString[1];
                     ;
                     cp1a++, cp2++)
                {
                    if (*cp2 == '\0')
                        return cp1;
                    if (tolower(*cp1a) != tolower(*cp2))
                        break;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dll_manager.cxx ===
/*++

   Copyright    (c)    2000-2001    Microsoft Corporation

   Module Name :
     dll_manager.cxx

   Abstract:
     IIS Plus ISAPI Handler. Dll management classes.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000
     Wade A. Hilmo (WadeH)              08-Mar-2001

   Project:
     w3isapi.dll

--*/

#include "precomp.hxx"
#include "dll_manager.h"

ISAPI_DLL_MANAGER * g_pDllManager = NULL;

PTRACE_LOG              ISAPI_DLL::sm_pTraceLog;
ALLOC_CACHE_HANDLER *   ISAPI_DLL::sm_pachIsapiDlls;

//
//  Generic mapping for Application access check
//

GENERIC_MAPPING g_FileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

//static
HRESULT
ISAPI_DLL::Initialize(
    VOID
)
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    //
    // Initialize a lookaside for this structure
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ISAPI_DLL );

    DBG_ASSERT( sm_pachIsapiDlls == NULL );
    
    sm_pachIsapiDlls = new ALLOC_CACHE_HANDLER( "ISAPI_DLL",  
                                                &acConfig );

    if ( sm_pachIsapiDlls == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    return NO_ERROR;
}

//static
VOID
ISAPI_DLL::Terminate(
    VOID
)
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    if ( sm_pachIsapiDlls != NULL )
    {
        delete sm_pachIsapiDlls;
        sm_pachIsapiDlls = NULL;
    }
}    

HRESULT
ISAPI_DLL::SetName(
    const WCHAR *   szModuleName
    )
{
    HRESULT hr;

    DBG_ASSERT( CheckSignature() );

    hr = m_strModuleName.Copy( szModuleName );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Store a copy of the anti-canon module name
    //

    hr = MakePathCanonicalizationProof(
        const_cast<LPWSTR>( szModuleName ),
        &m_strAntiCanonModuleName
        );

    if ( SUCCEEDED( hr ) )
    {
        //
        // Verify that the file exists by getting its attributes.
        //

        if ( GetFileAttributes( m_strAntiCanonModuleName.QueryStr() ) ==
             0xffffffff )
        {
            IF_DEBUG( DLL_MANAGER )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Attempt to get file attributes on %S failed "
                    "with error %d.\r\n",
                    szModuleName,
                    GetLastError()
                    ));
            }

            //
            // CODEWORK - This smoke and mirrors game with the last
            // error is to preserve the old behavior that extensions
            // that are not found return 500 errors to the client
            // instead of 404.
            //

            if ( GetLastError() == ERROR_FILE_NOT_FOUND )
            {
                SetLastError( ERROR_MOD_NOT_FOUND );
            }

            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    
    return hr;
}

HRESULT
ISAPI_DLL::SetFastSid(
    IN PSID             pSid
)
{
    DBG_ASSERT( pSid != NULL );
    
    if ( GetLengthSid( pSid ) <= sizeof( m_abFastSid ) )
    {
        memcpy( m_abFastSid,
                pSid,
                GetLengthSid( pSid ) );
        
        m_pFastSid = m_abFastSid;
    }
    
    return NO_ERROR;
}

HRESULT
ISAPI_DLL::Load(
    IN HANDLE hImpersonation,
    IN PSID pSid
    )
{
    HRESULT             hr;
    HSE_VERSION_INFO    VersionInfo;

    DBG_ASSERT( CheckSignature() );

    //
    // Check to see if the dll is already loaded.
    // If so, just return NO_ERROR.
    //

    if ( m_fIsLoaded )
    {
        return NO_ERROR;
    }

    //
    // So the dll is not loaded.  Grab the lock and
    // check again (another thread may have snuck in between
    // the first test and now and already loaded it...
    //

    Lock();

    if ( !m_fIsLoaded )
    {
        //
        // Load the ACL for the dll file and do an access check
        // before loading the dll itself.  This is a slightly different
        // approach than what earlier versions of IIS did.  We are
        // not going to be actually doing impersonation at the time
        // we load the dll as earlier versions did.  As a result,
        // DllMain's DLL_PROCESS_ATTACH will run in the context of
        // the worker process primary token instead of as the
        // authenticated user.
        //
        // This new approach is the right way to do it, but it might
        // introduce an incompatibility with any extensions that implement
        // code in DllMain that depends on running as the authenticated
        // user.  It is very, very unlikely that we'll see this problem.
        // If we do, the solution is to impersonate the token before
        // calling LoadLibraryEx.
        //

        hr = LoadAcl( m_strAntiCanonModuleName );

        if ( FAILED( hr ) )
        {
            goto Failed;
        }

        if ( !AccessCheck( hImpersonation, 
                           pSid ) )
        {
            hr =  HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            goto Failed;
        }

        m_hModule = LoadLibraryEx( m_strAntiCanonModuleName.QueryStr(),
                                   NULL,
                                   LOAD_WITH_ALTERED_SEARCH_PATH
                                   );

        if ( m_hModule == NULL ) 
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        
            DBGPRINTF(( DBG_CONTEXT,
                       "[ISAPI_DLL::Load] LoadLibrary %S failed. Error %d\n",
                        m_strModuleName.QueryStr(),
                        GetLastError()
                        ));

            goto Failed;
        }
    
        //
        // Get the entry points
        //

        m_pfnGetExtensionVersion = 
            (PFN_GETEXTENSIONVERSION)GetProcAddress( m_hModule, 
                                                     "GetExtensionVersion" 
                                                     );

        m_pfnTerminateExtension = 
            (PFN_TERMINATEEXTENSION)GetProcAddress( m_hModule,
                                                    "TerminateExtension"
                                                    );

        m_pfnHttpExtensionProc = 
            (PFN_HTTPEXTENSIONPROC)GetProcAddress( m_hModule,
                                                   "HttpExtensionProc"
                                                   );
    
        //
        // HttpExtensionProc and GetExtensionVersion are required
        //

        if( !m_pfnGetExtensionVersion ||
            !m_pfnHttpExtensionProc )
        {
            hr = HRESULT_FROM_WIN32( ERROR_PROC_NOT_FOUND );

            //
            // Make sure we dont call TerminateExtension on
            // cleanup.
            //

            m_pfnTerminateExtension = NULL;

            goto Failed;
        }

        if( !m_pfnGetExtensionVersion( &VersionInfo ) )
        {
            hr = GetLastError() == ERROR_SUCCESS ?
                E_FAIL :
                HRESULT_FROM_WIN32( GetLastError() );

            goto Failed;
        }

        DBGPRINTF(( DBG_CONTEXT,
                    "ISAPI_DLL::Load() Loaded extension %S, "
                    " description \"%s\"\n",
                    m_strModuleName.QueryStr(),
                    VersionInfo.lpszExtensionDesc ));

        m_fIsLoaded = TRUE;
    }

    Unlock();
    
    return NO_ERROR;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    //
    // Clean up after the failed load attempt
    //

    if ( m_pfnHttpExtensionProc )
    {
        m_pfnHttpExtensionProc = NULL;
    }

    if ( m_pfnGetExtensionVersion )
    {
        m_pfnGetExtensionVersion = NULL;
    }

    if ( m_pfnTerminateExtension )
    {
        m_pfnTerminateExtension = NULL;
    }

    if ( m_hModule )
    {
        FreeLibrary( m_hModule );
        m_hModule = NULL;
    }

    Unlock();

    return hr;
}

VOID
ISAPI_DLL::Unload( VOID )
{
    if( m_pfnTerminateExtension )
    {
        m_pfnTerminateExtension( HSE_TERM_MUST_UNLOAD );
        m_pfnTerminateExtension = NULL;
    }

    m_pfnGetExtensionVersion = NULL;
    m_pfnHttpExtensionProc = NULL;

    if( m_hModule )
    {
        FreeLibrary( m_hModule );
    }
}

HRESULT
ISAPI_DLL::LoadAcl( STRU &strModuleName )
{
    DWORD cbSecDesc = m_buffSD.QuerySize();
    DWORD dwError;

    DBG_ASSERT( CheckSignature() );
    
    //
    //  Force an access check on the next request
    //

    while ( !GetFileSecurity( strModuleName.QueryStr(),
                              (OWNER_SECURITY_INFORMATION |
                               GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION),
                              m_buffSD.QueryPtr(),
                              m_buffSD.QuerySize(),
                              &cbSecDesc ))
    {
        if ( ( dwError = GetLastError() ) != ERROR_INSUFFICIENT_BUFFER )
        {
            return HRESULT_FROM_WIN32( dwError );
        }

        if ( !m_buffSD.Resize( cbSecDesc ) )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Hopefully, we have sufficient buffer now, retry
        //
    }

    return NOERROR;
}

BOOL
ISAPI_DLL::AccessCheck(
    IN HANDLE hImpersonation,
    IN PSID   pSid
    )
{
    BOOL          fRet = TRUE;
    DWORD         dwGrantedAccess;
    BYTE          PrivSet[400];
    DWORD         cbPrivilegeSet = sizeof(PrivSet);
    BOOL          fAccessGranted;

    DBG_ASSERT( CheckSignature() );

    //
    // First compare to the fast check SID if possible
    //
    
    if ( pSid != NULL && QueryFastSid() != NULL )
    {
        if ( EqualSid( pSid, QueryFastSid() ) )
        {
            return TRUE;
        }
    }

    //
    // Ok, just do the real access check
    //

    fRet = ( ::AccessCheck( QuerySecDesc(),
                            hImpersonation,
                            FILE_GENERIC_EXECUTE,
                            &g_FileGenericMapping,
                            (PRIVILEGE_SET *) &PrivSet,
                            &cbPrivilegeSet,
                            &dwGrantedAccess,
                            &fAccessGranted )
            && fAccessGranted);

    return fRet;
}

HRESULT
ISAPI_DLL_MANAGER::GetIsapi( 
    IN const WCHAR *    szModuleName,
    OUT ISAPI_DLL **    ppIsapiDll,
    IN HANDLE           hImpersonation,
    IN PSID             pSid
    )
{
    HRESULT     hr          = NOERROR;
    ISAPI_DLL * pIsapiDll   = NULL;
    LK_RETCODE  lkrc;

    IF_DEBUG( DLL_MANAGER )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "DllManager looking for %S.\r\n",
            szModuleName
            ));
    }

    //
    // Check for the ISAPI in the hash table.  If we don't
    // find it, then we'll need to create an entry in the
    // hash for it.
    //

    lkrc = m_IsapiHash.FindKey( szModuleName, &pIsapiDll );

    if ( lkrc == LK_SUCCESS )
    {
        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Found ISAPI_DLL %p (%S).\r\n",
                pIsapiDll,
                pIsapiDll->QueryModuleName()
                ));
        }
    }
    else
    {
        //
        // Create a new entry
        //

        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Creating new ISAPI_DLL object for %S.\r\n",
                szModuleName
                ));
        }

        pIsapiDll = new ISAPI_DLL;

        if ( !pIsapiDll )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Failed;
        }

        if ( FAILED( hr = pIsapiDll->SetName( szModuleName ) ) )
        {
            pIsapiDll->DereferenceIsapiDll();
            pIsapiDll = NULL;
            goto Failed;
        }
        
        //
        // Set fast access sid if available
        //
        
        if ( pSid != NULL )
        {
            hr = pIsapiDll->SetFastSid( pSid );
            if ( FAILED( hr ) )
            {
                pIsapiDll->DereferenceIsapiDll();
                pIsapiDll = NULL;
                goto Failed;
            }
        }

        //
        // Insert the new object into the hash table.  If someone
        // else beat us to it, then we'll just release our new one.
        //

        lkrc = m_IsapiHash.InsertRecord( pIsapiDll );

        if ( lkrc == LK_SUCCESS )
        {
            IF_DEBUG( DLL_MANAGER )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Added ISAPI_DLL %p to table for %S.\r\n",
                    pIsapiDll,
                    szModuleName
                    ));
            }
        }
        else
        {
            pIsapiDll->DereferenceIsapiDll();
            pIsapiDll = NULL;

            if ( lkrc == LK_KEY_EXISTS )
            {
                IF_DEBUG( DLL_MANAGER )
                {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "InsertRecord for %S returned LK_KEY_EXISTS.\r\n",
                        szModuleName
                        ));
                }

                //
                // Ok, so let's get the existing one
                //

                lkrc = m_IsapiHash.FindKey( szModuleName, &pIsapiDll );
            }

            if ( lkrc != LK_SUCCESS )
            {
                hr = HRESULT_FROM_WIN32( lkrc );
                goto Failed;
            }
        }
    }

    DBG_ASSERT( pIsapiDll );

    //
    // Call the Load function for the ISAPI_DLL.  Note that the ISAPI_DLL
    // function is smart enough to deal with locking on GetExtensionVersion
    // and in only allowing it to happen one time.
    //

    hr = pIsapiDll->Load( hImpersonation,
                          pSid );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    //
    // We've got the extension, but we still need to do
    // an access check to make sure that the client
    // is allowed to run it.
    //

    DBG_ASSERT( pIsapiDll );

    if ( !pIsapiDll->AccessCheck( hImpersonation, 
                                  pSid ) )
    {
        hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        goto Failed;
    }

    //
    // We're about to return successfully.  Set the out parameter now.
    //

    *ppIsapiDll = pIsapiDll;

    DBG_ASSERT( SUCCEEDED( hr ) );

    return hr;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    IF_DEBUG( ISAPI )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Error %d(0x%08x) occurred getting ISAPI_DLL object for %S.\r\n",
            hr,
            hr,
            szModuleName
            ));
    }

    if ( pIsapiDll )
    {
        pIsapiDll->DereferenceIsapiDll();
        pIsapiDll = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\dll_manager.h ===
/*++

   Copyright    (c)    2000-2001    Microsoft Corporation

   Module Name :
     dll_manager.h

   Abstract:
     IIS Plus ISAPI Handler. Dll management classes.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000
     Wade A. Hilmo (WadeH)              08-Mar-2001

   Project:
     w3isapi.dll

--*/

#ifndef _DLL_MANAGER_H_
#define _DLL_MANAGER_H_

#define ISAPI_DLL_SIGNATURE         (DWORD)'LDSI'
#define ISAPI_DLL_SIGNATURE_FREE    (DWORD)'fDSI'

/************************************************************
 *  Include Headers
 ************************************************************/

#include <lkrhash.h>
#include <reftrace.h>
#include <acache.hxx>

/************************************************************
 *  Declarations
 ************************************************************/

/*++

class ISAPI_DLL

    Encapsulate an ISAPI dll.

--*/

class ISAPI_DLL
{
    friend class ISAPI_DLL_MANAGER;

public:

    //
    // ACACHE and ref tracing goo
    //

    VOID * 
    operator new( 
        size_t            size
    )
    {
        DBG_ASSERT( size == sizeof( ISAPI_DLL ) );
        DBG_ASSERT( sm_pachIsapiDlls != NULL );
        return sm_pachIsapiDlls->Alloc();
    }
    
    VOID
    operator delete(
        VOID *              pIsapiDll
    )
    {
        DBG_ASSERT( pIsapiDll != NULL );
        DBG_ASSERT( sm_pachIsapiDlls != NULL );
        
        DBG_REQUIRE( sm_pachIsapiDlls->Free( pIsapiDll ) );
    }

    BOOL
    CheckSignature()
    {
        return ( m_Signature == ISAPI_DLL_SIGNATURE );
    }
    
    static
    HRESULT
    Initialize(
        VOID
    );
    
    static
    VOID
    Terminate(
        VOID
    );

    //
    // Construction and destruction
    //

    ISAPI_DLL()
        : m_nRefs(1),
          m_pfnGetExtensionVersion( NULL ),
          m_pfnTerminateExtension( NULL ),
          m_pfnHttpExtensionProc( NULL ),
          m_hModule( NULL ),
          m_pFastSid( NULL ),
          m_fIsLoaded( FALSE ),
          m_Signature( ISAPI_DLL_SIGNATURE )
    {
        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Created new ISAPI_DLL %p.\r\n",
                this
                ));
        }

        INITIALIZE_CRITICAL_SECTION( &m_csLock );
    }

    VOID
    ReferenceIsapiDll(
        VOID
        )
    {
        LONG nRefs;

        //
        // Don't go from 0 to 1 refs
        //

        DBG_ASSERT( m_nRefs != 0 );

        nRefs = InterlockedIncrement( &m_nRefs );

        if ( sm_pTraceLog != NULL )
        {
            WriteRefTraceLog( sm_pTraceLog, 
                              nRefs,
                              this );
        }
    }

    VOID
    DereferenceIsapiDll(
        VOID
        )
    {
        LONG    nRefs;

        nRefs = InterlockedDecrement( &m_nRefs );

        if ( sm_pTraceLog != NULL )
        {
            WriteRefTraceLog( sm_pTraceLog, 
                              nRefs,
                              this );
        }

        if ( nRefs == 0 )
        {
            delete this;
        }
    }

    HRESULT
    SetName(
        const WCHAR *szModuleName
        );

    HRESULT
    Load(
        IN HANDLE hImpersonation,
        IN PSID pSid
        );

    HRESULT
    SetFastSid(
        IN PSID pSid
    );

    PSID
    QueryFastSid(
        VOID
    ) const
    {
        return m_pFastSid;
    }

    //
    // Accessors
    //

    const WCHAR * 
    QueryModuleName( VOID ) const
    { 
        return m_strModuleName.QueryStr();
    }

    PFN_GETEXTENSIONVERSION
    QueryGetExtensionVersion( VOID ) const
    {
        return m_pfnGetExtensionVersion;
    }

    PFN_TERMINATEEXTENSION
    QueryTerminateExtension( VOID ) const
    {
        return m_pfnTerminateExtension;
    }

    PFN_HTTPEXTENSIONPROC
    QueryHttpExtensionProc( VOID ) const
    {
        return m_pfnHttpExtensionProc;
    }

    BOOL
    IsMatch(
        IN const WCHAR *    szModuleName
    )
    {
        return (_wcsicmp( szModuleName, m_strModuleName.QueryStr() ) == 0);
    }

    PSECURITY_DESCRIPTOR
    QuerySecDesc( VOID ) const
    {
        return (PSECURITY_DESCRIPTOR) m_buffSD.QueryPtr(); 
    }

    BOOL
    AccessCheck(
        IN HANDLE hImpersonation,
        IN PSID   pSid
        );

private:
    
    //
    // Avoid c++ errors
    //

    ISAPI_DLL( const ISAPI_DLL & ) {}
    ISAPI_DLL & operator = ( const ISAPI_DLL & ) { return *this; }

    ~ISAPI_DLL()
    {
        DBG_ASSERT( CheckSignature() );
        m_Signature = ISAPI_DLL_SIGNATURE_FREE;

        //
        // If this gets moved then we need to alter
        // cleanup paths during load.
        //

        Unload();

        DeleteCriticalSection( &m_csLock );

        IF_DEBUG( DLL_MANAGER )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Deleted ISAPI_DLL %p.\r\n",
                this
                ));
        }
    }

    VOID
    Unload( VOID );

    DWORD    m_Signature;
    LONG     m_nRefs;
    STRU     m_strModuleName;
    STRU     m_strAntiCanonModuleName;

    CRITICAL_SECTION m_csLock;

    volatile BOOL    m_fIsLoaded;

    static PTRACE_LOG               sm_pTraceLog;
    static ALLOC_CACHE_HANDLER *    sm_pachIsapiDlls;

    //
    // ISAPI Entry Points
    //
    PFN_GETEXTENSIONVERSION     m_pfnGetExtensionVersion;
    PFN_TERMINATEEXTENSION      m_pfnTerminateExtension;
    PFN_HTTPEXTENSIONPROC       m_pfnHttpExtensionProc;    

    //
    // Security members
    //
    HMODULE         m_hModule;
    BUFFER          m_buffSD;

    //
    // Fast check sid (the SID of the user which originally accessed DLL)
    //

    PSID            m_pFastSid;
    BYTE            m_abFastSid[ 64 ];

    HRESULT LoadAcl( STRU &strModuleName );

    VOID
    Lock( VOID )
    {
        EnterCriticalSection( &m_csLock );
    }

    VOID
    Unlock( VOID )
    {
        LeaveCriticalSection( &m_csLock );
    }
};

//
// Hash Table for ISAPI extension lookup
//

class ISAPI_DLL_HASH
    : public CTypedHashTable<
            ISAPI_DLL_HASH,
            ISAPI_DLL,
            LPCWSTR
            >
{
public:
    ISAPI_DLL_HASH()
        : CTypedHashTable< ISAPI_DLL_HASH, 
                           ISAPI_DLL, 
                           LPCWSTR > ( "ISAPI_DLL_HASH" )
    {
    }
    
    static 
    LPCWSTR
    ExtractKey(
        const ISAPI_DLL *      pEntry
    )
    {
        return pEntry->QueryModuleName();
    }
    
    static
    DWORD
    CalcKeyHash(
        LPCWSTR              pszKey
    )
    {
        int cchKey = wcslen(pszKey);

        return HashStringNoCase(pszKey, cchKey);
    }
     
    static
    bool
    EqualKeys(
        LPCWSTR               pszKey1,
        LPCWSTR               pszKey2
    )
    {
        return _wcsicmp( pszKey1, pszKey2 ) == 0;
    }
    
    static
    void
    AddRefRecord(
        ISAPI_DLL * pEntry,
        int         nIncr
        )
    {
        if ( nIncr == +1 )
        {
            pEntry->ReferenceIsapiDll();
        }
        else if ( nIncr == - 1)
        {
            pEntry->DereferenceIsapiDll();
        }
    }
};

class ISAPI_DLL_MANAGER
{
public:

    ISAPI_DLL_MANAGER()
    {
    }

    ~ISAPI_DLL_MANAGER()
    {
    }

    HRESULT
    GetIsapi( 
        IN const WCHAR *   szModuleName,
        OUT ISAPI_DLL **   ppIsapiDll,
        IN HANDLE          hImpersonation,
        IN PSID            pSid
        );

private:
    
    //
    // Avoid c++ errors
    //
    ISAPI_DLL_MANAGER( const ISAPI_DLL_MANAGER & ) {}
    ISAPI_DLL_MANAGER & operator = ( const ISAPI_DLL_MANAGER & ) { return *this; }

    ISAPI_DLL_HASH      m_IsapiHash;
};

extern ISAPI_DLL_MANAGER * g_pDllManager;

#endif // _DLL_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\isapi_context.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module Name : isapi_context.cxx

   Abstract: IIS ISAPI request context
 
   Author: Wade A. Hilmo (wadeh)        14-Mar-2001

   Project: w3isapi.dll

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "isapi_context.hxx"

PTRACE_LOG              ISAPI_CONTEXT::sm_pTraceLog;
ALLOC_CACHE_HANDLER *   ISAPI_CONTEXT::sm_pachIsapiContexts;

/************************************************************
 *  Implementation
 ************************************************************/

//static
HRESULT
ISAPI_CONTEXT::Initialize(
    VOID
    )
/*++

Routine Description:

    Static initialization for the ISAPI_CONTEXT object.  This
    function sets up the static members needed for acache.

Arguments:

    None
  
Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    
#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

    //
    // Initialize a lookaside for this structure
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ISAPI_CONTEXT );

    DBG_ASSERT( sm_pachIsapiContexts == NULL );
    
    sm_pachIsapiContexts = new ALLOC_CACHE_HANDLER( "ISAPI_CONTEXT",  
                                                    &acConfig );

    if ( sm_pachIsapiContexts == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return NO_ERROR;
}

//static
VOID
ISAPI_CONTEXT::Terminate(
    VOID
    )
/*++

Routine Description:

    Static uninitialization for the ISAPI_CONTEXT object.  This
    function cleans up the static members needed for acache.

Arguments:

    None
  
Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }
    
    if ( sm_pachIsapiContexts != NULL )
    {
        delete sm_pachIsapiContexts;
        sm_pachIsapiContexts = NULL;
    }
}

ISAPI_CONTEXT::ISAPI_CONTEXT(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    ISAPI_DLL *         pIsapiDll
    )
    : _pIsapiCore( pIsapiCore ),
      _pCoreData( pCoreData ),
      _pIsapiDll( pIsapiDll ),
      _cRefs(1),
      _fClientWantsKeepConn( FALSE ),
      _fDoKeepConn( FALSE ),
      _AsyncPending( NoAsyncIoPending ),
      _cbLastAsyncIo( 0 ),
      _pfnHseIoCompletion( NULL ),
      _pvHseIoContext( NULL ),
      _pvAsyncIoBuffer( NULL ),
      _pComContext( NULL ),
      _pComInitsCookie( NULL )
/*++

Routine Description:

    Constructor

Arguments:

    pIsapiCore - Interface to call into the IIS core for this request
    pCoreData  - The core data for this request
    pIsapiDll  - The ISAPI_DLL object associated with this request
  
Return Value:

    None

--*/
{
    DBG_ASSERT( pIsapiCore );
    DBG_ASSERT( pCoreData );
    DBG_ASSERT( pIsapiDll );

    //
    // Take a reference on the ISAPI core interface and
    // the ISAPI dll for the lifetime of this object.
    //

    _pIsapiCore->AddRef();
    _pIsapiDll->ReferenceIsapiDll();

    //
    // Initialize the ECB.  Note that the caller needs to
    // populate the WriteClient, ReadClient, GetServerVariable
    // and ServerSupportFunction members.
    //
    // Note that the ECB cbSize member doubles as the signature
    // for the ISAPI_CONTEXT.  So, it should be the first thing set
    // at construction.
    //

    _ECB.cbSize = sizeof( EXTENSION_CONTROL_BLOCK );
    _ECB.ConnID = this;
    _ECB.dwVersion = HSE_VERSION;
    _ECB.dwHttpStatusCode = 200;
    _ECB.cbTotalBytes = _pCoreData->dwContentLength;
    _ECB.cbAvailable = _pCoreData->cbAvailableEntity;
    _ECB.lpbData = (PBYTE) _pCoreData->pAvailableEntity;
    _ECB.lpszMethod = _pCoreData->szMethod;
    _ECB.lpszQueryString = _pCoreData->szQueryString;
    _ECB.lpszPathInfo = _pCoreData->szPathInfo;
    _ECB.lpszPathTranslated = _pCoreData->szPathTranslated;
    _ECB.lpszContentType = _pCoreData->szContentType;

    //
    // Inspect the HTTP version and connection header to
    // determine if the client is asking us to keep the
    // connection open at the conclusion of this request
    //
    // By default, we assume that the client wants us to
    // close the connection.  If the client sends us an
    // HTTP/1.x version, we will look for keep-alive
    // possibilities.
    //
    // Note that regardless of what the client wants, we will
    // close the connection by default.  The extension will
    // need to do something to cause us to change this stance.
    //

    if ( _pCoreData->dwVersionMajor == 1 )
    {
        if ( _pCoreData->dwVersionMinor == 0 )
        {
            //
            // The client is HTTP/1.0 - the presence of a
            // "connection: keep-alive" header indicates the
            // client wants to keep the connection open, else
            // the connection should close.
            //

            _fClientWantsKeepConn = 
                !( _stricmp( _pCoreData->szConnection, "keep-alive" ) );
        }
        else
        {
            //
            // The client is HTTP/1.x, where x is not 0. We
            // will assume that any 1.1+ version of HTTP uses
            // HTTP/1.1 semantics.  This means that the client
            // wants to keep the connection open unless a
            // "connection: close" header is present.
            //

            _fClientWantsKeepConn = 
                !!(_stricmp( _pCoreData->szConnection, "close" ) );
        }
    }
}

ISAPI_CONTEXT::~ISAPI_CONTEXT()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE  hToken = NULL;
    BOOL    fIsOop = FALSE;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pIsapiCore );

    //
    // The ECB cbSize member doubles as the signature.  Strange
    // but true.
    //

    _ECB.cbSize = ISAPI_CONTEXT_SIGNATURE_FREE;

    //
    // If this request is OOP, then delete the local copy of the core data
    //

    if ( _pCoreData->fIsOop )
    {
        fIsOop = TRUE;

        DBG_ASSERT( _pCoreData->hToken );
        CloseHandle( _pCoreData->hToken );

        DBG_ASSERT( _pCoreData );
        LocalFree( _pCoreData );
        _pCoreData = NULL;
    }

    //
    // Release the ISAPI_DLL and ISAPI core interface.  Note that
    // the _pIsapiCore->Release call will be going through RPC in
    // the OOP case.  We'll need to temporarily remove any impersonation
    // token for the duration of the Release call.
    //

    _pIsapiDll->DereferenceIsapiDll();

    if ( fIsOop )
    {
        if ( OpenThreadToken( GetCurrentThread(),
                              TOKEN_IMPERSONATE,
                              TRUE,
                              &hToken ) )
        {
            DBG_ASSERT( hToken );
            DBG_REQUIRE( RevertToSelf() );
        }
    }

    _pIsapiCore->Release();

    if ( hToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, hToken ) );
        DBG_REQUIRE( CloseHandle( hToken ) );
    }

    hToken = NULL;
}

VOID
ISAPI_CONTEXT::ReferenceIsapiContext(
    VOID
    )
/*++

Routine Description:

    Adds a reference to an ISAPI_CONTEXT object

Arguments:

    None
  
Return Value:

    None

--*/
{
    LONG    cRefs;

    cRefs = InterlockedIncrement( &_cRefs );

    //
    // Do ref tracing if configured
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    //
    // Going from zero to 1 is a bad thing
    //

    DBG_ASSERT( cRefs > 1 );

    return;
}

VOID
ISAPI_CONTEXT::DereferenceIsapiContext(
    VOID
    )
/*++

Routine Description:

    Removes a reference from an ISAPI_CONTEXT object.
    The object is deleted when the last reference is
    removed.

Arguments:

    None
  
Return Value:

    None

--*/
{
    LONG cRefs;

    cRefs = InterlockedDecrement( &_cRefs );

    //
    // Do ref tracing if configured
    //

    if ( sm_pTraceLog != NULL )
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }

    if ( cRefs == 0 )
    {
        delete this;
    }

    return;
}

BOOL
ISAPI_CONTEXT::TryInitAsyncIo(
    ASYNC_PENDING   IoType
    )
/*++

Routine Description:

    Sets up the ISAPI_CONTEXT for an asynchronous operation.
    The function also does error checking to ensure that only
    one asynchronous operation can exist for a given request.

Arguments:

    IoType - The type of asynchronous operation setting up
  
Return Value:

    TRUE if successful, FALSE if asynchronous operation should
    not be allowed

--*/
{
    BOOL            fResult;
    ASYNC_PENDING   OldAsyncFlag;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( IoType != NoAsyncIoPending );

    OldAsyncFlag = static_cast<ASYNC_PENDING>( InterlockedCompareExchange(
        (LPLONG)&_AsyncPending,
        IoType,
        NoAsyncIoPending
        ) );

    if ( OldAsyncFlag != NoAsyncIoPending )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    ReferenceIsapiContext();

    return TRUE;
}

ASYNC_PENDING
ISAPI_CONTEXT::UninitAsyncIo(
    VOID
    )
/*++

Routine Description:

    Cleans up after an asynchronous operation

Arguments:

    None
  
Return Value:

    The type of IO that was uninitialized

--*/
{
    ASYNC_PENDING   IoType;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _AsyncPending != NoAsyncIoPending );

    IoType = _AsyncPending;
    _AsyncPending = NoAsyncIoPending;

    DereferenceIsapiContext();

    return IoType;
}

VOID
ISAPI_CONTEXT::IsapiDoRevertHack(
    HANDLE *    phToken,
    BOOL        fForce
    )
/*++

Routine Description:

    Ensures that the calling thread is running with no impersonation
    token.  If an impersonation token existed, its value is returned
    to the caller.

    Note that we generally want to do this only for OOP requests (to
    prevent RPC from caching the impersonation token).

Arguments:

    phToken - Upon return, contains the value of any impersonation
              token removed from the thread.  If no impersonation
              token is removed, this contains NULL on return
    fForce  - If TRUE, don't do the revert hack even in the
              inproc case.
  
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( phToken );

    //
    // Init token to NULL, in case we fail
    //

    *phToken = NULL;

    if ( QueryIsOop() == FALSE  &&
         fForce == FALSE )
    {
        return;
    }

    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken ) )
    {
        DBG_ASSERT( *phToken );
        DBG_REQUIRE( RevertToSelf() );
    }

    return;
}

VOID
ISAPI_CONTEXT::IsapiUndoRevertHack(
    HANDLE *    phToken
    )
/*++

Routine Description:

    Restores an impersonation token after IsapiDoRevertHack

Arguments:

    phToken         - Pointer to token to restore
  
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( phToken );

    if ( *phToken != NULL )
    {
        DBG_REQUIRE( SetThreadToken( NULL, *phToken ) );
        DBG_REQUIRE( CloseHandle( *phToken ) );
    }

    *phToken = NULL;

    return;
}

BOOL
ISAPI_CONTEXT::GetOopServerVariableByIndex
(
    SERVER_VARIABLE_INDEX   Index,
    LPVOID                  lpvBuffer,
    LPDWORD                 lpdwSize
)
{
    CHAR    szTemp[64];
    LPVOID  pData;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cbBuffer;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( _pCoreData );
    DBG_ASSERT( QueryIsOop() );
    DBG_ASSERT( lpdwSize );
    DBG_ASSERT( lpvBuffer != NULL || *lpdwSize == 0 );

    cbBuffer = *lpdwSize;

    //
    // Get the value for the specified server variable
    //

    switch ( Index )
    {
    case ServerVariableApplMdPath:

        *lpdwSize = _pCoreData->cbApplMdPath;
        pData = _pCoreData->szApplMdPath;

        break;

    case ServerVariableUnicodeApplMdPath:

        *lpdwSize = _pCoreData->cbApplMdPathW;
        pData = _pCoreData->szApplMdPathW;

        break;

    case ServerVariableContentLength:

        sprintf( szTemp, "%d", _pCoreData->dwContentLength );

        *lpdwSize = strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableContentType:

        *lpdwSize = _pCoreData->cbContentType;
        pData = _pCoreData->szContentType;

        break;

    case ServerVariableInstanceId:

        sprintf( szTemp, "%d", _pCoreData->dwInstanceId );

        *lpdwSize = strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariablePathInfo:

        *lpdwSize = _pCoreData->cbPathInfo;
        pData = _pCoreData->szPathInfo;

        break;

    case ServerVariablePathTranslated:

        *lpdwSize = _pCoreData->cbPathTranslated;
        pData = _pCoreData->szPathTranslated;

        break;

    case ServerVariableUnicodePathTranslated:

        *lpdwSize = _pCoreData->cbPathTranslatedW;
        pData = _pCoreData->szPathTranslatedW;

        break;

    case ServerVariableQueryString:

        *lpdwSize = _pCoreData->cbQueryString;
        pData = _pCoreData->szQueryString;

        break;

    case ServerVariableRequestMethod:
    case ServerVariableHttpMethod:

        *lpdwSize = _pCoreData->cbMethod;
        pData = _pCoreData->szMethod;

        break;

    case ServerVariableServerPortSecure:

        sprintf( szTemp, "%d", _pCoreData->fSecure ? 1 : 0 );

        *lpdwSize = strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableServerProtocol:
    case ServerVariableHttpVersion:

        sprintf( szTemp, "HTTP/%d.%d", _pCoreData->dwVersionMajor, _pCoreData->dwVersionMinor );

        *lpdwSize = strlen( szTemp ) + 1;
        pData = szTemp;

        break;

    case ServerVariableHttpCookie:

        *lpdwSize = _pCoreData->cbCookie;
        pData = _pCoreData->szCookie;

        break;

    case ServerVariableHttpConnection:

        *lpdwSize = _pCoreData->cbConnection;
        pData = _pCoreData->szConnection;

        break;

    default:

        SetLastError( ERROR_INVALID_INDEX );
        return FALSE;
    }

    if ( cbBuffer < *lpdwSize )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    memcpy( lpvBuffer, pData, *lpdwSize );

    return TRUE;
}

SERVER_VARIABLE_INDEX
LookupServerVariableIndex(
    LPSTR   szServerVariable
    )
{
    //
    // Simple parameter checking...
    //

    if ( szServerVariable == NULL )
    {
        return ServerVariableExternal;
    }

    //
    // Look up the string passed in and see if it matches
    // one of the server variables that's known to be available
    // from ISAPI_CORE_DATA.
    //
    // Note that we only do this in the OOP case, so the cost of
    // failing to match up is trivial compared to the RPC call
    // that'll result.
    //

    switch ( szServerVariable[0] )
    {
    case 'A':

        if ( strcmp( szServerVariable, "APPL_MD_PATH" ) == 0 )
        {
            return ServerVariableApplMdPath;
        }

        break;

    case 'U':

        if ( strcmp( szServerVariable, "UNICODE_APPL_MD_PATH" ) == 0 )
        {
            return ServerVariableUnicodeApplMdPath;
        }

        if ( strcmp( szServerVariable, "UNICODE_PATH_TRANSLATED" ) == 0 )
        {
            return ServerVariableUnicodePathTranslated;
        }

        break;

    case 'C':

        if ( strcmp( szServerVariable, "CONTENT_LENGTH" ) == 0 )
        {
            return ServerVariableContentLength;
        }

        if ( strcmp( szServerVariable, "CONTENT_TYPE" ) == 0 )
        {
            return ServerVariableContentType;
        }

        break;

    case 'I':

        if ( strcmp( szServerVariable, "INSTANCE_ID" ) == 0 )
        {
            return ServerVariableInstanceId;
        }

        break;

    case 'P':

        if ( strcmp( szServerVariable, "PATH_INFO" ) == 0 )
        {
            return ServerVariablePathInfo;
        }

        if ( strcmp( szServerVariable, "PATH_TRANSLATED" ) == 0 )
        {
            return ServerVariablePathTranslated;
        }

    case 'Q':

        if ( strcmp( szServerVariable, "QUERY_STRING" ) == 0 )
        {
            return ServerVariableQueryString;
        }

        break;

    case 'R':

        if ( strcmp( szServerVariable, "REQUEST_METHOD" ) == 0 )
        {
            return ServerVariableRequestMethod;
        }

        break;

    case 'S':

        if ( strcmp( szServerVariable, "SERVER_PORT_SECURE" ) == 0 )
        {
            return ServerVariableServerPortSecure;
        }

        if ( strcmp( szServerVariable, "SERVER_PROTOCOL" ) == 0 )
        {
            return ServerVariableServerProtocol;
        }

        break;

    case 'H':

        if ( strcmp( szServerVariable, "HTTP_COOKIE" ) == 0 )
        {
            return ServerVariableHttpCookie;
        }

        if ( strcmp( szServerVariable, "HTTP_CONNECTION" ) == 0 )
        {
            return ServerVariableHttpConnection;
        }

        if ( strcmp( szServerVariable, "HTTP_METHOD" ) == 0 )
        {
            return ServerVariableHttpMethod;
        }

        if ( strcmp( szServerVariable, "HTTP_VERSION" ) == 0 )
        {
            return ServerVariableHttpVersion;
        }

        break;

    default:

        break;
    }

    return ServerVariableExternal;
}

HRESULT
ISAPI_CONTEXT::SetComStateForOop(
    VOID
    )
{
    HRESULT hr = NOERROR;

    DBG_ASSERT( QueryIsOop() );
    DBG_ASSERT( _pComInitsCookie == NULL );
    DBG_ASSERT( _pComContext == NULL );

    if( QueryIsOop() )
    {    
        hr = CoGetCallContext(
            IID_IComDispatchInfo,
            (void **)&_pComContext
            );


        if( SUCCEEDED(hr) ) 
        {
            hr = _pComContext->EnableComInits( &_pComInitsCookie );
        }
    }

    return hr;
}

VOID
ISAPI_CONTEXT::RestoreComStateForOop(
    VOID
    )
{
    DBG_ASSERT( QueryIsOop() );

    if( _pComContext ) 
    {
        DBG_ASSERT( _pComInitsCookie );

        _pComContext->DisableComInits( _pComInitsCookie );
        _pComContext->Release();

        _pComContext = NULL;
        _pComInitsCookie = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3isapi\w3isapi.cxx ===
/*++

   Copyright    (c)    1999-2001    Microsoft Corporation

   Module Name :
     w3isapi.cxx

   Abstract:
     IIS Plus ISAPI Handler
 
   Author:
     Wade Hilmo (WadeH)                 03-Feb-2000

   Project:
     w3isapi.dll

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "isapi_context.hxx"
#include "server_support.hxx"

/************************************************************
 * Globals
 ************************************************************/

CHAR    g_szClsid[SIZE_CLSID_STRING];
CHAR    g_szIsapiHandlerInstance[SIZE_CLSID_STRING];
DWORD   g_dwPidW3Core;

/************************************************************
 *  Declarations
 ************************************************************/

BOOL
WINAPI
GetServerVariable(
    HCONN       hConn,
    LPSTR       lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize
    );

BOOL
WINAPI
WriteClient(
    HCONN      ConnID,
    LPVOID     Buffer,
    LPDWORD    lpdwBytes,
    DWORD      dwReserved
    );

BOOL
WINAPI
ReadClient(
    HCONN      ConnID,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize
    );

BOOL
WINAPI
ServerSupportFunction(
    HCONN      hConn,
    DWORD      dwHSERequest,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize,
    LPDWORD    lpdwDataType
    );

HRESULT
ProcessIsapiRequest(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    DWORD *             pHseResult
    );

HRESULT
ProcessIsapiCompletion(
    VOID *  pContext,
    DWORD   cbCompletion,
    DWORD   dwCompletionStatus
    );

HRESULT
InitModule(
    LPCSTR  szClsid,
    LPCSTR  szIsapiHandlerInstance,
    DWORD   dwPidW3Core
    );

VOID
TerminateModule( VOID );

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\w3isapi";


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

/************************************************************
 *  Type Definitions  
 ************************************************************/


HRESULT
InitModule(
    LPCSTR  szClsid,
    LPCSTR  szIsapiHandlerInstance,
    DWORD   dwPidW3Core
    )
/*++

Routine Description:

    Initializes the w3isapi module

Arguments:

    szClsid                - In the OOP case, this is the CLSID of
                             the application being hosted.  This
                             value may be NULL (ie. in the case of
                             inproc ISAPI).
    szIsapiHandlerInstance - The instance ID of the ISAPI handler
                             that's initializing this module.
    dwPidW3Core            - The PID of the process containing the
                             core server that's responsible for this
                             module
  
Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    CREATE_DEBUG_PRINT_OBJECT("w3isapi");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    DBGPRINTF((
        DBG_CONTEXT,
        "Initializing w3isapi.dll - CLSID: %s, "
        "ISAPI Handler: %s, W3Core PID %d.\r\n",
        szClsid ? szClsid : "NULL",
        szIsapiHandlerInstance,
        dwPidW3Core
        ));

    //
    // If g_pDllManager is not NULL at this point, then
    // this module is being intialized multiple times.  This
    // is an unexpected state.
    //

    if ( g_pDllManager != NULL )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Warning - w3isapi.dll previously initalized.\r\n"
            "Previous CLSID: %s, Previous ISAPI Handler: %s, "
            "Previous W3Core PID: %d.\r\n",
            g_szClsid,
            g_szIsapiHandlerInstance,
            g_dwPidW3Core
            ));

        DBG_ASSERT( FALSE && "w3isapi.dll previously initialized." );
    }

    g_pDllManager = new ISAPI_DLL_MANAGER();

    if( g_pDllManager == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    
    hr = ISAPI_CONTEXT::Initialize();

    if ( FAILED( hr ) ) 
    {
        delete g_pDllManager;
        g_pDllManager = NULL;
    }

    hr = ISAPI_DLL::Initialize();

    if ( FAILED( hr ) )
    {
        delete g_pDllManager;
        g_pDllManager = NULL;

        ISAPI_CONTEXT::Terminate();
    }

    //
    // If we've successfully initialized, then store
    // the information from the caller so that we can
    // debug double initializations.
    //

    if ( SUCCEEDED( hr ) )
    {
        if ( szClsid )
        {
            strncpy(
                g_szClsid,
                szClsid,
                SIZE_CLSID_STRING
                );

            g_szClsid[SIZE_CLSID_STRING - 1] = '\0';
        }
        else
        {
            strcpy( g_szClsid, "NULL" );
        }

        strncpy(
            g_szIsapiHandlerInstance,
            szIsapiHandlerInstance,
            SIZE_CLSID_STRING
            );

        g_szIsapiHandlerInstance[SIZE_CLSID_STRING - 1] = '\0';

        g_dwPidW3Core = dwPidW3Core;
    }

    return hr;
}

VOID
TerminateModule( VOID )
/*++

Routine Description:

    Terminates the w3isapi module

Arguments:

    None
  
Return Value:

    None

--*/
{
    ISAPI_CONTEXT::Terminate();

    DBG_ASSERT( g_pDllManager );

    if( g_pDllManager )
    {
        delete g_pDllManager;
        g_pDllManager = NULL;
    }

    ISAPI_DLL::Terminate();

    DELETE_DEBUG_PRINT_OBJECT();
}

HRESULT
ProcessIsapiRequest(
    IIsapiCore *        pIsapiCore,
    ISAPI_CORE_DATA *   pCoreData,
    DWORD *             pHseResult
    )
/*++

Routine Description:

    Processes an ISAPI request

Arguments:

    pIsapiCore - The interface that provides connectivity to the core server
    pCoreData  - The core data that describes the request
    pHseResult - Upon return, contains the return code from
                 the extension's HttpExtensionProc
  
Return Value:

    HRESULT

--*/
{
    ISAPI_DLL *                 pIsapiDll = NULL;
    DWORD                       dwIsapiReturn = HSE_STATUS_ERROR;
    ISAPI_CONTEXT *             pIsapiContext = NULL;
    PFN_HTTPEXTENSIONPROC       pfnHttpExtensionProc;
    EXTENSION_CONTROL_BLOCK *   pEcb = NULL;
    HRESULT                     hr = NO_ERROR;
    ISAPI_CORE_DATA *           pTempCoreData = NULL;
    
    DBG_ASSERT( g_pDllManager );

    //
    // This function is only called by w3core.dll
    //

    DBG_ASSERT( pIsapiCore );
    DBG_ASSERT( pCoreData );
    DBG_ASSERT( pHseResult );

    //
    // If this request is running OOP, then make a local copy
    // and fix up the core data internal pointers.
    //

    if ( pCoreData->fIsOop )
    {
        pTempCoreData = (ISAPI_CORE_DATA*) LocalAlloc( LPTR, pCoreData->cbSize );

        if ( !pTempCoreData )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            goto Failed;
        }

        memcpy( pTempCoreData, pCoreData, pCoreData->cbSize );

        //
        // All the extra data begins right at the end of pCoreData, start
        // pointing there
        //

        pTempCoreData->szGatewayImage = (LPWSTR)(pTempCoreData + 1);
        pTempCoreData->szApplMdPathW = (LPWSTR)((LPSTR)pTempCoreData->szGatewayImage + pTempCoreData->cbGatewayImage);
        pTempCoreData->szPathTranslatedW = (LPWSTR)((LPSTR)pTempCoreData->szApplMdPathW + pTempCoreData->cbApplMdPathW);
        pTempCoreData->szPhysicalPath = (LPSTR)pTempCoreData->szPathTranslatedW + pTempCoreData->cbPathTranslatedW;
        pTempCoreData->szPathInfo = pTempCoreData->szPhysicalPath + pTempCoreData->cbPhysicalPath;
        pTempCoreData->szMethod = pTempCoreData->szPathInfo + pTempCoreData->cbPathInfo;
        pTempCoreData->szQueryString = pTempCoreData->szMethod + pTempCoreData->cbMethod;
        pTempCoreData->szPathTranslated = pTempCoreData->szQueryString + pTempCoreData->cbQueryString;
        pTempCoreData->szContentType = pTempCoreData->szPathTranslated + pTempCoreData->cbPathTranslated;
        pTempCoreData->szConnection = pTempCoreData->szContentType + pTempCoreData->cbContentType;
        pTempCoreData->szUserAgent = pTempCoreData->szConnection + pTempCoreData->cbConnection;
        pTempCoreData->szCookie = pTempCoreData->szUserAgent + pTempCoreData->cbUserAgent;
        pTempCoreData->szApplMdPath = pTempCoreData->szCookie + pTempCoreData->cbCookie;

        if ( pTempCoreData->cbAvailableEntity )
        {
            pTempCoreData->pAvailableEntity = pTempCoreData->szApplMdPath + pTempCoreData->cbApplMdPath;
        }
        else
        {
            pTempCoreData->pAvailableEntity = NULL;
        }

        //
        // We'll set pCoreData to point to our temp one.  This
        // doesn't leak because the ISAPI_CONTEXT destructor is smart
        // enough to know it needs to be deleted in the OOP case.
        //

        pCoreData = pTempCoreData;
    }

    //
    // Get the entry point for the ISAPI
    //

    hr = g_pDllManager->GetIsapi(
        pCoreData->szGatewayImage,
        &pIsapiDll,
        pCoreData->hToken,
        pCoreData->pSid
        );

    if ( FAILED( hr ) )
    {
        goto Failed;
    }

    //
    // Construct the ISAPI_CONTEXT for this request.  Once it's
    // allocated, it owns the lifetime of the ISAPI_REQUEST.  When
    // the ISAPI_CONTEXT is deallocated, it may release the final
    // reference.
    //

    pIsapiContext = new ISAPI_CONTEXT( pIsapiCore, pCoreData, pIsapiDll );

    if ( pIsapiContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError () );
        goto Failed;
    }

    //
    // Set the ECB
    //

    pEcb = pIsapiContext->QueryECB();

    //
    // Set the ECB function pointers
    //

    pEcb->GetServerVariable = GetServerVariable;
    pEcb->WriteClient = WriteClient;
    pEcb->ReadClient = ReadClient;
    pEcb->ServerSupportFunction = ServerSupportFunction;

    //
    // Get the extension's entry point
    //
    
    pfnHttpExtensionProc = pIsapiDll->QueryHttpExtensionProc();

    //
    // If we are running OOP, set the COM state so that the
    // extension can CoInitialize/CoUninitialize.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        hr = pIsapiContext->SetComStateForOop();

        DBG_ASSERT( SUCCEEDED( hr ) );
    }

    //
    // Impersonate the authenticated user and call it
    //

    if ( !SetThreadToken( NULL, pIsapiContext->QueryToken() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Failed;
    }

    pIsapiContext->ReferenceIsapiContext();
    dwIsapiReturn = pfnHttpExtensionProc( pEcb );

    DBG_REQUIRE( RevertToSelf() );

    if ( pIsapiContext->QueryIsOop() )
    {
        pIsapiContext->RestoreComStateForOop();
    }

    pIsapiContext->DereferenceIsapiContext();

    switch ( dwIsapiReturn )
    {
        case HSE_STATUS_PENDING:

            //
            // Don't dereference the ISAPI_CONTEXT.  This
            // will guarantee that it lives on beyond the
            // return from this function.
            //

            break;


        case HSE_STATUS_SUCCESS_AND_KEEP_CONN:

            //
            // Special case of success.  The extension wants
            // to keep the connection open, even though we may
            // not have detected proper response headers.
            //
            // After setting the disconnect mode, fall through.
            //

            if ( pIsapiContext->QueryClientKeepConn() )
            {
                pIsapiContext->SetKeepConn( TRUE );
                pIsapiCore->SetConnectionClose( FALSE );
            }

        case HSE_STATUS_ERROR:
        case HSE_STATUS_SUCCESS:
        default:

            pIsapiContext->DereferenceIsapiContext();

            break;
    }

    *pHseResult = dwIsapiReturn;

    pIsapiDll->DereferenceIsapiDll();
    pIsapiDll = NULL;

    return NO_ERROR;

Failed:

    DBG_ASSERT( FAILED( hr ) );

    if ( pIsapiContext )
    {
        pIsapiContext->DereferenceIsapiContext();
        pIsapiContext = NULL;
    }
    else
    {
        //
        // In OOP case, we're depending on the ISAPI_CONTEXT destructor
        // to free the copy of the core data and close the impersonation
        // token.  If we weren't able to allocate one, we'll have to
        // do it here.
        //

        if ( pCoreData->fIsOop )
        {
            CloseHandle( pCoreData->hToken );

            if ( pTempCoreData )
            {
                LocalFree( pTempCoreData );
                pTempCoreData = NULL;
            }
        }
    }

    if ( pIsapiDll )
    {
        pIsapiDll->DereferenceIsapiDll();
        pIsapiDll = NULL;
    }

    return hr;
}

HRESULT
ProcessIsapiCompletion(
    DWORD64 IsaContext,
    DWORD   cbCompletion,
    DWORD   dwCompletionStatus
    )
/*++

Routine Description:

    Processes an I/O completion for an ISAPI extension

Arguments:

    IsaContext         - The ISAPI_CONTEXT for this completion
    cbCompletion       - The byte count associated with the completion
    dwCompletionStatus - The result code associated with the completion
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT *         pIsapiContext;
    ASYNC_PENDING           IoType;
    PFN_HSE_IO_COMPLETION   pfnCompletion;
    DWORD                   cbLastIo;
    HRESULT                 hr = NO_ERROR;

    DBG_REQUIRE( pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( IsaContext ) );

    pIsapiContext->ReferenceIsapiContext();

    //
    // Magical hand waving:
    //
    // If this is a completion for a write, then we need to
    // restore the original buffer size.  This is necessary
    // to keep from confusing ISAPI extensions that examine
    // the cbCompletion value in the case where a filter
    // changed the size of the buffer before the actual
    // IO occured.
    //
    // If this is a completion for an EXEC_URL, then we need
    // to set the dwCompletionStatus to ERROR_SUCCESS.  The
    // caller of the EXEC_URL should use GET_EXECUTE_URL_STATUS
    // to see the result of the child URL.
    //

    cbLastIo = pIsapiContext->QueryLastAsyncIo();
    pIsapiContext->SetLastAsyncIo( 0 );

    IoType = pIsapiContext->UninitAsyncIo();

    if ( IoType == AsyncWritePending )
    {
        cbCompletion = cbLastIo;
    }
    else if ( IoType == AsyncExecPending )
    {
        dwCompletionStatus = ERROR_SUCCESS;
    }
    
    //
    // If the completion context indicates a completion routine,
    // then call it.
    //

    pfnCompletion = pIsapiContext->QueryPfnIoCompletion();

    if ( pfnCompletion )
    {
        //
        // First, impersonate the client
        //

        if ( SetThreadToken( NULL, pIsapiContext->QueryToken() ) )
        {
            pfnCompletion(
                pIsapiContext->QueryECB(),
                pIsapiContext->QueryExtensionContext(),
                cbCompletion,
                dwCompletionStatus
                );

            DBG_REQUIRE( RevertToSelf() );
        }
        else
        {
            hr =  HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    pIsapiContext->DereferenceIsapiContext();

    return hr;
}

BOOL
WINAPI
GetServerVariable(
    HCONN       hConn,
    LPSTR       lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize
    )
/*++

Routine Description:

    Retrieves a server variable

Arguments:

    hConn            - The ConnID associated with the request.  This
                       value is opaque to the ISAPI that calls into
                       this function, but it can be cast to the
                       ISAPI_CONTEXT associated with the request.
    lpszVariableName - The name of the variable to retrieve
    lpvBuffer        - Upon return, contains the value of the variable
    lpdwSize         - On entry, contains the size of lpvBuffer, upon
                       return, contains the number of bytes actually
                       needed to contain the value.
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( hConn );

    //
    // Parameter validation
    //

    if ( pIsapiContext ==  NULL ||
         lpszVariableName == NULL ||
         lpdwSize == NULL ||
         ( *lpdwSize != 0 && lpvBuffer == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // If we are running OOP, then try and get the data
    // locally from the process.
    //

    if ( pIsapiContext->QueryIsOop() )
    {
        SERVER_VARIABLE_INDEX   Index;

        Index = LookupServerVariableIndex( lpszVariableName );

        if ( Index != ServerVariableExternal )
        {
            return pIsapiContext->GetOopServerVariableByIndex(
                Index,
                lpvBuffer,
                lpdwSize
                );
        }
    }

    //
    // Call it
    //

    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    hr = pIsapiCore->GetServerVariable(
        lpszVariableName,
        *lpdwSize ? (BYTE*)lpvBuffer : NULL,
        *lpdwSize,
        lpdwSize
        );

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser);

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
WriteClient(
    HCONN      ConnID,
    LPVOID     Buffer,
    LPDWORD    lpdwBytes,
    DWORD      dwReserved
    )
/*++

Routine Description:

    Writes data to the client

Arguments:

    hConn      - The ConnID associated with the request.  This
                 value is opaque to the ISAPI that calls into
                 this function, but it can be cast to the
                 ISAPI_CONTEXT associated with the request.
    Buffer     - The data to write
    lpdwBytes  - On entry, the number of bytes to write.  Upon
                 return, the number of bytes written (or so the
                 docs say)
    dwReserved - Flags (ie. HSE_IO_SYNC, etc.)
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    BOOL            fResult;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( ConnID );

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL ||
         lpdwBytes == NULL ||
         ( *lpdwBytes != 0 && Buffer == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // If the user is sending zero bytes, return TRUE here.  Yeah, this
    // will be kind of a bogus thing to do because if the call is async,
    // we will return successful with no completion ever occuring.
    //
    // IIS has done this for as long as sync WriteClient has existed, and
    // we'd risk breaking legacy code if we change it now.
    //

    if ( *lpdwBytes == 0 )
    {
        return TRUE;
    }

    //
    // BUGBUG - Need to map the documented HSE_IO flags to reasonable
    // UL equivalents and provide a mechanism to pass them.
    //

    if ( dwReserved & HSE_IO_ASYNC )
    {
        //
        // Do an asynchronous write
        //
        // Check to make sure that we have a completion
        // function.
        //

        if ( pIsapiContext->QueryPfnIoCompletion() == NULL ||
             pIsapiContext->TryInitAsyncIo( AsyncWritePending ) == FALSE )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        //
        // Some extensions depend on the number of bytes reported in the
        // completion to confirm success.  In the case where a send raw
        // data filter is installed (or if we are using SSL), it's possible
        // that the number of bytes in the completion is not what the
        // caller expects.
        //
        // We need to save away the number of bytes that they are sending
        // to protect them from themselves.
        //

        pIsapiContext->SetLastAsyncIo( *lpdwBytes );

        pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

        hr = pIsapiCore->WriteClient(
            reinterpret_cast<DWORD64>( pIsapiContext ),
            reinterpret_cast<LPBYTE>( Buffer ),
            *lpdwBytes,
            HSE_IO_ASYNC
            );

        pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );

        if ( FAILED( hr ) )
        {
            pIsapiContext->SetLastAsyncIo( 0 );
            pIsapiContext->UninitAsyncIo();
        }
    }
    else
    {
        //
        // Do a synchronous write
        //

        pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

        hr = pIsapiCore->WriteClient(
            NULL,
            reinterpret_cast<LPBYTE>( Buffer ),
            *lpdwBytes,
            HSE_IO_SYNC
            );

        pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );
    }

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }
    
    return TRUE;
}

BOOL
WINAPI
ReadClient(
    HCONN      ConnID,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize
    )
/*++

Routine Description:

    Reads data from the client

Arguments:

    hConn     - The ConnID associated with the request.  This
                value is opaque to the ISAPI that calls into
                this function, but it can be cast to the
                ISAPI_CONTEXT associated with the request.
    lpvBuffer - Upon return, contains the data read
    lpdwsize  - On entry, the size of lpvBuffer.  Upon
                return, the number of bytes read.
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    IIsapiCore *    pIsapiCore;
    HANDLE          hCurrentUser;
    HRESULT         hr;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( ConnID );

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL ||
         lpdwSize == NULL ||
         ( *lpdwSize != 0 && lpvBuffer == NULL ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiCore = pIsapiContext->QueryIsapiCoreInterface();

    if ( pIsapiCore == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    hr = pIsapiCore->ReadClient(
        NULL,
        reinterpret_cast<unsigned char *>( lpvBuffer ),
        *lpdwSize,
        *lpdwSize,
        lpdwSize,
        HSE_IO_SYNC
        );

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
ServerSupportFunction(
    HCONN      hConn,
    DWORD      dwHSERequest,
    LPVOID     lpvBuffer,
    LPDWORD    lpdwSize,
    LPDWORD    lpdwDataType
    )
/*++

Routine Description:

    Dispatches a ServerSupportFunction command to the appropriate
    server support function.

Arguments:

    hConn        - The ConnID associated with the request.  This
                   value is opaque to the ISAPI that calls into
                   this function, but it can be cast to the
                   ISAPI_CONTEXT associated with the request.
    dwHSERequest - The server support command
    lpvBuffer    - Command-specific data
    lpdwSize     - Command-specific data
    lpdwDataType - Command-specific data
  
Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    HANDLE          hCurrentUser;
    HRESULT         hr = NO_ERROR;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( hConn );

    //
    // Parameter validation
    //

    if ( pIsapiContext == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pIsapiContext->ReferenceIsapiContext();
    pIsapiContext->IsapiDoRevertHack( &hCurrentUser );

    //
    // Handle the specified command
    //

    switch ( dwHSERequest )
    {

    case HSE_REQ_SEND_RESPONSE_HEADER:

        hr = SSFSendResponseHeader(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<LPSTR>( lpdwDataType )
            );

        break;

    case HSE_REQ_SEND_RESPONSE_HEADER_EX:

        hr = SSFSendResponseHeaderEx(
            pIsapiContext,
            reinterpret_cast<HSE_SEND_HEADER_EX_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_MAP_URL_TO_PATH:

        hr = SSFMapUrlToPath(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_URL_TO_PATH_EX:

        hr = SSFMapUrlToPathEx(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HSE_URL_MAPEX_INFO*>( lpdwDataType ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_UNICODE_URL_TO_PATH:

        hr = SSFMapUnicodeUrlToPath(
            pIsapiContext,
            reinterpret_cast<LPWSTR>( lpvBuffer ),
            lpdwSize
            );

        break;

    case HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX:

        hr = SSFMapUnicodeUrlToPathEx(
            pIsapiContext,
            reinterpret_cast<LPWSTR>( lpvBuffer ),
            reinterpret_cast<HSE_UNICODE_URL_MAPEX_INFO*>( lpdwDataType ),
            lpdwSize
            );

        break;

    case HSE_REQ_GET_IMPERSONATION_TOKEN:

        hr = SSFGetImpersonationToken(
            pIsapiContext,
            reinterpret_cast<HANDLE*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_KEEP_CONN:

        hr = SSFIsKeepConn(
            pIsapiContext,
            reinterpret_cast<BOOL*>( lpvBuffer )
            );

        break;

    case HSE_REQ_DONE_WITH_SESSION:

        hr = SSFDoneWithSession(
            pIsapiContext,
            reinterpret_cast<DWORD*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_CERT_INFO_EX:

        hr = SSFGetCertInfoEx(
            pIsapiContext,
            reinterpret_cast<CERT_CONTEXT_EX*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IO_COMPLETION:

        hr = SSFIoCompletion(
            pIsapiContext,
            reinterpret_cast<PFN_HSE_IO_COMPLETION>( lpvBuffer ),
            reinterpret_cast<VOID*>( lpdwDataType )
            );

        break;

    case HSE_REQ_ASYNC_READ_CLIENT:

        hr = SSFAsyncReadClient(
            pIsapiContext,
            lpvBuffer,
            lpdwSize
            );

        break;

    case HSE_REQ_TRANSMIT_FILE:

        hr = SSFTransmitFile(
            pIsapiContext,
            reinterpret_cast<HSE_TF_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_SEND_URL:
    case HSE_REQ_SEND_URL_REDIRECT_RESP:

        hr = SSFSendRedirect(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_CONNECTED:
        
        hr = SSFIsConnected(
            pIsapiContext,
            reinterpret_cast<BOOL*>( lpvBuffer )
            );

        break;

    case HSE_APPEND_LOG_PARAMETER:

        hr = SSFAppendLog(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer )
            );

        break;
        
    case HSE_REQ_EXEC_URL:
    
        hr = SSFExecuteUrl(
            pIsapiContext,
            reinterpret_cast<HSE_EXEC_URL_INFO*>( lpvBuffer )
            );
        
        break;
    
    case HSE_REQ_GET_EXEC_URL_STATUS:
    
        hr = SSFGetExecuteUrlStatus(
            pIsapiContext,
            reinterpret_cast<HSE_EXEC_URL_STATUS*>( lpvBuffer )
            );
        
        break;

    case HSE_REQ_SEND_CUSTOM_ERROR:
    
        hr = SSFSendCustomError(    
            pIsapiContext,
            reinterpret_cast<HSE_CUSTOM_ERROR_INFO*>( lpvBuffer )
            );
        
        break;

    case HSE_REQ_VECTOR_SEND:

        hr = SSFVectorSend(
            pIsapiContext,
            reinterpret_cast<HSE_RESPONSE_VECTOR*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_CUSTOM_ERROR_PAGE:

        hr = SSFGetCustomErrorPage(
            pIsapiContext,
            reinterpret_cast<HSE_CUSTOM_ERROR_PAGE_INFO*>( lpvBuffer )
            );

        break;

    case HSE_REQ_IS_IN_PROCESS:

        hr = SSFIsInProcess(
            pIsapiContext,
            reinterpret_cast<DWORD*>( lpvBuffer )
            );

        break;

    case HSE_REQ_GET_SSPI_INFO:

        hr = SSFGetSspiInfo(
            pIsapiContext,
            reinterpret_cast<CtxtHandle*>( lpvBuffer ),
            reinterpret_cast<CredHandle*>( lpdwDataType )
            );

        break;

    case HSE_REQ_GET_VIRTUAL_PATH_TOKEN:

        hr = SSFGetVirtualPathToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            FALSE
            );

        break;

    case HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN:

        hr = SSFGetVirtualPathToken(
            pIsapiContext,
            reinterpret_cast<LPSTR>( lpvBuffer ),
            reinterpret_cast<HANDLE*>( lpdwSize ),
            TRUE
            );

        break;

    default:

        hr = HRESULT_FROM_WIN32( ERROR_CALL_NOT_IMPLEMENTED );
    }

    pIsapiContext->IsapiUndoRevertHack( &hCurrentUser );
    pIsapiContext->DereferenceIsapiContext();
    pIsapiContext = NULL;

    if ( FAILED( hr ) )
    {
        SetLastError( WIN32_FROM_HRESULT( hr ) );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3wp\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_manager.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:    

    thread_manager.cxx

Abstract:

    implementation for THREAD_MANAGER

Author:    
    
    Jeffrey Wall (jeffwall)     11-28-2000

Revision History:
    
    
    
--*/

#include <iis.h>
#include <dbgutil.h>
#include <regconst.h>
#include "thread_manager.h"
#include "thread_pool_private.h"

TCHAR g_szModuleName[MAX_PATH];

const WCHAR W3TP_MODULE_NAME[] = L"W3TP";

const DWORD THREAD_POOL_TIMER_CALLBACK = 1000;
const DWORD THREAD_POOL_CONTEXT_SWITCH_RATE = 10000;

BOOL
TooMuchSystemLoad(ULONG ulFirstSample,
                  DWORD dwFirstSampleTime,
                  ULONG ulPerSecondSwitchRateMax,
                  DWORD dwNumProcs);

BOOL GetContextSwitchCount(ULONG * pulSwitchCount);

//static
HRESULT
THREAD_MANAGER::CreateThreadManager(THREAD_MANAGER ** ppManager,
                                    THREAD_POOL * pPool,
                                    THREAD_POOL_DATA * pPoolData)
/*++

Routine Description:
    Allocate and initialize a THREAD_MANAGER
    
Arguments:

    ppManager - where to store allocated manager pointer
    pPool - pointer to THREAD_POOL associated with this manager
    pPoolData - pointer to THREAD_POOL_DATA associated with this manager

Return Value:

    HRESULT
--*/
{
    DBG_ASSERT(NULL != ppManager);
    DBG_ASSERT(NULL != pPool);
    DBG_ASSERT(NULL != pPoolData);

    *ppManager = NULL;

    HRESULT hr = S_OK;

    THREAD_MANAGER * pManager = new THREAD_MANAGER(pPool, pPoolData);
    if (NULL == pManager)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = pManager->Initialize();
    if (FAILED(hr))
    {
        // don't call TerminateThreadManager - just delete it
        delete pManager;

        goto done;
    }

    *ppManager = pManager;

    hr = S_OK;
done:
    return hr;
}

VOID 
THREAD_MANAGER::TerminateThreadManager(LPTHREAD_STOP_ROUTINE lpStopAddress,
                                       LPVOID lpParameter)
/*++

Routine Description:
    Shutdown ALL THREAD_MANAGER theads and destroy a THREAD_MANAGER
    
Arguments:

    lpStopAddress - address of function that will stop threads
    lpParameter - argument to pass to stop function

Return Value:

    VOID
--*/
{
    // block until threads are gone
    DrainThreads(lpStopAddress, lpParameter);

    // do some initializion succeeded only cleanup
    if (m_hShutdownEvent)
    {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }
    if (m_hParkEvent)
    {
        CloseHandle(m_hParkEvent);
        m_hParkEvent = NULL;
    }

    DeleteCriticalSection(&m_CriticalSection);

    // don't do anything else after deletion
    delete this;

    return;
}




THREAD_MANAGER::THREAD_MANAGER(THREAD_POOL * pPool,
                               THREAD_POOL_DATA * pPoolData) :
    m_dwSignature(SIGNATURE_THREAD_MANAGER),
    m_fShuttingDown(FALSE),
    m_fWaitingForCreationCallback(FALSE),
    m_dwTimerPeriod(THREAD_POOL_TIMER_CALLBACK),
    m_ulPerSecondContextSwitchMax(THREAD_POOL_CONTEXT_SWITCH_RATE),
    m_hTimer(NULL),
    m_pParam(NULL),
    m_hParkEvent(NULL),
    m_hShutdownEvent(NULL),
    m_lParkedThreads(0),
    m_pPool(pPool),
    m_pPoolData(pPoolData),
    m_lTotalThreads(0)
/*++

Routine Description:

    Constructs the ThreadManager
    
Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT(m_pPool);
    DBG_ASSERT(m_pPoolData);

    return;
}

HRESULT
THREAD_MANAGER::Initialize()
/*++

Routine Description:
    Do initialization for THREAD_MANAGER
    
Arguments:

    VOID
Return Value:

    HRESULT
--*/
{
    HRESULT hr = S_OK;

    DWORD dwRet;
    HKEY hKey;
    BOOL fRet; 
    
    if ( GetModuleFileNameW(
            GetModuleHandleW( W3TP_MODULE_NAME ),
            g_szModuleName,
            MAX_PATH
            ) == 0 )
    {
        DBG_ASSERT(FALSE && "Failed getting module name for w3tp.dll");
        hr = E_FAIL;
        goto done;
    }

    m_hParkEvent = CreateEvent(NULL,    // security descriptor
                               FALSE,   // auto reset
                               FALSE,   // not signaled at creation
                               NULL     // event name
                               );
    if (NULL == m_hParkEvent)
    {
        DBG_ASSERT(FALSE && "Could not create parking event");
        hr = E_FAIL;
        goto done;
    }
    m_hShutdownEvent = CreateEvent(NULL,    // security descriptor
                                   TRUE,    // manual reset
                                   FALSE,   // not signaled at creation
                                   NULL     // event name
                                   );
    if (NULL == m_hShutdownEvent)
    {
        DBG_ASSERT(FALSE && "Could not create shutdown event");
        hr = E_FAIL;
        goto done;
    }

    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGISTRY_KEY_INETINFO_PARAMETERS_W,
                         0,
                         KEY_READ,
                         &hKey
                         );
    if (NO_ERROR == dwRet)
    {
        m_ulPerSecondContextSwitchMax = 
            I_ThreadPoolReadRegDword(hKey,
                                     THREAD_POOL_REG_MAX_CONTEXT_SWITCH,
                                     m_ulPerSecondContextSwitchMax
                                     );
        m_dwTimerPeriod =
            I_ThreadPoolReadRegDword(hKey,
                                     THREAD_POOL_REG_START_DELAY,
                                     m_dwTimerPeriod
                                     );
        RegCloseKey(hKey);
        hKey = NULL;
    }

    
    // keep this at the end of Initialize - if it fails, no need to clean it up ever
    // If it succeededs, no need to clean it up in this function.

    // By setting the high order bit for dwSpinCount, we preallocate the CriticalSection
    fRet = InitializeCriticalSectionAndSpinCount(&m_CriticalSection, 
                                                 0x80000000 );        
    if (FALSE == fRet)
    {
        DBG_ASSERT(FALSE && "Could not initialize critical section!");
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        if (m_hParkEvent)
        {
            CloseHandle(m_hParkEvent);
            m_hParkEvent = NULL;
        }
        if (m_hShutdownEvent)
        {
            CloseHandle(m_hShutdownEvent);
            m_hShutdownEvent = NULL;
        }
    }

    return hr;
}

THREAD_MANAGER::~THREAD_MANAGER()
/*++

Routine Description:

    Destructs the ThreadManager
    
Arguments:

    None

Return Value:

    None

--*/
{
    DBG_ASSERT(SIGNATURE_THREAD_MANAGER == m_dwSignature);
    m_dwSignature = SIGNATURE_THREAD_MANAGER_FREE;

    DBG_ASSERT(TRUE == m_fShuttingDown && "DrainThreads was not called!");

    DBG_ASSERT(NULL == m_hTimer);
    DBG_ASSERT(NULL == m_pParam);
    DBG_ASSERT(0 == m_lParkedThreads);
    DBG_ASSERT(0 == m_lTotalThreads);

    m_pPool = NULL;
    m_pPoolData = NULL;
}

//static
DWORD
THREAD_MANAGER::ThreadManagerThread(LPVOID ThreadParam)
/*++

Routine Description:
    Starter thread for THREAD_MANAGER created threads
    Takes a reference against the current DLL
    Notifies THREAD_MANAGER that it has started execution
    Calls out to "real" thread procedure
    Notifies THREAD_MANAGER that it is about to terminate
    Releases reference to current DLL and terminates
    
Arguments:

    ThreadParam - parameters for control of thread

Return Value:

    win32 error or return value from "real" thread proc
--*/
{
    HMODULE         hModuleDll;
    DWORD           dwReturnCode;    
    THREAD_PARAM   *pParam = NULL;
    pParam = (THREAD_PARAM*)ThreadParam;

    // grab a reference to this DLL
    hModuleDll = LoadLibrary(g_szModuleName);
    if (NULL == hModuleDll)
    {
        dwReturnCode = GetLastError();
        goto done;
    }

    // verify the thread parameter passed was reasonable
    DBG_ASSERT(NULL != pParam);
    DBG_ASSERT(NULL != pParam->pThreadManager);
    DBG_ASSERT(NULL != pParam->pThreadFunc);

    if (pParam->fCallbackOnCreation)
    {
        // Inform thread manager that this thread has successfully gotten through the loader lock
        pParam->pThreadManager->CreatedSuccessfully(pParam);
    }

    // actually do work thread is supposed to do
    dwReturnCode = pParam->pThreadFunc(pParam->pvThreadArg);

done:
    // Inform thread manager that this thread is going away
    pParam->pThreadManager->RemoveThread(pParam);

    // Thread owns[ed] memory passed
    delete pParam;

    // release reference to this DLL
    FreeLibraryAndExitThread(hModuleDll, dwReturnCode);

    // never executed
    return dwReturnCode;
}

VOID
THREAD_MANAGER::RequestThread(LPTHREAD_START_ROUTINE lpStartAddress,
                              LPVOID lpStartParameter)
/*++

Routine Description:

    Creates a timer to determine the correct thread action to take.

    May create a thread in a little while
    May take away a thread in a little while
    May not create the timer if there is another thread creation going on

Arguments:

    lpStartAddress  - address of function to begin thread execution
    lpParameter     - argument to pass to start function

Return Value:
    
    VOID

--*/
{
    BOOL        fRet = FALSE;
    
    DBG_ASSERT(NULL != lpStartAddress);

    if (TRUE == m_fShuttingDown ||
        TRUE == m_fWaitingForCreationCallback)
    {
        return;
    }

    //
    // only want to create one timer at a time
    //
    EnterCriticalSection(&m_CriticalSection);

    if (TRUE == m_fShuttingDown ||
        TRUE == m_fWaitingForCreationCallback)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return;
    }

    // only want one thread at a time to be created
    m_fWaitingForCreationCallback = TRUE;

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread Request received\n"));

    DWORD dwCurrentTime = GetTickCount();

    fRet = GetContextSwitchCount(&m_ulContextSwitchCount);
    if (FALSE == fRet)
    {
        goto done;
    }

    DBG_ASSERT(NULL == m_pParam);
    m_pParam = new THREAD_PARAM;
    if (NULL == m_pParam)
    {
        fRet = FALSE;
        goto done;
    }

    m_pParam->pThreadFunc = lpStartAddress;
    m_pParam->pvThreadArg = lpStartParameter;
    m_pParam->pThreadManager = this;
    m_pParam->dwRequestTime = dwCurrentTime;
    m_pParam->fCallbackOnCreation = TRUE;

    if (NULL != m_hTimer)
    {
        // if this isn't the first time we've requested a thread,
        // we have a previous TimerQueueTimer.  This timer was not
        // removed during the callback, so we have to clean it up now.
        // this is the blocking form of the delete operation, however
        // since the timer has already fired it will not block.
        fRet = DeleteTimerQueueTimer(NULL,                  // default timer queue
                                     m_hTimer,              // previous timer handle
                                     INVALID_HANDLE_VALUE   // wait until it is removed
                                     );
        m_hTimer = NULL;
    }

    DBG_ASSERT(NULL == m_hTimer);
    fRet = CreateTimerQueueTimer(&m_hTimer,             // storage for timer handle
                                 NULL,                  // default timer queue
                                 ControlTimerCallback, // callback function
                                 this,                  // callback argument
                                 m_dwTimerPeriod,       // time til callback
                                 0,                     // repeat time
                                 WT_EXECUTEONLYONCE     // no repition
                                 );
    if (FALSE == fRet)
    {
        goto done;
    }

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete m_pParam;
        m_pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;        
    }

    LeaveCriticalSection(&m_CriticalSection);
    return;
}


//static
VOID
THREAD_MANAGER::ControlTimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)    
/*++

Routine Description:

    Callback for timer created in RequestThread
    
    restores this pointer and forwards to DetermineThreadAction
    
Arguments:
    lpParameter - THREAD_MANAGER this pointer

Return Value:
    VOID
--*/
{
    THREAD_MANAGER* pThreadManager = (THREAD_MANAGER*)lpParameter;
    
    DBG_ASSERT(NULL != pThreadManager);
    DBG_ASSERT(NULL != pThreadManager->m_pParam);
    DBG_ASSERT(TRUE == pThreadManager->m_fWaitingForCreationCallback);

    pThreadManager->DetermineThreadAction();

    return;
}

VOID
THREAD_MANAGER::DetermineThreadAction()    
/*++

Routine Description:

    Try to determine correct action, create or take away a thread
    
    Will take away a thread if context switch rate is too high
    
    m_pParam must be populated
Arguments:

  VOID

Return Value:

  VOID

--*/
{
    BOOL        fRet = FALSE;
    DWORD       dwElapsedTime = 0;
    DWORD       dwCurrentTime = 0;

    EnterCriticalSection(&m_CriticalSection);

    DBG_ASSERT(NULL != m_pParam);

    if (TRUE == m_fShuttingDown)
    {
        fRet = FALSE;
        goto done;
    }

    DBG_ASSERT(TRUE == m_fWaitingForCreationCallback);

    if (TooMuchSystemLoad(m_ulContextSwitchCount,
                          m_pParam->dwRequestTime,
                          m_ulPerSecondContextSwitchMax,
                          m_pPoolData->m_cCPU))
    {
        // Switching too much

        DoThreadParking();
        fRet = FALSE;
        goto done;
    }

    fRet = DoThreadCreation(m_pParam);
    if (!fRet)
    {
        goto done;
    }

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete m_pParam;
        m_pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;
    }
    else
    {
        // thread now has responsibility for the memory
        m_pParam = NULL;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return;
}

BOOL
THREAD_MANAGER::DoThreadCreation(THREAD_PARAM *pParam)
/*++

Routine Description:

    If there are no threads in parked state

    Creates a thread, 
    add the HANDLE to the internal list of handles
    add the creation time to the internal list of times          

    Otherwise, bring a thread out of parked state

Arguments:
    pParam - parameter to pass to created thread

Return Value:

    TRUE if thread is created successfully
    FALSE if thread is not created - either a thread was returned from
    parked state, OR there was a problem with creation.  

--*/
{
    BOOL        fRet = FALSE;
    HANDLE      hThread = NULL;

    if (DoThreadUnParking())
    {
        // we have not created a new thread
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Signaled a thread to be unparked\n"));

        // return false - signal that pParam needs to be freed by the caller
        fRet = FALSE;
        goto done;
    }
    
    // bugbug: use _beginthreadex?
    hThread = ::CreateThread( NULL,     // default security descriptor
                              0,        // default process stack size
                              ThreadManagerThread, // thread function
                              pParam,   // thread argument
                              0,        // create running
                              NULL      // don't care for thread identifier
                              );
    if( NULL == hThread )
    {
        fRet = FALSE;
        goto done;
    }

    // don't keep the handle around
    CloseHandle(hThread);

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Created a new thread\n"));

    InterlockedIncrement(&m_lTotalThreads);

    // we've successfully created the thread!
    fRet = TRUE;
done:
    return fRet;
}

VOID 
THREAD_MANAGER::DoThreadParking()
/*++

Routine Description:

    Called when context switch rate has been determined to be too high
    Removes a thread from participation in the thread pool, and parks it

Arguments:
    none

Return Value:

    VOID
--*/
{
    BOOL fRet;

    // make sure that we leave the starting number of threads in the pool
    if (m_pPoolData &&
        m_lTotalThreads - m_lParkedThreads >= m_pPoolData->m_cStartupThreads)
    {
        return;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Posting to park a thread\n"));

    fRet = m_pPool->PostCompletion(0, 
                                   ParkThread,
                                   (LPOVERLAPPED)this);
    DBG_ASSERT(TRUE == fRet);
    return;
}

BOOL
THREAD_MANAGER::DoThreadUnParking()
/*++

Routine Description:
    Release one thread from the parked state
    
Arguments:

    VOID
Return Value:

    BOOL - TRUE if thread was released
    FALSE if no threads were available to release
--*/
{
    if (0 == m_lParkedThreads)
    {
        return FALSE;
    }
    SetEvent(m_hParkEvent);
    return TRUE;
}

//static
VOID
THREAD_MANAGER::ParkThread(DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransferred,
                                  LPOVERLAPPED lpo)
/*++

Routine Description:
    Put a THREAD_MANAGER thread in a parked state
    
Arguments:

    dwErrorCode - not used
    dwNumberOfBytesTransferred - not used
    lpo - pointer to overlapped that is really a pointer to a THREAD_MANAGER
Return Value:

    VOID
--*/
{
    DWORD dwRet = 0;
    THREAD_MANAGER * pThis= (THREAD_MANAGER*)lpo;
    DBG_ASSERT(NULL != pThis);
    
    HANDLE arrHandles[2];
    arrHandles[0] = pThis->m_hParkEvent;
    arrHandles[1] = pThis->m_hShutdownEvent;

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread parking\n"));

    InterlockedIncrement(&pThis->m_lParkedThreads);
    
    dwRet = WaitForMultipleObjects(2,
                                   arrHandles,
                                   FALSE,
                                   INFINITE);
    
    InterlockedDecrement(&pThis->m_lParkedThreads);

    DBGPRINTF(( DBG_CONTEXT, "W3TP: Thread unparked\n"));

    DBG_ASSERT(WAIT_OBJECT_0 == dwRet ||
               WAIT_OBJECT_0 + 1 == dwRet);

    return;
}

BOOL
THREAD_MANAGER::CreateThread(LPTHREAD_START_ROUTINE lpStartAddress,
                             LPVOID lpParameter)
/*++

Routine Description:

    Creates a thread if no other thread is being created currently
    
Arguments:

    lpStartAddress  - address of function to begin thread execution
    lpParameter     - argument to pass to start function

Return Value:

    TRUE if thread is created successfully
    FALSE if thread is not created

--*/
{
    BOOL fRet = FALSE;
    THREAD_PARAM * pParam = NULL;

    EnterCriticalSection(&m_CriticalSection);
    
    if (TRUE == m_fShuttingDown)
    {
        fRet = FALSE;
        goto done;
    }

    pParam = new THREAD_PARAM;
    if (NULL == pParam)
    {
        fRet = FALSE;
        goto done;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: CreateThread thread creation\n"));

    pParam->pThreadFunc = lpStartAddress;
    pParam->pvThreadArg = lpParameter;
    pParam->pThreadManager = this;
    pParam->dwRequestTime = GetTickCount();
    pParam->fCallbackOnCreation = FALSE;

    fRet = DoThreadCreation(pParam);
    if (FALSE == fRet)
    {
        goto done;
    }

    // created thread has responsibility for this memory
    pParam = NULL;

    fRet = TRUE;
done:
    if (FALSE == fRet)
    {
        delete pParam;
        pParam = NULL;

        m_fWaitingForCreationCallback = FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return fRet;
}

VOID
THREAD_MANAGER::RemoveThread(THREAD_PARAM * pParam)
/*++

Routine Description:

    Removes given thread from list of active threads and closes handle

Arguments:

    hThreadSelf - handle to current thread

Return Value:

    void
--*/
{
    InterlockedDecrement(&m_lTotalThreads);
    return;
}

VOID
THREAD_MANAGER::CreatedSuccessfully(THREAD_PARAM * pParam)
/*++

Routine Description:

    Notification that given thread has successfully started

Arguments:

    hThread - current thread handle

Return Value:

    VOID

--*/
{
    DBG_ASSERT(pParam);

    EnterCriticalSection(&m_CriticalSection);

    DBG_ASSERT(m_fWaitingForCreationCallback);
    
    m_fWaitingForCreationCallback = FALSE;

    LeaveCriticalSection(&m_CriticalSection);

    return;
}

VOID
THREAD_MANAGER::DrainThreads(LPTHREAD_STOP_ROUTINE lpStopAddress,
                             LPVOID lpParameter)
/*++

Routine Description:

    stop all threads currently being managed.
    Doesn't return until all threads are stopped.
    
Arguments:

    lpStopAddress   - address of function to call to signal one thread to stop

Return Value:

    TRUE if all threads are stopped
    FALSE if one or more threads could not be stopped

--*/
{
    if (TRUE == m_fShuttingDown)
    {
        DBG_ASSERT(FALSE && "DrainThreads has been called previously!");
        return;
    }


    EnterCriticalSection(&m_CriticalSection);
    // stop any additional thread creation
    m_fShuttingDown = TRUE;
    LeaveCriticalSection(&m_CriticalSection);

    // release all parked threads
    SetEvent(m_hShutdownEvent);

    // push as many stops are there are threads running
    for (INT i = m_lTotalThreads; i >= 0; i--)
//TODO: think about sync with interlocked and m_lTotalThreads - is there a race here?
    {
        lpStopAddress(lpParameter);
    }

    // stop the callback timer
    if (NULL != m_hTimer)
    {
        // block until timer is deleted
        DeleteTimerQueueTimer(NULL,
                              m_hTimer,
                              INVALID_HANDLE_VALUE);
        m_hTimer = NULL;
        if (m_pParam)
        {
            // the ownership for m_pParam moves from the creator
            // to the timer to the thread.
            // However, we just destroyed the timer - need to cleanup
            // the memory
            delete m_pParam;
            m_pParam = NULL;
        }
    }

    while(m_lTotalThreads > 0)
    {
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Waiting for threads to drain, sleep 1000 \n"));
        Sleep(1000);
    }
    
    DBGPRINTF(( DBG_CONTEXT, "W3TP: All threads drained\n"));

    return;
}


BOOL
GetContextSwitchCount(ULONG * pulSwitchCount)
/*++

Routine Description:

    Get the current machine context switch count
    
Arguments:

    pulSwitchCount - where to store switch count

Return Value:

    TRUE if context switch count is read correctly
    FALSE if context switch count could not be read

--*/
{
    DBG_ASSERT(NULL != pulSwitchCount);

    SYSTEM_PERFORMANCE_INFORMATION spi;
    ULONG ulReturnLength;
    NTSTATUS status;
    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &spi,
                                      sizeof(spi),
                                      &ulReturnLength);
    if (!NT_SUCCESS(status))
    {
        return FALSE;
    }

    *pulSwitchCount = spi.ContextSwitches;

    return TRUE;
}


BOOL
TooMuchSystemLoad(ULONG ulFirstSample,
                  DWORD dwFirstSampleTime,
                  ULONG ulPerSecondSwitchRateMax,
                  DWORD dwNumProcs)
/*++

Routine Description:

    Determine if the system is under too much load in terms
    of context switches / second

    If dwNumProcs > 1 - the per second switch rate per processor is multiplied by two
    
Arguments:

    ulFirstSample - first context switch count number
    dwSampleTimeInMilliseconds - how much time between first sample and calling this function
    ulPerSecondSwitchRateMax - Maximum switch rate per processor
    dwNumProcs - number of processors on machine

Return Value:

    TRUE if context switch rate per second per processor is > ulPerSecondSwitchRateMax
    FALSE if context switch rate is below ulPerSecondSwitchRateMax

--*/
{
    ULONG ulSecondSample = 0;
    ULONG ulContextSwitchDifference = 0;
    double dblPerSecondSwitchRate = 0;
    double dblPerSecondSwitchRatePerProcessor = 0;        
    DWORD dwCurrentTime = 0;
    DWORD dwElapsedTime = 0;

    BOOL fRet = FALSE;

    fRet = GetContextSwitchCount(&ulSecondSample);
    if (FALSE == fRet)
    {
        goto done;
    }
    
    dwCurrentTime = GetTickCount();
    if (dwCurrentTime <= dwFirstSampleTime)
    {
        // wrap around on time occurred - assume only one wrap around
        const DWORD MAXDWORD = MAXULONG;
        dwElapsedTime = MAXDWORD - dwFirstSampleTime + dwCurrentTime;
    }
    else
    {
        // no wrap around
        dwElapsedTime = dwCurrentTime - dwFirstSampleTime;
    }
    DBG_ASSERT(dwElapsedTime > 0);


    if (ulSecondSample <= ulFirstSample)
    {
        // wrap around on counter occurred - assume only one wrap around
        ulContextSwitchDifference = (MAXULONG - ulFirstSample) + ulSecondSample;
    }
    else
    {
        // no wrap around
        ulContextSwitchDifference = ulSecondSample - ulFirstSample;
    }
    DBG_ASSERT(ulContextSwitchDifference > 0);
    
    dblPerSecondSwitchRate = ulContextSwitchDifference / ( dwElapsedTime / 1000.0);

    dblPerSecondSwitchRatePerProcessor = dblPerSecondSwitchRate / dwNumProcs;
    
    if (dwNumProcs > 1)
    {
        // on multiproc boxes, double the allowed context switch rate per processor
        ulPerSecondSwitchRateMax *= 2;
    }

    if (dblPerSecondSwitchRatePerProcessor > ulPerSecondSwitchRateMax)
    {
        DBGPRINTF(( DBG_CONTEXT, "W3TP: Not creating thread, ContextSwitch rate is: %g\n", dblPerSecondSwitchRate ));
        fRet = TRUE;
        goto done;
    }

    DBGPRINTF(( DBG_CONTEXT, "W3TP: OK to create thread, ContextSwitch rate is: %g\n", dblPerSecondSwitchRate ));

    fRet = FALSE;
done:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_functions.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_functions.cxx

Abstract:

    Public routines for the worker process thread pool

    Creates global instance of THREAD_POOL and forwards calls

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000
    Jeffrey Wall (jeffwall)      April 2001

--*/

#include <iis.h>
#include <dbgutil.h>
#include <thread_pool.h>

//
// Only initialize ourselves once
//
LONG    g_cInitializeCount = -1;

// 
// global pointer for process thread pool
//
THREAD_POOL * g_pThreadPool = NULL;

/**********************************************************************
    Public function definitions
**********************************************************************/

HRESULT
ThreadPoolInitialize( VOID )
/*++

Routine Description:

    Initializes the thread pool.

    NO SYNCHRONIZATION HERE

    Make sure the initialization of the thread pool is complete (this function returns S_OK)
    before calling other public API functions, including this one.
    
Arguments:

    None.

Return Value:

    NOERROR if thread pool is initialized
    FAILED() otherwise

--*/
{

    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    if ( InterlockedIncrement( &g_cInitializeCount ) != 0 )
    {
        //
        // Already inited
        //
        
        DBGPRINTF(( DBG_CONTEXT,
                    "W3TP: ThreadPoolInitialize() already called\n" ));
        
        hr = S_OK;
        goto done;
    }

    DBG_ASSERT(NULL == g_pThreadPool);

    fRet = THREAD_POOL::CreateThreadPool(&g_pThreadPool);
    if (FALSE == fRet)
    {
        hr = E_FAIL;
        goto done;
    }

    DBG_ASSERT(NULL != g_pThreadPool);

    hr = S_OK;
done:
    return hr;
}

HRESULT
ThreadPoolTerminate( VOID )
/*++

Routine Description:

    Cleans up the thread pool. At this point all clients should
    have terminated (cleanly we hope) and our threads should 
    be idle.

Arguments:

    None.

Return Value:

    NOERROR if clean shutdown
    FAILED() otherwise

--*/
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;

    if ( InterlockedDecrement( &g_cInitializeCount ) >= 0 )
    {
        //
        // Someone else is using the pool
        //
        
        DBGPRINTF(( DBG_CONTEXT,
                    "W3TP: ThreadPoolTerminate() called but pool still in use\n" ));
        
        hr = S_OK;
        goto done;
    }
    
    //
    // Now we can cleanup!
    //
    
    DBG_ASSERT(NULL != g_pThreadPool);

    g_pThreadPool->TerminateThreadPool();
    
    g_pThreadPool = NULL;

    hr = S_OK;
done:
    return hr;
}

BOOL ThreadPoolPostCompletion(
    IN DWORD dwBytesTransferred,
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,
    IN LPOVERLAPPED lpo
    )
/*++

Routine Description:

    Posts a completion to the port.  Results in an asynchronous callback.

Arguments:

    dwBytesTransferred - bytes transferred for this completions
    Function - function to call on completion
    lpo - overlapped pointer
    

Return Value:

    TRUE if completion posted, otherwise FALSE

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->PostCompletion(dwBytesTransferred,
                                         Function,
                                         lpo);
}

BOOL 
ThreadPoolBindIoCompletionCallback(
    HANDLE FileHandle,                         // handle to file
    LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
    ULONG Flags                                // reserved
    )
/*++

Routine Description:

    Binds given handle to completion port

Arguments:

    FileHandle - handle to bind
    Function - function to call on completion
    Flags - not used

Return Value:

    TRUE if handle bound to port, otherwise FALSE

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->BindIoCompletionCallback(FileHandle,
                                                   Function,
                                                   Flags);
}

ULONG_PTR
ThreadPoolSetInfo(
    IN THREAD_POOL_INFO InfoId,
    IN ULONG_PTR        Data
    )
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId      - Data item to set
    Data        - New value for item

Return Value:

    The old data value

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->SetInfo(InfoId, Data);
}

ULONG_PTR
ThreadPoolGetInfo(
    IN THREAD_POOL_INFO InfoId
    )
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId     - Data item to set

Return Value:

    The configuration data value

--*/
{
    DBG_ASSERT(g_pThreadPool);
    return g_pThreadPool->GetInfo(InfoId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_pool_private.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_pool_private.h

Abstract:

    Internal declarations and types for the IIS+ worker process
    thread pool.
    
    This thread pool is based on the IIS5 atq implementation.

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000

Revision History:

--*/

#ifndef _THREAD_POOL_PRIVATE_H_
#define _THREAD_POOL_PRIVATE_H_

/**********************************************************************
    Configuration
**********************************************************************/

//
// Registry parameters 
// HKLM\System\CurrentControlSet\Services\InetInfo\Parameters
//

#define THREAD_POOL_REG_PER_PROCESSOR_THREADS     TEXT("MaxPoolThreads")
#define THREAD_POOL_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit")
#define THREAD_POOL_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define THREAD_POOL_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define THREAD_POOL_REG_POOL_THREAD_START         TEXT("ThreadPoolStartupThreadCount")
#define THREAD_POOL_REG_START_DELAY               TEXT("ThreadPoolStartDelay")
#define THREAD_POOL_REG_MAX_CONTEXT_SWITCH        TEXT("ThreadPoolMaxContextSwitch")

//
// Default values
//

// special value of 0 means that system will determine this dynamically.
const DWORD THREAD_POOL_REG_DEF_PER_PROCESSOR_CONCURRENCY = 0;

// how many threads do we start with
const LONG THREAD_POOL_REG_DEF_PER_PROCESSOR_THREADS = 4;

// thirty minutes
const DWORD THREAD_POOL_REG_DEF_THREAD_TIMEOUT = (30 * 60);

// thread limits
const LONG THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT = 64;
const LONG THREAD_POOL_REG_DEF_POOL_THREAD_LIMIT = 128;
const LONG THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT = 256;


/**********************************************************************
**********************************************************************/

// Arbitrary signal for the thread to shutdown
const ULONG_PTR THREAD_POOL_THREAD_EXIT_KEY = NULL;

/**********************************************************************
    Function declarations
**********************************************************************/


DWORD
I_ThreadPoolReadRegDword(
   IN HKEY     hkey,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue 
   );


class THREAD_POOL;
class THREAD_MANAGER;

#define SIGNATURE_THREAD_POOL_DATA            ((DWORD) 'ADPT')
#define SIGNATURE_THREAD_POOL_DATA_FREE       ((DWORD) 'xDPT')

/*++
Storage for data members of THREAD_POOL
--*/
class THREAD_POOL_DATA
{
private:
    DWORD m_dwSignature;

public:
    THREAD_POOL_DATA(THREAD_POOL * pPool)
    {
        m_dwSignature = SIGNATURE_THREAD_POOL_DATA;
        m_cCPU = 1;
        m_cConcurrency = THREAD_POOL_REG_DEF_PER_PROCESSOR_CONCURRENCY;
        m_msThreadTimeout = THREAD_POOL_REG_DEF_THREAD_TIMEOUT * 1000;
        m_cMaxThreadLimit = THREAD_POOL_REG_DEF_POOL_THREAD_LIMIT;
        m_hCompPort = NULL;
        m_cThreads = 0;
        m_cAvailableThreads = 0;
        m_cMaxThreads = THREAD_POOL_REG_DEF_PER_PROCESSOR_THREADS;
        m_fShutdown = FALSE;
        m_pThreadManager = NULL;
        m_cStartupThreads = 1;

        DBG_ASSERT(NULL != pPool);
        m_pPool = pPool;
    }
    ~THREAD_POOL_DATA()
    {
        DBG_ASSERT(SIGNATURE_THREAD_POOL_DATA == m_dwSignature);
        m_dwSignature = SIGNATURE_THREAD_POOL_DATA_FREE;

        m_pPool = NULL;
        DBG_ASSERT(NULL == m_pThreadManager);
        DBG_ASSERT(NULL == m_hCompPort);
        DBG_ASSERT(0 == m_cAvailableThreads);
        DBG_ASSERT(0 == m_cThreads);
    }
    
    BOOL InitializeThreadPool();

    DWORD ThreadPoolThread();
    static DWORD ThreadPoolThread(LPVOID pvThis);

    static void WINAPI ThreadPoolStop(LPVOID pvThis);

    BOOL ThreadPoolCheckThreadStatus();
    
    BOOL WINAPI OkToCreateAnotherThread();

    //
    // # of CPUs in machine (for thread-tuning)
    //
    DWORD   m_cCPU;

    //
    // concurrent # of threads to run per processor
    //
    LONG   m_cConcurrency;

    //
    //  Amount of time (in ms) a worker thread will be idle before suicide
    //
    DWORD   m_msThreadTimeout;

    //
    // The absolute thread limit
    //
    LONG    m_cMaxThreadLimit;


    // -------------------------
    // Current state information
    // -------------------------
    
    //
    // Handle for completion port
    //
    HANDLE  m_hCompPort;
    
    //
    // number of thread in the pool
    //
    LONG    m_cThreads;
    
    //
    // # of threads waiting on the port.
    //
    LONG    m_cAvailableThreads;
    
    //
    // Current thread limit
    //
    LONG    m_cMaxThreads;
    
    //
    // Number of threads to start up
    //
    LONG m_cStartupThreads;

    //
    // Are we shutting down
    //
    BOOL    m_fShutdown;
    
    //
    // Pointer to THREAD_MANAGER
    //
    THREAD_MANAGER *m_pThreadManager;

    //
    // Back pointer to owner THREAD_POOL
    //
    THREAD_POOL * m_pPool;
};

#endif // !_THREAD_POOL_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_pool.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    thread_pool.cxx

Abstract:

    THREAD_POOL implementation

    THREAD_POOL_DATA definition and implementation

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000
    Jeffrey Wall (jeffwall)      April 2001

--*/

#include <iis.h>
#include <dbgutil.h>
#include <thread_pool.h>
#include "thread_pool_private.h"
#include "thread_manager.h"

/**********************************************************************
    Globals
**********************************************************************/

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

CONST TCHAR g_szConfigRegKey[] =
    TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");


//static
BOOL
THREAD_POOL::CreateThreadPool(THREAD_POOL ** ppThreadPool)
/*++

Routine Description:
    Creates and initializes a THREAD_POOL object

Arguments:
    ppThreadPool - storage for pointer of allocated THREAD_POOL

Return Value:
    BOOL - TRUE if pool successfully created and initialized, else FALSE

--*/
{
    BOOL fRet = FALSE;
    THREAD_POOL * pThreadPool = NULL;
    THREAD_POOL_DATA * pData = NULL;

    DBG_ASSERT(NULL != ppThreadPool);
    *ppThreadPool = NULL;

    pThreadPool = new THREAD_POOL;
    if (NULL == pThreadPool)
    {
        fRet = FALSE;
        goto done;
    }

    pData = new THREAD_POOL_DATA(pThreadPool);
    if (NULL == pData)
    {
        delete pThreadPool;
        fRet = FALSE;
        goto done;
    }

    // give threadpool object ownership of THREAD_POOL_DATA memory
    pThreadPool->m_pData = pData;
    pData = NULL;

    fRet = pThreadPool->m_pData->InitializeThreadPool();
    if (FALSE == fRet)
    {
        delete pThreadPool;
        pThreadPool = NULL;
        goto done;
    }

    // created and initialized thread pool returned
    *ppThreadPool = pThreadPool;

    fRet = TRUE;
done:
    return fRet;
}

THREAD_POOL::THREAD_POOL()
/*++

Routine Description:
    THREAD_POOL constructor
    Interesting work occurs in InitializeThreadPool

Arguments:
    none

Return Value:
    none

--*/
{
    m_pData = NULL;
}

THREAD_POOL::~THREAD_POOL()
/*++

Routine Description:
    THREAD_POOL destructor
    Interesting work occurs in TerminateThreadPool

Arguments:
    none

Return Value:
    none

--*/
{
    delete m_pData;
    m_pData = NULL;
}

BOOL
THREAD_POOL_DATA::InitializeThreadPool()
/*++

Routine Description:

    Initializes a THREAD_POOL object.
    Determines thread limits, reads settings from registry
    creates completion port, creates THREAD_MANAGER
    and creates initial threads

Arguments:
    none

Return Value:
    BOOL - TRUE if pool successfully initialized, else FALSE

--*/
{
    BOOL fRet = FALSE;
    HRESULT hr = S_OK;

    BOOL    IsNtServer;

    INITIALIZE_PLATFORM_TYPE();

    //
    // Only scale for NT Server
    //
    
    IsNtServer = TsIsNtServer();

    SYSTEM_INFO     si;
    GetSystemInfo( &si );
    m_cCPU = si.dwNumberOfProcessors;

    if( IsNtServer )
    {
        MEMORYSTATUS    ms;


        //
        // get the memory size
        //

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( &ms );

        //
        // Alloc two threads per MB of memory.
        //

        m_cMaxThreadLimit = (LONG)((ms.dwTotalPhys >> 19) + 2);

        if ( m_cMaxThreadLimit < THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT ) 
        {
            m_cMaxThreadLimit = THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT;
        } 
        else if ( m_cMaxThreadLimit > THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT ) 
        {
            m_cMaxThreadLimit = THREAD_POOL_REG_MAX_POOL_THREAD_LIMIT;
        }
    }
    else
    {
        // Not server

        m_cMaxThreadLimit = THREAD_POOL_REG_MIN_POOL_THREAD_LIMIT;
    }

    //
    // Get configuration parameters from the registry
    //

    HKEY    hKey = NULL;
    DWORD   dwVal;
    DWORD   dwError;

    //
    // BUGBUG - ACL may deny this if process level is insufficient
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_szConfigRegKey,
                            0,
                            KEY_READ,
                            &hKey
                            );

    if( dwError == NO_ERROR )
    {
        //
        // Read the Concurrency factor per processor
        //

        dwVal = I_ThreadPoolReadRegDword( 
                    hKey,
                    THREAD_POOL_REG_PER_PROCESSOR_CONCURRENCY,
                    THREAD_POOL_REG_DEF_PER_PROCESSOR_CONCURRENCY
                    );

        m_pPool->SetInfo( ThreadPoolMaxConcurrency, (ULONG_PTR)dwVal);

        //
        // Read the count of threads to be allowed per processor
        //

        dwVal = I_ThreadPoolReadRegDword( 
                    hKey,
                    THREAD_POOL_REG_PER_PROCESSOR_THREADS,
                    THREAD_POOL_REG_DEF_PER_PROCESSOR_THREADS
                    );

        if ( dwVal != 0 ) 
        {
            m_pPool->SetInfo( ThreadPoolMaxPoolThreads, (ULONG_PTR)dwVal);
        }

        //
        // Read the time (in seconds) of how long the threads
        //   can stay alive when there is no IO operation happening on
        //   that thread.
        //

        dwVal = I_ThreadPoolReadRegDword( 
                    hKey,
                    THREAD_POOL_REG_THREAD_TIMEOUT,
                    THREAD_POOL_REG_DEF_THREAD_TIMEOUT
                    );

        m_pPool->SetInfo( ThreadPoolThreadTimeout, (ULONG_PTR)dwVal);

        //
        // Read the max thread limit. We've already computed a limit 
        // based on memory, but allow registry override.
        //

        m_cMaxThreadLimit = I_ThreadPoolReadRegDword( 
                                hKey,
                                THREAD_POOL_REG_POOL_THREAD_LIMIT,
                                m_cMaxThreadLimit
                                );

        // 
        // Read the number of threads to start
        // with a default of one per CPU and a floor of 4
        //
        if (m_cCPU < 4)
        {
            m_cStartupThreads = 4;
        }
        else
        {
            m_cStartupThreads = m_cCPU;
        }
        m_cStartupThreads = I_ThreadPoolReadRegDword(
                                hKey,
                                THREAD_POOL_REG_POOL_THREAD_START,
                                m_cStartupThreads
                                );


        RegCloseKey( hKey );
        hKey = NULL;
    }


    hr = THREAD_MANAGER::CreateThreadManager(&m_pThreadManager, m_pPool, this);
    if (FAILED(hr))
    {
        fRet = FALSE;
        goto cleanup;
    }

    //
    // Create the completion port
    //
    
    m_hCompPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
                                          NULL,
                                          0,
                                          m_cConcurrency
                                          );
    if( !m_hCompPort )
    {
        fRet = FALSE;
        goto cleanup;
    }

    //
    // Create our initial threads
    //
    DBG_REQUIRE( m_pThreadManager->CreateThread(ThreadPoolThread,
                                                (LPVOID) this) );
    for(int i = 1; i < m_cStartupThreads; i++)
    {
        DBG_REQUIRE( m_pThreadManager->CreateThread(ThreadPoolThread,
                                                    (LPVOID) this) );
    }

    fRet = TRUE;
    return fRet;
    
    //
    // Only on failure
    //
cleanup:
    
    if( m_hCompPort != NULL ) 
    {
        CloseHandle( m_hCompPort );
        m_hCompPort = NULL;
    }

    return fRet;
}

VOID
THREAD_POOL::TerminateThreadPool()
/*++

Routine Description:
    cleans up and destroys a THREAD_POOL object
    
    CAVEAT: blocks until all threads in pool have terminated

Arguments:
    none

Return Value:
    none

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "W3TP: Cleaning up thread pool.\n" ));


    if ( m_pData->m_fShutdown ) 
    {
        //
        // We have not been intialized or have already terminated.
        //
        
        DBG_ASSERT( FALSE );
        return;
    }

    m_pData->m_fShutdown = TRUE;

    if ( m_pData->m_pThreadManager )
    {
        m_pData->m_pThreadManager->TerminateThreadManager(THREAD_POOL_DATA::ThreadPoolStop, m_pData);
    }
    m_pData->m_pThreadManager = NULL;

    CloseHandle( m_pData->m_hCompPort );
    m_pData->m_hCompPort = NULL;

    // finally, release this objects memory
    delete this;

    return;
}

//static
void 
WINAPI 
THREAD_POOL_DATA::ThreadPoolStop(VOID * pvThis)
/*++

Routine Description:
    posts completion to signal one thread to terminate

Arguments:
    pvThis - THREAD_POOL this pointer

Return Value:
    none

--*/
{
    BOOL        fRes;
    OVERLAPPED  Overlapped;
    ZeroMemory( &Overlapped, sizeof(OVERLAPPED) );

    THREAD_POOL_DATA * pThis= reinterpret_cast<THREAD_POOL_DATA*>(pvThis);

    fRes = PostQueuedCompletionStatus( pThis->m_hCompPort,
                                       0,
                                       THREAD_POOL_THREAD_EXIT_KEY,
                                       &Overlapped
                                       );
    DBG_ASSERT( fRes || 
                (!fRes && GetLastError() == ERROR_IO_PENDING) 
                );
    return;
}

ULONG_PTR
THREAD_POOL::SetInfo(IN THREAD_POOL_INFO InfoId,
                               IN ULONG_PTR        Data)
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId      - Data item to set
    Data        - New value for item

Return Value:

    The old data value

--*/
{
    ULONG_PTR oldVal = 0;

    switch ( InfoId ) 
    {

    //
    // Per processor values internally we maintain value 
    // for all processors
    //

    case ThreadPoolMaxPoolThreads:
        DBG_ASSERT( m_pData->m_cCPU );
        DBG_ASSERT( Data );
        oldVal = (ULONG_PTR)( m_pData->m_cMaxThreads / m_pData->m_cCPU );
        m_pData->m_cMaxThreads = (DWORD)Data * m_pData->m_cCPU;
        break;

    //
    //  Increment or decrement the max thread count.  In this instance, we
    //  do not scale by the number of CPUs
    //

    case ThreadPoolIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &m_pData->m_cMaxThreads );
        oldVal = TRUE;
        break;

    case ThreadPoolDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &m_pData->m_cMaxThreads );
        oldVal = TRUE;
        break;

    case ThreadPoolMaxConcurrency:
        oldVal = (ULONG_PTR)m_pData->m_cConcurrency;
        m_pData->m_cConcurrency = (DWORD)Data;
        break;

    //
    // Stored value is in millisecs. Public data is in seconds.
    //
    case ThreadPoolThreadTimeout:
        oldVal = (ULONG_PTR)(m_pData->m_msThreadTimeout/1000);
        m_pData->m_msThreadTimeout = (DWORD)Data * 1000;
        break;

    default:
        DBG_ASSERT( FALSE );
        break;
    
    } // switch

    return oldVal;

} // ThreadPoolSetInfo()

ULONG_PTR
THREAD_POOL::GetInfo(
    IN THREAD_POOL_INFO InfoId
    )
/*++

Routine Description:

    Sets thread pool configuration data

Arguments:

    InfoId     - Data item to set

Return Value:

    The configuration data value

--*/
{
    ULONG_PTR dwVal = 0;

    switch ( InfoId ) 
    {

      case ThreadPoolMaxPoolThreads:
        DBG_ASSERT( m_pData->m_cCPU );
        dwVal = (ULONG_PTR ) (m_pData->m_cMaxThreads/m_pData->m_cCPU);
        break;

      case ThreadPoolMaxConcurrency:
        dwVal = (ULONG_PTR ) m_pData->m_cConcurrency;
        break;

      //
      // Stored in milliseconds. Public in seconds.
      //
      case ThreadPoolThreadTimeout:
        dwVal = (ULONG_PTR ) (m_pData->m_msThreadTimeout/1000);
        break;

      case ThreadPoolMaxThreadLimit:
        dwVal = (ULONG_PTR ) m_pData->m_cMaxThreadLimit;
        break;
        
      case ThreadPoolAvailableThreads:
        dwVal = (ULONG_PTR)  m_pData->m_cAvailableThreads;
        break;

      default:
        DBG_ASSERT( FALSE );
        break;
    
    } // switch

    return dwVal;
} // ThreadPoolGetInfo()

BOOL
THREAD_POOL::BindIoCompletionCallback(HANDLE FileHandle,                         // handle to file
                                      LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
                                      ULONG Flags                                // reserved
                                      )
/*++

Routine Description:

    Binds given handle to completion port

Arguments:

    FileHandle - handle to bind
    Function - function to call on completion
    Flags - not used

Return Value:

    TRUE if handle bound to port, otherwise FALSE

--*/
{
    DBG_ASSERT( FileHandle && FileHandle != INVALID_HANDLE_VALUE );
    DBG_ASSERT( Function );
    DBG_ASSERT( m_pData->m_hCompPort );

    return ( CreateIoCompletionPort( FileHandle,
                                     m_pData->m_hCompPort,
                                     (ULONG_PTR)Function,
                                     m_pData->m_cConcurrency ) != NULL );
}

BOOL
THREAD_POOL::PostCompletion(IN DWORD dwBytesTransferred,
                            IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                            IN LPOVERLAPPED lpo)
/*++

Routine Description:

    Posts a completion to the port.  Results in an asynchronous callback.

Arguments:

    dwBytesTransferred - bytes transferred for this completions
    Function - function to call on completion
    lpo - overlapped pointer
    

Return Value:

    TRUE if completion posted, otherwise FALSE

--*/
{
    DBG_ASSERT( m_pData->m_hCompPort && m_pData->m_hCompPort != INVALID_HANDLE_VALUE );

    return ( PostQueuedCompletionStatus( m_pData->m_hCompPort,
                                         dwBytesTransferred,
                                         (ULONG_PTR)function,
                                         lpo ) != NULL );
}

//
// Thread pool thread function
//

//static
DWORD
THREAD_POOL_DATA::ThreadPoolThread(
    LPVOID pvThis
    )
/*++

Routine Description:

    Thread pool thread function

Arguments:
    
    pvThis - pointer to THREAD_POOL

Return Value:

    Thread return value (ignored)

--*/
{
    THREAD_POOL_DATA *pThis = reinterpret_cast<THREAD_POOL_DATA*>(pvThis);
    DBG_ASSERT(pThis);
    return pThis->ThreadPoolThread();
}

DWORD
THREAD_POOL_DATA::ThreadPoolThread()
/*++

Routine Description:

    Thread pool thread function

Arguments:
    
    none

Return Value:

    Thread return value (ignored)

--*/
{
    BOOL            fRet;
    DWORD           BytesTransfered;
    LPOVERLAPPED    lpo = NULL;
    DWORD           ReturnCode = ERROR_SUCCESS;
    DWORD           LastError;
    BOOL            fFirst = FALSE;

    LPOVERLAPPED_COMPLETION_ROUTINE CompletionCallback;

    //
    // Increment the total thread count and mark the 
    // threads that we spin up at startup to not timeout
    //
    if (m_cStartupThreads >= InterlockedIncrement( &m_cThreads ))
    {
        fFirst = TRUE;
    }

    for(;;)
    {
        lpo = NULL;
        //
        // try to get a completion with a zero wait before 
        // going through interlockedincrement
        //
        fRet = GetQueuedCompletionStatus( m_hCompPort,      // completion port to wait on
                                          &BytesTransfered, // number of bytes transferred
                                          (ULONG_PTR *)&CompletionCallback,  // function pointer
                                          &lpo,         // buffer to fill
                                          0             // timeout in milliseconds
                                          );
        if (FALSE == fRet && 
            NULL == lpo &&
            WAIT_TIMEOUT == GetLastError())
        {
            //
            // no completion was immediately available
            // wait for the configured timeout
            //
            InterlockedIncrement( &m_cAvailableThreads );
            
            fRet = GetQueuedCompletionStatus( m_hCompPort,  // completion port to wait on
                                              &BytesTransfered, // number of bytes transferred
                                              (ULONG_PTR *)&CompletionCallback, // function pointer
                                              &lpo,             // buffer to fill
                                              m_msThreadTimeout // timeout in milliseconds
                                              );
            
            InterlockedDecrement( &m_cAvailableThreads );
        }

        LastError = fRet ? ERROR_SUCCESS : GetLastError();

        if( fRet || lpo )
        {
            //
            // There was a completion.
            //
            
            if( CompletionCallback == THREAD_POOL_THREAD_EXIT_KEY )
            {
                //
                // signal to exit this thread
                //
                ReturnCode = ERROR_SUCCESS;
                break;
            }

            //
            // This thread is about to go do work so verify that there
            // are still threads available.
            //            
            ThreadPoolCheckThreadStatus();            

            //
            // Call the completion function.
            //            
            CompletionCallback( LastError, BytesTransfered, lpo );
        }
        else
        {
            //
            // No completion, timeout or error.
            //

            //
            // Keep the initial threads alive.
            //
            if( TRUE == fFirst
                && !m_fShutdown )
            {
                continue;
            }

            //
            // Handle time out
            //

            if( !m_fShutdown && LastError == WAIT_TIMEOUT )
            {
                //
                // BUGBUG - Dependency on ntdll
                //
                NTSTATUS NtStatus;
                ULONG    ThreadHasPendingIo;

                NtStatus = NtQueryInformationThread( NtCurrentThread(),
                                                     ThreadIsIoPending,
                                                     &ThreadHasPendingIo,
                                                     sizeof(ThreadHasPendingIo),
                                                     NULL 
                                                     );
                
                //
                // Do not exit if io is pending
                //

                if( NT_SUCCESS( NtStatus ) && ThreadHasPendingIo )
                {
                    continue;
                }
            }

            //
            // Something bad happened or thread timed out.
            //

            ReturnCode = LastError;
            break;
        }

    }

    //
    // Let ThreadPoolTerminate know that all the threads are dead
    //

    InterlockedDecrement( &m_cThreads );
    
    return ReturnCode;
}

BOOL WINAPI
THREAD_POOL_DATA::OkToCreateAnotherThread()
/*++

Routine Description:

    determines whether or not thread pool should have another thread created
    based on shutting down, available threads, current limit, and max limit

Arguments:

    void

Return Value:

    TRUE if another thread is ok to create, otherwise FALSE

--*/
{
    if (!m_fShutdown &&
        (m_cAvailableThreads == 0) &&
        (m_cThreads < m_cMaxThreads) &&
        (m_cThreads < m_cMaxThreadLimit) )
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
THREAD_POOL_DATA::ThreadPoolCheckThreadStatus()
/*++

Routine Description:

    Make sure there is at least one thread in the thread pool.  
    We're fast and loose so a couple of extra threads may be 
    created.



Arguments:

    ThreadParam - usually NULL, may be used to signify
                  special thread status.

Return Value:

    TRUE if successful
    FALSE thread 

--*/
{
    BOOL fRet = TRUE;

    // CODEWORK: Should investigate making this stickier. It should
    // not be quite so easy to create threads.
    

    if ( OkToCreateAnotherThread() )
    {
        DBG_ASSERT( NULL != m_pThreadManager );

        m_pThreadManager->RequestThread(ThreadPoolThread,       // thread function
                                        this            // thread argument
                                        );
    }

    return fRet;
}

/**********************************************************************
    Private function definitions
**********************************************************************/

DWORD
I_ThreadPoolReadRegDword(
   IN HKEY     hKey,
   IN LPCTSTR  pszValueName,
   IN DWORD    dwDefaultValue 
   )
/*++

Routine Description:

    Reads a DWORD value from the registry

Arguments:
    
    hKey - Opened registry key to read
    
    pszValueName - The name of the value.

    dwDefaultValue - The default value to use if the
        value cannot be read.


Return Value:

    DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;
    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hKey != NULL ) 
    {
        err = RegQueryValueEx( hKey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer 
                               );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) 
        {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3tp\thread_manager.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:    

    thread_manager.hxx

Abstract:
    
    Provides thread creation and cleanup management

Author:

    Jeffrey Wall (jeffwall)     11-28-2000

Revision History:
    
    
    
--*/

#ifndef _THREADMANAGER_H_
#define _THREADMANAGER_H_

#include <thread_pool.h>

typedef void (WINAPI *PTHREAD_STOP_ROUTINE)(PVOID);
typedef PTHREAD_STOP_ROUTINE LPTHREAD_STOP_ROUTINE;
typedef BOOL (WINAPI *PTHREAD_DECISION_ROUTINE )(PVOID);
typedef PTHREAD_DECISION_ROUTINE LPTHREAD_DECISION_ROUTINE;

#define SIGNATURE_THREAD_MANAGER          ((DWORD) 'NAMT')
#define SIGNATURE_THREAD_MANAGER_FREE     ((DWORD) 'xAMT')
#define SIGNATURE_THREAD_PARAM            ((DWORD) 'RAPT')
#define SIGNATURE_THREAD_PARAM_FREE       ((DWORD) 'xAPT')

class THREAD_MANAGER
{
private:
    DWORD m_dwSignature;

public:
    static HRESULT CreateThreadManager(THREAD_MANAGER ** ppThreadManager,
                                       THREAD_POOL * pPool,
                                       THREAD_POOL_DATA * pPoolData);
    
    VOID TerminateThreadManager(LPTHREAD_STOP_ROUTINE lpStopAddress,
                                LPVOID lpParameter);

    BOOL CreateThread(LPTHREAD_START_ROUTINE lpStartAddress,
                      LPVOID lpParameter);

    VOID RequestThread(LPTHREAD_START_ROUTINE lpStartAddress,
                       LPVOID lpStartParameter);

private:
    // use create and terminate
    THREAD_MANAGER(THREAD_POOL * pPool,
                   THREAD_POOL_DATA * pPoolData);
    ~THREAD_MANAGER();

    // not implemented
    THREAD_MANAGER(const THREAD_MANAGER&);
    THREAD_MANAGER& operator=(const THREAD_MANAGER&);

    HRESULT Initialize();

    VOID DrainThreads(LPTHREAD_STOP_ROUTINE lpStopAddress,
                      LPVOID lpParameter);

    /*++
    Struct Description:
        Storage for parameters passed to ThreadManagerThread

    Members:
        pThreadFunc - thread function to call
        pvThreadArg - arguments to pass to thread function
        pThreadManager - pointer to ThreadManager associated with current thread
        hThreadSelf - handle returned from call to CreateThread
        dwRequestTime - time that thread request was made
    --*/
    struct THREAD_PARAM
    {
        THREAD_PARAM() : 
            dwSignature(SIGNATURE_THREAD_PARAM),
            pThreadFunc(NULL),
            pvThreadArg(NULL),
            pThreadManager(NULL),
            dwRequestTime(NULL),
            fCallbackOnCreation(FALSE)
        {
        }
        ~THREAD_PARAM()
        {
            DBG_ASSERT(SIGNATURE_THREAD_PARAM == dwSignature);
            dwSignature = SIGNATURE_THREAD_PARAM_FREE;
        }

        DWORD                   dwSignature;
        LPTHREAD_START_ROUTINE  pThreadFunc;
        LPVOID                  pvThreadArg;
        THREAD_MANAGER         *pThreadManager;
        DWORD                   dwRequestTime;
        BOOL                    fCallbackOnCreation;
    };
    
    static DWORD ThreadManagerThread(LPVOID);
    static VOID ControlTimerCallback(PVOID lpParameter, 
                                      BOOLEAN TimerOrWaitFired);

    VOID DetermineThreadAction();
    BOOL DoThreadCreation(THREAD_PARAM * pParam);

    VOID CreatedSuccessfully(THREAD_PARAM * pParam);
    VOID RemoveThread(THREAD_PARAM * pParam);

    VOID DoThreadParking();
    BOOL DoThreadUnParking();
    static VOID ParkThread(DWORD dwErrorCode,
                                  DWORD dwNumberOfBytesTransferred,
                                  LPOVERLAPPED lpo);

    CRITICAL_SECTION        m_CriticalSection;

    BOOL                    m_fShuttingDown;
    BOOL                    m_fWaitingForCreationCallback;

    HANDLE                  m_hTimer;
    DWORD                   m_dwTimerPeriod;

    THREAD_PARAM           *m_pParam;

    ULONG                   m_ulPerSecondContextSwitchMax;
    ULONG                   m_ulContextSwitchCount;

    LONG                    m_lTotalThreads;

    LONG                    m_lParkedThreads;
    HANDLE                  m_hParkEvent;
    HANDLE                  m_hShutdownEvent;

    THREAD_POOL            *m_pPool;
    THREAD_POOL_DATA       *m_pPoolData;
};

#endif // _THREADMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wamps\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wam\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Wam.rc
//
#define IDS_PROJNAME                    100
#define IDR_WAM                         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3wp\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

#define DEBUG_TRACE             0x10000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\w3wp\w3wp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       w3wp.cxx

   Abstract:
       Main module for IIS compatible worker process
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS compatible worker process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "wpif.h"
#include "ulw3.h"
#include "../../../svcs/mdadmin/ntsec.h"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

//
// Configuration parameters registry key.
//

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";


class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
#else
        UNREFERENCED_PARAMETER(pszModule);
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};

//
// W3 DLL which does all the work
//

extern "C" INT
__cdecl
wmain(
    INT                     argc,
    PWSTR                   argv[]
    )
{
    DEBUG_WRAPPER   dbgWrapper( "w3wp" );
    HRESULT         hr;
    HMODULE         hModule = NULL;
    PFN_ULW3_ENTRY  pEntry = NULL;
    ULONG           rcRet = CLEAN_WORKER_PROCESS_EXIT_CODE;
    BOOL            fCoInit = FALSE;

    //
    // We don't want the worker process to get stuck in a dialog box
    // if it goes awry.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX );

    IF_DEBUG( TRACE) 
    {

        //
        // Print out our process affinity mask on debug builds.
        //


        BOOL fRet = TRUE;
        DWORD_PTR ProcessAffinityMask = 0;
        DWORD_PTR SystemAffinityMask = 0;

        fRet = GetProcessAffinityMask(
                    GetCurrentProcess(),
                    &ProcessAffinityMask,
                    &SystemAffinityMask
                    );

        DBGPRINTF(( DBG_CONTEXT, "Process affinity mask: %p\n", ProcessAffinityMask ));
        
    }
    
    //
    // Move this process to the WindowStation (with full access to all) in
    // which we would have been if running in inetinfo.exe (look at
    // iis\svcs\mdadmin\ntsec.cxx)
    //
    HWINSTA hWinSta = OpenWindowStationA(SZ_IIS_WINSTA, FALSE, WINSTA_ALL);
    if (hWinSta == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // Set this as this process's window station
    //
    if (!SetProcessWindowStation(hWinSta))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Finished;
    }

    //
    // Do some COM junk
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    fCoInit = TRUE;

    hr = CoInitializeSecurity(  NULL
                            ,   -1
                            ,   NULL
                            ,   NULL
                            ,   RPC_C_AUTHN_LEVEL_DEFAULT
                            ,   RPC_C_IMP_LEVEL_IMPERSONATE  
                            ,   NULL
                            ,   EOAC_NONE
                            ,   NULL);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeSecurity().  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
 
    
    //
    // Load the ULW3 DLL which does all the work
    //

    hModule = LoadLibrary( ULW3_DLL_NAME );
    if ( hModule == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error loading W3 service dll '%ws'.  Error = %d\n",
                    ULW3_DLL_NAME,
                    GetLastError() ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    pEntry = (PFN_ULW3_ENTRY) GetProcAddress( hModule, 
                                              ULW3_DLL_ENTRY );
    if ( pEntry == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Could not find entry point '%s'.  Error = %d\n",
                    ULW3_DLL_ENTRY,
                    GetLastError() ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    hr = pEntry( argc, 
                 argv, 
                 FALSE );               // Compatibility Mode = FALSE
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error executing W3WP.  hr = %x\n",
                    hr ));
                    
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }

Finished:

    DBG_ASSERT(SUCCEEDED(hr));

    //
    // Cleanup any lingering COM objects before unloading
    //
    
    if ( fCoInit )
    {
        CoUninitialize();
    }

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    }
    
    return CLEAN_WORKER_PROCESS_EXIT_CODE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wamps\iwam_i_stub.c ===
#include "IWam_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wam\wam.cpp ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
       wam.cpp

   Abstract:
       This module implements the exported routines for WAM object

   Author:
       David Kaplan    ( DaveK )     26-Feb-1997
       Wade Hilmo      ( WadeH )     08-Sep-2000

   Environment:
       User Mode - Win32

   Project:
       Wam DLL

--*/

//
// Following are the notes from the original MSDEV generated file
// Note: Proxy/Stub Information
//        To merge the proxy/stub code into the object DLL, add the file
//        dlldatax.c to the project.  Make sure precompiled headers
//        are turned off for this file, and add _MERGE_PROXYSTUB to the
//        defines for the project.
//
//        If you are not running WinNT4.0 or Win95 with DCOM, then you
//        need to remove the following define from dlldatax.c
//        #define _WIN32_WINNT 0x0400
//
//        Further, if you are running MIDL without /Oicf switch, you also
//        need to remove the following define from dlldatax.c.
//        #define USE_STUBLESS_PROXY
//
//        Modify the custom build rule for Wam.idl by adding the following
//        files to the Outputs.
//            Wam_p.c
//            dlldata.c
//        To build a separate proxy/stub DLL,
//        run nmake -f Wamps.mk in the project directory.

// BEGIN mods
// Post-wizard mods appear within BEGIN mods ... END mods
// END mods

#include "precomp.hxx"

#include <w3isapi.h>
#include <isapi_context.hxx>
#include "wamobj.hxx"
#include "IWam_i.c"
#include "wamccf.hxx"

#include <atlbase.h>

// BEGIN mods
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
// END mods

/************************************************************
 *  Global Variables
 ************************************************************/

const CHAR g_pszModuleName[] = "WAM";
const CHAR g_pszWamRegLocation[] =
  "System\\CurrentControlSet\\Services\\W3Svc\\WAM";

HMODULE                         WAM::sm_hIsapiModule;
PFN_ISAPI_TERM_MODULE           WAM::sm_pfnTermIsapiModule;
PFN_ISAPI_PROCESS_REQUEST       WAM::sm_pfnProcessIsapiRequest;
PFN_ISAPI_PROCESS_COMPLETION    WAM::sm_pfnProcessIsapiCompletion;


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Wam, WAM)
END_OBJECT_MAP()

// BEGIN mods

WAM_CCF_MODULE _WAMCCFModule;

DECLARE_PLATFORM_TYPE();
DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
// END mods

/************************************************************
 *  Type Definitions  
 ************************************************************/
// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";

class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule )
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule );
#else
        UNREFERENCED_PARAMETER( pszModule );
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};

class CWamModule _Module;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    DWORD dwErr = NO_ERROR;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {

        //
        // BEGIN mods
        //
    
        // From ATL generated
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        // End of ATL generated

        _WAMCCFModule.Init();

        // END mods

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if ( NULL != lpReserved )
        {
            
            //
            // Only cleanup if there is a FreeLibrary() call
            //
         
            return ( TRUE);
        }
        _WAMCCFModule.Term();
        _Module.Term();

        // BEGIN mods

        DELETE_DEBUG_PRINT_OBJECT();
        // END mods
    }

    return (dwErr == NO_ERROR);
} // DllMain()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    if (ppv == NULL) {
       return ( NULL);
    }
    *ppv = NULL;    // reset the value before getting inside.

    if (ppv == NULL) {
        return ( E_POINTER);
    }
    *ppv = NULL;   // set the incoming value to be invalid entry

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    hr = _WAMCCFModule.GetClassObject(rclsid, riid, ppv);

    // BEGIN mods
    if (hr == CLASS_E_CLASSNOTAVAILABLE)
    {
        // If request for standard CF failed -> try custom
        hr = _Module.GetClassObject(CLSID_Wam, riid, ppv);
    }
    // END mods

    return ( hr);

} // DllGetClassObject()



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}

HRESULT
WAM::WamProcessIsapiRequest(
    BYTE *pCoreData,
    DWORD cbCoreData,
    IIsapiCore *pIsapiCore,
    DWORD *pdwHseResult
    )
/*++

Routine Description:

    Processes an ISAPI request

Arguments:

    pCoreData    - The core data from the server for the request
    cbCoreData   - The size of pCoreData
    pIsapiCore   - The IIsapiCore interface pointer for this request
    pdwHseResult - Upon return, contains the return from HttpExtensionProc

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    pIsapiCore->AddRef();

    hr = sm_pfnProcessIsapiRequest(
        pIsapiCore,
        (ISAPI_CORE_DATA*)pCoreData,
        pdwHseResult
        );

    pIsapiCore->Release();

    return hr;
}

HRESULT
WAM::WamProcessIsapiCompletion(
    DWORD64 IsapiContext,
    DWORD cbCompletion,
    DWORD cbCompletionStatus
    )
/*++

Routine Description:

    Processes an ISAPI I/O completion

Arguments:

    IsapiContext        - The ISAPI_CONTEXT that identifies the request
    cbCompletion        - The number of bytes associated with the completion
    cbCompletionStatus  - The status code associated with the completion

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;

    hr = sm_pfnProcessIsapiCompletion(
        IsapiContext,
        cbCompletion,
        cbCompletionStatus
        );

    return hr;
}

HRESULT
WAM::WamInitProcess(
    BYTE *szIsapiModule,
    DWORD cbIsapiModule,
    DWORD *pdwProcessId,
    LPSTR szClsid,
    LPSTR szIsapiHandlerInstance,
    DWORD dwCallingProcess
    )
/*++

Routine Description:

    Initializes WAM for the host process.  This includes loading
    w3isapi.dll and getting function pointers for the relevant stuff

Arguments:

    szIsapiModule          - The full path (UNICODE) of w3isapi.dll
    cbIsapiModule          - The number of bytes in the above path
    pdwProcessId           - Upon return, contains the process ID of the
                             host process
    szClsid                - The CLSID of the WAM object being initialized
    szIsapiHandlerInstance - The instance ID of the W3_ISAPI_HANDLER that's
                             initializing this WAM.
    dwCallingProcess       - The process ID of this function's caller


Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NOERROR;
    PFN_ISAPI_INIT_MODULE   pfnInit = NULL;

    //
    // Initialize IISUTIL
    //

    if ( !InitializeIISUtil() )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing IISUTIL.  hr = %x\n",
                    hr ));

        goto ErrorExit;
    }
    
    //
    // Load and initialize the ISAPI module
    //

    sm_hIsapiModule = LoadLibraryW( (LPWSTR)szIsapiModule );
    if( sm_hIsapiModule == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ErrorExit;
    }

    sm_pfnTermIsapiModule = 
        (PFN_ISAPI_TERM_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_TERM_MODULE 
                                               );

    sm_pfnProcessIsapiRequest = 
        (PFN_ISAPI_PROCESS_REQUEST)GetProcAddress( sm_hIsapiModule,
                                                   ISAPI_PROCESS_REQUEST
                                                   );

    sm_pfnProcessIsapiCompletion =
        (PFN_ISAPI_PROCESS_COMPLETION)GetProcAddress( sm_hIsapiModule,
                                                      ISAPI_PROCESS_COMPLETION
                                                      );

    if( !sm_pfnTermIsapiModule ||
        !sm_pfnProcessIsapiRequest ||
        !sm_pfnProcessIsapiCompletion )
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    pfnInit = 
        (PFN_ISAPI_INIT_MODULE)GetProcAddress( sm_hIsapiModule, 
                                               ISAPI_INIT_MODULE 
                                               );
    if( !pfnInit )
    {
        hr = E_FAIL;
        goto ErrorExit;
    }

    hr = pfnInit(
        szClsid,
        szIsapiHandlerInstance,
        dwCallingProcess
        );

    if( FAILED(hr) )
    {
        goto ErrorExit;
    }

    //
    // Set the process ID for the process hosting this object
    //
    
    *pdwProcessId = GetCurrentProcessId();
    
    return hr;

ErrorExit:

    DBG_ASSERT( FAILED( hr ) );

    return hr;
}

HRESULT
WAM::WamUninitProcess(
    VOID
    )
/*++

Routine Description:

    Uninitializes WAM for the host process.  This function ultimately
    causes TerminateExtension to get called for each loaded extension.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    
    DBG_ASSERT( sm_pfnTermIsapiModule );
    DBG_ASSERT( sm_hIsapiModule );

    if( sm_pfnTermIsapiModule )
    {
        sm_pfnTermIsapiModule();
        sm_pfnTermIsapiModule = NULL;
    }

    if( sm_hIsapiModule )
    {
        FreeLibrary( sm_hIsapiModule );
        sm_hIsapiModule = NULL;
    }

    TerminateIISUtil();

    return hr;
}

HRESULT
WAM::WamMarshalAsyncReadBuffer( 
    DWORD64 IsapiContext,
    BYTE *pBuffer,
    DWORD cbBuffer
    )
/*++

Routine Description:

    Receives a buffer to be passed to a request.  This function will be
    called just prior to an I/O completion in the case where and OOP
    extension does an asynchronous ReadClient.

Arguments:

    IsapiContext - The ISAPI_CONTEXT that identifies the request
    pBuffer      - The data buffer
    cbBuffer     - The size of pBuffer

Return Value:

    HRESULT

--*/
{
    ISAPI_CONTEXT * pIsapiContext;
    VOID *          pReadBuffer;

    pIsapiContext = reinterpret_cast<ISAPI_CONTEXT*>( IsapiContext );

    DBG_ASSERT( pIsapiContext );
    DBG_ASSERT( pIsapiContext->QueryIoState() == AsyncReadPending );

    pReadBuffer = pIsapiContext->QueryAsyncIoBuffer();

    DBG_ASSERT( pReadBuffer != NULL );

    memcpy( pReadBuffer, pBuffer, cbBuffer );

    pIsapiContext->SetAsyncIoBuffer( NULL );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\wamps\iwam_p_stub.c ===
#include "IWam_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\import\inc\catalog.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for catalog.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __catalog_h__
#define __catalog_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISimpleTableDispenser2_FWD_DEFINED__
#define __ISimpleTableDispenser2_FWD_DEFINED__
typedef interface ISimpleTableDispenser2 ISimpleTableDispenser2;
#endif 	/* __ISimpleTableDispenser2_FWD_DEFINED__ */


#ifndef __IMetabaseSchemaCompiler_FWD_DEFINED__
#define __IMetabaseSchemaCompiler_FWD_DEFINED__
typedef interface IMetabaseSchemaCompiler IMetabaseSchemaCompiler;
#endif 	/* __IMetabaseSchemaCompiler_FWD_DEFINED__ */


#ifndef __ICatalogErrorLogger_FWD_DEFINED__
#define __ICatalogErrorLogger_FWD_DEFINED__
typedef interface ICatalogErrorLogger ICatalogErrorLogger;
#endif 	/* __ICatalogErrorLogger_FWD_DEFINED__ */


#ifndef __ICatalogErrorLogger2_FWD_DEFINED__
#define __ICatalogErrorLogger2_FWD_DEFINED__
typedef interface ICatalogErrorLogger2 ICatalogErrorLogger2;
#endif 	/* __ICatalogErrorLogger2_FWD_DEFINED__ */


#ifndef __ISimpleTableRead2_FWD_DEFINED__
#define __ISimpleTableRead2_FWD_DEFINED__
typedef interface ISimpleTableRead2 ISimpleTableRead2;
#endif 	/* __ISimpleTableRead2_FWD_DEFINED__ */


#ifndef __ISimpleTableWrite2_FWD_DEFINED__
#define __ISimpleTableWrite2_FWD_DEFINED__
typedef interface ISimpleTableWrite2 ISimpleTableWrite2;
#endif 	/* __ISimpleTableWrite2_FWD_DEFINED__ */


#ifndef __ISimpleTableAdvanced_FWD_DEFINED__
#define __ISimpleTableAdvanced_FWD_DEFINED__
typedef interface ISimpleTableAdvanced ISimpleTableAdvanced;
#endif 	/* __ISimpleTableAdvanced_FWD_DEFINED__ */


#ifndef __ISnapshotManager_FWD_DEFINED__
#define __ISnapshotManager_FWD_DEFINED__
typedef interface ISnapshotManager ISnapshotManager;
#endif 	/* __ISnapshotManager_FWD_DEFINED__ */


#ifndef __ISimpleTableController_FWD_DEFINED__
#define __ISimpleTableController_FWD_DEFINED__
typedef interface ISimpleTableController ISimpleTableController;
#endif 	/* __ISimpleTableController_FWD_DEFINED__ */


#ifndef __IAdvancedTableDispenser_FWD_DEFINED__
#define __IAdvancedTableDispenser_FWD_DEFINED__
typedef interface IAdvancedTableDispenser IAdvancedTableDispenser;
#endif 	/* __IAdvancedTableDispenser_FWD_DEFINED__ */


#ifndef __ISimpleTableInterceptor_FWD_DEFINED__
#define __ISimpleTableInterceptor_FWD_DEFINED__
typedef interface ISimpleTableInterceptor ISimpleTableInterceptor;
#endif 	/* __ISimpleTableInterceptor_FWD_DEFINED__ */


#ifndef __ISimplePlugin_FWD_DEFINED__
#define __ISimplePlugin_FWD_DEFINED__
typedef interface ISimplePlugin ISimplePlugin;
#endif 	/* __ISimplePlugin_FWD_DEFINED__ */


#ifndef __IInterceptorPlugin_FWD_DEFINED__
#define __IInterceptorPlugin_FWD_DEFINED__
typedef interface IInterceptorPlugin IInterceptorPlugin;
#endif 	/* __IInterceptorPlugin_FWD_DEFINED__ */


#ifndef __ISimpleTableEvent_FWD_DEFINED__
#define __ISimpleTableEvent_FWD_DEFINED__
typedef interface ISimpleTableEvent ISimpleTableEvent;
#endif 	/* __ISimpleTableEvent_FWD_DEFINED__ */


#ifndef __ISimpleTableAdvise_FWD_DEFINED__
#define __ISimpleTableAdvise_FWD_DEFINED__
typedef interface ISimpleTableAdvise ISimpleTableAdvise;
#endif 	/* __ISimpleTableAdvise_FWD_DEFINED__ */


#ifndef __ISimpleTableEventMgr_FWD_DEFINED__
#define __ISimpleTableEventMgr_FWD_DEFINED__
typedef interface ISimpleTableEventMgr ISimpleTableEventMgr;
#endif 	/* __ISimpleTableEventMgr_FWD_DEFINED__ */


#ifndef __ISimpleTableFileChange_FWD_DEFINED__
#define __ISimpleTableFileChange_FWD_DEFINED__
typedef interface ISimpleTableFileChange ISimpleTableFileChange;
#endif 	/* __ISimpleTableFileChange_FWD_DEFINED__ */


#ifndef __ISimpleTableFileAdvise_FWD_DEFINED__
#define __ISimpleTableFileAdvise_FWD_DEFINED__
typedef interface ISimpleTableFileAdvise ISimpleTableFileAdvise;
#endif 	/* __ISimpleTableFileAdvise_FWD_DEFINED__ */


#ifndef __ISimpleTableDispenserWiring_FWD_DEFINED__
#define __ISimpleTableDispenserWiring_FWD_DEFINED__
typedef interface ISimpleTableDispenserWiring ISimpleTableDispenserWiring;
#endif 	/* __ISimpleTableDispenserWiring_FWD_DEFINED__ */


#ifndef __IShellInitialize_FWD_DEFINED__
#define __IShellInitialize_FWD_DEFINED__
typedef interface IShellInitialize IShellInitialize;
#endif 	/* __IShellInitialize_FWD_DEFINED__ */


#ifndef __ISimpleClientTableOptimizer_FWD_DEFINED__
#define __ISimpleClientTableOptimizer_FWD_DEFINED__
typedef interface ISimpleClientTableOptimizer ISimpleClientTableOptimizer;
#endif 	/* __ISimpleClientTableOptimizer_FWD_DEFINED__ */


#ifndef __ISimpleTableMarshall_FWD_DEFINED__
#define __ISimpleTableMarshall_FWD_DEFINED__
typedef interface ISimpleTableMarshall ISimpleTableMarshall;
#endif 	/* __ISimpleTableMarshall_FWD_DEFINED__ */


#ifndef __ISimpleTableTransform_FWD_DEFINED__
#define __ISimpleTableTransform_FWD_DEFINED__
typedef interface ISimpleTableTransform ISimpleTableTransform;
#endif 	/* __ISimpleTableTransform_FWD_DEFINED__ */


#ifndef __ISimpleTableMerge_FWD_DEFINED__
#define __ISimpleTableMerge_FWD_DEFINED__
typedef interface ISimpleTableMerge ISimpleTableMerge;
#endif 	/* __ISimpleTableMerge_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_catalog_0000 */
/* [local] */ 

#define fST_LOS_NONE                 0x00000000L
#define fST_LOS_CONFIGWORK           0x00000001L
#define fST_LOS_READWRITE            0x00000002L
#define fST_LOS_UNPOPULATED          0x00000010L
#define fST_LOS_REPOPULATE           0x00000020L
#define fST_LOS_MARSHALLABLE         0x00000100L
#define fST_LOS_NOLOGIC              0x00010000L
#define fST_LOS_COOKDOWN             0x00020000L
#define fST_LOS_NOMERGE              0x00040000L
#define fST_LOS_NOCACHEING           0x00080000L
#define fST_LOS_NODEFAULTS           0x00100000L
#define fST_LOS_EXTENDEDSCHEMA       0x00200000L
#define fST_LOS_DETAILED_ERROR_TABLE 0x00400000L
#define fST_LOS_NO_LOGGING           0x00800000L
#define fST_LOSI_CLIENTSIDE          0x01000000L
#define eST_QUERYFORMAT_CELLS        3L
#define eST_QUERYFORMAT_SQL          4L
typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_catalog_0000_0001
    {
    LPVOID pData;
    DWORD eOperator;
    ULONG iCell;
    DWORD dbType;
    ULONG cbSize;
    } 	STQueryCell;

#define eST_OP_EQUAL                 2L
#define eST_OP_NOTEQUAL              3L
#define iST_CELL_SPECIAL             0xF0000000L
#define iST_CELL_FILE                0xF0000001L
#define iST_CELL_COMPUTER            0xF0000002L
#define iST_CELL_CLUSTER             0xF0000003L
#define iST_CELL_INDEXHINT           0xF0000004L
#define iST_CELL_SNID                0xF0000005L
#define iST_CELL_TABLEID             0xF0000006L
#define iST_CELL_cbminCACHE          0xF0000007L
#define iST_CELL_SELECTOR            0xF0000008L
#define iST_CELL_SCHEMAFILE          0xF0000009L
#define iST_CELL_LOCATION            0xF000000AL
#define DEX_MPK                      L"MPK" 
#define fST_SNID_NONE                0x00000000L
typedef /* [public][public] */ struct __MIDL___MIDL_itf_catalog_0000_0002
    {
    LPWSTR wszDatabase;
    LPWSTR wszTable;
    STQueryCell *pQueryData;
    LPVOID pQueryMeta;
    DWORD eQueryFormat;
    } 	MultiSubscribe;

const HRESULT E_ST_INVALIDTABLE      = 0x8021080A;
const HRESULT E_ST_INVALIDQUERY      = 0x8021080B;
const HRESULT E_ST_QUERYNOTSUPPORTED = 0x8021080C;
const HRESULT E_ST_LOSNOTSUPPORTED   = 0x8021080D;
const HRESULT E_ST_INVALIDMETA       = 0x8021080E;
const HRESULT E_ST_INVALIDWIRING     = 0x8021080F;
const HRESULT E_ST_OMITDISPENSER     = 0x80210810;
const HRESULT E_ST_OMITLOGIC         = 0x80210811;
const HRESULT E_ST_INVALIDSNID       = 0x80210812;
const HRESULT E_ST_INVALIDCALL       = 0x80210815;
const HRESULT E_ST_NOMOREROWS        = 0x80210816;
const HRESULT E_ST_NOMORECOLUMNS     = 0x80210817;
const HRESULT E_ST_NOMOREERRORS      = 0x80210818;
const HRESULT E_ST_BADVERSION        = 0x80210819;
const HRESULT E_SDTXML_NOTSUPPORTED                               = 0x80210511;
const HRESULT E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER         = 0x80210512;
const HRESULT E_SDTXML_XML_FAILED_TO_PARSE                        = 0x80210514;
const HRESULT E_SDTXML_WRONG_XMLSCHEMA                            = 0x80210515;
const HRESULT E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST                = 0x80210516;
const HRESULT E_SDTXML_DONE                                       = 0x80210517;
const HRESULT E_SDTXML_UNEXPECTED                                 = 0x80210520;
const HRESULT E_SDTXML_FILE_NOT_SPECIFIED                         = 0x80210522;
const HRESULT E_SDTXML_LOGICAL_ERROR_IN_XML                       = 0x80210523;
const HRESULT E_SDTXML_UPDATES_NOT_ALLOWED_ON_THIS_KIND_OF_TABLE  = 0x80210524;
const HRESULT E_SDTXML_NOT_IN_CACHE                               = 0x80210525;
const HRESULT E_SDTXML_INVALID_ENUM_OR_FLAG                       = 0x80210526;
const HRESULT E_SDTXML_FILE_NOT_WRITABLE                          = 0x80210527;
const HRESULT E_ST_ERRORTABLE        = 0x8021081E;
const HRESULT E_ST_DETAILEDERRS      = 0x8021081F;
const HRESULT E_ST_VALUENEEDED       = 0x80210820;
const HRESULT E_ST_VALUEINVALID      = 0x80210821;
const HRESULT E_ST_SIZENEEDED        = 0x80210825;
const HRESULT E_ST_SIZEEXCEEDED      = 0x80210826;
const HRESULT E_ST_PKNOTCHANGABLE    = 0x8021082A;
const HRESULT E_ST_FKDOESNOTEXIST    = 0x8021082B;
const HRESULT E_ST_ROWDOESNOTEXIST   = 0x80210830;
const HRESULT E_ST_ROWALREADYEXISTS  = 0x80210831;
const HRESULT E_ST_ROWALREADYUDPATED = 0x80210832;
const HRESULT E_ST_INVALIDEXTENDEDMETA= 0x80210833;
const HRESULT E_ST_ROWCONFLICT       = 0x80210834;
const HRESULT E_ST_INVALIDSELECTOR  = 0x80210850;
const HRESULT E_ST_MULTIPLESELECTOR = 0x80210851;
const HRESULT E_ST_NOCONFIGSTORES   = 0x80210852;
const HRESULT E_ST_UNKNOWNPROTOCOL  = 0x80210853;
const HRESULT E_ST_UNKNOWNWEBSERVER = 0x80210854;
const HRESULT E_ST_UNKNOWNDIRECTIVE = 0x80210855;
const HRESULT E_ST_DISALLOWOVERRIDE = 0x80210856;
const HRESULT E_ST_NEEDDIRECTIVE    = 0x80210857;
const HRESULT E_ST_INVALIDSTATE     = 0x80210860;
const HRESULT E_ST_COMPILEFAILED    = 0x80210861;
const HRESULT E_ST_INVALIDBINFILE   = 0x80210862;
const HRESULT E_ST_COMPILEWARNING   = 0x80210863;
const HRESULT E_ST_INVALIDCOOKIE    = 0x80210870;
typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_catalog_0000_0003
    {
    ULONG iRow;
    HRESULT hr;
    ULONG iColumn;
    } 	STErr;

#define iST_ERROR_ALLCOLUMNS         ~0
#define iST_ERROR_ALLROWS            ~0
#include <oledb.h>
typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_catalog_0000_0004
    {
    DWORD dbType;
    ULONG cbSize;
    DWORD fMeta;
    } 	SimpleColumnMeta;

typedef DWORD SNID;

#define fST_COLUMNSTATUS_CHANGED     0x000000001
#define fST_COLUMNSTATUS_DEFAULTED   0x000000004
#define fST_COLUMNSTATUS_NONNULL     0x000000002
#define maskfST_COLUMNSTATUS         0x000000007
// Row actions (advanced use):
#define eST_ROW_IGNORE               0L
#define eST_ROW_INSERT               1L
#define eST_ROW_UPDATE               2L
#define eST_ROW_DELETE               3L
#define fST_POPCONTROL_RETAINREAD    0x00000001
#define fST_POPCONTROL_RETAINERRS    0x00000002
#define maskfST_CONTROL              0x00000003
#define fST_FILECHANGE_RECURSIVE     0x000000001
extern HRESULT GetSimpleTableDispenser(LPWSTR wszProductName, DWORD dwReserved, ISimpleTableDispenser2** o_ppISTDisp);
extern void InitializeSimpleTableDispenser(void);
extern HRESULT CookDown(LPWSTR wszProductName);
extern HRESULT RecoverFromInetInfoCrash(LPWSTR wszProductName);
extern HRESULT UninitCookdown(LPWSTR wszProductName,BOOL   bDoNotTouchMetabase);
extern UINT GetMachineConfigDirectory(LPWSTR wszProduct, LPWSTR lpBuffer, UINT uSize);
extern HRESULT UnloadDispenserDll(LPWSTR wszProduct);
extern HRESULT PostProcessChanges(ISimpleTableWrite2  *i_pISTWrite);


extern RPC_IF_HANDLE __MIDL_itf_catalog_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0000_v0_0_s_ifspec;

#ifndef __ISimpleTableDispenser2_INTERFACE_DEFINED__
#define __ISimpleTableDispenser2_INTERFACE_DEFINED__

/* interface ISimpleTableDispenser2 */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableDispenser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e1a560e-18b6-11d3-8fe3-00c04fc2e0c7")
    ISimpleTableDispenser2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTable( 
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ LPVOID *o_ppvSimpleTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableDispenser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableDispenser2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableDispenser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableDispenser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTable )( 
            ISimpleTableDispenser2 * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        END_INTERFACE
    } ISimpleTableDispenser2Vtbl;

    interface ISimpleTableDispenser2
    {
        CONST_VTBL struct ISimpleTableDispenser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableDispenser2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableDispenser2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableDispenser2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableDispenser2_GetTable(This,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppvSimpleTable)	\
    (This)->lpVtbl -> GetTable(This,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppvSimpleTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableDispenser2_GetTable_Proxy( 
    ISimpleTableDispenser2 * This,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ DWORD i_eQueryFormat,
    /* [in] */ DWORD i_fServiceRequests,
    /* [out] */ LPVOID *o_ppvSimpleTable);


void __RPC_STUB ISimpleTableDispenser2_GetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableDispenser2_INTERFACE_DEFINED__ */


#ifndef __IMetabaseSchemaCompiler_INTERFACE_DEFINED__
#define __IMetabaseSchemaCompiler_INTERFACE_DEFINED__

/* interface IMetabaseSchemaCompiler */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IMetabaseSchemaCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8B71BC6C-B5F9-4068-888C-4C67CC16C2D3")
    IMetabaseSchemaCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Compile( 
            /* [in] */ LPCWSTR i_wszExtensionsXmlFile,
            /* [in] */ LPCWSTR i_wszResultingOutputXmlFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBinFileName( 
            /* [out] */ LPWSTR o_wszBinFileName,
            /* [out] */ ULONG *io_pcchSizeBinFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBinPath( 
            /* [in] */ LPCWSTR i_wszBinPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBinFileName( 
            /* [in] */ LPCWSTR i_wszBinFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetabaseSchemaCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetabaseSchemaCompiler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetabaseSchemaCompiler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetabaseSchemaCompiler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Compile )( 
            IMetabaseSchemaCompiler * This,
            /* [in] */ LPCWSTR i_wszExtensionsXmlFile,
            /* [in] */ LPCWSTR i_wszResultingOutputXmlFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetBinFileName )( 
            IMetabaseSchemaCompiler * This,
            /* [out] */ LPWSTR o_wszBinFileName,
            /* [out] */ ULONG *io_pcchSizeBinFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBinPath )( 
            IMetabaseSchemaCompiler * This,
            /* [in] */ LPCWSTR i_wszBinPath);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBinFileName )( 
            IMetabaseSchemaCompiler * This,
            /* [in] */ LPCWSTR i_wszBinFileName);
        
        END_INTERFACE
    } IMetabaseSchemaCompilerVtbl;

    interface IMetabaseSchemaCompiler
    {
        CONST_VTBL struct IMetabaseSchemaCompilerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetabaseSchemaCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMetabaseSchemaCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMetabaseSchemaCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMetabaseSchemaCompiler_Compile(This,i_wszExtensionsXmlFile,i_wszResultingOutputXmlFile)	\
    (This)->lpVtbl -> Compile(This,i_wszExtensionsXmlFile,i_wszResultingOutputXmlFile)

#define IMetabaseSchemaCompiler_GetBinFileName(This,o_wszBinFileName,io_pcchSizeBinFileName)	\
    (This)->lpVtbl -> GetBinFileName(This,o_wszBinFileName,io_pcchSizeBinFileName)

#define IMetabaseSchemaCompiler_SetBinPath(This,i_wszBinPath)	\
    (This)->lpVtbl -> SetBinPath(This,i_wszBinPath)

#define IMetabaseSchemaCompiler_ReleaseBinFileName(This,i_wszBinFileName)	\
    (This)->lpVtbl -> ReleaseBinFileName(This,i_wszBinFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMetabaseSchemaCompiler_Compile_Proxy( 
    IMetabaseSchemaCompiler * This,
    /* [in] */ LPCWSTR i_wszExtensionsXmlFile,
    /* [in] */ LPCWSTR i_wszResultingOutputXmlFile);


void __RPC_STUB IMetabaseSchemaCompiler_Compile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMetabaseSchemaCompiler_GetBinFileName_Proxy( 
    IMetabaseSchemaCompiler * This,
    /* [out] */ LPWSTR o_wszBinFileName,
    /* [out] */ ULONG *io_pcchSizeBinFileName);


void __RPC_STUB IMetabaseSchemaCompiler_GetBinFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMetabaseSchemaCompiler_SetBinPath_Proxy( 
    IMetabaseSchemaCompiler * This,
    /* [in] */ LPCWSTR i_wszBinPath);


void __RPC_STUB IMetabaseSchemaCompiler_SetBinPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMetabaseSchemaCompiler_ReleaseBinFileName_Proxy( 
    IMetabaseSchemaCompiler * This,
    /* [in] */ LPCWSTR i_wszBinFileName);


void __RPC_STUB IMetabaseSchemaCompiler_ReleaseBinFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMetabaseSchemaCompiler_INTERFACE_DEFINED__ */


#ifndef __ICatalogErrorLogger_INTERFACE_DEFINED__
#define __ICatalogErrorLogger_INTERFACE_DEFINED__

/* interface ICatalogErrorLogger */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ICatalogErrorLogger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EB623F6E-5AFA-402d-BBE0-CF74D34EB4C3")
    ICatalogErrorLogger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LogError( 
            /* [in] */ HRESULT i_hrErrorCode,
            /* [in] */ ULONG i_ulCategory,
            /* [in] */ ULONG i_ulEvent,
            /* [in] */ LPCWSTR i_szSource,
            /* [in] */ ULONG i_ulLineNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogErrorLoggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogErrorLogger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogErrorLogger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogErrorLogger * This);
        
        HRESULT ( STDMETHODCALLTYPE *LogError )( 
            ICatalogErrorLogger * This,
            /* [in] */ HRESULT i_hrErrorCode,
            /* [in] */ ULONG i_ulCategory,
            /* [in] */ ULONG i_ulEvent,
            /* [in] */ LPCWSTR i_szSource,
            /* [in] */ ULONG i_ulLineNumber);
        
        END_INTERFACE
    } ICatalogErrorLoggerVtbl;

    interface ICatalogErrorLogger
    {
        CONST_VTBL struct ICatalogErrorLoggerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogErrorLogger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogErrorLogger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogErrorLogger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogErrorLogger_LogError(This,i_hrErrorCode,i_ulCategory,i_ulEvent,i_szSource,i_ulLineNumber)	\
    (This)->lpVtbl -> LogError(This,i_hrErrorCode,i_ulCategory,i_ulEvent,i_szSource,i_ulLineNumber)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatalogErrorLogger_LogError_Proxy( 
    ICatalogErrorLogger * This,
    /* [in] */ HRESULT i_hrErrorCode,
    /* [in] */ ULONG i_ulCategory,
    /* [in] */ ULONG i_ulEvent,
    /* [in] */ LPCWSTR i_szSource,
    /* [in] */ ULONG i_ulLineNumber);


void __RPC_STUB ICatalogErrorLogger_LogError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogErrorLogger_INTERFACE_DEFINED__ */


#ifndef __ICatalogErrorLogger2_INTERFACE_DEFINED__
#define __ICatalogErrorLogger2_INTERFACE_DEFINED__

/* interface ICatalogErrorLogger2 */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ICatalogErrorLogger2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("190B6C3B-A2C5-4e40-B1F7-A2C6D455CD5B")
    ICatalogErrorLogger2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReportError( 
            /* [in] */ ULONG i_BaseVersion_DETAILEDERRORS,
            /* [in] */ ULONG i_ExtendedVersion_DETAILEDERRORS,
            /* [in] */ ULONG i_cDETAILEDERRORS_NumberOfColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogErrorLogger2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogErrorLogger2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogErrorLogger2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogErrorLogger2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReportError )( 
            ICatalogErrorLogger2 * This,
            /* [in] */ ULONG i_BaseVersion_DETAILEDERRORS,
            /* [in] */ ULONG i_ExtendedVersion_DETAILEDERRORS,
            /* [in] */ ULONG i_cDETAILEDERRORS_NumberOfColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues);
        
        END_INTERFACE
    } ICatalogErrorLogger2Vtbl;

    interface ICatalogErrorLogger2
    {
        CONST_VTBL struct ICatalogErrorLogger2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogErrorLogger2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogErrorLogger2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogErrorLogger2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogErrorLogger2_ReportError(This,i_BaseVersion_DETAILEDERRORS,i_ExtendedVersion_DETAILEDERRORS,i_cDETAILEDERRORS_NumberOfColumns,i_acbSizes,i_apvValues)	\
    (This)->lpVtbl -> ReportError(This,i_BaseVersion_DETAILEDERRORS,i_ExtendedVersion_DETAILEDERRORS,i_cDETAILEDERRORS_NumberOfColumns,i_acbSizes,i_apvValues)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatalogErrorLogger2_ReportError_Proxy( 
    ICatalogErrorLogger2 * This,
    /* [in] */ ULONG i_BaseVersion_DETAILEDERRORS,
    /* [in] */ ULONG i_ExtendedVersion_DETAILEDERRORS,
    /* [in] */ ULONG i_cDETAILEDERRORS_NumberOfColumns,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues);


void __RPC_STUB ICatalogErrorLogger2_ReportError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogErrorLogger2_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableRead2_INTERFACE_DEFINED__
#define __ISimpleTableRead2_INTERFACE_DEFINED__

/* interface ISimpleTableRead2 */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableRead2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e1a560f-18b6-11d3-8fe3-00c04fc2e0c7")
    ISimpleTableRead2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowIndexByIdentity( 
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnValues( 
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ ULONG *o_acbSizes,
            /* [out] */ LPVOID *o_apvValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableMeta( 
            /* [out] */ ULONG *o_pcVersion,
            /* [out] */ DWORD *o_pfTable,
            /* [out] */ ULONG *o_pcRows,
            /* [out] */ ULONG *o_pcColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnMetas( 
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ SimpleColumnMeta *o_aColumnMetas) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRowIndexBySearch( 
            /* [in] */ ULONG i_iStartingRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableRead2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableRead2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableRead2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableRead2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowIndexByIdentity )( 
            ISimpleTableRead2 * This,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnValues )( 
            ISimpleTableRead2 * This,
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ ULONG *o_acbSizes,
            /* [out] */ LPVOID *o_apvValues);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableMeta )( 
            ISimpleTableRead2 * This,
            /* [out] */ ULONG *o_pcVersion,
            /* [out] */ DWORD *o_pfTable,
            /* [out] */ ULONG *o_pcRows,
            /* [out] */ ULONG *o_pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnMetas )( 
            ISimpleTableRead2 * This,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ SimpleColumnMeta *o_aColumnMetas);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowIndexBySearch )( 
            ISimpleTableRead2 * This,
            /* [in] */ ULONG i_iStartingRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        END_INTERFACE
    } ISimpleTableRead2Vtbl;

    interface ISimpleTableRead2
    {
        CONST_VTBL struct ISimpleTableRead2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableRead2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableRead2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableRead2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableRead2_GetRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)

#define ISimpleTableRead2_GetColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_acbSizes,o_apvValues)	\
    (This)->lpVtbl -> GetColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_acbSizes,o_apvValues)

#define ISimpleTableRead2_GetTableMeta(This,o_pcVersion,o_pfTable,o_pcRows,o_pcColumns)	\
    (This)->lpVtbl -> GetTableMeta(This,o_pcVersion,o_pfTable,o_pcRows,o_pcColumns)

#define ISimpleTableRead2_GetColumnMetas(This,i_cColumns,i_aiColumns,o_aColumnMetas)	\
    (This)->lpVtbl -> GetColumnMetas(This,i_cColumns,i_aiColumns,o_aColumnMetas)

#define ISimpleTableRead2_GetRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableRead2_GetRowIndexByIdentity_Proxy( 
    ISimpleTableRead2 * This,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues,
    /* [out] */ ULONG *o_piRow);


void __RPC_STUB ISimpleTableRead2_GetRowIndexByIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableRead2_GetColumnValues_Proxy( 
    ISimpleTableRead2 * This,
    /* [in] */ ULONG i_iRow,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [out] */ ULONG *o_acbSizes,
    /* [out] */ LPVOID *o_apvValues);


void __RPC_STUB ISimpleTableRead2_GetColumnValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableRead2_GetTableMeta_Proxy( 
    ISimpleTableRead2 * This,
    /* [out] */ ULONG *o_pcVersion,
    /* [out] */ DWORD *o_pfTable,
    /* [out] */ ULONG *o_pcRows,
    /* [out] */ ULONG *o_pcColumns);


void __RPC_STUB ISimpleTableRead2_GetTableMeta_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableRead2_GetColumnMetas_Proxy( 
    ISimpleTableRead2 * This,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [out] */ SimpleColumnMeta *o_aColumnMetas);


void __RPC_STUB ISimpleTableRead2_GetColumnMetas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableRead2_GetRowIndexBySearch_Proxy( 
    ISimpleTableRead2 * This,
    /* [in] */ ULONG i_iStartingRow,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues,
    /* [out] */ ULONG *o_piRow);


void __RPC_STUB ISimpleTableRead2_GetRowIndexBySearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableRead2_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableWrite2_INTERFACE_DEFINED__
#define __ISimpleTableWrite2_INTERFACE_DEFINED__

/* interface ISimpleTableWrite2 */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableWrite2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e1a5610-18b6-11d3-8fe3-00c04fc2e0c7")
    ISimpleTableWrite2 : public ISimpleTableRead2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddRowForDelete( 
            /* [in] */ ULONG i_iReadRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRowForInsert( 
            /* [out] */ ULONG *o_piWriteRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRowForUpdate( 
            /* [in] */ ULONG i_iReadRow,
            /* [out] */ ULONG *o_piWriteRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWriteColumnValues( 
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteColumnValues( 
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ DWORD *o_afStatus,
            /* [out] */ ULONG *o_acbSizes,
            /* [out] */ LPVOID *o_apvValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexByIdentity( 
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateStore( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexBySearch( 
            /* [in] */ ULONG i_iStartingRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorTable( 
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ LPVOID *o_ppvSimpleTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableWrite2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableWrite2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableWrite2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableWrite2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowIndexByIdentity )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnValues )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ ULONG *o_acbSizes,
            /* [out] */ LPVOID *o_apvValues);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableMeta )( 
            ISimpleTableWrite2 * This,
            /* [out] */ ULONG *o_pcVersion,
            /* [out] */ DWORD *o_pfTable,
            /* [out] */ ULONG *o_pcRows,
            /* [out] */ ULONG *o_pcColumns);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnMetas )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ SimpleColumnMeta *o_aColumnMetas);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowIndexBySearch )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iStartingRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        HRESULT ( STDMETHODCALLTYPE *AddRowForDelete )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iReadRow);
        
        HRESULT ( STDMETHODCALLTYPE *AddRowForInsert )( 
            ISimpleTableWrite2 * This,
            /* [out] */ ULONG *o_piWriteRow);
        
        HRESULT ( STDMETHODCALLTYPE *AddRowForUpdate )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iReadRow,
            /* [out] */ ULONG *o_piWriteRow);
        
        HRESULT ( STDMETHODCALLTYPE *SetWriteColumnValues )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteColumnValues )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [out] */ DWORD *o_afStatus,
            /* [out] */ ULONG *o_acbSizes,
            /* [out] */ LPVOID *o_apvValues);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteRowIndexByIdentity )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateStore )( 
            ISimpleTableWrite2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteRowIndexBySearch )( 
            ISimpleTableWrite2 * This,
            /* [in] */ ULONG i_iStartingRow,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ ULONG *i_aiColumns,
            /* [in] */ ULONG *i_acbSizes,
            /* [in] */ LPVOID *i_apvValues,
            /* [out] */ ULONG *o_piRow);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorTable )( 
            ISimpleTableWrite2 * This,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        END_INTERFACE
    } ISimpleTableWrite2Vtbl;

    interface ISimpleTableWrite2
    {
        CONST_VTBL struct ISimpleTableWrite2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableWrite2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableWrite2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableWrite2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableWrite2_GetRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)

#define ISimpleTableWrite2_GetColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_acbSizes,o_apvValues)	\
    (This)->lpVtbl -> GetColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_acbSizes,o_apvValues)

#define ISimpleTableWrite2_GetTableMeta(This,o_pcVersion,o_pfTable,o_pcRows,o_pcColumns)	\
    (This)->lpVtbl -> GetTableMeta(This,o_pcVersion,o_pfTable,o_pcRows,o_pcColumns)

#define ISimpleTableWrite2_GetColumnMetas(This,i_cColumns,i_aiColumns,o_aColumnMetas)	\
    (This)->lpVtbl -> GetColumnMetas(This,i_cColumns,i_aiColumns,o_aColumnMetas)

#define ISimpleTableWrite2_GetRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)


#define ISimpleTableWrite2_AddRowForDelete(This,i_iReadRow)	\
    (This)->lpVtbl -> AddRowForDelete(This,i_iReadRow)

#define ISimpleTableWrite2_AddRowForInsert(This,o_piWriteRow)	\
    (This)->lpVtbl -> AddRowForInsert(This,o_piWriteRow)

#define ISimpleTableWrite2_AddRowForUpdate(This,i_iReadRow,o_piWriteRow)	\
    (This)->lpVtbl -> AddRowForUpdate(This,i_iReadRow,o_piWriteRow)

#define ISimpleTableWrite2_SetWriteColumnValues(This,i_iRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues)	\
    (This)->lpVtbl -> SetWriteColumnValues(This,i_iRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues)

#define ISimpleTableWrite2_GetWriteColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_afStatus,o_acbSizes,o_apvValues)	\
    (This)->lpVtbl -> GetWriteColumnValues(This,i_iRow,i_cColumns,i_aiColumns,o_afStatus,o_acbSizes,o_apvValues)

#define ISimpleTableWrite2_GetWriteRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetWriteRowIndexByIdentity(This,i_acbSizes,i_apvValues,o_piRow)

#define ISimpleTableWrite2_UpdateStore(This)	\
    (This)->lpVtbl -> UpdateStore(This)

#define ISimpleTableWrite2_GetWriteRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)	\
    (This)->lpVtbl -> GetWriteRowIndexBySearch(This,i_iStartingRow,i_cColumns,i_aiColumns,i_acbSizes,i_apvValues,o_piRow)

#define ISimpleTableWrite2_GetErrorTable(This,i_fServiceRequests,o_ppvSimpleTable)	\
    (This)->lpVtbl -> GetErrorTable(This,i_fServiceRequests,o_ppvSimpleTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_AddRowForDelete_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG i_iReadRow);


void __RPC_STUB ISimpleTableWrite2_AddRowForDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_AddRowForInsert_Proxy( 
    ISimpleTableWrite2 * This,
    /* [out] */ ULONG *o_piWriteRow);


void __RPC_STUB ISimpleTableWrite2_AddRowForInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_AddRowForUpdate_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG i_iReadRow,
    /* [out] */ ULONG *o_piWriteRow);


void __RPC_STUB ISimpleTableWrite2_AddRowForUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_SetWriteColumnValues_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG i_iRow,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues);


void __RPC_STUB ISimpleTableWrite2_SetWriteColumnValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_GetWriteColumnValues_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG i_iRow,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [out] */ DWORD *o_afStatus,
    /* [out] */ ULONG *o_acbSizes,
    /* [out] */ LPVOID *o_apvValues);


void __RPC_STUB ISimpleTableWrite2_GetWriteColumnValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_GetWriteRowIndexByIdentity_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues,
    /* [out] */ ULONG *o_piRow);


void __RPC_STUB ISimpleTableWrite2_GetWriteRowIndexByIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_UpdateStore_Proxy( 
    ISimpleTableWrite2 * This);


void __RPC_STUB ISimpleTableWrite2_UpdateStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_GetWriteRowIndexBySearch_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ ULONG i_iStartingRow,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ ULONG *i_aiColumns,
    /* [in] */ ULONG *i_acbSizes,
    /* [in] */ LPVOID *i_apvValues,
    /* [out] */ ULONG *o_piRow);


void __RPC_STUB ISimpleTableWrite2_GetWriteRowIndexBySearch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableWrite2_GetErrorTable_Proxy( 
    ISimpleTableWrite2 * This,
    /* [in] */ DWORD i_fServiceRequests,
    /* [out] */ LPVOID *o_ppvSimpleTable);


void __RPC_STUB ISimpleTableWrite2_GetErrorTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableWrite2_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableAdvanced_INTERFACE_DEFINED__
#define __ISimpleTableAdvanced_INTERFACE_DEFINED__

/* interface ISimpleTableAdvanced */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e1a5611-18b6-11d3-8fe3-00c04fc2e0c7")
    ISimpleTableAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PopulateCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailedErrorCount( 
            /* [out] */ ULONG *o_pcErrs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDetailedError( 
            /* [in] */ ULONG i_iErr,
            /* [out] */ STErr *o_pSTErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *PopulateCache )( 
            ISimpleTableAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailedErrorCount )( 
            ISimpleTableAdvanced * This,
            /* [out] */ ULONG *o_pcErrs);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailedError )( 
            ISimpleTableAdvanced * This,
            /* [in] */ ULONG i_iErr,
            /* [out] */ STErr *o_pSTErr);
        
        END_INTERFACE
    } ISimpleTableAdvancedVtbl;

    interface ISimpleTableAdvanced
    {
        CONST_VTBL struct ISimpleTableAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableAdvanced_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableAdvanced_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableAdvanced_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableAdvanced_PopulateCache(This)	\
    (This)->lpVtbl -> PopulateCache(This)

#define ISimpleTableAdvanced_GetDetailedErrorCount(This,o_pcErrs)	\
    (This)->lpVtbl -> GetDetailedErrorCount(This,o_pcErrs)

#define ISimpleTableAdvanced_GetDetailedError(This,i_iErr,o_pSTErr)	\
    (This)->lpVtbl -> GetDetailedError(This,i_iErr,o_pSTErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableAdvanced_PopulateCache_Proxy( 
    ISimpleTableAdvanced * This);


void __RPC_STUB ISimpleTableAdvanced_PopulateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableAdvanced_GetDetailedErrorCount_Proxy( 
    ISimpleTableAdvanced * This,
    /* [out] */ ULONG *o_pcErrs);


void __RPC_STUB ISimpleTableAdvanced_GetDetailedErrorCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableAdvanced_GetDetailedError_Proxy( 
    ISimpleTableAdvanced * This,
    /* [in] */ ULONG i_iErr,
    /* [out] */ STErr *o_pSTErr);


void __RPC_STUB ISimpleTableAdvanced_GetDetailedError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableAdvanced_INTERFACE_DEFINED__ */


#ifndef __ISnapshotManager_INTERFACE_DEFINED__
#define __ISnapshotManager_INTERFACE_DEFINED__

/* interface ISnapshotManager */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISnapshotManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962B6F98-1CCA-4cf9-8663-52BE195859AE")
    ISnapshotManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryLatestSnapshot( 
            /* [out] */ SNID *o_psnid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefSnapshot( 
            SNID i_snid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSnapshot( 
            SNID i_snid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapshotManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISnapshotManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISnapshotManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISnapshotManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLatestSnapshot )( 
            ISnapshotManager * This,
            /* [out] */ SNID *o_psnid);
        
        HRESULT ( STDMETHODCALLTYPE *AddRefSnapshot )( 
            ISnapshotManager * This,
            SNID i_snid);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseSnapshot )( 
            ISnapshotManager * This,
            SNID i_snid);
        
        END_INTERFACE
    } ISnapshotManagerVtbl;

    interface ISnapshotManager
    {
        CONST_VTBL struct ISnapshotManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapshotManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapshotManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapshotManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapshotManager_QueryLatestSnapshot(This,o_psnid)	\
    (This)->lpVtbl -> QueryLatestSnapshot(This,o_psnid)

#define ISnapshotManager_AddRefSnapshot(This,i_snid)	\
    (This)->lpVtbl -> AddRefSnapshot(This,i_snid)

#define ISnapshotManager_ReleaseSnapshot(This,i_snid)	\
    (This)->lpVtbl -> ReleaseSnapshot(This,i_snid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISnapshotManager_QueryLatestSnapshot_Proxy( 
    ISnapshotManager * This,
    /* [out] */ SNID *o_psnid);


void __RPC_STUB ISnapshotManager_QueryLatestSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISnapshotManager_AddRefSnapshot_Proxy( 
    ISnapshotManager * This,
    SNID i_snid);


void __RPC_STUB ISnapshotManager_AddRefSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISnapshotManager_ReleaseSnapshot_Proxy( 
    ISnapshotManager * This,
    SNID i_snid);


void __RPC_STUB ISnapshotManager_ReleaseSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapshotManager_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableController_INTERFACE_DEFINED__
#define __ISimpleTableController_INTERFACE_DEFINED__

/* interface ISimpleTableController */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e1a5612-18b6-11d3-8fe3-00c04fc2e0c7")
    ISimpleTableController : public ISimpleTableAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShapeCache( 
            /* [in] */ DWORD i_fTable,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ SimpleColumnMeta *i_acolmetas,
            /* [in] */ LPVOID *i_apvDefaults,
            /* [in] */ ULONG *i_acbSizes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrePopulateCache( 
            /* [in] */ DWORD i_fControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostPopulateCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardPendingWrites( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteRowAction( 
            /* [in] */ ULONG i_iRow,
            DWORD *o_peAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWriteRowAction( 
            /* [in] */ ULONG i_iRow,
            DWORD i_eAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeWriteColumnStatus( 
            /* [in] */ ULONG i_iRow,
            ULONG i_iColumn,
            DWORD i_fStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDetailedError( 
            /* [in] */ STErr *o_pSTErr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarshallingInterface( 
            /* [out] */ IID *o_piid,
            /* [iid_is][out] */ LPVOID *o_ppItf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableController * This);
        
        HRESULT ( STDMETHODCALLTYPE *PopulateCache )( 
            ISimpleTableController * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailedErrorCount )( 
            ISimpleTableController * This,
            /* [out] */ ULONG *o_pcErrs);
        
        HRESULT ( STDMETHODCALLTYPE *GetDetailedError )( 
            ISimpleTableController * This,
            /* [in] */ ULONG i_iErr,
            /* [out] */ STErr *o_pSTErr);
        
        HRESULT ( STDMETHODCALLTYPE *ShapeCache )( 
            ISimpleTableController * This,
            /* [in] */ DWORD i_fTable,
            /* [in] */ ULONG i_cColumns,
            /* [in] */ SimpleColumnMeta *i_acolmetas,
            /* [in] */ LPVOID *i_apvDefaults,
            /* [in] */ ULONG *i_acbSizes);
        
        HRESULT ( STDMETHODCALLTYPE *PrePopulateCache )( 
            ISimpleTableController * This,
            /* [in] */ DWORD i_fControl);
        
        HRESULT ( STDMETHODCALLTYPE *PostPopulateCache )( 
            ISimpleTableController * This);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardPendingWrites )( 
            ISimpleTableController * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteRowAction )( 
            ISimpleTableController * This,
            /* [in] */ ULONG i_iRow,
            DWORD *o_peAction);
        
        HRESULT ( STDMETHODCALLTYPE *SetWriteRowAction )( 
            ISimpleTableController * This,
            /* [in] */ ULONG i_iRow,
            DWORD i_eAction);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeWriteColumnStatus )( 
            ISimpleTableController * This,
            /* [in] */ ULONG i_iRow,
            ULONG i_iColumn,
            DWORD i_fStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AddDetailedError )( 
            ISimpleTableController * This,
            /* [in] */ STErr *o_pSTErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshallingInterface )( 
            ISimpleTableController * This,
            /* [out] */ IID *o_piid,
            /* [iid_is][out] */ LPVOID *o_ppItf);
        
        END_INTERFACE
    } ISimpleTableControllerVtbl;

    interface ISimpleTableController
    {
        CONST_VTBL struct ISimpleTableControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableController_PopulateCache(This)	\
    (This)->lpVtbl -> PopulateCache(This)

#define ISimpleTableController_GetDetailedErrorCount(This,o_pcErrs)	\
    (This)->lpVtbl -> GetDetailedErrorCount(This,o_pcErrs)

#define ISimpleTableController_GetDetailedError(This,i_iErr,o_pSTErr)	\
    (This)->lpVtbl -> GetDetailedError(This,i_iErr,o_pSTErr)


#define ISimpleTableController_ShapeCache(This,i_fTable,i_cColumns,i_acolmetas,i_apvDefaults,i_acbSizes)	\
    (This)->lpVtbl -> ShapeCache(This,i_fTable,i_cColumns,i_acolmetas,i_apvDefaults,i_acbSizes)

#define ISimpleTableController_PrePopulateCache(This,i_fControl)	\
    (This)->lpVtbl -> PrePopulateCache(This,i_fControl)

#define ISimpleTableController_PostPopulateCache(This)	\
    (This)->lpVtbl -> PostPopulateCache(This)

#define ISimpleTableController_DiscardPendingWrites(This)	\
    (This)->lpVtbl -> DiscardPendingWrites(This)

#define ISimpleTableController_GetWriteRowAction(This,i_iRow,o_peAction)	\
    (This)->lpVtbl -> GetWriteRowAction(This,i_iRow,o_peAction)

#define ISimpleTableController_SetWriteRowAction(This,i_iRow,i_eAction)	\
    (This)->lpVtbl -> SetWriteRowAction(This,i_iRow,i_eAction)

#define ISimpleTableController_ChangeWriteColumnStatus(This,i_iRow,i_iColumn,i_fStatus)	\
    (This)->lpVtbl -> ChangeWriteColumnStatus(This,i_iRow,i_iColumn,i_fStatus)

#define ISimpleTableController_AddDetailedError(This,o_pSTErr)	\
    (This)->lpVtbl -> AddDetailedError(This,o_pSTErr)

#define ISimpleTableController_GetMarshallingInterface(This,o_piid,o_ppItf)	\
    (This)->lpVtbl -> GetMarshallingInterface(This,o_piid,o_ppItf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableController_ShapeCache_Proxy( 
    ISimpleTableController * This,
    /* [in] */ DWORD i_fTable,
    /* [in] */ ULONG i_cColumns,
    /* [in] */ SimpleColumnMeta *i_acolmetas,
    /* [in] */ LPVOID *i_apvDefaults,
    /* [in] */ ULONG *i_acbSizes);


void __RPC_STUB ISimpleTableController_ShapeCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_PrePopulateCache_Proxy( 
    ISimpleTableController * This,
    /* [in] */ DWORD i_fControl);


void __RPC_STUB ISimpleTableController_PrePopulateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_PostPopulateCache_Proxy( 
    ISimpleTableController * This);


void __RPC_STUB ISimpleTableController_PostPopulateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_DiscardPendingWrites_Proxy( 
    ISimpleTableController * This);


void __RPC_STUB ISimpleTableController_DiscardPendingWrites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_GetWriteRowAction_Proxy( 
    ISimpleTableController * This,
    /* [in] */ ULONG i_iRow,
    DWORD *o_peAction);


void __RPC_STUB ISimpleTableController_GetWriteRowAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_SetWriteRowAction_Proxy( 
    ISimpleTableController * This,
    /* [in] */ ULONG i_iRow,
    DWORD i_eAction);


void __RPC_STUB ISimpleTableController_SetWriteRowAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_ChangeWriteColumnStatus_Proxy( 
    ISimpleTableController * This,
    /* [in] */ ULONG i_iRow,
    ULONG i_iColumn,
    DWORD i_fStatus);


void __RPC_STUB ISimpleTableController_ChangeWriteColumnStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_AddDetailedError_Proxy( 
    ISimpleTableController * This,
    /* [in] */ STErr *o_pSTErr);


void __RPC_STUB ISimpleTableController_AddDetailedError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableController_GetMarshallingInterface_Proxy( 
    ISimpleTableController * This,
    /* [out] */ IID *o_piid,
    /* [iid_is][out] */ LPVOID *o_ppItf);


void __RPC_STUB ISimpleTableController_GetMarshallingInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableController_INTERFACE_DEFINED__ */


#ifndef __IAdvancedTableDispenser_INTERFACE_DEFINED__
#define __IAdvancedTableDispenser_INTERFACE_DEFINED__

/* interface IAdvancedTableDispenser */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAdvancedTableDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e3ec3192-544c-11d3-8fe9-00c04fc2e0c7")
    IAdvancedTableDispenser : public ISimpleTableDispenser2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMemoryTable( 
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ ISimpleTableWrite2 **o_ppISTWrite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProductID( 
            /* [out] */ LPWSTR o_wszProductID,
            /* [out][in] */ DWORD *io_pcchProductID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCatalogErrorLogger( 
            /* [out] */ ICatalogErrorLogger2 **o_ppErrorLogger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCatalogErrorLogger( 
            /* [in] */ ICatalogErrorLogger2 *i_pErrorLogger) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdvancedTableDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAdvancedTableDispenser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAdvancedTableDispenser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAdvancedTableDispenser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTable )( 
            IAdvancedTableDispenser * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryTable )( 
            IAdvancedTableDispenser * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fServiceRequests,
            /* [out] */ ISimpleTableWrite2 **o_ppISTWrite);
        
        HRESULT ( STDMETHODCALLTYPE *GetProductID )( 
            IAdvancedTableDispenser * This,
            /* [out] */ LPWSTR o_wszProductID,
            /* [out][in] */ DWORD *io_pcchProductID);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogErrorLogger )( 
            IAdvancedTableDispenser * This,
            /* [out] */ ICatalogErrorLogger2 **o_ppErrorLogger);
        
        HRESULT ( STDMETHODCALLTYPE *SetCatalogErrorLogger )( 
            IAdvancedTableDispenser * This,
            /* [in] */ ICatalogErrorLogger2 *i_pErrorLogger);
        
        END_INTERFACE
    } IAdvancedTableDispenserVtbl;

    interface IAdvancedTableDispenser
    {
        CONST_VTBL struct IAdvancedTableDispenserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdvancedTableDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdvancedTableDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdvancedTableDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdvancedTableDispenser_GetTable(This,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppvSimpleTable)	\
    (This)->lpVtbl -> GetTable(This,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppvSimpleTable)


#define IAdvancedTableDispenser_GetMemoryTable(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppISTWrite)	\
    (This)->lpVtbl -> GetMemoryTable(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fServiceRequests,o_ppISTWrite)

#define IAdvancedTableDispenser_GetProductID(This,o_wszProductID,io_pcchProductID)	\
    (This)->lpVtbl -> GetProductID(This,o_wszProductID,io_pcchProductID)

#define IAdvancedTableDispenser_GetCatalogErrorLogger(This,o_ppErrorLogger)	\
    (This)->lpVtbl -> GetCatalogErrorLogger(This,o_ppErrorLogger)

#define IAdvancedTableDispenser_SetCatalogErrorLogger(This,i_pErrorLogger)	\
    (This)->lpVtbl -> SetCatalogErrorLogger(This,i_pErrorLogger)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAdvancedTableDispenser_GetMemoryTable_Proxy( 
    IAdvancedTableDispenser * This,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ ULONG i_TableID,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ DWORD i_eQueryFormat,
    /* [in] */ DWORD i_fServiceRequests,
    /* [out] */ ISimpleTableWrite2 **o_ppISTWrite);


void __RPC_STUB IAdvancedTableDispenser_GetMemoryTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAdvancedTableDispenser_GetProductID_Proxy( 
    IAdvancedTableDispenser * This,
    /* [out] */ LPWSTR o_wszProductID,
    /* [out][in] */ DWORD *io_pcchProductID);


void __RPC_STUB IAdvancedTableDispenser_GetProductID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAdvancedTableDispenser_GetCatalogErrorLogger_Proxy( 
    IAdvancedTableDispenser * This,
    /* [out] */ ICatalogErrorLogger2 **o_ppErrorLogger);


void __RPC_STUB IAdvancedTableDispenser_GetCatalogErrorLogger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAdvancedTableDispenser_SetCatalogErrorLogger_Proxy( 
    IAdvancedTableDispenser * This,
    /* [in] */ ICatalogErrorLogger2 *i_pErrorLogger);


void __RPC_STUB IAdvancedTableDispenser_SetCatalogErrorLogger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAdvancedTableDispenser_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableInterceptor_INTERFACE_DEFINED__
#define __ISimpleTableInterceptor_INTERFACE_DEFINED__

/* interface ISimpleTableInterceptor */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableInterceptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("165887C6-43A8-11d3-B131-00805FC73204")
    ISimpleTableInterceptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Intercept( 
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
            /* [in] */ LPCWSTR i_wszLocator,
            /* [in] */ LPVOID i_pSimpleTable,
            /* [out] */ LPVOID *o_ppvSimpleTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableInterceptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableInterceptor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableInterceptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableInterceptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Intercept )( 
            ISimpleTableInterceptor * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
            /* [in] */ LPCWSTR i_wszLocator,
            /* [in] */ LPVOID i_pSimpleTable,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        END_INTERFACE
    } ISimpleTableInterceptorVtbl;

    interface ISimpleTableInterceptor
    {
        CONST_VTBL struct ISimpleTableInterceptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableInterceptor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableInterceptor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableInterceptor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableInterceptor_Intercept(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fLOS,i_pISTDisp,i_wszLocator,i_pSimpleTable,o_ppvSimpleTable)	\
    (This)->lpVtbl -> Intercept(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fLOS,i_pISTDisp,i_wszLocator,i_pSimpleTable,o_ppvSimpleTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableInterceptor_Intercept_Proxy( 
    ISimpleTableInterceptor * This,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ ULONG i_TableID,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ DWORD i_eQueryFormat,
    /* [in] */ DWORD i_fLOS,
    /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
    /* [in] */ LPCWSTR i_wszLocator,
    /* [in] */ LPVOID i_pSimpleTable,
    /* [out] */ LPVOID *o_ppvSimpleTable);


void __RPC_STUB ISimpleTableInterceptor_Intercept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableInterceptor_INTERFACE_DEFINED__ */


#ifndef __ISimplePlugin_INTERFACE_DEFINED__
#define __ISimplePlugin_INTERFACE_DEFINED__

/* interface ISimplePlugin */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimplePlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1AD849C-4495-11d3-B131-00805FC73204")
    ISimplePlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnInsert( 
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdate( 
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDelete( 
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimplePluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimplePlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimplePlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimplePlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnInsert )( 
            ISimplePlugin * This,
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdate )( 
            ISimplePlugin * This,
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2);
        
        HRESULT ( STDMETHODCALLTYPE *OnDelete )( 
            ISimplePlugin * This,
            /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ ULONG iRow,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2);
        
        END_INTERFACE
    } ISimplePluginVtbl;

    interface ISimplePlugin
    {
        CONST_VTBL struct ISimplePluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimplePlugin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimplePlugin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimplePlugin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimplePlugin_OnInsert(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)	\
    (This)->lpVtbl -> OnInsert(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)

#define ISimplePlugin_OnUpdate(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)	\
    (This)->lpVtbl -> OnUpdate(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)

#define ISimplePlugin_OnDelete(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)	\
    (This)->lpVtbl -> OnDelete(This,i_pDisp2,i_wszDatabase,i_wszTable,i_fLOS,iRow,i_pISTW2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimplePlugin_OnInsert_Proxy( 
    ISimplePlugin * This,
    /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ DWORD i_fLOS,
    /* [in] */ ULONG iRow,
    /* [in] */ ISimpleTableWrite2 *i_pISTW2);


void __RPC_STUB ISimplePlugin_OnInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimplePlugin_OnUpdate_Proxy( 
    ISimplePlugin * This,
    /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ DWORD i_fLOS,
    /* [in] */ ULONG iRow,
    /* [in] */ ISimpleTableWrite2 *i_pISTW2);


void __RPC_STUB ISimplePlugin_OnUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimplePlugin_OnDelete_Proxy( 
    ISimplePlugin * This,
    /* [in] */ ISimpleTableDispenser2 *i_pDisp2,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ DWORD i_fLOS,
    /* [in] */ ULONG iRow,
    /* [in] */ ISimpleTableWrite2 *i_pISTW2);


void __RPC_STUB ISimplePlugin_OnDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimplePlugin_INTERFACE_DEFINED__ */


#ifndef __IInterceptorPlugin_INTERFACE_DEFINED__
#define __IInterceptorPlugin_INTERFACE_DEFINED__

/* interface IInterceptorPlugin */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInterceptorPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1AD849D-4495-11d3-B131-00805FC73204")
    IInterceptorPlugin : public ISimpleTableInterceptor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPopulateCache( 
            /* [in] */ ISimpleTableWrite2 *i_pISTW2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateStore( 
            /* [in] */ ISimpleTableWrite2 *i_pISTW2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInterceptorPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterceptorPlugin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterceptorPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterceptorPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *Intercept )( 
            IInterceptorPlugin * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fLOS,
            /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
            /* [in] */ LPCWSTR i_wszLocator,
            /* [in] */ LPVOID i_pSimpleTable,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        HRESULT ( STDMETHODCALLTYPE *OnPopulateCache )( 
            IInterceptorPlugin * This,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateStore )( 
            IInterceptorPlugin * This,
            /* [in] */ ISimpleTableWrite2 *i_pISTW2);
        
        END_INTERFACE
    } IInterceptorPluginVtbl;

    interface IInterceptorPlugin
    {
        CONST_VTBL struct IInterceptorPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterceptorPlugin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInterceptorPlugin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInterceptorPlugin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInterceptorPlugin_Intercept(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fLOS,i_pISTDisp,i_wszLocator,i_pSimpleTable,o_ppvSimpleTable)	\
    (This)->lpVtbl -> Intercept(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fLOS,i_pISTDisp,i_wszLocator,i_pSimpleTable,o_ppvSimpleTable)


#define IInterceptorPlugin_OnPopulateCache(This,i_pISTW2)	\
    (This)->lpVtbl -> OnPopulateCache(This,i_pISTW2)

#define IInterceptorPlugin_OnUpdateStore(This,i_pISTW2)	\
    (This)->lpVtbl -> OnUpdateStore(This,i_pISTW2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInterceptorPlugin_OnPopulateCache_Proxy( 
    IInterceptorPlugin * This,
    /* [in] */ ISimpleTableWrite2 *i_pISTW2);


void __RPC_STUB IInterceptorPlugin_OnPopulateCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInterceptorPlugin_OnUpdateStore_Proxy( 
    IInterceptorPlugin * This,
    /* [in] */ ISimpleTableWrite2 *i_pISTW2);


void __RPC_STUB IInterceptorPlugin_OnUpdateStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInterceptorPlugin_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableEvent_INTERFACE_DEFINED__
#define __ISimpleTableEvent_INTERFACE_DEFINED__

/* interface ISimpleTableEvent */
/* [local][unique][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ISimpleTableEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31348BD5-781F-4375-9BBD-1C6F06B5A417")
    ISimpleTableEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ISimpleTableWrite2 **i_ppISTWrite,
            /* [in] */ ULONG i_cTables,
            /* [in] */ DWORD i_dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ISimpleTableEvent * This,
            /* [in] */ ISimpleTableWrite2 **i_ppISTWrite,
            /* [in] */ ULONG i_cTables,
            /* [in] */ DWORD i_dwCookie);
        
        END_INTERFACE
    } ISimpleTableEventVtbl;

    interface ISimpleTableEvent
    {
        CONST_VTBL struct ISimpleTableEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableEvent_OnChange(This,i_ppISTWrite,i_cTables,i_dwCookie)	\
    (This)->lpVtbl -> OnChange(This,i_ppISTWrite,i_cTables,i_dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableEvent_OnChange_Proxy( 
    ISimpleTableEvent * This,
    /* [in] */ ISimpleTableWrite2 **i_ppISTWrite,
    /* [in] */ ULONG i_cTables,
    /* [in] */ DWORD i_dwCookie);


void __RPC_STUB ISimpleTableEvent_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableEvent_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableAdvise_INTERFACE_DEFINED__
#define __ISimpleTableAdvise_INTERFACE_DEFINED__

/* interface ISimpleTableAdvise */
/* [local][unique][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ISimpleTableAdvise;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDB5BA55-6279-4873-8461-B62457DF8F20")
    ISimpleTableAdvise : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SimpleTableAdvise( 
            /* [in] */ ISimpleTableEvent *i_pISTEvent,
            /* [in] */ SNID i_snid,
            /* [in] */ MultiSubscribe *i_ams,
            /* [in] */ ULONG i_cms,
            /* [out] */ DWORD *o_pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimpleTableUnadvise( 
            /* [in] */ DWORD i_dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableAdviseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableAdvise * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableAdvise * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableAdvise * This);
        
        HRESULT ( STDMETHODCALLTYPE *SimpleTableAdvise )( 
            ISimpleTableAdvise * This,
            /* [in] */ ISimpleTableEvent *i_pISTEvent,
            /* [in] */ SNID i_snid,
            /* [in] */ MultiSubscribe *i_ams,
            /* [in] */ ULONG i_cms,
            /* [out] */ DWORD *o_pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SimpleTableUnadvise )( 
            ISimpleTableAdvise * This,
            /* [in] */ DWORD i_dwCookie);
        
        END_INTERFACE
    } ISimpleTableAdviseVtbl;

    interface ISimpleTableAdvise
    {
        CONST_VTBL struct ISimpleTableAdviseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableAdvise_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableAdvise_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableAdvise_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableAdvise_SimpleTableAdvise(This,i_pISTEvent,i_snid,i_ams,i_cms,o_pdwCookie)	\
    (This)->lpVtbl -> SimpleTableAdvise(This,i_pISTEvent,i_snid,i_ams,i_cms,o_pdwCookie)

#define ISimpleTableAdvise_SimpleTableUnadvise(This,i_dwCookie)	\
    (This)->lpVtbl -> SimpleTableUnadvise(This,i_dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableAdvise_SimpleTableAdvise_Proxy( 
    ISimpleTableAdvise * This,
    /* [in] */ ISimpleTableEvent *i_pISTEvent,
    /* [in] */ SNID i_snid,
    /* [in] */ MultiSubscribe *i_ams,
    /* [in] */ ULONG i_cms,
    /* [out] */ DWORD *o_pdwCookie);


void __RPC_STUB ISimpleTableAdvise_SimpleTableAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableAdvise_SimpleTableUnadvise_Proxy( 
    ISimpleTableAdvise * This,
    /* [in] */ DWORD i_dwCookie);


void __RPC_STUB ISimpleTableAdvise_SimpleTableUnadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableAdvise_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableEventMgr_INTERFACE_DEFINED__
#define __ISimpleTableEventMgr_INTERFACE_DEFINED__

/* interface ISimpleTableEventMgr */
/* [local][unique][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ISimpleTableEventMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E27D38E9-189F-4ec4-9BD5-0AB5E2602624")
    ISimpleTableEventMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsTableConsumed( 
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUpdateStoreDelta( 
            /* [in] */ LPCWSTR i_wszTableName,
            /* [in] */ char *i_pWriteCache,
            /* [in] */ ULONG i_cbWriteCache,
            /* [in] */ ULONG i_cbWriteVarData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireEvents( 
            /* [in] */ ULONG i_snid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelEvents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RehookNotifications( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMetabaseListener( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UninitMetabaseListener( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableEventMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableEventMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableEventMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableEventMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTableConsumed )( 
            ISimpleTableEventMgr * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable);
        
        HRESULT ( STDMETHODCALLTYPE *AddUpdateStoreDelta )( 
            ISimpleTableEventMgr * This,
            /* [in] */ LPCWSTR i_wszTableName,
            /* [in] */ char *i_pWriteCache,
            /* [in] */ ULONG i_cbWriteCache,
            /* [in] */ ULONG i_cbWriteVarData);
        
        HRESULT ( STDMETHODCALLTYPE *FireEvents )( 
            ISimpleTableEventMgr * This,
            /* [in] */ ULONG i_snid);
        
        HRESULT ( STDMETHODCALLTYPE *CancelEvents )( 
            ISimpleTableEventMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *RehookNotifications )( 
            ISimpleTableEventMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitMetabaseListener )( 
            ISimpleTableEventMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninitMetabaseListener )( 
            ISimpleTableEventMgr * This);
        
        END_INTERFACE
    } ISimpleTableEventMgrVtbl;

    interface ISimpleTableEventMgr
    {
        CONST_VTBL struct ISimpleTableEventMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableEventMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableEventMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableEventMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableEventMgr_IsTableConsumed(This,i_wszDatabase,i_wszTable)	\
    (This)->lpVtbl -> IsTableConsumed(This,i_wszDatabase,i_wszTable)

#define ISimpleTableEventMgr_AddUpdateStoreDelta(This,i_wszTableName,i_pWriteCache,i_cbWriteCache,i_cbWriteVarData)	\
    (This)->lpVtbl -> AddUpdateStoreDelta(This,i_wszTableName,i_pWriteCache,i_cbWriteCache,i_cbWriteVarData)

#define ISimpleTableEventMgr_FireEvents(This,i_snid)	\
    (This)->lpVtbl -> FireEvents(This,i_snid)

#define ISimpleTableEventMgr_CancelEvents(This)	\
    (This)->lpVtbl -> CancelEvents(This)

#define ISimpleTableEventMgr_RehookNotifications(This)	\
    (This)->lpVtbl -> RehookNotifications(This)

#define ISimpleTableEventMgr_InitMetabaseListener(This)	\
    (This)->lpVtbl -> InitMetabaseListener(This)

#define ISimpleTableEventMgr_UninitMetabaseListener(This)	\
    (This)->lpVtbl -> UninitMetabaseListener(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_IsTableConsumed_Proxy( 
    ISimpleTableEventMgr * This,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable);


void __RPC_STUB ISimpleTableEventMgr_IsTableConsumed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_AddUpdateStoreDelta_Proxy( 
    ISimpleTableEventMgr * This,
    /* [in] */ LPCWSTR i_wszTableName,
    /* [in] */ char *i_pWriteCache,
    /* [in] */ ULONG i_cbWriteCache,
    /* [in] */ ULONG i_cbWriteVarData);


void __RPC_STUB ISimpleTableEventMgr_AddUpdateStoreDelta_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_FireEvents_Proxy( 
    ISimpleTableEventMgr * This,
    /* [in] */ ULONG i_snid);


void __RPC_STUB ISimpleTableEventMgr_FireEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_CancelEvents_Proxy( 
    ISimpleTableEventMgr * This);


void __RPC_STUB ISimpleTableEventMgr_CancelEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_RehookNotifications_Proxy( 
    ISimpleTableEventMgr * This);


void __RPC_STUB ISimpleTableEventMgr_RehookNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_InitMetabaseListener_Proxy( 
    ISimpleTableEventMgr * This);


void __RPC_STUB ISimpleTableEventMgr_InitMetabaseListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableEventMgr_UninitMetabaseListener_Proxy( 
    ISimpleTableEventMgr * This);


void __RPC_STUB ISimpleTableEventMgr_UninitMetabaseListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableEventMgr_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableFileChange_INTERFACE_DEFINED__
#define __ISimpleTableFileChange_INTERFACE_DEFINED__

/* interface ISimpleTableFileChange */
/* [local][unique][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ISimpleTableFileChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1744E4E-386D-45cb-80B8-A5037600CEB3")
    ISimpleTableFileChange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnFileCreate( 
            /* [in] */ LPCWSTR i_wszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFileModify( 
            /* [in] */ LPCWSTR i_wszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFileDelete( 
            /* [in] */ LPCWSTR i_wszFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableFileChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableFileChange * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableFileChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableFileChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFileCreate )( 
            ISimpleTableFileChange * This,
            /* [in] */ LPCWSTR i_wszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *OnFileModify )( 
            ISimpleTableFileChange * This,
            /* [in] */ LPCWSTR i_wszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *OnFileDelete )( 
            ISimpleTableFileChange * This,
            /* [in] */ LPCWSTR i_wszFileName);
        
        END_INTERFACE
    } ISimpleTableFileChangeVtbl;

    interface ISimpleTableFileChange
    {
        CONST_VTBL struct ISimpleTableFileChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableFileChange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableFileChange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableFileChange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableFileChange_OnFileCreate(This,i_wszFileName)	\
    (This)->lpVtbl -> OnFileCreate(This,i_wszFileName)

#define ISimpleTableFileChange_OnFileModify(This,i_wszFileName)	\
    (This)->lpVtbl -> OnFileModify(This,i_wszFileName)

#define ISimpleTableFileChange_OnFileDelete(This,i_wszFileName)	\
    (This)->lpVtbl -> OnFileDelete(This,i_wszFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableFileChange_OnFileCreate_Proxy( 
    ISimpleTableFileChange * This,
    /* [in] */ LPCWSTR i_wszFileName);


void __RPC_STUB ISimpleTableFileChange_OnFileCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableFileChange_OnFileModify_Proxy( 
    ISimpleTableFileChange * This,
    /* [in] */ LPCWSTR i_wszFileName);


void __RPC_STUB ISimpleTableFileChange_OnFileModify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableFileChange_OnFileDelete_Proxy( 
    ISimpleTableFileChange * This,
    /* [in] */ LPCWSTR i_wszFileName);


void __RPC_STUB ISimpleTableFileChange_OnFileDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableFileChange_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableFileAdvise_INTERFACE_DEFINED__
#define __ISimpleTableFileAdvise_INTERFACE_DEFINED__

/* interface ISimpleTableFileAdvise */
/* [local][unique][helpstring][object][uuid] */ 


EXTERN_C const IID IID_ISimpleTableFileAdvise;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E96C7344-7E2B-4c28-8502-F075CF6C62F0")
    ISimpleTableFileAdvise : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SimpleTableFileAdvise( 
            /* [in] */ ISimpleTableFileChange *i_pISTFile,
            /* [in] */ LPCWSTR i_wszDirectory,
            /* [in] */ LPCWSTR i_wszFile,
            /* [in] */ DWORD i_fFlags,
            /* [out] */ DWORD *o_pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimpleTableFileUnadvise( 
            /* [in] */ DWORD i_dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableFileAdviseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableFileAdvise * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableFileAdvise * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableFileAdvise * This);
        
        HRESULT ( STDMETHODCALLTYPE *SimpleTableFileAdvise )( 
            ISimpleTableFileAdvise * This,
            /* [in] */ ISimpleTableFileChange *i_pISTFile,
            /* [in] */ LPCWSTR i_wszDirectory,
            /* [in] */ LPCWSTR i_wszFile,
            /* [in] */ DWORD i_fFlags,
            /* [out] */ DWORD *o_pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SimpleTableFileUnadvise )( 
            ISimpleTableFileAdvise * This,
            /* [in] */ DWORD i_dwCookie);
        
        END_INTERFACE
    } ISimpleTableFileAdviseVtbl;

    interface ISimpleTableFileAdvise
    {
        CONST_VTBL struct ISimpleTableFileAdviseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableFileAdvise_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableFileAdvise_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableFileAdvise_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableFileAdvise_SimpleTableFileAdvise(This,i_pISTFile,i_wszDirectory,i_wszFile,i_fFlags,o_pdwCookie)	\
    (This)->lpVtbl -> SimpleTableFileAdvise(This,i_pISTFile,i_wszDirectory,i_wszFile,i_fFlags,o_pdwCookie)

#define ISimpleTableFileAdvise_SimpleTableFileUnadvise(This,i_dwCookie)	\
    (This)->lpVtbl -> SimpleTableFileUnadvise(This,i_dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableFileAdvise_SimpleTableFileAdvise_Proxy( 
    ISimpleTableFileAdvise * This,
    /* [in] */ ISimpleTableFileChange *i_pISTFile,
    /* [in] */ LPCWSTR i_wszDirectory,
    /* [in] */ LPCWSTR i_wszFile,
    /* [in] */ DWORD i_fFlags,
    /* [out] */ DWORD *o_pdwCookie);


void __RPC_STUB ISimpleTableFileAdvise_SimpleTableFileAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableFileAdvise_SimpleTableFileUnadvise_Proxy( 
    ISimpleTableFileAdvise * This,
    /* [in] */ DWORD i_dwCookie);


void __RPC_STUB ISimpleTableFileAdvise_SimpleTableFileUnadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableFileAdvise_INTERFACE_DEFINED__ */


#ifndef __ISimpleTableDispenserWiring_INTERFACE_DEFINED__
#define __ISimpleTableDispenserWiring_INTERFACE_DEFINED__

/* interface ISimpleTableDispenserWiring */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableDispenserWiring;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8927A44-D3CE-11d1-8472-006008B0E5CA")
    ISimpleTableDispenserWiring : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMarshallingConnection( 
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ REFIID i_riid,
            /* [out] */ void **o_ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExtractWiringInformation( 
            /* [in] */ DWORD i_fClientOrServer,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ ULONG i_QueryType,
            /* [in] */ DWORD i_fTable,
            /* [out] */ CLSID *o_pclsidDataTableDispenser,
            /* [out] */ LPWSTR *o_pwszLocator,
            /* [out] */ CLSID **o_paclsidLogicTableDispenser,
            /* [out] */ ULONG *o_pcLogicTableDispenser,
            /* [out] */ IID *o_pIIDMarshallingConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableDispenserWiringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableDispenserWiring * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableDispenserWiring * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableDispenserWiring * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarshallingConnection )( 
            ISimpleTableDispenserWiring * This,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ REFIID i_riid,
            /* [out] */ void **o_ppv);
        
        HRESULT ( STDMETHODCALLTYPE *ExtractWiringInformation )( 
            ISimpleTableDispenserWiring * This,
            /* [in] */ DWORD i_fClientOrServer,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ ULONG i_QueryType,
            /* [in] */ DWORD i_fTable,
            /* [out] */ CLSID *o_pclsidDataTableDispenser,
            /* [out] */ LPWSTR *o_pwszLocator,
            /* [out] */ CLSID **o_paclsidLogicTableDispenser,
            /* [out] */ ULONG *o_pcLogicTableDispenser,
            /* [out] */ IID *o_pIIDMarshallingConnection);
        
        END_INTERFACE
    } ISimpleTableDispenserWiringVtbl;

    interface ISimpleTableDispenserWiring
    {
        CONST_VTBL struct ISimpleTableDispenserWiringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableDispenserWiring_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableDispenserWiring_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableDispenserWiring_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableDispenserWiring_GetMarshallingConnection(This,i_QueryData,i_QueryMeta,i_eQueryFormat,i_riid,o_ppv)	\
    (This)->lpVtbl -> GetMarshallingConnection(This,i_QueryData,i_QueryMeta,i_eQueryFormat,i_riid,o_ppv)

#define ISimpleTableDispenserWiring_ExtractWiringInformation(This,i_fClientOrServer,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_QueryType,i_fTable,o_pclsidDataTableDispenser,o_pwszLocator,o_paclsidLogicTableDispenser,o_pcLogicTableDispenser,o_pIIDMarshallingConnection)	\
    (This)->lpVtbl -> ExtractWiringInformation(This,i_fClientOrServer,i_wszDatabase,i_wszTable,i_QueryData,i_QueryMeta,i_QueryType,i_fTable,o_pclsidDataTableDispenser,o_pwszLocator,o_paclsidLogicTableDispenser,o_pcLogicTableDispenser,o_pIIDMarshallingConnection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableDispenserWiring_GetMarshallingConnection_Proxy( 
    ISimpleTableDispenserWiring * This,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ DWORD i_eQueryFormat,
    /* [in] */ REFIID i_riid,
    /* [out] */ void **o_ppv);


void __RPC_STUB ISimpleTableDispenserWiring_GetMarshallingConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableDispenserWiring_ExtractWiringInformation_Proxy( 
    ISimpleTableDispenserWiring * This,
    /* [in] */ DWORD i_fClientOrServer,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ ULONG i_QueryType,
    /* [in] */ DWORD i_fTable,
    /* [out] */ CLSID *o_pclsidDataTableDispenser,
    /* [out] */ LPWSTR *o_pwszLocator,
    /* [out] */ CLSID **o_paclsidLogicTableDispenser,
    /* [out] */ ULONG *o_pcLogicTableDispenser,
    /* [out] */ IID *o_pIIDMarshallingConnection);


void __RPC_STUB ISimpleTableDispenserWiring_ExtractWiringInformation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableDispenserWiring_INTERFACE_DEFINED__ */


#ifndef __IShellInitialize_INTERFACE_DEFINED__
#define __IShellInitialize_INTERFACE_DEFINED__

/* interface IShellInitialize */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1AD849E-4495-11d3-B131-00805FC73204")
    IShellInitialize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fTable,
            /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
            /* [in] */ LPCWSTR i_wszLocator,
            /* [in] */ LPVOID i_pvSimpleTable,
            /* [in] */ IInterceptorPlugin *i_pInterceptorPlugin,
            /* [in] */ ISimplePlugin *i_pReadPlugin,
            /* [in] */ ISimplePlugin *i_pWritePlugin,
            /* [out] */ LPVOID *o_ppvSimpleTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellInitialize * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellInitialize * This,
            /* [in] */ LPCWSTR i_wszDatabase,
            /* [in] */ LPCWSTR i_wszTable,
            /* [in] */ ULONG i_TableID,
            /* [in] */ LPVOID i_QueryData,
            /* [in] */ LPVOID i_QueryMeta,
            /* [in] */ DWORD i_eQueryFormat,
            /* [in] */ DWORD i_fTable,
            /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
            /* [in] */ LPCWSTR i_wszLocator,
            /* [in] */ LPVOID i_pvSimpleTable,
            /* [in] */ IInterceptorPlugin *i_pInterceptorPlugin,
            /* [in] */ ISimplePlugin *i_pReadPlugin,
            /* [in] */ ISimplePlugin *i_pWritePlugin,
            /* [out] */ LPVOID *o_ppvSimpleTable);
        
        END_INTERFACE
    } IShellInitializeVtbl;

    interface IShellInitialize
    {
        CONST_VTBL struct IShellInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellInitialize_Initialize(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fTable,i_pISTDisp,i_wszLocator,i_pvSimpleTable,i_pInterceptorPlugin,i_pReadPlugin,i_pWritePlugin,o_ppvSimpleTable)	\
    (This)->lpVtbl -> Initialize(This,i_wszDatabase,i_wszTable,i_TableID,i_QueryData,i_QueryMeta,i_eQueryFormat,i_fTable,i_pISTDisp,i_wszLocator,i_pvSimpleTable,i_pInterceptorPlugin,i_pReadPlugin,i_pWritePlugin,o_ppvSimpleTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellInitialize_Initialize_Proxy( 
    IShellInitialize * This,
    /* [in] */ LPCWSTR i_wszDatabase,
    /* [in] */ LPCWSTR i_wszTable,
    /* [in] */ ULONG i_TableID,
    /* [in] */ LPVOID i_QueryData,
    /* [in] */ LPVOID i_QueryMeta,
    /* [in] */ DWORD i_eQueryFormat,
    /* [in] */ DWORD i_fTable,
    /* [in] */ IAdvancedTableDispenser *i_pISTDisp,
    /* [in] */ LPCWSTR i_wszLocator,
    /* [in] */ LPVOID i_pvSimpleTable,
    /* [in] */ IInterceptorPlugin *i_pInterceptorPlugin,
    /* [in] */ ISimplePlugin *i_pReadPlugin,
    /* [in] */ ISimplePlugin *i_pWritePlugin,
    /* [out] */ LPVOID *o_ppvSimpleTable);


void __RPC_STUB IShellInitialize_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellInitialize_INTERFACE_DEFINED__ */


#ifndef __ISimpleClientTableOptimizer_INTERFACE_DEFINED__
#define __ISimpleClientTableOptimizer_INTERFACE_DEFINED__

/* interface ISimpleClientTableOptimizer */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleClientTableOptimizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0D911F10-DAEE-11d1-8476-006008B0E5CA")
    ISimpleClientTableOptimizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMarshallingConnection( 
            LPVOID i_pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleClientTableOptimizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleClientTableOptimizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleClientTableOptimizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleClientTableOptimizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMarshallingConnection )( 
            ISimpleClientTableOptimizer * This,
            LPVOID i_pUnk);
        
        END_INTERFACE
    } ISimpleClientTableOptimizerVtbl;

    interface ISimpleClientTableOptimizer
    {
        CONST_VTBL struct ISimpleClientTableOptimizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleClientTableOptimizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleClientTableOptimizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleClientTableOptimizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleClientTableOptimizer_SetMarshallingConnection(This,i_pUnk)	\
    (This)->lpVtbl -> SetMarshallingConnection(This,i_pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleClientTableOptimizer_SetMarshallingConnection_Proxy( 
    ISimpleClientTableOptimizer * This,
    LPVOID i_pUnk);


void __RPC_STUB ISimpleClientTableOptimizer_SetMarshallingConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleClientTableOptimizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0029 */
/* [local] */ 

#define fST_MCACHE_READ				0x00010000
#define fST_MCACHE_WRITE				0x00020000
#define fST_MCACHE_ERRS				0x00040000
#define fST_MCACHE_WRITE_COPY		0x00080000
#define fST_MCACHE_WRITE_MERGE		0x00100000
#define maskfST_MCACHE				0x001F0000


extern RPC_IF_HANDLE __MIDL_itf_catalog_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0029_v0_0_s_ifspec;

#ifndef __ISimpleTableMarshall_INTERFACE_DEFINED__
#define __ISimpleTableMarshall_INTERFACE_DEFINED__

/* interface ISimpleTableMarshall */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableMarshall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7073790-bbc6-11d1-9d31-006008b0e5ca")
    ISimpleTableMarshall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SupplyMarshallable( 
            /* [in] */ DWORD i_fCaches,
            /* [size_is][size_is][out] */ char **o_ppv1,
            /* [out] */ ULONG *o_pcb1,
            /* [size_is][size_is][out] */ char **o_ppv2,
            /* [out] */ ULONG *o_pcb2,
            /* [size_is][size_is][out] */ char **o_ppv3,
            /* [out] */ ULONG *o_pcb3,
            /* [size_is][size_is][out] */ char **o_ppv4,
            /* [out] */ ULONG *o_pcb4,
            /* [size_is][size_is][out] */ char **o_ppv5,
            /* [out] */ ULONG *o_pcb5) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConsumeMarshallable( 
            /* [in] */ DWORD i_fCaches,
            /* [unique][size_is][in] */ char *i_pv1,
            /* [in] */ ULONG i_cb1,
            /* [unique][size_is][in] */ char *i_pv2,
            /* [in] */ ULONG i_cb2,
            /* [unique][size_is][in] */ char *i_pv3,
            /* [in] */ ULONG i_cb3,
            /* [unique][size_is][in] */ char *i_pv4,
            /* [in] */ ULONG i_cb4,
            /* [unique][size_is][in] */ char *i_pv5,
            /* [in] */ ULONG i_cb5) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableMarshallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableMarshall * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableMarshall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableMarshall * This);
        
        HRESULT ( STDMETHODCALLTYPE *SupplyMarshallable )( 
            ISimpleTableMarshall * This,
            /* [in] */ DWORD i_fCaches,
            /* [size_is][size_is][out] */ char **o_ppv1,
            /* [out] */ ULONG *o_pcb1,
            /* [size_is][size_is][out] */ char **o_ppv2,
            /* [out] */ ULONG *o_pcb2,
            /* [size_is][size_is][out] */ char **o_ppv3,
            /* [out] */ ULONG *o_pcb3,
            /* [size_is][size_is][out] */ char **o_ppv4,
            /* [out] */ ULONG *o_pcb4,
            /* [size_is][size_is][out] */ char **o_ppv5,
            /* [out] */ ULONG *o_pcb5);
        
        HRESULT ( STDMETHODCALLTYPE *ConsumeMarshallable )( 
            ISimpleTableMarshall * This,
            /* [in] */ DWORD i_fCaches,
            /* [unique][size_is][in] */ char *i_pv1,
            /* [in] */ ULONG i_cb1,
            /* [unique][size_is][in] */ char *i_pv2,
            /* [in] */ ULONG i_cb2,
            /* [unique][size_is][in] */ char *i_pv3,
            /* [in] */ ULONG i_cb3,
            /* [unique][size_is][in] */ char *i_pv4,
            /* [in] */ ULONG i_cb4,
            /* [unique][size_is][in] */ char *i_pv5,
            /* [in] */ ULONG i_cb5);
        
        END_INTERFACE
    } ISimpleTableMarshallVtbl;

    interface ISimpleTableMarshall
    {
        CONST_VTBL struct ISimpleTableMarshallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableMarshall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableMarshall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableMarshall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableMarshall_SupplyMarshallable(This,i_fCaches,o_ppv1,o_pcb1,o_ppv2,o_pcb2,o_ppv3,o_pcb3,o_ppv4,o_pcb4,o_ppv5,o_pcb5)	\
    (This)->lpVtbl -> SupplyMarshallable(This,i_fCaches,o_ppv1,o_pcb1,o_ppv2,o_pcb2,o_ppv3,o_pcb3,o_ppv4,o_pcb4,o_ppv5,o_pcb5)

#define ISimpleTableMarshall_ConsumeMarshallable(This,i_fCaches,i_pv1,i_cb1,i_pv2,i_cb2,i_pv3,i_cb3,i_pv4,i_cb4,i_pv5,i_cb5)	\
    (This)->lpVtbl -> ConsumeMarshallable(This,i_fCaches,i_pv1,i_cb1,i_pv2,i_cb2,i_pv3,i_cb3,i_pv4,i_cb4,i_pv5,i_cb5)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableMarshall_SupplyMarshallable_Proxy( 
    ISimpleTableMarshall * This,
    /* [in] */ DWORD i_fCaches,
    /* [size_is][size_is][out] */ char **o_ppv1,
    /* [out] */ ULONG *o_pcb1,
    /* [size_is][size_is][out] */ char **o_ppv2,
    /* [out] */ ULONG *o_pcb2,
    /* [size_is][size_is][out] */ char **o_ppv3,
    /* [out] */ ULONG *o_pcb3,
    /* [size_is][size_is][out] */ char **o_ppv4,
    /* [out] */ ULONG *o_pcb4,
    /* [size_is][size_is][out] */ char **o_ppv5,
    /* [out] */ ULONG *o_pcb5);


void __RPC_STUB ISimpleTableMarshall_SupplyMarshallable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableMarshall_ConsumeMarshallable_Proxy( 
    ISimpleTableMarshall * This,
    /* [in] */ DWORD i_fCaches,
    /* [unique][size_is][in] */ char *i_pv1,
    /* [in] */ ULONG i_cb1,
    /* [unique][size_is][in] */ char *i_pv2,
    /* [in] */ ULONG i_cb2,
    /* [unique][size_is][in] */ char *i_pv3,
    /* [in] */ ULONG i_cb3,
    /* [unique][size_is][in] */ char *i_pv4,
    /* [in] */ ULONG i_cb4,
    /* [unique][size_is][in] */ char *i_pv5,
    /* [in] */ ULONG i_cb5);


void __RPC_STUB ISimpleTableMarshall_ConsumeMarshallable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableMarshall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0030 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_catalog_0030_0001
    {
    LPWSTR wszLogicalPath;
    STQueryCell *aQueryCells;
    ULONG cNrQueryCells;
    BOOL fAllowOverride;
    } 	STConfigStore;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0030_v0_0_s_ifspec;

#ifndef __ISimpleTableTransform_INTERFACE_DEFINED__
#define __ISimpleTableTransform_INTERFACE_DEFINED__

/* interface ISimpleTableTransform */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7965650C-4DBE-4c97-9E15-321D4A92A795")
    ISimpleTableTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISimpleTableDispenser2 *i_pDispenser,
            /* [in] */ LPCWSTR i_wszProtocol,
            /* [in] */ LPCWSTR i_wszSelector,
            /* [out] */ ULONG *o_pcRealConfigStores,
            /* [out] */ ULONG *o_pcPossibleConfigStores) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRealConfigStores( 
            /* [in] */ ULONG i_cConfigStores,
            /* [size_is][out][in] */ STConfigStore *io_paConfigStores) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPossibleConfigStores( 
            /* [in] */ ULONG i_cPossibleConfigStores,
            /* [size_is][out][in] */ STConfigStore *io_paConfigStores) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableTransform * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISimpleTableTransform * This,
            /* [in] */ ISimpleTableDispenser2 *i_pDispenser,
            /* [in] */ LPCWSTR i_wszProtocol,
            /* [in] */ LPCWSTR i_wszSelector,
            /* [out] */ ULONG *o_pcRealConfigStores,
            /* [out] */ ULONG *o_pcPossibleConfigStores);
        
        HRESULT ( STDMETHODCALLTYPE *GetRealConfigStores )( 
            ISimpleTableTransform * This,
            /* [in] */ ULONG i_cConfigStores,
            /* [size_is][out][in] */ STConfigStore *io_paConfigStores);
        
        HRESULT ( STDMETHODCALLTYPE *GetPossibleConfigStores )( 
            ISimpleTableTransform * This,
            /* [in] */ ULONG i_cPossibleConfigStores,
            /* [size_is][out][in] */ STConfigStore *io_paConfigStores);
        
        END_INTERFACE
    } ISimpleTableTransformVtbl;

    interface ISimpleTableTransform
    {
        CONST_VTBL struct ISimpleTableTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableTransform_Initialize(This,i_pDispenser,i_wszProtocol,i_wszSelector,o_pcRealConfigStores,o_pcPossibleConfigStores)	\
    (This)->lpVtbl -> Initialize(This,i_pDispenser,i_wszProtocol,i_wszSelector,o_pcRealConfigStores,o_pcPossibleConfigStores)

#define ISimpleTableTransform_GetRealConfigStores(This,i_cConfigStores,io_paConfigStores)	\
    (This)->lpVtbl -> GetRealConfigStores(This,i_cConfigStores,io_paConfigStores)

#define ISimpleTableTransform_GetPossibleConfigStores(This,i_cPossibleConfigStores,io_paConfigStores)	\
    (This)->lpVtbl -> GetPossibleConfigStores(This,i_cPossibleConfigStores,io_paConfigStores)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableTransform_Initialize_Proxy( 
    ISimpleTableTransform * This,
    /* [in] */ ISimpleTableDispenser2 *i_pDispenser,
    /* [in] */ LPCWSTR i_wszProtocol,
    /* [in] */ LPCWSTR i_wszSelector,
    /* [out] */ ULONG *o_pcRealConfigStores,
    /* [out] */ ULONG *o_pcPossibleConfigStores);


void __RPC_STUB ISimpleTableTransform_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableTransform_GetRealConfigStores_Proxy( 
    ISimpleTableTransform * This,
    /* [in] */ ULONG i_cConfigStores,
    /* [size_is][out][in] */ STConfigStore *io_paConfigStores);


void __RPC_STUB ISimpleTableTransform_GetRealConfigStores_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableTransform_GetPossibleConfigStores_Proxy( 
    ISimpleTableTransform * This,
    /* [in] */ ULONG i_cPossibleConfigStores,
    /* [size_is][out][in] */ STConfigStore *io_paConfigStores);


void __RPC_STUB ISimpleTableTransform_GetPossibleConfigStores_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableTransform_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_catalog_0031 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_catalog_0031_0001
    {
    BOOL fAllowOverride;
    } 	STMergeContext;



extern RPC_IF_HANDLE __MIDL_itf_catalog_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_catalog_0031_v0_0_s_ifspec;

#ifndef __ISimpleTableMerge_INTERFACE_DEFINED__
#define __ISimpleTableMerge_INTERFACE_DEFINED__

/* interface ISimpleTableMerge */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISimpleTableMerge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0A1A94A-8032-4666-9B52-1D822CFED2A2")
    ISimpleTableMerge : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ULONG i_cNrColumns,
            /* [in] */ ULONG i_cNrPKColumns,
            /* [size_is][in] */ ULONG *i_aPKColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ ISimpleTableRead2 *i_pSTRead,
            /* [out][in] */ ISimpleTableWrite2 *io_pCache,
            /* [in] */ STMergeContext *i_pContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleTableMergeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleTableMerge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleTableMerge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleTableMerge * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISimpleTableMerge * This,
            /* [in] */ ULONG i_cNrColumns,
            /* [in] */ ULONG i_cNrPKColumns,
            /* [size_is][in] */ ULONG *i_aPKColumns);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            ISimpleTableMerge * This,
            /* [in] */ ISimpleTableRead2 *i_pSTRead,
            /* [out][in] */ ISimpleTableWrite2 *io_pCache,
            /* [in] */ STMergeContext *i_pContext);
        
        END_INTERFACE
    } ISimpleTableMergeVtbl;

    interface ISimpleTableMerge
    {
        CONST_VTBL struct ISimpleTableMergeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleTableMerge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleTableMerge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleTableMerge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleTableMerge_Initialize(This,i_cNrColumns,i_cNrPKColumns,i_aPKColumns)	\
    (This)->lpVtbl -> Initialize(This,i_cNrColumns,i_cNrPKColumns,i_aPKColumns)

#define ISimpleTableMerge_Merge(This,i_pSTRead,io_pCache,i_pContext)	\
    (This)->lpVtbl -> Merge(This,i_pSTRead,io_pCache,i_pContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleTableMerge_Initialize_Proxy( 
    ISimpleTableMerge * This,
    /* [in] */ ULONG i_cNrColumns,
    /* [in] */ ULONG i_cNrPKColumns,
    /* [size_is][in] */ ULONG *i_aPKColumns);


void __RPC_STUB ISimpleTableMerge_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleTableMerge_Merge_Proxy( 
    ISimpleTableMerge * This,
    /* [in] */ ISimpleTableRead2 *i_pSTRead,
    /* [out][in] */ ISimpleTableWrite2 *io_pCache,
    /* [in] */ STMergeContext *i_pContext);


void __RPC_STUB ISimpleTableMerge_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleTableMerge_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\import\inc\catmeta.h ===
//  catmeta.h - Table Names and Helper enums and flags.  
//  Generated 05/16/2001 02:09:04 by Catalog Utility - Version 1.00.2830 Build(1) 
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved. 

#ifndef __TABLEINFO_H__  
#define __TABLEINFO_H__  

#ifndef _OBJBASE_H_
    #include <objbase.h>
#endif
#ifdef REGSYSDEFNS_DEFINE
    #include <initguid.h>
#endif

// -----------------------------------------                             
// PRODUCT constants:                                                    
// -----------------------------------------                             
#define WSZ_PRODUCT_APPCENTER	                L"ApplicationCenter"     
#define WSZ_PRODUCT_IIS			            L"IIS"                   
#define WSZ_PRODUCT_NETFRAMEWORKV1            L"NetFrameworkv1"        

//The Meta flags exist in two places.  When a new flag is added it needs 
//into the following:                                                    
//XMLUtility.h                                                           
//CatMeta.xml                                                            

//These macros are needed for the metabase
#define SynIDFromMetaFlagsEx(MetaFlagsEx) ((MetaFlagsEx>>2)&0x0F)
#define kInferredColumnMetaFlags   (fCOLUMNMETA_FOREIGNKEY | fCOLUMNMETA_BOOL | fCOLUMNMETA_FLAG | fCOLUMNMETA_ENUM | fCOLUMNMETA_HASNUMERICRANGE | fCOLUMNMETA_UNKNOWNSIZE | fCOLUMNMETA_VARIABLESIZE)
#define kInferredColumnMetaFlagsEx (fCOLUMNMETA_EXTENDEDTYPE0 | fCOLUMNMETA_EXTENDEDTYPE1 | fCOLUMNMETA_EXTENDEDTYPE2 | fCOLUMNMETA_EXTENDEDTYPE3 | fCOLUMNMETA_EXTENDED | fCOLUMNMETA_USERDEFINED)


//------------------------------DatabaseName---------------------------   
#define wszDATABASE_META                                    L"META"
#define wszDATABASE_ERRORS                                  L"ERRORS"
#define wszDATABASE_PACKEDSCHEMA                            L"PACKEDSCHEMA"
#define wszDATABASE_CONFIGSYS                               L"CONFIGSYS"
#define wszDATABASE_MEMORY                                  L"MEMORY"
#define wszDATABASE_FIXED                                   L"FIXED"
#define wszDATABASE_MOFGENERATOR                            L"MOFGENERATOR"
#define wszDATABASE_METABASE                                L"METABASE"
#define wszDATABASE_IIS                                     L"IIS"





//-------------------------------TableName-----------------------------   
#define wszTABLE_COLUMNMETA                              L"COLUMNMETA"
#define TABLEID_COLUMNMETA                               (0xfe16a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_COLUMNMETA                           (0L)
#define ExtendedVersion_COLUMNMETA                       (0L)

//----------------IndexMeta------------------------   
#define COLUMNMETA_ByName L"ByName"
#define COLUMNMETA_ByID L"ByID"

//-----------------Column Index Enums--------------   
enum eCOLUMNMETA {
    iCOLUMNMETA_Table,  
    iCOLUMNMETA_Index,  
    iCOLUMNMETA_InternalName,  
    iCOLUMNMETA_PublicName,  
    iCOLUMNMETA_Type,  
    iCOLUMNMETA_Size,  
    iCOLUMNMETA_MetaFlags,  
    iCOLUMNMETA_DefaultValue,  
    iCOLUMNMETA_FlagMask,  
    iCOLUMNMETA_StartingNumber,  
    iCOLUMNMETA_EndingNumber,  
    iCOLUMNMETA_CharacterSet,  
    iCOLUMNMETA_SchemaGeneratorFlags,  
    iCOLUMNMETA_ID,  
    iCOLUMNMETA_UserType,  
    iCOLUMNMETA_Attributes,  
    iCOLUMNMETA_Description,  
    iCOLUMNMETA_PublicColumnName,  
    cCOLUMNMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tCOLUMNMETARow {
         WCHAR *     pTable;
         ULONG *     pIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pType;
         ULONG *     pSize;
         ULONG *     pMetaFlags;
 unsigned char *     pDefaultValue;
         ULONG *     pFlagMask;
         ULONG *     pStartingNumber;
         ULONG *     pEndingNumber;
         WCHAR *     pCharacterSet;
         ULONG *     pSchemaGeneratorFlags;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pAttributes;
         WCHAR *     pDescription;
         WCHAR *     pPublicColumnName;
};

enum eCOLUMNMETA_Type {
    eCOLUMNMETA_Boolean           	=	      19,	//(0x00000013)
    eCOLUMNMETA_Bool              	=	      19,	//(0x00000013)
    eCOLUMNMETA_StrictBool        	=	      19,	//(0x00000013)
    eCOLUMNMETA_Enum              	=	      19,	//(0x00000013)
    eCOLUMNMETA_Flag              	=	      19,	//(0x00000013)
    eCOLUMNMETA_int32             	=	      19,	//(0x00000013)
    eCOLUMNMETA_ByteBracketBracket	=	     128,	//(0x00000080)
    eCOLUMNMETA_String            	=	     130,	//(0x00000082)
    eCOLUMNMETA_UI4               	=	      19,	//(0x00000013)
    eCOLUMNMETA_GUID              	=	      72,	//(0x00000048)
    eCOLUMNMETA_BYTES             	=	     128,	//(0x00000080)
    eCOLUMNMETA_WSTR              	=	     130,	//(0x00000082)
    eCOLUMNMETA_DBTIMESTAMP       	=	     135,	//(0x00000087)
    eCOLUMNMETA_DWORD_METADATA    	=	      19,	//(0x00000013)
    eCOLUMNMETA_STRING_METADATA   	=	     130,	//(0x00000082)
    eCOLUMNMETA_BINARY_METADATA   	=	     128,	//(0x00000080)
    eCOLUMNMETA_EXPANDSZ_METADATA 	=	     130,	//(0x00000082)
    eCOLUMNMETA_MULTISZ_METADATA  	=	     130,	//(0x00000082)
    eCOLUMNMETA_BOOL_BITMASK      	=	      19,	//(0x00000013)
    eCOLUMNMETA_MIMEMAP           	=	     130,	//(0x00000082)
    eCOLUMNMETA_IPSECLIST         	=	     128,	//(0x00000080)
    eCOLUMNMETA_NTACL             	=	     128,	//(0x00000080)
    eCOLUMNMETA_HTTPERRORS        	=	     130,	//(0x00000082)
    eCOLUMNMETA_HTTPHEADERS       	=	     130,	//(0x00000082)
    eCOLUMNMETA_XMLBLOB           	=	     130	//(0x00000082)
};

enum eCOLUMNMETA_MetaFlags {
    fCOLUMNMETA_PRIMARYKEY        	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_FOREIGNKEY        	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_NAMECOLUMN        	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_NAVCOLUMN         	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_DIRECTIVE         	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_BOOL              	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_FLAG              	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_ENUM              	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_WRITENEVER        	=	0x00000100,	//(256 decimal)
    fCOLUMNMETA_WRITEONCHANGE     	=	0x00000200,	//(512 decimal)
    fCOLUMNMETA_WRITEONINSERT     	=	0x00000400,	//(1024 decimal)
    fCOLUMNMETA_NOTPUBLIC         	=	0x00000800,	//(2048 decimal)
    fCOLUMNMETA_NOTDOCD           	=	0x00001000,	//(4096 decimal)
    fCOLUMNMETA_PUBLICREADONLY    	=	0x00002000,	//(8192 decimal)
    fCOLUMNMETA_PUBLICWRITEONLY   	=	0x00004000,	//(16384 decimal)
    fCOLUMNMETA_INSERTGENERATE    	=	0x00010000,	//(65536 decimal)
    fCOLUMNMETA_INSERTUNIQUE      	=	0x00020000,	//(131072 decimal)
    fCOLUMNMETA_INSERTPARENT      	=	0x00040000,	//(262144 decimal)
    fCOLUMNMETA_NOTNULLABLE       	=	0x00080000,	//(524288 decimal)
    fCOLUMNMETA_FIXEDLENGTH       	=	0x00100000,	//(1048576 decimal)
    fCOLUMNMETA_HASNUMERICRANGE   	=	0x00200000,	//(2097152 decimal)
    fCOLUMNMETA_LEGALCHARSET      	=	0x00400000,	//(4194304 decimal)
    fCOLUMNMETA_ILLEGALCHARSET    	=	0x00800000,	//(8388608 decimal)
    fCOLUMNMETA_NOTPERSISTABLE    	=	0x01000000,	//(16777216 decimal)
    fCOLUMNMETA_MULTISTRING       	=	0x02000000,	//(33554432 decimal)
    fCOLUMNMETA_EXPANDSTRING      	=	0x04000000,	//(67108864 decimal)
    fCOLUMNMETA_UNKNOWNSIZE       	=	0x08000000,	//(134217728 decimal)
    fCOLUMNMETA_VARIABLESIZE      	=	0x10000000,	//(268435456 decimal)
    fCOLUMNMETA_CASEINSENSITIVE   	=	0x20000000,	//(536870912 decimal)
    fCOLUMNMETA_TOLOWERCASE       	=	0x40000000,	//(1073741824 decimal)
    fCOLUMNMETA_MetaFlags_Mask	= 0x7fff7fff
};

enum eCOLUMNMETA_SchemaGeneratorFlags {
    fCOLUMNMETA_CACHE_PROPERTY_MODIFIED	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_CACHE_PROPERTY_CLEARED	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_EXTENDEDTYPE0     	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_EXTENDEDTYPE1     	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_EXTENDEDTYPE2     	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_EXTENDEDTYPE3     	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_PROPERTYISINHERITED	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_USEASPUBLICROWNAME	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_EXTENDED          	=	0x00000100,	//(256 decimal)
    fCOLUMNMETA_MANDATORY         	=	0x00000200,	//(512 decimal)
    fCOLUMNMETA_USERDEFINED       	=	0x00000400,	//(1024 decimal)
    fCOLUMNMETA_WAS_NOTIFICATION  	=	0x00000800,	//(2048 decimal)
    fCOLUMNMETA_XMLBLOB           	=	0x00001000,	//(4096 decimal)
    fCOLUMNMETA_HIDDEN            	=	0x00010000,	//(65536 decimal)
    fCOLUMNMETA_WAS_NOTIFICATION_ON_NO_CHANGE_IN_VALUE	=	0x00002000,	//(8192 decimal)
    fCOLUMNMETA_VALUEINCHILDELEMENT	=	0x00004000,	//(16384 decimal)
    fCOLUMNMETA_SchemaGeneratorFlags_Mask	= 0x00017fff
};

enum eCOLUMNMETA_UserType {
    eCOLUMNMETA_UNKNOWN_UserType  	=	       0,	//(0x00000000)
    eCOLUMNMETA_IIS_MD_UT_SERVER  	=	       1,	//(0x00000001)
    eCOLUMNMETA_IIS_MD_UT_FILE    	=	       2,	//(0x00000002)
    eCOLUMNMETA_IIS_MD_UT_WAM     	=	     100,	//(0x00000064)
    eCOLUMNMETA_ASP_MD_UT_APP     	=	     101	//(0x00000065)
};

enum eCOLUMNMETA_Attributes {
    fCOLUMNMETA_NO_ATTRIBUTES     	=	0x00000000,	//(0 decimal)
    fCOLUMNMETA_INHERIT           	=	0x00000001,	//(1 decimal)
    fCOLUMNMETA_PARTIAL_PATH      	=	0x00000002,	//(2 decimal)
    fCOLUMNMETA_SECURE            	=	0x00000004,	//(4 decimal)
    fCOLUMNMETA_REFERENCE         	=	0x00000008,	//(8 decimal)
    fCOLUMNMETA_VOLATILE          	=	0x00000010,	//(16 decimal)
    fCOLUMNMETA_ISINHERITED       	=	0x00000020,	//(32 decimal)
    fCOLUMNMETA_INSERT_PATH       	=	0x00000040,	//(64 decimal)
    fCOLUMNMETA_LOCAL_MACHINE_ONLY	=	0x00000080,	//(128 decimal)
    fCOLUMNMETA_Attributes_Mask	= 0x000000ff
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_DATABASEMETA                            L"DATABASEMETA"
#define TABLEID_DATABASEMETA                             (0xb125a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_DATABASEMETA                         (0L)
#define ExtendedVersion_DATABASEMETA                     (0L)

//-----------------Column Index Enums--------------   
enum eDATABASEMETA {
    iDATABASEMETA_InternalName,  
    iDATABASEMETA_PublicName,  
    iDATABASEMETA_BaseVersion,  
    iDATABASEMETA_ExtendedVersion,  
    iDATABASEMETA_CountOfTables,  
    iDATABASEMETA_Description,  
    cDATABASEMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tDATABASEMETARow {
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pCountOfTables;
         WCHAR *     pDescription;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_INDEXMETA                               L"INDEXMETA"
#define TABLEID_INDEXMETA                                (0x7530a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_INDEXMETA                            (0L)
#define ExtendedVersion_INDEXMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eINDEXMETA {
    iINDEXMETA_Table,  
    iINDEXMETA_InternalName,  
    iINDEXMETA_PublicName,  
    iINDEXMETA_ColumnIndex,  
    iINDEXMETA_ColumnInternalName,  
    iINDEXMETA_MetaFlags,  
    cINDEXMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tINDEXMETARow {
         WCHAR *     pTable;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pColumnIndex;
         WCHAR *     pColumnInternalName;
         ULONG *     pMetaFlags;
};

enum eINDEXMETA_MetaFlags {
    fINDEXMETA_UNIQUE             	=	0x00000001,	//(1 decimal)
    fINDEXMETA_SORTED             	=	0x00000002,	//(2 decimal)
    fINDEXMETA_MetaFlags_Mask	= 0x00000003
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TABLEMETA                               L"TABLEMETA"
#define TABLEID_TABLEMETA                                (0x6ba9a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TABLEMETA                            (0L)
#define ExtendedVersion_TABLEMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eTABLEMETA {
    iTABLEMETA_Database,  
    iTABLEMETA_InternalName,  
    iTABLEMETA_PublicName,  
    iTABLEMETA_PublicRowName,  
    iTABLEMETA_BaseVersion,  
    iTABLEMETA_ExtendedVersion,  
    iTABLEMETA_NameColumn,  
    iTABLEMETA_NavColumn,  
    iTABLEMETA_CountOfColumns,  
    iTABLEMETA_MetaFlags,  
    iTABLEMETA_SchemaGeneratorFlags,  
    iTABLEMETA_ConfigItemName,  
    iTABLEMETA_ConfigCollectionName,  
    iTABLEMETA_PublicRowNameColumn,  
    iTABLEMETA_ContainerClassList,  
    iTABLEMETA_Description,  
    iTABLEMETA_ChildElementName,  
    cTABLEMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTABLEMETARow {
         WCHAR *     pDatabase;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         WCHAR *     pPublicRowName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pNameColumn;
         ULONG *     pNavColumn;
         ULONG *     pCountOfColumns;
         ULONG *     pMetaFlags;
         ULONG *     pSchemaGeneratorFlags;
         WCHAR *     pConfigItemName;
         WCHAR *     pConfigCollectionName;
         ULONG *     pPublicRowNameColumn;
         WCHAR *     pContainerClassList;
         WCHAR *     pDescription;
         WCHAR *     pChildElementName;
};

enum eTABLEMETA_MetaFlags {
    fTABLEMETA_INTERNAL           	=	0x00000001,	//(1 decimal)
    fTABLEMETA_NOLISTENING        	=	0x00000002,	//(2 decimal)
    fTABLEMETA_RELATIONINTEGRITY  	=	0x00000004,	//(4 decimal)
    fTABLEMETA_ROWINTEGRITY       	=	0x00000008,	//(8 decimal)
    fTABLEMETA_HASUNKNOWNSIZES    	=	0x00000010,	//(16 decimal)
    fTABLEMETA_NOPUBLICINSERT     	=	0x00000020,	//(32 decimal)
    fTABLEMETA_NOPUBLICUPDATE     	=	0x00000040,	//(64 decimal)
    fTABLEMETA_NOPUBLICDELETE     	=	0x00000080,	//(128 decimal)
    fTABLEMETA_REQUIRESQUERY      	=	0x00000100,	//(256 decimal)
    fTABLEMETA_HASDIRECTIVES      	=	0x00000200,	//(512 decimal)
    fTABLEMETA_STOREDELTAS        	=	0x00000400,	//(1024 decimal)
    fTABLEMETA_AUTOGENITEMCLASS   	=	0x00000800,	//(2048 decimal)
    fTABLEMETA_AUTOGENCOLLECTIONCLASS	=	0x00001000,	//(4096 decimal)
    fTABLEMETA_OVERRIDEITEMCLASS  	=	0x00002000,	//(8192 decimal)
    fTABLEMETA_OVERRIDECOLLECTIONCLASS	=	0x00004000,	//(16384 decimal)
    fTABLEMETA_NAMEVALUEPAIRTABLE 	=	0x00008000,	//(32768 decimal)
    fTABLEMETA_HIDDEN             	=	0x00010000,	//(65536 decimal)
    fTABLEMETA_OVERWRITEALLROWS   	=	0x00020000,	//(131072 decimal)
    fTABLEMETA_MetaFlags_Mask	= 0x0003ffff
};

enum eTABLEMETA_SchemaGeneratorFlags {
    fTABLEMETA_EMITXMLSCHEMA      	=	0x00000001,	//(1 decimal)
    fTABLEMETA_EMITCLBBLOB        	=	0x00000002,	//(2 decimal)
    fTABLEMETA_ISCONTAINED        	=	0x00000004,	//(4 decimal)
    fTABLEMETA_NOTSCOPEDBYTABLENAME	=	0x00000008,	//(8 decimal)
    fTABLEMETA_GENERATECONFIGOBJECTS	=	0x00000010,	//(16 decimal)
    fTABLEMETA_NOTABLESCHEMAHEAPENTRY	=	0x00000020,	//(32 decimal)
    fTABLEMETA_CONTAINERCLASS     	=	0x00000040,	//(64 decimal)
    fTABLEMETA_EXTENDED           	=	0x00000100,	//(256 decimal)
    fTABLEMETA_USERDEFINED        	=	0x00000400,	//(1024 decimal)
    fTABLEMETA_SchemaGeneratorFlags_Mask	= 0x0000057f
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TAGMETA                                 L"TAGMETA"
#define TABLEID_TAGMETA                                  (0x06bfa100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_TAGMETA                              (0L)
#define ExtendedVersion_TAGMETA                          (0L)

//----------------IndexMeta------------------------   
#define TAGMETA_ByTableAndTagNameOnly L"ByTableAndTagNameOnly"
#define TAGMETA_ByTableAndColumnIndexOnly L"ByTableAndColumnIndexOnly"
#define TAGMETA_ByTableAndColumnIndexAndNameOnly L"ByTableAndColumnIndexAndNameOnly"
#define TAGMETA_ByTableAndColumnIndexAndValueOnly L"ByTableAndColumnIndexAndValueOnly"
#define TAGMETA_ByTableAndTagIDOnly L"ByTableAndTagIDOnly"

//-----------------Column Index Enums--------------   
enum eTAGMETA {
    iTAGMETA_Table,  
    iTAGMETA_ColumnIndex,  
    iTAGMETA_InternalName,  
    iTAGMETA_PublicName,  
    iTAGMETA_Value,  
    iTAGMETA_ID,  
    cTAGMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tTAGMETARow {
         WCHAR *     pTable;
         ULONG *     pColumnIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pValue;
         ULONG *     pID;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_RELATIONMETA                            L"RELATIONMETA"
#define TABLEID_RELATIONMETA                             (0x16dea100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_RELATIONMETA                         (0L)
#define ExtendedVersion_RELATIONMETA                     (0L)

//-----------------Column Index Enums--------------   
enum eRELATIONMETA {
    iRELATIONMETA_PrimaryTable,  
    iRELATIONMETA_PrimaryColumns,  
    iRELATIONMETA_ForeignTable,  
    iRELATIONMETA_ForeignColumns,  
    iRELATIONMETA_MetaFlags,  
    cRELATIONMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tRELATIONMETARow {
         WCHAR *     pPrimaryTable;
 unsigned char *     pPrimaryColumns;
         WCHAR *     pForeignTable;
 unsigned char *     pForeignColumns;
         ULONG *     pMetaFlags;
};

enum eRELATIONMETA_MetaFlags {
    fRELATIONMETA_CASCADEDELETE   	=	0x00000001,	//(1 decimal)
    fRELATIONMETA_PRIMARYREQUIRED 	=	0x00000002,	//(2 decimal)
    fRELATIONMETA_USECONTAINMENT  	=	0x00000004,	//(4 decimal)
    fRELATIONMETA_CONTAINASSIBLING	=	0x00000008,	//(8 decimal)
    fRELATIONMETA_HIDDEN          	=	0x00010000,	//(65536 decimal)
    fRELATIONMETA_MetaFlags_Mask	= 0x0001000f
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_QUERYMETA                               L"QUERYMETA"
#define TABLEID_QUERYMETA                                (0x6bbda100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_QUERYMETA                            (0L)
#define ExtendedVersion_QUERYMETA                        (0L)

//-----------------Column Index Enums--------------   
enum eQUERYMETA {
    iQUERYMETA_Table,  
    iQUERYMETA_InternalName,  
    iQUERYMETA_PublicName,  
    iQUERYMETA_Index,  
    iQUERYMETA_CellName,  
    iQUERYMETA_Operator,  
    iQUERYMETA_MetaFlags,  
    cQUERYMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tQUERYMETARow {
         WCHAR *     pTable;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pIndex;
         WCHAR *     pCellName;
         ULONG *     pOperator;
         ULONG *     pMetaFlags;
};

enum eQUERYMETA_Operator {
    eQUERYMETA_EQUAL              	=	       0,	//(0x00000000)
    eQUERYMETA_NOTEQUAL           	=	       1	//(0x00000001)
};

enum eQUERYMETA_MetaFlags {
    fQUERYMETA_ALL                	=	0x00000001,	//(1 decimal)
    fQUERYMETA_ANY                	=	0x00000002,	//(2 decimal)
    fQUERYMETA_MetaFlags_Mask	= 0x00000003
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SERVERWIRINGMETA                        L"SERVERWIRINGMETA"
#define TABLEID_SERVERWIRINGMETA                         (0xd653ba00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SERVERWIRINGMETA                     (0L)
#define ExtendedVersion_SERVERWIRINGMETA                 (0L)

//-----------------Column Index Enums--------------   
enum eSERVERWIRINGMETA {
    iSERVERWIRINGMETA_Table,  
    iSERVERWIRINGMETA_Order,  
    iSERVERWIRINGMETA_ReadPlugin,  
    iSERVERWIRINGMETA_ReadPluginDLLName,  
    iSERVERWIRINGMETA_WritePlugin,  
    iSERVERWIRINGMETA_WritePluginDLLName,  
    iSERVERWIRINGMETA_Interceptor,  
    iSERVERWIRINGMETA_InterceptorDLLName,  
    iSERVERWIRINGMETA_MetaFlags,  
    iSERVERWIRINGMETA_Locator,  
    iSERVERWIRINGMETA_Reserved,  
    iSERVERWIRINGMETA_Merger,  
    iSERVERWIRINGMETA_MergerDLLName,  
    cSERVERWIRINGMETA_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSERVERWIRINGMETARow {
         WCHAR *     pTable;
         ULONG *     pOrder;
         ULONG *     pReadPlugin;
         WCHAR *     pReadPluginDLLName;
         ULONG *     pWritePlugin;
         WCHAR *     pWritePluginDLLName;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorDLLName;
         ULONG *     pMetaFlags;
         WCHAR *     pLocator;
         ULONG *     pReserved;
         ULONG *     pMerger;
         WCHAR *     pMergerDLLName;
};

enum eSERVERWIRINGMETA_ReadPlugin {
    eSERVERWIRINGMETA_RPNone      	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_RPDucttape_CFGValidationPlugin	=	    1001,	//(0x000003e9)
    eSERVERWIRINGMETA_RPTracer    	=	    1002,	//(0x000003ea)
    eSERVERWIRINGMETA_AddRemoveClearReadPlugin	=	    1003	//(0x000003eb)
};

enum eSERVERWIRINGMETA_WritePlugin {
    eSERVERWIRINGMETA_WPNone      	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_WPTracer    	=	    2001,	//(0x000007d1)
    eSERVERWIRINGMETA_AddRemoveClearWritePlugin	=	    2002	//(0x000007d2)
};

enum eSERVERWIRINGMETA_Interceptor {
    eSERVERWIRINGMETA_NoInterceptor	=	       0,	//(0x00000000)
    eSERVERWIRINGMETA_TableDispenser	=	       1,	//(0x00000001)
    eSERVERWIRINGMETA_Core_FixedInterceptor	=	       2,	//(0x00000002)
    eSERVERWIRINGMETA_Core_ComplibInterceptor	=	       3,	//(0x00000003)
    eSERVERWIRINGMETA_Core_XMLInterceptor	=	       4,	//(0x00000004)
    eSERVERWIRINGMETA_Core_EventInterceptor	=	       5,	//(0x00000005)
    eSERVERWIRINGMETA_Core_MemoryInterceptor	=	       6,	//(0x00000006)
    eSERVERWIRINGMETA_Core_MergeDirectivesInterceptor	=	       7,	//(0x00000007)
    eSERVERWIRINGMETA_Core_AssemblyInterceptor	=	       8,	//(0x00000008)
    eSERVERWIRINGMETA_Core_AssemblyInterceptor2	=	       9,	//(0x00000009)
    eSERVERWIRINGMETA_Core_FixedPackedInterceptor	=	      10,	//(0x0000000a)
    eSERVERWIRINGMETA_Ducttape_FileNameInterceptor	=	      11,	//(0x0000000b)
    eSERVERWIRINGMETA_WebServer_ValidationInterceptor	=	      12,	//(0x0000000c)
    eSERVERWIRINGMETA_Ducttape_WriteInterceptor	=	      13,	//(0x0000000d)
    eSERVERWIRINGMETA_Core_MetabaseInterceptor	=	      14,	//(0x0000000e)
    eSERVERWIRINGMETA_Core_MetabaseDifferencingInterceptor	=	      15,	//(0x0000000f)
    eSERVERWIRINGMETA_Core_MetaMergeInterceptor	=	      16,	//(0x00000010)
    eSERVERWIRINGMETA_Core_DetailedErrorInterceptor	=	      17,	//(0x00000011)
    eSERVERWIRINGMETA_Core_MergeInterceptor	=	      18,	//(0x00000012)
    eSERVERWIRINGMETA_AppCenter_ASAIInterceptor	=	      19	//(0x00000013)
};

enum eSERVERWIRINGMETA_MetaFlags {
    fSERVERWIRINGMETA_First       	=	0x00000001,	//(1 decimal)
    fSERVERWIRINGMETA_Next        	=	0x00000002,	//(2 decimal)
    fSERVERWIRINGMETA_Last        	=	0x00000004,	//(4 decimal)
    fSERVERWIRINGMETA_NoNext      	=	0x00000008,	//(8 decimal)
    fSERVERWIRINGMETA_WireOnWriteOnly	=	0x00000010,	//(16 decimal)
    fSERVERWIRINGMETA_WireOnReadWrite	=	0x00000020,	//(32 decimal)
    fSERVERWIRINGMETA_ReadOnly    	=	0x00000040,	//(64 decimal)
    fSERVERWIRINGMETA_MetaFlags_Mask	= 0x0000007f
};

enum eSERVERWIRINGMETA_Merger {
    eSERVERWIRINGMETA_ListAppend  	=	    3001,	//(0x00000bb9)
    eSERVERWIRINGMETA_PropertyOverride	=	    3002,	//(0x00000bba)
    eSERVERWIRINGMETA_ListMerge   	=	    3003	//(0x00000bbb)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_DETAILEDERRORS                          L"DETAILEDERRORS"
#define TABLEID_DETAILEDERRORS                           (0xb17dca00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_DETAILEDERRORS                       (0L)
#define ExtendedVersion_DETAILEDERRORS                   (0L)

//-----------------Column Index Enums--------------   
enum eDETAILEDERRORS {
    iDETAILEDERRORS_ErrorID,  
    iDETAILEDERRORS_Description,  
    iDETAILEDERRORS_Date,  
    iDETAILEDERRORS_Time,  
    iDETAILEDERRORS_SourceModuleName,  
    iDETAILEDERRORS_MessageString,  
    iDETAILEDERRORS_CategoryString,  
    iDETAILEDERRORS_Source,  
    iDETAILEDERRORS_Type,  
    iDETAILEDERRORS_Category,  
    iDETAILEDERRORS_User,  
    iDETAILEDERRORS_Computer,  
    iDETAILEDERRORS_Data,  
    iDETAILEDERRORS_Event,  
    iDETAILEDERRORS_String1,  
    iDETAILEDERRORS_String2,  
    iDETAILEDERRORS_String3,  
    iDETAILEDERRORS_String4,  
    iDETAILEDERRORS_String5,  
    iDETAILEDERRORS_ErrorCode,  
    iDETAILEDERRORS_Interceptor,  
    iDETAILEDERRORS_InterceptorSource,  
    iDETAILEDERRORS_OperationType,  
    iDETAILEDERRORS_Table,  
    iDETAILEDERRORS_ConfigurationSource,  
    iDETAILEDERRORS_Row,  
    iDETAILEDERRORS_Column,  
    iDETAILEDERRORS_MajorVersion,  
    iDETAILEDERRORS_MinorVersion,  
    cDETAILEDERRORS_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;
         WCHAR *     pDescription;
         WCHAR *     pDate;
         WCHAR *     pTime;
         WCHAR *     pSourceModuleName;
         WCHAR *     pMessageString;
         WCHAR *     pCategoryString;
         WCHAR *     pSource;
         ULONG *     pType;
         ULONG *     pCategory;
         WCHAR *     pUser;
         WCHAR *     pComputer;
 unsigned char *     pData;
         ULONG *     pEvent;
         WCHAR *     pString1;
         WCHAR *     pString2;
         WCHAR *     pString3;
         WCHAR *     pString4;
         WCHAR *     pString5;
         ULONG *     pErrorCode;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorSource;
         ULONG *     pOperationType;
         WCHAR *     pTable;
         WCHAR *     pConfigurationSource;
         ULONG *     pRow;
         ULONG *     pColumn;
         ULONG *     pMajorVersion;
         ULONG *     pMinorVersion;
};

enum eDETAILEDERRORS_Type {
    eDETAILEDERRORS_SUCCESS       	=	       0,	//(0x00000000)
    eDETAILEDERRORS_ERROR         	=	       1,	//(0x00000001)
    eDETAILEDERRORS_WARNING       	=	       2,	//(0x00000002)
    eDETAILEDERRORS_INFORMATION   	=	       4,	//(0x00000004)
    eDETAILEDERRORS_AUDIT_SUCCESS 	=	       8,	//(0x00000008)
    eDETAILEDERRORS_AUDIT_FAILURE 	=	      16	//(0x00000010)
};

enum eDETAILEDERRORS_OperationType {
    eDETAILEDERRORS_Unspecified   	=	       0,	//(0x00000000)
    eDETAILEDERRORS_Populate      	=	       1,	//(0x00000001)
    eDETAILEDERRORS_UpdateStore   	=	       2	//(0x00000002)
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_COLLECTION_META                         L"COLLECTION_META"
#define TABLEID_COLLECTION_META                          (0xcb4ba600L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_COLLECTION_META                      (0L)
#define ExtendedVersion_COLLECTION_META                  (0L)

//-----------------Column Index Enums--------------   
enum eCOLLECTION_META {
    iCOLLECTION_META_Database,  
    iCOLLECTION_META_InternalName,  
    iCOLLECTION_META_PublicName,  
    iCOLLECTION_META_PublicRowName,  
    iCOLLECTION_META_BaseVersion,  
    iCOLLECTION_META_ExtendedVersion,  
    iCOLLECTION_META_NameColumn,  
    iCOLLECTION_META_NavColumn,  
    iCOLLECTION_META_CountOfColumns,  
    iCOLLECTION_META_MetaFlags,  
    iCOLLECTION_META_SchemaGeneratorFlags,  
    iCOLLECTION_META_ConfigItemName,  
    iCOLLECTION_META_ConfigCollectionName,  
    iCOLLECTION_META_PublicRowNameColumn,  
    iCOLLECTION_META_ContainerClassList,  
    iCOLLECTION_META_Description,  
    iCOLLECTION_META_ChildElementName,  
    cCOLLECTION_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tCOLLECTION_METARow {
         WCHAR *     pDatabase;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         WCHAR *     pPublicRowName;
         ULONG *     pBaseVersion;
         ULONG *     pExtendedVersion;
         ULONG *     pNameColumn;
         ULONG *     pNavColumn;
         ULONG *     pCountOfColumns;
         ULONG *     pMetaFlags;
         ULONG *     pSchemaGeneratorFlags;
         WCHAR *     pConfigItemName;
         WCHAR *     pConfigCollectionName;
         ULONG *     pPublicRowNameColumn;
         WCHAR *     pContainerClassList;
         WCHAR *     pDescription;
         WCHAR *     pChildElementName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_PROPERTY_META                           L"PROPERTY_META"
#define TABLEID_PROPERTY_META                            (0xfae7a100L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_PROPERTY_META                        (0L)
#define ExtendedVersion_PROPERTY_META                    (0L)

//-----------------Column Index Enums--------------   
enum ePROPERTY_META {
    iPROPERTY_META_Table,  
    iPROPERTY_META_Index,  
    iPROPERTY_META_InternalName,  
    iPROPERTY_META_PublicName,  
    iPROPERTY_META_Type,  
    iPROPERTY_META_Size,  
    iPROPERTY_META_MetaFlags,  
    iPROPERTY_META_DefaultValue,  
    iPROPERTY_META_FlagMask,  
    iPROPERTY_META_StartingNumber,  
    iPROPERTY_META_EndingNumber,  
    iPROPERTY_META_CharacterSet,  
    iPROPERTY_META_SchemaGeneratorFlags,  
    iPROPERTY_META_ID,  
    iPROPERTY_META_UserType,  
    iPROPERTY_META_Attributes,  
    iPROPERTY_META_Description,  
    iPROPERTY_META_PublicColumnName,  
    cPROPERTY_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tPROPERTY_METARow {
         WCHAR *     pTable;
         ULONG *     pIndex;
         WCHAR *     pInternalName;
         WCHAR *     pPublicName;
         ULONG *     pType;
         ULONG *     pSize;
         ULONG *     pMetaFlags;
 unsigned char *     pDefaultValue;
         ULONG *     pFlagMask;
         ULONG *     pStartingNumber;
         ULONG *     pEndingNumber;
         WCHAR *     pCharacterSet;
         ULONG *     pSchemaGeneratorFlags;
         ULONG *     pID;
         ULONG *     pUserType;
         ULONG *     pAttributes;
         WCHAR *     pDescription;
         WCHAR *     pPublicColumnName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_SERVERWIRING_META                       L"SERVERWIRING_META"
#define TABLEID_SERVERWIRING_META                        (0x58ffcd00L)





//-------------------------------Table Versions-------------------------
#define BaseVersion_SERVERWIRING_META                    (0L)
#define ExtendedVersion_SERVERWIRING_META                (0L)

//-----------------Column Index Enums--------------   
enum eSERVERWIRING_META {
    iSERVERWIRING_META_Table,  
    iSERVERWIRING_META_Order,  
    iSERVERWIRING_META_ReadPlugin,  
    iSERVERWIRING_META_ReadPluginDLLName,  
    iSERVERWIRING_META_WritePlugin,  
    iSERVERWIRING_META_WritePluginDLLName,  
    iSERVERWIRING_META_Interceptor,  
    iSERVERWIRING_META_InterceptorDLLName,  
    iSERVERWIRING_META_MetaFlags,  
    iSERVERWIRING_META_Locator,  
    iSERVERWIRING_META_Reserved,  
    iSERVERWIRING_META_Merger,  
    iSERVERWIRING_META_MergerDLLName,  
    cSERVERWIRING_META_NumberOfColumns
};

//-----------------Columns as Struct---------------   
struct tSERVERWIRING_METARow {
         WCHAR *     pTable;
         ULONG *     pOrder;
         ULONG *     pReadPlugin;
         WCHAR *     pReadPluginDLLName;
         ULONG *     pWritePlugin;
         WCHAR *     pWritePluginDLLName;
         ULONG *     pInterceptor;
         WCHAR *     pInterceptorDLLName;
         ULONG *     pMetaFlags;
         WCHAR *     pLocator;
         ULONG *     pReserved;
         ULONG *     pMerger;
         WCHAR *     pMergerDLLName;
};





//-------------------------------TableName-----------------------------   
#define wszTABLE_TAG_META                 