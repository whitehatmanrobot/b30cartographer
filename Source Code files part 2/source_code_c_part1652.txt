            //or release. For
                                                         //browsers, it has
                                                          //the net add appended
                                                         //to it
        LPBYTE               pName;
        DWORD                NameLen;
        PCOMM_ADD_T          pNodeAdd;      // Address of Node
        DWORD_PTR            TimeStamp;     // Time since Jan 1, 1970
        NMSDB_NODE_ADDS_T    NodeAdds;      // addresses (spec. group)
        VERS_NO_T            VersNo;        // Version No.
        DWORD                StatCode;      // Status
        NMSDB_ENTRY_STATE_E  EntryState_e;  // State of entry
        DWORD                OwnerId;       // Owner of the record
        BYTE                 NodeTyp;       // Type of Node (B, M  or P)
        BYTE                 EntTyp;        // Group or Unique flag
        BOOL                 fUpdVersNo;    // Update version number
        BOOL                 fUpdTimeStamp; // Update Time Stamp  ?
                                            // field has IP Address appended
        BOOL                 fStatic;       // indicates whether the record
                                            // is static (statically intialized)
        BOOL                 fAdmin;        //administrative action (used only)
                                            //for releases
        BOOL                 fLocal;        //Is it a local name
//        DWORD                CommitGrBit;    //kind of log flush
        } NMSDB_ROW_INFO_T, *PNMSDB_ROW_INFO_T;

/*
  NMSDB_STAT_INFO_T -- Contains the status of a NmsDb call.  If an error
      occurred, it also contains information pertaining to the error status.
      Currently, the  error status is NMDB_CONFLICI and information returned is
      unique/group status  and  IP address(es)  of the conflicting record in
      the  database.
*/
typedef NMSDB_ROW_INFO_T        NMSDB_STAT_INFO_T, *PNMSDB_STAT_INFO_T;

//////////////////////////////////////////////////////////////////////

#if DYNLOADJET

typedef JET_ERR (FAR JET_API *JETPROC)();
typedef struct _NMSDB_JETFTBL_T {
         BYTE   Index;  //index into array
         LPCSTR pFName; //function name for jet 500
         DWORD  FIndex; //function index for jet 200
         JETPROC pFAdd;
        } NMSDB_JETFTBL_T;

#define NMSDB_SIZEOFJETFTBL  sizeof(NmsDbJetFTbl)/sizeof(NMSDB_JETFTBL_T)
typedef enum {
Init,
Term,
Term2,
SetSystemParameter,
BeginSession,
EndSession,
CreateDatabase,
AttachDatabase,
DetachDatabase,
CreateTable,
DeleteTable,
GetTableColumnInfo,
GetColumnInfo,
AddColumn,
CreateIndex,
BeginTransaction,
CommitTransaction,
Rollback,
CloseDatabase,
CloseTable,
OpenDatabase,
OpenTable,
Delete,
Update,
RetrieveColumn,
SetColumn,
PrepareUpdate,
GetCurrentIndex,
SetCurrentIndex,
Move,
MakeKey,
Seek,
Backup,
Restore
} NMDB_JETFTBL_E;


#define JetInit (*(NmsDbJetFTbl[Init].pFAdd))
#define JetTerm (*(NmsDbJetFTbl[Term].pFAdd))
#define JetTerm2 (*(NmsDbJetFTbl[Term2].pFAdd))
#define JetSetSystemParameter (*(NmsDbJetFTbl[SetSystemParameter].pFAdd))
#define JetBeginSession (*(NmsDbJetFTbl[BeginSession].pFAdd))

#define JetEndSession  (*(NmsDbJetFTbl[EndSession].pFAdd))

#define JetCreateDatabase (*(NmsDbJetFTbl[CreateDatabase].pFAdd))

#define JetAttachDatabase (*(NmsDbJetFTbl[AttachDatabase].pFAdd))

#define JetDetachDatabase (*(NmsDbJetFTbl[DetachDatabase].pFAdd))

#define JetCreateTable (*(NmsDbJetFTbl[CreateTable].pFAdd))


#define JetDeleteTable (*(NmsDbJetFTbl[DeleteTable].pFAdd))

#define JetGetTableColumnInfo (*(NmsDbJetFTbl[GetTableColumnInfo].pFAdd))

#define JetGetColumnInfo (*(NmsDbJetFTbl[GetColumnInfo].pFAdd))

#define JetAddColumn (*(NmsDbJetFTbl[AddColumn].pFAdd))


#define JetCreateIndex (*(NmsDbJetFTbl[CreateIndex].pFAdd))

#define JetBeginTransaction (*(NmsDbJetFTbl[BeginTransaction].pFAdd))

#define JetCommitTransaction (*(NmsDbJetFTbl[CommitTransaction].pFAdd))

#define JetRollback (*(NmsDbJetFTbl[Rollback].pFAdd))

#define JetCloseDatabase (*(NmsDbJetFTbl[CloseDatabase].pFAdd))

#define JetCloseTable (*(NmsDbJetFTbl[CloseTable].pFAdd))

#define JetOpenDatabase (*(NmsDbJetFTbl[OpenDatabase].pFAdd))

#define JetOpenTable (*(NmsDbJetFTbl[OpenTable].pFAdd))

#define JetDelete (*(NmsDbJetFTbl[Delete].pFAdd))

#define JetUpdate (*(NmsDbJetFTbl[Update].pFAdd))

#define JetRetrieveColumn (*(NmsDbJetFTbl[RetrieveColumn].pFAdd))

#define JetSetColumn (*(NmsDbJetFTbl[SetColumn].pFAdd))

#define JetPrepareUpdate (*(NmsDbJetFTbl[PrepareUpdate].pFAdd))

#define JetGetCurrentIndex (*(NmsDbJetFTbl[GetCurrentIndex].pFAdd))

#define JetSetCurrentIndex (*(NmsDbJetFTbl[SetCurrentIndex].pFAdd))

#define JetMove (*(NmsDbJetFTbl[Move].pFAdd))

#define JetMakeKey (*(NmsDbJetFTbl[MakeKey].pFAdd))

#define JetSeek (*(NmsDbJetFTbl[Seek].pFAdd))

#define JetRestore (*(NmsDbJetFTbl[Restore].pFAdd))

#define JetBackup (*(NmsDbJetFTbl[Backup].pFAdd))
#endif

//////////////////////////////////////////////////////////////////////
/*
 function definitions
*/
extern
STATUS
NmsDbInit(
        VOID
        );

extern
STATUS
NmsDbInsertRowInd(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbInsertRowGrp(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbRelRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);

extern
STATUS
NmsDbQueryRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
STATUS
NmsDbUpdateRow(
        IN  PNMSDB_ROW_INFO_T        pNmsDbRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


STATUS
NmsDbSeekNUpdateRow(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
);


extern
VOID
NmsDbThdInit(
         IN         WINS_CLIENT_E        Client_e
        );


STATUS
NmsDbEndSession (
        VOID
        );

extern
VOID
NmsDbRelRes(
        VOID
        );



extern
STATUS
NmsDbGetDataRecs(
        IN  WINS_CLIENT_E   Client_e,
        IN  OPTIONAL INT    ThdPrLvl,
        IN  VERS_NO_T            MinVersNo,
        IN  VERS_NO_T            MaxVersNo,
        IN  DWORD            MaxNoOfRecsReqd,
        IN  BOOL            fUpToLimit,
        IN  BOOL            fOnlyReplicaTomb,
        IN  PNMSSCV_CLUT_T  pClutter,
        IN  PCOMM_ADD_T            pWinsAdd,
        IN  BOOL            fOnlyDynRecs,
    IN  DWORD           RplType,
        OUT LPVOID                *ppRspBuf,
        OUT LPDWORD            pRspBufLen,
        OUT LPDWORD            pNoOfRecs
);


extern
STATUS
NmsDbWriteOwnAddTbl (
        IN  NMSDB_TBL_ACTION_E   TblAct_e,
        IN  DWORD                OwnerId,
        IN  PCOMM_ADD_T          pWinsAdd,
        IN  NMSDB_WINS_STATE_E   WinsState_e,
        IN  PVERS_NO_T           pStartVersNo,
        IN  PWINS_UID_T          pUid
        );


extern
STATUS
NmsDbUpdateVersNo (
        IN  BOOL                fAfterClash,
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        IN  PNMSDB_STAT_INFO_T  pStatusInfo
       );

extern
STATUS
NmsDbSetCurrentIndex(
        IN  NMSDB_TBL_NAM_E        TblNm_e,
        IN  LPBYTE                pIndexNam
        );

extern
STATUS
NmsDbQueryNUpdIfMatch(
        IN  LPVOID        pRecord,
        IN  int                ThdPrLvl,
        IN  BOOL        fChgPrLvl,
        IN  WINS_CLIENT_E Client_e
        );
extern
STATUS
NmsDbUpdHighestVersNoRec(
        IN PWINSTHD_TLS_T        pTls,
        IN VERS_NO_T                MyMaxVersNo,
        IN BOOL                        fEnterCrtSec
        );


extern
STATUS
NmsDbDelDataRecs(
#if 0
        PCOMM_ADD_T        pWinsAdd,
#endif
        DWORD                dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo,
        BOOL                fEnterCrtSec,
    BOOL        fFragmentedDel
        );

extern
STATUS
NmsDbTombstoneDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo
        );


extern
STATUS
NmsDbSetFlushTime(
        DWORD WaitTime
        );

extern
STATUS
NmsDbOpenTables(
        WINS_CLIENT_E        Client_e
        );

extern
STATUS
NmsDbCloseTables(
        VOID
        );


extern
STATUS
NmsDbGetNamesWPrefixChar(
        BYTE                         PrefixChar,
        PWINSINTF_BROWSER_INFO_T *ppInfo,
        LPDWORD                         pEntriesRead
        );


extern
STATUS
NmsDbCleanupOwnAddTbl(
        LPDWORD pNoOfOwners
        );


extern
STATUS
NmsDbBackup(
    LPBYTE  pBackupPath,
    DWORD   TypeOfBackup
    );

extern
STATUS
NmsDbGetDataRecsByName(
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           Location,
  DWORD           NoOfRecsDesired,
  PCOMM_ADD_T     pWinsAdd,
  DWORD           TypeOfRecs,
  LPVOID          *ppBuff,
  LPDWORD         pBuffLen,
  LPDWORD         pNoOfRecsRet
 );

extern
STATUS
NmsDbEndTransaction(
  VOID
 );

#ifdef __cplusplus
}
#endif
#endif //_NMSDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\nmsscv.h ===
#ifndef _NMSSCV_
#define _NMSSCV_

#ifdef __cplusplus
extern "C" {
#endif

/*++
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	nmsscv.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include <time.h>
#include "wins.h"
//#include "winscnf.h"
/*
  defines
*/


/*
  macros
*/

/*
 externs
*/

//
// The min. version number to start scavenging from (for local records)
//
extern VERS_NO_T  	NmsScvMinScvVersNo;

extern HANDLE	NmsScvDoScvEvtHdl;//event signaled to initiate scavenging
volatile extern BOOL	    fNmsScvThdOutOfReck;//To indicate that the scav. thd has
                                   //db session but is not in the count
                                   //of thds to wait for.

/* 
 typedef  definitions
*/
typedef struct _NMSSCV_CC_T {
               DWORD TimeInt;
               BOOL  fSpTime;
               DWORD SpTimeInt;
               DWORD MaxRecsAAT;
               BOOL  fUseRplPnrs;
} NMSSCV_CC_T, *PNMSSCV_CC_T;

typedef struct _NMSSCV_PARAM_T {
	DWORD  RefreshInterval;
	DWORD  TombstoneInterval;
	DWORD  TombstoneTimeout;
	DWORD  VerifyInterval;
    NMSSCV_CC_T  CC;
	LONG   PrLvl;
	DWORD  ScvChunk;
        CHAR   BackupDirPath[WINS_MAX_FILENAME_SZ];
	} NMSSCV_PARAM_T, *PNMSSCV_PARAM_T;

//
// Used to pass information to NmsDbGetDataRecs
//
typedef struct _NMSSCV_CLUT_T {
	DWORD	Interval;
	time_t  CurrentTime;
	DWORD   OwnerId;
    DWORD   Age;
    BOOL    fAll;
	} NMSSCV_CLUT_T, *PNMSSCV_CLUT_T;	

//
// Used by ChkConfNUpd() to determine whether a record pulled during 
// verification/consistency check should be inserted into the db
//
typedef enum _NMSSCV_REC_ACTION_E {
          NMSSCV_E_INSERT,
          NMSSCV_E_DONT_INSERT
       } NMSSCV_REC_ACTION_E, *PNMSSCV_REC_ACTION_E;
/* 
 function declarations
*/
extern 
VOID
NmsScvInit(
	VOID
	);
#ifdef __cplusplus
}
#endif
#endif //_NMSSCV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\rpl.h ===
#ifndef _RPL_
#define _RPL_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:



Abstract:





Functions:



Portability:


        This header is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "comm.h"
#include "nmsdb.h"
#include "winsque.h"

/*
  defines
*/
/*
  RPL_OPCODE_SIZE -- size of opcode in message sent between two replicators.
        This define is used by rplmsgf
*/
#define RPL_OPCODE_SIZE                4        //sizeof the Opcode in an RPL message


/*
 The maximum numbers of RQ WINS on a network.
*/
#define RPL_MAX_OWNERS_INITIALLY                NMSDB_MAX_OWNERS_INITIALLY


/*
  RPL_MAX_GRP_MEMBERS --
  Maximum members allowed in a group
*/
#define RPL_MAX_GRP_MEMBERS                 25


//
// We don't send more than 5000 records at a time.  Note: This value is
// used to define MAX_BYTES_IN_MSG in comm.c
//
// By not having a very bug number we have a better chance for being serviced
// within our timeout period for a request.  This is because of queuing that
// results when there are a lot of replication requests
//
//
#define RPL_MAX_LIMIT_FOR_RPL           5000

/*
 This define is used by ReadPartnerInfo and by RplPull functions.  The size
 is made a multiple of  8.  I could have used sizeof(LARGE_INTEGER) instead of
 8 but I am not sure whether that will remain a multiple of 8 in the future.

 The size is made a multiple of 8 to avoid alignment exceptions on MIPS (
 check out ReadPartnerInfo in winscnf.c or GetReplicas in rplpull.c for
 more details)
*/

#define  RPL_CONFIG_REC_SIZE        (sizeof(RPL_CONFIG_REC_T) + \
                                   (8 - sizeof(RPL_CONFIG_REC_T)%8))
//
// check out GetDataRecs in nmsdb.c
//
#define  RPL_REC_ENTRY_SIZE        (sizeof(RPL_REC_ENTRY_T) + \
                                   (8 - sizeof(RPL_REC_ENTRY_T)%8))

//
// check out GetDataRecs in nmsdb.c
//
#define  RPL_REC_ENTRY2_SIZE        (sizeof(RPL_REC_ENTRY2_T) + \
                                   (8 - sizeof(RPL_REC_ENTRY2_T)%8))

//
// The following define is used to initialize the TimeInterval/UpdateCount
// field of a RPL_REC_ENTRY_T structure to indicate that it is invalid
//
#define RPL_INVALID_METRIC        -1


//
// defines to indicate whether the trigger needs to be propagated to all WINS
// in the PUSH chain
//
#define RPL_PUSH_PROP                TRUE        //must remain TRUE since in
                                        //NmsNmhNamRegInd, at one place
                                        //we use fAddDiff value in place of
                                        //this symbol. fAddDiff when TRUE
                                        //indicates that the address has
                                        //changed, thus initiating propagation
#define RPL_PUSH_NO_PROP        FALSE



/*
  macros
*/

//
// Macro called in an NBT thread after it increments the version number
// counter.  This macro is supposed to be called from within the
// NmsNmhNamRegCrtSec.
//
#define RPL_PUSH_NTF_M(fAddDiff, pCtx, pNoPushWins1, pNoPushWins2) {                \
                             if ((WinsCnf.PushInfo.NoPushRecsWValUpdCnt \
                                                              != 0) ||  \
                                        fAddDiff)                        \
                             {                                                \
                                ERplPushProc(fAddDiff, pCtx, pNoPushWins1,    \
                                                pNoPushWins2);          \
                             }                                                \
               }

/*
        FIND_ADD_BY_OWNER_ID_M - This macro is called by the PUSH thread
        when sending data records to its Pull Partner.  It calls this function
        to determine the Address of the WINS owning the database record

        The caller of this macro, if not executing in the PULL thread, must
        synchronize using NmsDbOwnAddTblCrtSec (Only PULL thread updates
        the NmsDbOwnAddTbl array during steady state).

        I am not putting the critical section entry and exit inside this
        macro for performance reasons (refer StoreGrpMems in nmsdb.c where
        this macro may be called many times -once for each member of a
        special group).  Also refer RplMsgfFrmAddVersMapRsp()  and
        WinsRecordAction (in winsintf.c)
*/

#define   RPL_FIND_ADD_BY_OWNER_ID_M(OwnerId, pWinsAdd, pWinsState_e, pStartVersNo)                                                                          \
                {                                                        \
                        PNMSDB_ADD_STATE_T pWinsRec;                     \
                        if (OwnerId < NmsDbTotNoOfSlots)                 \
                        {                                                \
                            pWinsRec       = pNmsDbOwnAddTbl+OwnerId;    \
                            (pWinsAdd)     = &(pWinsRec->WinsAdd);       \
                            (pWinsState_e) = &pWinsRec->WinsState_e;     \
                            (pStartVersNo) = &pWinsRec->StartVersNo;     \
                        }                                                \
                        else                                             \
                        {                                                \
                            (pWinsAdd)     = NULL;                       \
                            (pWinsState_e) = NULL;                       \
                            (pStartVersNo) = NULL;                       \
                        }                                                \
                }


//
//  Names of event variables signaled when Pull and/or Push configuration
//  changes
//
#define  RPL_PULL_CNF_EVT_NM                TEXT("RplPullCnfEvt")
#define  RPL_PUSH_CNF_EVT_NM                TEXT("RplPushCnfEvt")
/*
 externs
*/


/*
  Handle of heap used for allocating/deallocating work items for the RPL
  queues
*/

extern  HANDLE                RplWrkItmHeapHdl;
#if 0
extern  HANDLE                RplRecHeapHdl;
#endif

/*
  OwnerIdAddressTbl

  This table stores the Addresses corresponding to different WINS servers.

  In the local database, the local WINS's owner id is always 0.  The owner ids
  of other WINS servers are 1, 2, 3 ....  The owner ids form a sequential list,
  without any gap.  This is because, the first time the database is created
  at a WINS, it assigns sequential numbers to the other WINS.


  Note: The table is static for now.  We might change it to be a dynamic one
        later.

*/



/*
 PushPnrVersNoTbl

  This table stores the Max. version number pertaining to each WINS server
  owning entries in the database of Push Partners

  Note: The table is static for now.  We might change it to be a dynamic one
        later.
*/

#if 0
extern VERS_NO_T   pPushPnrVersNoTbl;
#endif

/*
 OwnerVersNo -- this array stores the maximum version number for each
         owner in the local database

        This is used by HandleAddVersMapReq() in RplPush.c

*/
extern VERS_NO_T   pRplOwnerVersNo;


extern HANDLE                RplSyncWTcpThdEvtHdl; //Sync up with the TCP thread

//
// critical section to guard the RplPullOwnerVersNo array
//
extern CRITICAL_SECTION  RplVersNoStoreCrtSec;

/*
 typedef  definitions
*/

/*
        The different types of records that can be read from the registry
*/
typedef enum _RPL_RR_TYPE_E {
        RPL_E_PULL = 0,   // pull record
        RPL_E_PUSH,          //push record
        RPL_E_QUERY          //query record
        } RPL_RR_TYPE_E, *PRPL_RR_TYPE_E;

typedef struct _RPL_VERS_NOS_T {
        VERS_NO_T                VersNo;
        VERS_NO_T                StartVersNo;
        } RPL_VERS_NOS_T, *PRPL_VERS_NOS_T;

/*
  RPL_CONFIG_REC_T -- Configuration record for the WINS replicator.  It
                specifies the Pull/Push/Query partner and associated
                parameters


  NOTE NOTE NOTE:  Keep the datatype of UpdateCount and TimeInterval the same
  (see LnkWSameMetricRecs)
*/
typedef  struct _RPL_CONFIG_REC_T {
    DWORD       MagicNo;    //Same as that in WinsCnf
        COMM_ADD_T        WinsAdd;        /*address of partner        */
        LPVOID                pWinsCnf;        //back pointer to the old WINS struct
        LONG                TimeInterval;   /*time interval in secs for pulling or
                                         * pushing        */
        BOOL                fSpTime;        //indicates whether pull/push
                                        //replication should be done at
                                        // a specific time
        LONG                SpTimeIntvl;        //Number of secs to specific time
        LONG                UpdateCount;        /*Count of updates after which
                                         *notification will be sent (applies
                                         *only to Push RR types*/
        DWORD                RetryCount;        //No of retries done
        DWORD                RetryAfterThisManyRpl; //Retry after this many rpl
                                               //time intervals have elapsed
                                               //from the time we stopped
                                               //replicating due to RetryCount
                                               //hitting the limit
        time_t                LastCommFailTime;   //time of last comm. failure
        time_t                LastRplTime;        //time of last replication
#if PRSCONN
        time_t                LastCommTime;   //time of last comm. 
#endif
        DWORD                PushNtfTries;       //No of tries for establishing
                                            //comm. in the past few minutes
        //
        // The two counters below have to 32 bit aligned otherwise
        // the Interlock instructions will fail on x86 MP machines
        //
        DWORD                NoOfRpls;           //no of times replication
                                           //happened with this partner
        DWORD                NoOfCommFails;           //no of times replication
                                           //failed due to comm failure
        DWORD                MemberPrec;        //precedence of members of special grp
                                        //relative to other WINS servers

        struct _RPL_CONFIG_REC_T        *pNext; //ptr to next rec. with same
                                                //time interval (in case of
                                                //of PULL record) or update
                                                //count (in case of PUSH record)
        VERS_NO_T        LastVersNo;     //Only valid for Push records.
                                        //Indicates what the value of the
                                        //local version number counter at the
                                        //time a push notification is sent
        DWORD           RplType;       //type of replication with this guy
        BOOL                fTemp;                //Indicates whether it is a temp
                                        //record that should be deallocated
                                        //after use.
        BOOL                fLinked;        //indicates whether the record is
                                        //is linked to a record before it in
                                        //the buffer of records of the same type                                        //as this record
        BOOL            fOnlyDynRecs; //indicates whether only dynamic
                                          //records should be pulled/pushed
        RPL_RR_TYPE_E    RRTyp_e;        /*Type of record PULL/PUSH/QUERY*/
#if MCAST > 0
    BOOL         fSelfFnd;    //indicates whether this record was self found
#endif
#if PRSCONN
        BOOL           fPrsConn;
        COMM_HDL_T     PrsDlgHdl;
#endif

        
        } RPL_CONFIG_REC_T, *PRPL_CONFIG_REC_T;




/*
 RPL_ADD_VERS_NO_T - stores the highest version No. pertaining to an owner
                 in the directory.

                 Used by GetVersNo and RplMsgUfrmAddVersMapRsp
*/
typedef struct _RPL_ADD_VERS_NO_T {
        COMM_ADD_T                OwnerWinsAdd;
        VERS_NO_T                 VersNo;
        VERS_NO_T                 StartVersNo;
        } RPL_ADD_VERS_NO_T, *PRPL_ADD_VERS_NO_T;

/*

 RPL_PUSHPNR_VERS_NO_T -- stores the Push Pnr Id, the id. of the owner whose
                         records  should be pulled, and the max version
                         number  of these records


        This structure is initializes at replication time.  The PULL thread
        looks at this structure and sends requests to its Push partners to
        pull records.

        This structure is used by functions in the rplpull.c and rplmsgf.c
        modules.

*/
typedef struct _RPL_PUSHPNR_VERS_NO_T {
        DWORD                PushPnrId;
        DWORD           OwnerId;
        VERS_NO_T        MaxVersNo;
        } RPL_PUSHPNR_VERS_NO_T, *PRPL_PUSHPNR_VERS_NO_T;


FUTURES("Use NmsDbRowInfo struture")
/*
  RPL_REC_ENTRY_T -- structure that holds a record in the range
                Min version no - Max version no for an owner WINS

                Used by RplPushHandleSndEntriesReq
  Size of this structure is 68 bytes
*/
typedef struct _RPL_REC_ENTRY_T {
        DWORD           NameLen;
        DWORD           NoOfAdds;
        union {
          PCOMM_ADD_T pNodeAdd;
          COMM_ADD_T  NodeAdd[2];
        };
        VERS_NO_T  VersNo;
        DWORD           TimeStamp;          //used only when doing scavenging
        DWORD           NewTimeStamp;          //used only when doing scavenging
        BOOL           fScv;        //used only when doing scavenging
        BOOL           fGrp;
        LPBYTE     pName;
        DWORD           Flag;
        } RPL_REC_ENTRY_T, *PRPL_REC_ENTRY_T;

// this struct is same as above plus has the ownerid.
// winsgetdatarecsbyname routine needs to know the ownerid of each
// record and so this new structure is created.
typedef struct _RPL_REC_ENTRY2_T {
        DWORD           NameLen;
        DWORD           NoOfAdds;
        union {
          PCOMM_ADD_T pNodeAdd;
          COMM_ADD_T  NodeAdd[2];
        };
        VERS_NO_T  VersNo;
        DWORD           TimeStamp;          //used only when doing scavenging
        DWORD           NewTimeStamp;          //used only when doing scavenging
        BOOL           fScv;        //used only when doing scavenging
        BOOL           fGrp;
        LPBYTE     pName;
        DWORD           Flag;
        DWORD       OwnerId;
        } RPL_REC_ENTRY2_T, *PRPL_REC_ENTRY2_T;

//
// Argument to GetReplicas, EstablishComm (both in rplpull.c), and
// WinsCnfGetNextCnfRec to  indicate to it how it should traverse
// the buffer of Configuration records
//
typedef enum _RPL_REC_TRAVERSAL_E {
                RPL_E_VIA_LINK = 0,
                RPL_E_IN_SEQ,
                RPL_E_NO_TRAVERSAL
                } RPL_REC_TRAVERSAL_E, *PRPL_REC_TRAVERSAL_E;



/*
 function declarations
*/

extern
STATUS
ERplInit(
        VOID
);

extern
STATUS
ERplInsertQue(
        WINS_CLIENT_E        Client_e,
        QUE_CMD_TYP_E   CmdTyp_e,
        PCOMM_HDL_T        pDlgHdl,
        MSG_T                pMsg,
        MSG_LEN_T        MsgLen,
        LPVOID                pClientCtx,
    DWORD       MagicNo
        );

extern
STATUS
RplFindOwnerId (
        IN  PCOMM_ADD_T                        pWinsAdd,
        IN  OUT LPBOOL                        pfAllocNew,
        OUT DWORD UNALIGNED         *pOwnerId,
        IN  DWORD                            InitpAction_e,
        IN  DWORD                            MemberPrec
        );

extern
VOID
ERplPushProc(
        BOOL                fAddDiff,
    LPVOID      pCtx,
        PCOMM_ADD_T     pNoPushWins1,
        PCOMM_ADD_T     pNoPushWins2
        );


extern
PRPL_CONFIG_REC_T
RplGetConfigRec(
    RPL_RR_TYPE_E   TypeOfRec_e,
    PCOMM_HDL_T     pDlgHdl,
    PCOMM_ADD_T     pAdd
    );

#if 0
extern
VOID
ERplPushCompl(
        PCOMM_ADD_T     pNoPushWins
        );
#endif

#endif //_RPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\rplmsgf.h ===
#ifndef _RPLMSGF_
#define _RPLMSGF_ 
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplmsgf.h

	

Abstract:

 
	header file for interfacing with the rplmsgf.c module


Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

#include "wins.h"
#include "comm.h"
#include "rpl.h"

/*
  defines
*/
/*
  Sizes for the different messages to be sent between replicators

*/

#define RPLMSGF_ADDVERSMAP_REQ_SIZE	 (sizeof(LONG) +  COMM_N_TCP_HDR_SZ)	
#define RPLMSGF_SNDENTRIES_REQ_SIZE  (COMM_N_TCP_HDR_SZ + sizeof(RPLMSGF_SENDENTRIES_REQ_T))


#define RPLMSGF_ADDVERSMAP_RSP_SIZE_M(_NoOfOwners) \
                       (COMM_N_TCP_HDR_SZ +  \
                       sizeof(RPLMSGF_ADDVERSMAP_RSP_T) + \
                       (sizeof(RPLMSGF_OWNER_MAP_INFO_T) * (_NoOfOwners)));
		

//
// RPLMSGF_UPD_VERS_NO_REQ_T includes COMM_N_TCP_HDR 
//
#define RPLMSGF_UPDVERSNO_REQ_SIZE	 sizeof(RPLMSGF_UPD_VERS_NO_REQ_T)

#define RPLMSGF_UPDVERSNO_RSP_SIZE	 (sizeof(RPLMSGF_UPD_VERS_NO_RSP_T) +  \
					  COMM_N_TCP_HDR_SZ)	

/*
  macros
*/

#define RPLMSGF_SET_OPC_M(pTmpB, Opc_e)			\
			{				\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = 0;		\
				*(pTmpB)++ = (BYTE)(Opc_e);	\
			}
				
//
// Opcode is stored in the 4th byte of the message (in keeping with the
// convention of passing the MSB first).
//
#define RPLMSGF_GET_OPC_FROM_MSG_M(pBuff, Opc_e)	\
		{					\
			Opc_e = *(pBuff + 3);		\
		} 

/*
* externs
*/

/* 
* typedef  definitions
*/

//
//  Message structures
//

// 
//  Some of these structures are used just for determining the sizes of the
//  buffers used for formatting the messages corresponding to them
//

typedef struct _RPLMSGF_ADD_VERS_MAP_REQ_T {
		DWORD	Opcode;
		} RPLMSGF_ADD_VERS_MAP_REQ_T, *PRPLMSGF_ADD_VERS_MAP_REQ_T;


typedef struct _RPLMSGF_OWNER_MAP_INFO_T {
           COMM_ADD_T    Add;
           VERS_NO_T     MaxVersNo;
           VERS_NO_T     StartVersNo;
           DWORD         Uid;
           } RPLMSGF_OWNER_MAP_INFO_T, *PRPLMSGF_OWNER_MAP_INFO_T;

        
typedef struct _RPLMSGF_ADDVERSMAP_RSP_T {
           DWORD  LengthOfMsg;
           DWORD Opcode;
           DWORD NoOfOwners;
           PRPLMSGF_OWNER_MAP_INFO_T pOwnerInfo;
           DWORD  RplTimeInterval;
        } RPLMSGF_ADDVERSMAP_RSP_T, *PRPLMSGF_ADDVERSMAP_RSP_T;

typedef struct _RPLMSGF_SENDENTRIES_REQ_T {
           DWORD          LengthOfMsg;
           DWORD          Opcode;
           COMM_ADD_T     Add;
           VERS_NO_T      MaxVersNo;
           VERS_NO_T      MinVersNo;
           DWORD          TypOfRec;
           } RPLMSGF_SENDENTRIES_REQ_T, PRPLMSGF_SENDENTRIES_REQ_T; 
            
    

typedef struct _RPLMSGF_UPD_VERS_NO_REQ_T {
        COMM_TCP_HDR_T  TcpHdr; 
		DWORD  		Opcode;
		BYTE  	    Name[NMSDB_MAX_NAM_LEN];
		DWORD   	NameLen;
		} RPLMSGF_UPD_VERS_NO_REQ_T,  *PRPLMSGF_UPD_VERS_NO_REQ_T; 

typedef struct _RPLMSGF_UPD_VERS_NO_RSP_T {
		DWORD	Opcode;
		BYTE	Rcode;
		} RPLMSGF_UPD_VERS_NO_RSP_T, *PRPLMSGF_UPD_VERS_NO_RSP_T;


/*
 RPLMSGF_MSG_OPCODE_E -- lists the various opcodes used in messages sent
		     between replicators of different WINS servers.

		  These opcodes are used by the formatting and unformatting
		  functions of module rplmsgf.c 
*/

typedef enum _RPLMSGF_MSG_OPCODE_E {
	RPLMSGF_E_ADDVERSNO_MAP_REQ = 0,
	RPLMSGF_E_ADDVERSNO_MAP_RSP, 
	RPLMSGF_E_SNDENTRIES_REQ,
	RPLMSGF_E_SNDENTRIES_RSP,
	RPLMSGF_E_UPDATE_NTF,			//update notification
	RPLMSGF_E_UPDATE_NTF_PROP,		//update notification (to be
						//propagated
	RPLMSGF_E_UPDVERSNO_REQ,		//update vers. no request 
	RPLMSGF_E_UPDVERSNO_RSP,			//update vers. no response 
                                //adding the following two at the end
                                //so as to not mess up the parser's notion
                                //of the above ones
	RPLMSGF_E_UPDATE_NTF_PRS,	//update notification on a pers. conn
	RPLMSGF_E_UPDATE_NTF_PROP_PRS	//update notification (to be propagated
	} RPLMSGF_MSG_OPCODE_E, *PRPLMSGF_MSG_OPCODE_E;

/* 
 function declarations
*/

extern
VOID
RplMsgfFrmAddVersMapReq(
	IN  LPBYTE	pBuff,
	OUT LPDWORD	pMsgLen
	);

extern
VOID
RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN  RPLMSGF_MSG_OPCODE_E   Opcode_e,
	IN  LPBYTE		  pBuff,
	IN  DWORD		  BuffLen,		  
	IN  PRPL_ADD_VERS_NO_T	  pOwnerAddVersNoMap, 
	IN  DWORD		  MaxNoOfOwners, 
    IN  DWORD         RplTimeInterval,
	OUT LPDWORD		  pMsgLen 
	);

extern
VOID
RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN  LPBYTE	pBuff,
	IN  PCOMM_ADD_T pWinsAdd,
	IN  VERS_NO_T	MaxversNo,
	IN  VERS_NO_T	MinVersNo,
    IN  DWORD       RplType,
	OUT LPDWORD	pMsgLen 
	);

extern
VOID
RplMsgfFrmSndEntriesRsp (
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN LPBYTE		pBuff,
	IN DWORD		NoOfRecs,
	IN LPBYTE		pName,
	IN DWORD		NameLen,
	IN BOOL			fGrp,
	IN DWORD		NoOfAdd,
	IN PCOMM_ADD_T		pNodeAdd,
	IN DWORD		Flag,
	IN VERS_NO_T		VersNo,
	IN BOOL			fFirstTime,
	OUT LPBYTE		*ppNewPos 
	);

extern
VOID
RplMsgfFrmUpdVersNoReq(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pName,
	IN  DWORD	NameLen,
#if 0
	IN  BOOL	fBrowserName,
	IN  BOOL	fStatic,
	IN  BYTE	NodeTyp,
	IN  PCOMM_ADD_T	pNodeAdd,
#endif
	OUT LPDWORD     pMsgLen
		);
extern
VOID
RplMsgfFrmUpdVersNoRsp(
	IN  LPBYTE	pBuff,
	IN  BYTE	Rcode,
	OUT LPDWORD     pMsgLen
		);
extern
VOID
RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN 	LPBYTE 		    pBuff,
	OUT	LPDWORD		    pNoOfMaps,
    OUT LPDWORD         pRplTimeInterval,
	IN OUT	PRPL_ADD_VERS_NO_T  *ppAddVers
	);

extern
VOID
RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN 	LPBYTE 		    pBuff,
	OUT	PCOMM_ADD_T	    pWinsAdd,
	OUT	PVERS_NO_T	    pMaxVersNo,
	OUT	PVERS_NO_T	    pMinVersNo,
        OUT     LPDWORD             pRplType
	);


extern
VOID
RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
    IN  BOOL       fPnrIsBeta1Wins,
#endif
	IN OUT	LPBYTE 		*ppBuff,
	OUT     LPDWORD		pNoOfRecs,
	OUT     IN LPBYTE	pName,
	OUT     LPDWORD		pNameLen,
	OUT     LPBOOL		pfGrp,
	OUT     LPDWORD		pNoOfAdd,
	OUT	PCOMM_ADD_T	pNodeAdd,
	OUT     LPDWORD		pFlag,
	OUT     PVERS_NO_T	pVersNo,
	IN      BOOL		fFirstTime 
	);

extern
VOID
RplMsgfUfmUpdVersNoReq(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pName,
	IN  LPDWORD	pNameLen
#if 0
	IN  LPBOOL	pfBrowserName,
	IN  LPBOOL	pfStatic,
	IN  LPBYTE	pNodeTyp,
	IN  PCOMM_ADD_T	pNodeAdd
#endif
		);

extern
VOID
RplMsgfUfmUpdVersNoRsp(
	IN  LPBYTE	pBuff,
	IN  LPBYTE	pRcode
		);

extern
VOID
RplMsgfUfmPullPnrReq(
	LPBYTE 			pMsg,
	DWORD  			MsgLen,
	PRPLMSGF_MSG_OPCODE_E   pPullReqType_e
	);

#endif //_RPLMSGF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\rplpull.h ===
#ifndef _RPLPULL_
#define _RPLPULL_


#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplpull.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "rpl.h"
/*
  defines
*/



/*
  macros
*/

/*
 externs
*/


extern HANDLE		RplPullCnfEvtHdl; //handle to event signaled by main
					  //thread when a configuration change
					  //has to be given to the Pull handler
					  //thread



#if 0
extern  BOOL		fRplPullAddDiffInCurrRplCycle;

extern  BOOL		fRplPullTriggeredWins; //indicates that during the current
					 //replication cycle, one or more 
					 //WINS's were triggered.  This
					 //when TRUE, then if the above
					 //"AddDiff.." flag is TRUE, it means
					 //that the PULL thread should trigger
					//all PULL Pnrs that have an INVALID
					//metric in their UpdateCount field
					//(of the RPL_CONFIG_T struct)

extern BOOL		fRplPullTrigger;//Indication to the PULL thread to
					//trigger Pull pnrs since one or more
					//address changed.  fRplPullTriggerWins
					//has got be FALSE when this is true
#endif

//
// indicates whether the pull thread sent a continue signal to the SC
//
extern   BOOL   fRplPullContinueSent;

//
//  This array is indexed by the id. of an RQ server that has entries in
//  our database.  Each owner's max. version number is stored in this array
//
extern  PRPL_VERS_NOS_T	pRplPullOwnerVersNo;

extern  DWORD  RplPullCnfMagicNo;

extern  DWORD RplPullMaxNoOfWins;   //slots in the RplPullOwnerVersNo

/* 
 typedef  definitions
*/

typedef struct _PUSHPNR_DATA_T {
        DWORD                  PushPnrId;    //id of the Push Pnr
        COMM_ADD_T             WinsAdd;      //address of the Push Pnr
        PRPL_CONFIG_REC_T      pPullCnfRec;  //configuration record.
        COMM_HDL_T             DlgHdl;       //Hdl of dlg with Push Pnr
        BOOL                   fPrsConn;     //indicates whether dlg is persistent
        DWORD                  NoOfMaps;     //no of IP address to Version No.
                                             //Maps sent by the Push Pnr
        PRPL_ADD_VERS_NO_T     pAddVers;     //maps

        DWORD                  RplType;      //type of replication
        BYTE                   fDlgStarted;  //indicates whether the dlg has
                                             //been started
        BOOL                   fToUse;
        VERS_NO_T              MaxVersNoToGet;
        } PUSHPNR_DATA_T, *PPUSHPNR_DATA_T;

typedef struct _PUSHPNR_TO_PULL_FROM_T {
        PPUSHPNR_DATA_T   pPushPnrData;
        VERS_NO_T         VersNo;          //max version number for an owner
        } PUSHPNR_TO_PULL_FROM_T, *PPUSHPNR_TO_PULL_FROM_T;

/* 
 function declarations
*/

extern DWORD	RplPullInit(LPVOID);

extern
VOID
RplPullPullEntries(
	PCOMM_HDL_T 		pDlgHdl,	
	DWORD			OwnerId,
	VERS_NO_T		MaxVersNo,	
	VERS_NO_T		MinVersNo,
	WINS_CLIENT_E		Client_e,
	LPBYTE			*ppRspBuff,
	BOOL			fUpdCntrs,
    DWORD            RplType
	);


extern
STATUS
RplPullRegRepl(
	LPBYTE		pName,
	DWORD		NameLen,
	DWORD		Flag,
	DWORD		OwnerId,
	VERS_NO_T	VersNo,
	DWORD		NoOfAdds,
	PCOMM_ADD_T	pNodeAdd,
	PCOMM_ADD_T	pOwnerWinsAdd,
    DWORD        RplType
	);

VOID
RplPullAllocVersNoArray(
      PRPL_VERS_NOS_T *ppRplOwnerVersNo,
      DWORD          CurrentNo
     );

#ifdef __cplusplus
}
#endif

#endif //_RPLPULL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\rplpush.h ===
#ifndef _RPLPUSH_
#define _RPLPUSH_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	rplpush.h
	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
/*
  defines
*/



/*
  macros
*/
	//
	// If NmsNmhMyMaxVersNo counter is > 0, check if we need to
	// send Push notifications at init time.  If no, initialize 
	// all push records such that their LastVersNo field (the version
	// number sent last to Pull Pnrs) is set to the counter value
	// Note: default value of WinsCnf.InitTimePush is 0.  It will 
	// therefore be set to 1 only if there are PUSH records in the
	// registry with valid UpdateCount field values.
    //
    //  
	//	
FUTURES("Init time push should also be to addresses with invalid or no upd cnt")
FUTURES("Modify ERplPushProc")
#define RPLPUSH_INIT_PUSH_RECS_M(pWinsCnf)				\
   {									\
	if (LiGtrZero(NmsNmhMyMaxVersNo))			        \
	{								\
		if (							\
			((pWinsCnf)->PushInfo.InitTimePush == 0) && 	\
			((pWinsCnf)->PushInfo.NoPushRecsWValUpdCnt != 0)\
		   )							\
		{							\
			WinsCnfSetLastUpdCnt((pWinsCnf));		\
		}							\
	}								\
  }
/*
 externs
*/

extern   HANDLE		RplPushCnfEvtHdl;
extern   BOOL           fRplPushThdExists;

/* 
 typedef  definitions
*/

/* 
 function declarations
*/




extern DWORD	RplPushInit(LPVOID);


#ifdef __cplusplus
}
#endif

#endif //_RPLPUSH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsevt.h ===
#ifndef _winsevT_
#define _WINSEVT_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	winsevt.h

Abstract:




Functions:



Portability:


	This module is portable.

Author:

	Pradeep Bahl	(PradeepB)	Dec-1992



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

#include "wins.h"

/*
  defines
*/



/*
  macros
*/

#define  WINSFILE	TEXT(__FILE__)
#define  WINSLINE	__LINE__

/*
  WINSEVT_LOG_N_RET_IF_ERR_M --  Logs and Returns with indicated status if
	the  return from the function is not as expected.
*/
#if 0
#define WINSEVT_LOG_N_RET_IF_ERR_M(Func_add, Success_Stat, Status_To_Ret, error_str_mo)  \
		{					  	  \
		    LONG	Status_m;			  \
		    if ((Status_m = (Func_add)) != (Success_Stat))\
		    {					  	  \
		       WinsEvtLogEvt(Status, EVENTLOG_ERROR_TYPE,  \
				error_str, WINSFILE, WINSLINE);   \
		       return((Status_To_Ret)); 		  \
		    }					  	  \
	        }
#endif


#define WINSEVT_LOG_PRINT_D_M(_pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_PRINT_M((_pStr));	\
		}						\
	}						
#define WINSEVT_LOG_PRINT_M(_pStr) 	{			\
				WINSEVT_STRS_T EvtStrs;		\
				EvtStrs.NoOfStrs = 1;		\
				EvtStrs.pStr[0]  = _pStr;		\
				WinsEvtLogEvt(WINS_SUCCESS,		\
				     EVENTLOG_INFORMATION_TYPE,		\
				     WINS_EVT_PRINT,			\
				     WINSFILE, WINSLINE, &EvtStrs);	\
					}
				
#define WINSEVT_LOG_INFO_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_INFO_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_INFO_M(Status, EvtId)  			\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    WinsEvtLogEvt(Status_m, EVENTLOG_INFORMATION_TYPE, \
				(EvtId), WINSFILE, WINSLINE, NULL);  \
	        }
/*
  WINSEVT_LOG_M --  Logs the indicated event
*/

#define WINSEVT_LOG_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_M(Status, EvtId)  				\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE, \
				(EvtId), WINSFILE, WINSLINE, NULL);  \
	        }

//
// log one or more strings specified by the EvtStr structure pointed
// to by pStr (Message is an error message)
//
#define WINSEVT_LOG_STR_D_M(EvtId, pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_STR_M((EvtId), (pStr));	\
		}						\
	}
#define  WINSEVT_LOG_STR_M(EvtId, pStr) 			\
			WinsEvtLogEvt(WINS_FAILURE, EVENTLOG_ERROR_TYPE, \
				(EvtId), WINSFILE, WINSLINE, (pStr));

//
// log one or more strings specified by the EvtStr structure pointed
// to by pStr (Message is an informational message)
//
#define WINSEVT_LOG_INFO_STR_D_M(EvtId, pStr)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_INFO_STR_M((EvtId), (pStr));	\
		}						\
	}						
#define  WINSEVT_LOG_INFO_STR_M(EvtId, pStr) 			\
			WinsEvtLogEvt(WINS_SUCCESS, EVENTLOG_INFORMATION_TYPE, \
				(EvtId), WINSFILE, WINSLINE, (pStr));
/*
  WINSEVT_LOG_IF_ERR_M --  Logs the indicated event
*/

#define WINSEVT_LOG_IF_ERR_D_M(Status, EvtId)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_IF_ERR_M((Status), (EvtId));	\
		}						\
	}						
#define WINSEVT_LOG_IF_ERR_M(Status, Event_id)  		\
		{					  	\
		    LONG Status_m;				\
		    Status_m = (Status);		  	\
		    if (Status_m != WINS_SUCCESS)		\
		    {					        \
		      WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE, \
				(Event_id), WINSFILE, WINSLINE, NULL);  \
		    }						\
	        }

/*
  WINSEVT_LOG_N_RET_M --  Logs and Returns with indicated status if
	the  return from the function is not as expected.
*/

#define WINSEVT_LOG_N_RET_D_M(Func, EvtId, RetStat)  			\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_N_RET_M((Func), (EvtId), (RetStat));\
		}						\
	}						
#define WINSEVT_LOG_N_RET_M(Func, Event_id, ret_stat)  		  \
		{					          \
		    LONG  Status_m;			          \
		    if (Status_m = (Func))     			  \
		    {					  	  \
		       WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE,  \
				(Event_id), WINSFILE, WINSLINE, NULL);    \
			return(ret_stat);			  \
		    }					          \
	        }

/*
  WINSEVT_LOG_N_EXIT_M --  Logs and exit
*/

#define WINSEVT_LOG_N_EXIT_D_M(Func, EvtId, RetStat)	\
	{							\
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
			WINSEVT_LOG_N_EXIT_M((Func), (EvtId), (RetStat));\
		}						\
	}						
#define WINSEVT_LOG_N_EXIT_M(Func, Event_id, ret_stat)  	\
		{					  	\
		    LONG	Status_m;			\
		    if ((Status_m = (Func)) != (WINS_SUCCESS))  \
		    {					  	\
		       WinsEvtLogEvt(Status_m, EVENTLOG_ERROR_TYPE,\
				(Event_id), WINSFILE, WINSLINE, NULL); 	\
		       Exitprocess(1);				\
		     }					  	\
	        }


#define WINSEVT_LOG_DET_EVT_M1(_Type, _EvtId, _Fmt, _D1)        \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1));                                                    \
		}

#define WINSEVT_LOG_DET_EVT_M2(_Type, _EvtId, _Fmt, _D1, _D2)   \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2));                                                 \
		}

#define WINSEVT_LOG_DET_EVT_M3(_Type, _EvtId, _Fmt, _D1, _D2, _D3)     \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2), (_D3));                                                 \
		}
#define WINSEVT_LOG_DET_EVT_M3(_Type, _EvtId, _Fmt, _D1, _D2, _D3)     \
		if (WinsCnf.LogDetailedEvts > 0) 		\
		{						\
                     WinsEvtLogDetEvt((_Type), (_EvtId), __FILE__, __LINE__, (_Fmt), (_D1), (_D2), (_D3));                                                 \
		}

//
// Max. number of strings that can be logged
//
#define MAX_NO_STRINGS	5

/*
 externs
*/

/*
 structure definitions
*/
typedef struct _WINSEVT_STRS_T	{
	DWORD	NoOfStrs;
	LPTSTR	pStr[MAX_NO_STRINGS];
	} WINSEVT_STRS_T, *PWINSEVT_STRS_T;

/*
 function definitions
*/


extern
VOID
WinsEvtLogEvt
	(
	LONG 		StatusCode,
	WORD		EvtTyp,
	DWORD		EvtId,
	LPTSTR		pFileStr,  //change to LPTSTR later
	DWORD 		LineNumber,
	PWINSEVT_STRS_T	pStr
	);


extern
VOID
WinsEvtLogDetEvt(
        BOOL            fInfo,
        DWORD           EvtId,
	LPTSTR		pFileStr,
	DWORD 		LineNumber,
        LPSTR           pFormat,
        ...
        );

VOID
WinsLogAdminEvent(
    IN      DWORD               EventId,
    IN      DWORD               StrArgs,
    IN      ...
    );

#endif //_WINSEVT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsque.h ===
#ifndef _WINSQUE_
#define _WINSQUE_

#ifdef __cplusplus
extern "C" {
#endif

/*
TODO --

  Maybe: Coalesce different queue structures into one.
*/
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        queue.c

Abstract:

        This is the header file to be included for calling queue.c functions



Functions:



Portability:


        This module is portable.

Author:

        Pradeep Bahl        (PradeepB)        Dec-1992



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/


/*
  defines
*/
#include <time.h>
#include "wins.h"
#include "comm.h"
#include "assoc.h"
#include "nmsdb.h"
#include "nmsmsgf.h"
#include "nmschl.h"

#define QUE_NBT_WRK_ITM_SZ        sizeof(NBT_REQ_WRK_ITM_T)

/*
  QUE_INIT_BUFF_HEAP_SIZE -- This is the initial size of the heap
                             for allocating queue items for the various
                             queues
*/
#define QUE_INIT_BUFF_HEAP_SIZE                10000


#define WINS_QUEUE_HWM        500
#define WINS_QUEUE_HWM_MAX      5000
#define WINS_QUEUE_HWM_MIN       50
/*
  macros
*/

/*
 externs
*/
//
// forward declarator
//
struct _QUE_HD_T;

extern struct _QUE_HD_T  *pWinsQueQueHd[];

/*
 forward declaration
*/
typedef struct _QUE_HD_T QUE_HD_T;

extern QUE_HD_T  QueNbtWrkQueHd;  //head for nbt req queue

#if REG_N_QUERY_SEP > 0
extern QUE_HD_T  QueOtherNbtWrkQueHd;  //head for nbt reg. req queue
extern DWORD     QueOtherNbtWrkQueMaxLen;
#endif
extern QUE_HD_T  QueRplPullQueHd; //head for rpl pull thread's queue
extern QUE_HD_T  QueRplPushQueHd; //head for rpl push thread's queue
extern QUE_HD_T  QueNmsNrcqQueHd; //head for challenge queue used by NBT thds
extern QUE_HD_T  QueNmsRrcqQueHd; //head for challenge queue used by Replicator
extern QUE_HD_T  QueNmsCrqQueHd;  //head for response queue for challenges sent
extern QUE_HD_T  QueWinsTmmQueHd; //head for timer manager queue
extern QUE_HD_T   QueWinsScvQueHd;  //head for scavenger queue
extern QUE_HD_T  QueInvalidQueHd; //head for an invalid queue. Never inited


extern HANDLE                  QueBuffHeapHdl;  //handle to heap for use for queue items

/*
 structure definitions
*/



/*
 QUE_TYP_E -- enumerator for the various queue types.

                Used by QueInsertWrkItm and its callers
                Used by QueRemoveWrkItm and its callers

This enumerator's value index the spQueHd (queue.c) array.  Do not change the
order of entries without changing QueHd's static initialization appropriately
*/
typedef enum  __QUE_TYP_E {
        QUE_E_NBT_REQ = 0,  //nbt req queue
#if REG_N_QUERY_SEP > 0
        QUE_E_OTHER_NBT_REQ,  //reg/rel nbt req queue
#endif
        QUE_E_RPLPULL,            //pull thread queue
        QUE_E_RPLPUSH,            //push thread queue
        QUE_E_NMSNRCQ,            //nbt request challenge queue
        QUE_E_NMSRRCQ,             //replicator request challenge queue
        QUE_E_NMSCRQ,            //challenge response queue
        QUE_E_WINSTMQ,            //timer queue
        QUE_E_WINSSCVQ,            //Scavenger queue
        QUE_E_UNKNOWN_TYPQ, //Unknown type of queue
        QUE_E_TOTAL_NO_QS   //Total no of queues
                } QUE_TYP_E, *PQUE_TYP_E;

//
// Work items for the different queues.
//
//  NOTE NOTE NOTE -- The work items must have LIST_ENTRY
//                 as the first field in them.
//
typedef struct _NBT_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        COMM_HDL_T                 DlgHdl;
        MSG_T                        pMsg;
        MSG_LEN_T                MsgLen;
        } NBT_REQ_WRK_ITM_T,         *PNBT_REQ_WRK_ITM_T;
//
//  CHL_REQ_WRK_ITM_T        -- Name challenge queue work item.  This is a work item
//                  that can be used for any of the four name challenge
//                   queues NRCQ, RRCQ, and CRQ
//
typedef struct _CHL_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        COMM_HDL_T                 DlgHdl;        //dlg handle
        MSG_T                        pMsg;          //NBT message recd
        MSG_LEN_T                MsgLen;        //msg len
        DWORD                        QuesNamSecLen; //Length of question name sec.
        NMSDB_ROW_INFO_T        NodeToReg;     //Info of node To Register
        NMSDB_NODE_ADDS_T        NodeAddsInCnf;
        BOOL                        fGroupInCnf; //whether the cnf record is group or unique
        DWORD                        OwnerIdInCnf;
//        BYTE                        NodeTypInCnf;
//        BYTE                        EntTypInCnf;

        COMM_ADD_T                AddToReg;

        //COMM_ADD_T                AddOfNodeInCnf;
        COMM_ADD_T                AddOfRemWins;        //address of remote WINS to
                                                //be sent the name reg request
                                                //so that the version number
                                                //of the record that caused
                                                //the conflict gets updated
        NMSCHL_CMD_TYP_E        CmdTyp_e;
        WINS_CLIENT_E                Client_e;
        NMSMSGF_NAM_REQ_TYP_E        ReqTyp_e;      //query or release
        DWORD                        NoOfAddsToUse;
        DWORD                        NoOfAddsToUseSv;
        } CHL_REQ_WRK_ITM_T, *PCHL_REQ_WRK_ITM_T;


//
// The response work item is the same as the challenge work item
//
typedef struct _CHL_REQ_WRK_ITM_T  CHL_RSP_WRK_ITM_T, *PCHL_RSP_WRK_ITM_T;


typedef struct _QUE_HD_T {
        LIST_ENTRY                        Head;
        CRITICAL_SECTION                 CrtSec;
        HANDLE                                EvtHdl;
        HANDLE                                HeapHdl;
        DWORD               NoOfEntries;
        } QUE_HD_T, *PQUE_HD_T;


/*
 QUE_CMD_TYP_E - Various Command Types that can be specified in the work item
        of one or more work queues
*/
typedef enum QUE_CMD_TYP_E {
        QUE_E_CMD_REPLICATE = 0,  //Replicate command directd to the Pull
                                  //thread as a result of administrative
                                  //action
        QUE_E_CMD_PULL_RANGE,     //Pull Range command directd to the Pull
                                  //thread as a result of administrative
                                  //action
        QUE_E_CMD_REPLICATE_MSG,  //Replicate message received by COMSYS TCP
                                  //thread
        QUE_E_CMD_SND_PUSH_NTF,   //push update count to remote WINS. This is
                                 //a cmd to the Pull thread at the local WINS
                                 //(by an NBT thread) and a request to the
                                 //Pull thread at the remote WINS.
        QUE_E_CMD_SND_PUSH_NTF_PROP,   //identical to the above except that
                                 //this one requests propagation along the
                                 //the chain of WINSs (Pull Partners)
        QUE_E_CMD_HDL_PUSH_NTF,  //handle Push notification from a remote WINS.
                                 //This is a command forwarded to the PULL
                                 //thread by the Push thread
        QUE_E_CMD_CONFIG,        //set configuration request
        QUE_E_CMD_DELETE_WINS,   //Delete WINS from add-vers map tables (records
                                 //are also deleted)
        QUE_E_CMD_SET_TIMER,     //set timer request to TMM
        QUE_E_CMD_CANCEL_TIMER,  //cancel timer request to TMM
        QUE_E_CMD_MODIFY_TIMER,  //modify timer reqyest to TMM
        QUE_E_CMD_TIMER_EXPIRED, //response to an earlier set timer request
        QUE_E_CMD_SCV_ADMIN,      // Admin initiated request
        QUE_E_CMD_ADDR_CHANGE     // Address of the local machine changed
        } QUE_CMD_TYP_E, *PQUE_CMD_TYP_E;

/*
 Work item for the Replicator's queue


        It is used in the work queue of both the PULL thread and the
        PUSH thread.

         CmdTyp_e                pClientCtx


        E_RPL                   NULL
        E_CONFIG                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL
        E_REPLICATE                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL
        E_TIMER_EXPIRE                address of list of RPL_CONFIG_REC_T records
                                terminated by NULL

*/

//
// The replicator, timer and Scavenger work items must have LIST_ENTRY,
// QUE_TYP_E, and QUE_CMD_TYP_E as the top 3 fields in this order.
//
// Refer RplPullInit and RplPushInit to discover why.
//
typedef struct _QUE_RPL_REQ_WRK_ITM_T {
        LIST_ENTRY               Head;
        QUE_TYP_E                QueTyp_e;
        QUE_CMD_TYP_E            CmdTyp_e;

        //
        // Don't change the order of the three fields above. Also,
        // they need to be at the top. See comment above
        //

        COMM_HDL_T               DlgHdl;
        MSG_T                    pMsg;
        MSG_LEN_T                MsgLen;
        LPVOID                   pClientCtx; /*client context.  For example,
                                             *it may point to config
                                             *records (RPL_CONFIG_REC_T
                                             *in case the cmd is E_CONFIG
                                             */
        DWORD                    MagicNo;   //used by IsTimeoutToBeIgnored()
                                           //in rplpull.c
        } QUE_RPL_REQ_WRK_ITM_T, *PQUE_RPL_REQ_WRK_ITM_T;

//
// SCV_REQ_WRK_ITM_E
//
typedef enum WINSINTF_SCV_OPC_E  QUE_SCV_OPC_E, *PQUE_SCV_OPC_E;


typedef struct _QUE_SCV_REQ_WRK_ITM_T {
        LIST_ENTRY         Head;
        QUE_TYP_E          QueTyp_e;
        QUE_CMD_TYP_E      CmdTyp_e;
        WINSINTF_SCV_OPC_E Opcode_e;
        DWORD              Age;
        BOOL               fForce;
        } QUE_SCV_REQ_WRK_ITM_T,         *PQUE_SCV_REQ_WRK_ITM_T;


/*
 Que of timer manager
*/
typedef struct _QUE_TMM_REQ_WRK_ITM_T {
        LIST_ENTRY                Head;
        QUE_TYP_E                QueTyp_e;
        QUE_CMD_TYP_E                CmdTyp_e;

        //
        // Don't change the order of the three fields above. Also,
        // they need to be at the top. They have to be in the same order
        // and position within this and the _QUE_RPL_REQ_WRK_ITM_T data
        // structure
        //

        DWORD                        ReqId;           //id of request
        WINS_CLIENT_E                Client_e;  //maybe not needed. Check ??
        time_t                        TimeInt;   //Time Interval
        time_t                        AbsTime;   //Absolute time
        DWORD                        DeltaTime; //Delta time
               HANDLE                        RspEvtHdl; //event to signal for response
        PQUE_HD_T                pRspQueHd;           //Que to put the response on
        LPVOID                        pClientCtx; /*client context.  For example,
                                             *it may point to config
                                             *records (RPL_CONFIG_REC_T
                                             *in case the cmd is E_CONFIG
                                             */
        DWORD                        MagicNo;   //used by IsTimeoutToBeIgnored()
                                           //in rplpull.c
        } QUE_TMM_REQ_WRK_ITM_T, *PQUE_TMM_REQ_WRK_ITM_T;


/*
 function prototypes
*/

extern
STATUS
QueInsertNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T        pMsg,
        IN MSG_LEN_T    MsgLen
        );

extern
STATUS
QueRemoveNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T                      ppMsg,
        OUT PMSG_LEN_T                  pMsgLen
        );
#if REG_N_QUERY_SEP > 0
extern
STATUS
QueInsertOtherNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T        pMsg,
        IN MSG_LEN_T    MsgLen
        );

extern
STATUS
QueRemoveOtherNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T                      ppMsg,
        OUT PMSG_LEN_T                  pMsgLen
        );
#endif



extern
STATUS
QueInsertChlReqWrkItm(
        IN NMSCHL_CMD_TYP_E        CmdTyp_e,
        IN WINS_CLIENT_E        Client_e,
        IN PCOMM_HDL_T           pDlgHdl,
        IN MSG_T                 pMsg,
        IN MSG_LEN_T             MsgLen,
        IN DWORD                 QuesNamSecLen,
        IN PNMSDB_ROW_INFO_T    pNodeToReg,
        IN PNMSDB_STAT_INFO_T   pNodeInCnf,
        //IN PCOMM_ADD_T           pAddOfNodeInCnf,
        IN PCOMM_ADD_T           pAddOfRemWins
        );

extern
STATUS
QueRemoveChlReqWrkItm(
        IN        HANDLE        EvtHdl,
        IN OUT  LPVOID        *ppaWrkItm,
        OUT        LPDWORD        pNoOfReqs
        );


extern
STATUS
QueInsertChlRspWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        );

extern
STATUS
QueRemoveChlRspWrkItm(
        OUT  LPVOID        *ppWrkItm
        );


extern
STATUS
QueInsertWrkItm (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        );

extern
STATUS
QueGetWrkItm (
        IN  QUE_TYP_E                QueTyp_e,
        OUT LPVOID                *ppWrkItm
        );



extern
VOID
QueAllocWrkItm(
        IN   HANDLE        HeapHdl,
        IN   DWORD        Size,
        OUT  LPVOID        *ppBuf
        );

extern
VOID
QueDeallocWrkItm(
   IN  HANDLE HeapHdl,
   IN  LPVOID  pBuff
        );



extern
STATUS
QueInsertWrkItmAtHdOfList (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        );


extern
STATUS
QueInsertRplPushWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN           BOOL                fAlreadyInCrtSec
        );

extern
STATUS
QueInsertNetNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        );

extern
STATUS
QueInsertSndNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        );



extern
VOID
QueChlWaitForRsp(
    VOID
    );
extern
VOID
QueChlNoWaitForRsp(
    VOID
    );

extern
__inline
STATUS
QueInsertScvWrkItm(
     PLIST_ENTRY  pWrkItm
        );

extern
__inline
STATUS
QueRemoveScvWrkItm(
     LPVOID  *ppWrkItm
        );


extern
VOID
WinsQueInit(
    LPTSTR     pName,
    PQUE_HD_T  pQueHd
    );

#ifdef __cplusplus
}
#endif

#endif //_WINSQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winscnf.h ===
#ifndef _WINSCNF_
#define _WINSCNF_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

        nmscnf.c

Abstract:

        This is the header file to be included for calling functions defined
        in nmscnf.c file.


Functions:



Portability:

        This header is portable.

Author:

        Pradeep Bahl        (PradeepB)        Jan-1993



Revision History:

        Modification Date        Person                Description of Modification
        ------------------        -------                ---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "rpl.h"
#include "winscnst.h"

#if MCAST > 0
#include "rnraddrs.h"
#endif

/*
  defines
*/

/*
  macros
*/

/*
* externs
*/
struct _WINSCNF_CNF_T;                  //forward declaration

extern  DWORD   WinsCnfCnfMagicNo;
extern  struct _WINSCNF_CNF_T        WinsCnf;
extern  BOOL    fWinsCnfRplEnabled;     //replication is enabled/disabled
extern  BOOL    fWinsCnfScvEnabled;     //scavenging is enabled/disabled
extern  BOOL    fWinsCnfReadNextTimeVersNo; //set if vers. no. to use next time
                                            //is read in

FUTURES("use #ifdef PERF around the following three perf. mon. vars")
extern        BOOL        fWinsCnfPerfMonEnabled; //Perf Mon is enabled/disabled


extern  BOOL        fWinsCnfHighResPerfCntr;     //indicates whether the hardware
                                             //supports a high resolution
                                             //perf. counter
extern  LARGE_INTEGER  LiWinsCnfPerfCntrFreq; //Performance Counter's Frequency

extern CRITICAL_SECTION WinsCnfCnfCrtSec;

extern TCHAR        WinsCnfDb[WINS_MAX_FILENAME_SZ];   //db file to hold tables
extern TCHAR    WinsCnfStaticDataFile[WINS_MAX_FILENAME_SZ]; //file containing
                                                         //static data used
                                                         //to initialize WINS

extern BOOL     WinsCnfRegUpdThdExists;
extern HANDLE        WinsCnfNbtHandle;
extern PTCHAR        pWinsCnfNbtPath;
extern BOOL     fWinsCnfInitStatePaused;
extern BOOL   sfNoLimitChk;   //to override the limit checks

//
// magic number of the Wins Cnf structure used at process invocation.  This
// WinsCnf structure is a global structure.  When there is a reconfiguration
// of WINS, we allocate a new WinsCnf structure and copy its contents to
// the global WinsCnf structure.  The magic number in the global WinsCnf is
// incremented.
//
#define  WINSCNF_INITIAL_CNF_MAGIC_NO        0

#define  WINSCNF_FILE_INFO_SZ         sizeof(WINSCNF_DATAFILE_INFO_T)

#define WINSCNF_SPEC_GRP_MASK_SZ  32
/*
 typedef  definitions
*/


//
// Action to take regarding whether the MemberPrec field of NMSDB_ADD_STATE_T
// table should be set. Used in RplFindOwnerId (called by Pull Thread).
//
typedef enum _WINSCNF_INITP_ACTION_E {
        WINSCNF_E_INITP = 0,
        WINSCNF_E_INITP_IF_NON_EXISTENT,
        WINSCNF_E_IGNORE_PREC
        } WINSCNF_INITP_ACTION_E, *PWINSCNF_INITP_ACTION_E;

//
// This structure holds information about the file (name and type as
// found in the registry (REG_SZ, REG_EXPAND_SZ) to be used for static
// initialization of WINS
//
typedef struct _WINSCNF_DATAFILE_INFO_T{
                TCHAR        FileNm[WINS_MAX_FILENAME_SZ];
                DWORD   StrType;
                } WINSCNF_DATAFILE_INFO_T, *PWINSCNF_DATAFILE_INFO_T;
//
// used to index the array of handles specified to WinsMscWaitUntilSignaled
// in nms.c
//
typedef enum _WINSCNF_HDL_SIGNALED_E {
                WINSCNF_E_TERM_HDL = 0,
                WINSCNF_E_WINS_HDL,
                WINSCNF_E_PARAMETERS_HDL,
                WINSCNF_E_PARTNERS_HDL,
                WINSCNF_E_NO_OF_HDLS_TO_MONITOR
        } WINSCNF_HDL_SIGNALED_E, *PWINSCNF_HDL_SIGNALED_E;
//
// The various keys in the WINS configuration (in registry)
//

//
// Don't modify the following enum without looking at TypOfMon[] in winscnf.c
// first
//
typedef enum _WINSCNF_KEY_E {
                WINSCNF_E_WINS_KEY = 0,
                WINSCNF_E_PARAMETERS_KEY,
                WINSCNF_E_SPEC_GRP_MASKS_KEY,
                WINSCNF_E_DATAFILES_KEY,
                WINSCNF_E_PARTNERS_KEY,
                WINSCNF_E_PULL_KEY,
                WINSCNF_E_PUSH_KEY,
                WINSCNF_E_ALL_KEYS
        } WINSCNF_KEY_E, *PWINSCNF_KEY_E;


//
// The states of a WINS
//
typedef enum _WINSCNF_STATE_E {
        WINSCNF_E_INITING = 0,
        WINSCNF_E_STEADY_STATE,         //not used currently
        WINSCNF_E_STEADY_STATE_INITING, //not used currently
    WINSCNF_E_RUNNING,
    WINSCNF_E_INIT_TIME_PAUSE,  //paused at initialization time as directed
                                //via registry
    WINSCNF_E_PAUSED,
    WINSCNF_E_TERMINATING
        } WINSCNF_STATE_E, *PWINSCNF_STATE_E;

//
// Stores the special groups
//
typedef struct _WINSCNF_SPEC_GRP_MASKS_T {
        DWORD         NoOfSpecGrpMasks;
        LPSTR        pSpecGrpMasks;
        } WINSCNF_SPEC_GRP_MASKS_T, *PWINSCNF_SPEC_GRP_MASKS_T;

typedef struct _WINSCNF_CC_T {
               DWORD TimeInt;
               BOOL  fSpTime;
               DWORD SpTimeInt;
               DWORD MaxRecsAAT;
               BOOL  fUseRplPnrs;
             } WINSCNF_CC_T, *PWINSCNF_CC_T;


//
// Stores the 1B names cache used in R_WinsGetBrowserNames
//
typedef struct _DOM_CACHE_T {
            DWORD   NoOfUsers;
            HANDLE  EvtHdl;
            DWORD   EntriesRead;
            DWORD   SzOfBlock;
            LPVOID  pInfo;
            BOOL    bRefresh;
} DOM_CACHE_T;

//
//  WINSCNF_CNF_T --
//         Holds all the configuration information about the WINS
//
typedef struct _WINSCNF_CNF_T {
        DWORD        MagicNo;            //Id.
        DWORD        LogDetailedEvts;    //log detailed events
        DWORD        NoOfProcessors;     // No of processors on the WINS machine
        DWORD        NoOfDbBuffers;      //No of buffers to specify to Jet
        WINSCNF_SPEC_GRP_MASKS_T    SpecGrpMasks;
        WINSCNF_STATE_E             State_e;   //State
        DWORD        RefreshInterval;      //Refresh time interval
        DWORD        TombstoneInterval;    //Tombstone time interval
        DWORD        TombstoneTimeout;     //Tombstone timeout
        DWORD        VerifyInterval;       //Verify time interval
        DWORD        ScvChunk;             //# of records to handle at one
                                           //time by the scavenger thread
        DWORD        MaxNoOfRetries;       //Max # of retries for challenges
        DWORD        RetryInterval;        //Retry time interval
        LPBYTE       pWinsDb;              //db file name
        DWORD        NoOfDataFiles;        //no of files to use for static init
        PWINSCNF_DATAFILE_INFO_T pStaticDataFile;
        BOOL         fStaticInit;           //Do static initialization of WINS
        HANDLE       WinsKChgEvtHdl;            /*event to specify to
                                           *RegNotifyChangeKeyValue
                                           */
        HANDLE       ParametersKChgEvtHdl;  /*event to specify to
                                            *RegNotifyChangeKeyValue
                                            */
        HANDLE       PartnersKChgEvtHdl;   /*event to specify to
                                             *RegNotifyChangeKeyValue
                                             */
        HANDLE       CnfChgEvtHdl;          //Manual reset event to signal on
                                            //to notify other threads of config
                                            //change
        HANDLE       LogHdl;                /*
                                            * Handle to the WINS event log
                                            * Used by ReportEvent
                                            */
        DWORD        WinsPriorityClass;     //Priority class of the process
        DWORD        MaxNoOfWrkThds;        //Max. no. of worker thds.
        int          ScvThdPriorityLvl;
        DWORD        MaxRplTimeInterval;    //max. rpl time interval
        BOOL         fRplOnlyWCnfPnrs;      //Rpl only with Pull/Push Pnrs
        BOOL         fAdd1Bto1CQueries;     //1B name should prepend responses to queries for 1C names
#if MCAST > 0
        BOOL         fUseSelfFndPnrs;       //Rpl with Pnrs found by self
        DWORD        McastTtl;              // TTL for Mcast packets
        DWORD        McastIntvl;            // Time interval for mcast packets
#endif
        BOOL         fLoggingOn;            //Turn on logging flag
        LPBYTE       pLogFilePath;          //Path to log file
        LPBYTE       pBackupDirPath;        //Path to backup directory
        BOOL         fDoBackupOnTerm;       //To turn on backup on termination
        BOOL         fPStatic;              //Set it TRUE to make static
                                            //records p-static

        BOOL         fPersonaGrata;         // TRUE/FALSE if pPersonaList is persona grata/non-grata
        DWORD        NoOfPersona;           // number of personas in the pPersonas
        PCOMM_ADD_T  pPersonaList;          // list of Personas

        DWORD         RplType;               //Rpl types (defined in winscnf.h)
        BOOL         fNoRplOnErr;            //stop rpl on error
#if PRSCONN
        BOOL         fPrsConn;               //Prs Conn
#endif
        WINSCNF_CC_T  CC;                     //Consistency Chk
        BOOL         fDoSpoofing;
        BOOL         fRandomize1CList;         // whether or not to randomize 1C list
                                                // list members.
        struct _PULL_T {
                DWORD          MaxNoOfRetries;  //no of retries to do in case
                                                //of comm. failure
                DWORD          NoOfPushPnrs;    //No of Push Pnrs
                PRPL_CONFIG_REC_T pPullCnfRecs; //ptr. to buff holding
                                                //cnf records for PULL
                                                //thd
                DWORD          InitTimeRpl;     // indicates whether
                                                // Replication
                                                //should be done at invocation
                DWORD         RplType;          //replication type
#if PRSCONN
                BOOL          fPrsConn;
#endif
                        } PullInfo;
        struct _PUSH_T {

                BOOL     fAddChgTrigger;         //trigger repl. on address chg
                                                 //of entry owned by us
                DWORD    NoOfPullPnrs;           //No of Pull Pnrs
                DWORD    NoPushRecsWValUpdCnt;
                PRPL_CONFIG_REC_T pPushCnfRecs; //ptr to buffer holding
                                                //cnf records for PUSH
                                                //thd
                DWORD   InitTimePush;          //indicates whether Push
                                               // notifications should
                                               //be sent at invocation
                BOOL    PropNetUpdNtf;         //set to TRUE if we want
                                               //net triggers to be
                                               //propagated
                DWORD         RplType;         //replication type
#if PRSCONN
                BOOL          fPrsConn;
#endif
                        } PushInfo;
        } WINSCNF_CNF_T, *PWINSCNF_CNF_T;
/*
 function declarations
*/

#if USENETBT > 0
extern
STATUS
WinsCnfReadNbtDeviceName(
        VOID
        );
#endif

extern
STATUS
WinsCnfInitConfig(
        VOID
        );


extern
VOID
WinsCnfSetLastUpdCnt(
        PWINSCNF_CNF_T        pWinsCnf
        );
extern
VOID
WinsCnfReadRegInfo(
        PWINSCNF_CNF_T        pWinsCnf
        );

extern
VOID
WinsCnfCopyWinsCnf(
                WINS_CLIENT_E        Client_e,
                PWINSCNF_CNF_T  pSrc
                );

extern
LPVOID
WinsCnfGetNextRplCnfRec(
         PRPL_CONFIG_REC_T        pCnfRec,
        RPL_REC_TRAVERSAL_E        RecTrv_e
        );


extern
VOID
WinsCnfAskToBeNotified(
        WINSCNF_KEY_E         Key_e
 );

extern
VOID
WinsCnfDeallocCnfMem(
  PWINSCNF_CNF_T        pWinsCnf
        );


extern
VOID
WinsCnfReadWinsInfo(
        PWINSCNF_CNF_T  pWinsCnf
        );


extern
VOID
WinsCnfReadPartnerInfo(
        PWINSCNF_CNF_T pWinsCnf
        );


extern
VOID
WinsCnfOpenSubKeys(
        VOID
        );
extern
VOID
WinsCnfCloseKeys(
        VOID
        );

extern
VOID
WinsCnfCloseSubKeys(
        VOID
        );

extern
STATUS
WinsCnfGetNamesOfDataFiles(
        IN  PWINSCNF_CNF_T        pWinsCnf
        );


extern
DWORD
WinsCnfWriteReg(
    LPVOID  pTmp
    );


extern
STATUS
WinsCnfInitLog(
        VOID
        );


#if MCAST > 0
extern
STATUS
WinsCnfAddPnr(
  RPL_RR_TYPE_E  PnrType_e,
  LPBYTE         pPnrAdd
);

extern
STATUS
WinsCnfDelPnr(
  RPL_RR_TYPE_E  PnrType_e,
  LPBYTE         pPnrAdd
);

#endif

#ifdef DBGSVC
extern
VOID
WinsCnfReadWinsDbgFlagValue(
        VOID
        );
#endif

#ifdef __cplusplus
}
#endif

#endif //_WINSCNF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\wins.h ===
#ifndef _WINS_
#define _WINS_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	wins.h

Abstract:

	This is the main header file for WINS.


Author:
	Pradeep Bahl				Dec-1992



Revision History:

--*/

/*
  Includes
*/
/*
 For now include all header files here since wins.h is included in every
 C file.  In future, include only those headers whose stuff is being referenced
*/
#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntseapi.h>
#include <rpc.h>
#include "winsdbg.h"
#include "winsevnt.h"
#if 0
#ifdef WINSDBG
#include "winsthd.h"
#endif
#endif


/*
 defines
*/

#pragma warning (disable: 4005)
#define LiGtr(a, b)           ((a).QuadPart > (b).QuadPart)
#define LiGeq(a, b)           ((a).QuadPart >= (b).QuadPart)
#define LiLtr(a, b)           ((a).QuadPart < (b).QuadPart)
#define LiLeq(a, b)           ((a).QuadPart <= (b).QuadPart)
#define LiGtrZero(a)          ((a).QuadPart > 0)
#define LiGeqZero(a)          ((a).QuadPart >= 0)
#define LiLtrZero(a)          ((a).QuadPart < 0)
#define LiLeqZero(a)          ((a).QuadPart <= 0)
#define LiNeqZero(a)          ((a).QuadPart != 0)
#define LiAdd(a,b)            ((a).QuadPart + (b).QuadPart)
#define LiSub(a,b)            ((a).QuadPart - (b).QuadPart)
#define LiXDiv(a,b)           ((a).Quadpart/(b).QuadPart)
#define LiEql(a,b)            ((a).QuadPart == (b).QuadPart)
#define LiEqlZero(a)          ((a).QuadPart == 0)
#define LiNeq(a,b)            ((a).QuadPart != (b).QuadPart)
#pragma warning (default: 4005)

#if 0
#define HIGH_WORD(a)          (DWORD)Int64ShraMod32(a,32)
#define LOW_WORD(a)           (DWORD)(a & 0xffffffff)
#define WINS_LI_TO_INT64_M(Li, b)  b = Int64ShllMod32(Li.HighPart, 32) | Li.LowPart
#endif



//
// Major and minor version numbers for WINS.
//
// Used in start assoc. req message.
//
#define WINS_MAJOR_VERS	    2

#if PRSCONN
#define WINS_MINOR_VERS_NT5		5
#define WINS_MINOR_VERS		WINS_MINOR_VERS_NT5  //for NT 5
#else
#define WINS_MINOR_VERS		1
#endif

#if SUPPORT612WINS > 0
#define WINS_BETA2_MAJOR_VERS_NO  2
#define WINS_BETA1_MAJOR_VERS_NO  1
#endif


#define   WINS_SERVER 		TEXT("Wins")
#define   WINS_SERVER_FULL_NAME 		TEXT("WINDOWS INTERNET NAME SERVICE")
#define   WINS_NAMED_PIPE 	TEXT("\\pipe\\WinsPipe")
#define   WINS_NAMED_PIPE_ASCII "\\pipe\\WinsPipe"

/*
The following macros are used to flag places in the code that need to be
examined for enhancements (FUTURES), or verification of something to make
the code better (CHECK) or for porting to another transport (NON_PORT)
or performance improvement (PERF) or for alignment considerations (ALIGN)
or for just FYI (NOTE)


These macros provide a convenient mechanism to quickly determine all that
needs to be enhanced, verified, or ported.

*/



#ifdef FUTURES
#define FUTURES(x)	FUTURES: ## x
#else
#define FUTURES(x)
#endif

#ifdef CHECK
#define CHECK(x)	CHECK: ## x
#else
#define CHECK(x)
#endif

#ifdef NONPORT
#define NONPORT(x)	NON_PORT: ## x
#else
#define NONPORT(x)	
#endif

#ifdef PERF
#define PERF(x)		PERF: ## x
#else
#define PERF(x)	
#endif

#ifdef NOTE
#define NOTE(x)		NOTE: ## x
#else
#define NOTE(x)	
#endif


//
// NOTE NOTE NOTE:
//  The sequence of entering critical sections when more than one is
//  entered is given below
//

//
// WinsCnfCnfCrtSec, NmsNmhNamRegCrtSec
//
//  Entered in winsintf.c,winscnf.c,nmsscv.c, rplpull.c
//


//
// Various critical sections and how they are entered
//
// ******************************
//  NmsNmhNamRegCrtSec
//*******************************
//
// Entered by the main thread on a reconfig if vers. counter value is
// specified in the registry. Enetered by nbt threads, nmschl thread
//

//
// ******************************
// NmsDbOwnAddTblCrtSec
// ******************************
//
// Entered by Pull, Push, Rpc threads.
//


/*
 ALIGN - macro to flag places where alignment is very important
*/
#ifdef ALIGN
#define ALIGN(x)	ALIGNMENT: ## x
#else
#define ALIGN(x)	
#endif


/*
  EOS is not defined in windef.h.
*/
#define EOS     (TCHAR)0


/*
  The opcodes in the first long word of a message sent on an association.

  When a message comes in on a TCP connection, the receiving COMSYS,
  checks the opcode in the first long word of the message ( lcation:
  bit 11 to bit 15) to determine if it is a message from an nbt node or
  a WINS server.  NBT message formats use bit 11- bit 15 for the opcode and
  Req/Response bit.  Since out of a posssible 32 opcode combintations, only
  5 are used by NBT, WINS uses one so that the COMSYS receiving the first
  message on a connection can determine whether the connection was
  established by an NBT node or a WINS server.

  if we do not go with the above scheme, we would have had to compare the
  address of the node making the connection with all the addresses of the
  WINS partners that we were configured with to determine whether the
  connection came from a WINS partner or an NBT node. This search is not
  only expensive but also constraints a WINS to know of all its partners
  apriori.

  All messages sent by a WINS have WINS_IS_NOT_NBT opcode in the first byte.
  This is to  enable the receiving COMSYS to look up the assoc. ctx block
  quickly without a search.  This is because if the message is from a WINS
  and is not the first one, then it has the ptr to the local assoc. ctx (this
  was sent to that WINS in the start assoc. response message).

*/

/*
 The value put in the first long word by rplmsgf functions
*/
#define WINS_RPL_NOT_FIRST_MSG	(0xF800)

//
//  Defines to indicate to WinsMscTermThd whether a database session is
//  existent or not
//
#define WINS_DB_SESSION_EXISTS		0	
#define WINS_NO_DB_SESSION_EXISTS	1	

//
// Max. size of a file name
//
#define WINS_MAX_FILENAME_SZ		255


//
// Max. size of a line
//
// Used in winsprs.c
//
#define WINS_MAX_LINE_SZ		80	

//
// Swap bytes (used in NmsMsgfProcNbtReq) and in nmschl.c)
//
#define WINS_SWAP_BYTES_M(pFirstByte, pSecondByte)			\
			{						\
				BYTE SecondByte = *(pSecondByte);	\
				*(pSecondByte) = *(pFirstByte);		\
				*(pFirstByte) = (SecondByte);		\
			}	
		

//
// Max size of a non-scoped null name (along with NULL character)
//
#define WINS_MAX_NS_NETBIOS_NAME_LEN	17

//
// Max. size of a name in the name - address mapping table.
//
#define WINS_MAX_NAME_SZ           255

FUTURES("Make this a value in the enumerator for Opcodes")
/*
 The actual value put in bit 11-bit 14.  Use 0xE (0xF is used for multihomed
 registration)
*/
#define WINS_IS_NOT_NBT			(0xF)

/*
  defines for the different status values returned by the various
  functions withing WINS


|
| SeverityNames=(Success=0x0:STATUS_SEVERITY_SUCCESS
|                Informational=0x1:STATUS_SEVERITY_INFORMATIONAL
|                Warning=0x2:STATUS_SEVERITY_WARNING
|                Error=0x3:STATUS_SEVERITY_ERROR
|               )
|
| FacilityNames=(System=0x0
|                RpcRuntime=0x2:FACILITY_RPC_RUNTIME
|                RpcStubs=0x3:FACILITY_RPC_STUBS
|                Io=0x4:FACILITY_IO_ERROR_CODE
|               )
|
| Status codes are laid out as:
|
| //
| //  Values are 32 bit values layed out as follows:
| //
| //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
| //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
| //  +---+-+-+-----------------------+-------------------------------+
| //  |Sev|C|R|     Facility          |               Code            |
| //  +---+-+-+-----------------------+-------------------------------+
| //
| //  where
| //
| //      Sev - is the severity code
| //
| //          00 - Success
| //          01 - Informational
| //          10 - Warning
| //          11 - Error
| //
| //      C - is the Customer code flag
| //
| //      R - is a reserved bit
| //
| //      Facility - is the facility code
| //
| //      Code - is the facility's status code
| //
| //
| // Define the facility codes
| //
|
| MS will never set the C bit. This is reserved for
| applications. If exceptions stay within the app, setting
| the C bit means you will never get a collision.
|
*/


#define  WINS_FIRST_NON_ERR_STATUS  ((DWORD )0x00000000L)
#define  WINS_SUCCESS		    (WINS_FIRST_NON_ERR_STATUS + 0x0)
#define  WINS_NO_REQ		    (WINS_FIRST_NON_ERR_STATUS + 0x1)
#define  WINS_NO_SP_TIME	    (WINS_FIRST_NON_ERR_STATUS + 0x2)
#define  WINS_LAST_NON_ERR_STATUS   (WINS_NO_SP_TIME)

#define  WINS_FIRST_ERR_STATUS	   ((DWORD )0xE0000000L)
#define  WINS_FAILURE		   (WINS_FIRST_ERR_STATUS + 0x1)
#define  WINS_FATAL_ERR 	   (WINS_FIRST_ERR_STATUS + 0x2)
#define  WINS_BAD_STATE_ASSOC 	   (WINS_FIRST_ERR_STATUS + 0x3)
#define  WINS_OUT_OF_MEM	   (WINS_FIRST_ERR_STATUS + 0x4)
#define  WINS_OUT_OF_HEAP	   (WINS_FIRST_ERR_STATUS + 0x5)
#define  WINS_BAD_PTR	   	   (WINS_FIRST_ERR_STATUS + 0x6)
#define  WINS_COULD_NOT_FREE_MEM   (WINS_FIRST_ERR_STATUS + 0x7)
#define  WINS_COMM_FAIL   	   (WINS_FIRST_ERR_STATUS + 0x8)
#define  WINS_ABNORMAL_TERM   	   (WINS_FIRST_ERR_STATUS + 0x9)
#define  WINS_PKT_FORMAT_ERR   	   (WINS_FIRST_ERR_STATUS + 0xA)
#define  WINS_HEAP_FREE_ERR	   (WINS_FIRST_ERR_STATUS + 0xB)
#define  WINS_HEAP_CREATE_ERR	   (WINS_FIRST_ERR_STATUS + 0xC)
#define  WINS_SIGNAL_TMM_ERR	   (WINS_FIRST_ERR_STATUS + 0xD)
#define  WINS_SIGNAL_CLIENT_ERR	   (WINS_FIRST_ERR_STATUS + 0xE)
#define  WINS_DB_INCONSISTENT	   (WINS_FIRST_ERR_STATUS + 0xF)
#define  WINS_OUT_OF_RSRCS	   (WINS_FIRST_ERR_STATUS + 0x10)
#define  WINS_INVALID_HDL	   (WINS_FIRST_ERR_STATUS + 0x11)
#define  WINS_CANT_OPEN_KEY	   (WINS_FIRST_ERR_STATUS + 0x12)
#define  WINS_CANT_CLOSE_KEY	   (WINS_FIRST_ERR_STATUS + 0x13)
#define  WINS_CANT_QUERY_KEY	   (WINS_FIRST_ERR_STATUS + 0x14)
#define  WINS_RPL_STATE_ERR	   (WINS_FIRST_ERR_STATUS + 0x15)
#define  WINS_RECORD_NOT_OWNED	   (WINS_FIRST_ERR_STATUS + 0x16)
#define  WINS_RECV_TIMED_OUT	   (WINS_FIRST_ERR_STATUS + 0x17)
#define  WINS_LOCK_ASSOC_ERR	   (WINS_FIRST_ERR_STATUS + 0x18)
#define  WINS_LOCK_DLG_ERR 	   (WINS_FIRST_ERR_STATUS + 0x19)
#define  WINS_OWNER_LIMIT_REACHED  (WINS_FIRST_ERR_STATUS + 0x20)
#define  WINS_NBT_ERR  		   (WINS_FIRST_ERR_STATUS + 0x21)
#define  WINS_QUEUE_FULL  		   (WINS_FIRST_ERR_STATUS + 0x22)
#define  WINS_BAD_RECORD  		   (WINS_FIRST_ERR_STATUS + 0x23)
#define  WINS_LAST_ERR_STATUS	   (WINS_QUEUE_FULL)


/*

 The various exceptions used within WINS
*/

#define  WINS_EXC_INIT         WINS_SUCCESS
#define  WINS_EXC_FAILURE	   WINS_FAILURE
#define  WINS_EXC_FATAL_ERR	   WINS_FATAL_ERR
#define  WINS_EXC_BAD_STATE_ASSOC  WINS_BAD_STATE_ASSOC
#define  WINS_EXC_OUT_OF_MEM	   WINS_OUT_OF_MEM

/*
 Could not allocate heap memory
*/
#define  WINS_EXC_OUT_OF_HEAP	   WINS_OUT_OF_HEAP

/*
 a bad pointer was passed Possibley to LocalFree
	Check WInsMscDealloc
*/
#define  WINS_EXC_BAD_PTR	   WINS_BAD_PTR

/*
 Memory could not be freed through LocalFree
	Check WInsMscDealloc
*/
#define  WINS_EXC_COULD_NOT_FREE_MEM	   WINS_COULD_NOT_FREE_MEM

#define  WINS_EXC_COMM_FAIL	   WINS_COMM_FAIL

/*
 The wait was terminated abnormally
*/
#define  WINS_EXC_ABNORMAL_TERM	   WINS_ABNORMAL_TERM

/*
 The name packet received is not formatted properly
*/
#define  WINS_EXC_PKT_FORMAT_ERR  WINS_PKT_FORMAT_ERR

/*
 Heap memory could not be freed
*/
#define  WINS_EXC_HEAP_FREE_ERR   WINS_HEAP_FREE_ERR

/*
 Heap could not be created
*/
#define  WINS_EXC_HEAP_CREATE_ERR   WINS_HEAP_CREATE_ERR

/*
 Could not signal Tmm thread
*/
#define  WINS_EXC_SIGNAL_TMM_ERR   WINS_SIGNAL_TMM_ERR

/*
 TMM Could not signal Client thread
*/
#define  WINS_EXC_SIGNAL_CLIENT_ERR   WINS_SIGNAL_CLIENT_ERR

/*
 Database is inconsistent.
*/
#define  WINS_EXC_DB_INCONSISTENT   WINS_DB_INCONSISTENT

/*
 Out of resources (for example: a thread could not be created)
*/
#define  WINS_EXC_OUT_OF_RSRCS   WINS_OUT_OF_RSRCS

/*
 An invalid handle is being used
*/
#define  WINS_EXC_INVALID_HDL  WINS_INVALID_HDL

/*
 The registry key is there but could not be opened
*/
#define  WINS_EXC_CANT_OPEN_KEY  WINS_CANT_OPEN_KEY

/*
 The registry key could not be closed
*/
#define  WINS_EXC_CANT_CLOSE_KEY  WINS_CANT_CLOSE_KEY

/*
 The registry key was opened but could not be queried
*/
#define  WINS_EXC_CANT_QUERY_KEY  WINS_CANT_QUERY_KEY

/*
 WINS received a replica that does not have the correct state.  For example,
 it may have received the replica of a special group (Internet) group that
 has all members timed out but the state is not TOMBSTONE

 Another example is when a replica with state RELEASED is received
*/
#define  WINS_EXC_RPL_STATE_ERR	  WINS_RPL_STATE_ERR

/*
  WINS received an update version number notification (from another WINS)
  for a record that it does not own

  There can be two reasons why this happened

  1) There is a bug in WINS (highly unlikely)
  2) The system administrator just deleted the record that was replicated
     to the remote WINS resulting in the clash and consequent update
     notification.

    Check the event logger to confirm/reject the second reason
*/
#define  WINS_EXC_RECORD_NOT_OWNED	WINS_RECORD_NOT_OWNED


//
// Could not lock an assoc block
//
#define  WINS_EXC_LOCK_ASSOC_ERR	WINS_LOCK_ASSOC_ERR

//
// Could not lock a dialogue block
//
#define  WINS_EXC_LOCK_DLG_ERR		WINS_LOCK_DLG_ERR

//
// NmsDbOwnAddTbl limit reached.  All owners of the array are taken
// by ACTIVE WINS owners
//
#define  WINS_EXC_OWNER_LIMIT_REACHED 	WINS_OWNER_LIMIT_REACHED

//
// Some fatal error concerning NBT was encountered
//
#define WINS_EXC_NBT_ERR		WINS_NBT_ERR

// bad database record encountered.
#define WINS_EXC_BAD_RECORD     WINS_BAD_RECORD
/*
 Macros
*/
//
// Control codes that can be used by the service controller (128-255)
//
#define WINS_MIN_SERVICE_CONTROL_CODE	128
#define WINS_ABRUPT_TERM	(WINS_MIN_SERVICE_CONTROL_CODE + 0)


#define WINS_RAISE_EXC_M(x)		RaiseException(x, 0, 0, NULL)


#define WINS_HDL_EXC_M(MemPtrs)	\
		{				\
		WinsMscFreeMem(MemPtrs);	\
		}	
#define WINS_HDL_EXC_N_EXIT_M(MemPtrs)	\
		{				\
		WinsMscFreeMem(MemPtrs);	\
		ExitProcess(0);			\
		}	
#define WINS_RERAISE_EXC_M()			\
		{				\
		DWORD ExcCode;			\
		ExcCode = GetExceptionCode(); 	\
		WINS_RAISE_EXC_M(ExcCode);	\
		}	

#define WINS_HDL_EXC_N_RERAISE_M(MemPtrs)	\
		{				\
		DWORD ExcCode;			\
		WinsMscFreeMem(MemPtrs);	\
		ExcCode = GetExceptionCode(); 	\
		WINS_RAISE_EXC_M(ExcCode);	\
		}

#if 0
#define WINS_RPL_OPCODE_M(pTmp)		\
		{			\
			*pTmp = WINS_RPL_NOT_FIRST_MSG; \
		}
#endif
			
#define WINS_EXIT_IF_ERR_M(func, ExpectedStatus)   	\
		{					\
		  STATUS  Status_mv ;   \
		  Status_mv = (func);	\
		  if (Status_mv != ExpectedStatus)   \
		  {				     \
			DBGPRINT0(ERR, "Major Error"); \
			ExitProcess(1); 	     \
		  }	\
		}

#define WINS_RET_IF_ERR_M(func, ExpectedStatus)   	\
		{				\
		  STATUS  Status_mv ;   \
		  Status_mv = (func);	\
		  if (Status_mv != ExpectedStatus)   \
		  {				     \
			DBGPRINT0(ERR, "Error returned by called func."); \
			return(WINS_FAILURE); 	     \
		  }		\
		}

//
// Vers. No. operations
//
#if 0
#define  WINS_ASSIGN_INT_TO_LI_M(Li, no)	{			\
				  (Li).LowPart  = (no);			\
				  (Li).HighPart = 0;			\
					}
#endif
#define  WINS_ASSIGN_INT_TO_LI_M(Li, no)  (Li).QuadPart  = (no)

#define  WINS_ASSIGN_INT_TO_VERS_NO_M(Li, no)  WINS_ASSIGN_INT_TO_LI_M(Li, no)

#define WINS_PUT_VERS_NO_IN_STREAM_M(pVersNo, pStr)			     \
						{		             \
			LPLONG	_pTmpL = (LPLONG)(pStr);	   	     \
			COMM_HOST_TO_NET_L_M((pVersNo)->HighPart, *_pTmpL);    \
			_pTmpL++;					     \
			COMM_HOST_TO_NET_L_M((pVersNo)->LowPart, *_pTmpL);     \
						}

#define WINS_GET_VERS_NO_FR_STREAM_M(pStr, pVersNo)			     \
							{		     \
			LPLONG	_pTmpL = (LPLONG)(pStr);	   	     \
			COMM_NET_TO_HOST_L_M(*_pTmpL, (pVersNo)->HighPart);    \
			_pTmpL++;					     \
			COMM_NET_TO_HOST_L_M(*_pTmpL, (pVersNo)->LowPart );    \
							}	
				
#define WINS_VERS_NO_SIZE		sizeof(LARGE_INTEGER)





/*
externs
*/
extern	DWORD	WinsTlsIndex;		/*TLS index for Nbt threads to
					 *store database info*/



/*
 Typedefs
*/
typedef  DWORD	STATUS;		// status returned by all NBNS funcs


/*
 *  VERS_NO_T -- datatype of variable storing version number.  The sizeof
 *	of this datatype is used when adding version number column in the
 *	name - address mapping table and when setting a value in this column.
 *      So, if you change the datatype, make sure you make appropriate changes
 *      in nmsdb.c (CreateTbl, InsertRow, etc)
 */

typedef  LARGE_INTEGER	VERS_NO_T, *PVERS_NO_T;      // version no.

typedef	 LPBYTE	MSG_T;		//ptr to a message
typedef	 LPBYTE	*PMSG_T;		//ptr to a message
typedef  DWORD	MSG_LEN_T;	//length of message
typedef  LPDWORD PMSG_LEN_T;	//length of message

typedef MSG_LEN_T	MSG_LEN;
typedef PMSG_LEN_T	PMSG_LEN;

typedef DWORD       WINS_UID_T, *PWINS_UID_T;



/*
    WINS_CLIENT_E -- specifies the different components and their parts
	inside the WINS server.
*/

typedef enum _WINS_CLIENT_E  {
	WINS_E_REPLICATOR = 0, 	/*replicator */
	WINS_E_RPLPULL, 	/*replicator - PULL*/
	WINS_E_RPLPUSH, 	/*replicator - PUSH*/
	WINS_E_NMS,		/* Name Space Manager		*/
	WINS_E_NMSNMH,		/* Name Space Manager - Name Handler	*/
	WINS_E_NMSCHL,		/* Name Space Manager - Challenge Manager*/
	WINS_E_NMSSCV,		/* Name Space Manager - Savenger	*/
	WINS_E_COMSYS,		/* Communication Subsystem Manager*/
	WINS_E_WINSCNF,		/* WINS - Configuration	*/
	WINS_E_WINSTMM,		/* WINS - Timer Manager*/
	WINS_E_WINSRPC		/* WINS - RPC thread*/
	} WINS_CLIENT_E, *PWINS_CLIENT_E;

#define WINS_NO_OF_CLIENTS  (WINS_E_WINSRPC + 1)
	
		
/*
 WINS_MEM_T -- This structure is used in any function that allocates memory
	      or has memory allocated for it by a called function and passed
	      back via an OUT argument

	      The ptrs to the memory blocks are linked together.  The memory
	      is freed in the exception handler.
	
	      This mechanism of keeping track of memory in a structure and
	      getting rid of it in the exception handler will alleviate memory
	      leak problems

*/
	
typedef struct _WINS_MEM_T {
	LPVOID	pMem;	     //non-heap allocated memory
	LPVOID	pMemHeap;   //memory allocated from a heap
	} WINS_MEM_T, *PWINS_MEM_T;



#ifdef __cplusplus
}
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsdbg.h ===
#ifndef _WINSDBG_
#define _WINSDBG_
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsdbg.h

Abstract:

	This file contains debug related macros and functions for the 
	WINS server

Functions:


Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/

/*
  defines
*/

#ifdef CPLUSPLUS
extern "C" {
#endif

#if DBG
#ifndef WINSDBG
#define WINSDBG
#endif
#define DBGSVC  1
#endif


#ifdef WINSDBG
#define STATIC  

#ifdef WINS_INTERACTIVE
#define PRINTF(pstr)	{printf ## pstr; }
#else
//#define PRINTF(pstr)	WINSEVT_LOG_PRINT_M(pstr)
#ifdef DBGSVC
//#define PRINTF(pstr)	{if (pNmsDbgFile != NULL) fprintf(pNmsDbgFile, pstr);}		


//
// files for storing debugs.
//
extern VOID NmsChkDbgFileSz(VOID);
extern HANDLE NmsDbgFileHdl;

#define PRINTF(pstr)	{ \
                          int DbgBytesWritten; \
                          NmsChkDbgFileSz();  \
                         if (NmsDbgFileHdl != INVALID_HANDLE_VALUE) WriteFile(NmsDbgFileHdl, pstr, strlen(pstr), (LPDWORD)&DbgBytesWritten, NULL);}
#endif
#endif
				
#define	DBGIF(flag)		if(flag)
//
// NOTE:  Use RtlQueryEnvironmental function instead of getenv in the macro
//        below
//
//  FUTURES: Use GetEnvironmentVariable here to be consistent with the general
//           usage of WIN32 API
//
#define DBGINIT	     {					           \
			        LPBYTE  _pStr;				   \
				_pStr = getenv("DBGFLAGS");		   \
				WinsDbg = _pStr == NULL ? 0 : atoi(_pStr); \
		     }
//
// check if replication should be disabled
//
#define DBGCHK_IF_RPL_DISABLED	     {			            \
			LPBYTE  _pStr;				    \
			_pStr = getenv("RPLDISABLED");		    \
			fWinsCnfRplEnabled = _pStr == NULL ? TRUE : FALSE;\
			     }
//
// check if scavenging should be disabled
//
#define DBGCHK_IF_SCV_DISABLED     {				   \
		        LPBYTE  _pStr;				   \
			_pStr = getenv("SCVDISABLED");		   \
			fWinsCnfScvEnabled = _pStr == NULL ? TRUE : FALSE;\
			     }
//
//FUTURES -- "Make this macro independent of DBG or WINSDBG")

//
// check if Perforamance Monitoring should be disabled
//
#define DBGCHK_IF_PERFMON_ENABLED     {				   \
		        LPBYTE  _pStr;				   \
			_pStr = getenv("PERFMON_ENABLED");		   \
			fWinsCnfPerfMonEnabled = _pStr == NULL ? FALSE : TRUE;\
			     }

#define IF_DBG(flag)		      if (WinsDbg & (DBG_ ## flag)) 

#ifdef WINS_INTERACTIVE

#define DBGPRINT0(flag, str) 	      {IF_DBG(flag) PRINTF((str));}  
#define DBGPRINT1(flag,str, v1)       {IF_DBG(flag) PRINTF((str,v1));} 	
#define DBGPRINT2(flag,str, v1,v2)    {IF_DBG(flag) PRINTF((str,v1,v2));} 	
#define DBGPRINT3(flag,str, v1,v2,v3) {IF_DBG(flag) PRINTF((str,v1,v2,v3));}  
#define DBGPRINT4(flag,str, v1,v2,v3,v4) {IF_DBG(flag) PRINTF((str,v1,v2,v3,v4));}  
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5) {IF_DBG(flag) PRINTF((str,v1,v2,v3,v4,v5));}  

#else

#ifdef DBGSVC 

#define DBGPRINT0(flag, str)	      {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str);PRINTF(cstr);}}   
#define DBGPRINT1(flag,str, v1)       {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1);PRINTF(cstr);}} 	
#define DBGPRINT2(flag,str, v1,v2)    {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1,v2);PRINTF(cstr);}} 	
#define DBGPRINT3(flag,str, v1,v2,v3) {IF_DBG(flag) {char cstr[500]; sprintf(cstr,str,v1,v2,v3);PRINTF(cstr);}}  
#define DBGPRINT4(flag,str, v1,v2,v3,v4) {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str,v1,v2,v3,v4);PRINTF(cstr);}}  
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5) {IF_DBG(flag) {char cstr[500]; sprintf(cstr, str,v1,v2,v3,v4,v5);PRINTF(cstr);}}  
#endif
#endif

#define DBGMYNAME(x)	{			\
	PWINSTHD_TLS_T  _pTls;			\
	_pTls  = TlsGetValue(WinsTlsIndex);	\
	if (_pTls == NULL)			\
	{					\
	  printf("Couldn't get ptr to TLS storage for storing thd name. Error is (%d)\n", GetLastError());\
	}								\
	else								\
	{								\
	   RtlCopyMemory(_pTls->ThdName, x, strlen(x));			\
	   _pTls->ThdName[strlen(x)] = EOS;				\
	}								\
 }
#define DBGPRINTNAME	{			\
	PWINSTHD_TLS_T  _pTls;			\
	_pTls  = TlsGetValue(WinsTlsIndex);	\
	if (_pTls == NULL)			\
	{					\
		DBGPRINT1(ERR, 			\
		"Couldn't get ptr to TLS storage for reading thd name. Error = (%X)\n", GetLastError()); \
	}							  	   \
	else								   \
	{								   \
	     DBGPRINT1(FLOW, "%s\n",_pTls->ThdName);			   \
	}								   \
  }

#define DBGPRINTEXC(str)	{					\
				    DBGPRINT0(EXC, str);		\
				    DBGPRINT1(EXC, ": Got Exception (%x)\n",\
					(DWORD)GetExceptionCode() );     \
				}
							
			
#define DBGENTER(str)		{					\
					DBGPRINT0(FLOW, "ENTER:") 	\
					DBGPRINT0(FLOW, str);	 	\
				}	
#define DBGLEAVE(str)		{					\
					DBGPRINT0(FLOW, "LEAVE:") 	\
					DBGPRINT0(FLOW, str);	 	\
				}	
#define  DBGSTART_PERFMON	if(fWinsCnfPerfMonEnabled) {

#define  DBGEND_PERFMON		}

//
// Use this macro in the var. declaration section of the function in which
// performance monitoring needs to be done
//
//
#define  DBG_PERFMON_VAR 			        \
	LARGE_INTEGER	LiStartCnt, LiEndCnt;	\

//
// Use this macro at the point from where you wish to start doing performance
// monitoring.  Make sure that the macro DBG_PERFMON_VAR is used in the
// variable declaration section of the function
//
#define DBG_START_PERF_MONITORING				     \
DBGSTART_PERFMON						     \
		if (fWinsCnfHighResPerfCntr)			     \
		{						     \
			printf("MONITOR START\n");		     \
			QueryPerformanceCounter(&LiStartCnt); 	     \
			printf("Current Count = (%x %x)\n", 	     \
				LiStartCnt.HighPart,		     \
				LiStartCnt.LowPart		     \
			      );				     \
		}						     \
DBGEND_PERFMON


//
// Use this macro at the point at which you wich to stop doing the monitoring
// The macro prints out the time spent in the section delimited by 
// DBG_START_PERF_MONITORING and this macro
//
//
#define DBG_PRINT_PERF_DATA						\
DBGSTART_PERFMON						        \
		LARGE_INTEGER   	TimeElapsed;			\
		if (fWinsCnfHighResPerfCntr)				\
		{							\
			QueryPerformanceCounter(&LiEndCnt);		\
		        TimeElapsed = LiDiv(				\
			    LiSub(LiEndCnt, LiStartCnt), LiWinsCnfPerfCntrFreq \
			   	);				          \
			printf("MONITOR END.\nEnd Count = (%x %x)\n", 	     \
				LiEndCnt.HighPart,		     \
				LiEndCnt.LowPart		     \
			      );				     \
		        printf("Time Elapsed (%d %d)\n", TimeElapsed.HighPart, TimeElapsed.LowPart);	\
	        }						        \
DBGEND_PERFMON

#define	DBGPRINTTIME(Type,Str, Time)	\
	{  \
      TIME_ZONE_INFORMATION tzInfo; \
      SYSTEMTIME     LocalTime; \
      GetTimeZoneInformation(&tzInfo);  \
      SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.Time), &LocalTime);  \
	  DBGPRINT5(Type, Str ## "on %d/%d at %d.%d.%d\n", \
		LocalTime.wMonth,	\
		LocalTime.wDay,	\
		LocalTime.wHour,	\
		LocalTime.wMinute,	\
		LocalTime.wSecond	\
		);					\
	}

#define WINSDBG_INC_SEC_COUNT_M(SecCount)   (SecCount)++


#else
#define STATIC  
//#define STATIC  static
#define PRINTF(str)
#define	DBGIF(flag)
#define	IF_DBG(flag)
#define DBGINIT
#define DBGCHK_IF_RPL_DISABLED
#define DBGCHK_IF_SCV_DISABLED
#define DBGCHK_IF_SCV_ENABLED
#define DBGCHK_IF_PERFMON_ENABLED
#define DBGPRINT0(flag,str) 
#define DBGPRINT1(flag,str, v1) 
#define DBGPRINT2(flag,str, v1,v2)
#define DBGPRINT3(flag,str, v1,v2,v3)
#define DBGPRINT4(flag,str, v1,v2,v3,v4)
#define DBGPRINT5(flag,str, v1,v2,v3,v4,v5)
#define DBGMYNAME(x)
#define DBGPRINTEXC(x)
#define DBGENTER(x)
#define DBGLEAVE(x)
#define DBGSTART_PERFMON
#define DBGEND_PERFMON
#define DBG_PERFMON_VAR
#define DBG_START_PERF_MONITORING
#define DBG_PRINT_PERF_DATA
#define DBGPRINTTIME(Type, Str, Time)
#define DBGPRINTNAME
#define WINSDBG_INC_SEC_COUNT_M(SecCount)
#endif

#define	WINSDBG_FILE	                TEXT("wins.dbg")
#define	WINSDBG_FILE_BK	                TEXT("wins.bak")


#define DBG_EXC          	  0x00000001   //exceptions
#define DBG_ERR                   0x00000002   //errors that do not result in 
					       //exceptions
#define DBG_FLOW                  0x00000004   //Control flow
#define DBG_HEAP             	  0x00000008   //heap related debugs 
#define DBG_SPEC             	  0x00000010   //for special debugs 
#define DBG_DS             	  0x00000020   //Data structures
#define DBG_DET			  0x00000040   //detailed stuff
#define DBG_INIT           0x00000080  //Initialization stuff

#define DBG_REPL		  0x00000100	//replication debugs
#define DBG_SCV			  0x00000200	//scavenging debugs

#define DBG_HEAP_CRDL             0x00000400    //heap creation/deletion
#define DBG_HEAP_CNTRS            0x00000800    //heap creation/deletion

#define DBG_TM                    0x00001000    //time related debugs
#define DBG_CHL                   0x00002000    //challenge mgr. related debugs
#define DBG_RPL                   0x00004000    //challenge mgr. related debugs
#define DBG_RPLPULL               0x00008000    //challenge mgr. related debugs
#define DBG_RPLPUSH               0x00010000    //challenge mgr. related debugs
#define DBG_UPD_CNTRS             0x01000000    //update counters
#define DBG_TMP                   0x02000000    //for temporary debugs 

#define DBG_INIT_BRKPNT           0x10000000    //breakpoint at the begining
#define DBG_MTCAST                0x20000000    //mcast debugs

/*
  macros
*/

/*
 externs
*/
extern ULONG WinsDbg;

/* 
 typedef  definitions
*/


/* 
 function declarations
*/
#ifdef CPLUSPLUS
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsmsc.h ===
#ifndef _WINSMSC_
#define _WINSMSC_

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsmsc.c

	

Abstract:

	This is the header file for interfacing with the winsevt.c module



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Jan-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winsque.h"
#include "winsprs.h"
/*
  defines
*/



/*
  macros
*/
//
// macros for hiding Rtl functions
//
#define WINSMSC_COPY_MEMORY_M(x,y,z)	{ RtlCopyMemory(x,y,z);  }
#define WINSMSC_MOVE_MEMORY_M(x,y,z)	{ RtlMoveMemory(x,y,z);	}
#define WINSMSC_FILL_MEMORY_M(x,y,z)	{ RtlFillMemory(x,y,z);	}
#define WINSMSC_COMPARE_MEMORY_M(x,y,z)	RtlCompareMemory(x,y,z)
#define WINSMSC_DELETE_FRM_TBL_M(x,y)	RtlDeleteElementGenericTable(x,y)
#define WINSMSC_INSERT_IN_TBL_M(u,w,x,y) RtlInsertElementGenericTable(u,w,x,y)
#if 0
#define WINSMSC_DELETE_FRM_TBL_M(x,y)	CommAssocDeleteUdpDlg(x,y)
#define WINSMSC_INSERT_IN_TBL_M(u,w,x,y) CommAssocInsertUdpDlg(u,w,x,y)
#endif

#define WINSMSC_INIT_TBL_M(u,w,x,y,z)	{RtlInitializeGenericTable(u,w,x,y,z);}


#define WINSMSC_REALLOC_M(_MemSize, _ppByte) WinsMscHeapReAlloc(GenBuffHeapHdl, (_MemSize), (_ppByte))

/*
 * externs
*/

/*
 typedef  definitions
*/


/*
 function declarations
*/


extern
VOID
WinsMscAlloc(
	IN  DWORD   Size,
	OUT LPVOID	*ppBuff
	);

extern
VOID
WinsMscDealloc(
	LPVOID	pBuff
	);

extern
VOID
WinsMscFreeMem(
	PWINS_MEM_T pWinsMem
	);
extern
VOID
WinsMscWaitInfinite(
	HANDLE Hdl
	);


extern
VOID
WinsMscWaitTimed(
	IN  HANDLE  Hdl,
	IN  DWORD   TimeOut,
        OUT LPBOOL  pfSignaled
);


extern
VOID
WinsMscCreateEvt(
	IN LPTSTR 	pName,
	IN BOOL		fManualReset,
	IN PHANDLE	pHdl
	);

extern
HANDLE
WinsMscCreateThd(
	IN  LPTHREAD_START_ROUTINE  pThdInitFn,
	IN  LPVOID		    pParam,
	OUT LPDWORD		    pThdId
	);

extern
STATUS
WinsMscSetUpThd(
	PQUE_HD_T		pQueHd,
	LPTHREAD_START_ROUTINE  pThdInitFn,
	LPVOID			pParam,
	LPHANDLE		pThdHdl,
	LPDWORD			pThdId
	);


extern
VOID
WinsMscWaitUntilSignaled(
	LPHANDLE	pHdlArray,
	DWORD		NoOfHdls,	
	LPDWORD		pIndexOfHdlSignaled,
    BOOL        fAlertable
	);


extern
VOID
WinsMscWaitTimedUntilSignaled(
	LPHANDLE	pHdlArray,
	DWORD		NoOfHdls,	
	LPDWORD		pIndexOfHdlSignaled,
	DWORD		TimeOut,
	LPBOOL		pfSignaled
	);


extern
LPVOID
WinsMscHeapAlloc(
  IN  HANDLE   HeapHdl,
  IN  DWORD      Size	
  );

extern
VOID
WinsMscHeapReAlloc(
    IN   HANDLE   HeapHdl,
	IN   DWORD    BuffSize,
	OUT  LPVOID  *ppRspBuff
	);


extern
VOID
WinsMscHeapFree(
   HANDLE HeapHdl,
   LPVOID pBuff
	);



extern
HANDLE
WinsMscHeapCreate(
	IN     DWORD  Options,
	IN     DWORD  InitSize
	);


extern
VOID
WinsMscHeapDestroy(
	HANDLE HeapHdl
	);

extern
VOID
WinsMscTermThd(
   STATUS ExitStatus,
   DWORD  DbSessionExists
	);

extern
VOID
WinsMscSignalHdl (
	HANDLE  Hdl
	);
extern
VOID
WinsMscResetHdl (
	HANDLE  Hdl
	);

extern
VOID
WinsMscCloseHdl (
	HANDLE  Hdl
	);

extern
VOID
WinsMscSetThreadPriority(
	HANDLE	ThdHdl,
	int	PrLvl
	);


extern
BOOL
WinsMscOpenFile(
	IN  LPTCH	 pFileName,
	IN  DWORD	 StrType,
	OUT LPHANDLE     pFileHandle
	);

extern
BOOL
WinsMscMapFile(
	PWINSPRS_FILE_INFO_T pFileInfo
	);


extern
VOID
WinsMscLogEvtStrs(
    LPBYTE          pAscii,
    DWORD           EvtNo,
    BOOL            fInfo
   );

extern
VOID
WinsMscConvertUnicodeStringToAscii(
	LPBYTE pUnicodeString,
	LPBYTE pAsciiString,
	DWORD	MaxSz
	);
extern
VOID
WinsMscConvertAsciiStringToUnicode(
	LPBYTE pAsciiString,
	LPBYTE pUnicodeString,
	DWORD	MaxSz
	);

extern
BOOL
WinsMscGetName(
   DWORD    StrType,
   LPTSTR   pFileName,
   LPTSTR   pExpandedFileName,
   DWORD    ExpandedFileNameBuffLen,
   LPTSTR   *ppHoldFileName
  );

extern
VOID
WinsMscSendControlToSc(
  DWORD ControlCode
);


extern
unsigned
WinsMscPutMsg(unsigned usMsgNum, ... );

LPTSTR
WinsMscGetString(
  DWORD StrId
  );

extern
VOID
WinsMscChkTermEvt(
#ifdef WINSDBG
 WINS_CLIENT_E  Client_e,
#endif
  BOOL     fTermTrans
 );

extern
VOID
WinsMscDelFiles(
 BOOL      fMultiple,
 LPCTSTR   pFilePattern,
 LPTSTR    pFilePath
 );


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsprs.h ===
#ifndef _WINSPRS_
#define _WINSPRS_

#ifdef _cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	

Abstract:

 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winscnf.h"
/*
  defines
*/



/*
  macros
*/

/*
 externs
*/

/* 
 typedef  definitions
*/

//
// Stores information about the file
//
typedef struct _WINSPRS_FILE_INFO_T {
	HANDLE		FileHdl;		//handle to file
	DWORD		FileSize;		//size of file
	DWORD		FileOffset;		//offset into file
	LPBYTE		pFileBuff;		//Memory storing the file 
	LPBYTE		pCurrPos;		//Current position to read
	LPBYTE  	pStartOfBuff;		//Start of Buffer
	LPBYTE		pLimit;			//Last Byte + 1
	} WINSPRS_FILE_INFO_T, *PWINSPRS_FILE_INFO_T;

/* 
 function declarations
*/

extern
STATUS
WinsPrsDoStaticInit(
	PWINSCNF_DATAFILE_INFO_T	pDataFile,
	DWORD				NoOfFiles,
        BOOL                            fAsync
	);

#ifdef _cplusplus
 }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winsthd.h ===
#ifndef _WINSTHD_
#define _WINSTHD_

#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winsthd.h



Abstract:


Author:

    Pradeep Bahl      18-Nov-1992	

Revision History:

--*/

#include "wins.h"
#include "esent.h"




/*
  WINS_MAX_THD - Maximum number of threads in the WINS Server

	Main thd + Thd pool # + Name Challenger (1) + Replicator (3) +
		COMSYS (2) +  Timer Manager (1)
*/

#if REG_N_QUERY_SEP > 0
#define WINSTHD_MIN_NO_NBT_THDS 2
#define WINSTHD_DEF_NO_NBT_THDS	2	
#else
#define WINSTHD_MIN_NO_NBT_THDS 1
#define WINSTHD_DEF_NO_NBT_THDS	1	
#endif
#define WINSTHD_MAX_NO_NBT_THDS 20



#define WINSTHD_NO_RPL_THDS	2
#define WINSTHD_NO_COMM_THDS	2
#define WINSTHD_NO_TMM_THDS	1
#define WINSTHD_NO_CHL_THDS	1
#define WINSTHD_NO_SCV_THDS	1


/*
	Indices of the various Replicator threads in the RplThds array of
	WinsThdPool var.
*/
#define WINSTHD_RPL_PULL_INDEX  0
#define WINSTHD_RPL_PUSH_INDEX  1

/*
 WINSTHD_TLS_T -- Structure in the thread local storage of a thread
*/

typedef struct _WINSTHD_TLS_T {
#ifdef WINSDBG
	BYTE		ThdName[30];	//just for testing
    WINS_CLIENT_E   Client_e;   //client
#endif
	JET_SESID   	SesId;		//session id	
	JET_DBID    	DbId;		//database id
	JET_TABLEID 	NamAddTblId;    //name-address table id
	JET_TABLEID 	OwnAddTblId;	//Owner - address table id
	BOOL		fNamAddTblOpen; //indicates whether the name-add tbl
					//was opened by this thread
	BOOL		fOwnAddTblOpen; //indicates whether the owner-add tbl
					//was opened by this thread
	HANDLE		HeapHdl;	
	} WINSTHD_TLS_T, *PWINSTHD_TLS_T;
	


/*
  WINSTHD_TYP_E -- Enumerates the different types of threads in the WINS server
*/
typedef enum  _WINSTHD_TYP_E {
	WINSTHD_E_TCP = 0,   //COMSYS TCP listener thread
	WINSTHD_E_UDP,	     //COMSYS UDP listener thread
	WINSTHD_E_NBT_REQ,   //NMS NBT REQ Thread
	WINSTHD_E_RPL_REQ,   //Replicator PULL Thread
	WINSTHD_E_RPL_RSP    //Replicator PUSH Thread
	} WINSTHD_TYP_E, *PWINSTHD_TYP_E;


/*
 WINSTHD_INFO_T -- Info. pertaining to a thread
*/
typedef struct _WINSTHD_INFO_T {
	BOOL	fTaken;			/*indicates whether entry is empty*/
	DWORD	ThdId;			/*thread id	*/
	HANDLE  ThdHdl;			/*handle to the thread*/
	WINSTHD_TYP_E	ThdTyp_e;	/*Type of thread	*/
	} WINSTHD_INFO_T, *PWINSTHD_INFO_T;

/*
 WINSTHD_POOL_T - The thread pool for the WINS server
*/	
typedef struct _WINSTHD_POOL_T {	
	DWORD	 	 ThdCount;	
	WINSTHD_INFO_T	 CommThds[WINSTHD_NO_COMM_THDS];/*comm thds (TCP and
							 *UDP listener)
							*/
	WINSTHD_INFO_T   RplThds[WINSTHD_NO_RPL_THDS];	//replication threads
	WINSTHD_INFO_T   ChlThd[WINSTHD_NO_CHL_THDS];   //Challenge threads
	WINSTHD_INFO_T	 TimerThds[WINSTHD_NO_TMM_THDS];//Timer thread
	WINSTHD_INFO_T	 ScvThds[WINSTHD_NO_SCV_THDS];
	WINSTHD_INFO_T   NbtReqThds[WINSTHD_MAX_NO_NBT_THDS]; //nbt threads
	} WINSTHD_POOL_T, *PWINSTHD_POOL_T;


/*
 Externals
*/

extern WINSTHD_POOL_T	WinsThdPool;


#ifdef __cplusplus
}
#endif

#endif //_WINSTHD_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\inc\winstmm.h ===
#ifndef _WINSTMM_
#define _WINSTMM_

#ifdef __cplusplus
extern "C" {
#endif
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:
	winstmm.h

	

Abstract:
	This is the header file for calling winstmm.c functions
 



Functions:



Portability:


	This header is portable.

Author:

	Pradeep Bahl	(PradeepB)	Feb-1993



Revision History:

	Modification Date	Person		Description of Modification
	------------------	-------		---------------------------

--*/

/*
  includes
*/
#include "wins.h"
#include "winsque.h"
#include "nmsdb.h"
/*
  defines
*/

#define   PAD			        10
#define  WINSTMM_MAX_SET_TMM_REQS	NMSDB_MAX_OWNERS_INITIALLY + PAD //use a pad
#if (WINSTMM_MAX_SET_TMM_REQS < NMSDB_MAX_OWNERS_INITIALLY + PAD)
#error("Your WINSTMM_MAX_SET_TMM_REQS is not set properly:)
#endif
/*
  macros
*/

/*
 externs
*/
extern HANDLE	WinsTmmHeapHdl;

/* 
 typedef  definitions
*/
//
// structure used to keep track of handles to set timer requests made
// by a component  
//
//
FUTURES("Use this in the future")
typedef struct _WINSTMM_TIMER_REQ_ACCT_T {
		DWORD	NoOfSetTimeReqs;
		LPDWORD	pSetTimeReqHdl;
		} WINSTMM_TIMER_REQ_ACCT_T, *PWINSTMM_TIMER_REQ_ACCT_T;

/* 
 function declarations
*/

extern
VOID 
WinsTmmInsertEntry(
	PQUE_TMM_REQ_WRK_ITM_T  pPassedWrkItm,
	WINS_CLIENT_E		Client_e,
	QUE_CMD_TYP_E   	CmdTyp_e,
	BOOL			fResubmit,
	time_t			AbsTime,
	DWORD			TimeInt,
	PQUE_HD_T		pRspQueHd,
	LPVOID			pClientCtx,
	DWORD			MagicNo,
	PWINSTMM_TIMER_REQ_ACCT_T pSetTimerReqs  //not used currently
	);


extern
VOID
WinsTmmInit(
	VOID
	);


//
// called when reconfiguring WINS
//
extern
VOID
WinsTmmDeleteReqs(
	WINS_CLIENT_E	WinsClient_e
	);



extern
VOID
WinsTmmDeallocReq(
	PQUE_TMM_REQ_WRK_ITM_T pWrkItm
	);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winscnf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winscnf.c

Abstract:

        This module contains functions that deal with the configuration
        information for the WINS

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992


Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/

#include "wins.h"
#include <winsock2.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <search.h>
#include "comm.h"
#include "winreg.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "nms.h"
#include "nmsnmh.h"
#include "rpl.h"
#include "rplpush.h"
#include "winsintf.h"
#include "nmfilter.h"
#include <resapi.h>


/*
 *        Local Macro Declarations
*/

//
// Size of max string that a user can input in a REG_SZ field
//
#define  MAX_SZ_SIZE        80

#define REG_M(fn, evt, exc)                                        \
                        {                                        \
                           if((fn) != ERROR_SUCCESS)                \
                           {                                        \
                                WINSEVT_LOG_M(                        \
                                        WINS_FATAL_ERR,                \
                                        (evt)                        \
                                                   );                \
                                WINS_RAISE_EXC_M((exc));        \
                           }                                        \
                        }

//
// pointer to default path for log file.  If you change this to a NON NULL
// value, make sure you don't try to free the memory in SetSystemParam
// in nmsdb.c
//
#define DEFAULT_LOG_PATH         NULL

#define  _WINS_CFG_KEY                \
                TEXT("System\\CurrentControlSet\\Services\\Wins")
#define  _WINS_CFG_PARAMETERS_KEY        TEXT("Parameters")
#define  _WINS_CFG_PARTNERS_KEY          TEXT("Partners")
#define  _WINS_CFG_CC_KEY                TEXT("Parameters\\ConsistencyCheck")
#define  _WINS_CFG_PULL_KEY              TEXT("Partners\\Pull")
#define  _WINS_CFG_PUSH_KEY              TEXT("Partners\\Push")
#define  _WINS_CFG_DATAFILES_KEY         TEXT("Parameters\\Datafiles")
#define  _WINS_CFG_SPEC_GRP_MASKS_KEY    TEXT("Parameters\\InternetGrpMasks")

#define  _WINS_LOG_KEY                \
                TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\WinsInt")
#define  _WINS_MSGFILE_SKEY  TEXT("EventMessageFile")


#define  _WINS_LOG_FILE_NAME TEXT("%SystemRoot%\\System32\\winsevnt.dll")


#define   _RPL_CLASS                TEXT("RplClass")//class for Rpl Pull and Push
                                                //keys


//
// The start version number should never be allowed to go above this number
// This will avoid a wrap around.
//

#define MAX_START_VERS_NO     0x0FFFFFFF

//
// Names of event variables used for notification purposes
//
#ifdef WINSDBG
#define        WINS_KEY_CHG_EVT_NM                TEXT("WinsKChgEvt")
#define        PARAMETERS_KEY_CHG_EVT_NM        TEXT("WinsParamatersKChgEvt")
#define        PARTNERS_KEY_CHG_EVT_NM                TEXT("WinsPartenersKChgEvt")
#define CNF_CHG_EVT_NM                        TEXT("WinsConfigChangeEvt")
#else
#define        WINS_KEY_CHG_EVT_NM                NULL
#define        PARAMETERS_KEY_CHG_EVT_NM        NULL
#define        PARTNERS_KEY_CHG_EVT_NM                NULL
#define CNF_CHG_EVT_NM                        NULL
#endif

//
// Values for the fStaticInit field of the configuration data structure
//
#define  DO_STATIC_INIT                        TRUE
#define  DONT_DO_STATIC_INIT                FALSE


//
// defines for the InitTimeRpl and InitTimePush fields of WinsCnf
//
#define DO_INIT_TIME_RPL                1
#define NO_INIT_TIME_RPL                0


//
//  NO_LIMIT_CHK_FLAG  - for easing the task of testers
//
//  If this flag is set in LogDetailedEvts DWORD, WINS skips all
//  checks for the min. values of the time intervals and Update Count.
//  This kind of operation of WINS is unsupported and is being provided
//  only to help out testers
//
#define  NO_LIMIT_CHK_FLAG   0x80000000    //MSB is set.


//
// If ErrEvt passed is 0, we don't log any message.  NOTE: a WINS event
// can never have 0 as its value (checkout winsevnt.mc)
//
#define QUERY_VALUE_M(Key, Str, ValTyp, Var, ErrEvt, DefVal)                \
        {                                                                \
                DWORD Sz = sizeof((Var));                                \
                if (RegQueryValueEx(                                        \
                                (Key),                                        \
                                (Str),                                        \
                                NULL,                                               \
                                &(ValTyp),                                \
                                (LPBYTE)&(Var),                                \
                                &Sz                                        \
                                ) != ERROR_SUCCESS                        \
                    )                                                        \
                {                                                        \
                        if ((ErrEvt) != 0)                                \
                        {                                                \
                                WINSEVT_LOG_INFO_M(                        \
                                        WINS_SUCCESS,                        \
                                        (ErrEvt)                        \
                                       );                                \
                        }                                                \
                        Var = DefVal;                                        \
                }                                                        \
           }
/*
 *        Local Typedef Declarations
 */

/*
 *        Global Variable Definitions
 */

CRITICAL_SECTION  WinsCnfCnfCrtSec;                //used for reinitialization
                                                //of certain fields of the
                                                //WinsCnf structure


BOOL        fWinsCnfRplEnabled = TRUE;                //replication is enabled
BOOL        fWinsCnfScvEnabled = TRUE;                //scavenging is enabled

FUTURES("use #ifdef PERF around the following three perf. mon. vars")
BOOL        fWinsCnfPerfMonEnabled   = FALSE;        //perf. mon is disabled
BOOL          fWinsCnfHighResPerfCntr = FALSE;    //indicates whether the
                                                  //hardware supports a high
                                                  //performance counter
LARGE_INTEGER LiWinsCnfPerfCntrFreq;                     //indicates the frequency of
                                                  //the counter

BOOL    fWinsCnfReadNextTimeVersNo = FALSE;
DWORD        WinsCnfCnfMagicNo          = WINSCNF_INITIAL_CNF_MAGIC_NO;
BOOL    fWinsCnfInitStatePaused;

//TCHAR        WinsCnfDb[WINS_MAX_FILENAME_SZ];   //db file to hold tables
BOOL    WinsCnfRegUpdThdExists = FALSE;
//#define MAX_PATH_SIZE        200
PTCHAR  pWinsCnfNbtPath;


BOOL   sfNoLimitChk = FALSE;   //to override the limit checks
//
// NetBt handle
//
HANDLE        WinsCnfNbtHandle = NULL;

//
//
// Init the configuration structure with default values
//
WINSCNF_CNF_T        WinsCnf = {
                                        WINSCNF_INITIAL_CNF_MAGIC_NO,        //id
NOTE("Change 1 to 0 before production")
                                        0,                //Log detailed evts
                    1,      //default number of processors
                    200,    //default no. of db buffers
                                        { 0, NULL},        //Spec.grp mask
                                        WINSCNF_E_INITING,        //state
                                        WINSCNF_DEF_REFRESH_INTERVAL,
                                        WINSCNF_MIN_TOMBSTONE_INTERVAL,
                                        WINSCNF_MIN_TOMBSTONE_TIMEOUT,
                                        WINSCNF_MIN_VERIFY_INTERVAL,
                                        WINSCNF_SCV_CHUNK,
                                        WINSCNF_DEF_CHL_MAX_RETRIES,
                                        WINSCNF_DEF_INIT_CHL_RETRY_INTVL,
                                        WINSCNF_DB_NAME_ASCII,  //db file name
                                        0,                //no of STATIC files
                                        NULL,                //ptr to file names
                                        DONT_DO_STATIC_INIT,
                                        (HANDLE)0,  //notify event handle (WINS)
                                        (HANDLE)0,  //not. evt hdl (PARAMETSRS)
                                        (HANDLE)0,  //not. evt hdl (PARTNERS)
                                        (HANDLE)0,  //Config change handle
                                        (HANDLE)0,  //log event handle
                                        (DWORD)WINSINTF_E_NORMAL,
                                        WINSTHD_DEF_NO_NBT_THDS,
                                        WINSCNF_SCV_PRIORITY_LVL,
                                        WINSCNF_MIN_VALID_RPL_INTVL,//max Rpl
                                                                    //Time Intvl
                                        TRUE,     //rpl. only with cnf partners
                                        TRUE,     //add 1B to responses to 1C name queries
#if MCAST > 0
                                        FALSE,    //no rpl. with self found pnrs
                                        WINSCNF_DEF_MCAST_TTL,
                                        WINSCNF_DEF_MCAST_INTVL,
#endif
                                        TRUE,     //logging is on
                                        NULL,     //current directory
                                        NULL,     //no backup directory
                                        FALSE,    //Do backup on term flg
                                        FALSE,    //PStatic flag
                                        0,        //type of persona list (0 = non-grata)
                                        0,        //number of addresses in persona list
                                        NULL,     //persona list
                                        WINSCNF_RPL_DEFAULT_TYPE, //def. rpl
                                        TRUE,    //No rpl on error
                                        TRUE,   //no persistent connections
                                //
                                // CC initialization
                                //
                                        MAXULONG, //CC Time Int
                                        FALSE,    //SpTime Set
                                        MAXULONG, //Sp Time
                                        WINSCNF_CC_DEF_RECS_AAT,
                                        WINSCNF_CC_DEF_USE_RPL_PNRS,

                                        FALSE,  //no spoofing
                                        FALSE,  // no randomization of 1C list.
                                //
                                //PullInfo initialization
                                //
                                          WINSCNF_MAX_COMM_RETRIES, //comm.
                                                                     //failure
                                                                     //retries
                                          0,   //no of Push Pnrs
                                          NULL,//ptr to Pull Pnrs records
                                          DO_INIT_TIME_RPL,  //do init time
                                                             //pulling
                                          WINSCNF_RPL_DEFAULT_TYPE,
                                          TRUE,  // persistent connections
                                //
                                // PushInfo initialization
                                //
                                          TRUE, // trigger on address change
                                                 //of owned entry
                                          0,   //no of Pull Pnrs
                                          0,   //no of Push recs with valid
                                               //update count
                                          NULL,//ptr to Push Pnrs records
                                          DO_INIT_TIME_RPL, //init time
                                                            //pushing disabled
                                          DO_PROP_NET_UPD_NTF,  //prop net upd
                                                               //ntfs.
                                          WINSCNF_RPL_DEFAULT_TYPE,
                                          TRUE  // persistent connections
                          };


/*
 *        Local Variable Definitions
*/
STATIC BOOL     sfVersNoUpdThdExists = FALSE;
STATIC BOOL     sfVersNoChanged = FALSE;

STATIC HKEY        sConfigRoot;              //HKEY for the WINS root
STATIC HKEY        sParametersKey;    //HKEY for the PARAMETERS subkey
STATIC HKEY        sCCKey;            //HKEY for the CC subkey
STATIC HKEY        sPartnersKey;      //HKEY for PARTNERS subkey
STATIC HKEY        sLogRoot;          //HKEY for the log root

FUTURES("Might want to change these to auto variables later")
STATIC TCHAR    sWinsCfgKey[]                 = _WINS_CFG_KEY;
STATIC TCHAR    sWinsLogKey[]                 = _WINS_LOG_KEY;
STATIC TCHAR    sWinsMsgFileSKey[]      = _WINS_MSGFILE_SKEY;

//
// flags that indicate to WinsCnfOpenSubKeys() whether the corresponding keys
// exist.
//
STATIC BOOL     sfParametersKeyExists = FALSE;
STATIC BOOL         sfPartnersKeyExists   = FALSE;

STATIC BOOL     sfParametersKeyOpen = FALSE;
STATIC BOOL         sfPartnersKeyOpen   = FALSE;

TCHAR        sLogFilePath[WINS_MAX_FILENAME_SZ];   //path to log file

/*
 *        Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */




STATIC
VOID
LnkWSameMetricValRecs(
        PWINSCNF_CNF_T           pWinsCnf,
        PRPL_CONFIG_REC_T  pCnfRec
        );

STATIC
int
__cdecl
CompUpdCnt(
        CONST LPVOID  pElem1,
        CONST LPVOID  pElem2
        );

STATIC
VOID
GetPnrInfo(
        RPL_RR_TYPE_E   RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        );

STATIC
VOID
GetKeyInfo(
        IN  HKEY                   Key,
        IN  WINSCNF_KEY_E        KeyTyp_e,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        );

STATIC
BOOL
SanityChkParam(
        PWINSCNF_CNF_T  pWinsCnf
        );

STATIC
VOID
ChkWinsSubKeys(
        VOID
        );

STATIC
VOID
GetSpTimeData(
        HKEY              SubKey,
        LPSYSTEMTIME      pCurrTime,
        LPBOOL            pfSpTime,
        LPDWORD           pSpTimeIntvl
        );
STATIC
VOID
ReadSpecGrpMasks(
        PWINSCNF_CNF_T pWinsCnf
        );

VOID
GetOwnerList(
  PWINSCNF_CNF_T  pWinsCnf
 );

VOID
ReadCCInfo(
 PWINSCNF_CNF_T  pWinsCnf
);

#if MCAST > 0
STATIC
DWORD
SetVal(
       HKEY     RootKey,
       LPWSTR   pName,
       DWORD    ValType,
       LPWSTR   pVal,
       DWORD    ValSize
);
#endif

#ifdef WINSDBG
STATIC
VOID
PrintRecs(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        );
#endif

/*function defs*/

STATUS
WinsCnfInitConfig(
        VOID
        )
/*++

Routine Description:

        This function opens the registry and reads in all the configuration
        information from it.


Arguments:
        None

Externals Used:
        WinsCnf

Called by:
        Init() in nms.c

Comments:
        None

Return Value:

   Success status codes --
   Error status codes  --

--*/

{
   DWORD  NewKeyInd;
   LONG          RetVal;

   /*
        First and foremost, open (or create if non-existent) the log file
   */
#if 0
   InitLog();
#endif

   RetVal = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                sWinsCfgKey,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &sConfigRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



    if (RetVal != ERROR_SUCCESS)
    {
        WINSEVT_LOG_N_RET_M(
                        WINS_FATAL_ERR,
                        WINS_EVT_CANT_OPEN_WINS_KEY,
                        WINS_FATAL_ERR
                           );
    }

   //
   // Initialize the critical section that guards the fields used
   // by Scavenger thread
   //
   InitializeCriticalSection(&WinsCnfCnfCrtSec);
   InitializeCriticalSection(&g_cs1BFilter);

   /*
        First create the events that will be passed to the
        RegNotifyChangeKeyValue function
   */
try {
   WinsMscCreateEvt(
                        WINS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.WinsKChgEvtHdl
                      );
   WinsMscCreateEvt(
                        PARAMETERS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.ParametersKChgEvtHdl
                      );
   WinsMscCreateEvt(
                        PARTNERS_KEY_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.PartnersKChgEvtHdl
                      );

}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfInitConfig");
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_CREATE_REG_EVT);
        return(WINS_FAILURE);
}

   //
   // Create the event that this main thread will set when configuration changes
   // The main thread sets this event to notify the scavenger thread (for now)
   // about the changes
   //
   WinsMscCreateEvt(
                        CNF_CHG_EVT_NM,
                        FALSE,        //auto reset event
                        &WinsCnf.CnfChgEvtHdl
                      );
   //
   // Opens the Partners and Parameters keys
   //
   WinsCnfOpenSubKeys();

   //
   // Read in the registry information
   //
   WinsCnfReadRegInfo(&WinsCnf);


   /*
        Ask to be notified when the Configuration key or any of the subkeys
        change
   */
    WinsCnfAskToBeNotified(WINSCNF_E_WINS_KEY);
    return(WINS_SUCCESS);
}

VOID
WinsCnfReadPartnerInfo(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:

  This function gets all the information pertaining to the Partners of this
  WINS. Under the configuration key above, there are two Keys PULL and PUSH.
  Under each key, there can be one or more keys (IP addresses). The values
  for each IP address key are:
        Time Interval   (for both Pull and Push IP address keys)
        Update Count        (for Push IP address keys)


Arguments:
        pWinsCnf - Address of Wins Configuration structure

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
   Init function of the Replicator.

Side Effects:

Comments:

    Note: This function should never be called when inside the
    NmsNmhNamRegCrtSec, otherwise a deadlock can occur with the Pull
    thread (check out Reconfig in rplpull.c)
--*/

{

  DWORD                 ValTyp;
  //
  // Initialize the MaxRplTimeInterval field to 0. After we have read
  // both the PULL and PUSH key information from the registry, the above
  // field will contain the max. replication time interval specified for
  // pulling and pushing replicas
  //
  pWinsCnf->MaxRplTimeInterval = 0;

  pWinsCnf->PullInfo.NoOfPushPnrs   = 0;
  pWinsCnf->PullInfo.pPullCnfRecs   = NULL;
  pWinsCnf->PullInfo.RplType        = WINSCNF_RPL_DEFAULT_TYPE;

  pWinsCnf->PushInfo.NoOfPullPnrs   = 0;
  pWinsCnf->PushInfo.pPushCnfRecs   = NULL;
  pWinsCnf->PushInfo.fAddChgTrigger = FALSE;
  pWinsCnf->PushInfo.RplType        = WINSCNF_RPL_DEFAULT_TYPE;
  //
  // Since we are again reading the info about the Partners key, increment
  // the magic no.  No other thread increments this no. The thread that
  // looks at this no is the Pull thread.
  //
  EnterCriticalSection(&WinsCnfCnfCrtSec);
  pWinsCnf->MagicNo = ++WinsCnfCnfMagicNo;
  LeaveCriticalSection(&WinsCnfCnfCrtSec);

try {
  GetOwnerList(pWinsCnf);    // get list of persona (grata / non-grata)
  //
  // Read in the RplType DWORD.  Even if no partners are defined, we do this
  // in case this WINS is open to all partners (i.e. fOnlyWCnfPnrs is FALSE)
  //
  QUERY_VALUE_M(
                          sPartnersKey,
                          WINSCNF_RPL_TYPE_NM,
                          ValTyp,
                          pWinsCnf->RplType,
                          0,      // no logging
                          WINSCNF_RPL_DEFAULT_TYPE
                            );

  GetPnrInfo(RPL_E_PULL, pWinsCnf);
  GetPnrInfo(RPL_E_PUSH, pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        //
        // If there is some problem with the registry, we don't want
        // to bugcheck WINS.  It can proceed with default values.
        // Since we have already logged the errors, the administrator
        // can take corrective action if necessary
        //
        if (
                (ExcCode != WINS_EXC_CANT_OPEN_KEY)
                         &&
                (ExcCode != WINS_EXC_CANT_QUERY_KEY)
                        &&
                (ExcCode != WINS_EXC_CANT_CLOSE_KEY)
           )
        {
                WINS_RERAISE_EXC_M();
        }
}
  return;
}



STATUS
WinsCnfInitLog(
        VOID
        )

/*++

Routine Description:
        This function open (or creates) a log file for registering events

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        WinsCnfInitConfig

Side Effects:

Comments:
        None
--*/
{

   LONG            RetVal = ERROR_SUCCESS;
   STATUS   RetStat = WINS_SUCCESS;

#ifdef WINS_INTERACTIVE
   DWORD    NewKeyInd;
   TCHAR    Buff[160];
   DWORD    dwData;

   RetVal =  RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,        //predefined key value
                sWinsLogKey,                //subkey for WINS
                0,                        //must be zero (reserved)
                TEXT("Class"),                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &sLogRoot,                //handle to key
                &NewKeyInd                //is it a new key (out arg) -- not
                                        //looked at
                );


   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }


   /*
        Set the event id message file name
   */
   lstrcpy(Buff, _WINS_LOG_FILE_NAME);

   /*
       Add the Event-ID message-file name to the subkey
   */
   RetVal = RegSetValueEx(
                        sLogRoot,            //key handle
                        sWinsMsgFileSKey,   //value name
                        0,                    //must be zero
                        REG_EXPAND_SZ,            //value type
                        (LPBYTE)Buff,
                        (lstrlen(Buff) + 1) * sizeof(TCHAR)   //length of value data
                         );

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }

   /*
     Set the supported data types flags
   */
   dwData = EVENTLOG_ERROR_TYPE       |
            EVENTLOG_WARNING_TYPE     |
            EVENTLOG_INFORMATION_TYPE;


   RetVal = RegSetValueEx (
                        sLogRoot,            //subkey handle
                        TEXT("TypesSupported"),  //value name
                        0,                    //must be zero
                        REG_DWORD,            //value type
                        (LPBYTE)&dwData,    //Address of value data
                        sizeof(DWORD)            //length of value data
                          );

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }

   /*
    * Done with the key.  Close it
   */
   RetVal = RegCloseKey(sLogRoot);

   if (RetVal != ERROR_SUCCESS)
   {
        return(WINS_FAILURE);
   }
#endif
   WinsCnf.LogHdl = RegisterEventSource(
                                (LPCTSTR)NULL,         //use local machine
                                TEXT("Wins")
                                      );
   if (WinsCnf.LogHdl == NULL)
   {
        DBGPRINT1(ERR, "InitLog: RegisterEventSource error = (%x)\n", GetLastError());
        return(WINS_FAILURE);
   }

   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_LOG_INITED);
   return(RetStat);
}

VOID
LnkWSameMetricValRecs(
        PWINSCNF_CNF_T           pWinsCnf,
        PRPL_CONFIG_REC_T  pCnfRec
        )

/*++

Routine Description:
        This function is called to link a configuration record with all
        other configuration records with the same metric value.  The metric
        to use depends upon the type of the record.  If it is a PULL record,
        the metric is "Time Interval".  If the record is a PUSH record,
        the metric is "Update Count"


Arguments:
        pWinsCnf - Address of configuration block
        pCnfRec - Configuration Record to link.

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        WinsCnfReadPartnerInfo

Side Effects:

Comments:
        The record to be linked is the last record in the buffer of
        records of the same type.
--*/

{
        PRPL_CONFIG_REC_T        pTmp;
        DWORD                        OffMetricToComp;
        LONG                        MetricVal;

        //
        // Set the variables used later based on the record type
        //
        if (pCnfRec->RRTyp_e == RPL_E_PULL)
        {
                pTmp            = pWinsCnf->PullInfo.pPullCnfRecs;
                MetricVal       = pCnfRec->TimeInterval;
                OffMetricToComp = offsetof(RPL_CONFIG_REC_T, TimeInterval);
        }
        else  //it is a PUSH record
        {
                pTmp            = pWinsCnf->PushInfo.pPushCnfRecs;
                MetricVal       = pCnfRec->UpdateCount;
                OffMetricToComp = offsetof(RPL_CONFIG_REC_T, UpdateCount);
        }

        //
        // Link in this record at the end of the linked list of
        // records with the same metric value in the buffer pointed by
        // the starting value of pTmp (set above).
        //
        for (
                ;
                pTmp != pCnfRec;                //until we reach this record
                pTmp = (PRPL_CONFIG_REC_T)((LPBYTE)pTmp + RPL_CONFIG_REC_SIZE)
            )
         {
                //
                // If Metric Value is same, go to end of linked list and
                // link in the record
                //
                if (*((LONG *)((LPBYTE)pTmp + OffMetricToComp)) == MetricVal)
                {
                        //
                        // Note: if the metric is UpdateCount (Push records)
                        // then, the following if will fail.
                        //

                        //
                        // If both records have a specific time for replication,
                        // that time must agree too
                        //
                        if (pTmp->fSpTime &&  pCnfRec->fSpTime)
                        {
                                //
                                // If specific time is not the same, go to the
                                // next record in the array
                                //
                                if (pTmp->SpTimeIntvl != pCnfRec->SpTimeIntvl)
                                {
                                        continue;
                                }
                        }

                        for(
                                ;
                                pTmp->pNext != NULL;
                                pTmp = pTmp->pNext
                           )
                                ;        //NULL body

                        pTmp->pNext            = pCnfRec;

                        //
                        // Set flag to indicate that this record has
                        // been linked. Used in SubmitTimerReqs in rplpull.c
                        //
                        pCnfRec->fLinked = TRUE;
                        break;  //record is linked. break out of the loop
                }

        }  //end of for { .. } for looping over all records in the buffer

        //
        // Make pNext to NULL since this is the last record in the buffer
        // buffer of Config Records (also in the chain if records with
        // the same metric)
        //
        pCnfRec->pNext = NULL;
        return;
}





VOID
WinsCnfSetLastUpdCnt(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:

        This function is called at initialization/reinitialization time if
        InitTimePush registry variable is set to 1) to set the LastVersNo
        field of all Push Configuration records to the value of the
        NmsNmhMyMAxVersNo counter.  This is done to avoid Push Notifications
        to be sent at Init time.

Arguments:
        pWinsCnf - Wins Configuration Info

Externals Used:
        NmsNmhMyMaxVersNo

Return Value:
        None

Error Handling:

Called by:
        NmsDbInit, Reinit (in nms.c)

Side Effects:

Comments:
        This function is called only after the local Database
        Name-Address mapping table has been read and NmsNmhMyMaxVersNo
        counter initialized (see GetMaxVersNos in nmsdb.c).  Also,
        this function is called only if the counter value is > 0
--*/

{
        PRPL_CONFIG_REC_T pCnfRec = pWinsCnf->PushInfo.pPushCnfRecs;

        for (
                ;   //null expr 1
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {
                //
                // If the Update count field is invalid, go to the next record
                //
                if (pCnfRec->UpdateCount == RPL_INVALID_METRIC)
                {
                        continue;
                }

                pCnfRec->LastVersNo = NmsNmhMyMaxVersNo;
        }

        return;
}

VOID
GetPnrInfo(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        )

/*++

Routine Description:
        This function is called to read PULL/PUSH records

Arguments:
        RRType_e - Type of Information to read (PULL or PUSH records)
        pWinsCnf  - Configuration structure


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsCnfReadPartnerInfo

Side Effects:

Comments:
        None
--*/

{

  LONG                  RetVal;
  HKEY                  CnfKey;
  TCHAR                 KeyName[20]; // will hold name of subkey of
                                     // PULL/PUSH records. These keys are IP
                                     // addresses for which 20 is a
                                     // big enough size

  CHAR                  AscKeyName[20];
  DWORD                 KeyNameSz;
  FILETIME              LastWrite;
  DWORD                 BuffSize;
  HKEY                  SubKey;
  DWORD                 ValTyp;
  DWORD                 Sz;
  PRPL_CONFIG_REC_T     paCnfRecs;
  DWORD                 NoOfPnrs   = 0;    //# of valid PULL or PUSH pnrs
  DWORD                 NoOfPnrsSv;        //# of valid PULL or PUSH pnrs saved
  DWORD                 NoOfVals;
  DWORD                 InitTime;
  DWORD                 IndexOfPnr = 0;   //total # of pnrs
  DWORD                 RplType;
  SYSTEMTIME            CurrTime;

  //
  // Get the current time.  It may be needed if we have partners with SpTime
  // specified.
  //
  if (RRType_e == RPL_E_PULL)
  {
        GetLocalTime(&CurrTime);
  }

   /*
   *  Open the key (PULL/PUSH)
   */
   RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,        //subkey for WINS
                0,                        //must be zero (reserved)
                KEY_READ,                //we desire read access to the keyo
                &CnfKey                        //handle to key
                );

   if (RetVal != ERROR_SUCCESS)
   {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
   }
   else   //key was successfully opened
   {

        /*
        *        Query the key.  The subkeys are IP addresses of PULL
        *      partners.
        */
        GetKeyInfo(
                        CnfKey,
                        (RRType_e == RPL_E_PULL ? WINSCNF_E_PULL_KEY :
                                                WINSCNF_E_PUSH_KEY),
                        &NoOfPnrs,
                        &NoOfVals   //ignored
                      );

        if (NoOfPnrs == 0)
        {

             WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_NO_SUBKEYS_UNDER_PULL  :
                                        WINS_EVT_NO_SUBKEYS_UNDER_PUSH
                                );
        }
        else
        {

                //
                // Since we have one or more Partners to replicate with,
                // read in the value of the InitTimeReplication attribute
                // of all such Partners
                //
                QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_INIT_TIME_RPL_NM,
                                ValTyp,
                                InitTime,
                                0, //WINS_EVT_CANT_GET_INITRPL_VAL,
                                DO_INIT_TIME_RPL
                             );

                //
                // Since we have one or more Partners to replicate with,
                // read in the value of the RplType attribute
                //
                QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_RPL_TYPE_NM,
                                ValTyp,
                                RplType,
                                0,
                                pWinsCnf->RplType
                             );
#if PRSCONN
               QUERY_VALUE_M(
                                   CnfKey,
                                   WINSCNF_PRS_CONN_NM,
                                   ValTyp,
                                   pWinsCnf->fPrsConn,
                                   0,
                                   TRUE
                                );
#endif
                //
                // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                //
                BuffSize = RPL_CONFIG_REC_SIZE * (NoOfPnrs + 1);
                WinsMscAlloc( BuffSize, &paCnfRecs);

                if (RRType_e == RPL_E_PULL)
                {
                        pWinsCnf->PullInfo.pPullCnfRecs = paCnfRecs;
                        QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_RETRY_COUNT_NM,
                                ValTyp,
                                pWinsCnf->PullInfo.MaxNoOfRetries,
                                0, //WINS_EVT_CANT_GET_RETRY_COUNT,
                                WINSCNF_MAX_COMM_RETRIES
                             );
                }
                else
                {
                        //
                        // Get the value of the field that indicates
                        // whether we should send a trigger when the
                        // address of an owned entry changes.
                        //
                        Sz = sizeof(pWinsCnf->PushInfo.fAddChgTrigger);
                        RetVal = RegQueryValueEx(
                                     CnfKey,
                                     WINSCNF_ADDCHG_TRIGGER_NM,
                                     NULL,        //reserved; must be NULL
                                     &ValTyp,
                                     (LPBYTE)&pWinsCnf->PushInfo.fAddChgTrigger,
                                     &Sz
                                                );

                        if (RetVal != ERROR_SUCCESS)
                        {
                            pWinsCnf->PushInfo.fAddChgTrigger = FALSE;
                        }
                        else
                        {
                            pWinsCnf->PushInfo.fAddChgTrigger =
                                (pWinsCnf->PushInfo.fAddChgTrigger >= 1);

                        }

                        QUERY_VALUE_M(
                                CnfKey,
                                WINSCNF_PROP_NET_UPD_NTF,
                                ValTyp,
                                pWinsCnf->PushInfo.PropNetUpdNtf,
                                0,                    //no event
                                DO_PROP_NET_UPD_NTF
                             );

                        pWinsCnf->PushInfo.pPushCnfRecs = paCnfRecs;
                        pWinsCnf->PushInfo.NoPushRecsWValUpdCnt = 0;
                }

                /*
                *   For each key, get the values (Time Interval/UpdateCount,
                *   etc)
                */
                NoOfPnrsSv = NoOfPnrs;  //save the number that we got from the
                                        //GetkeyInfo function
                for(
                     IndexOfPnr = 0, NoOfPnrs = 0;
                     NoOfPnrs < NoOfPnrsSv;  //no of valid pnrs < the total #
                     IndexOfPnr++
                   )
                {
                        KeyNameSz = sizeof(KeyName)/sizeof(TCHAR);  //init before every call
                        RetVal = RegEnumKeyEx(
                                CnfKey,
                                IndexOfPnr,       //Index Of Pnr
                                KeyName,
                                &KeyNameSz,
                                NULL,           //reserved
                                NULL,           //don't need class name
                                NULL,           //ptr to var. to hold class name
                                &LastWrite      //not looked at by us
                                );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                //
                                // No more ip address keys to get
                                //
                                break;
                        }

                        //
                        // Store pointer to the Wins Config structure in
                        // the configuration record
                        //
                        paCnfRecs->pWinsCnf = pWinsCnf;

                        //
                        // pWinsCnf->MagicNo contains the value of
                        // WinsCnfCnfMagicNo
                        //
                        paCnfRecs->MagicNo  = pWinsCnf->MagicNo;
                        paCnfRecs->RRTyp_e  = RRType_e;

#ifdef UNICODE
                        if (wcstombs(AscKeyName, KeyName, KeyNameSz) == -1)
                        {
                                DBGPRINT0(ERR,
                           "Conversion not possible in the current locale\n");
                        }
                        AscKeyName[KeyNameSz] = EOS;

NONPORT("Call a comm function to do this")
                        paCnfRecs->WinsAdd.Add.IPAdd = inet_addr(AscKeyName);
#else
                        paCnfRecs->WinsAdd.Add.IPAdd = inet_addr(KeyName);
#endif

                        //
                        // inet_addr returns bytes in network byte order
                        // (Left to Right).  Let us convert this into host
                        // order.  This will avoid confusion later on. All
                        // formatting functions expect address to be in host
                        // order.
                        //
                        paCnfRecs->WinsAdd.AddLen = COMM_IP_ADD_SIZE;
                        paCnfRecs->WinsAdd.AddTyp_e = COMM_ADD_E_TCPUDPIP;
                        paCnfRecs->WinsAdd.Add.IPAdd = ntohl(
                                             paCnfRecs->WinsAdd.Add.IPAdd
                                                    );
                        if (COMM_ADDRESS_SAME_M(&NmsLocalAdd, &paCnfRecs->WinsAdd))
                        {
                                //
                                // Invalid partner. Ignore. NoOfPnrs will
                                // not be incremented.  Also, the buffer
                                // pointer stays the same
                                //
                                continue;
                        }
                        RetVal = RegOpenKeyEx(
                                                CnfKey,
                                                KeyName,
                                                0,        //reserved; must be 0
                                                KEY_READ,
                                                &SubKey
                                                    );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                WINSEVT_LOG_M(
                                        WINS_FATAL_ERR,
                                        RRType_e == RPL_E_PULL ?
                                                WINS_EVT_CANT_OPEN_PULL_SUBKEY :
                                                WINS_EVT_CANT_OPEN_PUSH_SUBKEY
                                             );
FUTURES("It is possible that the user deleted the key. Recover from this")
                               if (RRType_e == RPL_E_PULL)
                               {
                                pWinsCnf->PullInfo.NoOfPushPnrs = 0;
                                WinsMscDealloc(pWinsCnf->PullInfo.pPullCnfRecs);
                                pWinsCnf->PullInfo.pPullCnfRecs = NULL;
                               }
                               else
                               {
                                pWinsCnf->PushInfo.NoOfPullPnrs = 0;
                                WinsMscDealloc(pWinsCnf->PushInfo.pPushCnfRecs);
                                pWinsCnf->PushInfo.pPushCnfRecs = NULL;
                               }
                               WINS_RAISE_EXC_M(WINS_EXC_CANT_OPEN_KEY);
                        }

FUTURES("Maybe, we will support a time interval attribute for Push records")
FUTURES("when that is done, LnkRecsWSameMetric would need to be updated")

                        if (RRType_e == RPL_E_PULL)
                        {

                           //
                           // Read in specific time for replication if one
                           // has been specified
                           //
                           GetSpTimeData(SubKey, &CurrTime, &paCnfRecs->fSpTime, &paCnfRecs->SpTimeIntvl);

                           Sz = sizeof(paCnfRecs->TimeInterval);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_RPL_INTERVAL_NM,
                                               NULL,        //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&paCnfRecs->TimeInterval,
                                               &Sz
                                                );

                           if (RetVal != ERROR_SUCCESS)
                           {
                                WINSEVT_LOG_INFO_D_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CANT_GET_PULL_TIMEINT
                                                    );
                                paCnfRecs->TimeInterval = RPL_INVALID_METRIC;
                           }
                           else  // a value was read in
                           {
                                //
                                // If the time interval is less than or
                                // equal to the minimum allowed, use the
                                // default minimum
                                //
                                if (paCnfRecs->TimeInterval
                                        < WINSCNF_MIN_VALID_RPL_INTVL)
                                {
                                        paCnfRecs->TimeInterval =
                                                WINSCNF_MIN_VALID_RPL_INTVL;
                                }
                                if (
                                   (DWORD)paCnfRecs->TimeInterval >
                                                 pWinsCnf->MaxRplTimeInterval
                                   )
                                {
                                        pWinsCnf->MaxRplTimeInterval =
                                                       paCnfRecs->TimeInterval;
                                }
                           }

                           //
                           // Read in the precedence level.  This can currently
                           // be either HIGH (> 0) or LOW (0).
                           //
                           Sz = sizeof(paCnfRecs->MemberPrec);
                           RetVal = RegQueryValueEx(
                                               SubKey,
                                               WINSCNF_MEMBER_PREC_NM,
                                               NULL,   //reserved; must be NULL
                                               &ValTyp,
                                               (LPBYTE)&paCnfRecs->MemberPrec,
                                               &Sz
                                                );
                           if (RetVal != ERROR_SUCCESS)
                           {
                                paCnfRecs->MemberPrec =  WINSCNF_LOW_PREC;
                           }
                           else
                           {
                                paCnfRecs->MemberPrec =
                                  (paCnfRecs->MemberPrec > 0) ?
                                         WINSCNF_HIGH_PREC : WINSCNF_LOW_PREC;
                           }

#if PRSCONN
                           QUERY_VALUE_M(
                                SubKey,
                                WINSCNF_PRS_CONN_NM,
                                ValTyp,
                                paCnfRecs->fPrsConn,
                                0,
                                pWinsCnf->fPrsConn
                             );
#endif
                        }
                        else  // it is a PUSH record
                        {

                                //
                                // Currently, we don't support periodic
                                // or specific time replication for Push
                                // records
                                //
                                paCnfRecs->fSpTime = FALSE;

#if PRSCONN
                                QUERY_VALUE_M(
                                   SubKey,
                                   WINSCNF_PRS_CONN_NM,
                                   ValTyp,
                                   paCnfRecs->fPrsConn,
                                   0,
                                   pWinsCnf->fPrsConn
                                );
#endif

                                Sz = sizeof(paCnfRecs->UpdateCount);
                                RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_UPDATE_COUNT_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->UpdateCount,
                                                &Sz
                                                        );

                                if (RetVal != ERROR_SUCCESS)
                                {
                                        paCnfRecs->UpdateCount =
                                                        RPL_INVALID_METRIC;
                                }
                                else
                                {
                                        paCnfRecs->LastVersNo.QuadPart = 0;
#if PRSCONN
                                        if (!paCnfRecs->fPrsConn && !sfNoLimitChk)
#else
                                        if (!sfNoLimitChk)
#endif
                                        {
                                          if (paCnfRecs->UpdateCount <
                                                 WINSCNF_MIN_VALID_UPDATE_CNT)
                                          {
                                                paCnfRecs->UpdateCount =
                                                   WINSCNF_MIN_VALID_UPDATE_CNT;
                                          }
                                        }
                                        else
                                        {
                                             if (paCnfRecs->UpdateCount == 0)
                                             {
                                                 paCnfRecs->UpdateCount = 1;
                                             }
                                        }
                                        pWinsCnf->PushInfo.NoPushRecsWValUpdCnt++;
                                }



                        }


#if MCAST > 0
                        Sz = sizeof(paCnfRecs->fSelfFnd);
                        RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_SELF_FND_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->fSelfFnd,
                                                &Sz
                                                        );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                paCnfRecs->fSelfFnd = FALSE;
                        }
#endif

                        Sz = sizeof(paCnfRecs->fOnlyDynRecs);
                        RetVal = RegQueryValueEx(
                                                SubKey,
                                                WINSCNF_ONLY_DYN_RECS_NM,
                                                NULL,
                                                &ValTyp,
                                                (LPBYTE)&paCnfRecs->fOnlyDynRecs,
                                                &Sz
                                                        );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                paCnfRecs->fOnlyDynRecs = FALSE;
                        }

                        QUERY_VALUE_M(
                                SubKey,
                                WINSCNF_RPL_TYPE_NM,
                                ValTyp,
                                paCnfRecs->RplType,
                                0,
                                pWinsCnf->RplType
                             );


                        if (paCnfRecs->RplType != 0)
                        {
                          WINSEVT_LOG_INFO_M(paCnfRecs->WinsAdd.Add.IPAdd, WINS_EVT_PARTIAL_RPL_TYPE);
                        }

#if PRSCONN
                        if (paCnfRecs->fPrsConn != 0)
                        {
                           paCnfRecs->fPrsConn = TRUE;
                        }
#endif

                        REG_M(
                                RegCloseKey(SubKey),
                                WINS_EVT_CANT_CLOSE_KEY,
                                WINS_EXC_CANT_CLOSE_KEY
                             );

                        //
                        // Initialize the retry count to 0 and the fLinked flag
                        // to FALSE
                        //
                        //used when pulling
                        //
                        paCnfRecs->RetryCount              = 0;

                        paCnfRecs->fLinked              = FALSE;

                        //
                        // Initialize the following to 0 so that once we stop
                        // communicating with a WINS we can start again when
                        // the following count reaches
                        // WINSCNF_RETRY_AFTER_THIS_MANY_RPL
                        //
                        paCnfRecs->RetryAfterThisManyRpl = 0;


#if PRSCONN
                        ECOMM_INIT_DLG_HDL_M(&paCnfRecs->PrsDlgHdl);
                        paCnfRecs->LastCommTime = 0;
#endif

                        //
                        // Initialize LastCommFailTime to 0. Used by
                        // SndPushNtf in rplpull.c
                        //

                        paCnfRecs->LastCommFailTime = 0;
                        paCnfRecs->PushNtfTries   = 0;

                        //
                        // Link the record with other PULL records with the same
                        // Time Interval
                        //
                        LnkWSameMetricValRecs(pWinsCnf, paCnfRecs);
                        //
                        // Mark the record as permanent (i.e. it will stay
                        // around until a reconfiguration or until the process
                        // terminates
                        //
                        paCnfRecs->fTemp = FALSE;

                        NoOfPnrs++;
                        paCnfRecs = (PRPL_CONFIG_REC_T)(
                                        (LPBYTE)paCnfRecs +
                                                RPL_CONFIG_REC_SIZE);
                } // end of for {..} for looping over subkeys of PULL

                //
                // GetReplicasNew expects the list to be terminated with a
                // record with INADDR_NONE as the address
                //
                paCnfRecs->WinsAdd.Add.IPAdd = INADDR_NONE;
                if (RRType_e == RPL_E_PULL)
                {
                      pWinsCnf->PullInfo.NoOfPushPnrs = NoOfPnrs;
                      pWinsCnf->PullInfo.InitTimeRpl  = InitTime;
                      pWinsCnf->PullInfo.RplType      = RplType;
                }
                else
                {
                      pWinsCnf->PushInfo.NoOfPullPnrs = NoOfPnrs;
                      pWinsCnf->PushInfo.InitTimePush = InitTime;
                      pWinsCnf->PushInfo.RplType      = RplType;

                      //
                      // Now that we are done with the Push record list,
                      //let us  sort it on the update count field
                      //
                      //
                      // Sort the array in increasing order of Update Counts
                      //

FUTURES("May use qsort to optimize the update notification process")
CHECK("Not sure yet whether sorting would optimize it")
#if 0
CHECK("this is resulting in compilation warnings.  haven't figured out")
CHECK("yet why.")
                      qsort(
                                pWinsCnf->pPushCnfRecs,        //start of array
                                (size_t)pWinsCnf->NoOfPullPnrs,//no of elements
                                RPL_CONFIG_REC_SIZE,        //size of each
                                                            //element
                                CompUpdCnt                    //compare func
                             );
#endif

                 } //end of else (It is PULL key)
            } // end of else (NoOfPnrs == 0)

            /*
             * Close the  key
            */
            REG_M(
                RegCloseKey(CnfKey),
                WINS_EVT_CANT_CLOSE_KEY,
                WINS_EXC_CANT_CLOSE_KEY
                      );
   } //end of else  (key could not be opened)
#if 0
#ifdef WINSDBG
     PrintRecs(RRType_e, pWinsCnf);
#endif
#endif

     return;
} // GetPnrInfo


VOID
GetOwnerList(
  PWINSCNF_CNF_T  pWinsCnf
 )

/*++

Routine Description:
  This function reads the list of owners whose records should be or should not be pulled
  from a partner WINS.


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    LONG        RetVal;
    DWORD       dwValType;    // type of the reg value
    LPSTR       pValName;     // pointer to the reg 
    LPBYTE      pValData;     // pointer to the reg value's data
    DWORD       dwValDataLen; // length of the reg value's data

    DBGENTER("GetOwnerList\n");

    // query for the type of persona (grata (1) / non-grata (0))
    pWinsCnf->fPersonaGrata = 0;
    dwValDataLen = sizeof(DWORD);
    RetVal = RegQueryValueExA(
                sPartnersKey,                       // reg key [HKLM\System\CCS\Services\Wins\Partners]
                WINSCNF_PERSONA_MODE_NM,            // name of the value: "PersonaType"
                NULL,                               // reserved; must be NULL
                &dwValType,                         // type of the value: should get REG_DWORD
                (LPVOID)&(pWinsCnf->fPersonaGrata), // value data
                &dwValDataLen);                     // size of the value's data
    // if this call didn't succeed, we go on with the default which is 0, 'non-grata'

    // get the actual entry we're going to pick the list of addresses from
    pValName = pWinsCnf->fPersonaGrata ? 
                WINSCNF_PERSONA_GRATA_NM : 
                WINSCNF_PERSONA_NON_GRATA_NM;

    // get the size of the data from the registry
    // since Sz is 0, if there are any personas
    // grata/non-grata then we should get ERROR_MORE_DATA
    // if we get a different error than just remove the current list
    dwValDataLen = 0;
    RetVal = RegQueryValueExA(
                sPartnersKey,           // reg key [HKLM\System\CCS\Services\Wins\Partners]
                pValName,               // name of the value: "PersonaList"
                NULL,                   // reserved; must be NULL
                &dwValType,             // type of the value: should get REG_MULTI_SZ
                (LPVOID)&pValData,      // dummy address
                &dwValDataLen);         // initially 0 since we try to determine the actual size
    // this call should return ERROR_MORE_DATA for a REG_MULTI_SZ value

    // clear-up the old buffer
    if (pWinsCnf->pPersonaList != NULL)
    {
        WinsMscDealloc(pWinsCnf->pPersonaList);
    }
    pWinsCnf->NoOfPersona = 0;
    pWinsCnf->pPersonaList = NULL;

    // check if there is a valid value, with the expected type; return if not
    if (RetVal != ERROR_MORE_DATA || dwValType != REG_MULTI_SZ)
    {
        DBGLEAVE("GetOwnerList\n");
        return;
    }

    // allocate the needed buffer
    WinsMscAlloc(dwValDataLen, &pValData);

    // now query for the data value with a buffer large enough
    RetVal = RegQueryValueExA(
                sPartnersKey,
                pValName,
                NULL,                       // reserved; must be NULL
                &dwValType,
                (LPVOID)pValData,           // now this is the real address
                &dwValDataLen);

    // ERROR_SUCCESS is expected here
    if (RetVal == ERROR_SUCCESS)
    {
        LPBYTE pString = pValData;

        // count in nAddr the number of addresses in the string
        for( pWinsCnf->NoOfPersona=0; *pString; pWinsCnf->NoOfPersona++)
            pString+= strlen(pString)+1;

        // see if there are any addresses there
        if (pWinsCnf->NoOfPersona > 0)
        {
            COMM_IP_ADD_T IpAdd;

            // allocate an array of nAddr COMM_ADD_T structures
            WinsMscAlloc(
                (pWinsCnf->NoOfPersona) * sizeof(COMM_ADD_T),
                &(pWinsCnf->pPersonaList));

            // loop through the string of addresses and convert 
            // them to COMM_IP_ADD_T structures
            for (pString = pValData, pWinsCnf->NoOfPersona = 0;
                *pString;
                pString += strlen(pString) + 1)
            {
                if ((IpAdd = inet_addr(pString)) != -1)
                {
                    // initialize a COMM_ADD_T structure only if the string token is
                    // indeed an IP address
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].AddTyp_e = COMM_ADD_E_TCPUDPIP;
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].AddLen = COMM_IP_ADD_SIZE;
                    (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].Add.IPAdd = ntohl(IpAdd);

                    DBGPRINT2(
                        DET,
                        "GetOwnerList: Address[%d] = %x\n",
                        pWinsCnf->NoOfPersona,
                        (pWinsCnf->pPersonaList)[pWinsCnf->NoOfPersona].Add.IPAdd);

                    pWinsCnf->NoOfPersona++;
                } //end 'if valid ip address'
            } //end 'for each token in the string'

            // if there are at least two addresses in the list,
            // sort them in ascending order
            if (pWinsCnf->NoOfPersona > 1)
            {
                qsort(pWinsCnf->pPersonaList,
                      (size_t)pWinsCnf->NoOfPersona,
                      sizeof(COMM_ADD_T),
                      ECommCompareAdd);
            }
            else
            {
                DBGPRINT0(DET, "GetOwnerList: No valid address found\n");
            } //end 'if there are more than two addresses picked up'

        } //end 'if there are any tokens at all'
    } //end 'if string could be read successfully from the registry'

    // the string buffer is no longer needed here
    WinsMscDealloc(pValData);

#ifdef WINSDBG
    {
        DWORD tstNAddrs;
        PCOMM_ADD_T tstPAddrs;
        DWORD i;

        DBGPRINT1(
            DET,
            "GetOwnerList: Persona %sGrata List:\n",
            pWinsCnf->fPersonaGrata ? "" : "Non-");

        tstNAddrs = pWinsCnf->NoOfPersona;
        tstPAddrs = pWinsCnf->pPersonaList;
        for (i = 0; i < tstNAddrs; i++)
        {
            DBGPRINT2(
                DET,
                "GetOwnerList:PersonaList[%d] = %08x\n",
                i,
                tstPAddrs[i].Add.IPAdd);
        }
    }
#endif

    DBGLEAVE("GetOwnerList\n");
    return;
}

LONG
ReadClusterIp(
    HKEY    KeyHandle,
    DWORD   *IpAddress
    )
{
    DWORD           Sz;
    LONG            RetVal;
    DWORD           ValTyp;
    TCHAR            DirPath[WINS_MAX_FILENAME_SZ];

    *IpAddress = 0;
    // Read the wins cluster name
    Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
    RetVal = RegQueryValueEx(
                         KeyHandle,
                         WINSCNF_CLUSTER_RESOURCE_NM,
                         NULL,                //reserved; must be NULL
                         &ValTyp,
                         (LPBYTE)DirPath,
                         &Sz
                         );

    if ((RetVal == ERROR_SUCCESS) && (DirPath[0] != (TCHAR)EOS))
    {
         HCLUSTER     hCluster;
         HRESOURCE    hResource;
         CHAR         IpAddressStr[sizeof ("xxx.xxx.xxx.xxx")];
         WCHAR        IpAddressWStr[sizeof ("xxx.xxx.xxx.xxx")];
         DWORD        i;
         HMODULE      Dll1, Dll2;
         #define      FUNC_TBL_ENTRY( _Dll, _Name ) { _Dll, &(#_Name)[1], NULL }
         #define      CALL_FUNC( _Func)     (PVOID)( *FuncTbl[_Func].FuncHdl )
         enum {
             _OpenCluster,
             _OpenClusterResource,
             _CloseCluster,
             _CloseClusterResource,
             _ResUtilGetResourceDependentIPAddressProps
         };
         struct {
             HMODULE     *Dll;
             LPCSTR       FuncName;
             FARPROC      FuncHdl;
         } FuncTbl[] = {
             FUNC_TBL_ENTRY( &Dll1,_OpenCluster),
             FUNC_TBL_ENTRY( &Dll1,_OpenClusterResource),
             FUNC_TBL_ENTRY( &Dll1,_CloseCluster),
             FUNC_TBL_ENTRY( &Dll1,_CloseClusterResource),
             FUNC_TBL_ENTRY( &Dll2,_ResUtilGetResourceDependentIPAddressProps)
         };


         DBGPRINT1(DET, "WinsCnfReadWinsInfo: ClusterResourceName is (%ws)\n", DirPath);
         hCluster = NULL;
         hResource = NULL;
         Dll1 = Dll2 = NULL;
        do {
             Dll1 = LoadLibrary(TEXT("clusapi.dll"));
             if (!Dll1) {
                 RetVal = GetLastError();
                 break;
             }
             Dll2 = LoadLibrary(TEXT("resutils.dll"));
             if (!Dll2) {

                 RetVal = GetLastError();
                 break;
             }
             for (i=0; i<(sizeof(FuncTbl)/sizeof(FuncTbl[0])); i++) {
                 FuncTbl[i].FuncHdl = GetProcAddress(*FuncTbl[i].Dll, FuncTbl[i].FuncName);
                 if (!FuncTbl[i].FuncHdl) {
                     RetVal = GetLastError();
                     break;
                 }
             }
             if (i<(sizeof(FuncTbl)/sizeof(FuncTbl[0]))) {
                 break;
             }
             hCluster = CALL_FUNC(_OpenCluster)( NULL );
             if (!hCluster) {
                 RetVal = GetLastError();
                 break;
             }
             hResource = CALL_FUNC(_OpenClusterResource)(hCluster, DirPath);
             if (!hResource) {
                 RetVal = GetLastError();
                 break;
             }
             Sz = sizeof (IpAddressWStr);
             RetVal = PtrToLong(CALL_FUNC(_ResUtilGetResourceDependentIPAddressProps)(
                         hResource,
                         IpAddressWStr,
                         &Sz,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                         ));
             if (ERROR_SUCCESS != RetVal) {
                 break;
             }
             WinsMscConvertUnicodeStringToAscii((LPBYTE)IpAddressWStr, IpAddressStr, sizeof(IpAddressStr));
             *IpAddress = ntohl(inet_addr(IpAddressStr));
             DBGPRINT1(DET, "ReadClusterIp: Cluster IpAddress is (%lx)\n", *IpAddress);
        } while ( FALSE );
        if( hResource ) CALL_FUNC(_CloseClusterResource)(hResource);
        if( hCluster ) CALL_FUNC(_CloseCluster) (hCluster);
        if ( Dll1 ) FreeLibrary(Dll1);
        if ( Dll2 ) FreeLibrary(Dll2);
    }

    return RetVal;
}

extern DOM_CACHE_T sDomCache;

VOID
WinsCnfReadWinsInfo(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:
        This function reads information (excluding subkeys) about
        the local WINS

Arguments:
        None

Externals Used:
        sConfigRoot,

Return Value:
        None

Error Handling:

Called by:
        WinsCnfInitConfig

Side Effects:

Comments:
        None
--*/

{

        DWORD           Sz;
        LONG            RetVal;
        DWORD           ValTyp;
        VERS_NO_T       MaxVersNo;
        WINSEVT_STRS_T  EvtStr;
        TCHAR            DirPath[WINS_MAX_FILENAME_SZ];
        TCHAR            Path2[WINS_MAX_FILENAME_SZ];
        LPTSTR          pHoldFileName;
        DWORD           fUse351Db;
        DWORD           fUse4Db;
        EvtStr.NoOfStrs = 1;

try {

#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
        //
        // Read the value of WinsDbg. Though this value is
        // being used concurrently by multiple threads (at reinit time), we
        // don't enter any critical section here.  This value
        // is used only for debugging
        //
        WinsCnfReadWinsDbgFlagValue();
#endif

        Sz = sizeof(pWinsCnf->LogDetailedEvts);
        (VOID)RegQueryValueEx(
                             sParametersKey,
                             WINSCNF_LOG_DETAILED_EVTS_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             (LPBYTE)&pWinsCnf->LogDetailedEvts,
                             &Sz
                                );

        // Read in the 1B filter. If the "Filter1BRequests" is there and it is a REG_MULTI_SZ
        // then the filter is created for each of the names specified there. When R_WinsGetBrowserNames
        // is called, the database is filtered only for the name present in the filter.
        RetVal = RegQueryValueExW(
                    sParametersKey,
                    WINSCNF_FILTER1BREQUESTS_NM,
                    NULL,
                    &ValTyp,
                    NULL,
                    &Sz);

        if (RetVal == ERROR_SUCCESS && ValTyp == REG_MULTI_SZ)
        {
            LPWSTR str1BFilters = NULL;
            LPWSTR p1BFilter;

            WinsMscAlloc(Sz, &str1BFilters);

            if (RegQueryValueExW(
                    sParametersKey,
                    WINSCNF_FILTER1BREQUESTS_NM,
                    NULL,
                    &ValTyp,
                    (LPBYTE)str1BFilters,
                    &Sz) == ERROR_SUCCESS)
            {
                EnterCriticalSection(&g_cs1BFilter);

                try
                {
                    g_p1BFilter = InitNmFilter(g_p1BFilter);

                    p1BFilter = str1BFilters;
                    do
                    {
                        DWORD nLenFilter = wcslen(p1BFilter);
                        CHAR  strOemName[17];
                        OEM_STRING      oemString;
                        UNICODE_STRING  unicodeString;

                        if (nLenFilter == 0)
                            break;

                        memset(strOemName, ' ', 16);
                        strOemName[16]=0;
                        if (nLenFilter > 15)
                            p1BFilter[16]=L'\0';

                        RtlInitUnicodeString(&unicodeString, p1BFilter);
                        RtlInitString(&oemString, strOemName);
                        RtlUpcaseUnicodeStringToOemString(&oemString, &unicodeString, FALSE);

                        strOemName[strlen(strOemName)] = ' ';
                        strOemName[15] = strOemName[0];
                        strOemName[0]  = 0x1B;
                        InsertNmInFilter(g_p1BFilter, strOemName, 16);
                        p1BFilter += nLenFilter+1;
                    }
                    while(TRUE);
                }
                finally
                {
                    LeaveCriticalSection(&g_cs1BFilter);
                }
            }

            WinsMscDealloc(str1BFilters);
        }
        else
        {
            // if the reg key is not there, reset the filter - all names will be returned.
            EnterCriticalSection(&g_cs1BFilter);
            try
            {
                g_p1BFilter = DestroyNmFilter(g_p1BFilter);
            }
            finally
            {
                g_p1BFilter = NULL;
                LeaveCriticalSection(&g_cs1BFilter);
            }
        }

        sDomCache.bRefresh = TRUE;

        //
        // Read in the fAdd1Bto1CQueries parameter. Default is TRUE
        // meaning: when processing name queries for 1C names, prepend the
        // response with the 1B name (browser name).
        //
        pWinsCnf->fAdd1Bto1CQueries = TRUE;
        Sz = sizeof(pWinsCnf->fAdd1Bto1CQueries);
        (VOID)RegQueryValueEx(
                            sParametersKey,
                            WINSCNF_ADD1BTO1CQUERIES_NM,
                            NULL,
                            &ValTyp,
                            (LPBYTE)&pWinsCnf->fAdd1Bto1CQueries,
                            &Sz
                            );
        //
        // Read in the cap value on the number of worker threads.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_MAX_NO_WRK_THDS_NM,
                        ValTyp,
                        pWinsCnf->MaxNoOfWrkThds,
                        0,
                        0   //WINSTHD_DEF_NO_NBT_THDS
                      );

        //
        // Check if the user needs to override our checks.
        //
        sfNoLimitChk = pWinsCnf->MaxNoOfWrkThds & NO_LIMIT_CHK_FLAG;
        if (sfNoLimitChk)
        {
            WINSEVT_LOG_M(pWinsCnf->LogDetailedEvts, WINS_EVT_INTERNAL_FEATURE);
            pWinsCnf->MaxNoOfWrkThds &= ~NO_LIMIT_CHK_FLAG;
        }

        if (pWinsCnf->MaxNoOfWrkThds > WINSTHD_MAX_NO_NBT_THDS)
        {
             pWinsCnf->MaxNoOfWrkThds = WINSTHD_MAX_NO_NBT_THDS;
        }
        if (pWinsCnf->MaxNoOfWrkThds < WINSTHD_MIN_NO_NBT_THDS)
        {
             pWinsCnf->MaxNoOfWrkThds = WINSTHD_MIN_NO_NBT_THDS;
        }

#if 0
        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
                ReadSpecGrpMasks(pWinsCnf);
        }
#endif

#if DYNLOADJET
        //
        // Read in the cap value on the number of worker threads.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_USE_351DB_NM,
                        ValTyp,
                        fUse351Db,
                        0,
                        0   //Use 500 db
                      );
        //
        // If set to a non-zero value, we need to load jet.dll
        //
        if (fUse351Db)
        {
            DynLoadJetVersion = DYN_LOAD_JET_200;
        } else {
            QUERY_VALUE_M(
                            sParametersKey,
                            WINSCNF_USE_4DB_NM,
                            ValTyp,
                            fUse4Db,
                            0,
                            0   //Use 500 db
                          );
            //
            // If set to a non-zero value, we need to load jet.dll
            //
            if (fUse4Db)
            {
                DynLoadJetVersion = DYN_LOAD_JET_500;
            }
        }

#endif
        //
        // Read in the refresh Interval
        //
        Sz = sizeof(pWinsCnf->RefreshInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_REFRESH_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->RefreshInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_REFRESH_INTERVAL_VAL
                               );
                pWinsCnf->RefreshInterval = WINSCNF_DEF_REFRESH_INTERVAL;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->RefreshInterval  <
                                   WINSCNF_MIN_REFRESH_INTERVAL)
                    {
                       pWinsCnf->RefreshInterval = WINSCNF_MIN_REFRESH_INTERVAL;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_REFRESH_INTVL_NM,
                             pWinsCnf->RefreshInterval);
                    }
                }
                else
                {
                      if (pWinsCnf->RefreshInterval < 60)
                      {
                          pWinsCnf->RefreshInterval = 60;
                      }
                }
        }

        //
        // Read in the Initial Challenge Retry Interval
        //
        Sz = sizeof(pWinsCnf->RetryInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_CHL_RETRY_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->RetryInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_INIT_CHL_RETRY_INTVL_VAL
                               );
                pWinsCnf->RetryInterval = WINSCNF_DEF_INIT_CHL_RETRY_INTVL;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->RetryInterval  <
                                   WINSCNF_MIN_INIT_CHL_RETRY_INTVL)
                    {
                       pWinsCnf->RetryInterval = WINSCNF_MIN_INIT_CHL_RETRY_INTVL;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_INIT_CHL_RETRY_INTVL_NM,
                             pWinsCnf->RetryInterval);
                    }
                }
                else
                {
                      if (pWinsCnf->RetryInterval < WINSCNF_MIN_INIT_CHL_RETRY_INTVL)
                      {
                          pWinsCnf->RetryInterval = WINSCNF_MIN_INIT_CHL_RETRY_INTVL;
                      }
                }
        }

        //
        // Read in the Initial Challenge Max. No. of Retries
        //
        Sz = sizeof(pWinsCnf->MaxNoOfRetries);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_CHL_MAX_RETRIES_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->MaxNoOfRetries,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CHL_MAX_RETRIES_VAL
                               );
                pWinsCnf->MaxNoOfRetries = WINSCNF_DEF_CHL_MAX_RETRIES;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                    if (pWinsCnf->MaxNoOfRetries  <
                                   WINSCNF_MIN_CHL_MAX_RETRIES)
                    {
                       pWinsCnf->MaxNoOfRetries = WINSCNF_MIN_CHL_MAX_RETRIES;
                       WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_CHL_MAX_RETRIES_NM,
                             pWinsCnf->MaxNoOfRetries);
                    }
                }
                else
                {
                      if (pWinsCnf->MaxNoOfRetries < WINSCNF_MIN_CHL_MAX_RETRIES)
                      {
                          pWinsCnf->MaxNoOfRetries = WINSCNF_MIN_CHL_MAX_RETRIES;
                      }
                }
        }

        //
        // Read in the tombstone Interval
        //
        Sz = sizeof(pWinsCnf->TombstoneInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_TOMBSTONE_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->TombstoneInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_TOMBSTONE_INTERVAL_VAL
                               );

                pWinsCnf->TombstoneInterval =
                        WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval);
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                      if (pWinsCnf->TombstoneInterval <
                           WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval) )
                      {
                        pWinsCnf->TombstoneInterval =
                           WINSCNF_MAKE_TOMB_INTVL_0_M(pWinsCnf->RefreshInterval);

                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_INTVL_NM,
                             pWinsCnf->TombstoneInterval);
                     }
                }
                else
                {
                     if (pWinsCnf->TombstoneInterval < 60)
                     {
                        pWinsCnf->TombstoneInterval = 60;
                     }
                }

        }

        //
        // Read in the tombstone timeout
        //
        Sz = sizeof(pWinsCnf->TombstoneTimeout);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_TOMBSTONE_TMOUT_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->TombstoneTimeout,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_TOMBSTONE_TIMEOUT_VAL
                               );
                pWinsCnf->TombstoneTimeout = pWinsCnf->RefreshInterval;
        }
        else
        {
                if (!sfNoLimitChk)
                {
                  if (pWinsCnf->TombstoneTimeout < pWinsCnf->RefreshInterval)
                  {
                    pWinsCnf->TombstoneTimeout = pWinsCnf->RefreshInterval;
                    WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_TMOUT_NM,
                             pWinsCnf->TombstoneTimeout);
                  }
               }
               else
               {
                   if (pWinsCnf->TombstoneTimeout < 60)
                   {
                      pWinsCnf->TombstoneTimeout = 60;
                   }
               }
        }

        //
        // Read in the Verify Interval
        //
        Sz = sizeof(pWinsCnf->VerifyInterval);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_VERIFY_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->VerifyInterval,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_VERIFY_INTERVAL_VAL
                               );

                pWinsCnf->VerifyInterval =
                   WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval);
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                   if (pWinsCnf->VerifyInterval <
                       WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval))
                   {
                        pWinsCnf->VerifyInterval =
                           WINSCNF_MAKE_VERIFY_INTVL_M(pWinsCnf->TombstoneInterval);
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_VERIFY_INTVL_NM,
                             pWinsCnf->VerifyInterval);

                  }
               }
               else
               {
                   if (pWinsCnf->VerifyInterval < 60)
                   {
                         pWinsCnf->VerifyInterval = 60;
                   }
               }

        }

        ReadCCInfo(pWinsCnf);

        //
        // Check if the admin. wants us to do pull/push replications with
        // pnrs found by self.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_BURST_HANDLING_NM,
                        ValTyp,
                        pWinsCnf->fDoSpoofing,
                        0,
                        TRUE
                      );
       if (pWinsCnf->fDoSpoofing)
       {
          pWinsCnf->fDoSpoofing = TRUE;  //for robustness
       }

#if MCAST > 0
        //
        // Check if the admin. wants us to do pull/push replications with
        // pnrs found by self.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_USE_SELF_FND_PNRS_NM,
                        ValTyp,
                        pWinsCnf->fUseSelfFndPnrs,
                        0,
                        FALSE
                      );

        if (pWinsCnf->fUseSelfFndPnrs)
        {
                 if (WinsCnf.State_e == WINSCNF_E_INITING)
                 {
                        Sz = sizeof(pWinsCnf->McastTtl);
                        RetVal = RegQueryValueEx(
                                            sParametersKey,
                                            WINSCNF_MCAST_TTL_NM,
                                            NULL,
                                            &ValTyp,
                                            (LPBYTE)&pWinsCnf->McastTtl,
                                             &Sz
                                         );

                        if (RetVal != ERROR_SUCCESS)
                        {
                            pWinsCnf->McastTtl = WINSCNF_DEF_MCAST_TTL;
                        }
                        else
                        {
                           if (
                             (pWinsCnf->McastTtl < WINSCNF_MIN_MCAST_TTL)
                                          ||
                             (pWinsCnf->McastTtl > WINSCNF_MAX_MCAST_TTL)
                               )
                           {
                             pWinsCnf->McastTtl = WINSCNF_DEF_MCAST_TTL;
                           }
                        }
                 }

                 Sz = sizeof(pWinsCnf->McastIntvl);
                 RetVal = RegQueryValueEx(
                                            sParametersKey,
                                            WINSCNF_MCAST_INTVL_NM,
                                            NULL,
                                            &ValTyp,
                                            (LPBYTE)&pWinsCnf->McastIntvl,
                                             &Sz
                                        );

                 if (RetVal != ERROR_SUCCESS)
                 {
                        pWinsCnf->McastIntvl = WINSCNF_DEF_MCAST_INTVL;
                 }
                 else
                 {
                        if ( pWinsCnf->McastIntvl < WINSCNF_MIN_MCAST_INTVL )
                        {
                               pWinsCnf->McastIntvl = WINSCNF_MIN_MCAST_INTVL;
                        }
                 }
         }
#endif
        //
        // Check if replication is to be done only with configured partners.
        // If set to TRUE, it means that an administrator will not be allowed
        // to trigger replication to/from a WINS that this WINS does not know
        // about.  Default value is FALSE
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_RPL_ONLY_W_CNF_PNRS_NM,
                        ValTyp,
                        pWinsCnf->fRplOnlyWCnfPnrs,
                        0,
                        TRUE
                      );
        //
        // Robust programming (in case the registry has a value other than 1
        // and later on we compare the value with TRUE)
        //
        if (pWinsCnf->fRplOnlyWCnfPnrs != FALSE)
        {
                pWinsCnf->fRplOnlyWCnfPnrs = TRUE;
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {

           (VOID)WinsMscAlloc(WINS_MAX_FILENAME_SZ, &(pWinsCnf->pWinsDb));
           //
           // Read in the name of the database file
           //
FUTURES("when jet supports UNICODE in its api, change this")
           Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
           RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_DB_FILE_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)DirPath,
                                &Sz
                                );

           if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
           {
               WinsMscDealloc(pWinsCnf->pWinsDb);
               pWinsCnf->pWinsDb = WINSCNF_DB_NAME_ASCII;
           }
           else
           {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                      WinsMscDealloc(pWinsCnf->pWinsDb);
                      pWinsCnf->pWinsDb = WINSCNF_DB_NAME_ASCII;
                 }
                 else
                 {
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pWinsDb, WINS_MAX_FILENAME_SZ);
                      DBGPRINT1(DET, "WinsCnfReadWinsInfo: Db file path is (%s)\n", pWinsCnf->pWinsDb);
                 }
           }

           RetVal = ReadClusterIp(
                        sParametersKey,
                        &WinsClusterIpAddress
                        );
           if (ERROR_SUCCESS == RetVal) {
               NmsLocalAdd.Add.IPAdd = WinsClusterIpAddress;
           } else {
               DBGPRINT1(DET, "ReadClusterIp: Returned (%ld)\n", RetVal);
           }
        }

        //
        // Read in the PriorityClassHigh value.  Default is normal
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_PRIORITY_CLASS_HIGH_NM,
                        ValTyp,
                        pWinsCnf->WinsPriorityClass,
                        0,
                        WINSINTF_E_NORMAL
                      );

        if (pWinsCnf->WinsPriorityClass != WINSINTF_E_NORMAL)
        {
             if (WinsCnf.WinsPriorityClass != WINSINTF_E_HIGH)
             {
                  WinsSetPriorityClass(WINSINTF_E_HIGH);
             }
        }
        else
        {
             if (WinsCnf.WinsPriorityClass != WINSINTF_E_NORMAL)
             {
                  WinsSetPriorityClass(WINSINTF_E_NORMAL);
             }
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
          //
          // Read in the InitTimeState value.  Default is FALSE
          //
          QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_INIT_TIME_PAUSE_NM,
                        ValTyp,
                        fWinsCnfInitStatePaused,
                        0,
                        FALSE
                      );

        //
        // Read in the name of the recovery file
        //
        (VOID)WinsMscAlloc(WINS_MAX_FILENAME_SZ, &(pWinsCnf->pLogFilePath));
        Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
        RetVal = RegQueryValueEx(
                        sParametersKey,
                        WINSCNF_LOG_FILE_PATH_NM,
                        NULL,          //reserved; must be NULL
                        &ValTyp,
                        (LPBYTE)DirPath,
                        &Sz
                                );

        if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
        {
                DBGPRINT1(ERR, "WinsCnfReadInfo: RetVal=(%x)\n", RetVal);
                WinsMscDealloc(pWinsCnf->pLogFilePath);
                pWinsCnf->pLogFilePath = DEFAULT_LOG_PATH;
        }
        else
        {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                DBGPRINT0(ERR, "WinsCnfReadInfo:WinsMscGetName returned FALSE\n");
                    WinsMscDealloc(pWinsCnf->pLogFilePath);
                    pWinsCnf->pLogFilePath = DEFAULT_LOG_PATH;
                 }
                 else
                 {
                DBGPRINT1(DET, "WinsCnfReadInfo:pHoldFileName=%s\n", pHoldFileName);
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pLogFilePath, WINS_MAX_FILENAME_SZ);

                 }
        }

        //
        // Check if user wants logging to be turned on.
        // In case of Q servers, the user would not wish the logging to be
        // turned on
        //
        Sz = sizeof(pWinsCnf->fLoggingOn);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_LOG_FLAG_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fLoggingOn,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                //
                // default is to turn on logging
                //
                pWinsCnf->fLoggingOn = TRUE;
        }
        else
        {
                //
                // If user has specified logging, get the path to the log
                // file if specified by user
                //
                if (pWinsCnf->fLoggingOn)
                {
                        pWinsCnf->fLoggingOn = TRUE;
                }
        }

       }
        //
        // Check to see if STATIC initialization of the WINS database needs
        // to be done
        //
        Sz = sizeof(pWinsCnf->fStaticInit);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_STATIC_INIT_FLAG_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fStaticInit,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fStaticInit = FALSE;
        }
        else
        {
                //
                // Safe programming (just in case a maintainer of this code
                // assumes a BOOL field to have just TRUE and FALSE values
                //
                pWinsCnf->fStaticInit = pWinsCnf->fStaticInit > 0 ? TRUE : FALSE;
        }

        //
        // If Static Initialization needs to be done, read in the name of
        // the file that contains the data.
        //
        if(pWinsCnf->fStaticInit)
        {
                WinsCnfGetNamesOfDataFiles(pWinsCnf);
        }


        //
        // Assign MaxVersNo with the default value
        //
        WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

        //
        // If the WINS server is just coming up (i.e. it is not a reinit),
        // then read in the starting value of the version number counter
        // if present in the registry
        //
        Sz = sizeof(DWORD);
        (VOID)RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_VERSNO_VAL_LW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.LowPart,
                                &Sz
                                );

        (VOID)RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_INIT_VERSNO_VAL_HW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.HighPart,
                                &Sz
                                );

        //
        // if we read in a value for the version counter
        //
        if (LiGtrZero(MaxVersNo) && (MaxVersNo.HighPart == 0) &&
                             (MaxVersNo.LowPart < MAX_START_VERS_NO))
        {
          //
          // Use WinsCnf, not pWinsCnf since at initialization time, we always
          // read into WinsCnf. At reinit, the State_e field in the WinsCnf
          // structure allocated may have garbage (actually will be 0 since we
          // initialize allocated memory to zero -- I might change in the
          // future to improve performance)
          //
          if (WinsCnf.State_e == WINSCNF_E_INITING)
          {
            //
            // Min. Vers. to start scavenging from.
            //
            //  NOTE: if we find local records or the special record then
            //  NmsScvMinScvVersNo will get changed (check out GetMaxVersNos
            //  in nmsdb.c
            //
            NmsNmhMyMaxVersNo  = MaxVersNo;
            NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
            NmsVersNoToStartFromNextTime.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);

            NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
          }
          else  // this must be a reconfiguration
          {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // change the value of the version counter if
                // the new value is more than it.
                //
                if (LiGtr(MaxVersNo, NmsNmhMyMaxVersNo))
                {
                        NmsNmhMyMaxVersNo = MaxVersNo;
                        WINSEVT_LOG_INFO_M(MaxVersNo.LowPart,
                                WINS_EVT_VERS_COUNTER_CHANGED);
                }
                NmsVersNoToStartFromNextTime.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
                NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
          }
        }

        if (WinsCnf.State_e == WINSCNF_E_INITING)
        {
           //
           // Check if a port has been assigned by the user.
           //
           QUERY_VALUE_M(
                                sParametersKey,
                                WINSCNF_WINS_PORT_NO_NM,
                                ValTyp,
                                CommWinsTcpPortNo,
                                0,
                                COMM_DEFAULT_IP_PORT
                             );
           DBGPRINT1(DET, "WinsCnfReadWinsInfo: Port No is (%d)\n", CommWinsTcpPortNo);

          //
          // Check if WINS should continue replication in case of an
          // error in replication.
          //
          QUERY_VALUE_M(
                                sParametersKey,
                                WINSCNF_NO_RPL_ON_ERR_NM,
                                ValTyp,
                                WinsCnf.fNoRplOnErr,
                                0,
                                TRUE
                             );


          //
          // Assign MaxVersNo with the default value
          //
          WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

          //
          // Read in the value specified in the registry for the version
          // number that we should use when starting.
          //
          Sz = sizeof(DWORD);
          (VOID)RegQueryValueEx(
                                sConfigRoot,
                                WINSCNF_INT_VERSNO_NEXTTIME_LW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.LowPart,
                                &Sz
                                );

          (VOID)RegQueryValueEx(
                                sConfigRoot,
                                WINSCNF_INT_VERSNO_NEXTTIME_HW_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&MaxVersNo.HighPart,
                                &Sz
                                );

          //
          // if we read in a value for the version counter and it is greater
          // than the high-water mark currently there
          //
          if (LiGtr(MaxVersNo, NmsHighWaterMarkVersNo))
          {
               fWinsCnfReadNextTimeVersNo = TRUE;

               //
               // Use WinsCnf, not pWinsCnf since at initialization time,
               // we always read into WinsCnf. At reinit, the State_e field
               // in the WinsCnf structure allocated may have garbage
               // (actually will be 0 since we initialize allocated memory
               // to zero -- I might change in the future to improve
               // performance)
               //

               //
               // Min. Vers. to start scavenging from.
               //
               //  NOTE: if we find local records or the special record then
               //  NmsScvMinScvVersNo will get changed (check out GetMaxVersNos
               //  in nmsdb.c
               //
               if (LiLtr(NmsNmhMyMaxVersNo, MaxVersNo))
               {
                   NmsNmhMyMaxVersNo  = MaxVersNo;
                   NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
               }
               NmsVersNoToStartFromNextTime.QuadPart =
                       LiAdd(NmsNmhMyMaxVersNo,  NmsRangeSize);
               NmsHighWaterMarkVersNo.QuadPart =
                        LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);
         }
       }  //end of if state is INITING

        //
        // Check to see if a backup directory has been specified for the WINS
        // database
        //
        //
        // Read in the name of the recovery file
        //
        Sz = WINS_MAX_FILENAME_SZ * sizeof(TCHAR);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_BACKUP_DIR_PATH_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)DirPath,
                                &Sz
                                );

        if ((RetVal != ERROR_SUCCESS) || (DirPath[0] == (TCHAR)EOS))
        {
                pWinsCnf->pBackupDirPath = NULL;
        }
        else
        {
                 if(!WinsMscGetName(ValTyp, DirPath, Path2, WINS_MAX_FILENAME_SZ, &pHoldFileName))
                 {
                    pWinsCnf->pBackupDirPath = NULL;
                 }
                 else
                 {
                      WinsMscAlloc(Sz + sizeof(WINS_BACKUP_DIR_ASCII), &pWinsCnf->pBackupDirPath);
FUTURES("When Jet starts taking UNICODE input, get rid of this")
                      WinsMscConvertUnicodeStringToAscii((LPBYTE)pHoldFileName, pWinsCnf->pBackupDirPath, WINS_MAX_FILENAME_SZ);
                      strcat(pWinsCnf->pBackupDirPath, WINS_BACKUP_DIR_ASCII);

                      //
                      // No need to look at the return code.
                      //
                      CreateDirectoryA(pWinsCnf->pBackupDirPath, NULL);

                 }

        }

        //
        // Check to see if the admin. has told WINS to do a backup on
        // termination
        //
        Sz = sizeof(pWinsCnf->fDoBackupOnTerm);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_DO_BACKUP_ON_TERM_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fDoBackupOnTerm,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fDoBackupOnTerm = FALSE;
        }

        //
        // Check to see if static records have to be treated as p-static
        //
        Sz = sizeof(pWinsCnf->fPStatic);
        RetVal = RegQueryValueEx(
                                sParametersKey,
                                WINSCNF_MIGRATION_ON_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->fPStatic,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                pWinsCnf->fPStatic = FALSE;
        }

        //
        // Read max wins registration que len.
        //
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_BURST_QUE_SIZE_NM,
                        ValTyp,
                        QueOtherNbtWrkQueMaxLen,
                        0,
                        WINS_QUEUE_HWM
                      );

        if (QueOtherNbtWrkQueMaxLen < WINS_QUEUE_HWM_MIN) {
            QueOtherNbtWrkQueMaxLen = WINS_QUEUE_HWM_MIN;
        } else if (QueOtherNbtWrkQueMaxLen > WINS_QUEUE_HWM_MAX) {
            QueOtherNbtWrkQueMaxLen = WINS_QUEUE_HWM_MAX;
        }

        // Read whether or not we randomize 1c list retrieval.
        QUERY_VALUE_M(
                        sParametersKey,
                        WINSCNF_RANDOMIZE_1C_LIST_NM,
                        ValTyp,
                        WinsCnf.fRandomize1CList,
                        0,
                        FALSE
                      );

} // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfReadWinsInfo");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SFT_ERR);
        }
        return;
}

VOID
ReadCCInfo(
 PWINSCNF_CNF_T  pWinsCnf
)

/*++

Routine Description:
         Function to read in CC info

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

        SYSTEMTIME CurrTime;
        DWORD           Sz;
        LONG            RetVal;
        DWORD           ValTyp;
        VERS_NO_T       MaxVersNo;
        WINSEVT_STRS_T  EvtStr;

        DBGENTER("ReadCCInfo\n");

        //
        // Open the Consistency Chk Key
        //

        RetVal =   RegOpenKeyEx(
                        sConfigRoot,           //predefined key value
                        _WINS_CFG_CC_KEY,
                        0,                     //must be zero (reserved)
                        KEY_READ | KEY_WRITE,  //we desire read/write access
                                               // to the key
                        &sCCKey                //handle to key
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_CC_KEY
                                   );
                pWinsCnf->CC.TimeInt = MAXULONG;
                return;
        }

        Sz = sizeof(pWinsCnf->CC.TimeInt);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_INTVL_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.TimeInt,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_INTERVAL_VAL
                               );

                pWinsCnf->CC.TimeInt = WINSCNF_CC_DEF_INTERVAL;
        }
        else
        {

                if ( !sfNoLimitChk)
                {
                   if (pWinsCnf->CC.TimeInt <  WINSCNF_CC_MIN_INTERVAL)
                   {
                        pWinsCnf->CC.TimeInt = WINSCNF_CC_MIN_INTERVAL;
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL,
                             NULL, __LINE__, "ud",
                             WINSCNF_CC_INTVL_NM,
                             pWinsCnf->CC.TimeInt);

                  }
               }
               else
               {
                   if (pWinsCnf->CC.TimeInt < 60)
                   {
                         pWinsCnf->CC.TimeInt = 60;
                   }
               }

        }

        Sz = sizeof(pWinsCnf->CC.MaxRecsAAT);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_MAX_RECS_AAT_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.MaxRecsAAT,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_MAX_RECS_AAT_VAL
                               );

                pWinsCnf->CC.MaxRecsAAT = WINSCNF_CC_DEF_RECS_AAT;
        }
        else
        {
                if (pWinsCnf->CC.MaxRecsAAT <  WINSCNF_CC_MIN_RECS_AAT)
                {
                   if ( !sfNoLimitChk)
                   {
                        WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_MAX_RECS_AAT,
                             NULL, __LINE__, "udd",
                             WINSCNF_CC_MAX_RECS_AAT_NM,
                             WINSCNF_CC_MIN_RECS_AAT,
                             pWinsCnf->CC.MaxRecsAAT);
                        pWinsCnf->CC.MaxRecsAAT = WINSCNF_CC_MIN_RECS_AAT;
                   }
                   else
                   {
                      if (pWinsCnf->CC.MaxRecsAAT < 2)
                      {
                        pWinsCnf->CC.MaxRecsAAT = 2;
                      }

                   }

               }
        }

        Sz = sizeof(pWinsCnf->CC.fUseRplPnrs);
        RetVal = RegQueryValueEx(
                                sCCKey,
                                WINSCNF_CC_USE_RPL_PNRS_NM,
                                NULL,                //reserved; must be NULL
                                &ValTyp,
                                (LPBYTE)&pWinsCnf->CC.fUseRplPnrs,
                                &Sz
                                );

        if (RetVal != ERROR_SUCCESS)
        {
                WINSEVT_LOG_INFO_D_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_GET_CC_USE_RPL_PNRS_VAL
                               );

                pWinsCnf->CC.fUseRplPnrs = WINSCNF_CC_DEF_USE_RPL_PNRS;
        }

        GetLocalTime(&CurrTime);
        GetSpTimeData(sCCKey, &CurrTime, &pWinsCnf->CC.fSpTime, &pWinsCnf->CC.SpTimeInt);
        REG_M(
                     RegCloseKey(sCCKey),
                     WINS_EVT_CANT_CLOSE_KEY,
                     WINS_EXC_CANT_CLOSE_KEY
                );
        DBGLEAVE("ReadCCInfo\n");
        return;
}
#if USENETBT > 0
//------------------------------------------------------------------------
STATUS
WinsCnfReadNbtDeviceName(
        VOID
    )

/*++

Routine Description:

    This procedure reads the registry to get the name of NBT to bind to.
    That name is stored in the Linkage section under the Netbt key.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    PTCHAR  SubKeyLinkage=NETBT_LINKAGE_KEY;
    HKEY    Key;
    PTCHAR  pLinkage=TEXT("Export");
    LONG    Type;
    LONG    Status;
    LONG    Status2;
    ULONG   Size;

    //
    // Open the NETBT key
    //
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 SubKeyLinkage,
                 0,
                 KEY_READ,
                 &Key);

    if (Status == ERROR_SUCCESS)
    {
        //
        // now read the linkage values
        //
        Status = RegQueryValueEx(Key,
                                 pLinkage,
                                 NULL,
                                 &Type,
                                 NULL,
                                 &Size);
        if (Status != ERROR_SUCCESS)
        {
            DBGPRINT0(ERR, "Error closing the Registry key\n");
            WINSEVT_LOG_M(Status, WINS_EVT_QUERY_NETBT_KEY_ERR);
            (VOID)RegCloseKey(Key);
            return(WINS_FAILURE);
        }
        else
        {
           //
           // Let us allocate a buffer that is big enough to hold all the
           // data
           //
           WinsMscAlloc(Size, (LPVOID *)&pWinsCnfNbtPath);

           //
           // now read the linkage values
           //
           Status = RegQueryValueEx(Key,
                                 pLinkage,
                                 NULL,
                                 &Type,
                                 (LPBYTE)pWinsCnfNbtPath,
                                 &Size);
           Status2 = RegCloseKey(Key);
           if ((Status != ERROR_SUCCESS) || (Status2 != ERROR_SUCCESS))
           {
              DBGPRINT0(ERR, "Error closing the Registry key\n");
              WINSEVT_LOG_M(Status, WINS_EVT_QUERY_NETBT_KEY_ERR);
              return(WINS_FAILURE);
           }
        }
    }
    else
    {
        WINSEVT_LOG_D_M(Status, WINS_EVT_OPEN_NETBT_KEY_ERR);
        return(WINS_FAILURE);
    }

    return(WINS_SUCCESS);
}
#endif

VOID
WinsCnfReadRegInfo(
  PWINSCNF_CNF_T        pWinsCnf
 )

/*++

Routine Description:
        This function is called to read the registry in order to populate the
        WinsCnf structure

Arguments:
        None

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        WinsCnfInitConfig
Side Effects:

Comments:
        None
--*/

{

try {
   if (sfParametersKeyExists)
   {
           /*
                Read in the  registry information pertaining to WINS
           */
           WinsCnfReadWinsInfo(pWinsCnf);
   }

   if (sfPartnersKeyExists)
   {
           //
           // Read the PUSH/PULL records and other global information used for
           // replication
           //
           WinsCnfReadPartnerInfo(pWinsCnf);
   }

   //
   // Do a sanity check on the params. We are not interested in the
   // return code
   //
   (VOID)SanityChkParam(pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("WinsCnfReadRegInfo");

       //
       // If we encountered an exception at boot time, we do not want to
       // reraise the exception, since we want to come up and continue on
       // For the non-initing case, the exception that we raise will be caught
       // in Reinit(). For the boot time case, it is ok to come up with the
       // defaults (an event message is being logged) - in WinsCnf.
       // In the non-init case, the defaults are not in the memory used to
       // read in the parameters (WinsCnf is initialized with stuff in
       // this memory block later).
       //
       if (WinsCnf.State_e != WINSCNF_E_INITING)
       {
             WINS_RERAISE_EXC_M();
       }
       WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
     }

   return;
}


VOID
WinsCnfCopyWinsCnf(
                WINS_CLIENT_E        Client_e,
                PWINSCNF_CNF_T  pSrc
        )

/*++

Routine Description:
        This function is called to copy relevant information from a WINS
        Cnf structure to the master (external) Wins Cnf structure

Arguments:
        pSrc - WinsCnf stucture to copy from

Externals Used:
        WinsCnf


Return Value:

        None
Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        This function may be enhanced in the future

        Note: this function is called only by the main thread
--*/
{

        BOOL fScvParamChg = FALSE;

        if (Client_e == WINS_E_WINSCNF)
        {

FUTURES("Queue a message to the Scavenger thread passing it pSrc")
FUTURES("That will avoid this synchronization overhead")

                //
                // We need to synchronize with the scavenger thread and
                // RPC threads that might be looking at fRplOnlyWCnfPnrs
                //
                EnterCriticalSection(&WinsCnfCnfCrtSec);

                //
                // Also need to synchronize with the nbt threads doing
                // name registrations/refreshes
                //
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Sanity check the parameters
                //
                fScvParamChg = SanityChkParam(pSrc);

                if (fScvParamChg)
                {
                  //
                  // Initialize the scavenging stuff.
                  //
                  WinsCnf.RefreshInterval   = pSrc->RefreshInterval;
                  WinsCnf.TombstoneInterval = pSrc->TombstoneInterval;
                  WinsCnf.TombstoneTimeout  = pSrc->TombstoneTimeout;
                  WinsCnf.CC                = pSrc->CC;
                  WinsCnf.ScvThdPriorityLvl = pSrc->ScvThdPriorityLvl;
                }

                //
                // Store the verify interval since SanityChkParam does
                // not set fScvParamChg if VerifyINterval has changed.
                //
                WinsCnf.VerifyInterval = pSrc->VerifyInterval;

                WinsCnf.fRplOnlyWCnfPnrs     = pSrc->fRplOnlyWCnfPnrs;
                WinsCnf.LogDetailedEvts      = pSrc->LogDetailedEvts;
                WinsCnf.fAdd1Bto1CQueries    = pSrc->fAdd1Bto1CQueries;
                WinsCnf.fPStatic             = pSrc->fPStatic;

                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                WinsCnf.fDoSpoofing           = pSrc->fDoSpoofing;
                WinsCnf.MaxNoOfWrkThds       = pSrc->MaxNoOfWrkThds;

                WinsCnf.fDoBackupOnTerm      = pSrc->fDoBackupOnTerm;
#if MCAST > 0
                WinsCnf.fUseSelfFndPnrs      = pSrc->fUseSelfFndPnrs;
                WinsCnf.McastIntvl           = pSrc->McastIntvl;
#endif

#if PRSCONN
                WinsCnf.fPrsConn             = pSrc->fPrsConn;
#endif
                if (WinsCnf.fDoBackupOnTerm && pSrc->pBackupDirPath != NULL)
                {
                        if (WinsCnf.pBackupDirPath != NULL)
                        {
                                WinsMscDealloc(WinsCnf.pBackupDirPath);
                        }
                        WinsCnf.pBackupDirPath = pSrc->pBackupDirPath;
                }

                LeaveCriticalSection(&WinsCnfCnfCrtSec);
        //        return;

        }
        else
        {
          if (Client_e == WINS_E_RPLPULL)
          {

                EnterCriticalSection(&WinsCnfCnfCrtSec);
                //
                // Copy the Scavenging parameters into the cnf structure
                // just allocated so that we can compare them for
                // compatibility with the new max. replication time interval
                // (since the Partners key was signaled, the replication
                 // stuff might have changed)
                //
                pSrc->RefreshInterval   = WinsCnf.RefreshInterval;
                pSrc->TombstoneInterval = WinsCnf.TombstoneInterval;
                pSrc->TombstoneTimeout  = WinsCnf.TombstoneTimeout;
                pSrc->VerifyInterval    = WinsCnf.VerifyInterval;

                //
                // Wasteful here and in SanityChkParam
                //
PERF("Pass an argument to SanityChk so that we don't have to do this")
PERF("See similar remark in SanityChk")
                pSrc->CC                = WinsCnf.CC;

                //
                // Sanity check the parameters.
                //
                // Sanity checking of the parameters is done here in
                // the main thread instead of in the PULL thread because
                // we don't want a situation where two different threads
                // (the main thread for changes to the PARAMETERS key)
                // and the PULL thread (for changes in the PARTNERS key)
                // updating the WinsCnf structure
                //
                // Also, as an aside, we don't copy the PullInfo information
                // into WinsCnf here to avoid unnecessary complication and
                // synchronization that would ensue by the fact that we
                // would then have two threads (main thread) and the PULL
                // thread accessing that field (check Reconfig() in
                // rplpull.c).
                //
FUTURES("When we start supporting time interval as an attribute of PUSHing")
FUTURES("move this check inside the NmsNmhNamRegCrtSec below")
                fScvParamChg = SanityChkParam(pSrc);

                //
                // If one or more scavenging parameters have  changed,
                // update WinsCnf and signal the Scavenger thread.
                //
                if (fScvParamChg)
                {
                        WinsCnf.RefreshInterval   = pSrc->RefreshInterval;
                        WinsCnf.TombstoneInterval = pSrc->TombstoneInterval;
                        WinsCnf.TombstoneTimeout  = pSrc->TombstoneTimeout;

                        //
                        // If SanityChkParam changed Tombstone interval, then
                        // verify interval has also changed.
                        //
                        WinsCnf.VerifyInterval = pSrc->VerifyInterval;

                }

                WinsCnf.MaxRplTimeInterval = pSrc->MaxRplTimeInterval;
                WinsCnf.RplType              = pSrc->RplType;
                LeaveCriticalSection(&WinsCnfCnfCrtSec);
          }
        }

        //
        // If the scavenging params have changed we need to signal
        // the scavenger thread
        //
        if (fScvParamChg)
        {
                WinsMscSignalHdl(WinsCnf.CnfChgEvtHdl);
        }
        return;
}


LPVOID
WinsCnfGetNextRplCnfRec(
         PRPL_CONFIG_REC_T        pCnfRec,
        RPL_REC_TRAVERSAL_E        RecTrv_e
        )

/*++

Routine Description:
        This function is called to get to the next configuration record

Arguments:
        pCnfRec - The current configuration record in a buffer of configuration
                  records
        RecTrv_e - indicates how the next one should be retrieved.  If set to
                  TRUE, it means that the next record to be retrieved is one
                  that follows the current record in the buffer.  If set to
                  FALSE, the next record is retrieved using the pNext field
                  of the current configuration record



Externals Used:
        None

Return Value:
        address of the next configuration record

Error Handling:

Called by:
        EstablishComm in rplpull.c, WinsPushTrigger() in wins.c

Side Effects:

Comments:
        None
--*/

{
        //
        // If no traversal is desired, return NULL as the next record
        //
        if (RecTrv_e == RPL_E_NO_TRAVERSAL)
        {
                return(NULL);
        }
        //
        //  Go to the next configuration record in a way specified
        //  by the  value of the RecTrv_e flag.
        //
        if(RecTrv_e == RPL_E_IN_SEQ)
        {
                pCnfRec = (PRPL_CONFIG_REC_T)(
                                 (LPBYTE)pCnfRec + RPL_CONFIG_REC_SIZE);
        }
        else  // RPL_E_VIA_LINK
        {
                return(pCnfRec->pNext);
        }
        return(pCnfRec);
}


VOID
WinsCnfAskToBeNotified(
         WINSCNF_KEY_E        KeyToMonitor_e
        )

/*++

Routine Description:
        This function is called to request that WINS be notified when
        the information pertaining to WINS and its subkeys in the registry
        changes

Arguments:

        KeyToMonitor_e

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        Reinit() in nms.c
        WinsCnfOpenSubKeys()
        WinsCnfInitConfig()

Side Effects:

Comments:
        None
--*/

{
   DWORD  NotifyFilter = 0;
   LONG          RetVal;
   DWORD  Error;

#define  CHK_RET_VAL_M     {                                            \
                                if (RetVal != ERROR_SUCCESS)         \
                                   {                                     \
                                        DBGPRINT1(ERR, "WinsAskToBeNotified: Error = (%d)\n", RetVal);                                                \
                                        WINSEVT_LOG_M(                      \
                                                 WINS_FATAL_ERR,              \
                                                 WINS_EVT_REG_NTFY_FN_ERR \
                                                      );             \
                                   }                                    \
                           }

   /*
    *  Set the notify filter.  Ask to be notified for all changes.
    */
   NotifyFilter = REG_NOTIFY_CHANGE_NAME       |
                  REG_NOTIFY_CHANGE_ATTRIBUTES |
                  REG_NOTIFY_CHANGE_LAST_SET  |
                  REG_NOTIFY_CHANGE_SECURITY ;


   switch(KeyToMonitor_e)
   {
        case(WINSCNF_E_WINS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: WINS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sConfigRoot,
                            TRUE,        //report changes in key and all subkeys
                            REG_NOTIFY_CHANGE_NAME,
                            WinsCnf.WinsKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                break;
        case(WINSCNF_E_PARAMETERS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: PARAMETERS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sParametersKey,
                            TRUE,        //report changes in key and all subkeys
                            NotifyFilter,
                            WinsCnf.ParametersKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                break;

        case(WINSCNF_E_PARTNERS_KEY):

//                DBGPRINT0(SPEC, "WinsCnfAskToBeNotified: PARTNERS Key\n");
                   RetVal = RegNotifyChangeKeyValue(
                            sPartnersKey,
                            TRUE,        //report changes in key and all subkeys
                            NotifyFilter,
                            WinsCnf.PartnersKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );

                CHK_RET_VAL_M;
                break;

FUTURES("Remove the following case")
        //
        // The following case would never get exercised.
        //
        case(WINSCNF_E_ALL_KEYS):

                   RetVal = RegNotifyChangeKeyValue(
                            sConfigRoot,
                            TRUE,        //report changes in key and all subkeys
                            REG_NOTIFY_CHANGE_NAME,
                            WinsCnf.WinsKChgEvtHdl,
                            TRUE         //Async signaling is what we want
                           );
                CHK_RET_VAL_M;
                if (sfParametersKeyExists)
                {
                           RetVal = RegNotifyChangeKeyValue(
                                            sParametersKey,
                                            TRUE,        //report changes in key and
                                                //all subkeys
                                            NotifyFilter,
                                            WinsCnf.ParametersKChgEvtHdl,
                                            TRUE         //Async signaling is what we
                                                 // want
                                                           );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                Error = GetLastError();
                                if (Error == ERROR_BADKEY)
                                {
                                        //
                                        // Key must not be there
                                        //
                                        sfParametersKeyExists = FALSE;
                                }
                                else
                                {
                                        DBGPRINT1(ERR,
        "WinsCnfAskToBeNotified: RegNotifyChangeKeyValue error = (%d)\n",
                                                 Error);

                                }
                        }
                }
                if (sfPartnersKeyExists)
                {
                           RetVal = RegNotifyChangeKeyValue(
                                            sPartnersKey,
                                            TRUE,        //report changes in key and
                                                //all subkeys
                                            NotifyFilter,
                                            WinsCnf.PartnersKChgEvtHdl,
                                            TRUE         //Async signaling is what we
                                                 //want
                                                           );
                        if (RetVal != ERROR_SUCCESS)
                        {
                                Error = GetLastError();
                                if (Error == ERROR_BADKEY)
                                {
                                        //
                                        // Key must not be there
                                        //
                                        sfPartnersKeyExists =  FALSE;
                                }
                                else
                                {
                                        DBGPRINT1(ERR,
        "WinsCnfAskToBeNotified: RegNotifyChangeKeyValue error = (%d)\n",
                                                 Error);

                                }
                        }
                }
                        break;
        default:

                DBGPRINT1(ERR, "WinsCnfAskToBeNotified: Wrong Hdl (%d)\n",
                                KeyToMonitor_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                break;
        }


            return;
}

VOID
WinsCnfDeallocCnfMem(
  PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function is called to deallocate the Wins Cnf structure and
        memory associated with it

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        Reconfig in rplpull.c

Side Effects:

Comments:
        None
--*/

{
try {
        //
        // Deallocate the buffer holding one or more names of files used
        // for STATIC initialization of WINS
        //
        if (pWinsCnf->pStaticDataFile != NULL)
        {
                WinsMscDealloc(pWinsCnf->pStaticDataFile);
        }
        WinsMscDealloc(pWinsCnf);
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsCnfDeallocCnfMem");
        DBGPRINT0(EXC, "WinsCnfDeallocCnfMem: Got an exception\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
        }

        return;
}

VOID
GetKeyInfo(
        IN  HKEY                   Key,
        IN  WINSCNF_KEY_E        KeyType_e,
        OUT LPDWORD                  pNoOfSubKeys,
        OUT LPDWORD                pNoOfVals
        )

/*++

Routine Description:
        This function is called to get the number of subkeys under a key

Arguments:
        Key         - Key whose subkey count has to be determined
        KeyType_e
        pNoOfSubKeys

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        GetPnrInfo()

Side Effects:

Comments:
        None
--*/

{
          TCHAR    ClsStr[40];
          DWORD    ClsStrSz = sizeof(ClsStr);
          DWORD    LongestKeyLen;
          DWORD    LongestKeyClassLen;
          DWORD    LongestValueNameLen;
          DWORD    LongestValueDataLen;
          DWORD    SecDesc;
        LONG         RetVal;

          FILETIME LastWrite;
          /*
                Query the key.  The subkeys are IP addresses of PULL
                partners.
          */
          RetVal = RegQueryInfoKey(
                        Key,
                        ClsStr,
                        &ClsStrSz,
                        NULL,                        //must be NULL, reserved
                        pNoOfSubKeys,
                        &LongestKeyLen,
                        &LongestKeyClassLen,
                        pNoOfVals,
                        &LongestValueNameLen,
                        &LongestValueDataLen,
                        &SecDesc,
                        &LastWrite
                                );

          if (RetVal != ERROR_SUCCESS)
          {
                WINSEVT_LOG_M(
                        WINS_FATAL_ERR,
                        KeyType_e == WINSCNF_E_DATAFILES_KEY ?
                                WINS_EVT_CANT_QUERY_DATAFILES_KEY :
                                ((KeyType_e == WINSCNF_E_PULL_KEY) ?
                                        WINS_EVT_CANT_QUERY_PULL_KEY :
                                        ((KeyType_e == WINSCNF_E_PUSH_KEY) ?
                                        WINS_EVT_CANT_QUERY_PUSH_KEY :
                                        WINS_EVT_CANT_QUERY_SPEC_GRP_MASKS_KEY))
                             );
                WINS_RAISE_EXC_M(WINS_EXC_CANT_QUERY_KEY);
        }
        return;
}
VOID
WinsCnfOpenSubKeys(
        VOID
        )

/*++

Routine Description:
        This function opens the subkeys of the WINS key.  The subkeys are
        the PARTNERS key and the PARAMETERS key.
Arguments:
        None

Externals Used:
        sfParamatersKeyExists
        sfPartnersKeyExists

Return Value:
        None

Error Handling:

Called by:

        WinsCnfInitConfig()

Side Effects:

Comments:
        None
--*/

{

   LONG  RetVal;

   //
   // Check if the Parameters and Partners Keys are present
   //
   ChkWinsSubKeys();

   //
   // Try to open the Parameters key if it exists
   //
   if ((sfParametersKeyExists) && (!sfParametersKeyOpen))
   {
           /*
           *  Open the Parameters key
           */
           RetVal =   RegOpenKeyEx(
                        sConfigRoot,                //predefined key value
                        _WINS_CFG_PARAMETERS_KEY,
                        0,                        //must be zero (reserved)
                        KEY_READ | KEY_WRITE,        //we desire read/write access
                                                // to the key
                        &sParametersKey                //handle to key
                                );

           if (RetVal != ERROR_SUCCESS)
           {
CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_PARAMETERS_KEY
                                   );
                sfParametersKeyExists = FALSE;
           }
           else
           {
                sfParametersKeyOpen = TRUE;
                WinsCnfAskToBeNotified(WINSCNF_E_PARAMETERS_KEY);
           }
   }

   //
   // Try to open the Partners key if it exists
   //
   if ((sfPartnersKeyExists) && (!sfPartnersKeyOpen))
   {
           /*
           *  Open the Partners key
           */
           RetVal =   RegOpenKeyEx(
                                sConfigRoot,                //predefined key value
                                _WINS_CFG_PARTNERS_KEY,
                                0,                        //must be zero(reserved)
                                KEY_READ,                //we desire read
                                                        //access to the key
                                &sPartnersKey                //handle to key
                                );

           if (RetVal != ERROR_SUCCESS)
           {

CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_KEY
                         );
                sfPartnersKeyExists = FALSE;
           }
           else
           {
                sfPartnersKeyOpen = TRUE;
                WinsCnfAskToBeNotified(WINSCNF_E_PARTNERS_KEY);
           }
   }

   return;

}  //WinsCnfOpenSubKeys()

BOOL
SanityChkParam(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function  is called to ensure that the time intervals for
        scavenging specified in WinsCnf are compatible with the ones
        used for replication

Arguments:
        pWinsCnf - ptr to the WINS configuration

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsCnfCopyWinsCnf (during reinitialization of the WINS), by
        WinsCnfReadRegInfo() during initialization of the WINS
Side Effects:

        The scavenging intervals could be affected

Comments:
        This function must be called from inside the critical section
        guarded by WinsCnfCnfCrtSec except at process initialization.
--*/
{
        DWORD   MinTombInterval;
        BOOL        fScvParamChg = FALSE;
        WINSEVT_STRS_T  EvtStr;
        EvtStr.NoOfStrs = 1;

        DBGENTER("SanityChkParam\n");

        //
        // Get the minimum tombstone time interval
        //
        MinTombInterval = WINSCNF_MAKE_TOMB_INTVL_M(pWinsCnf->RefreshInterval,
                                           pWinsCnf->MaxRplTimeInterval);

        //
        // Make the actual equal to the min. if it is less
        //
        if (!sfNoLimitChk && (pWinsCnf->TombstoneInterval < MinTombInterval))
        {
                DBGPRINT2(FLOW, "SanityChkParam: Adjusting Tombstone Interval from (%d) to (%d)\n", pWinsCnf->TombstoneInterval, MinTombInterval);

FUTURES("This is actually a warning. Use a different macro or enhance it")
FUTURES("Currently, it will log this message as an informational")

                WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL_R,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_INTVL_NM,
                             MinTombInterval );

                pWinsCnf->TombstoneInterval = MinTombInterval;

                //
                // Verify Interval is dependent on the tombstone interval
                //
                pWinsCnf->VerifyInterval = WINSCNF_MAKE_VERIFY_INTVL_M(MinTombInterval);
                fScvParamChg = TRUE;
        }

        //
        // reusing the var. The time interval is for tombstone timeout
        //
        MinTombInterval =
                  WINSCNF_MAKE_TOMBTMOUT_INTVL_M(pWinsCnf->MaxRplTimeInterval);
        if (!sfNoLimitChk && (pWinsCnf->TombstoneTimeout <  MinTombInterval))
        {
                DBGPRINT2(FLOW, "SanityChkParam: Adjusting Tombstone Timeout from (%d) to (%d)\n", pWinsCnf->TombstoneInterval, MinTombInterval);

                pWinsCnf->TombstoneTimeout = MinTombInterval;
                WinsEvtLogDetEvt(TRUE, WINS_EVT_ADJ_TIME_INTVL_R,
                             NULL, __LINE__, "ud",
                             WINSCNF_TOMBSTONE_TMOUT_NM,
                             MinTombInterval );
                if (!fScvParamChg)
                {
                        fScvParamChg = TRUE;
                }

        }
        if (!fScvParamChg)
        {
PERF("Pass an argument to SanityChk so that we don't have to do this")
PERF("for CC for the case where we just read the partner info. See")
PERF("WinsCnfCopyWinsCnf for the case where client_e is WINS_E_RPLPULL")
                if (
                     (WinsCnf.RefreshInterval != pWinsCnf->RefreshInterval)
                                        ||
                     (WinsCnf.TombstoneInterval != pWinsCnf->TombstoneInterval)
                                        ||
                     (WinsCnf.TombstoneTimeout != pWinsCnf->TombstoneTimeout)
                                        ||
                     (WinsCnf.CC.TimeInt  != pWinsCnf->CC.TimeInt)
                                        ||
                     (WinsCnf.CC.SpTimeInt  != pWinsCnf->CC.SpTimeInt)
                                        ||
                     (WinsCnf.CC.fUseRplPnrs  != pWinsCnf->CC.fUseRplPnrs)
                                        ||
                     (WinsCnf.CC.MaxRecsAAT  != pWinsCnf->CC.MaxRecsAAT)
                   )
                {
                        fScvParamChg = TRUE;
                }
        }

        DBGLEAVE("SanityChkParam\n");
        return(fScvParamChg);
}
STATUS
WinsCnfGetNamesOfDataFiles(
        PWINSCNF_CNF_T        pWinsCnf
        )

/*++

Routine Description:
        This function gets the names of all the datafiles that need to
        be used for initializing WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        LONG             RetVal;
        HKEY             DFKey;
        DWORD            BuffSize;
        STATUS          RetStat = WINS_SUCCESS;
        PWINSCNF_DATAFILE_INFO_T            pSaveDef;
        DWORD          NoOfSubKeys;

        DBGENTER("WinsCnfGetNamesOfDataFiles\n");

        //
        // Store timestamp of initialization in the statistics structure
        //
        WinsIntfSetTime(NULL, WINSINTF_E_INIT_DB);

        //
        // Set up the default name
        //

        //
        // First allocate the buffer that will hold the default file name
        //
        WinsMscAlloc(WINSCNF_FILE_INFO_SZ, &pWinsCnf->pStaticDataFile);

        lstrcpy(pWinsCnf->pStaticDataFile->FileNm, WINSCNF_STATIC_DATA_NAME);

        //
        // The default name contains a %<string>% in it.  Therefore, specify
        // the type as EXPAND_SZ
        //
        pWinsCnf->pStaticDataFile->StrType = REG_EXPAND_SZ;
        pWinsCnf->NoOfDataFiles            = 1;

        pSaveDef = pWinsCnf->pStaticDataFile;  //save the address

           /*
           *  Open the DATAFILES key
           */
           RetVal =   RegOpenKeyEx(
                        sConfigRoot,                //predefined key value
                        _WINS_CFG_DATAFILES_KEY,
                        0,                //must be zero (reserved)
                        KEY_READ,        //we desire read access to the keyo
                        &DFKey                //handle to key
                );

           if (RetVal != ERROR_SUCCESS)
           {

CHECK("Is there any need to log this")
                WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                WINS_EVT_CANT_OPEN_DATAFILES_KEY
                                 );
                DBGLEAVE("WinsCnfGetNamesOfDataFiles\n");
                return(FALSE);
           }
        else
try {
        {
                //
                // Get the count of data files listed under the DATAFILES
                // key
                //
                GetKeyInfo(
                        DFKey,
                        WINSCNF_E_DATAFILES_KEY,
                        &NoOfSubKeys,                        //ignored
                        &pWinsCnf->NoOfDataFiles
                      );
        }
        if (pWinsCnf->NoOfDataFiles > 0)
        {

                DWORD                          Index;
                PWINSCNF_DATAFILE_INFO_T pTmp;
                TCHAR ValNmBuff[MAX_PATH];
                DWORD ValNmBuffSz = MAX_PATH;


                  //
                  // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                  //
                  BuffSize = WINSCNF_FILE_INFO_SZ * pWinsCnf->NoOfDataFiles;
                    WinsMscAlloc( BuffSize, &pWinsCnf->pStaticDataFile);

                   /*
                    *   Enumerate  the values
                     */
                     for(
                        Index = 0, pTmp = pWinsCnf->pStaticDataFile;
                        Index <  pWinsCnf->NoOfDataFiles;
                                // no third expression
                         )
                {
                        ValNmBuffSz = sizeof(ValNmBuff)/sizeof(TCHAR);  //init before
                                                          //every call
                        BuffSize  = sizeof(pWinsCnf->pStaticDataFile->FileNm);
                          RetVal = RegEnumValue(
                                    DFKey,
                                    Index,        //key
                                    ValNmBuff,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &pTmp->StrType,
                                    (LPBYTE)(pTmp->FileNm),//ptr to var. to
                                                           //hold name of
                                                           //datafile
                                    &BuffSize        //not looked at by us
                                            );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }
                        //
                        // if StrType is not REG_SZ or REG_EXPAND_SZ, go to
                        // the next  Value
                        //
                        if  (
                                (pTmp->StrType != REG_EXPAND_SZ)
                                        &&
                                   (pTmp->StrType != REG_SZ)
                                )
                        {
                                continue;
                        }

                        Index++;
                        pTmp = (PWINSCNF_DATAFILE_INFO_T)((LPBYTE)pTmp +
                                                WINSCNF_FILE_INFO_SZ);
                }

                //
                // If not even one valid name was retrieved, get rid of the
                // buffer
                //
                if (Index == 0)
                {
                        //
                        // Get rid of the buffer
                        //
                        WinsMscDealloc((LPBYTE)pWinsCnf->pStaticDataFile);

                        //
                        // We will use the default
                        //
                        pWinsCnf->pStaticDataFile = pSaveDef;
                }
                else
                {
                        //
                        // Get rid of the default name buffer
                        //
                        WinsMscDealloc((LPBYTE)pSaveDef);
                }

                pWinsCnf->NoOfDataFiles = Index;
        }
 } // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("WinsCnfGetNamesOfDataFiles");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                RetStat = WINS_FAILURE;
        }
         REG_M(
                RegCloseKey(DFKey),
                WINS_EVT_CANT_CLOSE_KEY,
                WINS_EXC_CANT_CLOSE_KEY
             );
        DBGLEAVE("WinsCnfGetNamesOfDataFiles\n");
        return(RetStat);
}



VOID
WinsCnfCloseKeys(
        VOID
        )

/*++

Routine Description:
        This function closes the the open keys.  The keys closed are
        the WINS key, the PARTNERS key, and the PARAMETERS key.
Arguments:
        None

Externals Used:
        sfParametersKeyExists
        sfPartnersKeyExists

Return Value:
        None

Error Handling:

Called by:
        Reinit()

Side Effects:

Comments:
        We don't look at the return code of RegCloseKey.  This is because
        we might call this function even with the key not being open (not
        the case currently).

--*/

{

   //
   // Close the PARAMETERS key if it  is open
   //
   if (sfParametersKeyOpen)
   {
           (VOID)RegCloseKey(sParametersKey);
   }

   //
   // Close the PARTNERS key if it is open
   //
   if (sfPartnersKeyOpen)
   {
           (VOID)RegCloseKey(sPartnersKey);
   }

#if 0
   //
   // NOTE NOTE NOTE: Build 436.  If we attempt to close a key that has been
   // deleted from the registry NT comes down
   //

   //
   // Close the WINS key
   //
   (VOID)RegCloseKey(sConfigRoot);
#endif

   return;
}  //WinsCnfCloseKeys()


VOID
ChkWinsSubKeys(
        VOID
        )

/*++

Routine Description:
        This function is called to check whether we have the PARTNERS
        and PARAMETERS sub-keys under the root subkey of WINS.

Arguments:
        None

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        Reinit() in nms.c

Side Effects:

Comments:
        None
--*/

{
        DWORD      NoOfSubKeys = 0;
          DWORD             KeyNameSz;
          TCHAR           KeyName[20];
          FILETIME   LastWrite;
        LONG           RetVal;
        BOOL           fParametersKey = FALSE;
        BOOL           fPartnersKey   = FALSE;

           /*
            *   Get each subkey's  name
           */
            RetVal = ERROR_SUCCESS;
            for(
                        ;
                RetVal == ERROR_SUCCESS;
                NoOfSubKeys++
            )
          {
                KeyNameSz = sizeof(KeyName)/sizeof(TCHAR);  //init before every call
                 RetVal = RegEnumKeyEx(
                                sConfigRoot,
                                NoOfSubKeys,        //key
                                KeyName,
                                &KeyNameSz,
                                NULL,                //reserved
                                NULL,                //don't need class name
                                NULL,                //ptr to var. to hold class name
                                &LastWrite        //not looked at by us
                                );

                if (RetVal != ERROR_SUCCESS)
                {
                        continue;
                }

                if (lstrcmp(KeyName, _WINS_CFG_PARAMETERS_KEY) == 0)
                {
                        fParametersKey = TRUE;
                }

                if (lstrcmp(KeyName, _WINS_CFG_PARTNERS_KEY) == 0)
                {
                        fPartnersKey = TRUE;
                }
        }

        //
        // if the Parameters key does not exist but it existed before,
        // close the key to get rid of the handle we have
        //
        if (!fParametersKey)
        {
                 if (sfParametersKeyExists)
                {
                        sfParametersKeyExists = FALSE;
                        sfParametersKeyOpen = FALSE;
                }
        }
        else
        {
                sfParametersKeyExists = TRUE;
        }

        //
        // if the Partners key does not exist but it existed before,
        // close the key to get rid of the handle we have
        //
        if (!fPartnersKey)
        {
                if (sfPartnersKeyExists)
                {
                        sfPartnersKeyExists = FALSE;
                        sfPartnersKeyOpen   = FALSE;
                }
        }
        else
        {
                sfPartnersKeyExists = TRUE;
        }

        return;
} //ChkWinsSubKeys()

VOID
GetSpTimeData(
        HKEY              SubKey,
        LPSYSTEMTIME      pCurrTime,
        LPBOOL            pfSpTime,
        LPDWORD           pSpTimeIntvl

/*++

Routine Description:
        This function is called to get the specific time and period information
        for a PULL/PUSH record.

Arguments:
        SubKey   - Key of a WINS under the Pull/Push key
        pCnfRFec - ptr to the Conf. record of the WINS

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_NO_SP_TIME

Error Handling:

Called by:
        GetPnrInfo

Side Effects:

Comments:
        None
--*/

        )
{
        DWORD    ValTyp;
        BYTE     tSpTime[MAX_SZ_SIZE];
        BYTE     SpTime[MAX_SZ_SIZE];
        LPBYTE   pSpTime = SpTime;
        DWORD    Sz = sizeof(tSpTime);
        LONG     RetVal;
        DWORD    Hr = 0;
        DWORD    Mt = 0;
        DWORD    Sec = 0;
        LONG     TimeInt;


   // DBGENTER("GetSpTimeData\n");
        *pfSpTime = FALSE;

try {

            Sz = sizeof(tSpTime);
            RetVal = RegQueryValueEx(
                             SubKey,
                             WINSCNF_SP_TIME_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             tSpTime,
                             &Sz
                                                );

            //
            // If the user has not specifed a specific time, then we use
            // the current time as the specific time.  For current time,
            // the interval is 0
            //
            if (RetVal == ERROR_SUCCESS)
            {

#ifdef UNICODE
                (VOID)WinsMscConvertUnicodeStringToAscii(tSpTime, SpTime, MAX_SZ_SIZE);
#else
                pSpTime = tSpTime;
#endif

                RetVal = (LONG)sscanf(pSpTime, "%d:%d:%d", &Hr, &Mt, &Sec);
                if ((RetVal == EOF) || (RetVal == 0))
                {
                        DBGPRINT1(ERR, "GetSpTime: Wrong time format (%s)\n",
                                                pSpTime);
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_TIME_FORMAT);
                }
                else
                {

                  *pSpTimeIntvl = 0;
                  if ((Hr <= 23)  && (Mt <= 59) && (Sec <= 59))
                  {
                     TimeInt =  ((Hr * 3600) + (Mt * 60) + Sec) -
                                       ((pCurrTime->wHour * 3600) +
                                        (pCurrTime->wMinute * 60) +
                                         pCurrTime->wSecond);
                     if (TimeInt < 0)
                     {
                        *pSpTimeIntvl =  (24 * 3600) + TimeInt;
                     }
                     else
                     {
                        *pSpTimeIntvl =  TimeInt;
                     }
                     *pfSpTime      = TRUE;
                     DBGPRINT1(DET, "GetSpTimeData: Sp. Time Interval is %d\n",
                            *pSpTimeIntvl);
                  }
                  else
                  {
                     DBGPRINT0(DET, "GetSpTimeData: WRONG TIME FORMAT\n");
                  }
                }
            }
 }
 except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetSpTime");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CONFIG_ERR);
        }
//    DBGLEAVE("GetSpTimeData\n");
    return;
}
#if MCAST > 0
STATUS
WinsCnfAddPnr(
  RPL_RR_TYPE_E  RRType_e,
  LPBYTE         pPnrAdd
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

     LONG RetVal;
     HKEY  CnfKey;
     HKEY  PnrKey;
     DWORD NewKeyInd;

     DBGENTER("WinsCnfAddPnr\n");
     /*
     *  Open the key (PULL/PUSH)
     */
     RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,        //subkey for WINS
                0,                          //must be zero (reserved)
                KEY_CREATE_SUB_KEY,    //we want "subkey create" priv
                &CnfKey                //handle to key
                );

     if (RetVal != ERROR_SUCCESS)
     {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                RetVal,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
        return (WINS_FAILURE);
   }
     //
     //  Add the pnr
     //
     RetVal = RegCreateKeyExA(
                CnfKey,        //predefined key value
                pPnrAdd,                //subkey for WINS
                0,                        //must be zero (reserved)
                "Class",                //class -- may change in future
                REG_OPTION_NON_VOLATILE, //non-volatile information
                KEY_ALL_ACCESS,                //we desire all access to the keyo
                NULL,                         //let key have default sec. attributes
                &PnrKey,                //handle to key
                &NewKeyInd                //is it a new key (out arg)
                );



    if (RetVal != ERROR_SUCCESS)
    {
        WINSEVT_LOG_M(
                       RetVal,
                       RRType_e == RPL_E_PULL ? WINS_EVT_CANT_OPEN_PULL_SUBKEY
                                              : WINS_EVT_CANT_OPEN_PUSH_SUBKEY
                           );
         DBGPRINT3(ERR, "WinsCnfAddPnr: Could not create key with address = (%s) under the %s Key. RetVal = (%d)\n", pPnrAdd,
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH",
                       RetVal);
         return(WINS_FAILURE);
    }
    else
    {
         if (NewKeyInd != REG_CREATED_NEW_KEY)
         {
            DBGPRINT2(ERR, "WinsCnfAddPnr: key with address = (%s) under the %s Key already present\n", pPnrAdd, RRType_e == RPL_E_PULL ? "PULL" : "PUSH");
         }
         else
         {

             //
             // If Pull pnr, add the time interval
             //
             if (RRType_e == RPL_E_PULL)
             {
                 //
                 // Add the time interval
                 //
                 SetVal(PnrKey, WINSCNF_RPL_INTERVAL_NM, REG_DWORD,
                     (LPWSTR)WINSCNF_TIME_INT_W_SELF_FND_PNRS, sizeof(DWORD));

             }
             SetVal(PnrKey, WINSCNF_SELF_FND_NM, REG_DWORD,
                       (LPWSTR)TRUE, sizeof(DWORD));

         }
         RegCloseKey(PnrKey);
         RegCloseKey(CnfKey);

    }

    DBGLEAVE("WinsCnfAddPnr\n");
    return(WINS_SUCCESS);
}
STATUS
WinsCnfDelPnr(
  RPL_RR_TYPE_E  RRType_e,
  LPBYTE         pPnrAdd
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

     LONG RetVal;
     HKEY  TypeOfPnrKey;
     HKEY  PnrKey;
     //WCHAR Key[160];
     WCHAR String[160];
     BOOL  fSelfFnd;
     DWORD Sz;
     DWORD ValType;

     DBGENTER("WinsCnfDelPnr\n");

     WinsMscConvertAsciiStringToUnicode(pPnrAdd, (LPBYTE)String, sizeof(String)/sizeof(WCHAR));

     /*
     *  Open the key (PULL/PUSH)
     */
     RetVal =   RegOpenKeyEx(
                sConfigRoot,                //predefined key value
                RRType_e == RPL_E_PULL ?
                        _WINS_CFG_PULL_KEY :
                        _WINS_CFG_PUSH_KEY,
                0,                          //must be zero (reserved)
                KEY_ALL_ACCESS,
                &TypeOfPnrKey                //handle to key
                );

     if (RetVal != ERROR_SUCCESS)
     {

CHECK("Is there any need to log this")
        WINSEVT_LOG_INFO_M(
                                WINS_SUCCESS,
                                RRType_e == RPL_E_PULL ?
                                        WINS_EVT_CANT_OPEN_PULL_KEY :
                                        WINS_EVT_CANT_OPEN_PUSH_KEY
                         );
        //--ft: Prefix bug 444974 - this key has to exist. If absurdly is missing, we won't find
        // the partner anyhow.
        return (WINS_SUCCESS);
     }
     RetVal = RegOpenKeyEx(
                TypeOfPnrKey,        //predefined key value
                String,
                0,                          //must be zero (reserved)
                KEY_ALL_ACCESS,    //we want "subkey create" priv
                &PnrKey                //handle to key
                );



    if (RetVal != ERROR_SUCCESS)
    {
         DBGPRINT3(ERR, "WinsCnfDelPnr: %s Pnr with address = (%s) is Non-existent. RetVal = (%d)",
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH", pPnrAdd,
                       RetVal);
         return(WINS_SUCCESS);
    }
    else
    {
          Sz = sizeof(fSelfFnd);
          RetVal = RegQueryValueEx(
                                        PnrKey,
                                        WINSCNF_SELF_FND_NM,
                                        NULL,
                                        &ValType,
                                        (LPBYTE)&fSelfFnd,
                                        &Sz
                                  );

         //
         // If SelfFnd is there and it's value is 1, delete it
         //
         if ((RetVal == ERROR_SUCCESS) && (fSelfFnd == 1))
         {
            RetVal = RegDeleteKey(TypeOfPnrKey, String);
            if (RetVal != ERROR_SUCCESS)
            {
               DBGPRINT3(ERR, "WinsCnfDelPnr: Could not delete %s Pnr with address = (%s). RetVal = (%d)",
                       RRType_e == RPL_E_PULL ? "PULL" : "PUSH", pPnrAdd,
                       RetVal);
               RegCloseKey(PnrKey);
               return(WINS_FAILURE);

            }
         }
         RegCloseKey(TypeOfPnrKey);

    }

    DBGLEAVE("WinsCnfDelPnr\n");
    return(WINS_SUCCESS);
}

DWORD
SetVal(
       HKEY     RootKey,
       LPWSTR   pName,
       DWORD    ValType,
       LPWSTR   pVal,
       DWORD    ValSize
)
{
        UINT Status = WINS_SUCCESS;
        LONG  RetVal;
        DWORD Val;
        if (ValType == REG_DWORD)
        {
             Val = PtrToUlong (pVal);
        }
        RetVal = RegSetValueEx(
                          RootKey,
                          pName,
                          0,         //reserved -- must be 0
                          ValType,
                          ValType == REG_DWORD ? (LPBYTE)&Val : (LPBYTE)pVal,
                          ValType == REG_DWORD ?  ValSize : lstrlen(pVal)
                             );

        if (RetVal != ERROR_SUCCESS)
        {
                 printf("SetVal: Could not set value of %s\n", pName);
                 Status = WINS_FAILURE;
        }

        return(Status);
}
#endif

DWORD
WinsCnfWriteReg(
    LPVOID  pTmp
    )

/*++

Routine Description:
    This function write the value of the version counter to be used
    at the next invocation.

Arguments:
    pTmp - Will be NULL if WinsCnfNextTimeVersNo was found in the registry
           when WINS came up.

Externals Used:
    NmsHighWaterMarkVersNo
    NmsVersNoToStartFromNextTime
    NmsNmhNamRegCrtSec
    NmsRangeSize
    NmsHalfRangeSize
    sfVersNoChanged
    sfVersNoUpdThdExists

Return Value:

    VOID

Error Handling:

Called by:
    NMSNMH_INC_VERS_COUNTER_M

Side Effects:

Comments:
        None
--*/

{
    LONG  RetVal;
    LONG  RetVal2;
    VERS_NO_T VersNo;
    DBGENTER("WinsCnfWriteReg\n");
    EnterCriticalSection(&NmsNmhNamRegCrtSec);

    //
    // if pTmp is not NULL, it means that either WINS did not find
    // Next time's version number in the registry or that the max. version
    // number in the db is greater than the high water mark we set at
    // initialization.  In the former case, we already have the correct
    // value in NmsNmhToStartFromNextTime, so the if body is not executed.
    //
    if (!pTmp || LiLtr(NmsHighWaterMarkVersNo, NmsNmhMyMaxVersNo))
    {
         NmsHighWaterMarkVersNo.QuadPart   = LiAdd(NmsVersNoToStartFromNextTime,
                                                NmsHalfRangeSize);
         NmsVersNoToStartFromNextTime.QuadPart = LiAdd(NmsVersNoToStartFromNextTime,
                                                        NmsRangeSize);
    }
    VersNo = NmsVersNoToStartFromNextTime;
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);

    RetVal = RegSetValueEx(
                        sConfigRoot,
                        WINSCNF_INT_VERSNO_NEXTTIME_LW_NM,
                        0,         //reserved -- must be 0
                        REG_DWORD,
                        (LPBYTE)&VersNo.LowPart,
                        sizeof(DWORD)
                                        );


    RetVal2 = RegSetValueEx(
                        sConfigRoot,
                        WINSCNF_INT_VERSNO_NEXTTIME_HW_NM,
                        0,         //reserved -- must be 0
                        REG_DWORD,
                        (LPBYTE)&VersNo.HighPart,
                        sizeof(DWORD)
                                        );
    if ((RetVal != ERROR_SUCCESS) || (RetVal2 != ERROR_SUCCESS))
    {
                DBGPRINT2(ERR, "WinsCnfWriteReg - Could not set Next time's start version counter value in the registry.  The new value is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);
    }

    EnterCriticalSection(&NmsNmhNamRegCrtSec);
    WinsCnfRegUpdThdExists = FALSE;
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    DBGLEAVE("WinsCnfWriteReg\n");
    return(WINS_SUCCESS);
}

#if defined (DBGSVC)  && !defined (WINS_INTERACTIVE)
VOID
WinsCnfReadWinsDbgFlagValue(
        VOID
        )
{
        DWORD Sz;
          DWORD ValTyp;

        WinsDbg = 0;   //set it to zero now.  It was set to a value by Init() in
                   //nms.c
        Sz = sizeof(WinsDbg);
        (VOID)RegQueryValueEx(
                             sParametersKey,
                             WINSCNF_DBGFLAGS_NM,
                             NULL,        //reserved; must be NULL
                             &ValTyp,
                             (LPBYTE)&WinsDbg,
                             &Sz
                                );

        return;
}
#endif


VOID
ReadSpecGrpMasks(
        PWINSCNF_CNF_T pWinsCnf
        )

/*++

Routine Description:
        This function is called to read in the special group masks specified
        under the SpecialGrpMasks key

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD NoOfSubKeys;
        HKEY  SGMKey;
        BOOL  fKeyOpen = FALSE;
           LONG  RetVal;
        DBGENTER("ReadSpecGrpMasks\n");
try {
           /*
           *  Open the SPEC_GRP_MASKS key
           */
           RetVal =   RegOpenKeyEx(
                        sParametersKey,                //predefined key value
                        _WINS_CFG_SPEC_GRP_MASKS_KEY,
                        0,                //must be zero (reserved)
                        KEY_READ,        //we desire read access to the keyo
                        &SGMKey                //handle to key
                );
        if (RetVal == ERROR_SUCCESS)
        {
            fKeyOpen = TRUE;
           //
           // Get the count of data files listed under the DATAFILES
           // key
           //
           GetKeyInfo(
                        SGMKey,
                        WINSCNF_E_SPEC_GRP_MASKS_KEY,
                        &NoOfSubKeys,                        //ignored
                        &pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks
                      );
           if (pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks > 0)
           {

                DWORD                 Index;
                LPBYTE                 pTmp;
                TCHAR                 ValNmBuff[5];
                DWORD                 ValNmBuffSz;
                DWORD                 StrType;
                LPBYTE                 pByte;
                DWORD                 BuffSize;
                CHAR                 Tmp[WINS_MAX_FILENAME_SZ];
#ifdef UNICODE
                WCHAR                Str[WINSCNF_SPEC_GRP_MASK_SZ];
#endif

                  //
                  // Allocate buffer big enough to hold data for
                // the number of subkeys found under the PULL key
                  //
                  BuffSize = (WINSCNF_SPEC_GRP_MASK_SZ + 1) *
                                pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks;
                    WinsMscAlloc( BuffSize, &pWinsCnf->SpecGrpMasks.pSpecGrpMasks);

                   /*
                    *   Enumerate  the values
                     */
                     for(
                        Index = 0, pTmp = pWinsCnf->SpecGrpMasks.pSpecGrpMasks;
                        Index <  pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks;
                                // no third expression
                         )
                {
                        ValNmBuffSz = sizeof(ValNmBuff)/sizeof(TCHAR);  //init before
                                                          //every call
                        BuffSize  = WINSCNF_SPEC_GRP_MASK_SZ;
                          RetVal = RegEnumValue(
                                    SGMKey,
                                    Index,        //key
                                    ValNmBuff,
                                    &ValNmBuffSz,
                                    (LPDWORD)NULL,                //reserved
                                    &StrType,
#ifdef UNICODE
                                    (LPBYTE)Str,
#else
                                    pTmp,
#endif
                                    &BuffSize
                                            );

                        if (RetVal != ERROR_SUCCESS)
                        {
                                continue;
                        }

                        //
                        // if StrType is not REG_SZ  go to the next  Value
                        //
                        if  (StrType != REG_SZ)
                        {
                                continue;
                        }
                        if (BuffSize != WINSCNF_SPEC_GRP_MASK_SZ)
                        {
                                DBGPRINT1(ERR, "ReadSpecGrpMasks: Wrong spec. grp mask (%s)\n", pTmp);

                                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_SPEC_GRP_MASK_M);
                                continue;
                        }
                        else
                        {
#ifdef UNICODE
                          WinsMscConvertUnicodeStringToAscii(
                                                (LPBYTE)Str,
                                                (LPBYTE)Tmp,
                                                WINSCNF_SPEC_GRP_MASK_SZ
                                                );
#endif
                          pByte = (LPBYTE)Tmp;
                          for (Index = 0; Index < WINSCNF_SPEC_GRP_MASK_SZ;
                                        Index++, pByte++)
                          {
                                *pByte = (BYTE)CharUpperA((LPSTR)*pByte);
                                if (
                                        ((*pByte >= '0') && (*pByte <= '9'))
                                                        ||
                                        ((*pByte >= 'A') && (*pByte <= 'F'))
                                   )
                                {
                                        continue;
                                }
                                else
                                {
                                        break;
                                }

                          }
                          if (Index > WINSCNF_SPEC_GRP_MASK_SZ)
                          {
                                DBGPRINT1(ERR, "ReadSpecGrpMasks: Wrong spec. grp mask (%s)\n", pTmp);
                                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_WRONG_SPEC_GRP_MASK_M);
                                continue;
                          }
                         *(pTmp + WINSCNF_SPEC_GRP_MASK_SZ) = EOS;
                        }

                        Index++;
                        pTmp += WINSCNF_SPEC_GRP_MASK_SZ + 1;
                }

                //
                // If not even one valid name was retrieved, get rid of the
                // buffer
                //
                if (Index == 0)
                {
                        //
                        // Get rid of the buffer
                        //
                        WinsMscDealloc((LPBYTE)pWinsCnf->SpecGrpMasks.pSpecGrpMasks);
                }

                pWinsCnf->SpecGrpMasks.NoOfSpecGrpMasks = Index;
           }
        } // end of if
 } // end of try ..
 except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("ReadSpecGrpMasks");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_CANT_INIT);
        }

        if (fKeyOpen && RegCloseKey(SGMKey) != ERROR_SUCCESS)
        {
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_CLOSE_KEY);
                DBGPRINT0(ERR, "ReadSpecGrpMasks: Can not read the spec. grp. mask. key\n");
        }
        DBGLEAVE("ReadSpecGrpMasks\n");
        return;
}


#if 0
int
__cdecl
CompUpdCnt(
        CONST LPVOID  pElem1,
        CONST LPVOID  pElem2
        )

/*++

Routine Description:
        This function is called by qsort crtl function to compare two
        elements of the array that has to be sorted


Arguments:
        pElem1 - ptr to first element
        pElem1 - ptr to second element

Externals Used:
        None

Return Value:
        -1 if first element is < second element
        = 0 if first element is == second element
        1 if first element is > second element

Error Handling:

Called by:
        qsort (which is called by WinsCnfReadPartnerInfo

Side Effects:

Comments:
        Not used currently
--*/

{

        CONST PRPL_CONFIG_REC_T        pCnfRec1 = pElem1;
        CONST PRPL_CONFIG_REC_T        pCnfRec2 = pElem2;

        if (pCnfRec1->UpdateCount < pCnfRec2->UpdateCount)
        {
                return(-1);
        }
        else
        {
                if (pCnfRec1->UpdateCount == pCnfRec2->UpdateCount)
                {
                        return(0);
                }
        }

        //
        // The first record has a higher UpdateCount than the second one
        //
        return(1);
}

#endif

#ifdef WINSDBG
VOID
PrintRecs(
        RPL_RR_TYPE_E  RRType_e,
        PWINSCNF_CNF_T  pWinsCnf
        )
{
 return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\nmfilter.c ===
#include <string.h>
#include "wins.h"
#include "winsmsc.h"
#include "nmfilter.h"

// local defines
#define SET_BIT(Mask, Key)     (Mask)[(Key)>>3] |= 1<<((Key)&7)
#define CLR_BIT(Mask, Key)     (Mask)[(Key)>>3] &= ~(1<<((Key)&7))
#define IS_SET(Mask, Key)      ((Mask)[(Key)>>3] & (1<<((Key)&7)))

// the root of the filter tree.
PNMFILTER_TREE      g_p1BFilter = NULL;
// critical section protecting the filter tree
CRITICAL_SECTION    g_cs1BFilter;

//--------------------------
// init the filter passed as parameter
PNMFILTER_TREE
InitNmFilter(PNMFILTER_TREE pFilter)
{
    if (pFilter != NULL)
        DestroyNmFilter(pFilter);

    // create the root node of the filter. This stands only for the common point
    // of all filters starting with different chars.
    //
    WinsMscAlloc(sizeof(NMFILTER_TREE), &pFilter);
    InitializeListHead(&pFilter->Link);
    pFilter->chKey = 0;
    // for the root of the filter only, nRef is zero
    pFilter->nRef = 0;
    // for the FollowMap, memory has been zeroed on allocation
    // for the Flags, memory has been zeroed on allocation
    InitializeListHead(&pFilter->Follow);
    return pFilter;
}

//--------------------------
// clears the whole subtree from the node given as parameter, 
// the node itself being also deleted
PNMFILTER_TREE
DestroyNmFilter(PNMFILTER_TREE pNode)
{
    if (pNode == NULL)
        return NULL;

    while(!IsListEmpty(&pNode->Follow))
    {
        PLIST_ENTRY     pEntry;
        PNMFILTER_TREE  pFollow;

        pEntry = RemoveHeadList(&pNode->Follow);
        pFollow = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);

        DestroyNmFilter(pFollow);
    }
    WinsMscDealloc(pNode);

    return NULL;
}

//--------------------------
// inserts a name in the filter
VOID
InsertNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen)
{
    PNMFILTER_TREE pFollow = NULL;
    
    // the assumption is that the filter has been initialized already (hence pNode != NULL)
    //
    // if no data has been given, mark this node as being terminal and get out
    if (nLen == 0)
    {
        pNode->Flags |= NMFILTER_FLAG_TERMINAL;
        return;
    }

    // we do have a name to add
    // quick check if there is a follower for *pName already
    if (!IS_SET(pNode->FollowMap, *pName))
    {
        WinsMscAlloc(sizeof(NMFILTER_TREE), &pFollow);
        InitializeListHead(&pFollow->Link);
        pFollow->chKey = *pName;
        // this is the first reference for this key
        pFollow->nRef = 1;
        // for the FollowMap, memory has been zeroed on allocation
        // for the Flags, memory has been zeroed on allocation
        InitializeListHead(&pFollow->Follow);
        // insert this follower at the end of the node's "Follow" list (lowest nRef)
        InsertTailList(&pNode->Follow, &pFollow->Link);
        // set the bit in the map saying there is now a follower for this key
        SET_BIT(pNode->FollowMap, *pName);
    }
    else
    {
        PLIST_ENTRY     pEntry;

        // we have a follower for the given key
        // we need first to locate it
        for (pEntry = pNode->Follow.Blink; pEntry != &pNode->Follow; pEntry = pEntry->Blink)
        {
            PNMFILTER_TREE  pCandidate;

            pCandidate = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);

            // if we didn't find yet the right follower..
            if (pFollow == NULL)
            {
                // check if the current entry is not the right one
                if (pCandidate->chKey == *pName)
                {
                    pFollow = pCandidate;
                    // since this is a new reference to this follower, bump up nRef
                    pFollow->nRef++;
                }
            }
            else
            {
                // we did find the follower by going backwards in the list. Then move this
                // follower closer to the head of the list based on its nRef (the list should
                // be ordered descendingly by nRef)
                if (pFollow->nRef < pCandidate->nRef && pCandidate->Link.Flink != &pFollow->Link)
                {
                    RemoveEntryList(&pFollow->Link);
                    InsertHeadList(&pCandidate->Link, &pFollow->Link);
                    break;
                }
            }
        }
        // at this point, pFollow should be non-null!! the bit from FollowMap assured us the 
        // follower had to exist.
    }

    // now let the follower do the rest of the work
    pName++; nLen--;
    InsertNmInFilter(pFollow, pName, nLen);
}

//--------------------------
// checks whether a name is present in the filter or not
BOOL
IsNmInFilter(PNMFILTER_TREE pNode, LPSTR pName, UINT nLen)
{
    PLIST_ENTRY     pEntry;

    // if there is no filter, this means we filter the whole universe.
    // just return true.
    if (pNode == NULL)
        return TRUE;

    // if there are no more keys to look for, return true
    // if this node is marked as "terminal" (meaning there is a name
    // in the filter that ends at this level
    if (nLen == 0)
        return (pNode->Flags & NMFILTER_FLAG_TERMINAL);

    // if there is no follower for the name, it means 
    if (!IS_SET(pNode->FollowMap, *pName))
        return FALSE;

    // we do have a valid name, and a follower for it.
    // now just locate the follower and pass it the task of checking the remainings of the name
    for (pEntry = pNode->Follow.Flink; pEntry != &pNode->Follow; pEntry = pEntry->Flink)
    {
        PNMFILTER_TREE  pCandidate;
        pCandidate = CONTAINING_RECORD(pEntry, NMFILTER_TREE, Link);
        if (pCandidate->chKey == *pName)
        {
            pName++; nLen--;
            return IsNmInFilter(pCandidate, pName, nLen);
        }
    }

    // if we reached this point, something is wrong - we didn't find a follower although
    // the bitmap said there should be one. Just return FALSE;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winsevt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:



Abstract:

 	This module provides error logging routines needed for the entire
 	WINS.  See header file winsevt.h for the
 	macros which use the functions in this module.

Functions:


Portability:

       The current implementation of the module is not portable.

Author:

	Pradeep Bahl (PradeepB)  	Dec-1992

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/


#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include "wins.h"
#ifdef DBGSVC
#include "nms.h"
#endif
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"




/*
 *	Local Macro Declarations
 */
#if 0

/*
 *  get_month_m:
 *
 *  This macro converts a numerical month (0-11) to a month string
 *  abbreviation.
 *
 *  NOTE:  This macro must *NOT* be called with an expression as an argument.
 *         If this is done, then you will get the expression
 *         evaluated 11 times
 *	   (probably not desired).
 */

#define get_month_m(month_int)		\
       (((month_int) == 0)  ? "JAN" :	\
	((month_int) == 1)  ? "FEB" :	\
	((month_int) == 2)  ? "MAR" :	\
	((month_int) == 3)  ? "APR" :	\
	((month_int) == 4)  ? "MAY" :	\
	((month_int) == 5)  ? "JUN" :	\
	((month_int) == 6)  ? "JUL" :	\
	((month_int) == 7)  ? "AUG" :	\
	((month_int) == 8)  ? "SEP" :	\
	((month_int) == 9)  ? "OCT" :	\
	((month_int) == 10) ? "NOV" : "DEC" \
	)
#endif

/*
 *	Local Typedef Declarations
 */



/*
 *	Global Variable Definitions
 */



/*
 *	Local Variable Definitions
 */



/*
 *	Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


/*
 *  Function Name:
 *	extern WinsEvtLogEvt
 *
 *  Function Description:
 *      This is funtion that logs all errors from the WINS process.  It should
 *	only be "called" using the WINSEVT_ macros, except within
 *	this module.
 *
 *  Arguments:
 *	IN  StatusCode		- integer containing the status code of the
 *				  error to be printed.
 *
 *  Return value:
 *	None.
 *
 *  Error Handling:
 *	None.
 *
 *  Extern Variables used:
 *	None.
 *
 *  Side Effects:
 *	None.
 *
 *  Comments:
 *	Make sure that printf is thread-renetrant.
 *
 */
VOID
WinsEvtLogEvt
	(
	LONG 		BinaryData,
	WORD  	        EvtTyp,
	DWORD		EvtId,
	LPTSTR		pFileStr,
	DWORD 		LineNumber,
	PWINSEVT_STRS_T	pStr
	)
{
	BOOL  fRet = TRUE;
	DWORD Error;
	DWORD NoOfBytes;
	WORD	BinData[4];
	
	BinData[0] = (WORD)(LineNumber & 0xFFFF);
	BinData[1] = (WORD)(LineNumber >> 16);
	BinData[2] = (WORD)(BinaryData & 0xFFFF); //lower word first
	BinData[3] = (WORD)(BinaryData >> 16);	  //then higher word
				
try {

	NoOfBytes = sizeof(BinData);	


	fRet = ReportEvent(
		    WinsCnf.LogHdl,
		    (WORD)EvtTyp,
		    (WORD)0,			//category zero
		    EvtId,
		    NULL,		//no user SID
		    (WORD)(pStr != NULL ? pStr->NoOfStrs : 0),//no of strings
		    NoOfBytes,		//no of bytes in binary data
		    pStr != NULL ? (LPCTSTR *)(pStr->pStr) : (LPCTSTR *)NULL,//address of string arr
		    BinData		//address of data
		   );
	if (!fRet)
	{
		Error = GetLastError();
		DBGPRINT1(
			ERR,
			"WinsEvtLogEvt: ReportEvent returned error = (%d)",
			Error
			 );

	}
	
 }
except(EXCEPTION_EXECUTE_HANDLER) {

	DBGPRINT1(EXC, "WinsEvtLogEvt: Report Event generated the exception (%x).  Check if you have the right access. You should have power user access on this machine\n", GetExceptionCode());
	
	}

	return;
}


VOID
WinsEvtLogDetEvt(
     BOOL       fInfo,
     DWORD      EvtId,
     LPTSTR     pFileName,
     DWORD 	LineNumber,
     LPSTR      pFormat,
     ...
        )

{
        LPBYTE pFmt = pFormat;
        DWORD  NoOfStr = 0;
        DWORD  NoOfW = 0;
        DWORD  Data[30];
        LPWSTR ppwStr[10];
        WCHAR  wStr[10][80];
        BOOL   fRet = TRUE;
        DWORD  Error;
        DWORD  ArrIndex = 0;

        va_list ap;

        if (!WinsCnf.LogDetailedEvts)
            return;

        DBGENTER("WinsEvtLogDetEvt\n");

try {

        va_start(ap, pFormat);
        Data[NoOfW++] = LineNumber;
        if (pFileName != (LPTSTR)NULL)
        {
                ppwStr[NoOfStr++] = pFileName;
        }
        for (; *pFmt; pFmt++)
        {
               switch(*pFmt)
               {
                case('d'):
                        Data[NoOfW++] = (DWORD)va_arg(ap, long);
                        break;

                case('s'):
                        WinsMscConvertAsciiStringToUnicode(
                                               va_arg(ap, char *),
                                               (LPBYTE)wStr[ArrIndex], 80);
                        ppwStr[NoOfStr++] = wStr[ArrIndex++];

                        break;

                case('u'):
                        ppwStr[NoOfStr++] = va_arg(ap, short *);
                        break;

                default:
                        break;
               }
        }
        ppwStr[NoOfStr] = (LPWSTR)NULL;
	fRet = ReportEvent(
		    WinsCnf.LogHdl,
		    (WORD)(fInfo ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_ERROR_TYPE),
		    (WORD)0,			//category zero
		    EvtId,
		    NULL,		//no user SID
		    (WORD)NoOfStr,       //no of strings
		    NoOfW * sizeof(DWORD),	  //no of bytes in binary data
		    NoOfStr != 0 ? (LPCTSTR *)ppwStr : (LPCTSTR *)NULL,//address of string arr
		    Data		//address of data
		   );
	if (!fRet)
	{
		Error = GetLastError();
		DBGPRINT1(
			ERR,
			"WinsEvtLogDetEvt: ReportEvent returned error = (%d)",
			Error
			 );

	}
    va_end(ap);
} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {

	DBGPRINT1(EXC, "WinsLogDetEvt: Report Event generated the exception (%x).  Check if you have the right access. You should have power user access on this machine\n", GetExceptionCode());
	
	}

        DBGLEAVE("WinsEvtLogDetEvt\n");
        return;
}

VOID
WinsLogAdminEvent(
    IN      DWORD               EventId,
    IN      DWORD               StrArgs,
    IN      ...
    )
/*++

Routine Description:

    This routine is called to log admin triggerd events.

Arguments:

    EventId - The id of the event to be logged.

    StrArgs - No of additional args.

Return Value:

    None

Comments:
    This routine must be called fromt he RPC API processing code only.
        None
--*/
{
    RPC_STATUS              RpcStatus;
    TCHAR                   UserNameBuf[MAX_PATH+1];
    DWORD                   Size;
    WINSEVT_STRS_T          EvtStr;
    va_list                 ap;
    DWORD                   i;

    // first impersonate the client.
    RpcStatus = RpcImpersonateClient( NULL );
    if (RPC_S_OK != RpcStatus) {
        DBGPRINT1(ERR, "WinsLogAdminEvent: Could not impersonate client (Error = %ld)\n", RpcStatus);
        return;
    }
    if (!GetUserName(UserNameBuf,&Size)) {
        DBGPRINT1(ERR, "WinsLogAdminEvent: Could not get user name (Error = %ld)\n", GetLastError());
        goto Cleanup;
    }
    EvtStr.NoOfStrs = 1;
    EvtStr.pStr[0] = UserNameBuf;
    ASSERT( StrArgs < MAX_NO_STRINGS );

    va_start(ap,StrArgs);
    for(i=1;i<= StrArgs && i<= MAX_NO_STRINGS; i++) {
        EvtStr.pStr[i] = va_arg(ap, LPTSTR);
        EvtStr.NoOfStrs++;
    }
    va_end(ap);

    WINSEVT_LOG_INFO_STR_M(EventId, &EvtStr);

Cleanup:
    RpcStatus = RpcRevertToSelf();
    if (RPC_S_OK != RpcStatus) {
        ASSERT( FALSE );
    }
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winsmsc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        winsmsc.c



Abstract:

   This module contains miscellanous functions that in general are used by
   more than one component of WINS.  Some of the functions in this module are
   wrappers for WIN32 api functions.  These wrappers serve to isolate
   WINS code from changes in the WIN32 api.

Functions:

         WinsMscAlloc
        WinsMscDealloc
        WinsMscFreeMem
        WinsMscWaitInfinite
        WinsMscWaitTimed
        WinsMscCreateEvt
        WinsMscSetUpThd
        WinsMscWaitUntilSignaled
        WinsMscWaitTimedUntilSignaled
        WinsMscHeapAlloc
        WinsMscHeapFree
        WinsMscHeapCreate
        WinsMscHeapDestroy
        WinsMscTermThd
        WinsMscSignalHdl
        WinsMscResetHdl
        WinsMscCloseHdl
        WinsMscCreateThd
        WinsMscSetThdPriority
        WinsMscOpenFile
        WinsMscMapFile


Portability:
        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

#include <string.h>

#if 0
//
// The following is just for the system call
//
#ifdef WINSDBG
#include <process.h>
#include <stdlib.h>
#endif
#endif

#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "winstmm.h"
#include "winsevt.h"
#include "winsque.h"
#include "winsprs.h"
#include "winsdbg.h"

/*
 *        Local Macro Declarations
 */

#define  PERCENT_CHAR         TEXT('%')
/*
 *        Local Typedef Declarations
 */


/*
 *        Global Variable Definitions
 */



/*
 *        Local Variable Definitions
 */



/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */

__inline
VOID
WinsMscAlloc(
        IN   DWORD    BuffSize,
        OUT  LPVOID  *ppRspBuff
        )


/*++

Routine Description:
        This function is called to allocate memory.


Arguments:
        BuffSize  - Size of buffer to allocate
        ppRspBuff - Buffer allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:

        NmsDbGetDataRecs, GetGroupMembers
Side Effects:

Comments:
        None
--*/

{
FUTURES("Change this function into a macro")

        *ppRspBuff = WinsMscHeapAlloc(GenBuffHeapHdl, BuffSize);

        return;
}

__inline
VOID
WinsMscDealloc(
        IN LPVOID        pBuff
        )

/*++

Routine Description:

        This function frees memory allocated via NmsDbAlloc
Arguments:
        pBuff  -- Buffer to deallocate


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/


{
FUTURES("Change this function into a macro")
        WinsMscHeapFree(GenBuffHeapHdl, pBuff);
        return;
}



VOID
WinsMscFreeMem(
        IN  PWINS_MEM_T pWinsMem
        )

/*++

Routine Description:
         This function is called to free memory that is pointed to by one
        or more pointers in the pWinsMem array


        This function is called from all those functions that allocate
        memory or that acquire memory allocated by called function via
        OUT args of those "memory allocating" called functions.

Arguments:

        pWinsMem - ptr to an array of buffers to deallocate

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        pWinsMem array should end with a NULL pointer
--*/

{

  if (pWinsMem != NULL)
  {

          for (; pWinsMem->pMem != NULL; pWinsMem++)
          {
                WinsMscDealloc(pWinsMem->pMem);
          }
  }
  return;
}

VOID
WinsMscWaitInfinite(
        IN HANDLE  Hdl
)

/*++

Routine Description:
        The function is called to wait on a handle until signalled.

Arguments:
        Hdl -- handle to wait on until signaled


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        DWORD        RetVal = WAIT_OBJECT_0;

        /*
         The function should return only if the handle is in the signaled state
        */
        RetVal = WaitForSingleObject(Hdl, INFINITE);

        if (RetVal != WAIT_OBJECT_0)
        {
                WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);
        }

        return;
}

VOID
WinsMscWaitTimed(
        IN HANDLE    Hdl,
        IN DWORD     TimeOut,
        OUT LPBOOL   pfSignaled
)

/*++

Routine Description:
        The function is called to wait on a handle until signalled.

Arguments:
        Hdl        - handle to wait on until signaled
        TimeOut    - TIme for which the wait has to be done
        pfSIgnaled - Indicates whether the hdl got signaled.


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        DWORD        RetVal = WAIT_OBJECT_0;

        *pfSignaled = TRUE;

        /*
         The function should return only if the handle is in the signaled state
        */
        RetVal = WaitForSingleObject(Hdl, TimeOut);

        if (RetVal == WAIT_ABANDONED)
        {
                WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);

        }
        if (RetVal == WAIT_TIMEOUT)
        {
                if (TimeOut == INFINITE)
                {
                        WINS_RAISE_EXC_M(WINS_EXC_ABNORMAL_TERM);
                }
                else
                {
                   *pfSignaled = FALSE;
                }
        }


        return;
}

VOID
WinsMscCreateEvt(
        IN LPTSTR         pName,
        IN BOOL                fManualReset,
        IN PHANDLE        pHdl
        )

/*++

Routine Description:
        This function creates an event with the specified name


Arguments:
        pName                 - Name of Event to create
        fManualReset        - Flag indicating whether it is a manual reset event
        pHdl            - Handle to Event created


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        Init in nms.c

Side Effects:

Comments:
        None
--*/

{

   DWORD        Error;

   *pHdl = CreateEvent(
                        NULL,                //default security attributes
                        fManualReset,        //auto reset event
                        FALSE,          //Not signalled initially
                        pName            // name
                        );

   if (*pHdl == NULL)
   {
        Error = GetLastError();
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_CREATE_EVT);
        WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_RSRCS);
   }

   return;
}


STATUS
WinsMscSetUpThd(
        PQUE_HD_T                pQueHd,
        LPTHREAD_START_ROUTINE  pThdInitFn,
        LPVOID                        pParam,
        PHANDLE                        pThdHdl,
        LPDWORD                        pThdId
        )

/*++

Routine Description:

        This function initializes a queue and its critical section, creates
        an event and a thread to wait on that event.  The event is signaled
        whenever a work item is put on the queue.

Arguments:
        pQueHd     - Head of queue to be monitored by the thread
        pThdInitFn - Startup function of the thread
        pParam     - param to be passed to the startup function
        pThdhdl    - Hdl of thread created by this function
        pThdId     - Id of thread created by this function

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   -- none currently

Error Handling:

Called by:
        WinsTmmInit, RplInit, NmsChlInit
Side Effects:

Comments:
        None
--*/

{

        DWORD   ThdId;

        /*
        *  Initialize the critical section that protects the work queue of
        *  the Pull thread
        */
        InitializeCriticalSection(&pQueHd->CrtSec);

        /*
        *  Initialize the listhead for the pull thread's queue
        */
        InitializeListHead(&pQueHd->Head);

        /*
        * Create an auto-reset event for the above queue
        */
        WinsMscCreateEvt(
                        NULL,                //create without name
                        FALSE,                //auto-reser var
                        &pQueHd->EvtHdl
                        );

        /*
          Create the thread
        */
        *pThdHdl = WinsMscCreateThd(
                         pThdInitFn,
                         pParam,
                         &ThdId
                        );

        if (pThdId != NULL)
        {
          *pThdId = ThdId;
        }
        return(WINS_SUCCESS);

}



VOID
WinsMscWaitUntilSignaled(
        LPHANDLE        pHdlArray,
        DWORD                NoOfHdls,
        LPDWORD                pIndexOfHdlSignaled,
        BOOL            fAlertable
        )

/*++

Routine Description:
        This function is called to wait on multiple handles, one of which
        is the handle which is signaled at termination time


Arguments:
        pHdlArray - Array of handles to wait on
        NoOfHdls  - No of hdls in the array
        pIndexOfHdlSignaled - Index of the hdl signaled

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:

--*/
{

        DWORD  RetHdl;

        do {
            RetHdl = WaitForMultipleObjectsEx(
                                    NoOfHdls,        //# of handles in the array
                                    pHdlArray,        //array of handles
                                    FALSE,                //return when any of the events
                                                    //gets signaled
                                    INFINITE,        //Infinite timeout
                                    fAlertable
                                  );

            DBGPRINT1(DET, "WinsMscWaitUntilSignaled. WaitForMultipleObjects returned (%d)\n", RetHdl);
            // if we got signaled due to IO completion queued on the thread
            // just go back and wait again
        } while (fAlertable && WAIT_IO_COMPLETION == RetHdl);

        if (RetHdl == 0xFFFFFFFF)
        {
                DBGPRINT1(EXC, "WinsMscWaitUntilSignaled. WaitForMultipleObjects returned error. Error = (%d)\n", GetLastError());
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
        }

        *pIndexOfHdlSignaled = RetHdl - WAIT_OBJECT_0;
        if (*pIndexOfHdlSignaled >= NoOfHdls)
        {

            WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

        }

        return;
}


VOID
WinsMscWaitTimedUntilSignaled(
        LPHANDLE        pHdlArray,
        DWORD                NoOfHdls,
        LPDWORD                pIndexOfHdlSignaled,
        DWORD                TimeOut,
        LPBOOL                pfSignaled
        )

/*++

Routine Description:
        This function is called to wait on multiple handles, one of which
        is the handle which is signaled at termination time


Arguments:
        pHdlArray              - Array of handles to wait on
        NoOfHdls            - No of handles in the array
        pIndexOfHdlSignaled - Index of handle signaled
        Timeout             - Max time for which to do the wait
        pfSignaled          - indicates whether a hdl was signaled


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:

--*/
{

        DWORD  RetHdl = 0xFFFFFFFF;
        DWORD  Error;
        int        Index;

        *pfSignaled = TRUE;

        RetHdl = WaitForMultipleObjects(
                                NoOfHdls,        //# of handles in the array
                                pHdlArray,        //array of handles
                                FALSE,                //return when either event gets
                                                //signaled
                                TimeOut                //Infinite timeout
                              );

        if (RetHdl == 0xFFFFFFFF)
        {
                Error = GetLastError();
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
        }

        if (RetHdl == WAIT_TIMEOUT)
        {
                *pfSignaled = FALSE;
                return;
        }

        Index = RetHdl - WAIT_OBJECT_0;

        if ((Index >= (int)NoOfHdls) || (Index < 0))
        {

            DBGPRINT1(EXC, "WinsMscWaitTimedUntilSignaled: Index of handle signaled (%d) is INVALID\n", Index);

            Index = RetHdl - WAIT_ABANDONED_0 ;
            if ((Index > 0) && (Index < (int)NoOfHdls))
            {
                    DBGPRINT1(EXC, "WinsMscWaitTimedUntilSignaled: Index of handle in the abandoned state (%d)\n", Index);
            }

            WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

        }
        else
        {
                *pIndexOfHdlSignaled = Index;
        }
        return;
}



__inline
LPVOID
WinsMscHeapAlloc(
  IN  HANDLE     HeapHdl,
  IN  DWORD      Size
        )

/*++

Routine Description:
  The function returns with a buffer allocated from the specified heap



Arguments:

        HeapHdl  - Handle to the heap
        ppBuff   - Buffer allocated
        Size     - Size of Buffer

Externals Used:
        None

Return Value:

   Success status codes -- ptr to the allocated memory
   Error status codes   -- NULL

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{


  LPVOID  pBuff;
#ifdef WINSDBG
  LPDWORD pHeapCntr;
#endif

  //
  // Note: It is very important that the memory be initialized to zero
  //       (for example, until we have longlong (LARGE INTEGER) support
  //           in the db engine - JET, we will retrieve the version number
  //           as a long data type and store it in the LowPart field of the
  //           large integer storing the version number in our in-memory
  //       data structure.  The HighPart will be 0 by default due to
  //       the initialization done at allocation time.  This is what
  //       we want.
  //

  //
  // if you pass a very large value for the size, HeapAlloc returns NULL
  // instead of raising an exception.
  //
  pBuff = (MSG_T)HeapAlloc(
                        HeapHdl,
                        HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
                        Size
                        );

  DBGPRINT2(HEAP, "HeapAlloc: HeapHandle = (%p), pBuff = (%p)\n",
                        HeapHdl, pBuff);

#ifdef WINSDBG
    if (Size == 0)
    {
           DBGPRINT2(ERR, "WinsMscHeapAlloc: Size = 0; pBuff returned = (%p); HeapHdl = (%p)\n", pBuff, HeapHdl);

    }
    IF_DBG(HEAP_CNTRS)
    {

        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              pHeapCntr = &NmsUdpHeapAlloc;
        } else if (HeapHdl ==  CommUdpDlgHeapHdl)
        {
              pHeapCntr = &NmsUdpDlgHeapAlloc;
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
                  pHeapCntr = &NmsDlgHeapAlloc;
        } else if (HeapHdl == CommAssocTcpMsgHeapHdl)
        {
                  pHeapCntr = &NmsTcpMsgHeapAlloc;
        } else if (HeapHdl == GenBuffHeapHdl)
        {
                  pHeapCntr = &NmsGenHeapAlloc;
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
                  pHeapCntr = &NmsQueHeapAlloc;
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
                  pHeapCntr = &NmsChlHeapAlloc;
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
                  pHeapCntr = &NmsAssocHeapAlloc;
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
                  pHeapCntr = &NmsRplWrkItmHeapAlloc;
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
                  pHeapCntr = &NmsRpcHeapAlloc;
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
                  pHeapCntr = &NmsTmmHeapAlloc;
        } else
        {
            DBGPRINT1(HEAP, "WinsMscHeapAlloc: HeapHdl = (%p)\n", HeapHdl);
            pHeapCntr = &NmsCatchAllHeapAlloc;
        }


        EnterCriticalSection(&NmsHeapCrtSec);

        (*pHeapCntr)++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
  return(pBuff);
}





__inline
VOID
WinsMscHeapFree(
   IN   HANDLE  HeapHdl,
   IN   LPVOID  pBuff
        )

/*++

Routine Description:
        This function deallocates the memory pointed to by pBuff from the
        specified heap

Arguments:
        HeapHdl  - Handle to the heap
        pBuff         - Buffer to deallocate

Externals Used:


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

  DWORD  Error;
  BOOL   fStatus;
#ifdef WINSDBG
  LPDWORD pHeapCntr;
#endif

  DBGPRINT2(HEAP, "HeapFree: HeapHandle = (%p), pBuff = (%p)\n",
                        HeapHdl, pBuff);

  fStatus = HeapFree(
                HeapHdl,
                0,                //we want mutual exclusion
                pBuff
                    );

  if (!fStatus)
  {
        Error = GetLastError();
        WINSEVT_LOG_M(Error, WINS_EVT_HEAP_ERROR);
        WINS_RAISE_EXC_M(WINS_EXC_HEAP_FREE_ERR);
  }
#ifdef WINSDBG
    IF_DBG(HEAP_CNTRS)
    {
        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              pHeapCntr = &NmsUdpHeapFree;
        } else  if (HeapHdl ==  CommUdpDlgHeapHdl)
        {
              pHeapCntr = &NmsUdpDlgHeapFree;
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
                  pHeapCntr = &NmsDlgHeapFree;
        } else if (HeapHdl == CommAssocTcpMsgHeapHdl)
        {
                  pHeapCntr = &NmsTcpMsgHeapFree;
        } else if (HeapHdl == GenBuffHeapHdl)
        {
                  pHeapCntr = &NmsGenHeapFree;
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
                  pHeapCntr = &NmsQueHeapFree;
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
                  pHeapCntr = &NmsChlHeapFree;
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
                  pHeapCntr = &NmsAssocHeapFree;
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
                  pHeapCntr = &NmsRplWrkItmHeapFree;
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
                  pHeapCntr = &NmsRpcHeapFree;
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
                  pHeapCntr = &NmsTmmHeapFree;
        } else
        {
            DBGPRINT1(HEAP, "WinsMscHeapFree: HeapHdl = (%p)\n", HeapHdl);
            pHeapCntr = &NmsCatchAllHeapFree;
        }
        EnterCriticalSection(&NmsHeapCrtSec);
        (*pHeapCntr)++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
  return;

}



HANDLE
WinsMscHeapCreate(
        IN     DWORD         Options,
        IN     DWORD    InitSize
        )

/*++

Routine Description:
        This function creates a heap with the specified options


Arguments:
        Options -- Options for the HeapCreate function (Example: whether or
                   not to enable mutual exclusion)

        InitSize -- Initial Size of the heap (committed memory size)


Externals Used:
        None


Return Value:

   Success status codes --  Hdl to heap
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD   Error;
        HANDLE  HeapHdl;

        HeapHdl = HeapCreate(
                                Options,
                                InitSize,
                                0        //limited only by available memory
                                     );


        if (HeapHdl == NULL)
        {
          Error = GetLastError();
          DBGPRINT0(HEAP, "Cant create heap\n");
          WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_HEAP);
          WINS_RAISE_EXC_M(WINS_EXC_HEAP_CREATE_ERR);
        }

#ifdef WINSDBG
    IF_DBG(HEAP_CNTRS)
    {
        DBGPRINT1(HEAP_CRDL, "HeapCreate: HeapHandle = (%p)\n", HeapHdl);
        EnterCriticalSection(&NmsHeapCrtSec);
        NmsHeapCreate++;
        LeaveCriticalSection(&NmsHeapCrtSec);
    }
#endif
        return(HeapHdl);

}

VOID
WinsMscHeapDestroy(
        HANDLE HeapHdl
        )

/*++

Routine Description:
        This is a wrapper for the HeapDestroy function

Arguments:
        HeapHdl - Handle to heap to destroy

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WrapUp() in nms.c

Side Effects:

Comments:
        None
--*/
{
        BOOL  fRetVal;
        fRetVal = HeapDestroy(HeapHdl);

        ASSERT(fRetVal);
#ifdef WINSDBG
    if (!fRetVal)
    {
        DBGPRINT1(ERR, "HeapDestroy: FAILED -- HeapHandle used = (%p)\n", HeapHdl);
    }
    else
    {
     IF_DBG(HEAP_CNTRS)
     {
        if (HeapHdl ==  CommUdpBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Udp Buff heap\n");
        } else if (HeapHdl == CommAssocDlgHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Dlg Buff heap\n");
        } else if (HeapHdl == GenBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Gen Buff heap\n");
        } else if (HeapHdl ==  QueBuffHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Que Buff heap\n");
        } else if (HeapHdl ==  NmsChlHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Chl Buff heap\n");
        } else if (HeapHdl ==  CommAssocAssocHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Assoc Buff heap\n");
        } else if (HeapHdl ==  RplWrkItmHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Rpl Work Item heap\n");
        } else if (HeapHdl ==  NmsRpcHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Rpc Work Item heap\n");
        } else if (HeapHdl ==  WinsTmmHeapHdl)
        {
              DBGPRINT0(HEAP_CRDL, "Tmm Work Item heap\n");
        } else
        {
              static DWORD sAdjust = 0;
              DBGPRINT0(HEAP_CRDL, "Catchall Work Item heap\n");
              EnterCriticalSection(&NmsHeapCrtSec);
              if (((NmsHeapCreate - NmsHeapDestroy) == 12) && (NmsCatchAllHeapAlloc > (NmsCatchAllHeapFree + sAdjust)))
              {
                   PWINSTHD_TLS_T  pTls;
                   pTls = TlsGetValue(WinsTlsIndex);
                   if (pTls == NULL)
                   {
                      DBGPRINT1(ERR, "WinsMscHeapDestroy: Could not get  TLS. GetLastError() = (%d)\n", GetLastError());
                   }
                   else
                   {
                      DBGPRINT4(ERR, "WinsMscHeapDestroy: %s thd noticed a mismatch between allocs (%d) and frees (%d). Free count was adjusted by (%d)\n", pTls->ThdName, NmsCatchAllHeapAlloc, NmsCatchAllHeapFree, sAdjust);
                      sAdjust = NmsCatchAllHeapAlloc - NmsCatchAllHeapFree;
                      //system("net send pradeepb MISMATCH");
                   }
              }
              LeaveCriticalSection(&NmsHeapCrtSec);
        }

        DBGPRINT1(HEAP_CRDL, "HeapDestroy: HeapHandle = (%p)\n", HeapHdl);
        EnterCriticalSection(&NmsHeapCrtSec);
        NmsHeapDestroy++;
        LeaveCriticalSection(&NmsHeapCrtSec);
     }
   }
#endif
        return;
} //WinsMscHeapDestroy


VOID
WinsMscTermThd(
   IN  STATUS ExitStatus,
   IN  DWORD  DbSessionExistent
        )

/*++

Routine Description:
        This function is called to terminate the thread.
        The function does the necessary cleanup and exit.

Arguments:
        ExitStatus            - Status to exit with
        DbSessionExistent - indicates whether DB session is existent

Externals Used:
        None


Return Value:
        Thread is exited

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DBGPRINT0(FLOW, "Enter: WinsMscTermThd\n");

        /*
        *  End the database session if it exists.  Decrement the count of
        *  threads.  If it reaches 1, signal the main thread so that it can
        *  terminate itself. At the end terminate yourself.
        *
        */

        //
        // I could enter the critical section after the if block but it is
        // not important.  This way, I get the prints in the right
        // order.
        //
        EnterCriticalSection(&NmsTermCrtSec);
        if (DbSessionExistent == WINS_DB_SESSION_EXISTS)
        {
try {
                if (ExitStatus == WINS_SUCCESS)
                {
                  DBGPRINT0(FLOW, "Ending the db session for thd -- ");
                }
                else
                {
                  DBGPRINT0(ERR, "Ending the db session for thd -- ");
                }
                DBGPRINTNAME;
                DBGPRINT0(FLOW,"\n");

                //for now, we don't check the return value
                NmsDbEndSession();
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsMscTermThd");
 }
        } // end of if block

        //
        // If the total thread count after decrementing is 1, it means
        // that after we exit from this thread, only the main thread
        // will be left.  Let us signal it to inform it of this situation.
        //
        // If the exit status is not success, it means that we have enetered
        // this function as a result of a fatal error/exception.  We need
        // to signal the main thread to kick off the process termination
        //
        if ((--NmsTotalTrmThdCnt == 1) || (ExitStatus != WINS_SUCCESS))
        {
            DBGPRINT1(FLOW, "Signaling the main thread. Exit status = (%x)\n",
                                ExitStatus);
            if (!SetEvent(NmsMainTermEvt))
            {
                WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_SIGNAL_MAIN_THD);

            }
        }

        //
        // If NmsTotalTrmThdCnt reached 1 above, then the main thread will
        // exit invalidating the NmsTermCrtSec.  We may get an INVALID_HANDLE
        // exception.  If we get it, it is ok.
        //
try {
        LeaveCriticalSection(&NmsTermCrtSec);
  }
except(EXCEPTION_EXECUTE_HANDLER) {
    if (GetExceptionCode() == STATUS_INVALID_HANDLE)
    {
        DBGPRINT1(FLOW, "WinsMscTermThd: LAST THREAD. NmsTotalTrmThdCnt = (%d)\n", NmsTotalTrmThdCnt);
    }
    else
    {
        WINS_RERAISE_EXC_M();
    }
   }


        DBGPRINT0(FLOW, "EXITING the thread\n");
        ExitThread(ExitStatus);

        return;
}


VOID
WinsMscSignalHdl(
        IN  HANDLE Hdl
)

/*++

Routine Description:
        This function is a wrapper for the WIN32 SignalEvent function

Arguments:
        Hdl  - Handle to signal

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

    if (!SetEvent(Hdl))
    {
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_SIGNAL_HDL);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }

    return;

}
VOID
WinsMscResetHdl(
        IN  HANDLE Hdl
)

/*++

Routine Description:
        This function is a wrapper for the WIN32 ResetEvent function

Arguments:
        Hdl  - Handle to signal

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        Change to a macro
--*/
{

    if (!ResetEvent(Hdl))
    {
        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_CANT_RESET_HDL);
        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
    }
    return;
}


VOID
WinsMscCloseHdl (
        HANDLE  Hdl
        )

/*++

Routine Description:
        This function is a wrapper for the WIN32 CloseHandle function

Arguments:
        Hdl  - Handle to  close


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        change to a macro
--*/

{

        BOOL fRet;

        fRet = CloseHandle(Hdl);
        if(!fRet)
        {
                DBGPRINT0(ERR, "WinsMscCloseHdl:Could not close handle\n");
                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
            }
            return;


}



HANDLE
WinsMscCreateThd(
        IN  LPTHREAD_START_ROUTINE      pThdInitFn,
        IN  LPVOID                        pParam,
        OUT LPDWORD                        pThdId
        )

/*++

Routine Description:
        This function is a wrapper around the WIN32 Create Thread function

Arguments:
        pThdInitFn        - Thread startup function
        pParam                 - Param to be passed to the startup function
        pThdId                - Thd Id


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        HANDLE ThdHdl;                //Thread handle
        DWORD  Error;

        /*
         * Create a thread with no sec attributes (i.e. it will take the
         * security attributes of the process), and default stack size
        */
        ThdHdl = CreateThread(
                                 NULL,                 /*no sec. attrbutes*/
                                 0,                   /*default stack size*/
                                   pThdInitFn,
                                 pParam,         /*arg*/
                                 0,                 /*run it now*/
                                 pThdId
                                );

        if (ThdHdl == NULL)
        {
          Error = GetLastError();

          DBGPRINT1(ERR, "WinsMscCreateThd: Can not create thread. Error = (%d)\n",
                                Error);
          WINSEVT_LOG_M( Error,  WINS_EVT_CANT_CREATE_THD);
          WINS_RAISE_EXC_M(WINS_EXC_OUT_OF_RSRCS);
        }

        return(ThdHdl);
}

VOID
WinsMscSetThreadPriority(
        HANDLE        ThdHdl,
        int        PrLvl
        )

/*++

Routine Description:
        This function is a wrapper for the "set thread priority" function

Arguments:
        ThdHdl - Handle of thread whose priority needs to be set
        PrLvl  - New Prirority level

Externals Used:
        None

Return Value:

        None
Error Handling:


Called by:
        DoScavenging in nmsscv.c

Side Effects:

Comments:
        None
--*/

{
        BOOL        fRet;
        DWORD   Error;

        //
        // Set the priority
        //
        fRet = SetThreadPriority(
                          ThdHdl,
                          PrLvl
                         );
        if (!fRet)
        {
             Error = GetLastError();
             DBGPRINT1(ERR, "NmsScvInit: Could not lower the priority of the scavanmger thread. Error = (%d)\n", Error);
             WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_UNABLE_TO_CHG_PRIORITY);
             WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
        return;
}



BOOL
WinsMscOpenFile(
        IN   LPTCH                pFileName,
        IN   DWORD                StrType,
        OUT  LPHANDLE                pFileHdl
        )

/*++

Routine Description:
        This is a wrapper for the WIN32 function to open an existing file

Arguments:
        pFileName   - Name of file
        StrType            - Indicates REG_EXPAND_SZ or REG_SZ
        pFileHdl    - handle to file if it could be opened

Externals Used:
        None


Return Value:

   Success status codes -- TRUE
   Error status codes   -- FALSE

Error Handling:

Called by:


Side Effects:

Comments:
        None
--*/

{
        DWORD                    Error;
        SECURITY_ATTRIBUTES SecAtt;
        TCHAR                    ExpandedFileName[WINS_MAX_FILENAME_SZ];
        LPTCH                    pHoldFileName;

        SecAtt.nLength              = sizeof(SecAtt);
        SecAtt.lpSecurityDescriptor = NULL;  //use default security descriptor
        SecAtt.bInheritHandle       = FALSE; //actually don't care


    if (!WinsMscGetName(StrType, pFileName, ExpandedFileName,
                 WINS_MAX_FILENAME_SZ, &pHoldFileName))
    {
            return(FALSE);
    }

        //
        // Open the file for reading and position self to start of the
        // file
        //
        *pFileHdl = CreateFile(
                        pHoldFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        &SecAtt,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0                        //ignored ?? check
                       );

        if (*pFileHdl == INVALID_HANDLE_VALUE)
        {
                WINSEVT_STRS_T        EvtStr;
                EvtStr.NoOfStrs = 1;
                EvtStr.pStr[0] = pHoldFileName;
                Error = GetLastError();

                DBGPRINT1(ERR, "WinsMscOpenFile: Could not open the  file (Error = %d)\n", Error);
FUTURES("Use WINSEVT_LOG_STR_M.  Make sure it takes TCHAR instead of CHAR")
                WINSEVT_LOG_STR_M(WINS_EVT_FILE_ERR, &EvtStr);

                return(FALSE);
        }
        return(TRUE);
 }


BOOL
WinsMscMapFile(
        IN OUT PWINSPRS_FILE_INFO_T   pFileInfo
        )

/*++

Routine Description:
        This function maps a file into allocated memory

Arguments:
        FileHdl    - Handle to the file
        pFileInfo  - Address of buffer into which the file was mapped

Externals Used:
        None


Return Value:

   Success status codes -- TRUE
   Error status codes   -- FALSE

Error Handling:

Called by:

Side Effects:

Comments:
        Note: The function returns an error if te file is more than
       2**32 bytes in size
--*/

{
        DWORD  HighWordOfFSz = 0;
        DWORD  Error;
        DWORD  cBytesRead;
        BOOL   fRetVal = FALSE;
try {
        //
        // get the size of the file so that we can allocate enough memory
        // to read the file in
        //
        pFileInfo->FileSize = GetFileSize(pFileInfo->FileHdl, &HighWordOfFSz);

        if (HighWordOfFSz)
        {
                DBGPRINT1(ERR, "WinsMscMapFile: File too big. High word of size is (%x)\n", HighWordOfFSz);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_FILE_TOO_BIG);
                fRetVal = FALSE;

        }
        else
        {
                //
                // if the low word of size is 0xFFFFFFFF either it is a valid
                // size or it is an error.  Check it
                //
                if (pFileInfo->FileSize == 0xFFFFFFFF)
                {
                        Error = GetLastError();
                        if (Error != NO_ERROR)
                        {
                                DBGPRINT1(ERR, "WinsMscMapFile: Error from GetFileSz = (%d)\n", Error);
                                WINSEVT_LOG_M(Error, WINS_EVT_FILE_ERR);
                                fRetVal = FALSE;
                        }
                }
                else
                {
                        //
                        // Allocate a buffer to hold the contents of the file
                        //
                        WinsMscAlloc(
                                        pFileInfo->FileSize,
                                        &pFileInfo->pFileBuff
                                    );
                        pFileInfo->pLimit = pFileInfo->pFileBuff +
                                                pFileInfo->FileSize;

                        fRetVal = ReadFile(
                                        pFileInfo->FileHdl,
                                        pFileInfo->pFileBuff,
                                        pFileInfo->FileSize,
                                        &cBytesRead,
                                        NULL
                                         );
                        if (!fRetVal)
                        {
                                DBGPRINT1(ERR,
        "WinsMscMapFile: Error reading file (Error = %d)\n", GetLastError());
                                WinsMscDealloc(pFileInfo->pFileBuff);
                        }

                }
        }
 }   // end of try ...
 except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsMscParse");
        }
        //
        // close the file
        //
        if (!CloseHandle(pFileInfo->FileHdl))
        {
                Error = GetLastError();
                DBGPRINT1(ERR, "WinsMscMapFile: Could not close the file (Error = %d)\n", Error);
        }
#ifdef WINSDBG
        else
        {
                DBGPRINT0(DET, "WinsMscMapFile: Closed handle to open file\n");
        }
#endif

   return(fRetVal);
}

VOID
WinsMscLogEvtStrs(
    LPBYTE          pAscii,
    DWORD           Evt,
    BOOL            fInfo
   )

{

        WINSEVT_STRS_T  EvtStrs;
        WCHAR String[NMSDB_MAX_NAM_LEN];
        EvtStrs.NoOfStrs = 1;
        (VOID)WinsMscConvertAsciiStringToUnicode(
                        pAscii,
                        (LPBYTE)String,
                        NMSDB_MAX_NAM_LEN);
         EvtStrs.pStr[0] = String;
         if (!fInfo)
         {
            WINSEVT_LOG_STR_M(Evt, &EvtStrs);
         }
         else
         {
            WINSEVT_LOG_INFO_STR_D_M(Evt, &EvtStrs);
         }

         return;
}

VOID
WinsMscConvertUnicodeStringToAscii(
        LPBYTE pUnicodeString,
        LPBYTE pAsciiString,
        DWORD  MaxSz
        )
{
        WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pUnicodeString, -1,
                                pAsciiString, MaxSz, NULL,
                                NULL);
        return;
}
VOID
WinsMscConvertAsciiStringToUnicode(
        LPBYTE pAsciiString,
        LPBYTE pUnicodeString,
        DWORD  MaxSz
        )
{
     MultiByteToWideChar(CP_ACP, 0, pAsciiString, -1,
                                              (LPWSTR)pUnicodeString, MaxSz);

        return;
}

BOOL
WinsMscGetName(
   DWORD    StrType,
   LPTSTR   pFileName,
   LPTSTR   pExpandedFileName,
   DWORD    ExpandedFileNameBuffLen,
   LPTSTR   *ppHoldFileName
  )
{
    DWORD ChInDest;

        if (StrType == REG_EXPAND_SZ)
        {
                ChInDest = ExpandEnvironmentStrings(
                                pFileName,
                                pExpandedFileName,
                                ExpandedFileNameBuffLen);

                if (ChInDest == 0)
                {
                        WINSEVT_STRS_T        EvtStr;
                        EvtStr.NoOfStrs = 1;
                        EvtStr.pStr[0] = pFileName;
                        DBGPRINT2(ERR, "WinsPrsDoStaticInit: Could not expand environment strings in (%s). Error is (%d)\n", pFileName, (DWORD)GetLastError());
                        WINSEVT_LOG_STR_M(WINS_EVT_FILE_ERR, &EvtStr);
                        return(FALSE);
                }
                //
                // If only part of the expanded name could be stored, log error
                //
                if (ChInDest > ExpandedFileNameBuffLen)
                {
                        WINSEVT_STRS_T        EvtStr;
                        EvtStr.NoOfStrs = 1;
                        EvtStr.pStr[0] = pFileName;
                        DBGPRINT2(ERR, "WinsPrsDoStaticInit: File name after expansion is just too big (%d> 255).\nThe name to be expanded is (%s))", ChInDest, pFileName);
                        WINSEVT_LOG_STR_M(WINS_EVT_FILE_NAME_TOO_BIG, &EvtStr);
                        return(FALSE);
                }
                *ppHoldFileName = pExpandedFileName;
        }
        else
        {
                //
                // There were no env. var. to expand
                //
                *ppHoldFileName = pFileName;
        }
    return(TRUE);
}


VOID
WinsMscSendControlToSc(
  DWORD ControlCode
)
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
  SERVICE_STATUS ServiceStatus;
  BOOL  fStatus;
  SC_HANDLE ScHdl;
  SC_HANDLE SvcHdl;
  BOOL  sCalled = FALSE;

try {
  ScHdl = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
  if (ScHdl == NULL)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from OpenSCManager\n", GetLastError());
    return;
  }

  SvcHdl = OpenService(ScHdl, WINS_SERVER, SERVICE_ALL_ACCESS);
  if (SvcHdl == NULL)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from OpenService\n", GetLastError());
    goto CLOSE_SC;
  }

  fStatus =  ControlService(SvcHdl, ControlCode, &ServiceStatus);
  if (!fStatus)
  {
    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from ControlService\n", GetLastError());
    goto CLOSE_SERVICE;
  }
  else
  {
    DBGPRINT1(FLOW, "WinsMscSendControlToSc: Current State is (%d)\n",
          ServiceStatus.dwCurrentState);

  }
CLOSE_SERVICE:
  fStatus = CloseServiceHandle(SvcHdl);
  if (!fStatus)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from CloseServiceHandle called for service\n", GetLastError());
  }

CLOSE_SC:
  fStatus = CloseServiceHandle(ScHdl);
  if (!fStatus)
  {

    DBGPRINT1(ERR, "WinsMscSendControlToSc: Error (%d) from CloseServiceHandle called for SC\n", GetLastError());
  }
 }
 except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("WinsMscSendControlToSc");
 }
  return;
}

unsigned
WinsMscPutMsg(
  unsigned usMsgNum,
  ... )

/*++

Routine Description:
    Displays a message

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    //unsigned msglen;
    //va_list arglist;
    //LPVOID  pMsg;
    //HINSTANCE hModule;

    DBGENTER("WinsMscPutMsg\n");

    //--ft: #106568 - WINS is a service and it shouldn't pop up message boxes.
    //--this is mostly annoying for cluster: in case the db. is corrupted WINS is popping the message wnd
    //--and does not terminate (at least the process wins.exe will be there for as long as the dialog is
    //--on the screen. This will prevent the cluster from bringing up WINS resource on the same node.
    //--In case of such a failure, the event being logged (in system log) should suffice.
    //
    //if ((hModule = LoadLibrary(TEXT("winsevnt.dll")))==NULL)
    //{
    //    DBGPRINT1(ERR, "WinsMscPutMsg: LoadLibrary(\"winsevnt.dll\") failed with error = (%d)\n.", GetLastError());
    //    return 0;
    //}
    //va_start(arglist, usMsgNum);
    //if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
    //      FORMAT_MESSAGE_FROM_HMODULE,
    //      hModule,
    //      usMsgNum,
    //      0L,       // Default country ID.
    //      (LPTSTR)&pMsg,
    //      0,
    //      &arglist)))
    //{
    //   DBGPRINT1(ERR, "WinsMscPutMsg: FormatMessage failed with error = (%d)\n",
    //        GetLastError());
    //}
    //else
    //{

    //  DBGPRINT0(DET, "WinsMscPutMsg: Putting up the message box\n");
    //  if(MessageBoxEx(NULL, pMsg, WINS_SERVER_FULL_NAME, MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0)
    //  {
    //     DBGPRINT1(ERR, "WinsMscPutMsg: MessageBoxEx failed with error = (%d)\n", GetLastError());

    //  }
    //  LocalFree(pMsg);
    //}

    //FreeLibrary(hModule);

    WINSEVT_LOG_M(WINS_FAILURE, usMsgNum);
    DBGLEAVE("WinsMscPutMsg\n");

    //return(msglen);
    return 0;
}

LPTSTR
WinsMscGetString(
  DWORD StrId
  )

/*++

Routine Description:
    This routine retrieves string corresponding to strid from the resource file.

Arguments:

    StrId - The unique id of the string.

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
    unsigned msglen;
    va_list arglist;
    LPTSTR  pMsg = NULL;
    HINSTANCE hModule;

    DBGENTER("WinsMscPutMsg\n");

    if ((hModule = LoadLibrary(TEXT("winsevnt.dll"))) == NULL)
    {
        DBGPRINT1(ERR, "LoadLibrary(\"winsevnt.dll\") failed with error = (%d)\n",
            GetLastError());
        return NULL;
    }

    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_HMODULE,
          hModule,
          StrId,
          0L,       // Default country ID.
          (LPTSTR)&pMsg,
          0,
          NULL)))
    {
       DBGPRINT1(ERR, "WinsMscPutMsg: FormatMessage failed with error = (%d)\n",
            GetLastError());
    }

    FreeLibrary(hModule);
    DBGLEAVE("WinsMscPutMsg\n");

    return(pMsg);
}

VOID
WinsMscChkTermEvt(
#ifdef WINSDBG
               WINS_CLIENT_E  Client_e,
#endif
               BOOL            fTermTrans
 )

/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        Currently (8/6/94), fTermTrans is set only by the scavenger thread
--*/

{
     DWORD fSignaled;
        /*
         *  We may have been signaled by the main thread
         *  Check it.
         */
        WinsMscWaitTimed(
                             NmsTermEvt,
                             0,              //timeout is 0
                             &fSignaled
                        );

        if (fSignaled)
        {
                   DBGPRINT1(DET, "WinsCnfChkTermEvt: %s thread got termination signal\n", Client_e == WINS_E_RPLPULL ? "PULL" : "SCV");

                   if (fTermTrans)
                   {
                       NmsDbEndTransaction(); //ignore return code
                   }
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        }

     return;
}

VOID
WinsMscDelFiles(
  BOOL   fMultiple,
  LPCTSTR pFilePattern,
  LPTSTR  pFilePath
 )
{
    DWORD ErrCode;
#ifdef WINSDBG
   BYTE  FileNameAscii[WINS_MAX_FILENAME_SZ];
#endif
   DBGENTER("WinsMscDelFiles\n");
   if (fMultiple)
   {
        WIN32_FIND_DATA FileInfo;
        HANDLE          SearchHandle;
        TCHAR           FullFilePath[WINS_MAX_FILENAME_SZ];

        //
        // Construct the full file pattern
        //
        lstrcpy(FullFilePath, pFilePath);
        lstrcat(FullFilePath, L"\\");
        lstrcat(FullFilePath, pFilePattern);

        SearchHandle = FindFirstFile(FullFilePath, &FileInfo);
        if (SearchHandle == INVALID_HANDLE_VALUE)
        {
             DBGPRINT1(ERR, "WinsMscDelFiles: FindFirstFile returned error = (%d)\n", GetLastError());
             return;
        }

        do {
             //
             // construct the full file path
             //
             lstrcpy(FullFilePath, pFilePath);
             lstrcat(FullFilePath, L"\\");
             lstrcat(FullFilePath, FileInfo.cFileName);

#ifdef WINSDBG
             WinsMscConvertUnicodeStringToAscii((LPBYTE)FullFilePath, FileNameAscii, sizeof(FileNameAscii));
             DBGPRINT1(DET, "WinsMscDelFiles: Deleting %s ..\n", FileNameAscii);

#endif
             if (!DeleteFile(FullFilePath))
             {
               DBGPRINT1(ERR, "WinsMscDelFiles: DeleteFile returned error = (%d)\n", GetLastError());
                FindClose(SearchHandle);
                return;
             }

        } while(FindNextFile(SearchHandle, &FileInfo));
        if ((ErrCode = GetLastError()) != ERROR_NO_MORE_FILES)
        {
               DBGPRINT1(ERR, "WinsMscDelFiles: FindNextFile returned error = (%d)\n", ErrCode);

        }
        if (!FindClose(SearchHandle))
        {
               DBGPRINT1(ERR, "WinsMscDelFiles: FindClose returned error = (%d)\n", ErrCode);
        }

   }
   else
   {
             if (!DeleteFile(pFilePattern))
             {
               DBGPRINT1(ERR, "WinsMscDelFiles: DeleteFile returned error = (%d)\n", GetLastError());
                return;
             }
   }

   DBGLEAVE("WinsMscDelFiles\n");
   return;
}

VOID
WinsMscHeapReAlloc(
    IN   HANDLE   HeapHdl,
        IN   DWORD    BuffSize,
        OUT  LPVOID  *ppRspBuff
        )


/*++

Routine Description:
        This function is called to allocate memory.


Arguments:
        BuffSize  - Size of buffer to allocate
        ppRspBuff - Buffer allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:

        NmsDbGetDataRecs, GetGroupMembers
Side Effects:

Comments:
        None
--*/

{

        *ppRspBuff = HeapReAlloc(
                   HeapHdl,
                   HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
                   *ppRspBuff,
                   BuffSize
                            );
   DBGPRINT3(HEAP, "WinsMscHeapReAlloc: HeapHdl = (%p), pStartBuff = (%p), BuffSize = (%d)\n", HeapHdl, *ppRspBuff, BuffSize);


        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winsintf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winsintf.c

Abstract:
        This module contains the RPC interface to the WINS server

Functions:
        R_WinsRecordAction
        R_WinsStatus
        R_WinsTrigger
        R_WinsDoStaticInit
        R_WinsGetDbRecs
        R_WinsDelDbRecs
        R_WinsSetProcPriority
        WinsRecordAction
        GetWinsStatus
        WinsTrigger
        WinsDoStaticInit
        WinsDoScavenging
        WinsGetDbRecs
        WinsDelDbRecs
        WinsSetProcPriority
        sGetVersNo
        GetConfig
        GetStatistics


Portability:

        This module is portable


Author:

        Pradeep Bahl (PradeepB)          Mar-1993

Revision History:

        Modification date        Person          Description of modification
        -----------------        -------         ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include <lmerr.h>
#include <lmcons.h>                //defines NET_API_STATUS
#include <secobj.h>
#include <rpcutil.h>                //for NetpRevertToSelf
#include <rpcndr.h>
#include "winsif.h"
#include "winsi2.h"
#include "winsintf.h"
#include "comm.h"
#include "winsque.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsmsgf.h"
#include "nmsdb.h"
#include "nmsscv.h"
#include "rpl.h"
#include "rplpull.h"
#include "winscnf.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winsprs.h"
#include "winstmm.h"
#ifdef WINSDBG
#include "winbasep.h"
#endif

/*
 *        Local Macro Declarations
 */

#if SECURITY > 0
#define  CHK_ACCESS_LEVEL_M(_access)        {                          \
                   if (!sfBS)                                   \
                   {                                            \
                        NET_API_STATUS NetStatus;               \
                        NetStatus = NetpAccessCheckAndAudit(    \
                                        WINS_SERVER,            \
                                        WINS_SERVER,            \
                                        pNmsSecurityDescriptor, \
                                        _access,    \
                                        &NmsInfoMapping         \
                                        );                      \
                        if (NetStatus != NERR_Success)          \
                        {                                       \
                                DBGPRINT1(ERR, "The Caller of the rpc function does not have the required permissions. NetSTatus is (%d)\n", NetStatus);   \
                                WINSEVT_LOG_M(NetStatus, WINS_EVT_NO_PERM);\
                                return(NetStatus);              \
                        }                                       \
                  }                                             \
        }

#else
#define  CHK_ACCESS_LEVEL_M()
#endif

#define INC_RPC_DB_COUNT_NCHK_M    {                         \
                     EnterCriticalSection(&NmsTermCrtSec);   \
                     NmsTotalTrmThdCnt++;                  \
                     LeaveCriticalSection(&NmsTermCrtSec);   \
           }
#define INC_RPC_DB_COUNT_M    {                              \
              if (WinsCnf.State_e != WINSCNF_E_TERMINATING)  \
              {                                              \
                     INC_RPC_DB_COUNT_NCHK_M;                \
              }                                              \
              else                                           \
              {                                              \
                     return(WINSINTF_FAILURE);               \
              }                                              \
           }
#define DEC_RPC_DB_COUNT_M    {                              \
              EnterCriticalSection(&NmsTermCrtSec);          \
              if (--NmsTotalTrmThdCnt == 1)                  \
              {                                              \
                   DBGPRINT0(FLOW, "RPC thread: Signaling the main thread\n");\
                   SetEvent(NmsMainTermEvt);                 \
              }                                              \
              LeaveCriticalSection(&NmsTermCrtSec);          \
           }
/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */
WINSINTF_STAT_T        WinsIntfStat = {0};

DWORD                WinsIntfNoOfNbtThds;
DWORD                WinsIntfNoCncrntStaticInits = 0;
//DWORD                WinsIntfNoOfRpcThds = 0;
CRITICAL_SECTION WinsIntfCrtSec;

CRITICAL_SECTION WinsIntfPotentiallyLongCrtSec;
CRITICAL_SECTION WinsIntfNoOfUsersCrtSec;  //extern in nms.h

/*
 *        Local Variable Definitions
*/
STATIC  BOOL    sfBS = FALSE;

//
// Time interval between reflushing of the 1B cache
//
#define THREE_MTS 180

//
// Used by WinsGetBrowserNames
//
DOM_CACHE_T sDomCache = { 0, NULL, 0, 0, NULL, FALSE};

/*
 *        Local Function Prototype Declarations
 */
DWORD
GetWinsStatus(
   IN  WINSINTF_CMD_E          Cmd_e,
   OUT LPVOID  pResults,
   BOOL fNew
        );

STATIC
DWORD
sGetVersNo(
        LPVOID  pResults
        );

STATIC
DWORD
GetStatistics(
        LPVOID  pResults,
        BOOL  fNew
        );

STATIC
DWORD
GetConfig(
        LPVOID   pResults,
        BOOL     fNew,
        BOOL     fAllMaps
        );

VOID
LogClientInfo(
        RPC_BINDING_HANDLE ClientHdl,
        BOOL               fAbruptTerm
  );


STATIC
STATUS
PackageRecs(
        PRPL_REC_ENTRY2_T     pBuff,
        DWORD                BuffLen,
        DWORD                NoOfRecs,
        PWINSINTF_RECS_T     pRecs
     );


//
// Function definitions start here
//

DWORD
R_WinsCheckAccess(
    WINSIF2_HANDLE        ServerHdl,
    DWORD                 *Access
    )
{
    NET_API_STATUS NetStatus;
    *Access = WINS_NO_ACCESS;
    NetStatus = NetpAccessCheckAndAudit(
                    WINS_SERVER,
                    WINS_SERVER,
                    pNmsSecurityDescriptor,
                    WINS_CONTROL_ACCESS,
                    &NmsInfoMapping
                    );
    if (NERR_Success == NetStatus) {
        *Access = WINS_CONTROL_ACCESS;
        return WINSINTF_SUCCESS;
    }
    NetStatus = NetpAccessCheckAndAudit(
                    WINS_SERVER,
                    WINS_SERVER,
                    pNmsSecurityDescriptor,
                    WINS_QUERY_ACCESS,
                    &NmsInfoMapping
                    );
    if (NERR_Success == NetStatus) {
        *Access = WINS_QUERY_ACCESS;
        return WINSINTF_SUCCESS;
    }
    return WINSINTF_SUCCESS;
}

DWORD
R_WinsRecordAction(
        PWINSINTF_RECORD_ACTION_T        *ppRecAction
        )

/*++

Routine Description:
        This function is called to insert/update/delete a record

Arguments:
        pRecAction - Record Information

Externals Used:
        None

Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

  DWORD                Status = WINSINTF_FAILURE;

PERF("Use & and || logic")

  if (*ppRecAction == NULL)
  {
       return(Status);
  }
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
          if (WINSINTF_E_QUERY == (*ppRecAction)->Cmd_e) {
              CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
          } else {
              CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
          }
          INC_RPC_DB_COUNT_NCHK_M;
try {
          Status = WinsRecordAction(ppRecAction);
}
finally {
          DEC_RPC_DB_COUNT_M;
}
  }

  return(Status);
}


DWORD
R_WinsStatusWHdl (
   WINSIF_HANDLE             pWinsHdl,
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_NEW_T  pResults
        )
{
    return(R_WinsStatusNew(Cmd_e, pResults));

}

DWORD
R_WinsStatus (
  // LPTSTR                pWinsAddStr,
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_T  pResults
        )
{

  DWORD                Status = WINSINTF_FAILURE;

  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
     CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
     Status = GetWinsStatus(/*pWinsAddStr,*/Cmd_e, pResults, FALSE);
  }
  return(Status);
}
DWORD
R_WinsStatusNew (
   WINSINTF_CMD_E          Cmd_e,
   PWINSINTF_RESULTS_NEW_T     pResults
        )
{

  DWORD                Status = WINSINTF_FAILURE;

  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
     CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
     Status = GetWinsStatus(Cmd_e, pResults, TRUE);
  }
  return(Status);
}

DWORD
R_WinsTrigger (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_TRIG_TYPE_E          TrigType_e
        )
{
  DWORD                Status = WINSINTF_FAILURE;
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
        CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
          Status = WinsTrigger(pWinsAdd, TrigType_e);
  }
  return(Status);
}

DWORD
R_WinsDoStaticInit (
        LPWSTR         pDataFilePath,
        DWORD          fDel
        )
{
  DWORD                Status;

  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  EnterCriticalSection(&WinsIntfCrtSec);

  //
  // The admin tool can go haywire and create a lot of threads.  Limit it
  // to a certain max value. The value will be incremented and decremented
  // by the thread doing the STATIC initialization.
  //
  if (WinsIntfNoCncrntStaticInits > WINSCNF_MAX_CNCRNT_STATIC_INITS)
  {
          LeaveCriticalSection(&WinsIntfCrtSec);
    DBGPRINT1(ERR, "R_WinsDoStaticInit: Too many concurrent STATIC inits. No is (%d)\n", WinsIntfNoCncrntStaticInits);
    WINSEVT_LOG_D_M(WinsIntfNoCncrntStaticInits, WINS_EVT_TOO_MANY_STATIC_INITS);
        return(WINSINTF_TOO_MANY_STATIC_INITS);
  }
  LeaveCriticalSection(&WinsIntfCrtSec);
  Status = WinsDoStaticInit(pDataFilePath, fDel);
  return(Status);
}

DWORD
R_WinsDoScavenging (
        VOID
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDoScavenging();
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsDoScavengingNew (
        PWINSINTF_SCV_REQ_T  pScvReq
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDoScavengingNew(pScvReq);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsGetDbRecs (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_VERS_NO_T          MinVersNo,
        WINSINTF_VERS_NO_T          MaxVersNo,
        PWINSINTF_RECS_T          pRecs
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
#if 0
#ifdef WINSDBG
   PVOID pCallersAdd, pCallersCaller;
   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
   DbgPrint("Callers Address = (%x)\nCallersCaller = (%x)\n", pCallersAdd, pCallersCaller);

#endif
#endif
  Status = WinsGetDbRecs(pWinsAdd, MinVersNo, MaxVersNo, pRecs);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}
DWORD
R_WinsGetDbRecsByName (
        PWINSINTF_ADD_T             pWinsAdd,
        DWORD                       Location,
        LPBYTE                      pName,
        DWORD                       NameLen,
        DWORD                       NoOfRecsDesired,
        DWORD                       fStaticOnly,
        PWINSINTF_RECS_T            pRecs
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_QUERY_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
#if 0
#ifdef WINSDBG
   PVOID pCallersAdd, pCallersCaller;
   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
#endif
#endif
  Status = WinsGetDbRecsByName(pWinsAdd, Location, pName, NameLen, NoOfRecsDesired,
                   fStaticOnly, pRecs);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}



DWORD
R_WinsDeleteWins(
        PWINSINTF_ADD_T   pWinsAdd
        )
{
  DWORD                Status;
  //LogClientInfo();
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDeleteWins(pWinsAdd);
}
finally {
  DEC_RPC_DB_COUNT_M;
}
  return(Status);
}

DWORD
R_WinsTerm (
        handle_t                ClientHdl,
        short                        fAbruptTerm
        )
{
  DWORD                Status;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsTerm(ClientHdl, fAbruptTerm);
  LogClientInfo(ClientHdl, fAbruptTerm);
  return(Status);
}


DWORD
R_WinsBackup (
   LPBYTE                pBackupPath,
   short                fIncremental
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  BYTE                BackupPath[WINS_MAX_FILENAME_SZ + sizeof(WINS_BACKUP_DIR_ASCII)];
#if 0
  (VOID)WinsMscConvertUnicodeStringToAscii(pBackupPath, BackupPath, WINS_MAX_FILENAME_SZ);
#endif
FUTURES("expensive.  Change idl prototype to pass length")
   if (strlen(pBackupPath) > WINS_MAX_FILENAME_SZ)
   {
         return(Status);
   }
  //
  // Make sure that the WINS is in steady state
  //
PERF("Use & and || logic")
  if ((WinsCnf.State_e == WINSCNF_E_RUNNING) || (WinsCnf.State_e == WINSCNF_E_PAUSED))
  {
      CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
      INC_RPC_DB_COUNT_NCHK_M;
      WinsLogAdminEvent( WINS_EVT_ADMIN_BACKUP_INITIATED, 0 );
try {
      strcpy(BackupPath, pBackupPath);
      strcat(BackupPath, WINS_BACKUP_DIR_ASCII);
      if (CreateDirectoryA(BackupPath, NULL) || ((Status = GetLastError()) ==
                                                    ERROR_ALREADY_EXISTS))
      {
         Status = WinsBackup(BackupPath, fIncremental);
      }
}
finally {
      DEC_RPC_DB_COUNT_M;
}
  }
  return(Status);
}

DWORD
R_WinsDelDbRecs(
        IN PWINSINTF_ADD_T        pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsDelDbRecs(pAdd, MinVersNo, MaxVersNo);
}
finally {
   DEC_RPC_DB_COUNT_M;
   }
  return(Status);
}

DWORD
R_WinsTombstoneDbRecs(
        IN WINSIF2_HANDLE            ServerHdl,
        IN PWINSINTF_ADD_T           pWinsAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  INC_RPC_DB_COUNT_M;
try {
  Status = WinsTombstoneDbRecs(pWinsAdd, MinVersNo, MaxVersNo);
}
finally {
   DEC_RPC_DB_COUNT_M;
   }
  return(Status);
}

DWORD
R_WinsPullRange(
        IN PWINSINTF_ADD_T        pAdd,
        IN PWINSINTF_ADD_T        pOwnerAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsPullRange(pAdd, pOwnerAdd, MinVersNo, MaxVersNo);
  return(Status);
}

DWORD
R_WinsSetPriorityClass(
        IN WINSINTF_PRIORITY_CLASS_E        PriorityClass
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsSetPriorityClass(PriorityClass);
  return(Status);
}

DWORD
R_WinsResetCounters(
        VOID
        )
{

  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsResetCounters();
  return(Status);
}

DWORD
R_WinsWorkerThdUpd(
        DWORD NewNoOfNbtThds
        )
{
  DWORD                Status = WINSINTF_FAILURE;
  CHK_ACCESS_LEVEL_M(WINS_CONTROL_ACCESS);
  Status = WinsWorkerThdUpd(NewNoOfNbtThds);
  return(Status);
}

DWORD
R_WinsGetNameAndAdd(
        PWINSINTF_ADD_T   pWinsAdd,
        LPBYTE                  pUncName
        )
{
  DWORD                Status = WINSINTF_FAILURE;
  //CHK_ACCESS_LEVEL_M();
  Status = WinsGetNameAndAdd(pWinsAdd, pUncName);
  return(Status);
}

DWORD
R_WinsGetBrowserNames_Old(
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{
  return(WINSINTF_FAILURE);
}



DWORD
R_WinsGetBrowserNames(
        WINSIF_HANDLE             pWinsHdl,
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{
  DWORD                Status = WINSINTF_FAILURE;

  static DWORD    sNoOfReq = 0;

  //
  // Allow access to anybody.  We don't check access here since
  // browser running as a service has zero access when it goes
  // on the network (It goes under the null account -- CliffVDyke 4/15/94)
  //
  INC_RPC_DB_COUNT_M;
  EnterCriticalSection(&WinsIntfPotentiallyLongCrtSec);
try {
  if (sNoOfReq++ < NMS_MAX_BROWSER_RPC_CALLS)
  {
    Status = WinsGetBrowserNames((PWINSINTF_BIND_DATA_T)pWinsHdl,pNames);
  }
  else
  {
        pNames->EntriesRead = 0;
        pNames->pInfo = NULL;
        Status = WINSINTF_FAILURE;
  }
 } // end of try
finally {
  sNoOfReq--;

  //
  //  increment the user count.
  //
  EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);
  sDomCache.NoOfUsers++;
  LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);

  LeaveCriticalSection(&WinsIntfPotentiallyLongCrtSec);
  DEC_RPC_DB_COUNT_M;

 }
  return(Status);
}


DWORD
R_WinsSetFlags (
        DWORD    fFlags
        )
{
  DWORD                Status = WINSINTF_SUCCESS;

  Status = WinsSetFlags(fFlags);
  return(Status);
}

DWORD
WinsSetFlags (
        DWORD    fFlags
        )
{
  DWORD                Status = WINSINTF_SUCCESS;
#ifdef WINSDBG
  DWORD                DbgFlagsStore = WinsDbg;
  SYSTEMTIME           SystemTime;
  BOOL                 sHaveProcessHeapHdl = FALSE;
  HANDLE               PrHeapHdl;

  typedef struct _HEAP_INFO_T {
     HANDLE HeapHdl;
     LPBYTE cstrHeapType;
     } HEAP_INFO_T, *PHEAP_INFO_T;

#define PRINT_TIME_OF_DUMP_M(SystemTime, Str)  {DBGPRINT5(SPEC, "Activity: %s done on %d/%d at %d.%d \n", Str, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute); }

#endif

  //sfBS = fFlags & WINSINTF_BS;

  DBGPRINT2(ERR, "WinsSetFlags: NmsDbDelDelDataRecs = (%d)\nNmsDbDelQueryNUpdRecs = (%d)\n", NmsDbDelDelDataRecs, NmsDbDelQueryNUpdRecs);

#ifdef WINSDBG
  if (!sHaveProcessHeapHdl)
  {
    PrHeapHdl = GetProcessHeap();
  }
  GetSystemTime(&SystemTime);
  WinsDbg |= DBG_SPEC;
  if (fFlags & WINSINTF_MEMORY_INFO_DUMP)
  {
     MEMORYSTATUS Mem;
     static SIZE_T  sLTVmUsed = 0;
     SIZE_T VmUsed;

     DBGPRINT0(SPEC, "\n\n------------------MEMORY USAGE INFO-----------------\n\n");
     GlobalMemoryStatus(&Mem);

     VmUsed = Mem.dwTotalVirtual - Mem.dwAvailVirtual;
     DBGPRINT2(SPEC, "VM used = (%d)\nDiff. from last time = (%d)\n", VmUsed,
         VmUsed - sLTVmUsed);
     sLTVmUsed = VmUsed;

  }
  EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
  if (fFlags & WINSINTF_HEAP_INFO_DUMP)
  {
      HEAP_INFO_T HeapHdls[] = {
             CommUdpBuffHeapHdl,    "Udp Buff Heap",
             CommUdpDlgHeapHdl,      "Udp Dlg Heap",
             CommAssocDlgHeapHdl,    "Tcp Dlg Heap",
             CommAssocTcpMsgHeapHdl, "Tcp Msg Heap",
             GenBuffHeapHdl,         "General Heap",
             QueBuffHeapHdl,         "Que Wrk. Item Heap",
             NmsChlHeapHdl,           "Chl Req/Resp Heap",
             CommAssocAssocHeapHdl,   "Assoc. Msg Heap",
             RplWrkItmHeapHdl,        "Rpl Wrk Itm Heap",
             NmsRpcHeapHdl,           "Rpc Buff Heap",
             WinsTmmHeapHdl,          "Tmm Buff Heap",
             (LPHANDLE)NULL,                    NULL
                            };
     static SIZE_T sDiffLTHeapTotalANF[sizeof(HeapHdls)/sizeof(HEAP_INFO_T)] = {0};
     static SIZE_T sHeapTotalANF[sizeof(HeapHdls)/sizeof(HEAP_INFO_T)] = {0};
     SIZE_T  Size2;
     static SIZE_T  sTotalAllocNFree = 0;
     static SIZE_T  LastTimeTotalAllocNFree = 0;
//     NTSTATUS  Status;
     HANDLE  HeapHdl;
     DWORD  i, n;
     DWORD dwNumberOfHeaps;
     PHANDLE pPrHeaps;
     HEAP_SUMMARY heapSummary;

     PRINT_TIME_OF_DUMP_M(SystemTime, "HEAP DUMP");
     dwNumberOfHeaps = GetProcessHeaps(0, NULL);
     Size2 = sizeof(*pPrHeaps) * dwNumberOfHeaps;
     pPrHeaps = WinsMscHeapAlloc( NmsRpcHeapHdl, (ULONG)Size2);
     dwNumberOfHeaps = GetProcessHeaps(dwNumberOfHeaps, pPrHeaps);

     DBGPRINT1(SPEC, "No Of Heaps is (%d)\n",  dwNumberOfHeaps);
     DBGPRINT1(SPEC, "Process default heap handle is (%p)\n",  PrHeapHdl);
     LastTimeTotalAllocNFree = sTotalAllocNFree;
     sTotalAllocNFree = 0;
     heapSummary.cb = sizeof(HEAP_SUMMARY);
     for (i=0; i< dwNumberOfHeaps; i++)
     {
        DBGPRINT0(SPEC, "----------Heap Info--------------------------\n");
        DBGPRINT0(SPEC, "Heap -- ");

        HeapHdl = pPrHeaps[i];
        for (n = 0;  HeapHdls[n].HeapHdl != NULL; n++)
        {
            if (HeapHdl == HeapHdls[n].HeapHdl)
            {
              DBGPRINT1(SPEC, "%s\n", HeapHdls[n].cstrHeapType);
              break;
            }
        }
        if (HeapHdls[n].HeapHdl == NULL)
        {

            DBGPRINT0(SPEC, "Catch all Heap\n");
        }

        DBGPRINT1(SPEC, "Heap Hdl = (%p)\n", HeapHdl);
        if (HeapSummary(HeapHdl, 0, &heapSummary))
        {
           DBGPRINT2(SPEC,"Total Allocated = (%d)\nTotalFree = (%d)\n",
                        heapSummary.cbAllocated, heapSummary.cbCommitted - heapSummary.cbAllocated);
        }
        else
        {
           DBGPRINT0(SPEC,"COULD NOT GET HEAP INFO\n");
           continue;
        }



        sDiffLTHeapTotalANF[n] = heapSummary.cbCommitted - sHeapTotalANF[n];
        sHeapTotalANF[n] = heapSummary.cbCommitted;
        sTotalAllocNFree += sHeapTotalANF[n];
        DBGPRINT1(SPEC, "Size allocated from RpcHeap is  (%d)\n", Size2);
     } // end of for looping over process heaps

     DBGPRINT0(SPEC, "\n----------Heap Info End --------------------------\n");
     WinsMscHeapFree(NmsRpcHeapHdl, pPrHeaps);

     for (n = 0;  HeapHdls[n].HeapHdl != NULL; n++)
     {
              DBGPRINT3(SPEC, "%s -- Total AllocNFree = (%d); Diff from Last time = (%d)\n",
                      HeapHdls[n].cstrHeapType, sHeapTotalANF[n],
                      sDiffLTHeapTotalANF[n]
                      );
     }
     DBGPRINT2(SPEC, "\nTotal Process AllocNFree = (%d)\nDiff from last time = (%d)\n\n",  sTotalAllocNFree, sTotalAllocNFree - LastTimeTotalAllocNFree);

     if (WinsDbg & (DBG_HEAP_CNTRS | DBG_UPD_CNTRS))
     {
        NmsPrintCtrs();
     }
    }
    if (fFlags & WINSINTF_QUE_ITEMS_DUMP)
    {
       typedef struct _QUE_INFO_T {
          PQUE_HD_T  pQueHd;
          LPBYTE     cstrQueType;
         } QUE_INFO_T, *PQUE_INFO_T;

       QUE_INFO_T  Queues[] = {
            &QueNbtWrkQueHd,     "Nbt Query Que",
	    &QueOtherNbtWrkQueHd, "Nbt Reg. Que",
  	    &QueRplPullQueHd,   "Pull Thd Que",          //Pull requests
	    &QueRplPushQueHd,   "Push Thd Que",          //Push requests
	    &QueNmsNrcqQueHd,   "Chl Nbt Req. Msg Que",  //Chl req fr nbt thds
	    &QueNmsRrcqQueHd,   "Chl req. from Pull thd Que",
	    &QueNmsCrqQueHd,    "Chl rsp from UDP thd Que",
	    &QueWinsTmmQueHd,   "Timer Queue",
	    &QueInvalidQueHd,   "Invalid Que"
                        };
        PQUE_INFO_T pQueInfo = Queues;
        PRINT_TIME_OF_DUMP_M(SystemTime, "WORK ITEM DUMP");

        DBGPRINT0(SPEC, "----------Count of Wrk items-----------\n");
        for (; pQueInfo->pQueHd != &QueInvalidQueHd; pQueInfo++)
        {
             PLIST_ENTRY pTmp;
             DWORD NoOfWrkItms = 0;
             pTmp = &pQueInfo->pQueHd->Head;
             EnterCriticalSection(&pQueInfo->pQueHd->CrtSec);
//             NoOfWrkItms = pQueInfo->pQueHd->NoOfEntries;
//#if 0

             while (pTmp->Flink != &pQueInfo->pQueHd->Head)
             {

                     NoOfWrkItms++;
                     pTmp = pTmp->Flink;
             }
//#endif
             LeaveCriticalSection(&pQueInfo->pQueHd->CrtSec);
             DBGPRINT2(SPEC, "Que = (%s) has (%d) wrk items\n",
                                   pQueInfo->cstrQueType,
                                   NoOfWrkItms
                                     );
        }

        DBGPRINT0(SPEC, "----------Count of Wrk items End-----------\n");
     }
} // end of try
finally {
      if (AbnormalTermination())
      {
         DBGPRINT0(SPEC, "WinsSetFlags terminated abnormally\n");
      }
      WinsDbg = DbgFlagsStore;
      LeaveCriticalSection(&WinsCnfCnfCrtSec);
 }  //end of finally { }
#endif
  return(Status);
}

DWORD
WinsBackup (
   LPBYTE                pBackupPath,
   short                 fIncremental
        )
{
 DWORD RetVal = WINS_FAILURE;
 try {
#if 0
   RetVal = NmsDbBackup(pBackupPath, fIncremental ? NMSDB_INCREMENTAL_BACKUP :
                        NMSDB_FULL_BACKUP);
#endif
   //
   // Always do full backup until Jet is solid enough in doing incremental
   // backups. Ian does not seem very sure about how robust it is currently.
   // (7/6/94)
   //
   RetVal = NmsDbBackup(pBackupPath, NMSDB_FULL_BACKUP);
  }
 except(EXCEPTION_EXECUTE_HANDLER) {
    DBGPRINTEXC("WinsBackup");
#if 0
    DBGPRINT2(ERR, "WinsBackup: Could not do %s backup to dir (%s)\n", fIncremental ? "INCREMENTAL" : "FULL", pBackupPath);

    DBGPRINT1(ERR, "WinsBackup: Could not do full backup to dir (%s)\n", pBackupPath);
#endif
    WinsEvtLogDetEvt(FALSE, WINS_EVT_BACKUP_ERR, NULL, __LINE__, "s", pBackupPath);
 }
 if (RetVal != WINS_SUCCESS)
 {
#if 0
   RetVal = fIncremental ? WINSINTF_INC_BACKUP_FAILED : WINSINTF_FULL_BACKUP_FAILED;
#endif
   RetVal = WINSINTF_FULL_BACKUP_FAILED;
 }
 else
 {
   RetVal = WINSINTF_SUCCESS;
 }
 return(RetVal);
}


DWORD
WinsTerm (
        handle_t        ClientHdl,
        short                fAbruptTerm
        )
{
  DBGPRINT1(FLOW, "WINS TERMINATED %s BY ADMINISTRATOR\n", fAbruptTerm ? "ABRUPTLY" : "GRACEFULLY");

  UNREFERENCED_PARAMETER(ClientHdl);

  if (fAbruptTerm)
  {
        fNmsAbruptTerm = TRUE;
          WinsMscSignalHdl(NmsMainTermEvt);
          ExitProcess(WINS_SUCCESS);

//        EnterCriticalSection(&NmsTermCrtSec);
//        NmsTotalTrmThdCnt = 0;  //force the count to less than 0
//        LeaveCriticalSection(&NmsTermCrtSec);
  }

  WinsMscSignalHdl(NmsMainTermEvt);
  return(WINSINTF_SUCCESS);
}

DWORD
WinsRecordAction(
        PWINSINTF_RECORD_ACTION_T        *ppRecAction
        )

/*++

Routine Description:
        This function is called to register, query, release a name

Arguments:
        pRecAction - Info about the operation to do and the name to insert,
                     query or release

Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsRecordAction()

Side Effects:

Comments:
        None
--*/

{

  STATUS             RetStat;
  RPL_REC_ENTRY_T   Rec;
  NMSDB_STAT_INFO_T StatInfo;
  NMSMSGF_CNT_ADD_T CntAdd;
  DWORD                    i, n;
  BOOL                    fSwapped = FALSE;
  PWINSINTF_RECORD_ACTION_T pRecAction = *ppRecAction;

  NmsDbThdInit(WINS_E_WINSRPC);
  NmsDbOpenTables(WINS_E_WINSRPC);
  DBGMYNAME("RPC-WinsRecordAction");

try {
  CntAdd.NoOfAdds          = 1;
  CntAdd.Add[0].AddTyp_e  = pRecAction->Add.Type;
  CntAdd.Add[0].AddLen    = pRecAction->Add.Len;
  CntAdd.Add[0].Add.IPAdd = pRecAction->Add.IPAdd;




  //
  // Check to see if it is a PDC name (0x1B in the 16th byte).  Do this only
  // if the name is atleast 16 bytes long.  Winscl or some other tool may
  // send a shorter name. Netbt will never send a shorter name.
  //
  if ((pRecAction->NameLen >= (WINS_MAX_NS_NETBIOS_NAME_LEN - 1)) && (*(pRecAction->pName + 15) == 0x1B))
  {
        WINS_SWAP_BYTES_M(pRecAction->pName, pRecAction->pName + 15);
        fSwapped = TRUE;
  }

  //
  // just in case the admin. tool is screwing up and passing us an invalid
  // name length, adjust the length.
  //
  if (pRecAction->NameLen > WINS_MAX_NAME_SZ)
  {
      pRecAction->NameLen = WINS_MAX_NAME_SZ - 1;
  }

  //
  // Terminate name with NULL, just in case user didn't do it.
  //
  *(pRecAction->pName + pRecAction->NameLen) = (TCHAR)NULL;

  switch(pRecAction->Cmd_e)
  {
        case(WINSINTF_E_INSERT):

                if (pRecAction->TypOfRec_e == WINSINTF_E_UNIQUE)
                {

                 RetStat = NmsNmhNamRegInd(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1, //to include the ending                                                         //0 byte. See GetName()
                                                         //in nmsmsgf.c
                                CntAdd.Add,
                                pRecAction->NodeTyp,
                                NULL,
                                0,
                                0,
                                FALSE,        //it is a name reg (nor a ref)
                                pRecAction->fStatic,
                                TRUE                  // administrative action
                                );
                }
                else  // the record is a group or  multihomed
                {

                if (
                        (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED )
                                        ||
                        (pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP )
                   )
                {
                        for (i = 0; i < pRecAction->NoOfAdds; i++)
                        {
                             //
                             // pAdd is a unique pointer and so can be 
                             // NULL.  We however do not protect oureelves
                             // here for the following reasons
                             //
                             //  - the call can only be executed by Admins
                             //    on this machine and through tools
                             //    that MS provides that do not pass pAdd as
                             //    NULL.  The rpc call is not published
                             //
                             //  - AV will be caught and a failure returned.
                             //    No harm done.
                             //
                             CntAdd.Add[i].AddTyp_e  =
                                        (pRecAction->pAdd + i)->Type;
                             CntAdd.Add[i].AddLen    =
                                        (pRecAction->pAdd + i)->Len;
                             CntAdd.Add[i].Add.IPAdd =
                                        (pRecAction->pAdd + i)->IPAdd;
                        }
                        CntAdd.NoOfAdds          = pRecAction->NoOfAdds;

                }
                RetStat= NmsNmhNamRegGrp(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1,
                                &CntAdd,
                                0,                //node type (not used)
                                NULL,
                                0,
                                0,
                                pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED ? NMSDB_MULTIHOMED_ENTRY : (NMSDB_IS_IT_SPEC_GRP_NM_M(pRecAction->pName) || (pRecAction->TypOfRec_e == WINSINTF_E_NORM_GROUP) ? NMSDB_NORM_GRP_ENTRY : NMSDB_SPEC_GRP_ENTRY),
                                FALSE,        //it is a name reg (nor a ref)
                                pRecAction->fStatic,
                                TRUE                  // administrative action
                                );
                }
                break;

        case(WINSINTF_E_RELEASE):

                if (
                        (pRecAction->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                                            ||
                        (pRecAction->TypOfRec_e == WINSINTF_E_SPEC_GROUP)
                   )
                {
                        if (pRecAction->pAdd != NULL)
                        {
                             CntAdd.Add[0].AddTyp_e  =  pRecAction->pAdd->Type;
                             CntAdd.Add[0].AddLen    =  pRecAction->pAdd->Len;
                             CntAdd.Add[0].Add.IPAdd =  pRecAction->pAdd->IPAdd;
                        }
                }


                RetStat = NmsNmhNamRel(
                                NULL,                   //no dialogue handle
                                (LPBYTE)pRecAction->pName,
                                pRecAction->NameLen + 1,
                                CntAdd.Add,
                                pRecAction->TypOfRec_e ==
                                        WINSINTF_E_UNIQUE ? FALSE : TRUE,
                                NULL,
                                0,
                                0,
                                TRUE                  // administrative action
                                     );

                break;

        case(WINSINTF_E_QUERY):

                //
                // Anybody can query a record.  We don't have any security 
                // for plain queries. Therefore somebody can cause a leak
                // by making calls with pAdd pointing to allocated memory.
                // Let us free that memory and proceed.  We can return 
                // failure also but let us cover for our legit caller's 
                // mistakes.  Currently, the only known callers of this
                // function are winsmon, winscl, winsadmn (NT 4 and before)
                // and wins snapin.   
                //
                if (pRecAction->pAdd != NULL)
                {
                     midl_user_free(pRecAction->pAdd);
                }
                RetStat = NmsNmhNamQuery(
                            NULL,                   //no dialogue handle
                            (LPBYTE)pRecAction->pName,
                            pRecAction->NameLen + 1,
                            NULL,
                            0,
                            0,
                            TRUE,                  // administrative action
                            &StatInfo
                             );

                if (RetStat == WINS_SUCCESS)
                {
                  pRecAction->TypOfRec_e = StatInfo.EntTyp;
                  pRecAction->OwnerId    = StatInfo.OwnerId;
                  pRecAction->State_e    =
                                        (WINSINTF_STATE_E)StatInfo.EntryState_e;
                  pRecAction->TimeStamp    = StatInfo.TimeStamp;
                  if (
                        NMSDB_ENTRY_UNIQUE_M(StatInfo.EntTyp)
                                ||
                        NMSDB_ENTRY_NORM_GRP_M(StatInfo.EntTyp)
                   )
                 {
                    pRecAction->NoOfAdds    = 0;
                    pRecAction->pAdd       = NULL;
                    pRecAction->Add.IPAdd  =
                                StatInfo.NodeAdds.Mem[0].Add.Add.IPAdd;
                    pRecAction->Add.Type  =
                                (UCHAR) StatInfo.NodeAdds.Mem[0].Add.AddTyp_e;
                    pRecAction->Add.Len  =
                                StatInfo.NodeAdds.Mem[0].Add.AddLen;
                 }
                 else
                 {

                  PNMSDB_WINS_STATE_E pWinsState_e;
                  PCOMM_ADD_T         pAdd;
                  PVERS_NO_T     pStartVersNo;

                  EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
try {
                  if (StatInfo.NodeAdds.NoOfMems > 0)
                  {
                    pRecAction->NoOfAdds = StatInfo.NodeAdds.NoOfMems * 2;
                    pRecAction->pAdd = midl_user_allocate(pRecAction->NoOfAdds * sizeof(WINSINTF_ADD_T));
                  }
                  else
                  {
                    pRecAction->NoOfAdds = 0;
                    pRecAction->pAdd = NULL;
                  }
                  for (
                        n = 0, i = 0;
                        n < (StatInfo.NodeAdds.NoOfMems)  && n < WINSINTF_MAX_MEM;                         n++
                     )
                  {
                        RPL_FIND_ADD_BY_OWNER_ID_M(
                                  StatInfo.NodeAdds.Mem[n].OwnerId,
                                  pAdd,
                                  pWinsState_e,
                                  pStartVersNo
                                        );
                       (pRecAction->pAdd + i++)->IPAdd = pAdd->Add.IPAdd;

                       (pRecAction->pAdd + i++)->IPAdd   =
                          StatInfo.NodeAdds.Mem[n].Add.Add.IPAdd;


                  }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPC_EXC);
        DBGPRINT1(EXC, "WinsRecordAction: Got Exception (%x)\n", ExcCode);
        }
                  LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
                }

                pRecAction->NodeTyp  = StatInfo.NodeTyp;
                pRecAction->VersNo   = StatInfo.VersNo;
                pRecAction->fStatic  = StatInfo.fStatic;
              }
              else
              {
                  pRecAction->NoOfAdds = 0;
                  pRecAction->pAdd = NULL;
              }
              break;

        case(WINSINTF_E_MODIFY):

                //
                // Note: Currently, the administrator can not change the
                // address in the record
                //
                time((time_t *)&Rec.NewTimeStamp);

                //
                // If the record type is wrong, return a failure
                //
                if (pRecAction->TypOfRec_e > WINSINTF_E_MULTIHOMED)
                {
                        RetStat = WINS_FAILURE;
                        break;
                }
                //
                // If the state specified is wrong, return a failure
                //
                if (pRecAction->State_e > WINSINTF_E_DELETED)
                {
                        RetStat = WINS_FAILURE;
                        break;
                }
                NMSDB_SET_ENTRY_TYPE_M(Rec.Flag, pRecAction->TypOfRec_e);
                NMSDB_SET_NODE_TYPE_M(Rec.Flag, pRecAction->NodeTyp);
                NMSDB_SET_STDYN_M(Rec.Flag, pRecAction->fStatic);

                //
                // Fall through
                //

        case(WINSINTF_E_DELETE):
                NMSDB_SET_STATE_M(Rec.Flag, pRecAction->State_e)

                Rec.pName = pRecAction->pName;
                Rec.NameLen = pRecAction->NameLen + 1;

                //
                // NOTE:
                // The index on the name address table was set to
                // the clustered index column (as required by this function)
                // in NmsDbThdInit()
                //

                RetStat = NmsDbQueryNUpdIfMatch(
                                        &Rec,
                                        THREAD_PRIORITY_NORMAL,
                                        FALSE,  //don't change priority to
                                                //normal
                                        WINS_E_WINSRPC //ensures no matching
                                                       //of timestamps
                                                );
                if (RetStat == WINS_SUCCESS)
                {
                  DBGPRINT1(DET, "WinsRecordAction: Record (%s) deleted\n",
                                                  Rec.pName);
FUTURES("use macros defined in winsevt.h. Change to warning")
                  if (WinsCnf.LogDetailedEvts > 0)
                  {
                     WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_DELETED, NULL, __LINE__, "s", Rec.pName);
                  }
                }
                break;


        default:
                RetStat = WINS_FAILURE;
                break;

  }
 } // end of try
 except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPC_EXC);
        DBGPRINT1(EXC, "WinsRecordAction: Got Exception (%x)\n", ExcCode);
        }
  if (fSwapped)
  {
        WINS_SWAP_BYTES_M(pRecAction->pName, pRecAction->pName + 15);
  }
  //
  // Let us end the session
  //
  NmsDbCloseTables();
  NmsDbEndSession();
  if (RetStat == WINS_SUCCESS)
  {
      RetStat = WINSINTF_SUCCESS;
  }
  else
  {
      if (pRecAction->Cmd_e == WINSINTF_E_QUERY)
      {
             RetStat = WINSINTF_REC_NOT_FOUND;
      }
      else
      {
             RetStat = WINSINTF_FAILURE;
      }
  }
  return(RetStat);
}

DWORD
GetWinsStatus(
   IN  WINSINTF_CMD_E          Cmd_e,
   OUT LPVOID  pResults,
   BOOL fNew
        )

/*++

Routine Description:
        This function is called to get the information pertaining to WINS
        Refer WINSINTF_RESULTS_T data structure to see what information
        is retrieved

Arguments:
        Cmd_e    - Command to execute
        pResults -  Info. retrieved

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsStatus()

Side Effects:

Comments:
        None
--*/

{

        DWORD RetVal = WINSINTF_FAILURE;

        switch(Cmd_e)
        {

                case(WINSINTF_E_ADDVERSMAP):
                                if (fNew)
                                {
                                   break;
                                }
                                RetVal = sGetVersNo(pResults);
                                break;
                case(WINSINTF_E_CONFIG):
                                RetVal = GetConfig(pResults, fNew, FALSE);
                                break;
                case(WINSINTF_E_CONFIG_ALL_MAPS):
                                RetVal = GetConfig(pResults, fNew, TRUE);
                                break;
                case(WINSINTF_E_STAT):
                                RetVal = GetStatistics(pResults, fNew);
                                break;
                default:
                  DBGPRINT1(ERR, "WinsStatus: Weird: Bad RPC Status command = (%D) \n", Cmd_e);
                  WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_BAD_RPC_STATUS_CMD);
                  break;

        }
        return(RetVal);

}

DWORD
WinsTrigger(
        PWINSINTF_ADD_T           pWinsAdd,
        WINSINTF_TRIG_TYPE_E         TrigType_e
        )

/*++

Routine Description:
        This function is called to send a trigger to a remote WINS so that
        it may pull the latest information from it

Arguments:

        pWinsAdd - Address of WINS to send a Push update notification to

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsTrigger

Side Effects:

Comments:
        A Trigger is sent to a remote WINS only if it is specified
        under the PULL/PUSH subkey of the PARTNERS key in the registry
--*/

{

        PRPL_CONFIG_REC_T        pPnr;
        DWORD                        RetCode = WINSINTF_SUCCESS;
        BOOL                        fRplPnr = FALSE;
        QUE_CMD_TYP_E                CmdType_e;

        DBGENTER("WinsTrigger\n");
        //
        // Enter the critical sections guarded by WinsCnfCnfCrtSec and
        // NmsNmhNamRegCrtSec. There is no danger of deadlock because we
        // always enter the two critical sections in the following sequence
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

PERF("Do we need to enter the following critical section")
//        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {
        if (
                (TrigType_e == WINSINTF_E_PUSH)
                        ||
                (TrigType_e == WINSINTF_E_PUSH_PROP)
              )
        {
                DBGPRINT1(DET, "WinsTrigger. Send Push trigger to (%x)\n",
                                     pWinsAdd->IPAdd);

                CmdType_e = (TrigType_e == WINSINTF_E_PUSH ?
                                QUE_E_CMD_SND_PUSH_NTF :
                                QUE_E_CMD_SND_PUSH_NTF_PROP);

                pPnr      = WinsCnf.PushInfo.pPushCnfRecs;
        }
        else        // it is a pull trigger
        {
                DBGPRINT1(DET, "WinsTrigger. Send Pull trigger to (%x)\n",
                                     pWinsAdd->IPAdd);

                CmdType_e  = QUE_E_CMD_REPLICATE;
                pPnr       = WinsCnf.PullInfo.pPullCnfRecs;

        }

        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
           if (pPnr != NULL)
           {
              //
              // Search for the Cnf record for the WINS we want to
              // send the PUSH notification to/Replicate with.
              //
              for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                        !fRplPnr;
                                // no third expression
                  )
               {


                   DBGPRINT1(DET, "WinsTrigger. Comparing with (%x)\n",
                                     pPnr->WinsAdd.Add.IPAdd);
                   //
                   // Check if this is the one we want
                   //
                   if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->IPAdd)
                   {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;

                        //
                        // Make it 0, so that we always try to establish
                        // a connection.  Otherwise, pull thread may not
                        // try if it has already exhausted the number of
                        // retries
                        //
                        pPnr->RetryCount = 0;
                        continue;                //so that we can break out

                   }
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
              } // end of for
          } // end of if (pPnr != 0)
       }  // end of if (fRplOnlyWCnfPnrs)
       else
       {
                //
                // Allocate from the general heap because that is what
                // is used by the replicator.
                //
                WinsMscAlloc(RPL_CONFIG_REC_SIZE, &pPnr);
                COMM_INIT_ADD_M(&pPnr->WinsAdd, pWinsAdd->IPAdd);
                pPnr->MagicNo           = 0;
                pPnr->RetryCount        = 0;
                pPnr->LastCommFailTime  = 0;
                pPnr->PushNtfTries    = 0;
                fRplPnr                     = TRUE;

                //
                // We want the buffer to be deallocated by the PULL thread
                //
                pPnr->fTemp = TRUE;
       }

       //
       // If replication needs to be done
       //
       if (fRplPnr)
       {
                //
                // Call RplInsertQue to insert the push request to
                // the Pull Thread
                //
                ERplInsertQue(
                             WINS_E_WINSRPC,
                             CmdType_e,
                             NULL,        //no Dlg Hdl
                             NULL,        //no msg is there
                             0,                //msg length
                             pPnr,   //client context
                             pPnr->MagicNo
                             );

       }
  } // end of try block

except (EXCEPTION_EXECUTE_HANDLER) {
                DWORD ExcCode = GetExceptionCode();
                DBGPRINT1(EXC, "WinsTrigger: Got Exception (%x)\n", ExcCode);
                WINSEVT_LOG_D_M(ExcCode, WINS_EVT_PUSH_TRIGGER_EXC);
                RetCode = WINSINTF_FAILURE;
  }

        //
        // Leave the critical section guarded by NmsNmhNamRegCrtSec.
        //
//        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // if replication was allowed only with configured partners and
        // there was no WINS with the address specified by the client,
        // return failure
        //
        if (!fRplPnr)
        {
                RetCode = WINSINTF_RPL_NOT_ALLOWED;
        }

        DBGLEAVE("WinsTrigger\n");
        return(RetCode);
}

DWORD
sGetVersNo(
        LPVOID  pResultsA
        )

/*++

Routine Description:

        This function returns with the highest version number of records
        owned by a particular WINS

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T        WinsAdd;
        DWORD                OwnerId;
        STATUS                RetStat;
        VERS_NO_T        VersNo;
        BOOL                fAllocNew = FALSE;
        PWINSINTF_RESULTS_T  pResults  = pResultsA;

        WinsAdd.AddLen    = sizeof(COMM_IP_ADD_T);
        WinsAdd.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
        WinsAdd.Add.IPAdd = pResults->AddVersMaps[0].Add.IPAdd;
        RetStat = RplFindOwnerId(
                        &WinsAdd,
                        &fAllocNew,                //don't assign if not there
                        &OwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                              );
        if(RetStat != WINS_SUCCESS)
        {
                return(WINSINTF_FAILURE);
        }

        if (OwnerId == 0)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, VersNo);
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                pResults->AddVersMaps[0].VersNo = VersNo;
        }
        else
        {
           EnterCriticalSection(&RplVersNoStoreCrtSec);
           try {
                   pResults->AddVersMaps[0].VersNo =
                                        (pRplPullOwnerVersNo+OwnerId)->VersNo;
            }
            except(EXCEPTION_EXECUTE_HANDLER) {
                                DBGPRINTEXC("sGetVersNo");
                        }
            LeaveCriticalSection(&RplVersNoStoreCrtSec);
        }
        return(WINSINTF_SUCCESS);

}

DWORD
GetConfig(
        OUT  LPVOID  pResultsA,
        IN   BOOL    fNew,
        IN   BOOL    fAllMaps
        )

/*++

Routine Description:
        This function returns with configuration information
        and counter info related to replication

Arguments:
        pResults - has the information retrieved

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        GetWinsStatus()

Side Effects:

Comments:
        None
--*/

{

        PNMSDB_WINS_STATE_E pWinsState_e;
        PCOMM_ADD_T            pWinsAdd;
        PVERS_NO_T          pStartVersNo;
        DWORD                    i, n;
        VERS_NO_T            MyMaxVersNo;
        PWINSINTF_ADD_VERS_MAP_T pAddVersMaps, pAddVersMapsStore;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        BOOL                 fDel;
        VERS_NO_T            VersNoForDelRec;


        if (fAllMaps)
        {
          fDel = FALSE;
          VersNoForDelRec.HighPart = MAXLONG;
          VersNoForDelRec.LowPart  = MAXULONG;
        }
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        MyMaxVersNo = NmsNmhMyMaxVersNo;
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        if (fNew)
        {

             pResultsN->pAddVersMaps =
                     midl_user_allocate(NmsDbNoOfOwners * sizeof(WINSINTF_ADD_VERS_MAP_T));
             pAddVersMaps = pResultsN->pAddVersMaps;

        }
        else
        {
             pAddVersMaps = pResults->AddVersMaps;
        }
        pAddVersMapsStore = pAddVersMaps;
        //
        // First extract the timeouts and Non-remote WINS information
        // from the WinsCnf global var.  We enter the WinsCnfCnfCrtSec
        // since we need to synchronize with the thread doing the
        // reinitialization (Main thread)
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);
        if (!fNew)
        {
        pResults->RefreshInterval    = WinsCnf.RefreshInterval;
        pResults->TombstoneInterval  = WinsCnf.TombstoneInterval;
        pResults->TombstoneTimeout   = WinsCnf.TombstoneTimeout;
        pResults->VerifyInterval     = WinsCnf.VerifyInterval;
        pResults->WinsPriorityClass  = WinsCnf.WinsPriorityClass == (DWORD)WINSINTF_E_NORMAL ? NORMAL_PRIORITY_CLASS : HIGH_PRIORITY_CLASS;
        pResults->NoOfWorkerThds     = NmsNoOfNbtThds;
        }
        else
        {
        pResultsN->RefreshInterval    = WinsCnf.RefreshInterval;
        pResultsN->TombstoneInterval  = WinsCnf.TombstoneInterval;
        pResultsN->TombstoneTimeout   = WinsCnf.TombstoneTimeout;
        pResultsN->VerifyInterval     = WinsCnf.VerifyInterval;
        pResultsN->WinsPriorityClass  = WinsCnf.WinsPriorityClass == (DWORD)WINSINTF_E_NORMAL ? NORMAL_PRIORITY_CLASS : HIGH_PRIORITY_CLASS;
        pResultsN->NoOfWorkerThds     = NmsNoOfNbtThds;

        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // Enter two critical sections in sequence. No danger of deadlock
        // here. The only other thread that takes both these critical section
        // is the RplPush thread. It takes these in the same order (See
        // HandleVersMapReq())
        //
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        EnterCriticalSection(&RplVersNoStoreCrtSec);
try {
NONPORT("Change when using different address family")

         for (
                i=0, n = 0;
                i < NmsDbNoOfOwners;
                i++
             )
         {

                if (!fNew && (i == WINSINTF_MAX_NO_RPL_PNRS))
                {
                    break;
                }
                //
                // if the record is deleted in the in-memory table, it
                // means that there are no records for it in the
                // database
                //
                if ((pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_DELETED)
                {
                        //
                        // if only active mappings are sought, skip this
                        // entry
                        //
                        if (!fAllMaps)
                        {
                          continue;
                        }
                        else
                        {
                             fDel = TRUE;
                        }
                }

                //
                // Find address corresponding to the owner id.
                //
                RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e,
                                                pStartVersNo);

                //
                //  It is possible for NmsDbNoOfOwners to be more than the
                //  number of initialized RplPullVersNoTbl entries.  When
                //  we reach a NULL entry, we break out of the loop.
                //
                if (pWinsAdd != NULL)
                {
                        pAddVersMaps->Add.Type   = WINSINTF_TCP_IP;
                        pAddVersMaps->Add.Len    = pWinsAdd->AddLen;
                        pAddVersMaps->Add.IPAdd  =  pWinsAdd->Add.IPAdd;

                        pAddVersMaps++->VersNo =  (fDel == FALSE) ? (pRplPullOwnerVersNo+i)->VersNo : VersNoForDelRec;
                }
                else
                {
                        break;
                }
                if (fDel)
                {
                    fDel = FALSE;
                }
                n++;
         } // end of for ..

         //
         // Since RplPullOwnerVersNo[0] may be out of date, let us get
         // get the uptodate value
         //
         NMSNMH_DEC_VERS_NO_M(MyMaxVersNo,
                              pAddVersMapsStore->VersNo
                             );
         if (fNew)
         {
           pResultsN->NoOfOwners = n;
         }
         else
         {
           pResults->NoOfOwners = n;

         }
NOTE("Wins Mib agent relies on the first entry being that of the local WINS")
NOTE("See WinsMib.c -- EnumAddKeys")
#if 0
         //
         // Since RplPullOwnerVersNo[0] may be out of date, let us get
         // get the uptodate value
         //
         NMSNMH_DEC_VERS_NO_M(MyMaxVersNo,
                              pResults->AddVersMaps[0].VersNo
                             );
#endif
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetConfig");
        //
        // log a message
        //
 }
        LeaveCriticalSection(&RplVersNoStoreCrtSec);
        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

        return(WINSINTF_SUCCESS);
}

DWORD
GetStatistics(
        LPVOID  pResultsA,
        BOOL                 fNew
        )

/*++

Routine Description:

        This function returns with the highest version number of records
        owned by a particular WINS

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PRPL_CONFIG_REC_T         pPnr;
        PWINSINTF_RPL_COUNTERS_T  pPnrData;
        DWORD                     i;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;


        ASSERT(pResults != NULL);

        
        //
        // If client passed us a non-null pRplPnr, then we return failure
        // so as to avoid a memory leak.  
        //
        if (!fNew)
        {
              if (pResults->WinsStat.pRplPnrs != NULL)
              {
                    return(WINSINTF_FAILURE);
              }

        }
        else
        {

              if (pResultsN->WinsStat.pRplPnrs != NULL)
              {
                    return(WINSINTF_FAILURE);
              }
        }
        //
        // Copy the counters
        //
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        if (!fNew)
        {
        pResults->WinsStat.Counters = WinsIntfStat.Counters;
FUTURES("Get rid of of the following two fields")
        pResults->WinsStat.Counters.NoOfQueries =
                                WinsIntfStat.Counters.NoOfSuccQueries +
                                  WinsIntfStat.Counters.NoOfFailQueries;
        pResults->WinsStat.Counters.NoOfRel = WinsIntfStat.Counters.NoOfSuccRel
                                        + WinsIntfStat.Counters.NoOfFailRel;
        }
        else
        {
        pResultsN->WinsStat.Counters = WinsIntfStat.Counters;
FUTURES("Get rid of of the following two fields")
        pResultsN->WinsStat.Counters.NoOfQueries =
                                WinsIntfStat.Counters.NoOfSuccQueries +
                                  WinsIntfStat.Counters.NoOfFailQueries;
        pResultsN->WinsStat.Counters.NoOfRel = WinsIntfStat.Counters.NoOfSuccRel
                                        + WinsIntfStat.Counters.NoOfFailRel;

        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        //
        // Copy the TimeStamps and replication specific counters
        //
        EnterCriticalSection(&WinsIntfCrtSec);
        {
            PWINSINTF_STAT_T pWinsStat = (fNew) ? &(pResultsN->WinsStat) : &(pResults->WinsStat);
            TIME_ZONE_INFORMATION tzInfo;

            GetTimeZoneInformation(&tzInfo);
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.WinsStartTime), &(pWinsStat->TimeStamps.WinsStartTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastPScvTime), &(pWinsStat->TimeStamps.LastPScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastATScvTime), &(pWinsStat->TimeStamps.LastATScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastTombScvTime), &(pWinsStat->TimeStamps.LastTombScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastVerifyScvTime), &(pWinsStat->TimeStamps.LastVerifyScvTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastInitDbTime), &(pWinsStat->TimeStamps.LastInitDbTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastPRplTime), &(pWinsStat->TimeStamps.LastPRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastATRplTime), &(pWinsStat->TimeStamps.LastATRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastNTRplTime), &(pWinsStat->TimeStamps.LastNTRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.LastACTRplTime), &(pWinsStat->TimeStamps.LastACTRplTime));
            SystemTimeToTzSpecificLocalTime(&tzInfo, &(WinsIntfStat.TimeStamps.CounterResetTime), &(pWinsStat->TimeStamps.CounterResetTime));
        }
        LeaveCriticalSection(&WinsIntfCrtSec);
        EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
        DWORD  NoOfPnrs;
        pPnr       = WinsCnf.PullInfo.pPullCnfRecs;
        if (!fNew)
        {
          NoOfPnrs = pResults->WinsStat.NoOfPnrs = WinsCnf.PullInfo.NoOfPushPnrs;

        }
        else
        {
          NoOfPnrs = pResultsN->WinsStat.NoOfPnrs = WinsCnf.PullInfo.NoOfPushPnrs;
        }

        //
        // If no. of push pnrs (pnrs under the pull key) is > 0
        //
        if (NoOfPnrs > 0)
        {
           if (!fNew)
           {
             pPnrData = pResults->WinsStat.pRplPnrs =
                        midl_user_allocate(pResults->WinsStat.NoOfPnrs *
                                         sizeof(WINSINTF_RPL_COUNTERS_T));
           }
           else
           {
             pPnrData = pResultsN->WinsStat.pRplPnrs =
                        midl_user_allocate(pResultsN->WinsStat.NoOfPnrs *
                                         sizeof(WINSINTF_RPL_COUNTERS_T));

           }
PERF("remove one of the expressions in the test condition of the if statement")
           for (
                 i = 0;
                (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                        &&
                i < NoOfPnrs;
                pPnrData++, i++
               )
           {

                   pPnrData->Add.IPAdd     = pPnr->WinsAdd.Add.IPAdd;
                   (VOID)InterlockedExchange(
                                        &pPnrData->NoOfRpls, pPnr->NoOfRpls);
                   (VOID)InterlockedExchange(
                                        &pPnrData->NoOfCommFails,
                                        pPnr->NoOfCommFails
                                        );
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
           }
        }
        else
        {
           if (!fNew)
           {
               pResults->WinsStat.pRplPnrs = NULL;
           }
           else
           {
               pResultsN->WinsStat.pRplPnrs = NULL;
           }
        }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("GetStatistics");
        //
        // log a message
        //
        }

        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        GetConfig(pResultsA, fNew, FALSE);
        return(WINSINTF_SUCCESS);
} // GetStatistics


DWORD
WinsDoStaticInit(
        LPWSTR  pDataFilePath,
        DWORD   fDel
        )

/*++

Routine Description:
        This function does the STATIC initialization of WINS

Arguments:
        pDataFilePath - Path to the data file or NULL

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsDoStaticInit
Side Effects:

Comments:
        None
--*/

{

        WINSCNF_CNF_T        WinsCnf;
        STATUS               RetStat = WINS_SUCCESS;

        //
        // If no path has been specified, take the values from the registry
        //
        if (pDataFilePath == NULL)
        {
           //
           // Read the DataFiles info information
           //
           // This function will return with either the name of the default
           // file to read or one or more files specified under the
           // Parameters\Datafiles key of WINS
           //
           (VOID)WinsCnfGetNamesOfDataFiles(&WinsCnf);
        }
        else
        {
FUTURES("expensive.  Change idl prototype to pass length")
                if (lstrlen(pDataFilePath) >= WINS_MAX_FILENAME_SZ)
                {

                        return(WINSINTF_STATIC_INIT_FAILED);
                }
                //
                // Set time of data initialization
                //
                WinsIntfSetTime(NULL, WINSINTF_E_INIT_DB);
                WinsMscAlloc(WINSCNF_FILE_INFO_SZ, &WinsCnf.pStaticDataFile);

                lstrcpy(WinsCnf.pStaticDataFile->FileNm,  pDataFilePath);
                WinsCnf.pStaticDataFile->StrType = REG_EXPAND_SZ;
                WinsCnf.NoOfDataFiles = 1;
        }

        //
        // If Static initialization fails, it will be logged.
        // This function does not return an error code
        //
        if ((RetStat = WinsPrsDoStaticInit(
                          WinsCnf.pStaticDataFile,
                          WinsCnf.NoOfDataFiles,
                           FALSE                   //do it synchronously
                                   )) == WINS_SUCCESS)
        {
           if ((pDataFilePath != NULL) && fDel)
           {
             if (!DeleteFile(pDataFilePath))
             {
                DWORD Error;
                Error = GetLastError();
                if (Error != ERROR_FILE_NOT_FOUND)
                {
                    DBGPRINT1(ERR, "DbgOpenFile: Could not delete the data file. Error = (%d).  Dbg file will not be truncated\n", Error);
                    WinsEvtLogDetEvt(FALSE, WINS_EVT_COULD_NOT_DELETE_FILE,
                      TEXT("winsintf.c"), __LINE__, "ud", pDataFilePath, Error);
                    RetStat = Error;

                }
             }

           }
        }
        return (RetStat == WINS_SUCCESS ? WINSINTF_SUCCESS : WINSINTF_STATIC_INIT_FAILED);
}
DWORD
WinsDoScavenging(
        VOID
        )

/*++

Routine Description:
        This function starts the scavenging cycle

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  exception from WinsMscSignalHdl

Error Handling:

Called by:
        R_WinsDoScavenging
Side Effects:

Comments:
        None
--*/

{
        PQUE_SCV_REQ_WRK_ITM_T pWrkItm;

        pWrkItm = WinsMscHeapAlloc( NmsRpcHeapHdl, sizeof(QUE_SCV_REQ_WRK_ITM_T));
        pWrkItm->Opcode_e = WINSINTF_E_SCV_GENERAL;
        pWrkItm->CmdTyp_e = QUE_E_CMD_SCV_ADMIN;
        pWrkItm->fForce   = 0;
        pWrkItm->Age      = 1;   //should not be zero since zero implies
                                 //consistency check on all replicas.
        WinsLogAdminEvent( WINS_EVT_ADMIN_SCVENGING_INITIATED, 0 );
        QueInsertScvWrkItm((PLIST_ENTRY)pWrkItm);
         return (WINSINTF_SUCCESS);
}

DWORD
WinsDoScavengingNew(
    PWINSINTF_SCV_REQ_T  pScvReq
        )

/*++

Routine Description:
        This function starts the scavenging cycle

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  exception from WinsMscSignalHdl

Error Handling:

Called by:
        R_WinsDoScavenging
Side Effects:

Comments:
        None
--*/

{
        PQUE_SCV_REQ_WRK_ITM_T pWrkItm;
        pWrkItm = WinsMscHeapAlloc( NmsRpcHeapHdl, sizeof(QUE_SCV_REQ_WRK_ITM_T));
        pWrkItm->Opcode_e = pScvReq->Opcode_e;
        pWrkItm->Age      = pScvReq->Age;
        pWrkItm->fForce   = pScvReq->fForce;
        if (WINSINTF_E_SCV_GENERAL == pWrkItm->Opcode_e ) {
            WinsLogAdminEvent( WINS_EVT_ADMIN_SCVENGING_INITIATED, 0 );
        } else {
            WinsLogAdminEvent( WINS_EVT_ADMIN_CCCHECK_INITIATED, 0);
        }
        QueInsertScvWrkItm((PLIST_ENTRY)pWrkItm);
         return (WINSINTF_SUCCESS);
}

DWORD
WinsGetDbRecs (
        PWINSINTF_ADD_T             pWinsAdd,
        WINSINTF_VERS_NO_T          MinVersNo,
        WINSINTF_VERS_NO_T          MaxVersNo,
        PWINSINTF_RECS_T          pRecs
        )

/*++

Routine Description:
        This function returns with all the records (that can fit into the
        buffer passed) owned by a WINS in the local db of this WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T           Address;
        PRPL_REC_ENTRY_T     pBuff = NULL;
        LPVOID               pStartBuff;
        DWORD                BuffLen;
        DWORD                NoOfRecs;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD                i;
        DWORD                ind;
        //VERS_NO_T          MinVersNo = {0,0};
        DWORD                EntType;
        PWINSTHD_TLS_T       pTls;
        //ULONG                Status;
        BOOL                 fExcRaised = FALSE;


//   PVOID pCallersAdd, pCallersCaller;
//   RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
        DBGENTER("WinsGetDbRecs\n");

        if (LiLtr(MaxVersNo, MinVersNo))
        {
                return(WINSINTF_FAILURE);
        }

        Address.AddTyp_e  = pWinsAdd->Type;
        Address.AddLen    = pWinsAdd->Len;

        //
        // snmp agent can pass a 0 for the address to ask for all records
        // owned by the local wins.
        //
        if (pWinsAdd->IPAdd == 0)
        {
                  Address.AddTyp_e  = NmsLocalAdd.AddTyp_e;
                  Address.AddLen    = NmsLocalAdd.AddLen;
                  Address.Add.IPAdd = NmsLocalAdd.Add.IPAdd;
        }
        else
        {
                  Address.AddTyp_e  = pWinsAdd->Type;
                  Address.AddLen    = pWinsAdd->Len;
                  Address.Add.IPAdd = pWinsAdd->IPAdd;
        }
        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsGetDbRecs");

PERF("The caller can pass the number of records for which space has been")
PERF("allocated in buffer pointed to by pRec in the NoOfRecs field. We should")
PERF("We should pass this argument to NmsDbGetDataRecs so that it does not get")
PERF("more records than are necessary")

        GET_TLS_M(pTls);
try {
        NmsDbGetDataRecs(
                        WINS_E_WINSRPC,
                        0,                //not used
                        MinVersNo,
                        MaxVersNo,
                        0,                //not used
                        LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo) ? TRUE : FALSE,
                        FALSE,                //not used
                        NULL,                //must be NULL since we are not doing
                                        //scavenging of clutter
                        &Address,
                        FALSE,          //dynamic + static records are wanted
//#if RPL_TYPE
                        WINSCNF_RPL_DEFAULT_TYPE,
//#endif
                        &pBuff,
                        &BuffLen,
                        &NoOfRecs
                        );

        i = 0;
        pStartBuff       = pBuff;

        //
        // If there are records to send back and the client has specified
        // a buffer for them, insert the records
        //
        if  (NoOfRecs > 0)
        {

          //
          // Allocate memory for the no of records
          //
          pRecs->BuffSize  =  sizeof(WINSINTF_RECORD_ACTION_T) * NoOfRecs;

          //
          // If memory can not be allocate, an exception will be returned
          // by midl_user_alloc
          //
          pRecs->pRow      =  midl_user_allocate(pRecs->BuffSize);
//          DBGPRINT1(DET, "WinsGetDbRecs: Address of memory for records is (%d)\n", pRecs->pRow);

#if 0
          pRecs->pRow      =  RpcSmAllocate(pRecs->BuffSize, &Status);
          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif
          pRow                    =  pRecs->pRow;


          for (; i<NoOfRecs; i++)
          {

                //
                // Initialize so that we don't get "enum wrong" error.
                //
                pRow->Cmd_e = WINSINTF_E_QUERY;

                //
                // the name retrieved has NULL as the last character.  This
                // We need to pass a name without this NULL.
                //
                pRow->NameLen = pBuff->NameLen;
                if (*pBuff->pName == 0x1B)
                {
                        WINS_SWAP_BYTES_M(pBuff->pName, pBuff->pName + 15);
                }

                pRow->pName =  midl_user_allocate(pRow->NameLen + 1);
                //DBGPRINT2(DET, "WinsGetDbRecs: Address of name = (%s) is (%d) \n", pBuff->pName, pRow->pName);
#if 0
                pRow->pName =  RpcSmAllocate(pRow->NameLen, &Status);
                if (Status != RPC_S_OK)
                {
                         DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
                }
#endif
                WINSMSC_COPY_MEMORY_M(pRow->pName, pBuff->pName,
                                                pRow->NameLen);


                WinsMscHeapFree(pTls->HeapHdl, pBuff->pName);
                EntType = NMSDB_ENTRY_TYPE_M(pBuff->Flag);
                pRow->TypOfRec_e = NMSDB_ENTRY_UNIQUE_M(EntType)
                                                         ? WINSINTF_E_UNIQUE :
                                (NMSDB_ENTRY_NORM_GRP_M(EntType) ?
                                        WINSINTF_E_NORM_GROUP :
                                (NMSDB_ENTRY_SPEC_GRP_M(EntType) ?
                                        WINSINTF_E_SPEC_GROUP :
                                        WINSINTF_E_MULTIHOMED));


                if (
                    (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
                    (pRow->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                   )
                {
                    PWINSINTF_ADD_T        pAdd;
                    DWORD                 No;
                    if (pBuff->NoOfAdds > 0)
                    {
                        pRow->NoOfAdds = pBuff->NoOfAdds * 2;

                        //
                        // Each member is comprised of two addresses,
                        // first address is that of the owner WINS, second
                        // address is that of the node registered
                        //
                        pRow->pAdd        =
//                             RpcSmAllocate(
                             midl_user_allocate(
                                        (unsigned int)(pRow->NoOfAdds)
                                                *
                                        sizeof(WINSINTF_ADD_T)//,
//                                        &Status
                                             );
                        //DBGPRINT2(DET, "WinsGetDbRecs: Address of ip address for name = (%s) is (%d) \n", pRow->pName, pRow->pAdd);
#if 0
                        if (Status != RPC_S_OK)
                        {
                             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
                        }
#endif
                        for (
                                No= 0, ind= 0, pAdd = pRow->pAdd;
                                No < (pRow->NoOfAdds/2);
                                No++
                            )
                        {
                          pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ind)->AddTyp_e;
                          pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                          pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind)->Add.IPAdd;

                          pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ++ind)->AddTyp_e;
                          pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                          pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind++)->Add.IPAdd;
                        }
                        WinsMscHeapFree(pTls->HeapHdl, pBuff->pNodeAdd);
                    }
                }
                else
                {
                          pRow->NoOfAdds   = 0;
                          pRow->pAdd       = NULL;
                          pRow->Add.Type   = (UCHAR)pBuff->NodeAdd[0].AddTyp_e;
                          pRow->Add.Len    = pBuff->NodeAdd[0].AddLen;
                          pRow->Add.IPAdd  = pBuff->NodeAdd[0].Add.IPAdd;
                }
                pRow->NodeTyp     = (BYTE)NMSDB_NODE_TYPE_M(pBuff->Flag);
                pRow->fStatic     = NMSDB_IS_ENTRY_STATIC_M(pBuff->Flag);
                pRow->State_e     = NMSDB_ENTRY_STATE_M(pBuff->Flag);
                pRow->VersNo      = pBuff->VersNo;
                pRow->TimeStamp   = pBuff->TimeStamp;

                pRow++;


                pBuff = (PRPL_REC_ENTRY_T)((LPBYTE)pBuff + RPL_REC_ENTRY_SIZE);
PERF("Do the addition above the for loop and store in a var. Use var. here")

         } // end of for loop
        } //end of if block
        else
        {
                pRecs->pRow = NULL;
        }

 }        // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecs");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        fExcRaised = TRUE;
        }

        pRecs->TotalNoOfRecs = NoOfRecs;

        //
        // Deallocate the buffer allocated by NmsDbGetDataRecs
        //


        WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
        WinsMscHeapDestroy(pTls->HeapHdl);

        if (!fExcRaised)
        {
           pRecs->NoOfRecs = i;
        }
        else
        {
//             RpcSmFree(pRecs->pRow);
            midl_user_free(pRecs->pRow);
            pRecs->NoOfRecs = 0;
        }

        //
        // Let us end the session
        //
        NmsDbCloseTables();
        NmsDbEndSession();

        DBGLEAVE("WinsGetDbRecs\n");
        return (WINSINTF_SUCCESS);
}

VOID
WinsIntfSetTime(
        OUT PSYSTEMTIME                     pTime,
        IN     WINSINTF_TIME_TYPE_E        TimeType_e
        )

/*++

Routine Description:
        This function is called to set the the time in the WINSINTF_STAT_T
        structure

Arguments:
        pTime      - Local Time (returned)
        TimeType_e - The activity for which the time has to be stored

Externals Used:
        None

Return Value:

        NONE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        SYSTEMTIME     SysTime;
        PSYSTEMTIME    pSysTime = &SysTime;

        GetSystemTime(pSysTime);

        EnterCriticalSection(&WinsIntfCrtSec);

        switch(TimeType_e)
        {
         case(WINSINTF_E_WINS_START):
                WinsIntfStat.TimeStamps.WinsStartTime   = *pSysTime;
                break;
         case(WINSINTF_E_PLANNED_SCV):
                WinsIntfStat.TimeStamps.LastPScvTime = *pSysTime;
                break;
         case(WINSINTF_E_ADMIN_TRIG_SCV):
                WinsIntfStat.TimeStamps.LastATScvTime = *pSysTime;
                break;
         case(WINSINTF_E_TOMBSTONES_SCV):
                WinsIntfStat.TimeStamps.LastTombScvTime = *pSysTime;
                break;
         case(WINSINTF_E_VERIFY_SCV):
                WinsIntfStat.TimeStamps.LastVerifyScvTime = *pSysTime;
                break;
         case(WINSINTF_E_INIT_DB):
                WinsIntfStat.TimeStamps.LastInitDbTime = *pSysTime;
                break;
         case(WINSINTF_E_PLANNED_PULL):
                WinsIntfStat.TimeStamps.LastPRplTime = *pSysTime;
                break;
         case(WINSINTF_E_ADMIN_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastATRplTime = *pSysTime;
                break;
         case(WINSINTF_E_NTWRK_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastNTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_UPDCNT_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastNTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_ADDCHG_TRIG_PULL):
                WinsIntfStat.TimeStamps.LastACTRplTime = *pSysTime;
                break;
         case(WINSINTF_E_COUNTER_RESET):
                WinsIntfStat.TimeStamps.CounterResetTime   = *pSysTime;
                break;
         default:
                DBGPRINT1(EXC, "WinsIntfSetTime: Weird Timestamp type = (%d)\n", TimeType_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                break;
        }
        LeaveCriticalSection(&WinsIntfCrtSec);

        if (pTime)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);
            SystemTimeToTzSpecificLocalTime(&tzInfo, pSysTime, pTime);
        }

        return;
}

DWORD
WinsDelDbRecs(
        IN PWINSINTF_ADD_T        pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This func. deletes a specified range of records belonging to a
        particular owner

Arguments:


Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsDelDbRecs

Side Effects:

Comments:
        None
--*/

{

        COMM_ADD_T        Address;
        DWORD                RetVal = WINSINTF_SUCCESS;
        DWORD                dwOwnerId;
        BOOL                fAllocNew = FALSE;

          Address.AddTyp_e  = pAdd->Type;
          Address.AddLen    = pAdd->Len;
          Address.Add.IPAdd = pAdd->IPAdd;

        //
        // initialize this thread with the db engine
        //
          NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsDelDbRecs");


        if (RplFindOwnerId(
                        &Address,
                        &fAllocNew,        //do not allocate an entry if not
                                        //present
                        &dwOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                      ) != WINS_SUCCESS)

        {
                DBGPRINT0(DET, "WinsDelDataRecs: WINS is not in the owner-add mapping table\n");
                RetVal = WINSINTF_FAILURE;
        }
        else
        {
            if (NmsDbDelDataRecs(
                        dwOwnerId,
                        MinVersNo,
                        MaxVersNo,
                        TRUE,         //enter critical section
                        FALSE         //no fragmented deletion
                        ) != WINS_SUCCESS)
            {
                RetVal = WINSINTF_FAILURE;
            }
        }

          //
          // Let us end the session
          //
        NmsDbCloseTables();
          NmsDbEndSession();
        return(RetVal);
}

DWORD
WinsTombstoneDbRecs(
        IN PWINSINTF_ADD_T           pAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This func. tombstones a specified range of records belonging to a
        particular owner

Arguments:


Externals Used:
        None


Return Value:

   Success status codes -- WINSINTF_SUCCESS
   Error status codes   -- WINSINTF_FAILURE

Error Handling:

Called by:
        R_WinsTombstoneDbRecs

Side Effects:


Comments:
        None
--*/

{

        DWORD                RetVal = WINSINTF_SUCCESS;
        COMM_ADD_T        Address;
        DWORD                dwOwnerId;
        BOOL                fAllocNew = FALSE;

        Address.AddTyp_e  = pAdd->Type;
        Address.AddLen    = pAdd->Len;
        Address.Add.IPAdd = pAdd->IPAdd;


        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsTombstoneDbRecs");

        if (RplFindOwnerId(
                        &Address,
                        &fAllocNew,        //do not allocate an entry if not
                                        //present
                        &dwOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                      ) != WINS_SUCCESS)

        {
                DBGPRINT0(DET, "WinsTombstoneDataRecs: WINS is not in the owner-add mapping table\n");
                RetVal = WINSINTF_FAILURE;
        }else if(NmsDbTombstoneDataRecs(
                    dwOwnerId,
                    MinVersNo,
                    MaxVersNo
                    ) != WINS_SUCCESS)
        {
            RetVal = WINSINTF_FAILURE;
        }
        // Let us end the session
        NmsDbCloseTables();
        NmsDbEndSession();
        return(RetVal);
}

DWORD
WinsPullRange(
        IN PWINSINTF_ADD_T        pWinsAdd,
        IN PWINSINTF_ADD_T        pOwnerAdd,
        IN WINSINTF_VERS_NO_T        MinVersNo,
        IN WINSINTF_VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This function is called to pull a range of records owned by a particular
        WINS server from another WINS server.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PWINSINTF_PULL_RANGE_INFO_T pPullRangeInfo;
        PRPL_CONFIG_REC_T        pPnr;
        BOOL                        fRplPnr = FALSE;
        DWORD                        RetCode = WINSINTF_SUCCESS;


        //
        // if the minimum version number is > than the max version number
        // return a failure code
        //
        if (LiGtr(MinVersNo, MaxVersNo))
        {
                return(WINSINTF_FAILURE);

        }
        //
        // Enter the critical sections guarded by WinsCnfCnfCrtSec and
        // NmsNmhNamRegCrtSec. There is no danger of deadlock because we
        // always enter the two critical sections in the following sequence
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

PERF("Do we need to enter the following critical section")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {
        pPnr = WinsCnf.PullInfo.pPullCnfRecs;

        //
        // If we are allowed to pull only from configured partners,
        // let us try to find the config record of the partner
        //
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
           if (pPnr != NULL)
           {
              //
              // Search for the Cnf record for the WINS we want to
              // send the PULL RANGE request to.
              //
              for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                        !fRplPnr;
                                // no third expression
                  )
               {


                   //
                   // Check if this is the one we want
                   //
                   if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->IPAdd)
                   {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        fRplPnr = TRUE;

                        //
                        // Make it 0, so that we always try to establish
                        // a connection.  Otherwise, pull thread may not
                        // try if it has already exhausted the number of
                        // retries
                        //
                        pPnr->RetryCount = 0;
                        continue;                //so that we can break out

                   }
                   //
                   // Get the next record that follows this one sequentially
                   //
                   pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
              } // end of for
          } // end of if (pPnr != 0)
       }  // end of if (fRplOnlyWCnfPnrs)
       else
       {
                pPnr = WinsMscHeapAlloc( NmsRpcHeapHdl, RPL_CONFIG_REC_SIZE);
                COMM_INIT_ADD_M(&pPnr->WinsAdd, pWinsAdd->IPAdd);
                pPnr->MagicNo           = 0;
                pPnr->RetryCount        = 0;
                pPnr->LastCommFailTime  = 0;
                pPnr->PushNtfTries    = 0;
                fRplPnr                     = TRUE;

                //
                // We want the buffer to be deallocated by the PULL thread
                //
                pPnr->fTemp   = TRUE;

//#if RPL_TYPE
                //
                // We need to pull according to the RplType for the pull pnrs
                //
                pPnr->RplType = WinsCnf.PullInfo.RplType;
//#endif

       }


        if (fRplPnr)
        {
            pPullRangeInfo = WinsMscHeapAlloc(
                                        NmsRpcHeapHdl,
                                        sizeof(WINSINTF_PULL_RANGE_INFO_T)
                                             );
#if 0
            WinsMscAlloc(sizeof(WINSINTF_PULL_RANGE_INFO_T),
                                  &pPullRangeInfo);
#endif
            pPullRangeInfo->pPnr      =  pPnr;
            pPullRangeInfo->OwnAdd    =  *pOwnerAdd;
            pPullRangeInfo->MinVersNo =  MinVersNo;
            pPullRangeInfo->MaxVersNo =  MaxVersNo;


           //
           // Call RplInsertQue to insert the push request to
           // the Pull Thread
           //
           ERplInsertQue(
                     WINS_E_WINSRPC,
                     QUE_E_CMD_PULL_RANGE,
                     NULL,        //no Dlg Hdl
                     NULL,        //no msg is there
                     0,                //msg length
                     pPullRangeInfo,       //client context
                     pPnr->MagicNo
                     );
        }
 }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("WinsPullRange");
                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_PUSH_TRIGGER_EXC);
                RetCode = WINSINTF_FAILURE;
  }

        //
        // Leave the critical section guarded by NmsNmhNamRegCrtSec.
        //
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        //
        // if replication was allowed only with configured partners and
        // there was no WINS with the address specified by the client,
        // return failure
        //
        if (!fRplPnr)
        {
                RetCode = WINSINTF_FAILURE;
        }

        return(RetCode);
}

DWORD
WinsSetPriorityClass(
        IN WINSINTF_PRIORITY_CLASS_E        PriorityClass_e
        )

/*++

Routine Description:
        This function sets the priority class of the Wins process.

Arguments:
        PriorityClass -- Priority Class of the WINS process

Externals Used:
        WinsCnf


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        //DWORD   OldPrCls;
        DWORD   NewPrCls;
        HANDLE  ProcHdl;
        DWORD   RetVal = WINSINTF_SUCCESS;

        switch(PriorityClass_e)
        {
                case(WINSINTF_E_NORMAL):
                        NewPrCls = NORMAL_PRIORITY_CLASS;
                        break;
                case(WINSINTF_E_HIGH):
                        NewPrCls = HIGH_PRIORITY_CLASS;
                        break;
                default:
                        DBGPRINT0(DET, "WinsSetPriorityClass: Invalid Priority Class\n");
                        return(WINSINTF_FAILURE);
                        break;
        }


        ProcHdl = GetCurrentProcess();

        EnterCriticalSection(&WinsCnfCnfCrtSec);
#if 0
try {
FUTURES("Use a WinsMsc functions here for consistency")

        if ((OldPrCls = GetPriorityClass(ProcHdl)) == 0)
        {
                DBGPRINT1(ERR, "WinsSetPriorityClass: Can not Proc Priority. Error = (%d)\n", GetLastError());
                RetVal = WINSINTF_FAILURE;
        }
        else
        {
           if (OldPrCls == NewPrCls)
           {
                DBGPRINT1(ERR, "WinsSetPriorityClass: Process already has this Priority Class = (%d)\n", NewPrCls);
           }
           else
           {
#endif
                if (SetPriorityClass(ProcHdl, NewPrCls) == FALSE)
                {
                        DBGPRINT1(ERR, "WinsSetPriorityClass: SetPriorityClass() Failed. Error = (%d)\n", GetLastError());
                }
                else
                {
                        WinsCnf.WinsPriorityClass = (DWORD)PriorityClass_e;
                }
#if 0
           }
       }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsSetPriorityCls");
        }
#endif

        //
        // ProcHdl is a pseudo-handle and does not need to be closed
        //
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
        return(WINSINTF_SUCCESS);
}

DWORD
WinsResetCounters(
        VOID
        )

/*++

Routine Description:
        This function resets/clears the counters

Arguments:
        None

Externals Used:
        NmsNmhNamRegCrtSec

Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
        R_WinsResetCounters

Side Effects:

Comments:
        None
--*/

{
  DWORD i;
  PRPL_CONFIG_REC_T         pPnr;
  //
  // Copy the counters
  //
  EnterCriticalSection(&NmsNmhNamRegCrtSec);
  (VOID)RtlFillMemory(&WinsIntfStat.Counters, sizeof(WinsIntfStat.Counters), 0);
  LeaveCriticalSection(&NmsNmhNamRegCrtSec);
  // now clear the per partner info.
  EnterCriticalSection(&WinsCnfCnfCrtSec);
  pPnr       = WinsCnf.PullInfo.pPullCnfRecs;
  for (i = 0; (i<WinsCnf.PullInfo.NoOfPushPnrs) && (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE) ; i++) {
      pPnr->NoOfRpls = 0;
      pPnr->NoOfCommFails = 0;
      pPnr = WinsCnfGetNextRplCnfRec(pPnr,RPL_E_IN_SEQ);
  }
  LeaveCriticalSection(&WinsCnfCnfCrtSec);

  //
  // Even if we have multiple threads doing resets (unlikely occurence),
  // the window between the above critical section and the one entered
  // by the following function does not cause any problem.
  //
  WinsIntfSetTime(NULL, WINSINTF_E_COUNTER_RESET);

  return(WINSINTF_SUCCESS);
}

DWORD
WinsWorkerThdUpd(
        DWORD NewNoOfNbtThds
        )

/*++

Routine Description:
        This function is called to change the count of the NBT threads in
        the WINS process.

Arguments:
        NewNoOfNbtThds  - The new count of the Nbt threads

Externals Used:
        None


Return Value:

   Success status codes --  WINSINTF_SUCCESS
   Error status codes   --  WINSINTF_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        //
        // If the WINS server is not in steady state or if the new count
        // of Nbt threads requested is outside the allowed range, return
        // failure
        //
CHECK("Somehow, if the number of threads is equal to the max. number allowed")
CHECK("pTls comes out as NULL for all NBT threads (seen at termination)")
          if (

             ((WinsCnf.State_e != WINSCNF_E_RUNNING)
                        &&
             (WinsCnf.State_e != WINSCNF_E_PAUSED))
                        ||
             (NewNoOfNbtThds >= WINSTHD_MAX_NO_NBT_THDS)
                        ||
             (NewNoOfNbtThds < WINSTHD_MIN_NO_NBT_THDS)
          )
          {
                return(WINSINTF_FAILURE);
          }

        EnterCriticalSection(&WinsCnfCnfCrtSec);
        WinsIntfNoOfNbtThds = NewNoOfNbtThds;

try {
        //
        // If the new count is more than the existing count, store the new
        // count in a global and signal an Nbt thread. The signaled
        // Nbt thread will create all the extra threads needed
        //
        if (NewNoOfNbtThds > NmsNoOfNbtThds)
        {
                WinsMscSignalHdl(NmsCrDelNbtThdEvt);
        }
        else
        {
                //
                // if the new count is same as the existing count, return
                // success
                //
                if (NewNoOfNbtThds == NmsNoOfNbtThds)
                {
                        DBGPRINT1(FLOW, "WinsWorkerThdUpd: Wins server already has %d threads\n", NewNoOfNbtThds);
                }
                else  // NewNoOfNbtThds < NmsNoOfNbtThds
                {
                        //
                        // Signal a thread to delete self. The signaled thread will
                        // signal the event again if more than one thread has to be
                        // deleted
                        //
                        WinsMscSignalHdl(NmsCrDelNbtThdEvt);
                }
        }
}
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsWorkerThdUpd");
        }

        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        return(WINSINTF_SUCCESS);
}



DWORD
WinsGetNameAndAdd(
        PWINSINTF_ADD_T   pWinsAdd,
        LPBYTE                      pUncName
        )
{
  DWORD RetStat = WINSINTF_SUCCESS;

//  TCHAR UncName[MAX_COMPUTERNAME_LENGTH + 1];
//  DWORD LenOfBuff = WINSINTF_MAX_COMPUTERNAME_LENGTH;
  DWORD LenOfBuff = MAX_COMPUTERNAME_LENGTH + 1;
  pWinsAdd->IPAdd = NmsLocalAdd.Add.IPAdd;
FUTURES("Change this to GetComputerName when winsadmn is made unicode compliant")
  if (GetComputerNameA(pUncName, &LenOfBuff) == FALSE)
  {
     DBGPRINT1(ERR, "WinsGetNameAndAdd: Name error. Error=(%x)\n", GetLastError());
     RetStat = GetLastError();
  }
  return(RetStat);
}



#define INITIAL_RAMPUP_NO       3

DWORD
WinsGetBrowserNames(
        PWINSINTF_BIND_DATA_T             pWinsHdl,
        PWINSINTF_BROWSER_NAMES_T         pNames
        )
{

        DWORD              RetVal = WINSINTF_SUCCESS;
        time_t             CurrentTime;
        static   DWORD     sNoOfTimes = 0;
        static   time_t    sLastTime = 0;
        BOOL               fPopCache = FALSE;


        UNREFERENCED_PARAMETER(pWinsHdl);

        //
        // If this the initial ramp up period, populate the cache
        //
        if (sNoOfTimes++ < INITIAL_RAMPUP_NO)
        {
                //
                // if this is the first call, create the dom. cache event.
                //
                if (sNoOfTimes == 1)
                {
                    WinsMscCreateEvt(L"WinsDomCachEvt", FALSE, &sDomCache.EvtHdl);
                }
                DBGPRINT1(SPEC, "WinsGetBrowserNames: sNoOfTimes = (%d)\n", sNoOfTimes);
                fPopCache = TRUE;
        }
        else
        {
          //
          // Initial ramp up period is past.  Populate the cache if 3 mts
          // have expired since it was last populated
          //
          if ((time(&CurrentTime) - sLastTime) > THREE_MTS || sDomCache.bRefresh)
          {
                DBGPRINT0(SPEC, "WinsGetBrowserNames: Pop Cache due to timeout\n");
                sDomCache.bRefresh = FALSE;
                sLastTime = CurrentTime;
                fPopCache = TRUE;
          }
        }
try {
        //
        // Populate the cache if fPopCache is set or if the number of entries
        // in the current cache are 0
        //
        if (fPopCache || (sDomCache.SzOfBlock == 0))
        {
          //
          // if our cache has some data, deallocate it first.
          //
          // Note: There could be an rpc thread in the rpc code accessing
          // this buffer. I can't free this buffer until it is done.
          //
          if (sDomCache.SzOfBlock > 0)
          {
                DWORD i;
                PWINSINTF_BROWSER_INFO_T pBrInfo = sDomCache.pInfo;
                DWORD NoOfUsers;

                //
                // Wait until all users are done. We won't iterate more than
                //
                // We can iterate a max. of INITIAL_RAMPUP_NO of times and
                // that too only at initial ramp up time. If a thread is
                // waiting on the event, another thread will also wait
                // on it (except during initial rampup time)
                //
                do {
                 EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);
                 NoOfUsers = sDomCache.NoOfUsers;
                 LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);
                 if (NoOfUsers > 0)
                 {
                    WinsMscWaitInfinite(sDomCache.EvtHdl);
                 }
                } while (NoOfUsers > 0);
                //
                // Free all memory allocated for names
                //
                for (i=0;  i< sDomCache.EntriesRead; i++, pBrInfo++)
                {
                   midl_user_free(pBrInfo->pName);
                }

                //
                // Free the main block
                //
                midl_user_free(sDomCache.pInfo);
                sDomCache.SzOfBlock = 0;
                pNames->EntriesRead = 0;
                pNames->pInfo = NULL;
          }

          NmsDbThdInit(WINS_E_WINSRPC);
          NmsDbOpenTables(WINS_E_WINSRPC);
          DBGMYNAME("RPC-WinsGetBrowserNames");

          //
          // Get all records starting with 1B Names
          //
          RetVal = NmsDbGetNamesWPrefixChar(
                                        0x1B,
                                        &pNames->pInfo,
                                        &pNames->EntriesRead
                                          );
          NmsDbCloseTables();
          NmsDbEndSession();

          //
          // Store the info. only if there is something to be stored.
          //
          if (
                (RetVal == WINS_SUCCESS)
                        &&
                (pNames->EntriesRead > 0)
             )
          {
             sDomCache.SzOfBlock =
                        pNames->EntriesRead * sizeof(WINSINTF_BROWSER_INFO_T);
            // sDomCache.pInfo = midl_user_allocate(sDomCache.SzOfBlock);
            // WINSMSC_COPY_MEMORY_M(sDomCache.pInfo, pNames->pInfo,
    //                                            sDomCache.SzOfBlock);
             sDomCache.pInfo = pNames->pInfo;
             sDomCache.EntriesRead = pNames->EntriesRead;
          }
          else
          {
                //
                // We did not get anything from the db
                //
                sDomCache.SzOfBlock = 0;
                pNames->EntriesRead = 0;
                pNames->pInfo = NULL;
          }
        }
        else
        {
                //
                // Use the cached info.
                //
                //pNames->pInfo = midl_user_allocate(sDomCache.SzOfBlock);
                //WINSMSC_COPY_MEMORY_M(pNames->pInfo, sDomCache.pInfo,
                //                                sDomCache.SzOfBlock);
                pNames->pInfo = sDomCache.pInfo;
                pNames->EntriesRead = sDomCache.EntriesRead;
        }
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetBrowserNames");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_BROWSER_NAME_EXC);
        pNames->EntriesRead = 0;
        pNames->pInfo = NULL;
        RetVal = WINSINTF_FAILURE;
        }
        return(RetVal);
}

VOID
R_WinsGetBrowserNames_notify_flag(boolean __MIDL_NotifyFlag
)
/*++

Routine Description:
  Called by rpc to indicate that it is done with the buffer returned by
  WinsGetBrowserNames

Arguments:

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
     //
     // Decrement the user count. If equal to 0, signal the event to let
     // another thread go on.
     //
     EnterCriticalSection(&WinsIntfNoOfUsersCrtSec);

     //
     // workaround an rpc bug (18627) where it may call notify without calling
     // R_WinsGetBrowserNames (checkout winsif_s.c)
     //
     if (
           (sDomCache.NoOfUsers > 0) &&
           (--sDomCache.NoOfUsers == 0) &&
           sDomCache.EvtHdl != NULL
        )
     {
          WinsMscSignalHdl(sDomCache.EvtHdl);
     }
     LeaveCriticalSection(&WinsIntfNoOfUsersCrtSec);
     return;
}

DWORD
WinsDeleteWins(
        PWINSINTF_ADD_T   pWinsAdd
        )
{
        PCOMM_ADD_T        pAdd;
        DWORD                RetVal = WINSINTF_FAILURE;


        if (pWinsAdd->IPAdd == NmsLocalAdd.Add.IPAdd)
        {
                WINSINTF_VERS_NO_T MinVersNo = {0};
                WINSINTF_VERS_NO_T MaxVersNo = {0};
                RetVal = WinsDelDbRecs(pWinsAdd, MinVersNo, MaxVersNo);
#if 0
                //
                // We always keep the entry for the local WINS. For any
                //
                DBGPRINT0(ERR, "WinsDeleteWins: Sorry, you can not delete the entry for the local WINS\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_DELETE_LOCAL_WINS_DISALLOWED);
                RetVal = WINSINTF_CAN_NOT_DEL_LOCAL_WINS;
#endif
        }
        else
        {
                WCHAR String[WINS_MAX_NAME_SZ];
                struct in_addr InAddr;

                InAddr.s_addr = htonl(pWinsAdd->IPAdd);
                (VOID)WinsMscConvertAsciiStringToUnicode(
                            inet_ntoa( InAddr),
                            (LPBYTE)String,
                            WINS_MAX_NAME_SZ);

                WinsLogAdminEvent(WINS_EVT_ADMIN_DEL_OWNER_INITIATED,1,String);

                //
                // Allocate from the general heap (not from the rpc heap)
                // since this memory will be deallocated by DeleteWins in
                // rplpull.c which I don't want to tie to just rpc work.
                //
                   WinsMscAlloc(sizeof(COMM_ADD_T), &pAdd);
                   pAdd->AddTyp_e = pWinsAdd->Type;
                   pAdd->AddLen    = pWinsAdd->Len;
                pAdd->Add.IPAdd = pWinsAdd->IPAdd;

                //
                // Call RplInsertQue to insert the push request to
                // the Pull Thread
                //
                ERplInsertQue(
                     WINS_E_WINSRPC,
                     QUE_E_CMD_DELETE_WINS,
                     NULL,        //no Dlg Hdl
                     NULL,        //no msg is there
                     0,                //msg length
                     pAdd,   //client context,
                     0      //no magic no
                     );
                RetVal = WINSINTF_SUCCESS;
        }
        return(RetVal);
}

#define MAX_RECS_TO_RETURN  5000
DWORD
WinsGetDbRecsByName (
        PWINSINTF_ADD_T             pWinsAdd,
        DWORD                       Location,
        LPBYTE                      pName,
        DWORD                       NameLen,
        DWORD                       NoOfRecsDesired,
        DWORD                       TypeOfRecs,
        PWINSINTF_RECS_T            pRecs
        )

/*++

Routine Description:
        This function returns with all the records (that can fit into the
        buffer passed) owned by a WINS in the local db of this WINS.

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        COMM_ADD_T           Address;
        LPVOID               pBuff = NULL;
        DWORD                BuffLen;
        DWORD                NoOfRecs = 0;
        DWORD                Status;
        PWINSTHD_TLS_T        pTls;

        DBGENTER("WinsGetDbRecsByName\n");


        if ((NoOfRecsDesired == 0) || (NoOfRecsDesired > MAX_RECS_TO_RETURN))
        {
                NoOfRecsDesired = MAX_RECS_TO_RETURN;
        }


        if ((pWinsAdd != NULL) && (pWinsAdd->IPAdd != 0))
        {
                  Address.AddTyp_e  = pWinsAdd->Type;
                  Address.AddLen    = pWinsAdd->Len;
                  Address.Add.IPAdd = pWinsAdd->IPAdd;
        }
        //
        // initialize this thread with the db engine
        //
        NmsDbThdInit(WINS_E_WINSRPC);
        NmsDbOpenTables(WINS_E_WINSRPC);
        DBGMYNAME("RPC-WinsGetDbRecsByName");
 try {
        if ((pName != NULL) && (NameLen != 0))
        {
           //
           // Terminate name with NULL, just in case user didn't do it.
           //
           *(pName + NameLen) = (BYTE)NULL;
        }
        if ((pName == NULL) && (NameLen > 0))
        {
             NameLen = 0;
        }

PERF("The caller can pass the number of records for which space has been")
PERF("allocated in buffer pointed to by pRec in the NoOfRecs field. We should")
PERF("We should pass this argument to NmsDbGetDataRecs so that it does not get")
PERF("more records than are necessary")

        Status = NmsDbGetDataRecsByName(
                        pName,
                        NameLen != 0 ? NameLen + 1 : 0,
                        Location,
                        NoOfRecsDesired,
                        pWinsAdd != NULL ? &Address : NULL,
                        TypeOfRecs,
                        &pBuff,
                        &BuffLen,
                        &NoOfRecs
                        );


        if (Status == WINS_SUCCESS)
        {
            Status = PackageRecs( pBuff, BuffLen, NoOfRecs, pRecs);
        }

      }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecsByName");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        Status = WINS_FAILURE;
 }
        //
        // Free the buffer and destroy the heap.
        //
        GET_TLS_M(pTls);
        if (pTls->HeapHdl != NULL)
        {
               if (pBuff != NULL)
               {
                  WinsMscHeapFree(pTls->HeapHdl, pBuff);
               }
               WinsMscHeapDestroy(pTls->HeapHdl);
//               pTls->HeapHdl = NULL;
        }

        //
        // Let us end the session
        //
        NmsDbCloseTables();
        NmsDbEndSession();

        if (Status != WINS_SUCCESS)
        {
            pRecs->pRow = NULL;
            pRecs->NoOfRecs = 0;
            Status = WINSINTF_FAILURE;
        }
        else
        {
            if (pRecs->NoOfRecs == 0)
            {
              pRecs->pRow = NULL;
              pRecs->NoOfRecs = 0;
              Status = WINSINTF_REC_NOT_FOUND;
            }
        }
        DBGLEAVE("WinsGetDbRecsByName\n");
        return (Status);
}

STATUS
PackageRecs(
        PRPL_REC_ENTRY2_T     pBuff,
        DWORD                BuffLen,
        DWORD                NoOfRecs,
        PWINSINTF_RECS_T     pRecs
     )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
//        ULONG                Status;
        BOOL                 fExcRaised = FALSE;
        PWINSINTF_RECORD_ACTION_T pRow;
        DWORD                i;
        DWORD                ind;
        DWORD                EntType;
 //       DWORD                MaxAdds;
        PWINSTHD_TLS_T       pTls;

        DBGENTER("PackageRecs\n");

        i = 0;
        GET_TLS_M(pTls);
try {

        //
        // If there are records to send back and the client has specified
        // a buffer for them, insert the records
        //
        if  (NoOfRecs > 0)
        {

          //
          // Allocate memory for the no of records
          //
          pRecs->BuffSize  =  sizeof(WINSINTF_RECORD_ACTION_T) * NoOfRecs;

          //
          // If memory can not be allocate, an exception will be returned
          // by midl_user_alloc
          //
          pRecs->pRow      =  midl_user_allocate(pRecs->BuffSize);

#if 0
          pRecs->pRow      =  RpcSmAllocate(pRecs->BuffSize, &Status);

          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "PackageRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif
          pRow                    =  pRecs->pRow;


          for (; i<NoOfRecs; i++)
          {

                //
                // Initialize so that we don't get "enum wrong" error.
                //
                pRow->Cmd_e = WINSINTF_E_QUERY;

                //
                // the name retrieved has NULL as the last character.  This
                // We need to pass a name without this NULL.
                //
                pRow->NameLen = pBuff->NameLen;
                if (*pBuff->pName == 0x1B)
                {
                        WINS_SWAP_BYTES_M(pBuff->pName, pBuff->pName + 15);
                }

                // +1 added to fix #390830
                pRow->pName =  midl_user_allocate(pRow->NameLen + 1);
#if 0
                pRow->pName =  RpcSmAllocate(pRow->NameLen, &Status);
                if (Status != RPC_S_OK)
                {
                   DBGPRINT1(ERR, "PackageRecs: RpcSmAllocate returned error = (%x)\n", Status);
                }
#endif
                WINSMSC_COPY_MEMORY_M(pRow->pName, pBuff->pName,pRow->NameLen);
                WinsMscHeapFree(pTls->HeapHdl, pBuff->pName);

                EntType = NMSDB_ENTRY_TYPE_M(pBuff->Flag);
                pRow->TypOfRec_e = NMSDB_ENTRY_UNIQUE_M(EntType)
                                                         ? WINSINTF_E_UNIQUE :
                                (NMSDB_ENTRY_NORM_GRP_M(EntType) ?
                                        WINSINTF_E_NORM_GROUP :
                                (NMSDB_ENTRY_SPEC_GRP_M(EntType) ?
                                        WINSINTF_E_SPEC_GROUP :
                                        WINSINTF_E_MULTIHOMED));


                if (
                    (pRow->TypOfRec_e == WINSINTF_E_SPEC_GROUP) ||
                    (pRow->TypOfRec_e == WINSINTF_E_MULTIHOMED)
                   )
                {
                        PWINSINTF_ADD_T       pAdd;
                        DWORD                 No;

                        if (pBuff->NoOfAdds > 0)
                        {
                            pRow->NoOfAdds = pBuff->NoOfAdds * 2;


                           //
                           // Each member is comprised of two addresses,
                           // first address is that of the owner WINS, second
                           // address is that of the node registered
                           //
                           pRow->pAdd        =
//                             RpcSmAllocate(
                             midl_user_allocate(
                                        (unsigned int)(pRow->NoOfAdds)
                                                *
                                        sizeof(WINSINTF_ADD_T)//,
//                                        &Status
                                             );

#if 0
          if (Status != RPC_S_OK)
          {
             DBGPRINT1(ERR, "WinsGetDbRecs: RpcSmAllocate returned error = (%x)\n", Status);
          }
#endif

                           for (
                                No= 0, ind= 0, pAdd = pRow->pAdd;
                                No < (pRow->NoOfAdds/2);
                                No++
                            )
                          {
                           pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ind)->AddTyp_e;
                           pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                           pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind)->Add.IPAdd;

                           pAdd->Type     =  (UCHAR)(pBuff->pNodeAdd + ++ind)->AddTyp_e;
                           pAdd->Len      =  (pBuff->pNodeAdd + ind)->AddLen;
                           pAdd++->IPAdd  =  (pBuff->pNodeAdd + ind++)->Add.IPAdd;
                          }
                          WinsMscHeapFree(pTls->HeapHdl, pBuff->pNodeAdd);
                       }
                }
                else
                {
                          pRow->NoOfAdds =  0;
                          pRow->pAdd       = NULL;
                          pRow->Add.Type   = (UCHAR)pBuff->NodeAdd[0].AddTyp_e;
                          pRow->Add.Len    = pBuff->NodeAdd[0].AddLen;
                          pRow->Add.IPAdd  = pBuff->NodeAdd[0].Add.IPAdd;
                }
                pRow->NodeTyp     = (BYTE)NMSDB_NODE_TYPE_M(pBuff->Flag);
                pRow->fStatic     = NMSDB_IS_ENTRY_STATIC_M(pBuff->Flag);
                pRow->State_e     = NMSDB_ENTRY_STATE_M(pBuff->Flag);
                pRow->VersNo      = pBuff->VersNo;
                pRow->TimeStamp   = pBuff->TimeStamp;
                pRow->OwnerId     = pBuff->OwnerId;
                pRow++;


                pBuff = (PRPL_REC_ENTRY2_T)((LPBYTE)pBuff + RPL_REC_ENTRY2_SIZE);
PERF("Do the addition above the for loop and store in a var. Use var. here")

         } // end of for loop
        } //end of if block
        else
        {
                pRecs->pRow = NULL;
        }

 }        // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("WinsGetDbRecs");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPC_EXC);
        fExcRaised = TRUE;
        }

        pRecs->TotalNoOfRecs = NoOfRecs;

        if (!fExcRaised)
        {
           pRecs->NoOfRecs = i;
        }
        else
        {
        //     RpcSmFree(pRecs->pRow);
            midl_user_free(pRecs->pRow);
            pRecs->NoOfRecs = 0;
        }

        DBGENTER("PackageRecs\n");
        return (WINSINTF_SUCCESS);
}




//void __RPC_FAR * __RPC_API
void *
midl_user_allocate(size_t cBytes)
{
#if 0
//#ifdef WINSDBG
        LPVOID pMem = WinsMscHeapAlloc(NmsRpcHeapHdl, cBytes);
        DBGPRINT1(DET, "midl_user_alloc: Memory allocated is (%d)\n", pMem);
        return(pMem);
//#else
#endif
        return(WinsMscHeapAlloc(NmsRpcHeapHdl, cBytes));
}

//void __RPC_FAR __RPC_API
void
//midl_user_free(void __RPC_FAR *pMem)
midl_user_free(void  *pMem)
{
        if (pMem != NULL)
        {
//                DBGPRINT1(DET, "midl_user_free: Memory to free is (%d)\n", pMem);
                WinsMscHeapFree(NmsRpcHeapHdl, pMem);
        }
        return;
}

VOID
LogClientInfo(
  RPC_BINDING_HANDLE ClientHdl,
  BOOL                   fAbruptTerm
  )
{
  RPC_STATUS        RpcRet;
  RPC_BINDING_HANDLE Binding;
  PTUCHAR pStringBinding;
  PTUCHAR pProtSeq;
  PTUCHAR pNetworkAddress;
  WINSEVT_STRS_T EvtStrs;

NOTE("remove #if 0 when we go to 540 or above")
#if 0
  RpcRet = RpcBindingServerFromClient(ClientHdl,  &Binding);

  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: Can not get binding handle. Rpc Error = (%d)\nThis could be because named pipe protocol is being used\n", RpcRet);
        Binding = ClientHdl;
  }
#endif
NOTE("remove when we go to 540 or above")
  Binding = ClientHdl;


  RpcRet = RpcBindingToStringBinding(Binding, &pStringBinding);
  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: RpcBindingToStringBinding returned error = (%d)\n", RpcRet);
          return;
  }
  RpcRet = RpcStringBindingParse(
                                pStringBinding,
                                NULL,        //don't want uuid
                                &pProtSeq,
                                &pNetworkAddress,
                                NULL,                //end point
                                NULL                //network options
                                );
  if (RpcRet != RPC_S_OK)
  {
        DBGPRINT1(ERR, "LogClientInfo: RpcStringBindingParse returned error = (%d)\n", RpcRet);
        RpcStringFree(&pStringBinding);
          return;
  }

#ifndef UNICODE
  DBGPRINT2(FLOW, "LogClientInfo: The protocol sequence and address used by client are (%s) and (%s)\n", pProtSeq, pNetworkAddress);
#else
#ifdef WINSDBG
  IF_DBG(FLOW)
  {
    wprintf(L"LogClientInfo: The protocol sequence and address used by client are (%s) and (%s)\n", pProtSeq, pNetworkAddress);
  }
#endif
#endif
  RpcStringFree(&pProtSeq);
  RpcStringFree(&pNetworkAddress);

  EvtStrs.NoOfStrs = 1;
  EvtStrs.pStr[0] = (LPTSTR)pNetworkAddress;
  if (fAbruptTerm)
  {
    WINSEVT_LOG_STR_D_M(WINS_EVT_ADMIN_ABRUPT_SHUTDOWN, &EvtStrs);
  }
  else
  {
    WINSEVT_LOG_STR_D_M(WINS_EVT_ADMIN_ORDERLY_SHUTDOWN, &EvtStrs);
  }
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winsprs.c ===
// NOTE:
//
// Unless the data read from the STATIC file is converted to UNICODE, we should
// not have UNICODE defined for this module
//
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	winsprs.c

Abstract:
    This source contains the functions that parse the lmhosts file.


Functions:
	GetTokens,
	IsKeyWord,
	Fgets,
	PrimeDb
	ExpandName,
	RegOrdinaryName,
	RegGrpName
	WinsPrsDoStaticInit
	

Portability:

	This module is portable


Author:

	Pradeep Bahl (PradeepB)  	Apr-1993

	Stole the parsing code from lm_parse.c, lm_io.c, and lm_parse.c in
	streams\tcpip\nbt; Modified it appropriately

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include <ctype.h>
#include <string.h>
#include "wins.h"
#include "nms.h"		//required for DBGPRINT statements
#include <winuser.h>
#include "winsevt.h"
#include "winsprs.h"
#include "winsmsc.h"
#include "nmsmsgf.h"
#include "nmsnmh.h"
#include "comm.h"
#include "winsintf.h"


/*
 *	Local Macro Declarations
*/


#define   DOMAIN_TOKEN 		"#DOM:"
#define   PRELOAD_TOKEN 	"#PRE"
#define   INCLUDE_TOKEN		"#INCLUDE"
#define   BEG_ALT_TOKEN		"#BEGIN_ALTERNATE"
#define   END_ALT_TOKEN		"#END_ALTERNATE"

#define   DOMAIN_TOKEN_SIZE 	(sizeof(DOMAIN_TOKEN) - 1)	

//
// To mark special groups in the lmhosts file
//
#define   SPEC_GRP_TOKEN 	"#SG:"
#define   SPEC_GRP_TOKEN_SIZE 	(sizeof(SPEC_GRP_TOKEN) - 1)	

//
// To indicate an mh node
//
#define   MH_TOKEN 	         "#MH"
#define   MH_TOKEN_SIZE          (sizeof(MH_TOKEN) - 1)	



#define  QUOTE_CHAR		'"'
#define  TAB_CHAR		'\t'
#define  SPACE_CHAR		' '
#define  CARRIAGE_RETURN_CHAR   '\r'
#define  NEWLINE_CHAR		'\n'
#define  COMMENT_CHAR		'#'
#define  BACKSLASH_CHAR		'\\'
#define  ZERO_CHAR      '0'
#define  x_CHAR         'x'
#define  X_CHAR			'X'

//
// Size of array to hold a non-coded netbios name read from a file (lmhosts)
//
#define NON_CODED_NAME_SIZE	17
/*
 *	Local Typedef Declarations
 */


//
// Private Definitions
//
typedef	struct _FILE_PARAM_T {
      		PWINSCNF_DATAFILE_INFO_T	pDataFile;
      		DWORD				NoOfFiles;
		} FILE_PARAM_T, *PFILE_PARAM_T;

//
// GetTokens() parses a line and returns the tokens in the following
// order:
//
typedef enum _TOKEN_ORDER_E {
    E_IPADDRESS = 0,                                      // first token
    E_NBNAME,                                             // 2nd token
    E_GROUPNAME,                                          // 3rd or 4th token
    E_NOTUSED,                                            // #PRE, if any
    E_MAX_TOKENS                                           // this must be last

} TOKEN_ORDER_E, *PTOKEN_ORDER_E;

//
// If the line category is E_SPEC_GRP, then we have just one token
//
#define SPEC_GRP_TOKEN_POS        0

//
// As each line in an lmhosts file is parsed, it is classified into one of
// the categories enumerated below.
//
// However, Preload is a special member of the enum (ignored by us).
//
//
typedef enum _TYPE_OF_LINE_E {

    E_COMMENT          = 0x0000,                         // comment line
    E_ORDINARY         = 0x0001,                         // ip_addr NetBIOS name
    E_DOMAIN           = 0x0002,                         // ... #DOM:name
    E_INCLUDE          = 0x0003,                         // #INCLUDE file
    E_BEGIN_ALTERNATE  = 0x0004,                         // #BEGIN_ALTERNATE
    E_END_ALTERNATE    = 0x0005,                         // #END_ALTERNATE
    E_SPEC_GRP         = 0x0006,                         // #Spec Grp
    E_SGWADD           = 0x0007,                         // #Spec Grp with add

    E_PRELOAD           = 0x8000,                         // ... #PRE
    E_MH                = 0x8001                        // ip_addr NetBIOS name
                                                         // for a mh machine
} TYPE_OF_LINE_E, *PTYPE_OF_LINE_E;


//
// In an lmhosts file, the following are recognized as keywords:
//
//     #BEGIN_ALTERNATE        #END_ALTERNATE          #PRE
//     #DOM:                   #INCLUDE
//
// Information about each keyword is kept in a KEYWORD structure.
//
//
typedef struct _KEYWORD_T {                           // reserved keyword
    LPBYTE           pKString;                         //  NULL terminated
    size_t          KStrlen;                          //  length of token
    TYPE_OF_LINE_E  KType_e;                          //  type of line
    DWORD           KNoOfOperands;                    //  max operands on line
} KEYWORD_T, *PKEYWORD_T;


//
// Information about the type of line read is kept in the LINE_CHARACTERISTICS
// structure
//
typedef struct _LINE_CHARACTERISTICS_T
{
    int     LineCategory:4;                               // enum _TYPE_OF_LINE
    int     LinePreload:1;                                // marked with #PRE ?
    int     Mh:1;                                         // marked with #MH ?
} LINE_CHARACTERISTICS_T, *PLINE_CHARACTERISTICS_T;

/*
 *	Global Variable Definitions
*/



/*
 *	Local Variable Definitions
 */


//
// In an lmhosts file, the token '#' in any column usually denotes that
// the rest of the line is to be ignored.  However, a '#' may also be the
// first character of a keyword.
//
// Keywords are divided into two groups:
//
//  1. decorations that must either be the 3rd or 4th token of a line,
//  2. directives that must begin in column 0,
//
//
KEYWORD_T Decoration[] = {
    DOMAIN_TOKEN,   sizeof(DOMAIN_TOKEN) - 1,   E_DOMAIN,   4,
    PRELOAD_TOKEN,  sizeof(PRELOAD_TOKEN) - 1,  E_PRELOAD,  4,
    SPEC_GRP_TOKEN, sizeof(SPEC_GRP_TOKEN) - 1, E_SGWADD,   4,
    MH_TOKEN,       sizeof(MH_TOKEN) - 1,       E_MH,       4,
    NULL,           0                                   // must be last
};


KEYWORD_T Directive[] = {
    INCLUDE_TOKEN,  sizeof(INCLUDE_TOKEN) - 1,  E_INCLUDE,         2,
    BEG_ALT_TOKEN,  sizeof(BEG_ALT_TOKEN) - 1,  E_BEGIN_ALTERNATE, 1,
    END_ALT_TOKEN,  sizeof(END_ALT_TOKEN) - 1,  E_END_ALTERNATE,   1,
    SPEC_GRP_TOKEN, sizeof(SPEC_GRP_TOKEN) - 1, E_SPEC_GRP, 1,
    NULL,           0                                   // must be last
};



/*
 *	Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


//
// Local (Private) Functions
//
STATIC
BOOL
ChkAdd(
    LPBYTE pstrAdd,
    LPDWORD pAdd
        );
STATIC
LINE_CHARACTERISTICS_T
GetTokens (
    IN OUT LPBYTE    pLine,
    OUT    LPBYTE    *ppToken,
    IN OUT LPDWORD  pNumTokens
    );

STATIC
PKEYWORD_T
IsKeyWord (
    IN LPBYTE 	  pString,
    IN PKEYWORD_T pTable
    );

STATIC
LPBYTE
Fgets (
	PWINSPRS_FILE_INFO_T	pFileInfo,
	LPDWORD			pCount
    );


STATIC
VOID
PrimeDb (
	PWINSPRS_FILE_INFO_T	pFileInfo
    );

STATIC
BOOL
ExpandName (
    OUT LPBYTE 	  pDest,
    IN  LPBYTE 	  pSrc,
    IN  BYTE 	  LastCh,
    OUT  LPBOOL    pfQuoted
    );

STATIC
VOID
CheckForInt(
    IN OUT LPBYTE 	  pDest,
    IN  BOOL      fQuoted
);

STATIC
VOID
RegOrdinaryName(
	LPBYTE	pName,
	DWORD	IpAdd	
  );

VOID
RegGrpName(
	LPBYTE	pName,
	DWORD	IpAdd,
        DWORD   TypeOfRec
	);
STATIC
DWORD
DoStaticInitThdFn(
	IN LPVOID	pThdParam
	);

STATIC
LINE_CHARACTERISTICS_T
GetTokens (
    IN OUT LPBYTE   pLine,
    OUT    LPBYTE   *ppToken,
    IN OUT LPDWORD  pNumTokens
    )

/*++

Routine Description:

    This function parses a line for tokens.  A maximum of *pnumtokens
    are collected.

Arguments:

    pLine        -  pointer to the NULL terminated line to parse
    pToken       -  an array of pointers to tokens collected
    pNumTokens   -  on input, number of elements in the array, token[];
                    on output, number of tokens collected in token[]

Return Value:

    The characteristics of this lmhosts line.

Notes:

    1. Each token must be separated by white space.  Hence, the keyword
       "#PRE" in the following line won't be recognized:

            11.1.12.132     lothair#PRE

    2. Any ordinary line can be decorated with a "#PRE", a "#DOM:name" or
       both.  Hence, the following lines must all be recognized:

            111.21.112.3        kernel          #DOM:ntwins #PRE
            111.21.112.4        orville         #PRE        #DOM:ntdev
            111.21.112.7        cliffv4         #DOM:ntlan
            111.21.112.132      lothair         #PRE

--*/

{
    enum _PARSE_E
    {                                      // current fsm state
        E_START_OF_LINE,
        E_WHITESPACE,
        E_TOKEN
    } State_e;

    LPBYTE 		   pCh;                          // current fsm input
    //LPBYTE 		   pByte;                          // current fsm input
    PKEYWORD_T 		   pKeyword;
    DWORD 		   Index;
    DWORD		   MaxTokens;
    LINE_CHARACTERISTICS_T Retval;
    BOOL		   fQuoteSeen = FALSE;
    BOOL		   fBreakOut  = FALSE;

    //
    // Zero out the token array
    //
    RtlZeroMemory(ppToken, *pNumTokens * sizeof(LPBYTE *));

    State_e             = E_START_OF_LINE;
    Retval.LineCategory = E_ORDINARY;
    Retval.LinePreload  = 0;
    Retval.Mh           = 0;
    MaxTokens           = *pNumTokens;
    Index               = 0;

    for (pCh = pLine; *pCh != (BYTE)NULL  && !fBreakOut; pCh++)
    {
      switch ((int)*pCh)
      {
        //
        // does the '#' signify the start of a reserved keyword, or the
        // start of a comment ?
        //
        case COMMENT_CHAR:
            //
            // if a quote character has been seen earlier, skip this
	    // char
            //
	    if(fQuoteSeen)
	    {
		continue;
	    }	

	    //
	    // See if we have a keyword.  Use the appropriate table for the
	    // lookup
	    //
            pKeyword = IsKeyWord(
                            pCh,
                            (State_e == E_START_OF_LINE) ?
					Directive : Decoration
			       );

	    //
            // If it is a keyword
	    //
            if (pKeyword)
	    {
                State_e     = E_TOKEN;
                MaxTokens   = pKeyword->KNoOfOperands;

                switch (pKeyword->KType_e)
		{
                	case E_PRELOAD:
                    		Retval.LinePreload = 1;
                    		continue;

                	case E_MH:
                    		Retval.Mh = 1;
                    		continue;

			//
			// It is one of the other keywords
			//
                	default:
                    		ASSERT(Index     <  MaxTokens);

                    		ppToken[Index++]      = pCh;
                    		Retval.LineCategory  = pKeyword->KType_e;
                    		continue;
                }

                ASSERT(0);
            }

	    //
            // Since it is not a keyword, it is a comment
            //
            if (State_e == E_START_OF_LINE)
	    {
                Retval.LineCategory = E_COMMENT;
            }
            /* fall through */

        case CARRIAGE_RETURN_CHAR:
        case NEWLINE_CHAR:
            *pCh = (BYTE) NULL;
	    fBreakOut = TRUE;
            break; 			//break out of the loop. We are done

        case SPACE_CHAR:
        case TAB_CHAR:
	    //
	    // if State is Token, and there is no ending quote to worry about
	    // we change the state to WhiteSpace
	    //
            if (State_e == E_TOKEN)
	    {
		if (!fQuoteSeen)
		{
                	State_e = E_WHITESPACE;
                	*pCh  = (BYTE)NULL;

			//
			// If we have accumulated the desired number of tokens
			// break out of the loop
			//
                	if (Index == MaxTokens)
			{
				fBreakOut = TRUE;
                    		break;
                	}
		}
            }
            continue;

	case QUOTE_CHAR:

		//
		// Check whether we have seen the beginning quote char earlier
		//
		if(fQuoteSeen)
		{
			//
			// Ending quote consumed.  Set flag to FALSE
			//
			fQuoteSeen = FALSE;
		}
		else  // companion quote not seen earlier
		{
		        //
			// This could be the starting quote of the #DOM:
			// keyword's string or could be the starting
			// quote of the nbtname string
			//
			if (State_e == E_TOKEN)
			{
			   //
			   // It is the starting quote of the #DOM: keyword
			   // string
			   //
               // --ft: the statement above doesn't stand for legal LMHOSTS lines like:
               // #SG:"SGNoMember"
               // so I commented out the assert below:
			   //ASSERT(Index > E_NBNAME);
			}
			else
			{

			  //
			  // Must be the starting quote of the Nbt name
			  //
			  ASSERT(Index == E_NBNAME);

	    		  State_e = E_TOKEN;
	    		  //
	    		  // Store the pointer to the token
            		  //
            		  ppToken[Index++] = pCh;
			}
	    		fQuoteSeen = TRUE;
		}
		continue;

        default:

	    //
	    // If this is the token state, continue
	    //
            if (State_e == E_TOKEN) 	
	    {
                continue;
            }
            ASSERT(Index     <  MaxTokens);
	
	    State_e = E_TOKEN;
	    //
	    // Store the pointer to the token
            //
            ppToken[Index++] = pCh;
            continue;
      } // end of switch
    } // end of for loop


    *pNumTokens = Index;

    return(Retval);

} // GetTokens




STATIC
PKEYWORD_T
IsKeyWord (
    IN LPBYTE     pString,
    IN PKEYWORD_T pKTable
    )

/*++

Routine Description:

    This function determines whether the string is a reserved keyword.

Arguments:

    pString  -  the string to search
    pKTable   -  an array of keywords to look for

Return Value:

    A pointer to the relevant keyword object, or NULL if unsuccessful

--*/

{
    size_t     StringSize;
    PKEYWORD_T pSpecial;


    StringSize = strlen(pString);

    for (pSpecial = pKTable; pSpecial->pKString; pSpecial++) {

	//
	// If the length of the string is less than that of the keyword,
	// go on to the next keyword in the table
	//
        if (StringSize < pSpecial->KStrlen)
	{
            continue;
        }

	//
	// if length of string is greater than or equal to the keyword
	// length and the string matches the keyword in the # of characters
	// that comprise the keywordm, return the address of the keyword
	// structure
	//
FUTURES("use lstrncmp when it becomes available")
        if (
		(StringSize >= pSpecial->KStrlen)
			&&
                !strncmp(pString, pSpecial->pKString, pSpecial->KStrlen)
	   )
	{
                return(pSpecial);
        }
    }
    return((PKEYWORD_T) NULL);

} // IsKeyWord




VOID
PrimeDb (
	PWINSPRS_FILE_INFO_T	pFileInfo
    )
/*++

Routine Description:
	This function primes the WINS db

Arguments:


Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
    LPBYTE 		    CurrLine;
    DWORD 		    Count;
    DWORD		    NWords;
    LPBYTE     	    	    ppToken[E_MAX_TOKENS];
    LINE_CHARACTERISTICS_T  CurrLineChar;
    DWORD                   Add;
    BOOL                    fBadAdd;
    DWORD                   TkSize;
    DWORD                   TypeOfRec;

try {

    //
    // Loop over all records
    //
    pFileInfo->pCurrPos = pFileInfo->pFileBuff;
    while (CurrLine = Fgets(pFileInfo, &Count) )
    {

        NWords        = E_MAX_TOKENS;

        fBadAdd       = FALSE;
        CurrLineChar  = GetTokens(CurrLine, ppToken, &NWords);
        switch (CurrLineChar.LineCategory)
	{

        	case E_SGWADD:
                        TypeOfRec = NMSDB_USER_SPEC_GRP_ENTRY;
                        TkSize     = SPEC_GRP_TOKEN_SIZE;

                            //fall through
        	case E_DOMAIN:

                        if (CurrLineChar.LineCategory == E_DOMAIN)
                        {
                          TypeOfRec = NMSDB_SPEC_GRP_ENTRY;
                          TkSize     = DOMAIN_TOKEN_SIZE;
                        }

		        //
			// If there are too few words in the line, go
			// get the next line
			//
            		if ((NWords - 1) < E_GROUPNAME)
			{
                		continue;
            		}

                        if (ChkAdd(ppToken[E_IPADDRESS], &Add))
                        {

	    		  //
            	          // Register the domain name (group name with 1C at
			  // the end)
            		  //
            		  RegGrpName(
                       		 ppToken[E_GROUPNAME] +  TkSize,
                        	 Add,
                                 TypeOfRec
                                 );
                        }
                        else
                        {
                                fBadAdd = TRUE;
                        }

	     		//
	     		// Fall through
	     		//

		case E_ORDINARY:

			//
			// If there are too few words in the line, go
			// get the next line
			//
			// Don't use (NWords - 1) < E_NBNAME since
			// NWords can be 0 in which case the test will
			// fail
			//

			if (NWords  < (E_NBNAME + 1))
			{
                		continue;
            		}
			else
			{
                            if (!fBadAdd && ChkAdd(ppToken[E_IPADDRESS], &Add))
                            {
                                if (CurrLineChar.Mh)
                                {
            		          RegGrpName(
                       		       ppToken[E_NBNAME],
                        	       Add,
                                       NMSDB_MULTIHOMED_ENTRY
                                          );
                                }
                                else
                                {
		   		  //
		   		  // register the name
		   		  //
		   		  RegOrdinaryName( ppToken[E_NBNAME], Add);
                                }
                            }
                            else
                            {
                                WinsMscLogEvtStrs(
                                                ppToken[E_NBNAME],
                                                WINS_EVT_BAD_ADDRESS,
                                                FALSE
                                                 );
                                DBGPRINT2(ERR, "PrimeDb: Name (%s) has bad address = (%s). It is being ignored\n", ppToken[E_NBNAME], ppToken[E_IPADDRESS]);
                            }
			}
            		continue;
	
                case E_SPEC_GRP:
	    		//
            	        // Register the domain name (group name with 1C at
			// the end)
            		//
            		RegGrpName(
                       		 ppToken[SPEC_GRP_TOKEN_POS] + SPEC_GRP_TOKEN_SIZE,
                        	 0,
                                 NMSDB_USER_SPEC_GRP_ENTRY);
                        continue;


        	case E_INCLUDE:			// fall through
        	case E_BEGIN_ALTERNATE:		// fall through
        	case E_END_ALTERNATE:		// fall through
			continue;
        	default:
            		continue;
        }
    }
}  // end of try block
finally {

	//
	// deallocate the memory to which the file was mapped
	//
  	WinsMscDealloc(pFileInfo->pFileBuff);
 }
    return;

} // PrimeDb



LPBYTE
Fgets (
    IN PWINSPRS_FILE_INFO_T 	pFileInfo,
    OUT LPDWORD 	    	pNoOfCh
    )

/*++

Routine Description:

    This function is vaguely similar to fgets(3).

    Starting at the current seek position, it reads through a newline
    character, or the end of the file. If a newline is encountered, it
    is replaced with a NULL character.

Arguments:

    pfile   -  file to read from
    nbytes  -  the number of characters read, excluding the NULL character

Return Value:

    A pointer to the beginning of the line, or NULL if we are at or past
    the end of the file.

--*/

{
    LPBYTE pEndOfLine;
    LPBYTE pStartOfLine;
    SIZE_T MaxCh;

    //
    // Store the current position  in the memory buffer
    //
    pStartOfLine = (LPBYTE)pFileInfo->pCurrPos;

    //
    // If it is greater or equal than the limit, return NULL
    //
    if (pStartOfLine >= (LPBYTE)pFileInfo->pLimit) {

        return(NULL);
    }

    //
    // Store the max. number of bytes between the current position and
    // the end of the buffer.
    //
    MaxCh  = (pFileInfo->pLimit - pFileInfo->pCurrPos);

    //
    // get to the end of the line
    //
    pEndOfLine = (LPBYTE)memchr(pStartOfLine, NEWLINE_CHAR, (size_t)MaxCh);

    if (!pEndOfLine)
    {

	DBGPRINT0(FLOW, "Data file does not end in newline\n");
        return(NULL);
    }

    *pEndOfLine = (BYTE)NULL;

    pFileInfo->pCurrPos = pEndOfLine + 1;	//adjust the pointer

    ASSERT(pFileInfo->pCurrPos <= pFileInfo->pLimit);

    *pNoOfCh = (DWORD) (pEndOfLine - pStartOfLine);
    return(pStartOfLine);

} // Fgets


VOID
RegOrdinaryName(
	IN LPBYTE	pName,
	IN DWORD	IPAdd	
  )

/*++

Routine Description:
	This function registers a unique name

Arguments:
	
	pName - Name to register
	IPAdd - Address to register

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	BYTE		Dest[WINS_MAX_LINE_SZ];	
	BOOL		fQuoted;
	COMM_ADD_T	NodeAdd;
        LPBYTE      pDest = Dest;

	NodeAdd.AddLen    = sizeof(COMM_IP_ADD_T);
	NodeAdd.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	NodeAdd.Add.IPAdd = IPAdd;
	
	//
	// Form the name.  If the name is < 16 characters, 0x20 will
	// be put in the Sixteenth bytes
	//
	if (!ExpandName(Dest, pName, 0x20, &fQuoted))
        {
                DBGPRINT1(ERR, "Name (%s) has more than 16 characters\n", pName);
                return;
        }

	NMSMSGF_MODIFY_NAME_IF_REQD_M(Dest);	
	
	NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  //we always store the terminating
					     //NULL
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );
	//
	// If the name was not quoted, register the other two records
	// (same name -- different suffixes)
	//
	if(!fQuoted)
	{
#if 0
                if (*pDest == 0x1B)
                {
                   WINS_SWAP_BYTES_M(pDest, pDest + 15);
                }
#endif
		Dest[NON_CODED_NAME_SIZE - 2] = 0x3;
		NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 1, //we always store the terminating
					    //NULL
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );

		Dest[NON_CODED_NAME_SIZE - 2] = 0x0;
		NmsNmhNamRegInd(
			 NULL,
			 Dest,
			 strlen(Dest) + 2,  //add 1 since terminating 0x0 is
					     //to be stored (will be taken
					     //as NULL by strlen
			 &NodeAdd,
			 NMSMSGF_E_BNODE,	
			 NULL,
			 0,
			 0,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
		       );
	}	
	return;
}

VOID
RegGrpName(
	IN  LPBYTE	pName,
	IN  DWORD	IPAdd,
        IN  DWORD       TypeOfRec
	)

/*++

Routine Description:

	This function registers a domain name

Arguments:
	pName - Name to register
	IpAdd - Address to register

Externals Used:
	None

	
Return Value:

	None
Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

	BYTE	    Dest[WINS_MAX_LINE_SZ];	
	BOOL	    fQuoted;
	NMSMSGF_CNT_ADD_T  CntAdd;
        DWORD       RecType;
        BYTE        SixteenthByte;

        if (*pName == EOS)
        {
            WinsMscLogEvtStrs(pName, WINS_EVT_NAME_FMT_ERR, FALSE);
            return;
        }

        //
        // don't want 0 ip address to be put in
        //
        if (IPAdd)
        {
	  CntAdd.NoOfAdds		= 1;
	  CntAdd.Add[0].AddLen    = sizeof(COMM_IP_ADD_T);
	  CntAdd.Add[0].AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	  CntAdd.Add[0].Add.IPAdd	= IPAdd;
        }
        else
        {
	  CntAdd.NoOfAdds		= 0;
        }

        if (TypeOfRec != NMSDB_SPEC_GRP_ENTRY)
        {
          SixteenthByte = 0x20;
        }
        else
        {
          SixteenthByte = 0x1C;
        }

        //
        // We can get called for domains, user. spec. grps and mh names.
        //
        RecType = (TypeOfRec == NMSDB_USER_SPEC_GRP_ENTRY) ?
                                       NMSDB_SPEC_GRP_ENTRY : TypeOfRec;
	//
	// If the name length is < 16 characters, 0x20 or 0x1C will be put in
	// the Sixteenth byte
	//
	if (!ExpandName(Dest, pName, SixteenthByte, &fQuoted))
        {
            return;
        }

        if (RecType == NMSDB_MULTIHOMED_ENTRY)
        {
          //
          // switch the 1st and Sixteenth bytes if the Sixteenth byte is a 0x1B.  This
          // is done only for non-group names
          //
	  NMSMSGF_MODIFY_NAME_IF_REQD_M(Dest);	
        }

	//
	// register the group
	//
	NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);

        if (RecType == NMSDB_MULTIHOMED_ENTRY)
        {
	  //
	  // If the name was not quoted, register the other two records
	  // (same name -- different suffixes)
	  //
	  if(!fQuoted)
	  {
		Dest[NON_CODED_NAME_SIZE - 2] = 0x3;
	        NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 1,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);

		Dest[NON_CODED_NAME_SIZE - 2] = 0x0;
	        NmsNmhNamRegGrp(
			 NULL,
			 Dest,
			 strlen(Dest) + 2,  // to store the null
			 &CntAdd,
			 0,		     //Node type (not used)
			 NULL,
			 0,
			 0,
			 RecType,
			 FALSE,	//it is a name registration (not a refresh)
			 NMSDB_ENTRY_IS_STATIC,
			 0		//not an administrative action
			);
	  }	
        }
	return;		
}



BOOL
ExpandName (
    OUT LPBYTE 	  pDest,
    IN  LPBYTE 	  pSrc,
    IN  BYTE 	  LastCh,
    OUT  LPBOOL    pfQuoted
    )

/*++

Routine Description:

    This function expands an lmhosts entry into a full 16 byte NetBIOS
    name.  It is padded with blanks up to 15 bytes; the Sixteenth byte is the
    input parameter, last.


    Both dest and source are NULL terminated strings.

Arguments:

    pDest            -  sizeof(dest) must be WINSPRS_NONCODED_NMSZ
    pSrc             -  the lmhosts entry
    LastCh           -  the Sixteenth byte of the NetBIOS name
    pfQuoted         -  flag to indicate whether the string was quoted or not

Return Value:
	None
--*/


{
    BYTE    Ch;
    DWORD   i = 0;
    LPBYTE  pFrom = pSrc;
    LPBYTE  pTo   = pDest;

    // Detect if it is quoted name..
    *pfQuoted = (*pFrom == QUOTE_CHAR);
    // ..and skip the initial quote char
    pFrom += *pfQuoted;

    // count for as many chars as are in a legal NetBios name (15) plus
    // the terminating char. (NON_CODED_NAME_SIZE is #defined to be 17)
    for (i = 0; i < NON_CODED_NAME_SIZE - 1; i++)
    {
        // get the next char from the name
        Ch = *(pFrom++);

        // check if it is a terminating char
        if (!Ch || (*pfQuoted ? Ch == QUOTE_CHAR : Ch == NEWLINE_CHAR))
            break;

        // check if the name doesn't exceed the legal 15 chars
        if (i == NON_CODED_NAME_SIZE - 2)
        {
            // We have picked up 15 characters already and there are more in the name
            // This is illegal so log error and bail out
            DBGPRINT1(ERR, "Name (%s) has more than 16 characters\n", pSrc);
            WinsMscLogEvtStrs(pSrc, WINS_EVT_BAD_NAME, FALSE);
            return FALSE;
        }

        // If the char is a leading DBCS byte then accept the extended char as it
        // is (take the trailing byte and go on.
        if (IsDBCSLeadByteEx(CP_ACP, Ch))
        {
            *pTo++ = Ch;
            *pTo++ = *pFrom++;
            continue;
        }

        // If the name is not quoted, map lower case alpha chars to upper case.
        // Note: don't use _toupper since _toupper does not check whether its
        // argument is indeed a lowercase char.
        if (!*pfQuoted && IsCharAlpha(Ch))
        {
            if(IsCharLower(Ch))
	        {
		        LPBYTE pCh;
    		    BYTE   sCh[2];
		        sCh[0] = Ch;
		        sCh[1] = (BYTE)NULL;
		        
		        pCh = (LPBYTE)CharUpperA(sCh);
		        Ch  = *pCh;
	        }
        }

        // Check if we have hex value in the name
        if (Ch == BACKSLASH_CHAR)
        {
            DWORD NoOfChar;
            INT   NumValue = 0;
            CHAR  Ch2;
            BOOL  fFailed = FALSE;

            // the hex value can be either \A3 or \xFC (obviously with any kind of hex digits)
            Ch = *pFrom;
            Ch2 = *(pFrom+1);

            if (Ch == BACKSLASH_CHAR)
            {
                // '\\' should be seen as one '\', hence keep Ch as it is and break from switch
                pFrom++;
            }
            else
            {
                if ((Ch == X_CHAR || Ch == x_CHAR) || 
                     (Ch == ZERO_CHAR && (Ch2 == X_CHAR || Ch2 == x_CHAR))
                    )
                {
                    DBGPRINT1(TMP, "Parsing hex num %s\n", pFrom);
                    // skip over x or 0x.
                    pFrom += (Ch == X_CHAR || Ch == x_CHAR) ? 1 : 2;
                    // we do have a hex number here. Pick up at most the first two digits.
                    fFailed = (sscanf(pFrom, "%2x%n", &NumValue, &NoOfChar) == 0 || NoOfChar == 0);

                    DBGPRINT2(TMP, "fFailed=%d; HexNumValue=0x%x\n", fFailed, NumValue);
                }
                else
                {
                    DBGPRINT1(TMP, "Parsing dec num %s\n", pFrom);
                    // it might be a decimal number. Pick up at most the first 3 digits.
                    fFailed = (sscanf(pFrom, "%3u%n", &NumValue, &NoOfChar) == 0 || NoOfChar == 0 || NumValue > 255);

                    DBGPRINT2(TMP, "fFailed=%d; DecNumValue=%u\n", fFailed, NumValue);
                }

                if (fFailed)
                {
                    // log an event and bail out with error.
                    DBGPRINT1(ERR, "Name (%s) contains incorrectly formed character code.\n", pSrc);
                    WinsMscLogEvtStrs(pSrc, WINS_EVT_BAD_CHARCODING, FALSE);
                    return FALSE;
                }

                // everything went fine, copy the hex value back to Ch
                Ch = (BYTE)NumValue;
                // and make sure to advance on the pFrom string
                pFrom += NoOfChar;
            }
        }

        // finally copy the char to the destination string
	    *pTo = Ch;
        // advance with the pointer on the destination string
        pTo++;
    } //end of for loop

    // if there were less than expected char, form the valid netbios name
    // by padding it with spaces
    for (;i < NON_CODED_NAME_SIZE - 2; i++, pTo++)
        *pTo = SPACE_CHAR;

    *pTo =      (BYTE)NULL;
    *(pTo+1) =  (BYTE)NULL;
    CheckForInt(pDest, *pfQuoted);

    // at the end, append the LastCh (16th byte) to the name.
    *pTo = LastCh;

    return(TRUE);
} // ExpandName

VOID
CheckForInt(
 LPBYTE pDest,
 BOOL   fQuoted
 )

/*++

Routine Description:
  This function munges the name so that if there are any characters
  from a different code set, they are converted properly

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
   WCHAR            UnicodeBuf[255];
   UNICODE_STRING   UnicodeStr;
   STRING           TmpStr;
   NTSTATUS        NTStatus;

   DBGENTER("CheckForInt\n");
    //
    // Now, convert to UNICODE then to OEM to force the ANSI -> OEM munge.
    // Then convert back to UNICODE and uppercase the name. Finally convert
    // back to OEM.
    //
    UnicodeStr.Length        = 0;
    UnicodeStr.MaximumLength = sizeof(UnicodeBuf);
    UnicodeStr.Buffer        = UnicodeBuf;

    RtlInitString(&TmpStr, pDest);

    NTStatus = RtlAnsiStringToUnicodeString(&UnicodeStr, &TmpStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:  Ansi -> Unicode failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }

    NTStatus = RtlUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:   Unicode -> Oem failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }

    NTStatus = RtlOemStringToUnicodeString(&UnicodeStr, &TmpStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:    Oem -> Unicode failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }


    if (!fQuoted)
        NTStatus = RtlUpcaseUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);
    else
        NTStatus = RtlUnicodeStringToOemString(&TmpStr, &UnicodeStr, FALSE);

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "CheckForInt:    Unicode -> Oem failed,  NTStatus %X\n",
            NTStatus);
        goto ERROR_PROC;
    }
ERROR_PROC:
    DBGLEAVE("CheckForInt\n");
    return;
}

STATUS
WinsPrsDoStaticInit(
      IN PWINSCNF_DATAFILE_INFO_T	pDataFile,
      IN DWORD				NoOfFiles,
      IN BOOL                           fAsync
	)

/*++

Routine Description:
	This function is called to do the STATIC initialization of the WINS
	db

Arguments:
	pDataFiles - Pointer to buffer containing one or more data file	
		     structures (PWINSCNF_DATAFILE_INFO_T)

Externals Used:
	None

	
Return Value:

	None
Error Handling:

Called by:
	Init()
Side Effects:

Comments:
	None
--*/

{
	DWORD ThdId;
	PFILE_PARAM_T  pFileParam;
        STATUS  RetStat = WINS_SUCCESS;
        HANDLE  sThdHdl = NULL;
		
try {
	WinsMscAlloc(sizeof(FILE_PARAM_T), &pFileParam);
	pFileParam->pDataFile = pDataFile;
	pFileParam->NoOfFiles = NoOfFiles;
        if (fAsync)
        {
	       sThdHdl =
                     WinsMscCreateThd(DoStaticInitThdFn, pFileParam, &ThdId);
               //
               // We don't need the handle, so let us close it
               //
               CloseHandle(sThdHdl);
        }
        else
        {
	       RetStat = DoStaticInitThdFn(pFileParam);
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("WinsPrsDoStaticInit");
	WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_STATIC_INIT_ERR);
	}
	return(RetStat);
}	

DWORD
DoStaticInitThdFn(
	IN LPVOID	pThdParam
	)

/*++

Routine Description:
	This thread reads one or more files to do STATIC initialization

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	WINSPRS_FILE_INFO_T	FileInfo;
	DWORD 		i;
        PWINSCNF_DATAFILE_INFO_T	pDataFile =
				(((PFILE_PARAM_T)pThdParam)->pDataFile);
        DWORD				NoOfFiles =
				(((PFILE_PARAM_T)pThdParam)->NoOfFiles);
	LPVOID		pSvDataFilePtr = pDataFile;
        DWORD       RetStat = WINS_SUCCESS;

	//
	// initialize this thread with the db engine
	//
	// This is not an RPC thread.  It could have been created either by
	// the main thread (doing an init/reinit) or by an rpc thread. For
	// either case, we do not want the counter NmsTermThdCnt to be
	// incremented in NmsDbThdInit(). Instead of passing a client
	// var to indicate which thread invoked it, we call it an RPC
	// thread to have NmsDbThdInit do the right thing.  NmsDbOpenTables
	// will also do the right thing.
	//
  	NmsDbThdInit(WINS_E_WINSRPC);
	NmsDbOpenTables(WINS_E_WINSRPC);

	EnterCriticalSection(&WinsIntfCrtSec);
	WinsIntfNoCncrntStaticInits++;
	LeaveCriticalSection(&WinsIntfCrtSec);
try {

	for (
		i = 0;
		i < NoOfFiles;
		i++, pDataFile = (PWINSCNF_DATAFILE_INFO_T)((LPBYTE)pDataFile +
				  WINSCNF_FILE_INFO_SZ)
	    )
	{
		//
		// Open the file
		//
		if (
			!WinsMscOpenFile(
				pDataFile->FileNm,
				pDataFile->StrType,
				&FileInfo.FileHdl
				    )
		   )
		{
			WINSEVT_STRS_T	EvtStrs;
#ifndef UNICODE
			DBGPRINT1(ERR, "WinsPrsDoStaticInit: Could not open file= (%s)\n", pDataFile->FileNm);
#else		


#ifdef WINSDBG
			IF_DBG(ERR)
			{
				wprintf(L"WinsPrsDoStatisInit: Could not open file = (%s)\n", pDataFile->FileNm);
			}				
#endif
#endif
			EvtStrs.NoOfStrs = 1;
			EvtStrs.pStr[0]  = pDataFile->FileNm;
			WINSEVT_LOG_STR_M(WINS_EVT_CANT_OPEN_DATAFILE, &EvtStrs);
            RetStat = WINS_FAILURE;
			continue;	
		}

#ifndef UNICODE
		DBGPRINT1(DET, "WinsPrsDoStaticInit: Opened file (%s) for doing STATIC initialization\n", pDataFile->FileNm);
#else
#ifdef WINSDBG
		IF_DBG(ERR)
		{
			wprintf(L"WinsPrsDoStatisInit: Opened file (%s) for doing STATIC initialization\n", pDataFile->FileNm);
		}
#endif
#endif
		//
		// Map the file into allocated memory
		//
		if(!WinsMscMapFile(&FileInfo))
		{
			continue;	
		}
	
		//
		// prime the db
		//
		PrimeDb(&FileInfo);

	} // end of for loop
 } // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("DoStaticInitThdFn");
	WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_STATIC_INIT_ERR);
	}

	EnterCriticalSection(&WinsIntfCrtSec);
	WinsIntfNoCncrntStaticInits--;
	LeaveCriticalSection(&WinsIntfCrtSec);

  	//
  	// Let us end the session
  	//
try {
	NmsDbCloseTables();
  	NmsDbEndSession();
}
except (EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("DoStaticInit: During wrap up");
  }

	//
	// Deallocate the memory
	//
	ASSERT(pSvDataFilePtr != NULL);
	WinsMscDealloc(pSvDataFilePtr);
	//
	// Be sure to deallocate the thread param
	//
	WinsMscDealloc(pThdParam);

//	ExitThread(WINS_SUCCESS);
	return(RetStat);	//to shutup compiler warning
}

BOOL
ChkAdd(
    LPBYTE pstrAdd,
    LPDWORD pAdd
        )

/*++

Routine Description:
        This function converts a dotted decimel ip address to
        a DWORD.  We don't use inet_addr() to do this, since it
        returns 0xFFFFFFFF for an address that has one of its
        parts > 255 and returns some value for an invalid address
        (for example, one with 3 dots)

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

        BYTE    Tmp[WINS_MAX_LINE_SZ];
        DWORD   Word[4];
        LPBYTE  pPos;
        DWORD   Count = 0;
        BOOL    fInvalid = FALSE;

        //
        // We must see three dots
        //
        while(Count < 4)
        {
                if ((pPos = strchr(pstrAdd, (int)'.')) != NULL)
                {

                     do
                     {
                        //
                        // Copy all chars before the dot
                        //
                        (void)RtlCopyMemory(Tmp, pstrAdd, pPos - pstrAdd);

                        //
                        // Put a NULL at the end
                        //
                        Tmp[pPos - pstrAdd] = EOS;
                        Word[Count] = (DWORD)atol(Tmp);

                        //
                        //atol returns 0 if it can not convert
                        //but 0 can be a valid return too (if we have '0' to
                        // connvert
                        //
                        if (Word[Count] == 0)
                        {
                                if (Tmp[0] != '0')
                                {
                                        fInvalid = TRUE;
                                        break;
                                }
                        }
                        else
                        {
                           if (Word[Count] > 255)
                           {
                                fInvalid = TRUE;
                                break;
                           }
                        }
                        Count++;
                        pstrAdd = ++pPos;
                    } while ((Count == 3) && (pPos = pstrAdd + strlen(pstrAdd)));
                    if (fInvalid)
                    {
                        break;
                    }
                }
                else
                {
                        //
                        // less than 3 dots seen, break out of the loop
                        //
                        break;
                }
        } // end of while (Count < 4)
        if ((Count < 4) || fInvalid)
        {
                return(FALSE);
        }
        else
        {
                *pAdd = (LONG)((Word[0] << 24) + (Word[1] << 16) +
                                (Word[2] << 8) + Word[3]);
        }
        return(TRUE);
}


#if 0
VOID
GetFullPath(
    IN LPBYTE  pTarget,
    OUT LPBYTE pPath
    )

/*++

Routine Description:

    This function returns the full path of the STATIC  file.  This is done
    by forming a unicode string from the concatenation of the C strings
    DatabasePath and the string, file.

    You must RtlFreeUnicodeString(path) after calling this function
    successfully !

Arguments:

    target    -  the name of the file.  This can either be a full path name
                 or a mere file name.
    path    -  a pointer to a UNICODE_STRING structure

Return Value:

    STATUS_SUCCESS if successful.

Notes:

    RtlMoveMemory() handles overlapped copies; RtlCopyMemory() doesn't.

--*/

{
    NTSTATUS status;
    ULONG unicodesize;
    STRING directory, file, prefix, remote;

    RtlInitString(&prefix, "\\DosDevices");
    RtlInitString(&remote, "\\DosDevices\\UNC");

    //
    // if the target begins with a '\', or contains a DOS drive letter,
    // then assume that it specifies a full path.  Otherwise, prepend the
    // default directory, DatabasePath, to create a full path.
    //
    //
    if ((*target == '\\') || (target[1] == ':')) {

        RtlInitString(&directory, target);
        RtlInitString(&file, NULL);
    }
    else {
        RtlInitString(&directory, DatabasePath);
        RtlInitString(&file, target);
    }

    ASSERT(RtlAnsiStringToUnicodeSize(&prefix) <=
                                    RtlAnsiStringToUnicodeSize(&remote));

    unicodesize = RtlAnsiStringToUnicodeSize(&remote) +
                    RtlAnsiStringToUnicodeSize(&directory) +
                    RtlAnsiStringToUnicodeSize(&file) +
                    2 * sizeof(OBJ_NAME_PATH_SEPARATOR) +
                    sizeof(UNICODE_NULL);

    path->Length        = 0;
    path->MaximumLength = (USHORT) unicodesize;
    path->Buffer        = ExAllocatePool(NonPagedPool, unicodesize);

    if (!path->Buffer) {
        return(STATUS_NO_MEMORY);
    }

    //
    // does the directory specify a DOS drive ?
    //
    // If the second character of directory is a colon, then it must specify
    // a DOS drive.  If so, it must be prefixed with "\\DosDevices".
    //
    //
    if (directory.Buffer[1] == ':') {
        status = LmpConcatenate(path, &prefix);

        if (status != STATUS_SUCCESS) {
            path->MaximumLength = 0;
            ExFreePool(path->Buffer);
            return(status);
        }
    }


    //
    // does the directory specify a remote file ?
    //
    // If so, it must be prefixed with "\\DosDevices\\UNC", and the double
    // slashes of the UNC name eliminated.
    //
    //
    if ((directory.Buffer[0] == '\\') && (directory.Buffer[1] == '\\')) {
        status = LmpConcatenate(path, &remote);

        if (status != STATUS_SUCCESS) {
            path->MaximumLength = 0;
            ExFreePool(path->Buffer);
            return(status);
        }

        directory.Length--;

        ASSERT(((ULONG) directory.Length - 1) > 0);

        RtlMoveMemory(                                  // overlapped copy
                    &(directory.Buffer[1]),             // Destination
                    &(directory.Buffer[2]),             // Source
                    (ULONG) directory.Length - 1);      // Length
    }


    //
    // is the first part of the directory "%SystemRoot%" ?
    //
    // If so, it must be changed to "\\SystemRoot\\".
    //
    //          0123456789 123456789 1
    //          %SystemRoot%\somewhere
    //
    //
    if (strncmp(directory.Buffer, "%SystemRoot%", 12) == 0) {

        directory.Buffer[0]  = '\\';
        directory.Buffer[11] = '\\';

        if (directory.Buffer[12] == '\\') {
            ASSERT(directory.Length >= 13);

            if (directory.Length > 13) {
                RtlMoveMemory(                          // overlapped copy
                        &(directory.Buffer[12]),        // Destination
                        &(directory.Buffer[13]),        // Source
                        (ULONG) directory.Length - 13); // Length

                directory.Buffer[directory.Length - 1] = (CHAR) NULL;
            }

            directory.Length--;
        }
    }

    status = LmpConcatenate(path, &directory);

    if (status != STATUS_SUCCESS) {
        path->MaximumLength = 0;
        ExFreePool(path->Buffer);
        return(status);
    }

    if (!(file.Length)) {
        return(status);
    }

    status = LmpConcatenate(path, &file);

    if (status != STATUS_SUCCESS) {
        path->MaximumLength = 0;
        ExFreePool(path->Buffer);
        return(status);
    }

    return(STATUS_SUCCESS);

} // LmGetFullPath
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winstmm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        winstmm.c


Abstract:
        This module contains the timer manager functions


Functions:
        WinsTmmInsertEntry
        TmmThdInitFn
        WinsTmmInit
        HandleReq
        SignalClient
        WinsTmmDeleteReqs
        WinsTmmDeallocReq

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Mar-1993 

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "nms.h"
#include "winsevt.h"
#include "winsmsc.h"
#include "winstmm.h"
#include "winsque.h"
#include "winsthd.h"

/*
 *        Local Macro Declarations
 */

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

HANDLE                WinsTmmHeapHdl;  //handle of heap to allocate TMM work items
                                // from

/*
 *        Local Variable Definitions
*/
STATIC CRITICAL_SECTION                sTmmReqCntCrtSec;
STATIC DWORD                        sTmmReqCnt = 0;

//
// This stores the req. id of the request at the top of the queue 
// (i.e. one for which the timer thread is doing a timed wait)
//
STATIC        DWORD                        sReqIdOfCurrReq;
/*
 *        Local Function Prototype Declarations
 */
STATIC
DWORD
TmmThdInitFn(
        LPVOID pParam
        );

VOID
HandleReq(
        OUT  LPLONG                        pDeltaTime        
        );

VOID 
SignalClient(
        VOID
        );


/* prototypes for functions local to this module go here */


VOID 
WinsTmmInsertEntry(
        PQUE_TMM_REQ_WRK_ITM_T    pPassedWrkItm,
        WINS_CLIENT_E             Client_e,
        QUE_CMD_TYP_E             CmdTyp_e,
        BOOL                      fResubmit,
        time_t                    AbsTime,
        DWORD                     TimeInt,
        PQUE_HD_T                 pRspQueHd,
        LPVOID                    pClientCtx,
        DWORD                     MagicNo,
        PWINSTMM_TIMER_REQ_ACCT_T pSetTimerReqs
        )

/*++

Routine Description:

        This function is called to insert a work item into the Timer Manager's
        request queue (delta queue).  It allocates a work item if required         
        (if pWrkItm != NULL) and enqueues it in its proper position in 
        the delta queue of the TMM thread.  It then signals the TMM thread
        if required. 

Arguments:

        pWrkItm    - work item to queue (if pWrkItm != NULL)
        Client_e   - id. of client that submitted the request
        CmdTyp_e   - type of command (set timer, modify timer, etc)
        fResubmit  - Is it a resubmit
        AbsTime   - absolute time (in secs) at which the client needs to be
                     notified
        TimeInt    - time interval in seconds after which the client needs to
                     be notified
        pRspQueHd  - Que Head of the queue where the notification needs to be
                     queued
        pClientCtx - Client's context that needs to be put in the work item
        pSetTimerReqs - For future extensibility
                     

Externals Used:
        None

        
Return Value:

        None
Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PQUE_TMM_REQ_WRK_ITM_T        pWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T        pTmp;
        BOOL                        fInserted = FALSE;

        UNREFERENCED_PARAMETER(pSetTimerReqs);

        if (!pPassedWrkItm)
        {
                QueAllocWrkItm(
                        WinsTmmHeapHdl,
                        sizeof(QUE_TMM_REQ_WRK_ITM_T),
                        &pWrkItm
                      );
        }
        else
        {
                pWrkItm = pPassedWrkItm;
        }

        //
        // Put a request id (a monotonically increasing number)
        //
        EnterCriticalSection(&sTmmReqCntCrtSec);        
        sTmmReqCnt++;        
        LeaveCriticalSection(&sTmmReqCntCrtSec);        
        pWrkItm->ReqId      = sTmmReqCnt; 

        //
        // If work item was allocated or if it is not a resubmit
        // init the rest of the fields appropriately
        //
        pWrkItm->CmdTyp_e   = CmdTyp_e;
        pWrkItm->AbsTime    = AbsTime;
        pWrkItm->TimeInt    = TimeInt;
        pWrkItm->QueTyp_e   = QUE_E_WINSTMQ;
        pWrkItm->RspEvtHdl  = pRspQueHd->EvtHdl;
        pWrkItm->pRspQueHd  = pRspQueHd;
        pWrkItm->pClientCtx = pClientCtx;
        pWrkItm->Client_e   = Client_e; 
        pWrkItm->MagicNo    = MagicNo;

        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
try {
        if (IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                InsertTailList(&QueWinsTmmQueHd.Head, &pWrkItm->Head);
                if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                {

                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SIGNAL_TMM_ERR);
                        DBGPRINT0(EXC, "Could not signal Tmm Thd\n");
                        WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                }
                fInserted = TRUE;
        }
        else
        {
                //
                // get the address of the first entry in the queue.
                //
                pTmp = (PQUE_TMM_REQ_WRK_ITM_T)QueWinsTmmQueHd.Head.Flink;

                //
                // Go over the circular linked list until we hit the head
                // of the queue
                //
                while(pTmp != (PQUE_TMM_REQ_WRK_ITM_T)&QueWinsTmmQueHd.Head)
                {

                   //
                   //  If the list entry has a longer timer than the new entry,
                   //  insert the new entry before it
                   //
                   if (pTmp->AbsTime > pWrkItm->AbsTime)
                   {
                        pWrkItm->Head.Flink     = &pTmp->Head;
                        pWrkItm->Head.Blink     = pTmp->Head.Blink;
                        pTmp->Head.Blink->Flink = &pWrkItm->Head;
                        pTmp->Head.Blink        = &pWrkItm->Head;
                        fInserted = TRUE;

                        //
                        // The element has been inserted. Let us break out
                        // of the loop
                        //
                        break;
                   }        
                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;
                }
                
        }        
        //
        // If the entry was not inserted (i.e. all entries in the queue have
        // a shorter expiry than our entry), insert the entry  at the 
        // end of the list
        //
        if (!fInserted)
        {
                InsertTailList(&QueWinsTmmQueHd.Head, &pWrkItm->Head);
        }

        //
        // If this is the top most entry in the queue and there is 
        // at least one more entry in the queue, signal the TMM
        // thread so that it can start a timer for it.  If the above
        // is not true, relax (either the TMM thread has already been 
        // signaled (if this is the only item in the queue) or it does not 
        // need to be signaled (this is not the top-most item in the queue). 
        //
        if (
                (pWrkItm->Head.Blink == &QueWinsTmmQueHd.Head)  
                                && 
                (pWrkItm->Head.Flink != &QueWinsTmmQueHd.Head)  
            )
        {
                if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                {

                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SIGNAL_TMM_ERR);
                        DBGPRINT0(EXC, "Could not signal Tmm Thd\n");
                        WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                }
        }
  } // end of try ..

finally {
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                
 }
        return;
}



VOID
WinsTmmInit(
        VOID
        )

/*++

Routine Description:
        This is the function that initializes the timer manager

Arguments:
        None

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        Init in nms.c
Side Effects:
        A timer thread is created
Comments:
        None
--*/

{

        
        STATUS   RetStat;

        //
        // Initialize the critical section guarding the counter for 
        // Tmm requests
        //
        InitializeCriticalSection(&sTmmReqCntCrtSec);

        /*
        * Create heap for allocating name challenge work items
        */
        DBGPRINT0(HEAP_CRDL, "WinsTmmInit: Tmm. Chl. heap\n");
        WinsTmmHeapHdl =  WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */ 
                TMM_INIT_HEAP_SIZE 
                );

        InitializeListHead(&QueWinsTmmQueHd.Head);

        
        //
        //
        // Create the timer thread.  This function will
        // initialize the critical section and the Evt handle passed
        // to it
        //        
        RetStat = WinsMscSetUpThd(
                        &QueWinsTmmQueHd,                //queue head
                        TmmThdInitFn,                        //init function
                        NULL,                                   // no param
                        &WinsThdPool.TimerThds[0].ThdHdl,
                        &WinsThdPool.TimerThds[0].ThdId
                        );

        if (RetStat == WINS_SUCCESS)
        {
                WinsThdPool.TimerThds[0].fTaken = TRUE;
                WinsThdPool.ThdCount++;  //increment the thread count
        }
        else
        {
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }

        return;                
}


DWORD
TmmThdInitFn(
        LPVOID pParam
        )

/*++

Routine Description:
        This is the top-most function of the TMM thread

Arguments:
        pParam - Param to the top most function (not used)

Externals Used:
        None

        
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        WinsTmmInit

Side Effects:

Comments:
        None
--*/

{

        LONG                        DeltaTime;
        BOOL                        fSignaled;
                
        UNREFERENCED_PARAMETER(pParam);
        
try {
        while(TRUE)
        {
                WinsMscWaitInfinite(QueWinsTmmQueHd.EvtHdl);

                while(!IsListEmpty(&QueWinsTmmQueHd.Head))
                {
                   HandleReq(&DeltaTime);

                   if (DeltaTime != 0)
                   {
                        //
                        // Do a timed wait until either the timer expires
                        // or the event is signaled. 
                        //
                        WinsMscWaitTimed(
                                QueWinsTmmQueHd.EvtHdl,
                                DeltaTime * 1000,  //convert to millisecs
                                &fSignaled
                                        );

                        //
                        // If signaled (interrupte from the wait), it means
                        // that there is a more urgent request in the timer
                        // queue.
                        //
                        if (fSignaled)
                        {
                                HandleReq(&DeltaTime);
                        }
                        else  //timer expired
                        {
                                SignalClient();
                        }
                   }
                   else
                   {
                        SignalClient();

                   }
                }
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
                
                DBGPRINT0(EXC, 
                  "TmmThdInitFn: Timer Thread encountered an exception\n");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TMM_EXC);
                ExitThread(WINS_FAILURE);

}
                        
        //
        // We should never reach here
        //
        ASSERT(0);
        return(WINS_FAILURE);

}


VOID
HandleReq(
        OUT  LPLONG                        pDeltaTime        
        )

/*++

Routine Description:
        This function is called to handle a timer request.  The function
        is called when the Timer thread is signaled.

Arguments:
        pDeltaTime -  Time Interval to wait for before signaling the client 

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        TmmThdInitFn

Side Effects:

Comments:
        None
--*/

{
        
        time_t                AbsTime;        
        time_t                CurrTime;
        QUE_CMD_TYP_E        CmdTyp_e;


        (void)time(&CurrTime);
        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);

        //
        // If list is empty, return.  
        //
        if (IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                *pDeltaTime = 0;
                LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);
                return;
        }

        //
        // Retrieve the absolute time corresponding to the
        // first entry in the timer queue.
        //
        AbsTime  = ((PQUE_TMM_REQ_WRK_ITM_T)
                        (QueWinsTmmQueHd.Head.Flink))->AbsTime; 
        CmdTyp_e = ((PQUE_TMM_REQ_WRK_ITM_T)
                        (QueWinsTmmQueHd.Head.Flink))->CmdTyp_e;        
        
        ASSERT(CmdTyp_e == QUE_E_CMD_SET_TIMER);

        //
        // Store the request id of the request that we will wait on
        // in the STATIC
        //
        sReqIdOfCurrReq =  ((PQUE_TMM_REQ_WRK_ITM_T)
                                (QueWinsTmmQueHd.Head.Flink))->ReqId;        
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);
        
        switch(CmdTyp_e)
        {
                case(QUE_E_CMD_SET_TIMER):
                        *pDeltaTime = (LONG)(AbsTime - CurrTime);        

                        //
                        // It is possible that we might have a small
                        // negative value here, just because of the
                        // time it took to process the request. 
                        //
                        if (*pDeltaTime < 0)
                        {
                           *pDeltaTime = 0;
                        }
                        break;
                case(QUE_E_CMD_MODIFY_TIMER):
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT0(ERR, "Not supported yet\n");
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
                case(QUE_E_CMD_CANCEL_TIMER):
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT0(ERR, "Not supported yet\n");
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
                default:
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        DBGPRINT1(EXC, "Wierd: Invalid Request. CmdType is (%d), \n", CmdTyp_e);
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        break;
        }
        return;
}


VOID 
SignalClient(
        VOID
        )

/*++

Routine Description:
        This function is called to notify the client that its 
        timer request has expired.

Arguments:

        None

Externals Used:
        None

        
Return Value:
        None

Error Handling:

Called by:
        TmmThdInitFn

Side Effects:

Comments:
        None
--*/

{
        PQUE_TMM_REQ_WRK_ITM_T        pWrkItm;

FUTURES("Optimize to signal all clients whose requests have expired")
        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
        pWrkItm = (PQUE_TMM_REQ_WRK_ITM_T)RemoveHeadList(&QueWinsTmmQueHd.Head);

        //
        // If the top of the queue has a different work item than the 
        // one we were doing a timed wait for, it means that the there has
        // been a queue purge (see WinsTmmDeleteEntry. Simply return.
        //
        if (sReqIdOfCurrReq != pWrkItm->ReqId)
        {
                LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);        
                return;
        }
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                

        pWrkItm->CmdTyp_e = QUE_E_CMD_TIMER_EXPIRED;

        //
        // Insert into client's queue
        //
        QueInsertWrkItm(
                        &pWrkItm->Head,
                        0,                //not used -- change to an enumrator val
                        pWrkItm->pRspQueHd
                       );
        
        return;
}


VOID
WinsTmmDeleteReqs(
        WINS_CLIENT_E        Client_e
        )

/*++

Routine Description:
        This function is called to delete all set timer requests submitted
        by a client

Arguments:


Externals Used:
        None

        
Return Value:

        None
Error Handling:

Called by:
        Reconfig (in rplpull.c)
Side Effects:

Comments:
        In the future, enhance this function so that it delete requests
        based on other criteria
                
--*/
{

        PQUE_TMM_REQ_WRK_ITM_T        pTmp;
        PQUE_TMM_REQ_WRK_ITM_T        pMemToDealloc;
        BOOL                    fFirstEntry = FALSE;

        EnterCriticalSection(&QueWinsTmmQueHd.CrtSec);
try {        

        if (!IsListEmpty(&QueWinsTmmQueHd.Head))
        {
                //
                // get the address of the first entry in the queue.  
                //
                pTmp = (PQUE_TMM_REQ_WRK_ITM_T)QueWinsTmmQueHd.Head.Flink;

                //
                // We loop until we get to the head of the list  (the linked
                // list is a circular list)
                //
                while(pTmp != (PQUE_TMM_REQ_WRK_ITM_T)&QueWinsTmmQueHd.Head)
                {

                           //
                           //  If the entry  was queued by the client, get rid of 
                        //  it
                           //
                           if (pTmp->Client_e == Client_e)
                           {
                                //
                                // If this is the first entry in the queue, it 
                                // means that the timer thread is doing a 
                                // wait on it.  Signal it. 
                                //
                                if (
                                    !fFirstEntry 
                                        && 
                                    (pTmp->Head.Blink == &QueWinsTmmQueHd.Head)
                                   )
                                {
                                        fFirstEntry = TRUE;
                                }


//                                if (pTmp->Head.Flink ==  &QueWinsTmmQueHd.Head)
                                if (fFirstEntry)
                                {
                                        if (!SetEvent(QueWinsTmmQueHd.EvtHdl))
                                        {

                                                WINSEVT_LOG_M(
                                                            WINS_FAILURE, 
                                                            WINS_EVT_SIGNAL_TMM_ERR
                                                                  );
                                                DBGPRINT0(EXC, 
                                                        "Could not signal Tmm for canceling a request\n");
                                                WINS_RAISE_EXC_M(WINS_EXC_SIGNAL_TMM_ERR);
                                        }
                                }

                                //
                                // unlink the request
                                //
                                pTmp->Head.Flink->Blink = pTmp->Head.Blink;
                                pTmp->Head.Blink->Flink = pTmp->Head.Flink;
                                pMemToDealloc = pTmp;
                                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;

                                //
                                // Dealloc the dequeued work item
                                //
                                WinsTmmDeallocReq(pMemToDealloc);
                           }        
                        else
                        {
                                   pTmp = (PQUE_TMM_REQ_WRK_ITM_T)pTmp->Head.Flink;
                        }
                }
         }
 } // end of try block
except(EXCEPTION_EXECUTE_HANDLER)  {
        DBGPRINT1(EXC, "WinsTmmDeleteReqs: Got exception (%x)\n",
                        (DWORD)GetExceptionCode());
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_TMM_EXC);
 }
        LeaveCriticalSection(&QueWinsTmmQueHd.CrtSec);                
        return;
}



__inline
VOID
WinsTmmDeallocReq(
        PQUE_TMM_REQ_WRK_ITM_T pWrkItm
        )

/*++

Routine Description:
        This function is called to deallocate a timer request work item

Arguments:

        pWrkItm - Work Item

Externals Used:
        WinsTmmHeapHdl        

Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{

        //
        // deallocate the work item
        //
        QueDeallocWrkItm(
                        WinsTmmHeapHdl,
                        pWrkItm
                        );

        return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\makefile.inc ===
wins.rc: ..\msg\winsevnt.rc ..\msg\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\msc\winsque.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Contains functions for queuing and dequeuing  to/from the various
    work queues


Functions:
        QueInsertNbtWrkItm
        QueRemoveNbtWrkItm
        QueInsertChlReqWrkItm
        QueRemoveChlReqWrkItm
        QueInsertChlRspWrkItm
        QueRemoveChlRspWrkItm
        QueInsertWrkItm
        QueGetWrkItm
        QueAllocWrkItm
        QueDeallocWrkItm
        QueInsertWrkItmAtHdOfList

Portability:

        This module is portable
Author:

    Pradeep Bahl (pradeepb)        18-Nov-1992


Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "comm.h"
//#include "winsque.h"
#include "nms.h"
#include "nmsdb.h"
#include "nmschl.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "rplpush.h"
#include "rplmsgf.h"
#include "winsque.h"

/*
 *        Local Macro Declarations
 */


/*
 *        Local Typedef Declarations
*/



/*
 *        Global Variable Definitions
 */
//
// The various queue heads
//
QUE_HD_T  QueNbtWrkQueHd;  //head for nbt req queue

#if REG_N_QUERY_SEP > 0
QUE_HD_T  QueOtherNbtWrkQueHd;  //head for nbt req queue
#endif
DWORD     QueOtherNbtWrkQueMaxLen;

QUE_HD_T  QueRplPullQueHd; //head for rpl pull thread's queue
QUE_HD_T  QueRplPushQueHd; //head for rpl push thread's queue
QUE_HD_T  QueNmsNrcqQueHd; //head for challenge queue used by NBT
QUE_HD_T  QueNmsRrcqQueHd; //head for challenge queue used by Replicator
QUE_HD_T  QueNmsCrqQueHd;  //head for response queue to challenges sent
QUE_HD_T  QueWinsTmmQueHd; //head for timer manager's queue
QUE_HD_T  QueWinsScvQueHd; //head for Scavenger's queue
QUE_HD_T  QueInvalidQueHd; //head for an invalid queue


HANDLE                  QueBuffHeapHdl;  //handle to heap for use for nbt queue items
/*
 *        Local Variable Definitions
*/
/*
        pWinsQueQueHd

        Array indexed by the enumerator QUE_TYP_E values.  This array
        maps the QUE_TYP_E to the address of the queue head

*/
PQUE_HD_T        pWinsQueQueHd[QUE_E_TOTAL_NO_QS] = {
                                &QueNbtWrkQueHd,    //nbt requests
#if REG_N_QUERY_SEP > 0
                                &QueOtherNbtWrkQueHd,    //nbt requests
#endif
                                &QueRplPullQueHd,   //Pull requests
                                &QueRplPushQueHd,   //Push requests
                                &QueNmsNrcqQueHd,   //Chl request from nbt thds
                                &QueNmsRrcqQueHd,   //Chl req. from Pull thd
                                &QueNmsCrqQueHd,    //Chl rsp from UDP thd
                                &QueWinsTmmQueHd,   //timer queue
                                &QueWinsScvQueHd,   //Scavenger queue
                                &QueInvalidQueHd
                                };

STATIC  fsChlWaitForRsp = FALSE;

CHECK("The timer queue may not be a PLIST_ENTRY queue.  We may not")
CHECK("just insert the work item at the end")

/*
 *        Local Function Prototype Declarations
*/

STATIC
BOOL
ChlRspDropped(
        MSG_T   pMsg
        );



//
// Function definitions start here
//

STATUS
QueInsertNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue


Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        QueNbtReq in nms.c

Side Effects:

Comments:
        None
--*/


{


     PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
     STATUS                   RetStat;

     QueAllocWrkItm(
                        QueBuffHeapHdl,
                        sizeof(NBT_REQ_WRK_ITM_T),
                        (LPVOID *)&pNbtWrkItm
                       );

     pNbtWrkItm->DlgHdl = *pDlgHdl;
     pNbtWrkItm->pMsg   = pMsg;
     pNbtWrkItm->MsgLen = MsgLen;

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pNbtWrkItm,
                        QUE_E_NBT_REQ,
                        NULL                         /*ptr to que head*/
                               );

     return(RetStat);
}



STATUS
QueRemoveNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T     ppMsg,
        OUT PMSG_LEN_T pMsgLen
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        pDlgHdl - Handle to dialogue of nbt request dequeued
        pMsg    - Nbt work item
        MsgLen  - Size of work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NbtThdInitFn() in nms.c

Side Effects:

Comments:
        None
--*/

{

  PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
  STATUS                    RetStat;

  RetStat = QueGetWrkItm(QUE_E_NBT_REQ, &pNbtWrkItm);

  if (RetStat != WINS_SUCCESS)
  {
        *ppMsg = NULL;
  }
  else
  {

          *ppMsg      = pNbtWrkItm->pMsg;
          *pMsgLen    = pNbtWrkItm->MsgLen;
        *pDlgHdl    = pNbtWrkItm->DlgHdl;


          QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
  }

  return(RetStat);

}
#if REG_N_QUERY_SEP > 0
STATUS
QueInsertOtherNbtWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue


Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        QueNbtReq in nms.c

Side Effects:

Comments:
        None
--*/


{


     PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
     STATUS                   RetStat;
     static BOOL              SpoofingStarted = FALSE;

     QueAllocWrkItm(
                        QueBuffHeapHdl,
                        sizeof(NBT_REQ_WRK_ITM_T),
                        (LPVOID *)&pNbtWrkItm
                       );

     pNbtWrkItm->DlgHdl = *pDlgHdl;
     pNbtWrkItm->pMsg   = pMsg;
     pNbtWrkItm->MsgLen = MsgLen;

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pNbtWrkItm,
                        QUE_E_OTHER_NBT_REQ,
                        NULL                         /*ptr to que head*/
                               );
     //
     // If the queue is full, the request was not inserted, so
     // drop it. Log an event after every 100 requests have
     // been dropped
     //
     if (RetStat == WINS_QUEUE_FULL)
     {
        static DWORD    sNoOfReqSpoofed = 0;
        static DWORD    sBlockOfReq = 1;

#if DBG
        static DWORD sNoOfReqDropped = 0;
#endif
        if (!WinsCnf.fDoSpoofing)
        {
#if DBG
          NmsRegReqQDropped++;
          if (sNoOfReqDropped++ == 5000)
          {
             sNoOfReqDropped = 0;
             DBGPRINT1(ERR, "ENmsHandleMsg: REG QUEUE FULL. REQUESTS DROPPED = (%d\n", NmsRegReqQDropped);
          }

#endif
         //
         // NOTE : freeing the buffers here takes away from modularity aspects
         // of code but saves us cycles on the critical path
         //
         ECommFreeBuff(pMsg);
         ECommEndDlg(pDlgHdl);
       }
       else
       {

        //
        // we respond to groups of 300
        // refresh/reg requests with a refresh interval of a multiple of
        // 5 mts.  The multiple is based on the group #.  The refresh interval
        // is not allowed to go over 1-2 hrs .
        //
        if (sNoOfReqSpoofed > 100)
        {
              if (sBlockOfReq == 10)
              {
                     sBlockOfReq = 1;
              }
              else
              {
                     sBlockOfReq++;
              }
              sNoOfReqSpoofed = 0;
        }
        else
        {
              sNoOfReqSpoofed++;
        }

        if (!SpoofingStarted) 
        {
            WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SPOOFING_STARTED);
            SpoofingStarted = TRUE;
        }
        DBGPRINT1(DET, "QueInsertOtherNbtWrkItm: Spoofing - SpoofBlockNum %d\n", sBlockOfReq);
        NmsMsgfSndNamRsp(pDlgHdl, pMsg, MsgLen, sBlockOfReq);
       }
       QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
    }

    if ((WINS_SUCCESS == RetStat) && SpoofingStarted &&  QueOtherNbtWrkQueHd.NoOfEntries < (QueOtherNbtWrkQueMaxLen >> 2)) 
    {
        WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SPOOFING_COMPLETED);
        SpoofingStarted = FALSE;

    }
    return(RetStat);
}



STATUS
QueRemoveOtherNbtWrkItm(
        OUT PCOMM_HDL_T pDlgHdl,
        OUT PMSG_T     ppMsg,
        OUT PMSG_LEN_T pMsgLen
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        pDlgHdl - Handle to dialogue of nbt request dequeued
        pMsg    - Nbt work item
        MsgLen  - Size of work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NbtThdInitFn() in nms.c

Side Effects:

Comments:
        None
--*/

{

  PNBT_REQ_WRK_ITM_T  pNbtWrkItm = NULL;
  STATUS                    RetStat;

  RetStat = QueGetWrkItm(QUE_E_OTHER_NBT_REQ, &pNbtWrkItm);

  if (RetStat != WINS_SUCCESS)
  {
        *ppMsg = NULL;
  }
  else
  {

          *ppMsg      = pNbtWrkItm->pMsg;
          *pMsgLen    = pNbtWrkItm->MsgLen;
        *pDlgHdl    = pNbtWrkItm->DlgHdl;


          QueDeallocWrkItm( QueBuffHeapHdl,  pNbtWrkItm );
  }

  return(RetStat);

}
#endif

STATUS
QueInsertChlReqWrkItm(
        IN NMSCHL_CMD_TYP_E    CmdTyp_e,
        IN WINS_CLIENT_E       Client_e,
        IN PCOMM_HDL_T         pDlgHdl,
        IN MSG_T               pMsg,
        IN MSG_LEN_T           MsgLen,
        IN DWORD               QuesNamSecLen,
        IN PNMSDB_ROW_INFO_T   pNodeToReg,
        IN PNMSDB_STAT_INFO_T  pNodeInCnf,
        //IN PCOMM_ADD_T         pAddOfNodeInCnf,
        IN PCOMM_ADD_T               pAddOfRemWins
        )

/*++

Routine Description:
        This function inserts a work item on the nbt request queue

Arguments:
        pDlgHdl - Handle to dialogue under which the nbt request was received
        pMsg    - Nbt work item
        MsgLen  - Size of work item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsChlHdlNamReg

Side Effects:

Comments:
        None
--*/


{


     PCHL_REQ_WRK_ITM_T  pWrkItm = NULL;
     STATUS                   RetStat = WINS_SUCCESS;
     DWORD                 Error   = 0;
     BOOL                 fLvCrtSec = FALSE;
     DWORD                 i;

     QueAllocWrkItm(
                        NmsChlHeapHdl,
                        sizeof(CHL_REQ_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                       );

     pWrkItm->CmdTyp_e       = CmdTyp_e;
     pWrkItm->Client_e       = Client_e;
     if (pDlgHdl != NULL)
     {
             pWrkItm->DlgHdl      = *pDlgHdl;
     }
     pWrkItm->pMsg           = pMsg;
     pWrkItm->MsgLen         = MsgLen;
     pWrkItm->QuesNamSecLen  = QuesNamSecLen;
     pWrkItm->NodeToReg      = *pNodeToReg;

     pWrkItm->NodeAddsInCnf.NoOfMems = pNodeInCnf->NodeAdds.NoOfMems;
     for (i=0; i < pNodeInCnf->NodeAdds.NoOfMems; i++)
     {
         pWrkItm->NodeAddsInCnf.Mem[i] = pNodeInCnf->NodeAdds.Mem[i];
     }
     pWrkItm->NoOfAddsToUse   = pNodeInCnf->NodeAdds.NoOfMems;
     pWrkItm->NoOfAddsToUseSv = pNodeInCnf->NodeAdds.NoOfMems;

     pWrkItm->OwnerIdInCnf  = pNodeInCnf->OwnerId;
     pWrkItm->fGroupInCnf   = NMSDB_ENTRY_GRP_M(pNodeInCnf->EntTyp);

    // pWrkItm->NodeTypInCnf  = pNodeInCnf->NodeTyp;
    // pWrkItm->EntTypInCnf   = pNodeInCnf->EntTyp;


     if (pNodeToReg->pNodeAdd != NULL)
     {
        pWrkItm->AddToReg =  *(pNodeToReg->pNodeAdd);
     }
     if (pAddOfRemWins != NULL)
     {
             pWrkItm->AddOfRemWins   = *pAddOfRemWins;
     }

     switch(Client_e)
     {
        case(WINS_E_NMSNMH):
                        pWrkItm->QueTyp_e = QUE_E_NMSNRCQ;
                        break;

        case(WINS_E_RPLPULL):
                        pWrkItm->QueTyp_e = QUE_E_NMSRRCQ;
                        break;

        default:
                        DBGPRINT0(ERR, "QueInsertChlWrkItm: Invalid Client\n");
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        break;

     }

     RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pWrkItm,
                        pWrkItm->QueTyp_e,
                        NULL /*ptr to que head*/
                               );

     return(RetStat);
}



STATUS
QueRemoveChlReqWrkItm(
        IN         HANDLE                EvtHdl,
        IN OUT         LPVOID                *ppaWrkItm,
        OUT        LPDWORD                pNoOfReqs
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        EvtHdl     - handle of event signaled (not used currently)
        ppaWrkItm  - pointer to array  of pointers (to work items) to
                     initialize
        pNoOfReqs  - No of Requests acquired (in the array pointed by
                     the ppaWrkItm arg


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ChlThdInitFn() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

          STATUS                    RetStat    = WINS_SUCCESS;
          PQUE_HD_T             pQueHd;

        UNREFERENCED_PARAMETER(EvtHdl);
        *pNoOfReqs = 0;

        //
        // EvtHdl is the handle of the event signaled.  We don't use
        // it since we always need to check the queues in the sequence
        // Nrcq, Rrcq, Srcq irrespective of the event that got signaled.
        //
        // EvtHdl is passed as an input argument for future extensibility

        //
        // We could have had one critical section for both the queues but that
        // could slow NBT threads due to replication. We don't
        // want that.
        //


        //
        // First check the NBT Request challenge queue
        //
        pQueHd        = &QueNmsNrcqQueHd;
        EnterCriticalSection(&pQueHd->CrtSec);
try {

        //
        // We have a limit to the number of nodes
        // we will challenge at any one time
        //
          while (
                (!IsListEmpty(&pQueHd->Head)) &&
                (*pNoOfReqs < NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
             )
          {
                  *ppaWrkItm++    = RemoveHeadList(&pQueHd->Head);
                (*pNoOfReqs)++;
          }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }
        //
        // if we have reached the limit return
        //
        if (*pNoOfReqs == NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
        {
        DBGPRINT0(CHL, "QueRemoveChlReqWrkItm: Limit reached with just nbt requests\n");
                *ppaWrkItm = NULL;   //delimiter to the list
                return(WINS_SUCCESS);
        }

        //
        // Now check the Replicator request challenge queue (populated
        // by the Pull handler
        //
        pQueHd = &QueNmsRrcqQueHd;
        EnterCriticalSection(&pQueHd->CrtSec);
try {
          while(
                (!IsListEmpty(&pQueHd->Head))  &&
                (*pNoOfReqs < NMSCHL_MAX_CHL_REQ_AT_ONE_TIME)
             )
          {
                  *ppaWrkItm++    = RemoveHeadList(&pQueHd->Head);
                (*pNoOfReqs)++;
          }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }

        if (*pNoOfReqs == 0)
        {
                RetStat = WINS_NO_REQ;
        }
        else
        {
                *ppaWrkItm = NULL;   //delimiter to the list
        }

          return(RetStat);
}




STATUS
QueInsertChlRspWrkItm(
        IN PCOMM_HDL_T   pDlgHdl,
        IN MSG_T         pMsg,
        IN MSG_LEN_T     MsgLen
        )

/*++

Routine Description:
        This function inserts a work item on the challenge response queue


Arguments:

        pDlgHdl - Handle to dialogue under which the nbt response was received
        pMsg    - response message
        MsgLen  - response msg length

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ENmsHdlMsg in nms.c

Side Effects:

Comments:
        None
--*/


{


     PCHL_REQ_WRK_ITM_T  pWrkItm = NULL;
     STATUS                RetStat = WINS_SUCCESS;
     DWORD                      Error   = 0;

     if (!ChlRspDropped(pMsg))
     {
       QueAllocWrkItm(
                        NmsChlHeapHdl,
                        sizeof(CHL_RSP_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                       );

       pWrkItm->DlgHdl = *pDlgHdl;
       pWrkItm->pMsg   = pMsg;
       pWrkItm->MsgLen = MsgLen;

       RetStat =  QueInsertWrkItm(
                        (PLIST_ENTRY)pWrkItm,
                        QUE_E_NMSCRQ,
                        NULL /*ptr to que head*/
                               );

     }
     return(RetStat);
}

STATUS
QueRemoveChlRspWrkItm(
        IN LPVOID                *ppWrkItm
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        ppaWrkItm  - address of an array of pointers to chl request work items

Externals Used:
        None

Return Value:

   Success status codes --   WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:

Called by:
        ChlThdInitFn() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

  STATUS                    RetStat;
  RetStat = QueGetWrkItm(QUE_E_NMSCRQ, ppWrkItm);
  return(RetStat);
}


STATUS
QueInsertWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN  OPTIONAL QUE_TYP_E                QueTyp_e,
        IN  OPTIONAL PQUE_HD_T                pQueHdPassed
        )

/*++

Routine Description:
        This function is called to queue a work item on
        a queue.  If the pQueHdPassed is Non NULL, the work item is queued
        on that queue, else, it is queued on the queue specified by
        QueTyp_e.

        TMM will use pQueHdPassed to specify the queue while other clients
        of the queue services will specify QueTyp_e

Arguments:
        pWrkItm      - Work Item to queue
        QueTyp_e     - Type of queue to queue it on (may or may not have valid                                       value)
        pQueHdPassed - Head of queue (may or may not be passed)

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
//        DWORD                Error;

        if (pQueHdPassed == NULL)
        {

                pQueHd = pWinsQueQueHd[QueTyp_e];
        }
        else
        {
                pQueHd = pQueHdPassed;
        }

        EnterCriticalSection(&pQueHd->CrtSec);
try {

        //
        // If we are surpassing the limit in the Reg/Ref/Rel queue,
        // don't insert the wrk. item.
        //
        if ((pQueHd == &QueOtherNbtWrkQueHd) &&
            (pQueHd->NoOfEntries > QueOtherNbtWrkQueMaxLen))
        {
               RetStat = WINS_QUEUE_FULL;
        }
        else
        {
          InsertTailList(&pQueHd->Head, pWrkItm);
          pQueHd->NoOfEntries++;
          if (!SetEvent(pQueHd->EvtHdl))
          {
//              Error   = GetLastError();
                RetStat = WINS_FAILURE;
          }
        }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
}

        return(RetStat);

}

STATUS
QueGetWrkItm (
        IN  QUE_TYP_E                QueTyp_e,
        OUT LPVOID                *ppWrkItm
        )

/*++

Routine Description:
        This function is called to dequeue a work item from
        a queue

Arguments:

        QueTyp_e  - Type of queue to get the wrk item from
        ppWrkItm  - Work Item

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS or WINS_NO_REQ
   Error status codes   --  None at present

Error Handling:

Called by:
        RplPullInit, QueNbtRemoveWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T       pQueHd;

        pQueHd         = pWinsQueQueHd[QueTyp_e];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
        if (IsListEmpty(&pQueHd->Head))
        {
                *ppWrkItm = NULL;
                RetStat   = WINS_NO_REQ;
        }
        else
        {
                  *ppWrkItm    = RemoveHeadList(&pQueHd->Head);
                  pQueHd->NoOfEntries--;
        }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
 }
        return(RetStat);
}




__inline
VOID
QueAllocWrkItm(
        IN   HANDLE        HeapHdl,
        IN   DWORD        Size,
        OUT  LPVOID        *ppBuf
        )

/*++

Routine Description:

        This function allocates a work item.  The work item is allocated
        from a heap

Arguments:

        ppBuf - Buffer (work item) allocated

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{



  //
  //  WinsMscHeapAlloc will return an exception if it is not able to
  //  allocate a buffer.  So there is no need to check the return value
  //  for NULL.
  //
  *ppBuf = WinsMscHeapAlloc(HeapHdl, Size );
  return;
}


__inline
VOID
QueDeallocWrkItm(
   IN  HANDLE HeapHdl,
   IN  PVOID  pBuff
        )

/*++

Routine Description:
        This function deallcoated a nbt request  work item

Arguments:
        pBuff - Nbt req. work item to deallocate

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  none currently

Error Handling:

Called by:
        QueRemoveNbtWrkItm
Side Effects:

Comments:
        None
--*/
{


  WinsMscHeapFree(
                        HeapHdl,
                        pBuff
                   );


  return;

}



STATUS
QueInsertWrkItmAtHdOfList (
        IN  PLIST_ENTRY                pWrkItm,
        IN  QUE_TYP_E                QueTyp_e,
        IN  PQUE_HD_T                pQueHdPassed
        )

/*++

Routine Description:
        This function is called to queue a work item
        at the head of a queue.  If the pQueHdPassed is Non NULL,
        the work item is queued on that queue, else, it is queued on
        the queue specified by QueTyp_e.

        TMM will use pQueHdPassed to specify the queue while other clients
        of the queue services will specify QueTyp_e

Arguments:
        pWrlItm      - Work Item to queue
        QueTyp_e     - Type of queue to queue it on (may or may not have valid                                       value)
        pQueHdPassed - ListHead of queue (may or may not be passed)

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ProcRsp in nmschl.c

Side Effects:

Comments:
        This function differs from QueInsertWrkItm in that it inserts
        the work item at the head of a queue versus at the tail.  I
        prefered to create this function rather than have an extra
        argument to QueInsertWrkItm to save an if test.  QueInsertWrkItm
        is used by the UDP listener thread and I want to do the minimum
        work I can in that thread.


--*/
{
FUTURES("I may get rid of this function since it is very similar to QueInsertWrkItm")
        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
        DWORD                Error;

        if (pQueHdPassed == NULL)
        {

                pQueHd = pWinsQueQueHd[QueTyp_e];
        }
        else
        {
                pQueHd = pQueHdPassed;
        }

        EnterCriticalSection(&pQueHd->CrtSec);
try {
          InsertHeadList(&pQueHd->Head, pWrkItm);
        if (!SetEvent(pQueHd->EvtHdl))
        {
           Error   = GetLastError();
           RetStat = WINS_FAILURE;
        }
}
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
  }

#ifdef WINSDBG
    NmsChlNoReqAtHdOfList++;
#endif
        return(RetStat);

}



STATUS
QueInsertRplPushWrkItm (
        IN               PLIST_ENTRY        pWrkItm,
        IN           BOOL                fAlreadyInCrtSec
        )

/*++

Routine Description:
        This function is called to queue a work item on
        the Push thread's queue.

Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd = pWinsQueQueHd[QUE_E_RPLPUSH];

        //
        // if we are already in the critical section, no need to enter it
        // again
        //
        if (!fAlreadyInCrtSec)
        {
                EnterCriticalSection(&pQueHd->CrtSec);
        }
try {
        //
        // if the push thread does not exist, create it.
        //
        if (!fRplPushThdExists)
        {
              WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdHdl =
                                WinsMscCreateThd(
                                        RplPushInit,
                                        NULL,
                                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdId
                                        );
             fRplPushThdExists = TRUE;
             WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].fTaken = TRUE;
             WinsThdPool.ThdCount++;
        }

        //
        // Insert the work item and signal the thread.
        //
          InsertTailList(&pQueHd->Head, pWrkItm);
        if (!SetEvent(pQueHd->EvtHdl))
        {
           WINSEVT_LOG_M(WINS_EVT_SFT_ERR, GetLastError());
           RetStat = WINS_FAILURE;
        }
  }
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "QueInsertRplPushWrkItm: Got exception (%d)\n",ExcCode);
        //
        // no need to log an event. WinsMscCreateThd logs it
        //

  }
        //
        // If we entered the critical section, we should get out of it
        //
        if (!fAlreadyInCrtSec)
        {
                LeaveCriticalSection(&pQueHd->CrtSec);
        }

        return(RetStat);

}

VOID
QueChlWaitForRsp(
    VOID
    )
{
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);
    fsChlWaitForRsp = TRUE;
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    return;
}

VOID
QueChlNoWaitForRsp(
    VOID
    )
{
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);
    fsChlWaitForRsp = FALSE;
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    return;
}

BOOL
ChlRspDropped(
        MSG_T   pMsg
        )
{
    BOOL fFreeBuff = FALSE;
    EnterCriticalSection(&QueNmsCrqQueHd.CrtSec);

    //
    // If the challenge thread is not wait for responses, drop the
    // datagram
    //
    if (!fsChlWaitForRsp)
    {
        fFreeBuff = TRUE;

    }
    LeaveCriticalSection(&QueNmsCrqQueHd.CrtSec);
    if (fFreeBuff)
    {
#ifdef WINSDBG
        NmsChlNoRspDropped++;
#endif
        ECommFreeBuff(pMsg);
        return(TRUE);
    }
    return(FALSE);
}

STATUS
QueInsertNetNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        )

/*++

Routine Description:
        This function is called to queue a push ntf work item on
    the RPLPULL  queue. It checks if there is another push ntf
    work item from the same WINS on the queue.  If there is, it is replaced
    with this new one. This is done because the new one has more information
    than the previous one.  The old one is terminated to free up the connection.


Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
    PQUE_RPL_REQ_WRK_ITM_T pTmp;
    COMM_IP_ADD_T  IpAddNew;
    COMM_IP_ADD_T  IpAddInList;
    BOOL           fBreak = FALSE;
    PRPL_CONFIG_REC_T pCnfRec;


    //
    // Get address of the WINS sending the notfication
    //
    pTmp = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItm;
    pCnfRec = pTmp->pClientCtx;
    COMM_GET_IPADD_M(&pTmp->DlgHdl, &IpAddNew);
        pQueHd = pWinsQueQueHd[QUE_E_RPLPULL];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
    for(pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pQueHd->Head.Flink;
        pTmp !=  (PQUE_RPL_REQ_WRK_ITM_T)pQueHd;
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pTmp->Head.Flink)
    {


       if ( pTmp->CmdTyp_e == QUE_E_CMD_HDL_PUSH_NTF )
       {
            //
            // Get address of the WINS that sent this notification
            //
            COMM_GET_IPADD_M(&pTmp->DlgHdl, &IpAddInList);
            if (IpAddInList == IpAddNew)
            {
                 DBGPRINT1(DET, "QueInsertNetNtfWrkItm: Found an earlier Net Ntf work item. Replacing it.  WINS address = (%x)\n", IpAddInList);
                 //
                 // switch the work items since the new one takes precedence
                 // over the old one.
                 //
                 pWrkItm->Flink = pTmp->Head.Flink;
                 pWrkItm->Blink = pTmp->Head.Blink;
                 pTmp->Head.Blink->Flink = pWrkItm;
                 pTmp->Head.Flink->Blink = pWrkItm;
                 fBreak = TRUE;
                 break;
            }
        }
     }
     //
     // If there was no match, insert at tail end of list
     //
     if (!fBreak)
     {
          InsertTailList(&pQueHd->Head, pWrkItm);
     }
     if (!SetEvent(pQueHd->EvtHdl))
     {
//              Error   = GetLastError();
               RetStat = WINS_FAILURE;
     }
    } // end of try
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);
}
    //
    // If we found a match, terminate the old work item
    //
    // Do this outside the critical section
    //
    if (fBreak)
    {
CHECK("Can we avoid the try block")
try {
#if PRSCONN
      RPLMSGF_MSG_OPCODE_E Opcode_e;
      BOOL                 fPrsDlg;
#endif


#if PRSCONN
      //
      // If the ntf was sent on a persistent dlg, we do not terminate it since
      // it will be terminated by the remote WINS when it so chooses. This
      // dlg is used for multiple such notifications.  If
      // it was sent on a non-persistent dlg, we will terminate it since the
      // remote WINS create a dlg for each such notification
      //
      RPLMSGF_GET_OPC_FROM_MSG_M(pTmp->pMsg, Opcode_e);

      fPrsDlg = ((Opcode_e == RPLMSGF_E_UPDATE_NTF_PRS) || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS));
      if (!fPrsDlg)
      {
         ECommEndDlg(&pTmp->DlgHdl);
      }
#else
      ECommEndDlg(&pTmp->DlgHdl);
#endif
      //
      // Terminate the dequeued request.
      //
      ECommFreeBuff(pTmp->pMsg - COMM_HEADER_SIZE);
      QueDeallocWrkItm(RplWrkItmHeapHdl, pTmp);

  }
except (EXCEPTION_EXECUTE_HANDLER) {
     DBGPRINTEXC("QueInsertNtfWrkItm");
    }
   }

        return(RetStat);

}
STATUS
QueInsertSndNtfWrkItm (
        IN               PLIST_ENTRY        pWrkItmp
        )

/*++

Routine Description:
        This function is called to queue a send push ntf work item on
    the RPLPULL  queue. It checks if there is another send push ntf
    work item from the same WINS on the queue.  If there is, it is replaced
    with this new one. This is done because the new one has more information
    than the previous one.  The old one is terminated to free up the connection.


Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue, QueInsertNbtWrkItm

Side Effects:

Comments:
        None
--*/
{

        STATUS                RetStat = WINS_SUCCESS;
        PQUE_HD_T        pQueHd  = NULL;
    PQUE_RPL_REQ_WRK_ITM_T pTmp;
    PQUE_RPL_REQ_WRK_ITM_T pWrkItm = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItmp;
    COMM_IP_ADD_T  IpAddNew;
    COMM_IP_ADD_T  IpAddInList;
    BOOL           fBreak = FALSE;
    PRPL_CONFIG_REC_T pCnfRec;


    pTmp = (PQUE_RPL_REQ_WRK_ITM_T)pWrkItm;
    pCnfRec = pTmp->pClientCtx;
    IpAddNew = pCnfRec->WinsAdd.Add.IPAdd;
        pQueHd = pWinsQueQueHd[QUE_E_RPLPULL];

        EnterCriticalSection(&pQueHd->CrtSec);
try {
    for(
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pQueHd->Head.Flink;
        pTmp !=  (PQUE_RPL_REQ_WRK_ITM_T)pQueHd;
        // no 3rd expression
        )
    {

        //
        // If this is a push ntf item, then go on to the next if test
        //
        if (( pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF ) ||
                        (pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF_PROP))
        {
                IpAddInList = ((PRPL_CONFIG_REC_T)(pTmp->pClientCtx))->WinsAdd.Add.IPAdd;
                //
                // If the push is to the same WINS, replace the work item
                //
                if (IpAddInList == IpAddNew)
                {
                   if (pTmp->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF_PROP)
                   {
                       pWrkItm->CmdTyp_e = pTmp->CmdTyp_e;
                   }

                   DBGPRINT1(DET, "QueInsertSndNtfWrkItm: Found an earlier Snd Ntf work item. Replacing it.  WINS address = (%x)\n", IpAddInList);

                   //
                   // switch the work items since the new one takes precedence
                   // over the old one.
                   //
                   pWrkItmp->Flink = pTmp->Head.Flink;
                   pWrkItmp->Blink = pTmp->Head.Blink;
                   pTmp->Head.Blink->Flink = pWrkItmp;
                   pTmp->Head.Flink->Blink = pWrkItmp;
                   fBreak = TRUE;
                   break;
                }
        }
        pTmp =   (PQUE_RPL_REQ_WRK_ITM_T)pTmp->Head.Flink;
    }
    if (!fBreak)
    {
          InsertTailList(&pQueHd->Head, pWrkItmp);
    }
    if (!SetEvent(pQueHd->EvtHdl))
    {
//              Error   = GetLastError();
           RetStat = WINS_FAILURE;
     }
  }
finally {
        LeaveCriticalSection(&pQueHd->CrtSec);

    //
    // if we replaced an item, we need to deallocate it here.
    //
    if (fBreak)
    {
       QueDeallocWrkItm(RplWrkItmHeapHdl, pTmp);
    }
}
        return(RetStat);

}

__inline
STATUS
QueInsertScvWrkItm (
        IN               PLIST_ENTRY        pWrkItm
        )

/*++

Routine Description:
        This function is called to queue a work item on
        the Push thread's queue.

Arguments:
        pWrkItm      - Work Item to queue

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ERplInsertQue

Side Effects:

Comments:
        None
--*/
{
        return(QueInsertWrkItm ( pWrkItm, QUE_E_WINSSCVQ, NULL));
}
__inline
STATUS
QueRemoveScvWrkItm(
        IN OUT     LPVOID                *ppWrkItm
        )

/*++

Routine Description:

        This function removes a work item from the nbt queue.
Arguments:

        ppWrkItm  - pointer to array  of pointers (to work items) to
                     initialize


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        return(QueGetWrkItm(QUE_E_WINSSCVQ, ppWrkItm));
}


VOID
WinsQueInit(
    LPTSTR     pName,
    PQUE_HD_T  pQueHd
    )

/*++

Routine Description:
          Function to init a queue

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	    //
	    // Create the response event handle.  This event is signaled
	    // by the UDP listener thread when it stores a response
	    // in the spReqWrkItmArr array
	    //
	    WinsMscCreateEvt(
			  pName,
			  FALSE,	//auto-reset
			  &pQueHd->EvtHdl
			);


	    //
	    // Initialize the critical section for the response queue
	    //				
	    InitializeCriticalSection(&pQueHd->CrtSec);
	
	    //
	    //Initialize the queue head for the response queue
	    //
	    InitializeListHead(&pQueHd->Head);
        pQueHd->NoOfEntries = 0;  //not required really since QueHd structures
                                  //are externs
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nms.c ===
/*
  Possible improvements

  If there were a way to end all sessions with one Jet call, there would be
  no need to have each nbt thread call WinsMscWaitUntilSignaled. It could simply
  call WaitForSingleObject.
*/

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        nms.c


Abstract:
        This module contains functions used by the name space manager (NMS)

        This is the top-most module of the name space manager component of
        WINS.  It contains functions used for initializing WINS and for
        providing an interface nto NMS to other components to WINS.


Functions:

        main
        WinsMain
        Init
        CreateNbtThdPool
        NbtThdInitFn
        CreateMem
        ENmsHandleMsg
        NmsAllocWrkItm
        NmsDeallocWrkItm
        NmsServiceControlHandler
        SignalWinsThds
        UpdateStatus
        WrapUp



Portability:
        This module is portable across various platforms

Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/


#include "wins.h"
#include  <lmerr.h>
#include  <lmcons.h>
#include  <secobj.h>        //required for ACE_DATA
#include "winsif.h"  //required because winsif_v1_0_s_ifspec is being
                     //referenced
#include "winsi2.h"
#ifdef WINSDBG
#include <time.h>
#endif

#include "winscnf.h"
#include "nmsdb.h"
#include "winsque.h"
#include "winsthd.h"
#include "comm.h"
#include "assoc.h"
#include "winsmsc.h"
#include "nms.h"
#include "nmsmsgf.h"
#include "nmschl.h"
#include "nmsnmh.h"
#include "nmsscv.h"
#include "winsevt.h"
#include "winstmm.h"
#include "rplpull.h"
#include "rplpush.h"
#include "winsintf.h"
#include "lmaccess.h"

/*
 *        Local Macro Declarations
 */
#define NMS_RANGE_SIZE          500
#define NMS_HW_SIZE             400

#define DBG_FILE_MAX_SIZE           1000000  //1 MB
#define DBG_TIME_INTVL_FOR_CHK      1800     //30 mts

/*
 *        Local Typedef Declarations
 */
/*
 *        Global Variable Definitions
 */

WINSTHD_POOL_T          WinsThdPool;              //thread pool for WINS
DWORD                    WinsTlsIndex;              //TLS index for NBT threads
HANDLE                  NmsMainTermEvt;     //For terminating the WINS service
HANDLE                  NmsTermEvt;              //Termination event
HANDLE                  NmsCrDelNbtThdEvt;
CRITICAL_SECTION  NmsTermCrtSec;      //Critical Section guarding count of
                                      //threads
//STATIC CRITICAL_SECTION  sSvcCtrlCrtSec;      //Critical Section guarding service

                                         //controller initiated action


GENERIC_MAPPING          NmsInfoMapping = {
                                        STANDARD_RIGHTS_READ,
                                        STANDARD_RIGHTS_WRITE,
                                        STANDARD_RIGHTS_EXECUTE,
                                        WINS_ALL_ACCESS
                                    };
#ifdef WINSDBG

FUTURES("put all ctrs in a structure")
CRITICAL_SECTION  sDbgCrtSec;

DWORD   NmsGenHeapAlloc;
DWORD   NmsDlgHeapAlloc;
DWORD   NmsTcpMsgHeapAlloc;
DWORD   NmsUdpHeapAlloc;
DWORD   NmsUdpDlgHeapAlloc;
DWORD   NmsQueHeapAlloc;
DWORD   NmsAssocHeapAlloc;
DWORD   NmsRpcHeapAlloc;
DWORD   NmsRplWrkItmHeapAlloc;
DWORD   NmsChlHeapAlloc;
DWORD   NmsTmmHeapAlloc;
DWORD   NmsCatchAllHeapAlloc;

DWORD   NmsHeapAllocForList;

DWORD   NmsGenHeapFree;
DWORD   NmsDlgHeapFree;
DWORD   NmsTcpMsgHeapFree;
DWORD   NmsUdpHeapFree;
DWORD   NmsUdpDlgHeapFree;
DWORD   NmsQueHeapFree;
DWORD   NmsAssocHeapFree;
DWORD   NmsRpcHeapFree;
DWORD   NmsRplWrkItmHeapFree;
DWORD   NmsChlHeapFree;
DWORD   NmsTmmHeapFree;
DWORD   NmsCatchAllHeapFree;

DWORD   NmsHeapCreate;
DWORD   NmsHeapDestroy;


//
// Count of updates (to version number) made by WINS.
//
DWORD   NmsUpdCtrs[WINS_NO_OF_CLIENTS][2][4][3][2];
DWORD   NmsRplUpd;
DWORD   NmsRplGUpd;
DWORD   NmsNmhUpd;
DWORD   NmsNmhGUpd;
DWORD   NmsNmhRelUpd;
DWORD   NmsNmhRelGUpd;
DWORD   NmsScvUpd;
DWORD   NmsScvGUpd;
DWORD   NmsChlUpd;
DWORD   NmsChlGUpd;
DWORD   NmsRpcUpd;
DWORD   NmsRpcGUpd;
DWORD   NmsOthUpd;
DWORD   NmsOthGUpd;

NMS_CTRS_T NmsCtrs;


CRITICAL_SECTION NmsHeapCrtSec;

STATIC        volatile DWORD                 sReqDq = 0;   //for testing only
STATIC        volatile DWORD                 sRegReqDq = 0;   //for testing only
STATIC        volatile DWORD                 sReqQ = 0;     //for testing only
STATIC        volatile DWORD                 sRegReqQ = 0;   //for testing only
STATIC        volatile DWORD                 sRsp = 0;   //for testing only

STATIC   time_t sDbgLastChkTime;


volatile DWORD                 NmsRegReqQDropped = 0;   //for testing only




extern DWORD   NmsGenHeapAlloc;
#endif

PSECURITY_DESCRIPTOR pNmsSecurityDescriptor = NULL;

COMM_ADD_T          NmsLocalAdd = {0};  //My own address
ULONG                  WinsDbg;            //for debugging purposes. see winsdbg.h
/*
 *  NmsTotalTrmThdCnt -- The total number of threads that deal with NmsTermEvt
 *                      event
 *                      These are -- main thread, nbt threads, name challenge thd,
 *                                   scavenger thread, replication threads
 */
DWORD                  NmsTotalTrmThdCnt = 1;  //set to 1 for the main thread
HANDLE                  GenBuffHeapHdl;  //handle to heap for use for queue items
HANDLE                  NmsRpcHeapHdl;  //handle to heap for use  by rpc
DWORD                  NmsNoOfNbtThds         = 0;
BOOL                  fNmsAbruptTerm          = FALSE;
BOOL                  fNmsMainSessionActive = FALSE;

//
// Counter to indicate how many rpc calls that have to do with Jet are
// currently in progress
//
DWORD                 NmsNoOfRpcCallsToDb;

//
// This is set to TRUE to indicate that there are one or more threads
// that have active DB sessions but are not included in the count of
// threads with such sessions.  When this is set to TRUE, the main thread
// will not call JetTerm (from within NmsDbRelRes) due to a limitation
// in Jet.  We take a thread out of the count when it is involved in an
// activity that can take long since we do not want to hold up WINS termination
// for long.  For example, the pull thread is taken out when it is trying
// to establish a connection.
//
BOOL          fNmsThdOutOfReck = FALSE;

#if defined (DBGSVC) || TEST_DATA > 0
HANDLE                    NmsFileHdl = INVALID_HANDLE_VALUE;
HANDLE                    NmsDbgFileHdl = INVALID_HANDLE_VALUE;
#define           QUERY_FAIL_FILE  TEXT("wins.out")
#endif

VERS_NO_T         NmsRangeSize                 = {0};
VERS_NO_T         NmsHalfRangeSize             = {0};
VERS_NO_T         NmsVersNoToStartFromNextTime = {0};
VERS_NO_T         NmsHighWaterMarkVersNo       = {0};

/*
 *        Local Variable Definitions
 */

static BOOL          sfHeapsCreated = FALSE;


static HANDLE           sNbtThdEvtHdlArray[3]; //event array to wait on (NBT thread)
static  BOOL          fsBackupOnTerm = TRUE;

#if REG_N_QUERY_SEP > 0
STATIC HANDLE           sOtherNbtThdEvtHdlArray[2]; //event array to wait on (NBT thread)
#endif

SERVICE_STATUS          ServiceStatus;
SERVICE_STATUS_HANDLE   ServiceStatusHdl;

/*
 *        Local Function Prototype Declarations
*/
#if TEST_DATA > 0 || defined(DBGSVC)
STATIC BOOL
DbgOpenFile(
        LPTSTR pFileNm,
        BOOL   fReopen
        );
#endif

STATIC
STATUS
ProcessInit(
        VOID
);

//
// Create a pool of NBT threads (Threads that service NBT requests)
//
STATIC
STATUS
CreateNbtThdPool(
        IN  DWORD NoOfThds,
        IN  LPTHREAD_START_ROUTINE NbtThdInitFn
        );

//
// Initialize memory for use by NMS
//
STATIC
VOID
CreateMem(
        VOID
        );

//
// Startup function of an NBT thread
//
STATIC
DWORD
NbtThdInitFn(
        IN LPVOID pThreadParam
        );
#if REG_N_QUERY_SEP > 0
//
// Startup function of an NBT thread for registering
//
STATIC
DWORD
OtherNbtThdInitFn(
        IN LPVOID pThreadParam
        );

#endif

//
// Signal all threads inside WINS that have a session with the db engine
//
STATIC
VOID
SignalWinsThds (
        VOID
        );

//
// Update status for the benefit of the service controller
//
STATIC
VOID
UpdateStatus(
    VOID
    );


STATIC
VOID
CrDelNbtThd(
        VOID
        );

//
// Main function of WINS called by the thread that is created for
// listerning to the service controller
//
STATIC
VOID
WinsMain(
  DWORD dwArgc,
  LPTSTR *lpszArgv
);

//
// Responsible for the reinitialization of WINS
//
STATIC
VOID
Reinit(
  WINSCNF_HDL_SIGNALED_E IndexOfHdlSignaled_e
);

//
// Responsible for initializing RPC
//
STATIC
BOOL
InitializeRpc(
    VOID
    );

STATIC
BOOL
InitSecurity(
        VOID
        );
STATIC
VOID
WrapUp(
        DWORD  ErrorCode,
        BOOL   fSvcSpecific
    );

STATIC
VOID
GetMachineInfo(
 VOID
);

#if 0
STATIC
VOID
SndQueryToLocalNetbt(
 VOID
);
#endif

//
// The main function
//
VOID __cdecl
main(
     VOID
    )

/*++

Routine Description:
        This is the main function of the WINS server.  It calls the
        StartServiceCtrlDispatcher to connect the main thread of this process
        (executing this function) to the Service Control Manager.


Arguments:
        dwArgc - no. of arguments to this function
        lpszArgv - list of pointers to the arguments

Externals Used:
        WinsCnf

Return Value:
        None

Error Handling:
        Message is printed if DBG ids defined

Called by:
        Startup code

Side Effects:

        None
Comments:
        None
--*/

{

        //
        //WINS server is a service in its own process
        //
        SERVICE_TABLE_ENTRY DispatchTable[] = {
                { WINS_SERVER,  WinsMain },
                { NULL, NULL                  }
                };
        //
        // Set WinsDbg if debugging is turned on
        // Set RplEnabled if Replicator functionality is to be turned on
        // Set ScvEnabled if Scavenging functionality is to be turned on
        //
        DBGINIT;
        DBGCHK_IF_RPL_DISABLED;
        DBGCHK_IF_SCV_DISABLED;
        DBGCHK_IF_PERFMON_ENABLED;


#ifndef WINS_INTERACTIVE
        if (! StartServiceCtrlDispatcher(DispatchTable) )
        {
                DBGPRINT0(ERR, "Main: StartServiceCtrlDispatcher Error\n");
                return;
        }
#else
        WinsMain(1, (LPTSTR *)NULL);
#endif
        return;
}


VOID
WinsMain(
  DWORD  dwArgc,
  LPTSTR *lpszArgv
)

/*++

Routine Description:

        This is the SERVICE_MAIN_FUNCTION of the WINS server.  It
        is called when the service controller starts the service.


Arguments:
        dwArgc   -- no of arguments
        lpszArgc -- argument strings


Externals Used:

        WinsCnf
        NmsTermEvt

Return Value:

        None

Error Handling:

Called by:
        main()

Side Effects:

Comments:
        None
--*/
{
   STATUS           RetStat = WINS_SUCCESS;
#ifndef WINS_INTERACTIVE
   DWORD       Error;
#endif
   HANDLE           ThdEvtHdlArray[WINSCNF_E_NO_OF_HDLS_TO_MONITOR];
   WINSCNF_HDL_SIGNALED_E   IndexOfHdlSignaled_e;//index in the
                                                 //ThdEvtHdlArray of the
                                        //handle that got signaled.  Used as
                                        //an arg to WinsMscWaitUntilSignaled
   DWORD   ExitCode = WINS_SUCCESS;

   UNREFERENCED_PARAMETER(dwArgc);
   UNREFERENCED_PARAMETER(lpszArgv);

   /*
    * Initialize the critical section that guards the
    * NmsTotalTrmThdCnt count  var.
    *
    * NOTE: The initialization of this critical section should occur
    * prior to registering with the service controller.  We are playing
    * it safe just in case in the future SignalWinsThds gets called
    * as part of the cleanup action due to an error that occurs right after
    * we have made ourselves known to the service controller
    *
    * In any case, we must initialize it before calling NmsDbThdInit(). In
    * short it must occue prior to the creation of any thread
    *
   */
   InitializeCriticalSection(&NmsTermCrtSec);

#ifndef WINS_INTERACTIVE
    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    ServiceStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    ServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted        = 0;
    ServiceStatus.dwCheckPoint              = 1;

    //
    // Though 10000 is fine most of the times, for a slow overloaded system,
    // it may not be enough.  Let us be extra conservative and specify
    // 60000 (60 secs). Most of the time is taken by Jet.  In fact, in
    // case the db is corrupted, we will do a restore which can take long.
    // So, add another 60 secs for a grand total of 120000.
    //
FUTURES("Specify 60 secs here and 60secs in nmsdb.c if Restore is to be")
FUTURES("attempted")
    ServiceStatus.dwWaitHint                = 120000;
    ServiceStatus.dwWin32ExitCode           = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = 0;

//    InitializeCriticalSection(&sSvcCtrlCrtSec);
    //
    // Initialize workstation to receive service requests by registering the
    // control handler.
    //
    ServiceStatusHdl = RegisterServiceCtrlHandler(
                              WINS_SERVER,
                              NmsServiceControlHandler
                              );

    if ( ServiceStatusHdl == (SERVICE_STATUS_HANDLE) 0) {
        Error = GetLastError();
               DBGPRINT1(ERR,"Wins: RegisterServiceCtrlHandler error = (%d)\n",
                                                                Error);
        return;
    }

    //
    // Tell Service Controller that we are start pending.
    //
    UpdateStatus();

#endif

#ifdef WINSDBG
        InitializeCriticalSection(&sDbgCrtSec);
#endif
#ifdef WINSDBG
DBGSTART_PERFMON
        fWinsCnfHighResPerfCntr =
                          QueryPerformanceFrequency(&LiWinsCnfPerfCntrFreq);
        if (!fWinsCnfHighResPerfCntr)
        {
                printf("WinsMain: The hardware does not support the high resolution performance monitor\n");
        }
        else
        {
                printf("WinsMain: The hardware supports the high resolution performance monitor.\nThe FREQUENCY is (%d %d)\n",
                                        LiWinsCnfPerfCntrFreq.HighPart,
                                        LiWinsCnfPerfCntrFreq.LowPart
                        );
        }

DBGEND_PERFMON
#endif

try {

    /*
	 First and foremost, open (or create if non-existent) the log file
    */
    WinsCnfInitLog();

    //
    //  Call the initialization function for WINS.  This function will
    //  make the WINS server operational.
    //
#ifdef WINSDBG
    IF_DBG(INIT_BRKPNT)
    {
        DbgUserBreakPoint();
    }
#endif
    RetStat = ProcessInit();

    if ( RetStat != WINS_SUCCESS)
    {

        fNmsAbruptTerm = TRUE;
        WrapUp(RetStat, TRUE);
        DBGPRINT0(ERR, "WinsMain: Initialization Failed\n");
           DBGPRINT0(ERR, "WINS Server has terminated\n");
        return;
    }
#ifndef WINS_INTERACTIVE
    else
    {
        //
        // Tell the service controller that we are up and running now
        //
        ServiceStatus.dwCheckPoint          = 0;
        ServiceStatus.dwCurrentState        = SERVICE_RUNNING;
        ServiceStatus.dwControlsAccepted    = SERVICE_ACCEPT_STOP |
                                              SERVICE_ACCEPT_SHUTDOWN |
                                              SERVICE_ACCEPT_PAUSE_CONTINUE;

        UpdateStatus( );
        if (fWinsCnfInitStatePaused)
        {
           ServiceStatus.dwCurrentState        =  SERVICE_PAUSED;
           UpdateStatus( );
        }

    }

    //
    // If Continue has been sent by the pull thread, it may have been
    // sent while we were in the START_PENDING state.  So, send it again.
    // Sending it again is ok.  We should also send it if we don't have
    // any pnrs to pull from.
    //
    EnterCriticalSection(&RplVersNoStoreCrtSec);
    if ((fRplPullContinueSent) || (WinsCnf.PullInfo.NoOfPushPnrs == 0))
    {
        WinsMscSendControlToSc(SERVICE_CONTROL_CONTINUE);
    }
    LeaveCriticalSection(&RplVersNoStoreCrtSec);
#endif

    //
    // Wait until we are told to stop or when the configuration changes.
    //

    //
    //  Initialize the array of handles on which this  thread will
    //  wait.
    //
    //  K&R C and  ANSI C do not allow non-constant initialization of
    //  an array or a structure.  C++ (not all compilers) allows it.
    //  So, we do it at run time.
    //
    ThdEvtHdlArray[WINSCNF_E_WINS_HDL]        =  WinsCnf.WinsKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_PARAMETERS_HDL]  =  WinsCnf.ParametersKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_PARTNERS_HDL]    =  WinsCnf.PartnersKChgEvtHdl;
    ThdEvtHdlArray[WINSCNF_E_TERM_HDL]        =  NmsMainTermEvt;


FUTURES("I may want to create another thread to do all the initialization and")
FUTURES("wait on the registry change notification key.  That way, the main")
FUTURES("thread will wait only on the TermEvt event. The justification for")
FUTURES("having another thread is debatable, so I am not doing so now ")

     while(TRUE)
     {
            WinsMscWaitUntilSignaled (
               ThdEvtHdlArray,
               sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
               (LPDWORD)&IndexOfHdlSignaled_e,
               TRUE
               );

            if (IndexOfHdlSignaled_e == WINSCNF_E_TERM_HDL)
            {

            DBGPRINT0(FLOW, "WinsMain: Got termination signal\n");

            //
            // Wrap up
            //
            WrapUp(ERROR_SUCCESS, FALSE);
            break;

        }
        else  // registry change notification received. Do reinitialization
        {
           //
           // reinitialize the WINS server according to changes in the
           // registry
           //
           Reinit(IndexOfHdlSignaled_e);
        }
      }
   }
except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("WinsMain");

        //
        // we received an exception.  Set the fNmsAbruptTerm so that
        // JetTerm is not called.
        //
        fNmsAbruptTerm = TRUE;
        //
        // Have an exception handler around this call just in case the
        // WINS or the system is really sick and Wrapup also generates
        // an exception. We are not bothered about performance at this
        // point.
        //
FUTURES("Check into restructuring the exception handlers in a better way")
try {
        WrapUp(GetExceptionCode(), TRUE);
}
except (EXCEPTION_EXECUTE_HANDLER) {
         DBGPRINTEXC("WinsMain");
 }
        ExitCode        = GetExceptionCode();

        WINSEVT_LOG_M(ExitCode, WINS_EVT_ABNORMAL_SHUTDOWN);
  }

#ifndef WINS_INTERACTIVE

    //
    // If it is not one of WINS specific codes, it may be a WIN32 api
    // or NTstatus codes.  Just in case it is an NTStatus codes, convert
    // it to a wins32 code since that is what the Service Controller likes.
    //
    if ((ExitCode & WINS_FIRST_ERR_STATUS) != WINS_FIRST_ERR_STATUS)
    {
        ExitCode = RtlNtStatusToDosError((NTSTATUS)ExitCode);
        ServiceStatus.dwWin32ExitCode = ExitCode;
        ServiceStatus.dwServiceSpecificExitCode = 0;
    }
    else
    {
        ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ServiceStatus.dwServiceSpecificExitCode = ExitCode;
    }
    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    ServiceStatus.dwCurrentState                = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted            = 0;
    ServiceStatus.dwCheckPoint                  = 0;
    ServiceStatus.dwWaitHint                    = 0;

    UpdateStatus();
#endif

   DBGPRINT0(ERR, "WINS Server has terminated\n");
   return;
} // end of WinsMain()




STATUS
ProcessInit(
        VOID
)

/*++

Routine Description:

        This is the function that initializes the WINS.  It is executed in
        the main thread of the process

Arguments:
        None


Externals Used:
        None

Called by:
        WinsMain()

Comments:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
        DWORD NoOfThds;


        /*
         * Initialize the Critical Section used for name registrations and
         * refreshes
        */
        InitializeCriticalSection(&NmsNmhNamRegCrtSec);

        //
        // Initialize the critical section that protects the statistics
        // var. (WinsIntfStat).  This needs to be done here before any
        // thread is created because various threads call WinsIntfSetTime
        // which uses this critical section
        //
        InitializeCriticalSection(&WinsIntfCrtSec);
        InitializeCriticalSection(&WinsIntfPotentiallyLongCrtSec);
        InitializeCriticalSection(&WinsIntfNoOfUsersCrtSec);

#if  TEST_DATA > 0
        //
        // Set WinsDbg so that we don't miss any printfs until we read
        // the registry
        //
        WinsDbg = DBG_ERR | DBG_EXC | DBG_FLOW | DBG_DET | DBG_HEAP_CRDL |
                        DBG_HEAP_CNTRS;

        (VOID)DbgOpenFile(QUERY_FAIL_FILE, FALSE);
#endif
#if defined(DBGSVC) || defined(WINS_INTERACTIVE)
//#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
#ifdef DBG
        (VOID)time(&sDbgLastChkTime);
        (VOID)DbgOpenFile(WINSDBG_FILE, FALSE);
#endif
#endif
        //
        // Initialize the Counter that keeps track of the highest version
        // number registered by this server
        //
        WINS_ASSIGN_INT_TO_LI_M(NmsNmhMyMaxVersNo, 1);
        NmsRangeSize.QuadPart     = NMS_RANGE_SIZE;
        NmsHalfRangeSize.QuadPart = NMS_HW_SIZE;

        NmsVersNoToStartFromNextTime.QuadPart = LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
        NmsHighWaterMarkVersNo.QuadPart       = LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);

        //
        // The lowest version to start scavenging from
        //
        NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;

        //
        // Initialize the global var. to be used to increment/decrement the
        // above counter by 1.
        //
        WINS_ASSIGN_INT_TO_LI_M(NmsNmhIncNo, 1);

        /*
         * Create Memory Heaps used by the Name Space Manager
        */
        CreateMem();

         /*
         * Allocate a TLS index so that each thread can set and get
         * thread specific info
        */
        WinsTlsIndex = TlsAlloc();

        if (WinsTlsIndex == 0xFFFFFFFF)
        {
                DBGPRINT1(ERR,
                "Init: Unable to allocate TLS index. Error = (%d)\n",
                GetLastError()
                         );
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }

        //
        // Initialize the thread count to 1 (to account for this thread)
        //
        WinsThdPool.ThdCount = 1;


        //
        // Allocate an array of 100 slots to store version numbers
        //
        RplPullAllocVersNoArray( &pRplPullOwnerVersNo, RplPullMaxNoOfWins );

        //
        // Store local machine's ip address in NmsLocalAdd.  We need to
        // do this before calling WinsCnfInitConfig so that we can
        // make sure that this WINS is not listed as its own partner
        // in the registry
        //
        if (ECommGetMyAdd(&NmsLocalAdd) != WINS_SUCCESS)
        {
            WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_BAD_WINS_ADDRESS);
            return(WINS_FAILURE);
        }
        /*
         * Read the configuration information from the registry
         * into in-memory data structures
        */
        WinsCnfInitConfig();

     //   if (fWinsCnfInitStatePaused)
      //  {
       //     NtClose(WinsCnfNbtHandle);
       // }
        //
        // Get machine information
        //
        GetMachineInfo();

        //
        // Update Status
        //
        /*
         * Initialize the Database Manager
        */
        if (NmsDbInit() != WINS_SUCCESS)
        {
                return(WINS_FAILURE);
        }


#ifndef WINS_INTERACTIVE
        //
        // Though 3000 should be ok, let us be extra conservative and
        // specify 30000.  Actually, if DNS is down, it takes around
        // 35 secs for timeout (rpc over tcpip may result in query to
        // WINS if query WINS for resolution check box is checked). So,
        // let us add another 30 secs for that for a total of 60000
        // Throw in another 30 secs for good measure to arrive at a grand
        // total of 120 secs.
        //
        ServiceStatus.dwWaitHint                = 120000;
        ServiceStatus.dwCheckPoint++;
        UpdateStatus();   //inform the service control manager
#endif


        //
        // NOTE: The value of NmsNmhMyMaxVersNo may have been changed by
        // NmsDbInit()
        //

        // If we did not find the version counter value for next time in
        // the registry or if the high water mark is lower than our
        // max. version number, adjust it and the next time start version
        // number and write it to the registry (since we are about to start
        // the worker threads).
        //
        if (!fWinsCnfReadNextTimeVersNo || LiLtr(NmsHighWaterMarkVersNo,
                                                    NmsNmhMyMaxVersNo))
        {
             NmsVersNoToStartFromNextTime.QuadPart =
                         LiAdd(NmsNmhMyMaxVersNo, NmsRangeSize);
             NmsHighWaterMarkVersNo.QuadPart       =
                         LiAdd(NmsNmhMyMaxVersNo, NmsHalfRangeSize);

             WinsCnfWriteReg(&fWinsCnfReadNextTimeVersNo);
        }

        /*
        *        Create the two event variables used for termination
        */

        //
        // NmsTermEvt is signaled by this main thread to signal all those
        // WINS threads that have db session to wrap up their sessions and
        // terminate
        //
        WinsMscCreateEvt(
                        TEXT("WinsTermEvt"),
                        TRUE,                //Manual Reset
                        &NmsTermEvt
                        );

        /*
         * NmsMainTermEvt -- This event is signaled by the service controller
         * or by another thread in the WINS server to request termination.
        */
        WinsMscCreateEvt(
                        TEXT("WinsMainTermEvt"),
                        FALSE,                //Auto Reset
                        &NmsMainTermEvt
                        );


        /*
         *  Do Static Initialization if required
        */
        if(WinsCnf.fStaticInit)
        {
                   //
                   // Do the initialization and deallocate the memory
                   //
                   if (WinsCnf.pStaticDataFile != NULL)
                   {
                         (VOID)WinsPrsDoStaticInit(
                                        WinsCnf.pStaticDataFile,
                                        WinsCnf.NoOfDataFiles,
                                        TRUE            //do it asynchronously
                                              );
                          //
                          // No need to deallocate memory for data file.
                          // It should have been freed by WinsPrsDoStaticInit
                          //
                   }
        }
        /*
        * Create the nbt request thread pool
        */

        //
        // If the user has not specified the number of threads, use the
        // processor count to determine the same, else use the value given
        // by user.
        //
        if (WinsCnf.MaxNoOfWrkThds == 0)
        {
           NoOfThds = WinsCnf.NoOfProcessors + 1;
        }
        else
        {
           NoOfThds =  WinsCnf.MaxNoOfWrkThds == 1 ? 2 : WinsCnf.MaxNoOfWrkThds;
        }
        CreateNbtThdPool(
                         NoOfThds,
        //                WinsCnf.MaxNoOfWrkThds == 1 ? 2 : WinsCnf.MaxNoOfWrkThds,
                        //WINSTHD_DEF_NO_NBT_THDS,
                        NbtThdInitFn
                        );


        /*
         *Initialize the name challenge manager
        */
        NmsChlInit();


        /*
         * Initialize the Timer Manager
        */
        WinsTmmInit();

        /*
         *Initialize the Replicator. Initialize it before initializing
         * the comm threads or the rpc threads.  This is because, the
         * comm threads and the rpc threads can create the Push thread
         * if it is not-existent.  fRplPushThdExists is set to TRUE or
         * FALSE by this function without the protection of a critical
         * section
        */
        ERplInit();


        /*
         *Initialize the Comm. subsystem
        */
        ECommInit();

        /*
         * Initialize the scavenger code
        */
        NmsScvInit();

        /*
         * All threads have been created.
        */


// We can not mark state as steady state until all threads are in
// steady state
FUTURES("Mark state as STEADY STATE only after the above is true")
        //
        // Mark state as steady state.  This is actually a PSEUDO steady
        // state since all the threads may not have initialized yet. This
        // will however do for rpc threads that need to know whether the
        // critical sections have been initialized or not
        //

        //
        // NOTE: there is no need to enter a critical section here even
        // though there are other threads (rpc threads) reading this since
        // if they find the value to be anything other than RUNNING
        // they will return a failure which is ok for the minute time window
        // where concurrent write and reads are going on
        //
        WinsCnf.State_e = WINSCNF_E_RUNNING;

        //
        // Do all RPC related initialization.
        //
        if (InitializeRpc() == FALSE)
        {
                DBGPRINT0(ERR, "Init: Rpc not initialized properly. Is Rpc service up\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_RPC_NOT_INIT);
        }

        NmsDbCloseTables();

//#if 0
        //
        // End the Db Session
        //
        NmsDbEndSession();
        fNmsMainSessionActive = FALSE;
//#endif

#if 0
//
//        The following initializations are temporary for JimY
//
#define ALMOST_MAX        (0xFFFFFFF8)
        WinsIntfStat.Counters.NoOfUniqueReg =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfGroupReg  =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfUniqueRef =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfGroupRef =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfUniqueCnf =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfGroupCnf =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfSuccRel =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfFailRel  =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfSuccQueries =  ALMOST_MAX;
        WinsIntfStat.Counters.NoOfFailQueries =  ALMOST_MAX;
#endif
        //
        // Log an informational message
        //
        WinsIntfSetTime(NULL, WINSINTF_E_WINS_START);
        WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_WINS_OPERATIONAL);
        DBGPRINT0(DET, "WINS: Operational\n");
        return(WINS_SUCCESS);
}


VOID
ENmsHandleMsg(
        IN  PCOMM_HDL_T pDlgHdl,
        IN  MSG_T        pMsg,
        IN  MSG_LEN_T   MsgLen
        )

/*++

Routine Description:

  This function queues the message either on the nbt request queue or on
  the nbt response queue.


Arguments:

        pDlgHdl - Dialogue handle
        pMsg        - Ptr to message to process
        MsgLen        - Message length


Externals Used:
        None

Called by:
        ParseMsg in comm.c

Comments:
        None

Return Value:
        None
--*/

{

        DWORD fRsp;
        BYTE Opcode = *(pMsg + 2);
        STATUS RetStat;

        /*
        *  Check whether the message is a request or a response
        */
        fRsp = NMS_RESPONSE_MASK & Opcode;

        if (!fRsp)
        {

           if ((WinsCnf.State_e == WINSCNF_E_PAUSED)  || fWinsCnfInitStatePaused)
           {
              //
              // Don't even let the queries go through since
              // the InitTimePaused state is meant for building
              // up the db while the backup handles the load
              // This way clients time out and try the backup.
              // If we let queries through, clients may get
              // back -ve query responses and will not go to
              // the backup for the name resolution
              //
              ECommFreeBuff(pMsg);
              ECommEndDlg(pDlgHdl);
              return;
           }
           DBGPRINT0(FLOW,
              "ENmsHandleMsg: Listener thread: queuing a work item\n");
#if REG_N_QUERY_SEP > 0
           if (((NMS_OPCODE_MASK & Opcode) >> 3) == NMSMSGF_E_NAM_QUERY)
           {
              QueInsertNbtWrkItm(pDlgHdl, pMsg, MsgLen);
#ifdef WINSDBG
              sReqQ++;
#endif
           }
           else
           {
              RetStat = QueInsertOtherNbtWrkItm(pDlgHdl, pMsg, MsgLen);

#ifdef WINSDBG
              sRegReqQ++;
#endif
           }
#else
              QueInsertNbtWrkItm(pDlgHdl, pMsg, MsgLen);
              sReqQ++;
#endif
        }
        else
        {
           DBGPRINT0(FLOW,
                 "UDP listener thread: queuing a response work item\n");
           QueInsertChlRspWrkItm(pDlgHdl, pMsg, MsgLen);
#ifdef WINSDBG
           sRsp++;
#endif
        }

        return;
}



VOID
CreateMem(
        VOID
        )

/*++

Routine Description:

        This function creates the heap that is used for allocating work
        items for the NBT work queues.  It also creates a heap for general
        allocation.

Arguments:
        None


Externals Used:
        GenBuffHeapHdl, QueBuffHeapHdl


Return Value:
        None

Error Handling:

Called by:
        Init

Side Effects:

Comments:
        None
--*/

{

#ifdef WINSDBG
        InitializeCriticalSection(&NmsHeapCrtSec);
#endif
        /*
         * Create heap for general allocation of memory
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Gen. Buff Heap\n");
        GenBuffHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                GEN_INIT_BUFF_HEAP_SIZE
                );

        /*
         * Create heap for allocating nbt work items
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Que. Buff Heap\n");
        QueBuffHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                QUE_INIT_BUFF_HEAP_SIZE
                );

        /*
         * Create heap for  rpc use
        */
        DBGPRINT0(HEAP_CRDL, "CreateMem: Rpc. Buff Heap\n");
        NmsRpcHeapHdl = WinsMscHeapCreate(
                0,    /*to have mutual exclusion        */
                RPC_INIT_BUFF_HEAP_SIZE
                );


        //
        // Let us set the flag looked at by WrapUp()
        //
        sfHeapsCreated = TRUE;
        return;
}


STATUS
CreateNbtThdPool(
        IN  DWORD                    NoOfThds,
        IN  LPTHREAD_START_ROUTINE NbtThdInitFn
        )

/*++

Routine Description:
        This function creates the nbt request thread pool

Arguments:
        NoOfThds     -- No. of threads to create
        NbtThdInitFn -- Initialization function for the threads


Externals Used:
        QueNbtWrkQueHd, sNbtThdEvtHdlArray

Called by:
        Init

Comments:
        None

Return Value:

   Success status codes --  Function should never return for a normal
                            thread.  It returns WINS_SUCCESS for an
                            overload thread

   Error status codes   --  WINS_FATAL_ERR

--*/


{

        DWORD              i;                 //counter for the number of threads
        DWORD             Error;
        PLIST_ENTRY  pHead;

#if REG_N_QUERY_SEP > 0
        pHead = &QueOtherNbtWrkQueHd.Head;

        /*
         * Initialize the critical section that protects the
         * nbt req. queue
        */
        InitializeCriticalSection(&QueOtherNbtWrkQueHd.CrtSec);

        /*
        * Initialize the listhead for the nbt request queue
        */
        InitializeListHead(pHead);

        /*
        *  Create an auto-reset event for the nbt request queue
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &QueOtherNbtWrkQueHd.EvtHdl
                        );

#endif
        pHead = &QueNbtWrkQueHd.Head;

        /*
         * Initialize the critical section that protects the
         * nbt req. queue
        */
        InitializeCriticalSection(&QueNbtWrkQueHd.CrtSec);

        /*
        * Initialize the listhead for the nbt request queue
        */
        InitializeListHead(pHead);

        /*
        *  Create an auto-reset event for the nbt request queue
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &QueNbtWrkQueHd.EvtHdl
                        );

        /*
        *  Create an auto-reset event for the dynamic creation/deletion of
        *  Nbt threads.
        */
        WinsMscCreateEvt(
                        NULL,   //create without name
                        FALSE,  //auto-reset var.
                        &NmsCrDelNbtThdEvt
                        );

        /*
         *  Initialize the array of handles on which each nbt thread will
         *  wait.
        */
        sNbtThdEvtHdlArray[0]    =  QueNbtWrkQueHd.EvtHdl; //work queue event
                                                           //var
        sNbtThdEvtHdlArray[1]    =  NmsCrDelNbtThdEvt; //
        sNbtThdEvtHdlArray[2]    =  NmsTermEvt;             //termination event var
#if REG_N_QUERY_SEP > 0
        /*
         *  Initialize the array of handles on which each nbt reg. thread will
         *  wait.
        */
        sOtherNbtThdEvtHdlArray[0]  =  QueOtherNbtWrkQueHd.EvtHdl; //work queue event
                                                              //var
        sOtherNbtThdEvtHdlArray[1]  =  NmsTermEvt;     //termination event var
#endif

        /*
         * Create the nbt request handling threads
        */
        for (i=0; i < NoOfThds -1; i++)
        {

#if REG_N_QUERY_SEP > 0
                DBGPRINT1(DET, "CreateNbtThdPool: Creating query thread no (%d)\n", i);
#else
                DBGPRINT1(DET, "NbtThdInitFn: Creating worker thread no (%d)\n", i);
#endif
                /*
                  Create an NBT req thread
                */
                WinsThdPool.NbtReqThds[i].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        NbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[i].ThdId
                                        );


                if (NULL == WinsThdPool.NbtReqThds[i].ThdHdl)
                {
                        Error = GetLastError();
                        WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_WRK_THD);
                }
                else
                {
                    WinsThdPool.NbtReqThds[i].fTaken = TRUE;
                    NmsNoOfNbtThds++;
                }

        }

#if REG_N_QUERY_SEP > 0
        DBGPRINT1(DET, "NbtThdInitFn: Creating reg/rel thread no (%d)\n", i);
        /*
                  Create an NBT req thread
        */
        WinsThdPool.NbtReqThds[i].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        OtherNbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[i].ThdId
                                        );


        if (NULL == WinsThdPool.NbtReqThds[i].ThdHdl)
        {
                  Error = GetLastError();
                  WINSEVT_LOG_M(Error, WINS_EVT_CANT_CREATE_WRK_THD);
        }
        else
        {
                WinsThdPool.NbtReqThds[i].fTaken = TRUE;
                NmsNoOfNbtThds++;
        }
#endif
        /*
        * if no thread could be created, there is something really wrong
        */
        if (NmsNoOfNbtThds == 0)
        {
          WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT);
          return(WINS_FATAL_ERR);
        }
        WinsThdPool.ThdCount +=  NmsNoOfNbtThds;

        return(WINS_SUCCESS);
}



DWORD
NbtThdInitFn(
        IN  LPVOID pThreadParam
        )

/*++

Routine Description:

        This function is the startup function of threads created
        for the nbt request thread pool

Arguments:
        pThreadParam  - Input argument which if present indicates that this
                        is an overload thread


Externals Used:
        sNbtThdEvtHdlArray

Called by:
        CreateNbtThdPool
Comments:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{



        COMM_HDL_T                    DlgHdl;
        MSG_T                     pMsg;
        MSG_LEN_T                  MsgLen;
        PNBT_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;        //Index of hdl in hdl array
try {
        /*
         *  Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSNMH);
#if REG_N_QUERY_SEP > 0
        DBGMYNAME("Nbt Query Thread");
#else
        DBGMYNAME("Nbt Thread");
#endif

        //
        // The worker thread is more important that all other threads.
        //
        // Set the priority of this thread to one level above what it is
        // for WINS.
        //
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

        /*
         * if thread param is NON-NULL, then it means that this is
         * an overload thread
        */
        if (pThreadParam != NULL)
        {

           //
           //Exract the dlg handle, message and msglen from work item
           //
           pWrkItm = pThreadParam;

           DlgHdl = pWrkItm->DlgHdl;
           pMsg   = pWrkItm->pMsg;
           MsgLen = pWrkItm->MsgLen;

           /*
            *        process the request
           */
           NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                        );

           /*
            *        Loop until there are no more requests to process in
            *        the NBT queue.
           */
           while(TRUE)
           {

             if ( QueRemoveNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                )
             {
                break;
             }
             else
             {
                NmsDbOpenTables(WINS_E_NMSNMH);
                NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                                 );
                NmsDbCloseTables();
             }
          }
        }
        else // this is a normal thread
        {

LOOP:
  try {
          /*
           *loop forever
          */
          while(TRUE)
          {

            /*
             *        Block until signaled
            */
            WinsMscWaitUntilSignaled(
                sNbtThdEvtHdlArray,
                sizeof(sNbtThdEvtHdlArray)/sizeof(HANDLE),   //no of events
                                                             //in array
                &ArrInd,
                FALSE
                                    );


           if (ArrInd == 0)
           {
             /*
                Loop until there are no more requests to process in
                the NBT queue.
             */
             while(TRUE)
             {

                if (
                   QueRemoveNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                  )
                {
                    break;
                }
                else
                {
#ifdef WINSDBG
                    ++sReqDq;
#endif
//                    DBGPRINT1(SPEC, "Nms: Dequeued Name Query Request no = (%d)\n",
//                                        sReqDq);

                    DBGPRINT0(FLOW, "NBT thread: Dequeued a Request\n");
                    NmsDbOpenTables(WINS_E_NMSNMH);
                    NmsMsgfProcNbtReq(
                                &DlgHdl,
                                pMsg,
                                MsgLen
                                    );
                    NmsDbCloseTables();
                } // end of else
            } // end of while (TRUE)  for getting requests from the queue
          } // end of if (signaled for name request handling)
          else
          {
                //
                // If signaled for creating/deleting threads, do so
                //
                if (ArrInd == 1)
                {
                        CrDelNbtThd();
                }
                else
                {
                      //
                      //  If Array Index indicates termination event, terminate the
                      //  the thread
                      //
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
          }
         } // end of while (TRUE) (never ending loop)

 }  // end of inner try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINTEXC("NbtThdInitFn: Nbt Thread \n");

        //
        // If ExcCode indicates NBT_ERR, it could mean that
        // the main thread closed the netbt handle
        //
        if (ExcCode == WINS_EXC_NBT_ERR)
        {
               if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
               {
                  WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
               }
               else
               {
                  //if (WinsCnf.State_e != WINSCNF_E_PAUSED)
                  {
                       WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
                  }
               }
        }
        else
        {
           WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
        }
    }

        goto LOOP;
        } // end of else (this is a normal thread)
  } // end of outer try block

except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("NbtThdInitFn: Nbt Thread exiting abnormally\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_WRK_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit() results in an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }

        /*
         *Only an overload thread should reach this return
        */
        ASSERT(pThreadParam != NULL);
        WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        return(WINS_SUCCESS);
}
#if REG_N_QUERY_SEP > 0
DWORD
OtherNbtThdInitFn(
        IN  LPVOID pThreadParam
        )

/*++

Routine Description:

        This function is the startup function of threads created
        for the nbt request thread pool

Arguments:
        pThreadParam  - Input argument which if present indicates that this
                        is an overload thread


Externals Used:
        sNbtThdEvtHdlArray

Called by:
        CreateNbtThdPool
Comments:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{



        COMM_HDL_T                    DlgHdl;
        MSG_T                     pMsg;
        MSG_LEN_T                  MsgLen;
        PNBT_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;        //Index of hdl in hdl array
try {
        /*
         *  Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSNMH);
        DBGMYNAME("Nbt Reg Thread");

        //
        // The worker thread is more important that all other threads.
        //
        // Set the priority of this thread to one level above what it is
        // for WINS.
        //
//        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

        /*
         * if thread param is NON-NULL, then it means that this is
         * an overload thread
        */
        if (pThreadParam != NULL)
        {

           //
           //Exract the dlg handle, message and msglen from work item
           //
           pWrkItm = pThreadParam;

           DlgHdl = pWrkItm->DlgHdl;
           pMsg   = pWrkItm->pMsg;
           MsgLen = pWrkItm->MsgLen;

           /*
            *        process the request
           */
           NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                        );

           /*
            *        Loop until there are no more requests to process in
            *        the NBT queue.
           */
           while(TRUE)
           {

             if ( QueRemoveOtherNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                )
             {
                break;
             }
             else
             {
                NmsDbOpenTables(WINS_E_NMSNMH);
                NmsMsgfProcNbtReq(
                        &DlgHdl,
                        pMsg,
                        MsgLen
                                 );
                NmsDbCloseTables();
             }
          }
        }
        else // this is a normal thread
        {

LOOP:
  try {
          /*
           *loop forever
          */
          while(TRUE)
          {

            /*
             *        Block until signaled
            */
            WinsMscWaitUntilSignaled(
                sOtherNbtThdEvtHdlArray,
                sizeof(sOtherNbtThdEvtHdlArray)/sizeof(HANDLE),   //no of events
                                                             //in array
                &ArrInd,
                FALSE
                                    );


           if (ArrInd == 0)
           {
             /*
                Loop until there are no more requests to process in
                the NBT queue.
             */
             while(TRUE)
             {

                if (
                   QueRemoveOtherNbtWrkItm(
                        &DlgHdl,
                        &pMsg,
                        &MsgLen) == WINS_NO_REQ
                  )
                {
                    break;
                }
                else
                {
#ifdef WINSDBG
                    ++sRegReqDq;
#endif
//                    DBGPRINT1(SPEC, "Nms: Dequeued Name Reg/Rel Request no = (%d)\n",
//                                        sRegReqDq);

                    DBGPRINT0(FLOW, "NBT thread: Dequeued a Request\n");
                    NmsDbOpenTables(WINS_E_NMSNMH);
                    NmsMsgfProcNbtReq(
                                &DlgHdl,
                                pMsg,
                                MsgLen
                                    );
                    NmsDbCloseTables();
                } // end of else
            } // end of while (TRUE)  for getting requests from the queue
          } // end of if (signaled for name request handling)
          else
          {
                      //
                      //  If Array Index indicates termination event, terminate the
                      //  the thread
                      //
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
          }
         } // end of while (TRUE) (never ending loop)

 }  // end of inner try {..}
 except(EXCEPTION_EXECUTE_HANDLER) {

        DWORD ExcCode = GetExceptionCode();
        DBGPRINTEXC("OtherNbtThdInitFn: Nbt Reg/Rel Thread \n");

        //
        // If ExcCode indicates NBT_ERR, it could mean that
        // the main thread closed the netbt handle
        //
        if (ExcCode == WINS_EXC_NBT_ERR)
        {
               if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
               {
                  WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
               }
               else
               {
                  //if (WinsCnf.State_e != WINSCNF_E_PAUSED)
                  {
                       WINSEVT_LOG_M(ExcCode, WINS_EVT_WRK_EXC);
                  }
               }
        }
    }

        goto LOOP;
        } // end of else (this is a normal thread)
  } // end of outer try block

except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("NbtThdInitFn: Nbt Reg Thread exiting abnormally\n");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_WRK_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit() results in an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }

        /*
         *Only an overload thread should reach this return
        */
        ASSERT(pThreadParam != NULL);
        WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
        return(WINS_SUCCESS);
}

#endif

VOID
SignalWinsThds (
        VOID
        )

/*++

Routine Description:
        This function is called to terminate all threads in the process.


Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsMain()
Side Effects:

Comments:
        None
--*/
{
        time_t  ThdTermStartTime;
        DBGENTER("SignalWinsThds\n");

        //
        // Close the udp and tcp sockets
        //
        WinsCnf.State_e = WINSCNF_E_TERMINATING;

        //
        // Signal the manual-reset event variable NmsTermEvt.  This
        // should signal all threads that deal with the db
        //
        // makes sure to set the Nbt handle to NULL to avoid NtClose() to be called from ECommGetMyAdd
        // on a closed handle - this would result in raising an exception. (bug #86768)
        //
        NtClose(WinsCnfNbtHandle);
        WinsCnfNbtHandle = NULL;

        SetEvent(NmsTermEvt);

#if USENETBT == 0
        closesocket(CommUdpPortHandle);
#else
#if MCAST > 0
        CommSendMcastMsg(COMM_MCAST_WINS_DOWN);
        CommLeaveMcastGrp();
        closesocket(CommUdpPortHandle);
#endif
#endif
        //
        // Just in case we are terminating before having created the socket
        //
        if (CommTcpPortHandle != INVALID_SOCKET)
        {
           CommDisc(CommTcpPortHandle, FALSE);
        }

#define FIVE_MTS  300          //seconds
        //
        // This is an infinite loop.
        //
        (VOID)time(&ThdTermStartTime);
        while(TRUE)
        {
                time_t  CurrTime;
                DWORD   TrmThdCnt;
                //
                // If all threads that deal with the db have terminated
                // break out of the loop.
                //
                // It is possible that WINS is terminating during
                // initialization itself.  The Counter is incremented
                // in NmsDbThdInit() as each thread that has to deal with the
                // db engine initializes itself with it.
                //
                // If NmsTotalTrmThdCnt is <=1 break.  The count can go
                // lower than 1 if a db thread is terminating without having
                // incremented the above counter
                //
                EnterCriticalSection(&NmsTermCrtSec);
                TrmThdCnt = NmsTotalTrmThdCnt;
                LeaveCriticalSection(&NmsTermCrtSec);
                if ((TrmThdCnt <= 1) || fNmsAbruptTerm)
                {
                        break;
                }

                if (((CurrTime = time(NULL)) - ThdTermStartTime) < FIVE_MTS)
                {
                  //
                  // Wait until signaled (when all threads have or are about
                  // to terminate)
                  //
                  DBGPRINT1(DET, "SignalWinsThds: Thd count left (%d)\n", TrmThdCnt);
                  WinsMscWaitInfinite(NmsMainTermEvt);
                }
                else
                {
                     DBGPRINT1(ERR, "SignalWinsThds: Thd count left (%d); BREAKING OUT DUE TO ONE HOUR DELAY\n", TrmThdCnt);
                     WINSEVT_LOG_M(WINS_EVT_TERM_DUE_TIME_LMT, TrmThdCnt);
                     break;
                }
        }

        //
        // End the Db Session for this thread (main thread).
        //
        if (fNmsMainSessionActive)
        {
                NmsDbEndSession();
        }


FUTURES("Check state of WINS. If Rpc has been initialized or maybe even")
FUTURES("otherwise, call RpcEpUnRegister")


        DBGLEAVE("SignalWinsThds\n");
        return;
} // SignalWinsThds()



VOID
UpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the workstation service status with the Service
    Controller.

Arguments:

    None.

Return Value:

   None

--*/
{
    DWORD Status = NO_ERROR;


    if (ServiceStatusHdl == (SERVICE_STATUS_HANDLE) 0) {
        DBGPRINT0(ERR, "WINS Server: Cannot call SetServiceStatus, no status handle.\n");
        return;
    }

    if (! SetServiceStatus(ServiceStatusHdl, &ServiceStatus))
    {
        Status = GetLastError();
        DBGPRINT1(ERR, " WINS Server: SetServiceStatus error %lu\n", Status);
    }

    return;
} //UpdateStatus()



VOID
NmsServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Wins service.

Arguments:

    Opcode - Supplies a value which specifies the action for the
             service to perform.

Return Value:

    None.

--*/
{
    BOOL  fRet = FALSE;
//    EnterCriticalSection(&sSvcCtrlCrtSec);
try {
     switch (Opcode)
     {

        case SERVICE_CONTROL_SHUTDOWN:
              //
              // Backup can take a long time to execute.  If the service
              // controller kills us in the middle, it will mess up the
              // backup. So, let us disable it.
              //
              fsBackupOnTerm = FALSE;
        case SERVICE_CONTROL_STOP:

            DBGPRINT1(DET, "NmsServiceControlHandler: %s Signal received\n", Opcode == SERVICE_CONTROL_STOP ? "STOP" : "SHUTDOWN");
            if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
            {

                ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                ServiceStatus.dwCheckPoint   = 1;

                //
                // We keep a high wait time (5 mts) to take care of the
                // case where the replicator pull thread is busy trying
                // to set up communication with partners that are not
                // up.  Tcpip stack takes around a minute and a half to come
                // back in case of failure. Also, WINS might have to do
                // backup on termination.
                //
                ServiceStatus.dwWaitHint     = 300000;

                //
                // Send the status response.
                //
                UpdateStatus();


                WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_ORDERLY_SHUTDOWN);
                //
                // Signal the main thread
                //
                if (! SetEvent(NmsMainTermEvt))
                {

                   //
                   // Problem with setting event to terminate Workstation
                   // service.
                   //
                   DBGPRINT1(ERR,
               "Service Control Handler: Error signaling NmsMainTermEvt %lu\n",
                              GetLastError());

                }

                fRet = TRUE;
            }
            break;

        case SERVICE_CONTROL_PAUSE:
                if (WinsCnf.State_e == WINSCNF_E_RUNNING)
                {
                   DBGPRINT0(DET,"NmsServiceControlHandler: Pausing WINS\n");
                   WinsCnf.State_e =  WINSCNF_E_PAUSED;
//                   NtClose(WinsCnfNbtHandle);
//                   SndQueryToLocalNetbt();
                   //CommDisc(CommTcpPortHandle);
                }
                ServiceStatus.dwCurrentState = SERVICE_PAUSED;
                break;
        case SERVICE_CONTROL_CONTINUE:
                //
                // If the state is paused as a result of a pause from the sc
                // or if it is paused as a result of a registry directive,
                // we need to unpause it
                //
                if (
                       (WinsCnf.State_e == WINSCNF_E_PAUSED)
                                 ||
                       fWinsCnfInitStatePaused
                   )
                {

                   //
                   // If paused as a result of sc directive, open nbt since
                   // we closed it earlier.  Note: We can have a case where
                   // WINS was init time paused and then it got a pause from
                   // sc.  The state would have then changed from RUNNING to
                   // PAUSED.
                   //
#if 0
                   if (  WinsCnf.State_e == WINSCNF_E_PAUSED )
                   {
#endif
//                      CommOpenNbt();
#if 0
                   }
#endif
                   if (fWinsCnfInitStatePaused)
                   {
#if 0
                         CommOpenNbt();
                         CommCreateUdpThd();
#endif
                         fWinsCnfInitStatePaused = FALSE;
                   }
                  //  CommCreateUdpThd();
                   // CommCreateTcpThd();
                    WinsCnf.State_e = WINSCNF_E_RUNNING;
                    ServiceStatus.dwCurrentState = SERVICE_RUNNING;
                }
                break;
        case SERVICE_CONTROL_INTERROGATE:
            break;

        //
        // Service specific command
        //
        case WINS_ABRUPT_TERM:
                fNmsAbruptTerm = TRUE;

                //
                // Signal the main thread
                //
                if (! SetEvent(NmsMainTermEvt))
                {

                    //
                    // Problem with setting event to terminate Workstation
                    // service.
                    //
                    DBGPRINT1(ERR,
                "Service Control Handler: Error signaling NmsMainTermEvt for abrupt termination. Error = %lu\n",
                               GetLastError());

                }
                fRet = TRUE;
                break;

        default:
            break;
    }
}
  except(EXCEPTION_EXECUTE_HANDLER) {
           DBGPRINTEXC("NmsServiceControlHandler");
    }
//    LeaveCriticalSection(&sSvcCtrlCrtSec);

    if (!fRet)
    {
       //
       // Send the status response.
       //
       UpdateStatus();
    }
    return;
} //NmsServiceControlHandler


VOID
Reinit(
        WINSCNF_HDL_SIGNALED_E IndexOfHdlSignaled_e
  )

/*++

Routine Description:
        This function is called whenever the configuration of the WINS changes.

Arguments:
        None

Externals Used:
        WinsCnf

Return Value:
        None

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
--*/

{
        PWINSCNF_CNF_T        pWinsCnf;
        DBGENTER("Reinit\n");
try {

        if (IndexOfHdlSignaled_e == WINSCNF_E_WINS_HDL)
        {

                // request notification for any subsequent changes (we have
                // to request changes every time we get a notification if we
                // want notification of further changes).
                //
                WinsCnfAskToBeNotified(WINSCNF_E_WINS_KEY);

                //
                // Maybe a key has been created or deleted
                //
                WinsCnfOpenSubKeys();
                DBGLEAVE("Reinit\n");
                return;
        }
        //
        // If either PULL or PUSH information has changed, copy the
        // read the new data from the registry and inform the
        // replicator
        //
        if  (IndexOfHdlSignaled_e == WINSCNF_E_PARTNERS_HDL)
        {
                WinsCnfAskToBeNotified(WINSCNF_E_PARTNERS_KEY);

                //
                // Allocate the WinsCnf structure
                //
                WinsMscAlloc(
                        sizeof(WINSCNF_CNF_T),
                        &pWinsCnf
                    );

                //
                // Read the Partner information
                //
                WinsCnfReadPartnerInfo(pWinsCnf);

                //
                // Copy some (not all) of the configuration information into
                // the global WinsCnf structure. Sanity check of the
                // parameters will be done by this function and the
                // scavenger thread will be signaled if required.
                //
                WinsCnfCopyWinsCnf(WINS_E_RPLPULL, pWinsCnf);


                //
                // Send the reconfig message to the Pull thread
                //
                // Note: The PULL thread will deallocate memory pointed
                // to be pWinsCnf when it gets done
                //
                ERplInsertQue(
                        WINS_E_WINSCNF,
                        QUE_E_CMD_CONFIG,
                        NULL,                        //no dlg handle
                        NULL,                        //no msg
                        0,                        //msg len
                        pWinsCnf,                //client ctx
                        pWinsCnf->MagicNo
                            );
                DBGLEAVE("Reinit\n");
                return;
        }

        //
        // Parameters related to WINS's configuration (nothing to do with
        // how it interacts with its PARTNERS) have changed. Let us read
        // the new data and signal the scavenger thread
        //
        if (IndexOfHdlSignaled_e == WINSCNF_E_PARAMETERS_HDL)
        {
                WinsCnfAskToBeNotified(WINSCNF_E_PARAMETERS_KEY);

                //
                // Allocate the WinsCnf structure
                //
                WinsMscAlloc(
                        sizeof(WINSCNF_CNF_T),
                        &pWinsCnf
                    );


                //
                // Read the registry information
                //
                WinsCnfReadWinsInfo(pWinsCnf);

                //
                // Copy some of the information read in into WinsCnf.
                //
                WinsCnfCopyWinsCnf(WINS_E_WINSCNF, pWinsCnf);

                WinsWorkerThdUpd(WinsCnf.MaxNoOfWrkThds);
                //
                // If the flag for doing STATIC initialization is set, do it
                //
                if (pWinsCnf->fStaticInit)
                {
                   EnterCriticalSection(&WinsIntfCrtSec);
                   if (WinsIntfNoCncrntStaticInits >
                                WINSCNF_MAX_CNCRNT_STATIC_INITS)
                    {
                        DBGPRINT1(ERR, "Reinit: Too many concurrent STATIC initializations are going on (No = %d). Try later\n", WinsIntfNoCncrntStaticInits);
                         WINSEVT_LOG_M(WinsIntfNoCncrntStaticInits, WINS_EVT_TOO_MANY_STATIC_INITS);
                         LeaveCriticalSection(&WinsIntfCrtSec);
                    }
                    else
                    {
                         LeaveCriticalSection(&WinsIntfCrtSec);
                         (VOID)WinsPrsDoStaticInit(
                                        pWinsCnf->pStaticDataFile,
                                        pWinsCnf->NoOfDataFiles,
                                        TRUE            //do it asynchronously
                                                      );
                          //
                          // No need to deallocate memory for data file.
                          // It should have been freed by WinsPrsDoStaticInit
                          //
                    }
                }

                WinsMscDealloc(pWinsCnf);

                //
                // Signal the scavenger thread
                //
FUTURES("Signal the scavenger thread only if parameters relevant to")
FUTURES("scavenging have changed. This requires some if tests.")
                WinsMscSignalHdl(WinsCnf.CnfChgEvtHdl);

        }

        DBGLEAVE("Reinit\n");
        return;


} // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("Reinit")
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
        }

        DBGLEAVE("Reinit\n");
        return;
}




#define USE_TCP
#define AUTO_BIND


BOOL
InitializeRpc(
    VOID
    )

/*++

Routine Description:
        This function is called to do all initialization necessary for
        making WINS respond to rpc calls

Arguments:
        None

Externals Used:
        None


Return Value:

   Success status codes --  TRUE
   Error status codes   --  FALSE

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
        None
--*/

{
    RPC_STATUS                 RpcStatus;
    RPC_BINDING_VECTOR         *pRpcBindingVector;
    BOOL                       fBool;

    DBGENTER("InitializeRpc\n");

#ifdef USE_TCP
#ifdef AUTO_BIND

    //
    // Specify the protocol sequence to use
    //
    RpcStatus = RpcServerUseProtseq(
                    TEXT("ncacn_ip_tcp"),
                    NMS_MAX_RPC_CALLS,          //Max Calls
                    0);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Tcp/Ip = RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }
    RpcStatus = RpcServerUseProtseq(
                    TEXT("ncalrpc"),
                    NMS_MAX_RPC_CALLS,          //Max Calls
                    NULL);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Local Rpc - RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }
FUTURES("Take this out to save on threads.  Take it out when winsadmn is")
FUTURES("updated to work with just tcp/ip")
    //
    //  Use Named pipes
    //
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_np"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_NAMED_PIPE,
                    NULL//pSecurityDescriptor
                    );
    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "Error: InitializeRpc: Named Pipes - RpcServerUseProtSeq = %u\n", RpcStatus );
        return( FALSE );
    }

    //
    // Get the binding vector to use when registring self as end point
    //
    RpcStatus = RpcServerInqBindings(&pRpcBindingVector);

    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT1(ERR, "InitializeRpc: RpcServerInqBindings  = %u\n",
                                                RpcStatus);
        return( FALSE );
    }

    //
    // Register  end point(s) with the end point mapper
    // RpcEpRegister instead of RpcEpRegisterNoReplace is used since
    // it will replace a stale entry in the endpoint map database (left
    // if the server stops running without calling RpcEpUnregister()).
    // Using RpcEpRegister however means that only a single instance of
    // the WINS server will run on a host.  This is OK.
    //
    // A dynamic end-point expires when the server instance stops running.
    //
FUTURES("From 541 onwards, one can replace the last parameter - Null string")
FUTURES("by a NULL")
    RpcStatus = RpcEpRegister(
                    winsif_v1_0_s_ifspec,
                    pRpcBindingVector,
                    NULL,
                    TEXT("") );

    if ( RpcStatus != RPC_S_OK)
    {
        DBGPRINT1( ERR, "InitializeRpc: RpcEpRegister  = %u \n", RpcStatus);
        return( FALSE );
    }

    RpcStatus = RpcEpRegister(
                    winsi2_v1_0_s_ifspec,
                    pRpcBindingVector,
                    NULL,
                    TEXT("") );

    if ( RpcStatus != RPC_S_OK)
    {
        DBGPRINT1( ERR, "InitializeRpc: RpcEpRegister  = %u \n", RpcStatus);
        return( FALSE );
    }

#else  // AUTO_BIND
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_ip_tcp"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_SERVER_PORT,
                    0
                    );

#endif // AUTO_BIND

#else

    //
    //  Use Named pipes
    //
    RpcStatus = RpcServerUseProtseqEp(
                    TEXT("ncacn_np"),
                    NMS_MAX_RPC_CALLS, // maximum concurrent calls
                    WINS_NAMED_PIPE,
                    NULL
                    );

    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR, "InitializeRpc: Cannot set server\n");
        return(FALSE);
    }

#endif
    //
    // Free the security descriptor
    //
FUTURES("Currently there is a bug in rpc where they use the memory pointed")
FUTURES("by pSecurityDescriptor even after RpcServerUseProtSeq returns")
FUTURES("uncomment the following after the rpc bug is fixed - 4/7/94")
//    WinsMscDealloc(pSecurityDescriptor);
    //
    // Register Interface Handle
    //
    RpcStatus = RpcServerRegisterIf(winsif_v1_0_s_ifspec, 0, 0);
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR,  "InitializeRpc: Registration of winsif failed\n");
        return(FALSE);
    }
    RpcStatus = RpcServerRegisterIf(winsi2_v1_0_s_ifspec, 0, 0);
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR,  "InitializeRpc: Registration of winsi2 failed\n");
        return(FALSE);
    }

#if SECURITY > 0
    //
    // register authentication info (used for tcpip calls).
    //
    RpcStatus = RpcServerRegisterAuthInfo(
                        WINS_SERVER,
                        RPC_C_AUTHN_WINNT,
                        NULL,  //use default encryption key acquisition method
                        NULL   //since NULL was passed for function address
                               //above, NULL needs to be passed here for arg
                        );
    if (RpcStatus != RPC_S_OK)
    {
        DBGPRINT0(ERR, "InitializeRpc: Cannot Register authentication info\n");
        return(FALSE);
    }

    if (!InitSecurity())
    {
        return(FALSE);
    }
#endif

    //
    // WINS is ready to process RPC calls.  The maximum no. of RPC calls
    // parameter (2nd) should not be less than that specified than any of
    // the RPC calls before (RpcServerUseProtseq)
    //
    RpcStatus = RpcServerListen(
                        NMS_MIN_RPC_CALL_THDS,
                        NMS_MAX_RPC_CALLS,
                        TRUE
                               );
    if ( RpcStatus != RPC_S_OK )
    {
        DBGPRINT0(ERR, "InitializeRpc: Listen failed\n");
        return(FALSE);
    }


    DBGLEAVE("InitializeRpc\n");
    return(TRUE);

}
BOOL
SecurityAllowedPathAddWins()
{
#define  _WINS_CFG_KEY  TEXT("System\\CurrentControlSet\\Services\\Wins")
#define  SECURITY_ALLOWED_PATH_KEY TEXT("System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths")
#define  ALLOWED_PATHS TEXT("Machine")
    DWORD NTStatus, ValSize, ValTyp;
    LPBYTE  ValData;
    LPWSTR   NextPath;
    HKEY    hKey;

    // Now openup the WINS regkey for remote lookup by readonly operators
    NTStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    SECURITY_ALLOWED_PATH_KEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    if (!NT_SUCCESS(NTStatus)) {
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not open security allowed path key (%ld)\n", NTStatus);
        return FALSE;
    }
    ValSize = 0;
    NTStatus = RegQueryValueEx(
                    hKey,
                    ALLOWED_PATHS,
                    NULL,
                    &ValTyp,
                    NULL,
                    &ValSize
                    );
    if (!NT_SUCCESS(NTStatus) || ValTyp != REG_MULTI_SZ) {
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not query allowed path value (%ld)\n", NTStatus);
        return FALSE;
    }

try {
    ValSize += (wcslen(_WINS_CFG_KEY) + 1)* sizeof (WCHAR);
    WinsMscAlloc(ValSize , &ValData);
    NTStatus = RegQueryValueEx(
                    hKey,
                    ALLOWED_PATHS,
                    NULL,
                    &ValTyp,
                    ValData,
                    &ValSize
                    );
    if (!NT_SUCCESS(NTStatus)){
        DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not query allowed path value (%ld)\n", NTStatus);
        return FALSE;
    }


    // First check if WINS key is alreay there or not.
    NextPath = (WCHAR *)ValData;
    while (*NextPath != L'\0' && wcscmp(NextPath, _WINS_CFG_KEY)) {
        NextPath += (wcslen(NextPath) + 1);
    }
    if (*NextPath == L'\0') {
        // The WINS path is not there, so add it.
        wcscpy(NextPath, _WINS_CFG_KEY);
        NextPath += (wcslen(NextPath) + 1);
        *NextPath = L'\0';

        ValSize += (wcslen(_WINS_CFG_KEY) + 1)* sizeof (WCHAR);
        NTStatus = RegSetValueEx(
                        hKey,
                        ALLOWED_PATHS,
                        0,
                        ValTyp,
                        ValData,
                        ValSize
                        );
        if (!NT_SUCCESS(NTStatus)){
            DBGPRINT1(ERR, "SecurityAllowedPathAddWins: Could not set allowed path value (%ld)\n", NTStatus);
            return FALSE;
        }
    }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "SecurityAllowedPathAddWins: Got Exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
    }
    return TRUE;
}


BOOL
InitSecurity()
/*++

Routine Description:
        This function initializes the security descriptor and
        InfoMapping for use by rpc functions

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:


Comments:
        None
--*/

{
   NTSTATUS     NTStatus;
   DWORD        SidSize = 0;
   LPWSTR		ReferencedDomainName = NULL;
   DWORD		ReferencedDomainNameSize = 0;
   SID_NAME_USE	SidUse;
   DWORD        AceCount;
   BOOL         Result;
   NET_API_STATUS NetStatus;
    PSID         WinsSid = NULL;
    GROUP_INFO_1 WinsGroupInfo = {
            WinsMscGetString(WINS_USERS_GROUP_NAME),
            WinsMscGetString(WINS_USERS_GROUP_DESCRIPTION)};


   ACE_DATA        AceData[5] = {

#if 0
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS,     &LocalSid},
#endif
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasAccountOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WINS_CONTROL_ACCESS|WINS_QUERY_ACCESS,     &AliasSystemOpsSid},

       {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
              WINS_QUERY_ACCESS,     &WinsSid}

        };
     AceCount = 4;

    //
    // Create sids
    //
    NTStatus = NetpCreateWellKnownSids(NULL);
    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "InitSecurity: Could not create well known Sids. Status returned is (%d)\n", NTStatus);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_SEC_OBJ_ERR);
        return(FALSE);
    }


    try {
        // Add Wins ReadOnly operators group if it doesn't
        // exist
        NetStatus = NetLocalGroupAdd(
                        NULL,
                        1,
                        (LPVOID)&WinsGroupInfo,
                        NULL
                        );
        if (NERR_Success != NetStatus && NERR_GroupExists != NetStatus && ERROR_ALIAS_EXISTS != NetStatus) {
            DBGPRINT1(ERR, "InitSecurity: NetGroupAdd Failed %ld \n",NetStatus);
            WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
        }
        // Lookup SID for WINS read only operators group
        Result = LookupAccountName(
                    NULL,
                    WinsGroupInfo.grpi1_name,
                    WinsSid,
                    &SidSize,
                    ReferencedDomainName,
                    &ReferencedDomainNameSize,
                    &SidUse
                    );
        if (!Result && (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {
            WinsMscAlloc(SidSize, &WinsSid);
            WinsMscAlloc(ReferencedDomainNameSize*sizeof(WCHAR), &ReferencedDomainName);
            Result = LookupAccountName(
                        NULL,
                        WinsGroupInfo.grpi1_name,
                        WinsSid,
                        &SidSize,
                        ReferencedDomainName,
                        &ReferencedDomainNameSize,
                        &SidUse
                        );
            WinsMscDealloc(ReferencedDomainName);
            if (!Result) {
                DBGPRINT1(ERR, "InitSecurity: LookupAccountName Failed (%lx)\n", GetLastError());
                WinsMscDealloc(WinsSid);
                WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
            } else{
                AceCount++;
                DBGPRINT0(DET, "InitSecurity: LookupAccountName Succeded \n");
            }
        }else{
            DBGPRINT1(ERR, "InitSecurity: LookupAccountName Failed (%lx)\n", GetLastError());
            WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "InitSecurity: Got Exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_WINS_GRP_ERR);
    }



    //
    // Actually create the security descriptor.
    //

    NTStatus = NetpCreateSecurityObject(
               AceData,
               AceCount,
               NULL, //LocalSystemSid,
               NULL, //LocalSystemSid,
               &NmsInfoMapping,
               &pNmsSecurityDescriptor
                );

    if (!NT_SUCCESS(NTStatus))
    {
        DBGPRINT1(ERR, "InitSecurity: Could not create security descriptor. Status returned is (%d)\n", NTStatus);
        WINSEVT_LOG_M(NTStatus, WINS_EVT_SEC_OBJ_ERR);
        return(FALSE);
    }

    SecurityAllowedPathAddWins();
    return(TRUE);
}

VOID
WrapUp(
        DWORD ErrorCode,
        BOOL  fSvcSpecific
    )

/*++

Routine Description:
        This function is called to release all resources held by WINS

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:


Side Effects:

Comments:
        None
--*/

{
    static BOOL        sfFirstTime = TRUE;
    BOOL               fWinsIniting = FALSE;
    if (sfFirstTime)
    {
        sfFirstTime = FALSE;
    }
    else
    {
        return;
    }

    //
    // Set flag if we are terminating during initialization.  This is
    // to avoid doing "backup on termination".  Normally, we shouldn't
    // have to skip the NmsDbBackup() call (it should simply return with
    // success/error but this is another instance where we have to work
    // around jet bugs.  Currently (7/7/94) JetBackup simply hangs when
    // called without a valid wins.mdb file being there.
    //
    fWinsIniting = (WinsCnf.State_e == WINSCNF_E_INITING);

    /*
     *         signal all threads to do cleanup and exit gracefully
     *
    */
    SignalWinsThds();

#ifdef WINSDBG
    NmsPrintCtrs();
#endif


    //
    // Close all keys
    //
    WinsCnfCloseKeys();

    //
    // We are almost done.  Let us check if we were told to backup
    // on termination.
    //
    if (!fWinsIniting && (WinsCnf.pBackupDirPath != NULL) && WinsCnf.fDoBackupOnTerm && fsBackupOnTerm)
    {

#ifndef WINS_INTERACTIVE
           //
           // Backup can take a while, so let us make sure that the
           // service controller does not give up on us.
           //
           ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
           ServiceStatus.dwCheckPoint   = 1;

           ServiceStatus.dwWaitHint     = 120000;     // 2 mts
           UpdateStatus();
#endif
try {
           (VOID)NmsDbBackup(WinsCnf.pBackupDirPath, NMSDB_FULL_BACKUP);
}
except(EXCEPTION_EXECUTE_HANDLER)      {
           DBGPRINTEXC("WrapUp: During NmsDbBackup\n");
     }
    }
    /*
     *  Release all resources used by the system
     *  This will result in all data being flushed to disk
    */
    NmsDbRelRes();

#if defined(DBGSVC) || defined(WINS_INTERACTIVE)
//#if defined(DBGSVC) && !defined(WINS_INTERACTIVE)
       if (NmsDbgFileHdl != INVALID_HANDLE_VALUE)
       {
                (VOID)CloseHandle(NmsDbgFileHdl);
       }
#endif
#if TEST_DATA > 0
        if (NmsFileHdl != INVALID_HANDLE_VALUE)
        {
                if (!CloseHandle(NmsFileHdl))
                {
                        DBGPRINT0(ERR, "WrapUp: Could not close output file\n");
                }
        }
#endif

#ifndef WINS_INTERACTIVE
     //
     // Tell the service controller that we stopped
     //
     ServiceStatus.dwCurrentState        = SERVICE_STOPPED;
     ServiceStatus.dwControlsAccepted    = 0;
     ServiceStatus.dwCheckPoint          = 0;
     ServiceStatus.dwWaitHint            = 0;
     ServiceStatus.dwServiceSpecificExitCode = ErrorCode;
     ServiceStatus.dwWin32ExitCode       = fSvcSpecific ? ERROR_SERVICE_SPECIFIC_ERROR : ErrorCode;

     UpdateStatus();
#endif

#if 0
    //
    // Destroy heaps that were created
    //
    if (sfHeapsCreated)
    {
            WinsMscHeapDestroy(GenBuffHeapHdl);
            WinsMscHeapDestroy(QueBuffHeapHdl);
            WinsMscHeapDestroy(NmsRpcHeapHdl);
    }
#endif
    return;
}


VOID
CrDelNbtThd(
        VOID
        )

/*++

Routine Description:
        This function creates or deletes an Nbt threads.

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsUpdThdCnt
Side Effects:

Comments:
        None
--*/

{

        DWORD   ThdId = GetCurrentThreadId();

        EnterCriticalSection(&WinsCnfCnfCrtSec);

try {
        //
        // If the existing number of threads is less than that desired, create
        // the extra ones.
        //
        if (WinsIntfNoOfNbtThds > NmsNoOfNbtThds)
        {
                while(NmsNoOfNbtThds < WinsIntfNoOfNbtThds)
                {
                  //
                  // Create an Nbt Thread
                  //
                  WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdHdl = CreateThread(
                                        NULL,  /*def sec. attributes*/
                                        0,     /*use default stack size*/
                                        NbtThdInitFn,
                                        NULL,  /*no arg*/
                                        0,     /*run it now*/
                                        &WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdId
                                        );


                 WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_WRK_THD_CREATED);
                 if (NULL == WinsThdPool.NbtReqThds[NmsNoOfNbtThds].ThdHdl)
                 {
                        WINSEVT_LOG_M(GetLastError(),
                                        WINS_EVT_CANT_CREATE_WRK_THD);
                 }
                 WinsThdPool.NbtReqThds[NmsNoOfNbtThds++].fTaken = TRUE;
                 DBGPRINT1(FLOW, "CrDelNbtThd: Created thread no = (%d) \n",
                                NmsNoOfNbtThds);
                }
        }
        else
        {
                //
                // If the count is less, terminate self after doing some
                // cleanup. The count could be same too in case more than
                // one rpc thread were invoked concurrently to create/delete
                // the threads (i.e. a second rpc thread changes the count
                // prior to this NBT thread looking at it)
                //
                if (WinsIntfNoOfNbtThds < NmsNoOfNbtThds)
                {

                   DWORD   i, n;
                   DBGPRINT0(FLOW, "CrDelNbtThd: EXITING\n");

                   //
                   // Find the slot for this thread
                   //
                   for (i = 0; i < NmsNoOfNbtThds; i++)
                   {
                        if (WinsThdPool.NbtReqThds[i].ThdId == ThdId)
                        {
                                break;
                        }
                   }
                   ASSERT(i < NmsNoOfNbtThds);

                   //
                   // Shift all successive filled slots one place down
                   //
                   for (n = i, i = i + 1 ; i <= NmsNoOfNbtThds; n++, i++)
                   {
                        WinsThdPool.NbtReqThds[n] =
                                WinsThdPool.NbtReqThds[i];
                   }

                   //
                   // Mark the last slot as empty
                   //
                   WinsThdPool.NbtReqThds[NmsNoOfNbtThds].fTaken = FALSE;

                   NmsNoOfNbtThds--;

                   //
                   // If the count is still less, signal the event again
                   //
                   if (WinsIntfNoOfNbtThds < NmsNoOfNbtThds)
                   {
                        WinsMscSignalHdl(NmsCrDelNbtThdEvt);
                   }

                   LeaveCriticalSection(&WinsCnfCnfCrtSec);
                   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS,
                                        WINS_EVT_WRK_THD_TERMINATED);
                   WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                }
        }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("CrDelNbtThd");
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
        return;

}

VOID
GetMachineInfo(
 VOID
)

/*++

Routine Description:
    This function gets information about the machine WINS is running on

Arguments:
   NONE

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
#define LOW_MEM_SIZE           8000000
#define MEDIUM_MEM_SIZE        12000000
#define LARGE_MEM_SIZE         16000000
#define SMALL_DB_BUFFER_COUNT  200
#define MEDIUM_DB_BUFFER_COUNT 400
#define LARGE_DB_BUFFER_COUNT  500

    SYSTEM_INFO  SystemInfo;
    MEMORYSTATUS MemStatus;
    BYTE Tmp[30], Tmp2[30], Tmp3[30];
    WinsCnf.NoOfProcessors = 1;
    WinsCnf.NoOfDbBuffers  = SMALL_DB_BUFFER_COUNT;

    GetSystemInfo(&SystemInfo);
    if (SystemInfo.dwNumberOfProcessors != 0)
    {
      DBGPRINT1(DET, "GetMachineInfo: The number of processors are (%d)\n",
                               SystemInfo.dwNumberOfProcessors);


      WinsCnf.NoOfProcessors = SystemInfo.dwNumberOfProcessors;
    }

    GlobalMemoryStatus(&MemStatus);
    DBGPRINT2(DET, "Total Phys. Memory = (%d); Total Avail Phys Memory = (%d)\n",
                       MemStatus.dwTotalPhys, MemStatus.dwAvailPhys);

    if (WinsCnf.LogDetailedEvts > 0)
    {
       WinsEvtLogDetEvt(TRUE, WINS_EVT_MACHINE_INFO,
                            NULL, __LINE__, "sss", _itoa((int)SystemInfo.dwNumberOfProcessors, Tmp, 10),
                        _itoa((int)MemStatus.dwTotalPhys, Tmp2, 10),
                        _itoa((int)MemStatus.dwAvailPhys, Tmp3, 10));
    }

    if ((MemStatus.dwAvailPhys >= MEDIUM_MEM_SIZE) &&
            (MemStatus.dwAvailPhys < LARGE_MEM_SIZE))
    {
       WinsCnf.NoOfDbBuffers = MEDIUM_DB_BUFFER_COUNT;
    }
    else
    {
        if (MemStatus.dwAvailPhys >= LARGE_MEM_SIZE)
        {
            WinsCnf.NoOfDbBuffers = LARGE_DB_BUFFER_COUNT;
        }
        else
        {
            WinsCnf.NoOfDbBuffers = SMALL_DB_BUFFER_COUNT;
        }
    }
    return;

}

VOID
ENmsWinsUpdateStatus(
  DWORD MSecsToWait
 )
{
#ifndef WINS_INTERACTIVE
        ServiceStatus.dwWaitHint                = MSecsToWait;
        ServiceStatus.dwCheckPoint++;
        UpdateStatus();   //inform the service control manager
#endif
        return;
}

#if 0
//dummy function for testing comsys and queuing/dequeing code
STATUS
NmsMsgfProcNbtReq(
        PCOMM_HDL_T        pDlgHdl,
        MSG_T                pMsg,
        MSG_LEN_T        MsgLen
        )
{
        printf("NBT thread: Received message\n");
        return(WINS_SUCCESS);
}
#endif
#if TEST_DATA > 0 || defined(DBGSVC)
BOOL
DbgOpenFile(
        LPTSTR pFileNm,
        BOOL   fReopen
        )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
    NmsChkDbgFileSize
Side Effects:

Comments:
	Don't use DBGPRINTF in this function, else stack overflow would result.
--*/

{
          SECURITY_ATTRIBUTES        SecAtt;
          DWORD                      HowToCreate;
          HANDLE                     *pTmpHdl;
          int             BytesWritten;
          char str[200];

          SecAtt.nLength              = sizeof(SecAtt);
          SecAtt.lpSecurityDescriptor = NULL;  //use default security descriptor
          SecAtt.bInheritHandle       = FALSE; //actually don't care

          if (!lstrcmp(pFileNm, WINSDBG_FILE))
          {
                HowToCreate =  CREATE_ALWAYS;
                pTmpHdl     =  &NmsDbgFileHdl;
                if (fReopen)
                {
                    if (!DeleteFile(WINSDBG_FILE_BK))
                    {
                       DWORD Error;
                       Error = GetLastError();
                       if (Error != ERROR_FILE_NOT_FOUND)
                       {
                           IF_DBG(ERR)
                           {
                             sprintf(str, "DbgOpenFile: Could not delete the backup file. Error = (%d).  Dbg file will not be truncated\n", Error);
                             WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
                           }
                            WinsEvtLogDetEvt(TRUE, WINS_EVT_COULD_NOT_DELETE_FILE,
                            TEXT("nms.c"), __LINE__, "ud", WINSDBG_FILE_BK, Error);
                            return(FALSE);

                       }
                   }
                   //--ft: fix #20801: don't use NmsDbgFileHdl once the handle is closed
                   if (NmsDbgFileHdl != NULL)
                   {
                       CloseHandle(NmsDbgFileHdl);
                       NmsDbgFileHdl = NULL;
                       if (!MoveFile(WINSDBG_FILE, WINSDBG_FILE_BK))
                           return (FALSE);
                   }

               }
          }
          else
          {
                HowToCreate = TRUNCATE_EXISTING;
                pTmpHdl =  &NmsFileHdl;               //for wins.rec
          }

          //
          // Open the file for reading and position self to start of the
          // file
          //
          *pTmpHdl = CreateFile(
                        pFileNm,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        &SecAtt,
                        HowToCreate,
                        FILE_ATTRIBUTE_NORMAL,
                        0                        //ignored ?? check
                       );

          if (*pTmpHdl == INVALID_HANDLE_VALUE)
          {

#ifndef UNICODE
               IF_DBG(ERR)
               {
                    sprintf(str, "DbgOpen: Could not open %s (Error = %d)\n", pFileNm, GetLastError());
                    WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
               }
#else
#ifdef WINSDBG
                IF_DBG(ERR)
                {
                  wprintf(L"DbgOpen: Could not open %s (Error = %d)\n", pFileNm, GetLastError());
                }
#endif
#endif
                return(FALSE);
          }
          return(TRUE);
}


#define LIMIT_OPEN_FAILURES  3
#if defined(DBGSVC)
VOID
NmsChkDbgFileSz(
    VOID
    )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
    NOTE NOTE:  Do not put a DBGPRINT statement inside this function, otherwise
                infinite recursion will occur.	
--*/

{
       DWORD           FileSize;
       time_t          CurrTime;
       BOOL            fOpened = FALSE;
       static DWORD    sFailureNo = 0;
       int             BytesWritten;
       char str[200];

       return;
       //
       // We check every half hour.  If the size has become more than
       // that allowed, move wins.dbg to wins.bak and reopen it
       //
       if (time(&CurrTime) > (sDbgLastChkTime + DBG_TIME_INTVL_FOR_CHK))
       {

          //
          // Is the log file too big?
          //
          EnterCriticalSection(&sDbgCrtSec);
try {
          IF_DBG(DET)
          {
              sprintf(str, "NmsChkDbgFileSz: Getting File Size\n");
              WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
          }
          FileSize = GetFileSize( NmsDbgFileHdl, NULL );
          if ( FileSize == 0xFFFFFFFF )
          {
             IF_DBG(ERR)
             {
              sprintf(str, "NmsChkDbgFileSize: Cannot GetFileSize %ld\n", GetLastError() );
              WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
             }
             return;
          }
          else
          {
            if ( FileSize > DBG_FILE_MAX_SIZE )
            {
               IF_DBG(ERR)
               {
                 sprintf(str, "NmsChkDbgFileSz: REOPEN A NEW DEBUG FILE\n");
                 WriteFile(NmsDbgFileHdl, str, strlen(str), &BytesWritten, NULL);
               }
               fOpened = DbgOpenFile( WINSDBG_FILE, TRUE );
            }
          }
          //
          // if the new file could not be opened (it could be because another
          // thread was writing to it), then we want to retry again (upto
          // a certain limit)
          //
          //
          if (fOpened)
          {
             sFailureNo = 0;
             sDbgLastChkTime = CurrTime;
          }
          else
          {
               if (++sFailureNo > LIMIT_OPEN_FAILURES)
               {
                  sFailureNo = 0;
                  sDbgLastChkTime = CurrTime;
               }
          }
}
except(EXCEPTION_EXECUTE_HANDLER) {

 }
          LeaveCriticalSection(&sDbgCrtSec);
      }

      return;
}

#endif
#endif

#if 0
VOID
SndQueryToLocalNetbt(
 VOID
)

/*++

Routine Description:
    This function sends a garbage name to local NETBT to unblock the
    MonUdp thread

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
#define     WINS_INTERNAL_MSG      "WINSMSGTOUNPAUSE"  //should be >= 16 bytes

  BYTE Buff[COMM_DATAGRAM_SIZE];
  DWORD MsgLen;
  struct sockaddr_in Dest;
  DWORD BytesSent;

  DBGLEAVE("SndQueryToLocalNetbt\n");

  Dest.sin_family      = CommNtfSockAdd.sin_family;
  Dest.sin_port        = htons(WINS_NBT_PORT);
  Dest.sin_addr.s_addr = htonl(NmsLocalAdd.Add.IPAdd);

  //
  // Format a name query message
  //
  NmsMsgfFrmNamQueryReq(
            WINS_MAXIMUM_TRANSACTION_ID + 1,   //use netbt. trans id.
            Buff,
            &MsgLen,
            WINS_INTERNAL_MSG,
            sizeof(WINS_INTERNAL_MSG)
            );


  //
  // Send it to local NETBT
  //

  BytesSent = sendto(
                       CommUdpPortHandle,
                       Buff,
                       MsgLen,
                       0,
                       (struct sockaddr *)&Dest,
                       sizeof(struct sockaddr)
                    );

  if ((BytesSent == SOCKET_ERROR) || (BytesSent != MsgLen))
  {
        DBGPRINT1(ERR, "SendQueryToLocalNetbt: Error from sendto is (%d)\n",
                             GetLastError());
  }

  DBGLEAVE("SndQueryToLocalNetbt\n");
  return;
}
#endif

#ifdef WINSDBG
VOID
NmsPrintCtrs(
 VOID
 )
{
static LPBYTE pTypeOfUpd[2] = {"INSERT", "REPLACE"};
static LPBYTE pTypeOfRec[4] = {"UNIQUE", "NORM GRP", "SPEC GRP", "MH"};
static LPBYTE pStateOfRec[3] = {"ACTIVE", "RELEASE", "TOMBSTONE"};
static LPBYTE pIndexUpd[2] = {"REFRESH", "UPDATE"};
DWORD h, i,j,k,n;
LPDWORD pNoOfUpd;
DWORD   TotalUpd, GTotalUpd = 0;
DWORD   TotalIndexUpd, GTotalIndexUpd = 0;
 BOOL   fDef = FALSE;
#if 0
//
// better for this to be on the stack than as static storage.
//
struct _NMS_CTRS_T {
              LPSTR  pText;
              DWORD  Value;
             } NmsCtrs[] = {
                      "# Udp Alloc",   NmsUdpHeapAlloc,
                      "# Udp Free",    NmsUdpHeapFree,
                      "# Gen Alloc",   NmsGenHeapAlloc,
                      "# Gen Free",    NmsGenHeapFree,
                      "# Udp Dlg Alloc",   NmsUdpDlgHeapAlloc,
                      "# Udp Dlg Free",    NmsUdpDlgHeapFree,
                      "# Assoc Alloc", NmsAssocHeapAlloc,
                      "# Assoc Free",  NmsAssocHeapFree,
                      "# Chl Alloc",   NmsChlHeapAlloc,
                      "# Chl Free",    NmsChlHeapFree,
                      "# Que Alloc",   NmsQueHeapAlloc,
                      "# Que Free",    NmsQueHeapFree,
                      "# RplWrkItm Alloc",   NmsRplWrkItmHeapAlloc,
                      "# RplWrkItm Free",    NmsRplWrkItmHeapFree,
                      "# Tmm Alloc",   NmsTmmHeapAlloc,
                      "# Tmm Free",    NmsTmmHeapFree,
                      "# Catch All Alloc",   NmsCatchAllHeapAlloc,
                      "# Catch All Free",    NmsCatchAllHeapFree,
                      "# Dlg Alloc",   NmsDlgHeapAlloc,
                      "# Dlg Free",    NmsDlgHeapFree,
                      "# Tcp Msg Alloc",   NmsTcpMsgHeapAlloc,
                      "# Tcp Msg Free",    NmsTcpMsgHeapFree,
                      "# Rpc Alloc",   NmsRpcHeapAlloc,
                      "# Rpc Free",    NmsRpcHeapFree,
                      "# Heap Allocs for List",    NmsHeapAllocForList,
                      "# Heap Creates",    NmsHeapCreate,
                      "# Heap Destroy",    NmsHeapDestroy,
                      "# Dgrms Recd",    CommNoOfDgrms,
                      "# Repeat Dgrms Recd",   CommNoOfRepeatDgrms,

                      "# of Chl req. queued by Nbt", NmsChlNoOfReqNbt,
                      "# of Chl req. queued by Rpl", NmsChlNoOfReqRpl,
                      "# Dequeued Chl req", NmsChlNoReqDequeued,
                      "# of Queued Chl req at Hd. of List", NmsChlNoReqAtHdOfList,
                      "# of Dequeud Chl req with no rsp", NmsChlNoNoRsp,
                      "# of Dequeud inv. resp", NmsChlNoInvRsp,
                      "# of Dequeued Chl rsp", NmsChlNoRspDequeued,
#if REG_N_QUERY_SEP > 0
                      "# of reg requests queued by udp thread", sRegReqQ,
                      "# of reg/ref/rel requests DROPPED by udp thread", NmsRegReqQDropped,
                      "# of query requests queued by udp thread", sReqQ,
                      "# of chl. responses queued by udp thread", sRsp,
                      "# of reg req dequeued by worker threads", sRegReqDq,
                      "# of query requests dequeued by worker threads",  sReqDq,
                      "# of tcp connections",  CommConnCount,
                      "# chl. Responses dropped:", NmsChlNoRspDropped,
#else
                      "# of requests deqeued by worker threads", sReqDq,
                      "# Responses dropped: (%d)\n",  NmsChlNoRspDropped,
#endif
                      "# of Nmh Updates", NmsNmhUpd,
                      "# of Chl Updates", NmsChlUpd,
                      "# of Scv Updates", NmsScvUpd,
                      "# of Rpl Updates", NmsRplUpd,
                      "# of Rpc Updates", NmsRpcUpd,
                      "# of Other Updates", NmsOthUpd
                     };

     DWORD i;
     struct _NMS_CTRS_T *pNmsCtrs = NmsCtrs;
     DBGPRINT0(HEAP_CNTRS, "----------Counters--------------------\n\n");
     DBGPRINT0(HEAP_CNTRS, "WrapUp Summary\n\n");
     for (i = 0; i < sizeof(NmsCtrs)/sizeof(struct _NMS_CTRS_T); pNmsCtrs++, i++)
     {
          DBGPRINT2(HEAP_CNTRS, "\t%s, %d\n",
                            pNmsCtrs->pText,
                            pNmsCtrs->Value
                   );

     }

#endif
     DBGPRINT4(HEAP_CNTRS, "WrapUp Summary\n\
\t# Udp Alloc/Free:          (%d/%d)\n  \
\t# Gen Alloc/Free:          (%d/%d)\n",
        NmsUdpHeapAlloc, NmsUdpHeapFree, NmsGenHeapAlloc, NmsGenHeapFree);

    DBGPRINT2(HEAP_CNTRS, "\
\t# Udp Dlg Alloc/Free:          (%d/%d)\n",
        NmsUdpDlgHeapAlloc, NmsUdpDlgHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Chl Alloc/Free:          (%d/%d)\n  \
\t# Assoc Alloc/Free:          (%d/%d)\n",
        NmsChlHeapAlloc, NmsChlHeapFree,NmsAssocHeapAlloc, NmsAssocHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Que Alloc/Free:          (%d/%d)\n  \
\t# RplWrkItm Alloc/Free:          (%d/%d)\n",
      NmsQueHeapAlloc, NmsQueHeapFree,
       NmsRplWrkItmHeapAlloc, NmsRplWrkItmHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Tmm Alloc/Free:          (%d/%d)\n\
\t# Catch All Alloc/Free:          (%d/%d)\n",
    NmsTmmHeapAlloc, NmsTmmHeapFree,NmsCatchAllHeapAlloc, NmsCatchAllHeapFree);

    DBGPRINT4(HEAP_CNTRS, "\
\t# Dlg Alloc/Free:          (%d/%d)\n\
\t# Tcp Msg Alloc/Free:      (%d/%d)\n",
    NmsDlgHeapAlloc, NmsDlgHeapFree,
    NmsTcpMsgHeapAlloc, NmsTcpMsgHeapFree);

    DBGPRINT2(HEAP_CNTRS, "\
\t# Rpc Alloc/Free:          (%d/%d)\n",
    NmsRpcHeapAlloc, NmsRpcHeapFree);

    DBGPRINT3(HEAP_CNTRS, "\n\n \
\t# of Heap Allocs for List = (%d)\n \
\t# of Heap Creates = (%d)\n \
\t# of Heap Destroys = (%d)\n",
                NmsHeapAllocForList, NmsHeapCreate, NmsHeapDestroy);

     DBGPRINT2(HEAP_CNTRS, "\nOther counters\n\n\
\t# of Dgrms recd\t(%d)\n\
\t# of repeat dgrms recd\t(%d)\n",
        CommNoOfDgrms,
        CommNoOfRepeatDgrms);

     DBGPRINT4(HEAP_CNTRS, "\
\t# of Chl req. queued by Nbt and Rpl(%d, %d)/Dequeued Chl req\t(%d)\n\
\t# of Queued Chl req at Hd. of List\t(%d)\n",
        NmsChlNoOfReqNbt, NmsChlNoOfReqRpl,
        NmsChlNoReqDequeued,
        NmsChlNoReqAtHdOfList);

     DBGPRINT3(HEAP_CNTRS, "\
\t# of Dequeued Chl req with no rsp\t(%d)\n\
\t# of Dequeud inv. resp\t(%d)\n\
\t# of Dequeued Chl rsp\t(%d)\n",
        NmsChlNoNoRsp,
        NmsChlNoInvRsp,
        NmsChlNoRspDequeued);



#if REG_N_QUERY_SEP > 0
     DBGPRINT3(HEAP_CNTRS, "   \
\t# of reg requests queued by udp thread       (%d)\n\
\t# of query requests queued by udp thread       (%d)\n\
\t# of chl. responses queued by udp thread       (%d)\n",
 sRegReqQ, sReqQ, sRsp);

     DBGPRINT4(HEAP_CNTRS, "   \
\t# of reg requests dequeued by worker threads       (%d)\n\
\t# of query requests dequeued by worker threads       (%d)\n\
\t# of tcp connections  (%d)\n\
\t# chl. Responses dropped: (%d)\n", sRegReqDq, sReqDq, CommConnCount, NmsChlNoRspDropped);


#else
     DBGPRINT2(HEAP_CNTRS, "   \
\t# of requests deqeued by worker threads       (%d)\n\
\t# Responses dropped: (%d)\n", sReqDq, NmsChlNoRspDropped);
#endif

    DBGPRINT0(UPD_CNTRS, "---UPDATE COUNTERS SUMMARY------\n");
#if 0
    DBGPRINT5(UPD_CNTRS, " \
\t# of nmh upd     (%d)\n\
\t# of nmh rel upd     (%d)\n\
\t# of chl upd     (%d)\n\
\t# of scv upd     (%d)\n\
\t# of rpl upd     (%d)\n", NmsNmhUpd, NmsNmhRelUpd, NmsChlUpd,NmsScvUpd,NmsRplUpd);

    DBGPRINT2(UPD_CNTRS, " \
\t# of rpc upd     (%d)\n\
\t# of other upd     (%d)\n", NmsRpcUpd, NmsOthUpd);

    DBGPRINT5(UPD_CNTRS, " \
\t# of nmh grp upd     (%d)\n\
\t# of nmh grp rel upd     (%d)\n\
\t# of chl grp upd     (%d)\n\
\t# of scv grp upd     (%d)\n\
\t# of rpl grp upd     (%d)\n", NmsNmhGUpd, NmsNmhRelGUpd, NmsChlGUpd,NmsScvGUpd,NmsRplGUpd);

    DBGPRINT2(UPD_CNTRS, " \
\t# of rpc grp upd     (%d)\n\
\t# of other grp upd     (%d)\n", NmsRpcGUpd, NmsOthGUpd);
#endif

    for (n=0; n<WINS_NO_OF_CLIENTS; n++)
    {
      switch(n)
      {
         case(WINS_E_NMSNMH):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSNMH counters\n");
                      break;
         case(WINS_E_NMSSCV):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSSCV counters\n");
                      break;

         case(WINS_E_NMSCHL):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "NMSCHL counters\n");
                      break;
         case(WINS_E_RPLPULL):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "RPLPULL counters\n");
                      break;
         case(WINS_E_WINSRPC):
                     DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
                      DBGPRINT0(UPD_CNTRS, "WINSRPC counters\n");
                      break;
         default:
                      fDef = TRUE;
                      break;
      }
      if (fDef)
      {
         fDef = FALSE;
         continue;
      }
      TotalUpd = 0;
      TotalIndexUpd = 0;
      for (j=0; j<2; j++)
      {
         for (k=0;k<4;k++)
         {
           for(i=0;i<3;i++)
           {
              for(h=0;h<2;h++)
              {
               pNoOfUpd = &NmsUpdCtrs[n][j][k][i][h];
               if (*pNoOfUpd != 0)
               {
                 DBGPRINT4(UPD_CNTRS, "%s - %s - %s - %s\t", pIndexUpd[h], pTypeOfUpd[j], pTypeOfRec[k], pStateOfRec[i]);
                 DBGPRINT1(UPD_CNTRS, "%d\n", *pNoOfUpd);
                 if (h==1)
                 {
                   TotalIndexUpd += *pNoOfUpd;
                   GTotalIndexUpd += *pNoOfUpd;
                 }
                 TotalUpd += *pNoOfUpd;
                 GTotalUpd += *pNoOfUpd;
               }
             }
          }
        }
      }
      DBGPRINT1(UPD_CNTRS, "TOTAL INDEX UPDATES = (%d)\n",  TotalIndexUpd);
      DBGPRINT1(UPD_CNTRS, "TOTAL UPDATES = (%d)\n",  TotalUpd);
    }
    DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
    DBGPRINT1(UPD_CNTRS, "GRAND TOTAL INDEX UPDATES = (%d)\n",  GTotalIndexUpd);
    DBGPRINT1(UPD_CNTRS, "GRAND TOTAL UPDATES = (%d)\n",  GTotalUpd);
    DBGPRINT0(UPD_CNTRS, "-------------------------------------\n");
    DBGPRINT5(UPD_CNTRS, "\
\t# of AddVersReq     (%d)\n\
\t# of SndEntReq      (%d)\n\
\t# of UpdNtfReq      (%d)\n\
\t# of UpdVerfsReq    (%d)\n\
\t# of InvReq      (%d)\n",
                 NmsCtrs.RplPushCtrs.NoAddVersReq,
                 NmsCtrs.RplPushCtrs.NoSndEntReq,
                 NmsCtrs.RplPushCtrs.NoUpdNtfReq,
                 NmsCtrs.RplPushCtrs.NoUpdVersReq,
                 NmsCtrs.RplPushCtrs.NoInvReq );

    DBGPRINT0(UPD_CNTRS, "---UPDATE COUNTERS SUMMARY------\n");

    DBGPRINT0(HEAP_CNTRS, "----------Counters Summary End--------------\n\n");

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nmschl.c ===
/*+

Copyright (c) 1990  Microsoft Corporation

Module Name:
	nmschl.c

Abstract:
	This module contains the name challenge functions


Functions:

	NmsChlInit
	NmsChlHdlNamReg
	ChlThdInitFn
	HandleWrkItm
	WaitForRsp
	ProcRsp
	ChlUpdateDb
	InfRemWins


Portability:

	This module is portable

Author:

	Pradeep Bahl (PradeepB)  	Jan-1993

Revision History:

	Modification date	Person		Description of modification
        -----------------	-------		----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsque.h"
#include "comm.h"
#include "winsthd.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "nmsnmh.h"
#include "nmschl.h"
#include "nmsmsgf.h"
#include "rplmsgf.h"


/*
 *	Local Macro Declarations
*/


//
// Computation of the time it can take for a WINS to conduct a challenge
// (in msecs)
//
#define WACK_TTL			(((1 << WinsCnf.MaxNoOfRetries) * \
					 WinsCnf.RetryInterval) + \
					WAIT_PAD)

//
// WAIT_PAD is used to increase the TTL sent to an NBT node that sent us the
// name registration request.  The pad is on top of the TTL we compute
// (WACK_TLL) above to determine how much time WINS will take to conduct
// the challenge. The pad is supposed to take care of the situation where
// WINS is dragging its feet due to a sudden transient peak in network
// load or cpu load.

#define  WAIT_PAD		       500	//500 msecs in case WINS is very
					        //busy

/*
 *	Global Variable Definitions
 */

//
// heap used to allocate work items for the challenge request and response
// queues
//
HANDLE  	   NmsChlHeapHdl;



/*
 *	Local Variable Definitions
 */
//
// It maintains a running count of how many responses to queries/releases are
// pending
//
DWORD		   scPendingRsp = 0;

//
// The maximum # of requests that the name challenge manager sends at any
// one time. This number is never allowed to go over
// NMSCHL_MAX_CHL_REQ_AT_ONE_TIME.  In fact after one series of
// challenges are over (i.e. either they have timed out or we have received
// responses for them, this counter is reinitialized to 0)
//
// This var. is reinitialized to zero when a batch of challenge requests
// is acquired from the one or more of the challenge request queues
//
// It maintains the total # of requests acquired from the request queues.
//
DWORD		   sMaxTransId = 0;
#ifdef WINSDBG
DWORD              NmsChlNoOfReqNbt;
DWORD              NmsChlNoOfReqRpl;
DWORD              NmsChlNoNoRsp;
DWORD              NmsChlNoInvRsp;
DWORD              NmsChlNoRspDropped;
DWORD              NmsChlNoReqDequeued;
DWORD              NmsChlNoRspDequeued;
DWORD              NmsChlNoReqAtHdOfList;
#endif
//
// We have a dimension 1 larger than the max. number of challenge requests
// handled at one time so that we can terminate the list with a NULL.
//
STATIC  PCHL_REQ_WRK_ITM_T   spReqWrkItmArr[NMSCHL_MAX_CHL_REQ_AT_ONE_TIME + 1];

/*
 *	Local Function Prototype Declarations
 */
STATIC
DWORD
ChlThdInitFn(
	IN LPVOID pThreadParam
	);

STATIC
STATUS
HandleWrkItm(
	PCHL_REQ_WRK_ITM_T	*ppaWrkItm,
	DWORD			MaxTransId,
	BOOL			fRetry	
	);


STATIC
STATUS
WaitForRsp(
	   VOID
	);

STATIC
STATUS
ProcRsp(
	VOID
	);

STATIC
STATUS
ChlUpdateDb(
        BOOL                    fUpdVersNoOfCnfRec,
	WINS_CLIENT_E		Client_e,
	PNMSDB_ROW_INFO_T	pRowInfo,
	DWORD			OwnerIdInCnf,
	BOOL			fRefreshOnly
	);
STATIC
VOID
InfRemWins(
	PCHL_REQ_WRK_ITM_T	pWrkItm
	  );

STATIC
STATUS
ProcAddList(
	PCHL_REQ_WRK_ITM_T	pReqWrkItm,
	PNMSMSGF_CNT_ADD_T	pCntAdd,
	LPBOOL			pfAdded
	);

/* prototypes for functions local to this module go here */

STATUS
NmsChlInit(
	VOID
	)

/*++

Routine Description:

	This function is called to initialize the name challenge component

Arguments:
	None

Externals Used:
	None

	
Return Value:
	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:
	Init in nms.c

Side Effects:
	
Comments:
	None
--*/

{

	STATUS RetStat = WINS_SUCCESS;
	
	/*
	* Create heap for allocating name challenge work items
	*/
        DBGPRINT0(HEAP_CRDL, "NmsChlInit: Chl. Mgr. heap\n");
	NmsChlHeapHdl =  WinsMscHeapCreate(
		0,    /*to have mutual exclusion	*/
		NMSCHL_INIT_BUFF_HEAP_SIZE
		);


	//
	//  Initialize the spReqWrkItmArr elements to NULL
	//	
	//  ANSI C should do it for us (all externals are initialized
	//  automatically, but I am taking no chances).  This is
	//  init time overhead.
	//
	WINSMSC_FILL_MEMORY_M((void *)spReqWrkItmArr, sizeof(spReqWrkItmArr), 0);
	
	
	//
	// Create the response event handle.  This event is signaled
	// by the UDP listener thread when it stores a response
	// in the spReqWrkItmArr array
	//
	WinsMscCreateEvt(
			  TEXT("WinsNmsChlRspEvt"),
			  FALSE,	//auto-reset
			  &QueNmsCrqQueHd.EvtHdl
			);

	//
	// Initialize the critical section for the response queue
	//				
	InitializeCriticalSection(&QueNmsCrqQueHd.CrtSec);
	
	//
	//Initialize the queue head for the response queue
	//
	InitializeListHead(&QueNmsCrqQueHd.Head);
	
	//
	// Since this thread deals with two request queues instead of
	// one, we need to create one more
	// critical section and event handle and initialize the
	// queue head of this  other queue.  The second queue
	// will be created when we create the thread
	//	
	InitializeListHead(&QueNmsRrcqQueHd.Head);	

	
	WinsMscCreateEvt(
			     TEXT("WinsNmsChlReplReqEvt"),
			     FALSE,		//Auto Reset
			     &QueNmsRrcqQueHd.EvtHdl
			  );

	InitializeCriticalSection(&QueNmsRrcqQueHd.CrtSec);

	//
	//
	// Create the name challenge thread.  This function will
	// initialize the critical section and the Evt handle passed
	// to it
	//	
	RetStat = WinsMscSetUpThd(
			&QueNmsNrcqQueHd,		//queue head
			ChlThdInitFn,		        //init function
			NULL,	   		        // no param
			&WinsThdPool.ChlThd[0].ThdHdl,
			&WinsThdPool.ChlThd[0].ThdId
			);

	if (RetStat == WINS_SUCCESS)
	{
		WinsThdPool.ChlThd[0].fTaken = TRUE;
		WinsThdPool.ThdCount++;  //increment the thread count
	}
	return(RetStat);

} // NmsChlInit()



STATUS
NmsChlHdlNamReg(
	IN NMSCHL_CMD_TYP_E   CmdTyp_e,
	IN WINS_CLIENT_E      Client_e,
	IN PCOMM_HDL_T        pDlgHdl,	
	IN MSG_T              pMsg,
        IN MSG_LEN_T          MsgLen,
	IN DWORD	      QuesNamSecLen,
	IN PNMSDB_ROW_INFO_T  pNodeToReg,
	IN PNMSDB_STAT_INFO_T  pNodeInCnf,
//	IN PCOMM_ADD_T	      pAddOfNodeInCnf,
	IN PCOMM_ADD_T	      pAddOfRemWins
	)

/*++

Routine Description:
	This function is called to handle a name registration that resulted
	in a conflict


Arguments:
	CmdTyp_e  - Type of command (challenge, challenge and release if
			challenge succeeds, release -- see nmschl.h)
	Client_e  - client (nms or replicator)
	pDlgHdl   - Dlg hdl (only if client is nms)
	pMsg      - Buffer containing request (only if client is nms)
	Msglen    - length of above buffer
	QuesNamSecLen - Length of question name section in buffer
	pNodeToreq  - Info about name to register
	pAddOfNodeInCnf - address of node in conflict (i.e. has name) with the
			  node trying to register

Externals Used:
	None

	
Return Value:

	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:
	NmsNmhNamRegInd, NmsNmhNamRegGrp (in an Nbt thread)

Side Effects:

Comments:
	None
--*/

{


	STATUS RetStat = WINS_SUCCESS;
#if USENETBT == 0
	BYTE   aBuff[COMM_DATAGRAM_SIZE];
#else
	BYTE   aBuff[COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE];
#endif
	DWORD  BuffLen;
	
	DBGENTER("NmsChlHdlNamReg\n");

	//
	//  Before inserting the request, send a WACK. The Time period
	//  in the TTL should be equal to WinsCnf.RetryInterval
	//
	//  Note: WACK is sent only if pDlgHdl is NON-NULL since that
	//        implies that the request is from an NBT thread
	//
	if (pDlgHdl != NULL)
	{
	
		COMM_ADD_T	NodeToSendWACKTo;
                DWORD       WackTtl;

                if (NMSDB_ENTRY_MULTIHOMED_M(pNodeInCnf->EntTyp))
                {
                        WackTtl = pNodeInCnf->NodeAdds.NoOfMems * WACK_TTL;
                }
                else
                {
                        WackTtl = WACK_TTL;
                }

		//
		// Format the WACK
		//
		NmsMsgfFrmWACK(
#if USENETBT == 0
				aBuff,
#else
				aBuff + COMM_NETBT_REM_ADD_SIZE,
#endif
				&BuffLen,
				pMsg,
				QuesNamSecLen,
				WackTtl
			     );


		//
		// We extract the address from the DlgHdl and don't use
		// the address passed in the name packet since a node
		// can register a name with an address different than
		// its own.
		//
		// RFCs are silent about the above
		//
		NodeToSendWACKTo.AddLen    = COMM_IP_ADD_SIZE;
		COMM_GET_IPADD_M(pDlgHdl, &NodeToSendWACKTo.Add.IPAdd);
		NodeToSendWACKTo.AddTyp_e  = COMM_ADD_E_TCPUDPIP;

		DBGPRINT2(CHL, "NmsChlHdlNamReg: Sending WACK to node with name = (%s) and address = (%X)\n", pNodeToReg->pName, NodeToSendWACKTo.Add.IPAdd);

		//
		// Send the WACK.  Use the explicit NBT dlg handle since the
		// WACK has to be sent as a UDP packet.
		//
		ECommSendMsg(
			&CommExNbtDlgHdl,
			&NodeToSendWACKTo,
#if USENETBT == 0
			aBuff,
#else
			aBuff + COMM_NETBT_REM_ADD_SIZE,
#endif	
			BuffLen

 	    	            );
	}	

        WINSMSC_COPY_MEMORY_M(
                pNodeToReg->Name,
                pNodeToReg->pName,
                pNodeToReg->NameLen
                        );
	//
	// Insert the request in the challenge queue so that the challenge
	// thread can get it
	//
	RetStat = QueInsertChlReqWrkItm(
			  CmdTyp_e,
			  Client_e,
			  pDlgHdl,
			  pMsg,
			  MsgLen,
			  QuesNamSecLen,
			  pNodeToReg,
			  pNodeInCnf,
			  pAddOfRemWins
			  );

#ifdef WINSDBG
        if (Client_e == WINS_E_NMSNMH)
        {
           NmsChlNoOfReqNbt++;
        }
        else
        {
           NmsChlNoOfReqRpl++;
        }
#endif
	DBGLEAVE("NmsChlHdlNamReg\n");
	return(RetStat);

} // NmsChlHdlNamReg()	





DWORD
ChlThdInitFn(
	IN LPVOID pThreadParam
	)
	
/*++

Routine Description:
	This is the initialization function for the name challenge thread


Arguments:
	pThreadParam  - NOT USED

Externals Used:
	None

	
Return Value:

	This function should never return.  If it returns it means there
	is some problem.  WINS_FAILURE is returned when this happens

Error Handling:

Called by:
	NmsChlInit

Side Effects:
	A name challenge thread is created

Comments:
	None
--*/

{
	
	STATUS 			RetStat = WINS_SUCCESS;
	HANDLE			ThdEvtHdlArray[3];	
	DWORD			ArrInd;		//index of hdl signaled
	PCHL_REQ_WRK_ITM_T	pWrkItm = NULL;
    BOOL                    fTablesOpen = FALSE;

    BOOL    bRecoverable = FALSE;
	UNREFERENCED_PARAMETER(pThreadParam);

while(TRUE)
{
try {
  if (!bRecoverable)
  {
	/*

	   Initialize the thread with the database
	*/
	NmsDbThdInit(WINS_E_NMSCHL);
	DBGMYNAME("Name Challenge Thread");

	/*
	 *  Initialize the array of handles on which the challenge thread will
	 *  wait.
	*/
	ThdEvtHdlArray[0]    =  NmsTermEvt;	        //termination event var
	ThdEvtHdlArray[1]    =  QueNmsNrcqQueHd.EvtHdl; //work queue event var
	ThdEvtHdlArray[2]    =  QueNmsRrcqQueHd.EvtHdl; //work queue event var

    bRecoverable = TRUE;
  }
	
	while (TRUE)
	{

		WinsMscWaitUntilSignaled(
				ThdEvtHdlArray,
				sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
				&ArrInd,
                FALSE
					);	

		//
		// if NmsTermEvt was signaled, terminate self
		//
		if (ArrInd == 0)
		{
		      WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
		}	

		while (TRUE)
		{	
			scPendingRsp      = 0;  //reinit TransId Counter to 0
			sMaxTransId       = 0;  //reinit MaxTransId Counter to 0
			RetStat =  QueRemoveChlReqWrkItm(
						ThdEvtHdlArray[ArrInd],
						(LPVOID *)spReqWrkItmArr,
						&sMaxTransId
						     );

			if (RetStat == WINS_NO_REQ)
			{
				break;   //break out of while loop	
			}	
			else   // one or more items were dequeued
			{
#ifdef WINSDBG
                                NmsChlNoReqDequeued += sMaxTransId;
#endif
				NmsDbOpenTables(WINS_E_NMSCHL);
                                fTablesOpen = TRUE;
				scPendingRsp = sMaxTransId;	

                                QueChlWaitForRsp();
				//
				// If HandleWrkItm fails, it will raise
				// an exception
				//
				HandleWrkItm(
					      spReqWrkItmArr,
					      sMaxTransId,
					      FALSE  //not a retry
					    );
				//
				// Wait for responses to all requests sent
				// WaitForRsp() function will return only
				// after all requests are done with
				// as a result of responses having been
				// received for them, they having timed out
				// after the requisite number of retries or
				// a mix of both.
				//
				WaitForRsp();

                                QueChlNoWaitForRsp();

				NmsDbCloseTables();
                                fTablesOpen = FALSE;

			}
		} // end of while (TRUE)
      } // end of while (TRUE)

     } // end of try {..}

except (EXCEPTION_EXECUTE_HANDLER) {
  if (bRecoverable)
  {
    DWORD   No;
    DWORD ExcCode = GetExceptionCode();
    DBGPRINTEXC("ChlThdInitFn: Name Challenge Thread");
    //
    // If ExcCode is NBT_ERR, it could mean that the main thread
    // closed the netbt handle.
    //
    if ( ExcCode == WINS_EXC_NBT_ERR)
    {
         if (WinsCnf.State_e == WINSCNF_E_TERMINATING)
         {
	        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
         }
         else
         {
            //if ((WinsCnf.State_e != WINSCNF_E_PAUSED) && (!fWinsCnfInitStatePaused))
            {
	           WINSEVT_LOG_M(ExcCode, WINS_EVT_CHL_EXC);
            }
         }
    }
    else
    {
	   WINSEVT_LOG_M(ExcCode, WINS_EVT_CHL_EXC);
    }
	
    if(fTablesOpen)
    {
	NmsDbCloseTables();
        fTablesOpen = FALSE;
    }

    //
    // For all requests that were never sent, free them
    //
    for (No=0; No < sMaxTransId; No++)
    {
           if (spReqWrkItmArr[No] != NULL)
           {
                if (spReqWrkItmArr[No]->pMsg != NULL)
                {
		   ECommFreeBuff(spReqWrkItmArr[No]->pMsg);
                }
		QueDeallocWrkItm(NmsChlHeapHdl, spReqWrkItmArr[No]);
           }
    }

    QueChlNoWaitForRsp();

  } // end of if (bRecoverable)
  else // if (bRecoverable)
  {
	DBGPRINTEXC("ChlThdInitFn: Name Challenge Thread");
	//
	// If NmsDbThdInit comes back with an exception, it is possible
	// that the session has not yet been started.  Passing
	// WINS_DB_SESSION_EXISTS however is ok
	//
	//
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_CHL_ABNORMAL_SHUTDOWN);
	WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);	
  } // if (bRecoverable)
} // exception handler
} // while(TRUE)
  //
  // We should never get here
  //
  return(WINS_FAILURE);

}  // ChlThdInitFn()



STATUS
HandleWrkItm(
	IN PCHL_REQ_WRK_ITM_T	*ppaWrkItm,
	IN DWORD		MaxTransId,
	IN BOOL			fRetry
	)

/*++

Routine Description:
	This function is called to send a name query to the node that
	was confliciting


Arguments:
	ppaWrkItm  - Address of an array of pointers to work items that
		    got queued in one or more of the challenge queues
		
	MaxTransId - One more than the index of the last filled entry in
		     the array

	fRetry	   - indicates whether HandleWrkItm is being called to
		     retry a request

Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
	ChlThdInitFn(), WaitForRsp

Side Effects:

Comments:
	None
--*/

{
#if USENETBT == 0
	BYTE 	        	Buff[COMM_DATAGRAM_SIZE];
#else
	BYTE 	        	Buff[COMM_DATAGRAM_SIZE + COMM_NETBT_REM_ADD_SIZE];
#endif
	MSG_LEN_T		MsgLen;
	LPBYTE			pName           = NULL;
	DWORD			NameLen         = 0;
	PCOMM_ADD_T  		pAddOfNodeInCnf = NULL;
	NMSCHL_CMD_TYP_E	CmdTyp_e;
	NMSMSGF_NODE_TYP_E	NodeTyp_e;
	DWORD			cPendingRsp     = 0; //count of pending
						     //responses
	volatile DWORD		i;

	DBGENTER("HandleWrkItm\n");

PERF("For retries, reuse the buffer sent for the initial try. This means")
PERF("that I need to allocate it and store it in the request work item")
PERF("instead of using the stack for it")
	UNREFERENCED_PARAMETER(fRetry);

	//
	// Loop over all slots of the array that were filled as a result of
	// the acquisition of requests from the challenge request queue(s)
	//
FUTURES("Remove the exception handler out of production code")
try {
        DBGPRINT1(CHL, "HandleWrkItm: Max Trans. Id = (%d)\n", MaxTransId);
	for(
		i = 0;
		i < MaxTransId;
		ppaWrkItm++, i++
	    )
	{
		//
		// if we have hit an empty slot, it means that this function
		// has been called to retry one or more requests that
		// did not get satisfied in the first wait period.  The empty
		// slot indicates that a request that occupied this slot
		// got satisfied in one of the earlier retries.  Just
		// skip the empty slot
		//
		if (fRetry && (*ppaWrkItm == NULL))
		{
			DBGPRINT1(CHL, "HandleWrkItm: HIT a NULL entry. Trans. Id = (%d)\n", i);
			continue;
		}

		(*ppaWrkItm)->NodeToReg.pName = (*ppaWrkItm)->NodeToReg.Name;

		CmdTyp_e  	= (*ppaWrkItm)->CmdTyp_e;
		NodeTyp_e 	= (*ppaWrkItm)->NodeToReg.NodeTyp;

		pName      = (*ppaWrkItm)->NodeToReg.pName;

		//
		// if the first character is 0x1B, swap the bytes
		// This is for supporting the browser. See
		// NmsMsgfProcNbtReq
		//
		if (*pName == 0x1B)
		{
			WINS_SWAP_BYTES_M(pName, pName + 15);
		}
       	        NameLen    = (*ppaWrkItm)->NodeToReg.NameLen;
		
	
		//
		// get the last address (the only address unless the node in
		// conflict is a multihomed node) from the list of addresses
		//
        	pAddOfNodeInCnf = &((*ppaWrkItm)->NodeAddsInCnf.Mem[
					(*ppaWrkItm)->NoOfAddsToUse - 1	
							].Add);
		


		//
		//  If the command is directing us to do a challenge, send a
		//  name query
		//
		if (
			(CmdTyp_e == NMSCHL_E_CHL)
				||
			(CmdTyp_e == NMSCHL_E_CHL_N_REL_N_INF)
				||
			(CmdTyp_e == NMSCHL_E_CHL_N_REL)
		   )
	        {
			DBGPRINT3(CHL, "HandleWrkItm: Sending Name Query Request with Transid = (%d) to node with name = (%s) and address = (%X)\n", i, pName, pAddOfNodeInCnf->Add.IPAdd);
		
			NmsMsgfFrmNamQueryReq(
						i, 	//Transaction Id
#if USENETBT == 0
						Buff,
#else
						Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
						&MsgLen,
						pName,
						NameLen
			    		     );	

			(*ppaWrkItm)->ReqTyp_e	        = NMSMSGF_E_NAM_QUERY;
		}	
		else   // has to be NMSCHL_E_REL or NMSCHL_E_REL_N_INF or
                       // NMSCHL_E_REL_ONLY
		{
		
			DBGPRINT3(CHL,
			    "HandleWrkItm: Sending Name Release Request with Transid = (%d) to node with name = (%s) and address = (%X)\n", i, pName, pAddOfNodeInCnf->Add.IPAdd);

			NmsMsgfFrmNamRelReq(
						i, 	//Transaction Id
#if USENETBT == 0
						Buff,
#else
						Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
						&MsgLen,
						pName,
						NameLen,
						NodeTyp_e,
						pAddOfNodeInCnf
			    		  );	
			(*ppaWrkItm)->ReqTyp_e	        = NMSMSGF_E_NAM_REL;
		}

		ECommSendMsg(
				&CommExNbtDlgHdl,
				pAddOfNodeInCnf,
#if USENETBT == 0
				Buff,
#else
				Buff + COMM_NETBT_REM_ADD_SIZE,
#endif
				MsgLen
 	    	   	    );
		cPendingRsp++;
	}
	
	//
	// Do a sanity check
	//
#ifdef WINSDBG
	if (cPendingRsp != scPendingRsp)
	{
		DBGPRINT2(EXC, "SOFTWARE ERROR.  THE COUNT OF PENDING RESPONSES (%d) AS COMPUTED BY THE HandleWrkItm FN DOES NOT MATCH WITH THE EXPECTED ONE (%d)\n\n", cPendingRsp, scPendingRsp);
		WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
	}
#endif
}	
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("HandleWrkItm");

        //
        // if the exception is an nbt error, it is expected if wins is in
        // the paused state.  Do not reraise the exception if this is the
        // case.  We want to go through our WaitRsp() function so that
        // the new records (replicas or registrations) get registered.
        // If this results in an inconsistent db, it will straighten
        // itself out soon after WINS is unpaused.
        //
        //if (!((GetExceptionCode() == WINS_EXC_NBT_ERR) && (WinsCnf.State_e ==
         //         WINSCNF_E_PAUSED) || (fWinsCnfInitStatePaused)))
        {
	   WINS_RERAISE_EXC_M();
        }
#if 0
        else
        {
            //
            // For all requests that were never sent, free them
            //
            for (No=0; No < sMaxTransId; No++, pReqWrkItm++)
            {
                if (pReqWrkItm != NULL)
                {
                  if (pReqWrkItm->pMsg != NULL)
                  {
		   ECommFreeBuff(pReqWrkItm->pMsg);
                  }
		  QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);

                }
            }
#endif
    }  // end of except { .. }

	DBGLEAVE("HandleWrkItm\n");
	return(WINS_SUCCESS);

} // HandleWrkItm()




STATUS
WaitForRsp(
	   VOID
	)

/*++

Routine Description:
	This function is responsible for waiting for responses to all
	requests that have been sent until either they time out or their
	responses are received.

Arguments:
	None

Externals Used:
	None

Return Value:
	WINS_SUCCESS or a failure code.  The function can also raise an
	exception in case of fatal errors

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
	HANDLE ThdEvtHdlArray[2];	
    	DWORD  Count 	  = 0;
    	DWORD  TickCntSv;
 	DWORD  TickCnt    = 0;
	DWORD  TimeLeft;
	BOOL   fSignaled  = TRUE;	//was an event signaled
	DWORD  ArrInd     = 0;		//Not used
	DWORD  i 	  = 0;
	NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SRV_ERR;
	PCHL_REQ_WRK_ITM_T pReqWrkItm;
	NMSMSGF_RSP_INFO_T RspInfo;
        BOOL               fNewTry = TRUE;

	/*
	 *  Initialize the array of handles on which the challenge thread will
	 *  wait.
	*/
	ThdEvtHdlArray[0]    =  NmsTermEvt;	       //termination event var
	ThdEvtHdlArray[1]    =  QueNmsCrqQueHd.EvtHdl; //work queue event var
	
FUTURES("Remove the try out of production level code")
try {	
	while(TRUE)
	{
            if (fNewTry)
            {
	      //
	      // Get the number of msecs that have
	      // elapsed since windows was started
	      //
	      TickCntSv     = GetTickCount();
	      TimeLeft      = (1 << Count) * WinsCnf.RetryInterval;
            }

	    //
	    // Check if we have exhausted all retries for this batch of
	    // requests
            //
	    if (Count == WinsCnf.MaxNoOfRetries)
	    {
		
		//
		// CleanUp all spReqWrkItmArr entries which have not
		// been satisfied as yet.
		//
		for (i = 0; i < sMaxTransId; i++)
		{	
		   if (spReqWrkItmArr[i] != NULL)
		   {
#ifdef  WINSDBG
                      NmsChlNoNoRsp++;
#endif
		      pReqWrkItm = spReqWrkItmArr[i];

		      //
		      // Decrement the count of addresses to send query or
		      // release  to.
		      //
		      pReqWrkItm->NoOfAddsToUse--;	

		      //
		      //
		      // If there are no more addresses to challenge/release
                      //
		      if (pReqWrkItm->NoOfAddsToUse == 0)
		      {
						
			   //
			   // Just in case the record to register is a UNIQUE
			   // record.  No need to have an if (will add overhead)
			   //
			   pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
			   //
			   // In case the row we are putting in the database is
			   // one given to use by the Replicator, we don't
			   // need to set Rcode_e.  However, to avoid an if
			   // test, we just set it.  It will remain unused
			   //
                          if (pReqWrkItm->CmdTyp_e != NMSCHL_E_REL_ONLY)
                          {
			      if (
			        ChlUpdateDb(
                                        FALSE,
					pReqWrkItm->Client_e,
					&pReqWrkItm->NodeToReg,
					pReqWrkItm->OwnerIdInCnf,
					FALSE  //not just a refresh
					) ==  WINS_SUCCESS
			         )

			      {
				    DBGPRINT0(CHL, "WaitForRsp:Database Updated\n");
				    //
				    // if the remote WINS has to be notified of
				    // the update, do so
				    //
			             if(pReqWrkItm->CmdTyp_e ==
                                                  NMSCHL_E_REL_N_INF)
				    {
					   InfRemWins(pReqWrkItm);
				
				    }
				    Rcode_e = NMSMSGF_E_SUCCESS;
			      }
			      else
			      {
				     Rcode_e = NMSMSGF_E_SRV_ERR;
				     WINSEVT_LOG_M(
					    WINS_FAILURE,
					    WINS_EVT_CHLSND_REG_RSP_ERR
					     );

				     DBGPRINT0(CHL, "WaitForRsp:Server Error\n");
                              }
			  }
			
			  //
			  // Send a response only if the registration request
			  // was sent by an NBT node
			  //
			  if (
				(pReqWrkItm->Client_e == WINS_E_NMSNMH)
					&&
				(!pReqWrkItm->NodeToReg.fStatic)
					&&
				(!pReqWrkItm->NodeToReg.fAdmin)
			   )
			  {
				RspInfo.pMsg   = pReqWrkItm->pMsg;
				RspInfo.MsgLen = pReqWrkItm->MsgLen;
				RspInfo.QuesNamSecLen =
						pReqWrkItm->QuesNamSecLen;
				RspInfo.Rcode_e = Rcode_e;

				if (Rcode_e == NMSMSGF_E_SUCCESS)
				{
				   EnterCriticalSection(&WinsCnfCnfCrtSec);
				   RspInfo.RefreshInterval =
						WinsCnf.RefreshInterval;
				   LeaveCriticalSection(&WinsCnfCnfCrtSec);
				}
				

			     	NmsNmhSndNamRegRsp(
					&pReqWrkItm->DlgHdl,
					&RspInfo
						  );
			   }

		          //
		          //  deallocate the req  wrk items
		          //
		          QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);

		   }
		   else  // we haven't yet dealt with all the addresses. So,
			 // let us requeue the work item.
		   {

			 //
			 // Reinsert the work item since there are other
			 // addresses that we need to handle in HandleWrkItm()
			 //
             DBGPRINT2(CHL, "WaitForRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
			 QueInsertWrkItmAtHdOfList(
						&pReqWrkItm->Head,
						pReqWrkItm->QueTyp_e,
						NULL
						    );

		   }

		   //
		   // Reinit the array entry to obliterate the
		   // possibility of error (see ProcRsp)
		   //
		   spReqWrkItmArr[i] = NULL;
		   scPendingRsp--; //actually there is no need for this
				   //since scPendingRsp will be inited
				   //after dequeing requests

		  } 	// end of if
	        }  	//end of for loop for looping over sReqWrkItm array

	        break; 	//break out of the while(TRUE) loop

	     }
	     else   //count is != WinsCnf.MaxNoOfRetries
	     {

	   	WinsMscWaitTimedUntilSignaled(
			ThdEvtHdlArray,
			sizeof(ThdEvtHdlArray)/sizeof(HANDLE),
			&ArrInd,	
			TimeLeft,
			&fSignaled
			    );

	       //
	       //  if signaled, it means a response item is in the response
	       //  queue.
	       //
	       if (fSignaled)
	       {
					
                  DWORD TicksToSub;

		  //
		  // If signaled for termination, do it
		  //
		  if (ArrInd == 0)
	 	  {
			WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
		  }

		  DBGPRINT0(CHL, "WaitForRsp: Received a response\n");
#ifdef WINSDBG
                  NmsChlNoRspDequeued++;
#endif
		  ProcRsp();	


		  //
		  //  If no responses are expected, break out of loop
		  //
		  if (scPendingRsp == 0)
		  {
			break;  	//break out of the while loop
		  }

	  	  //
	  	  // Get the number of msecs that have
	  	  // elapsed since windows was started
	  	  //
	  	  TickCnt = GetTickCount();

		  //
		  // If there has been a wrap around (will happen every 49.7
		  // days of Windows being up
		  //
		  if (TickCnt < TickCntSv)
		  {
		     TicksToSub = (TickCnt + (MAXULONG - TickCntSv));

		  }
		  else
		  {	
		     TicksToSub = TickCnt - TickCntSv;
		  }

                  //
                  // We don't want to subtract a biger number from a
                  // smaller number.  This will result in a huge value for
                  // TimeLeft making the challenge thread block forever.
                  //
                  if (TimeLeft > TicksToSub)
                  {
			TimeLeft -= TicksToSub;		
                        fNewTry = FALSE;
                  }
                  else
                  {
	    	        Count++;		//increment the count of retries
		        if ( Count != WinsCnf.MaxNoOfRetries)
		        {
			  //
			  // The Retry time interval being over, let us
			  // retry all those requests that did not get
			  // satisfied (i.e. no responses yet)
			  //
			  HandleWrkItm(
					spReqWrkItmArr,
					sMaxTransId,
					TRUE		//it is a retry	
				     );
                          //
                          // We have waited for the entire allowed
                          // wait time.  Time to do a retry
                          //
                          fNewTry = TRUE;
		        }
                  }
	       }
	       else
	       {
	    	  Count++;		//increment the count of retries
		  if ( Count != WinsCnf.MaxNoOfRetries)
		  {
			//
			// The Retry time interval being over, let us
			// retry all those requests that did not get
			// satisfied (i.e. no responses yet)
			//
			HandleWrkItm(
					spReqWrkItmArr,
					sMaxTransId,
					TRUE		//it is a retry	
				     );
                       fNewTry = TRUE;
		  }
	       }
	     }
	
	 }  // end of while (TRUE)
} // end of try ..
except(EXCEPTION_EXECUTE_HANDLER) {
	DBGPRINTEXC("WaitForRsp");

	//
	// must be some serious error. Reraise the exception
	//
	WINS_RERAISE_EXC_M();

 } // end of except { ..}
	return(WINS_SUCCESS);

}  // WaitForRsp()


STATUS
ProcRsp(
	VOID
	)

/*++

Routine Description:
	This function is called to process one or more work items
	queued on the challenge response queue.

	This response can be to  name query or name release requests sent
	earlier

Arguments:
	None

Externals Used:
	None

	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
	WaitForRsp()

Side Effects:

Comments:
	None
--*/
{

	DWORD  		       TransId  = 0;
	NMSMSGF_NAM_REQ_TYP_E  Opcode_e   = NMSMSGF_E_NAM_QUERY;
	BYTE		       Name[NMSMSGF_RFC_MAX_NAM_LEN];
	DWORD		       NameLen;
//	COMM_IP_ADD_T	       IPAdd;
	NMSMSGF_CNT_ADD_T      CntAdd;
	NMSMSGF_ERR_CODE_E     Rcode_e;
	PCHL_REQ_WRK_ITM_T     pReqWrkItm;
	STATUS		       RetVal;
	PCHL_RSP_WRK_ITM_T     pRspWrkItm;
	STATUS		       RetStat = WINS_SUCCESS;
	LPBYTE		       pNameToComp;
	DWORD		       NameLenUsedInComp;
	BOOL		       fAdded;
    BOOL               fGroup;

	DBGENTER("ProcRsp\n");
	while (TRUE)
	{
		//dequeue each response and process
		RetVal = QueRemoveChlRspWrkItm(&pRspWrkItm);

		if (RetVal == WINS_NO_REQ)
		{
			break;
		}
		if (
			NmsMsgfUfmNamRsp(
			 	pRspWrkItm->pMsg,
			 	&Opcode_e,
			 	&TransId,
			 	Name,
			 	&NameLen,
			 	&CntAdd,
			 	&Rcode_e,
                &fGroup
					) == WINS_FAILURE
	   	   )
		{

	   		//
			// Throw away response
			//	
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;
		}

        	//
		// Get the request corresponding to the response.
		//	
                if (TransId >= sMaxTransId)
                {
	   		//
			// Throw away response
			//	
                        DBGPRINT3(ERR, "ProcRsp: Rsp: Name = (%s); Transid = (%d), Opcode_e = (%d). Being rejected (TOO LARGE TRANS. ID)\n", Name, TransId, Opcode_e);
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;


                }
		pReqWrkItm = spReqWrkItmArr[TransId];
		if (!pReqWrkItm)
		{
			//
			// Throw this response away
			//
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;
		}	


		//
		// First and foremost check whether the response is for one of
		// the current requests (we want to guard against mismatching
		// the response to a request (the response could be for an old
		// request that is no longer in our spReqWrkItmArr array.
		//	

		
		//
		// Compare the Name and the Opcode from where the
		// response came with the same in the request
		//	
	        pNameToComp       =  pReqWrkItm->NodeToReg.pName;
		NameLenUsedInComp =  pReqWrkItm->NodeToReg.NameLen;

		RetVal = (ULONG) WINSMSC_COMPARE_MEMORY_M(
				       Name,
				       pNameToComp,
				       NameLenUsedInComp
						   );
		if (
		      (RetVal != NameLenUsedInComp )
		      		 ||
		      ( pReqWrkItm->ReqTyp_e != Opcode_e )
		     )
		{
			//
			// Throw this response away
			//
		        DBGPRINT5(ERR, "ProcRsp: Mismatch between response and request. Req/Res Name (%s/%s); ReqType_e/Opcode_e = (%d/%d). TransId = (%d)\n", pNameToComp, Name, pReqWrkItm->ReqTyp_e, Opcode_e, TransId);
		        WINSEVT_LOG_INFO_D_M(
					    WINS_SUCCESS,
					    WINS_EVT_REQ_RSP_MISMATCH
					  );
			ECommFreeBuff(pRspWrkItm->pMsg);
		        QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
#ifdef WINSDBG
                        NmsChlNoInvRsp++;
#endif
			continue;

		}

		//
		// We have a valid response
		//
		DBGPRINT3(CHL, "ProcRsp: (%s) Response is for name = (%s); 16th char (%X)\n", Opcode_e == NMSMSGF_E_NAM_REL ? "RELEASE" : "QUERY", Name, Name[15]);
		//
		// Decrement the count of addresses to send query or release
		// to.  We send query/release to the next address in the list
                // if we get back a negative response to the current one. This
                // is just for extra safety (in case we have one or more
                // addresses in our list that are no longer valid for the name)
		//
		pReqWrkItm->NoOfAddsToUse--;	

		if (Opcode_e == NMSMSGF_E_NAM_REL)
		{
			
			//
			// If there are more addresses for sending the releases
			// to, insert the work item at the head of the queue
			//
			if ( (Rcode_e != NMSMSGF_E_SUCCESS) &&
                                      (pReqWrkItm->NoOfAddsToUse > 0))
			{
		   	   //
		   	   // The request has been processed. Init its
			   // position in the array. Also,
			   // decrement scPendingRsp.
		   	   //
		   	   spReqWrkItmArr[TransId] = NULL;
		   	   scPendingRsp--;

			   //
			   // Now, we have to send the RELEASE to the next
			   // address on the list .  This
			   // request has to be processed in the same
			   // way as all the other requests that are
			   // queued on our request queues (i.e. retry
			   // a certain number of times using a certain
			   // time interval).  Since we are in the
			   // middle of an execution of a batch of
			   // requests, queue this request at the head
			   // of the   next batch of requests.
			   //
             DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
			   QueInsertWrkItmAtHdOfList(
						&pReqWrkItm->Head,
						pReqWrkItm->QueTyp_e,
						NULL
						);
			   //
			   // Throw the response away
			   //
			   ECommFreeBuff(pRspWrkItm->pMsg);

			   //
			   // deallocate the response buffer
			   //
		   	   QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
			   return(WINS_SUCCESS);
			}	

                        //
                        // Either the name was released or we have exhausted
                        // the list of addresses without getting a positive
                        // release response
                        //

			//
			// Update the database.  Note: There is no need to
			// check the Rcode_e value since even if the release
			// request failed, we will overwrite the entry
			//
                        // A release is sent as a result of a clash during
                        // replication only, so a client id. of WINS_E_RPLPULL
                        // is correct.
                        //

                        if (pReqWrkItm->CmdTyp_e == NMSCHL_E_REL)
                        {
			   pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
		           if (ChlUpdateDb(
                                        FALSE,
					WINS_E_RPLPULL,
					&pReqWrkItm->NodeToReg,
					pReqWrkItm->OwnerIdInCnf,
					FALSE  //not just a refresh
				       ) != WINS_SUCCESS
			       )
			   {
			   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			   DBGPRINT0(CHL, "ProcRsp:COULD NOT UPDATE THE DB AFTER A RELEASE \n");
			   Rcode_e = NMSMSGF_E_SRV_ERR;
			   }
			   else
			   {
				//
				// if the remote WINS has to be notified of
				// the update.
                                //
                                // NOTE: This code won't be executed.
				//
				if(spReqWrkItmArr[TransId]->CmdTyp_e ==
						NMSCHL_E_REL_N_INF)
				{
					InfRemWins(
						spReqWrkItmArr[TransId]
					  	  );
				}
				Rcode_e = NMSMSGF_E_SUCCESS;
			   }
                      }

		}	
		else  // it is a name query response
		{

#ifdef WINSDBG
		  {
		    DWORD i;	
		    for (i=0; i<CntAdd.NoOfAdds;i++)
		    {
			DBGPRINT2(CHL, "ProcRsp: Address (%d) is (%X)\n", (i+1),CntAdd.Add[i].Add.IPAdd);
		    }
		   }
#endif
		
		   //
		   //  if the challenge succeded, we may need
		   //  to update the database
		   //
		   if (Rcode_e != NMSMSGF_E_SUCCESS ||
               pReqWrkItm->fGroupInCnf != fGroup)
		   {
			
			//
			// a negative name query response was received
            // OR Record type (unique vs group) doesn't match
            // (the second check is to consider the case of
            // a node which used the same name first as unique
            // and then as group)
			//

			//
			// If there are no more addresses to query
			//
			if (pReqWrkItm->NoOfAddsToUse == 0)
			{				
			  //
			  // Update the database
			  //
			  pReqWrkItm->NodeToReg.pNodeAdd =
						&pReqWrkItm->AddToReg;
		          if (ChlUpdateDb(
                                FALSE,
				pReqWrkItm->Client_e,
				&pReqWrkItm->NodeToReg,
				pReqWrkItm->OwnerIdInCnf,
				FALSE
				       ) == WINS_SUCCESS
			     )
		          {
		
		             //
			     // Set Rcode_e to SUCCESS
			     //
		       	     Rcode_e = NMSMSGF_E_SUCCESS;
		          }
			  else
			  {
			     Rcode_e = NMSMSGF_E_SRV_ERR;
			     WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			  }
		       }
		       else
		       {
				//
				// We need to challenge (query) the next
				// address in the list of addresses
				//
		   	        spReqWrkItmArr[TransId] = NULL;
		   		scPendingRsp--;
			
             DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d)\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
				QueInsertWrkItmAtHdOfList(
							&pReqWrkItm->Head,
							pReqWrkItm->QueTyp_e,
							NULL
							);
				//
				// Throw this response away
				//
				ECommFreeBuff(pRspWrkItm->pMsg);

				//
				// deallocate the response buffer
				//
		   		QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
				return(WINS_SUCCESS);
		       }
		   }
		   else  // positive name query response received
		   {

                         //
                         // if the cmd is CHL_N_REL, we need to now tell
                         // the remote node to release the name.
                         //

                         if (CntAdd.NoOfAdds == 1)
                         {
                           //
                           // Note: the CmdType_e will be CHL_N_REL
                           // only if the client is WINS_E_RPLPULL
                           //
			   if (pReqWrkItm->CmdTyp_e ==  NMSCHL_E_CHL_N_REL)
			   {
                                  DWORD No;

				  //
				  // We need to tell the remote node
				  // release all names.
				  //
				  pReqWrkItm->CmdTyp_e = NMSCHL_E_REL_ONLY;

		   	          spReqWrkItmArr[TransId] = NULL;
		   		  scPendingRsp--;

                                  //
                                  // We need to update the Version
                                  // no of the conflicting entry
                                  //
		          	 (VOID)ChlUpdateDb(
                                                TRUE,  //update vers. no.
						WINS_E_NMSNMH,  //to speed fn up
						&pReqWrkItm->NodeToReg,
						pReqWrkItm->OwnerIdInCnf,
					        FALSE	
				       			);

                                 //
                                 // Tell the remote guy to release
                                 // the name. Copy the addresses of
                                 // into the proper field
                                 //
		                 pReqWrkItm->NoOfAddsToUse =
                                      pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;	
                                 ASSERT(pReqWrkItm->NoOfAddsToUse <= NMSDB_MAX_MEMS_IN_GRP);
                                 for (No=0; No < pReqWrkItm->NoOfAddsToUse; No++)
                                 {
                                        *(pReqWrkItm->NodeAddsInCnf.Mem + No) = *(pReqWrkItm->NodeToReg.NodeAdds.Mem + No);

                                 }
                                 pReqWrkItm->NodeAddsInCnf.NoOfMems
                                                  = pReqWrkItm->NoOfAddsToUse;

                  DBGPRINT2(CHL, "ProcRsp: Name = (%s); NoOfAddsToUse is (%d); request REL_ONLY\n", pReqWrkItm->NodeToReg.Name, pReqWrkItm->NoOfAddsToUse);
				  QueInsertWrkItmAtHdOfList(
							&pReqWrkItm->Head,
							pReqWrkItm->QueTyp_e,
							NULL
							);
				  //
				  // Throw this response away
				  //
				  ECommFreeBuff(pRspWrkItm->pMsg);

				  //
				  // deallocate the response buffer
				  //
		   		  QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
				  return(WINS_SUCCESS);
                          }
                        }

			//
			// If more than one address was returned in the
			// query response, it means that the challenged
			// node is a multi-homed node.  Actually, a multihomed
			// node could return just one address too. This is
			// because it might have just come up and the name
			// may not have yet been registered for the multiple
			// adapters.

			//
			// Note: We execute the else code if the
			// record to register is a special group
			//
			if (	
			     !NMSDB_ENTRY_GRP_M(pReqWrkItm->NodeToReg.EntTyp)
			   )
			{
				//
				// Check if we need to update the db
				//
				RetStat = ProcAddList(
						pReqWrkItm,
						&CntAdd,
						&fAdded
						      );	

				if (RetStat == WINS_FAILURE)
				{
				      //
				      // There is atleast one address in the
				      // list to register that is not in the
				      // list of addresses returned.  This means
				      // that at least one of the addresses to
				      // register is not claimed by the node
				      // that responded.  We can not honor
                                      // this registration
				      //

				      //
				      // NAME ACTIVE error
				      //
				      Rcode_e = NMSMSGF_E_ACT_ERR;
				}
				else
				{
			  	  	//
			  		// Update the database
			  		//
			  		pReqWrkItm->NodeToReg.pNodeAdd =
						  &pReqWrkItm->AddToReg;

		          		if (ChlUpdateDb(
                                                FALSE,
						pReqWrkItm->Client_e,
						&pReqWrkItm->NodeToReg,
						pReqWrkItm->OwnerIdInCnf,
						!fAdded
				       			) == WINS_SUCCESS
			     		  )
		          		{
		
		             		   //
			     		   // Set Rcode_e to SUCCESS
			     		   //
		       	     		   Rcode_e = NMSMSGF_E_SUCCESS;
		          		 }
			  		 else
			  		 {
			     			Rcode_e = NMSMSGF_E_SRV_ERR;
			     			WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CANT_UPDATE_DB);
			  		 }

				}
					
			}
CHECK("Should a local multihomed node be told to release the name if it ")
CHECK("with a replica. This is what is done for the local unique/remote unique")
CHECK("name clash.  It seems the right strategy but may need to be rethought")

			else  // entry to register is a group
			{
				//
				// set Rcode_e to Error code
				//
				Rcode_e = NMSMSGF_E_ACT_ERR;
			}
		   }
		}	

		//
		// The request has been processed. Init its position
		// in the array.  Send the response to the waiting node
		// This will free the buffer too.
		//
		//  Also, decrement scPendingRsp.  This was incremented by
		//  HandleWrkItm for each query/release sent.
		//
		spReqWrkItmArr[TransId] = NULL;
		scPendingRsp--;

		//
		// Send a registration response only if the client that
		// submitted the request was an NBT thread.
		//
		if (
                       (pReqWrkItm->Client_e == WINS_E_NMSNMH)
					&&
			(!pReqWrkItm->NodeToReg.fStatic)
					&&
			(!pReqWrkItm->NodeToReg.fAdmin)
                   )
		{
			NMSMSGF_RSP_INFO_T	RspInfo;

			RspInfo.pMsg          = pReqWrkItm->pMsg;
			RspInfo.MsgLen 	      = pReqWrkItm->MsgLen;
			RspInfo.QuesNamSecLen = pReqWrkItm->QuesNamSecLen;
			RspInfo.Rcode_e       = Rcode_e;

			if (Rcode_e == NMSMSGF_E_SUCCESS)
			{
			   EnterCriticalSection(&WinsCnfCnfCrtSec);
			   RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
			   LeaveCriticalSection(&WinsCnfCnfCrtSec);
			  DBGPRINT0(CHL, "ProcRsp: Sending a Positive name registration response\n");
			}
#ifdef WINSDBG
			else
			{
			  DBGPRINT0(CHL, "ProcRsp: Sending a negative name registration response\n");
			}
#endif

			NmsNmhSndNamRegRsp(
			 	        &pReqWrkItm->DlgHdl,
					&RspInfo
			      	          );
			
		}

	        //
	        // Throw this response away
		//
	        ECommFreeBuff(pRspWrkItm->pMsg);

		//
		//  deallocate the req and rsp wrk items
		//
		QueDeallocWrkItm(NmsChlHeapHdl, pReqWrkItm);
		QueDeallocWrkItm(NmsChlHeapHdl, pRspWrkItm);
	}

	DBGLEAVE("ProcRsp\n");
	return(WINS_SUCCESS);
} // ProcRsp()



STATUS
ChlUpdateDb(
        BOOL                    fUpdVersNoOfCnfRec,
	WINS_CLIENT_E		Client_e,
	PNMSDB_ROW_INFO_T	pRowInfo,
	DWORD			OwnerIdInCnf,	
	BOOL			fRefreshOnly
	)

/*++

Routine Description:
	This function is called to update the database.  It is called
	by ProcRsp and by ChlThdInitFn when challenge succeeds

Arguments:
	Client_e - id of client that submitted the request
	pRowInfo - info about the record to be inserted

Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
	WaitForRsp(), ProcRsp()
Side Effects:

Comments:
	None
--*/

{
	NMSDB_STAT_INFO_T   StatInfo;
	STATUS		    RetStat    = WINS_SUCCESS;
        BOOL                fIncVersNo = FALSE;

	DBGENTER("ChlUpdateDb\n");

	//
	// update the time
	//
PERF("We can avoid this call to time, since we called time earlier before we")
PERF("challenge.  In the worst case that time will be off by a 2.5-3")
PERF("unless the thread is preempted for a long time")
PERF("assuming a name challenge and release took place.  In the best case")
PERF("it will be off by 1.25-1.5 secs (if just a challenge).  We can add ")
PERF("1.25 secs to that time  and avoid the overhead of a function call")

	(void)time(&pRowInfo->TimeStamp);

	if (((Client_e == WINS_E_NMSNMH) && !fRefreshOnly) ||
                   fUpdVersNoOfCnfRec)
        {
            fIncVersNo =  TRUE;
        }
	EnterCriticalSection(&NmsNmhNamRegCrtSec);
    if (pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
    {
        pRowInfo->TimeStamp += WinsCnf.RefreshInterval;
    }
    else
    {
        pRowInfo->TimeStamp += WinsCnf.VerifyInterval;
    }
   try
   {

	//
	// If the client (the one that submitted the challenge request) is
	// an NBT thread, we need to store the new version number.  If the
	// client is the replicator, we use the version number in the
	// record
	//
	if (fIncVersNo)
	{
		pRowInfo->VersNo = NmsNmhMyMaxVersNo;
	}

	StatInfo.OwnerId = OwnerIdInCnf;
	if (*(pRowInfo->pName+15) == 0x1B)
	{
		WINS_SWAP_BYTES_M(pRowInfo->pName, pRowInfo->pName+15);
	}

        //
        // If the vers. no of the local record needs to be updated, do so.
        //
        if (fUpdVersNoOfCnfRec)
        {
            RetStat = NmsDbUpdateVersNo (FALSE, pRowInfo, &StatInfo);
        }
        else
        {
	   RetStat = NmsDbSeekNUpdateRow(
				pRowInfo,
				&StatInfo
			   	     );
        }

	if ((RetStat == WINS_SUCCESS) && (StatInfo.StatCode == NMSDB_SUCCESS))
	{
		//
		// If the client is an NBT thread, we increment the version
		// number since the record we inserted in the db is
		// owned by us (we could also check the owner id here).  If
		// the client is the replicator thread, we don't do anything
		//
		if (fIncVersNo)
		{
			NMSNMH_INC_VERS_COUNTER_M(
				NmsNmhMyMaxVersNo,
				NmsNmhMyMaxVersNo
					    );

			//
			// if fAddChgTrigger is TRUE, we pass RPL_PUSH_PROP
			// as the first parameter. Its value is TRUE. See
			// rpl.h
			//
			RPL_PUSH_NTF_M(
			  (WinsCnf.PushInfo.fAddChgTrigger ? RPL_PUSH_PROP :
				RPL_PUSH_NO_PROP), NULL, NULL, NULL);
		}
	}
	else
	{
		DBGPRINT1(ERR, "ChlUpdateDb: Update of record with name (%s) FAILED\n", pRowInfo->pName);

		RetStat = WINS_FAILURE;
	}
  }
  except (EXCEPTION_EXECUTE_HANDLER)
  {
		DBGPRINTEXC("ChlUpdateDb")
		WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_CANT_UPDATE_DB);
  }
	LeaveCriticalSection(&NmsNmhNamRegCrtSec);

	DBGLEAVE("ChlUpdateDb\n");
	return (RetStat);
} //ChlUpdateDb()


VOID
InfRemWins(
	PCHL_REQ_WRK_ITM_T	pWrkItm
	  )

/*++

Routine Description:

	This function is called when a remote WINS has to be
	told to change the version stamp of a record that was
	pulled by the local WINS at replication.  The need for this
	has arisen because the pulled record collided with a record
	owned by the local WINS (both records being in the active
	state).
	
	
Arguments:
	pWrkItm - the work item that got queued to the name challenge
		  manager

Externals Used:
	None
	
Return Value:
	None

Error Handling:

Called by:
	
	ProcRsp	

Side Effects:

Comments:
	None
--*/
{
	COMM_HDL_T	DlgHdl;
	BYTE		ReqBuff[RPLMSGF_UPDVERSNO_REQ_SIZE];
	LPBYTE		pRspBuff;
	DWORD		ReqBuffLen;
	DWORD		RspBuffLen;
	NMSMSGF_ERR_CODE_E Rcode_e = 0;  //init to 0.  This is initialization
					 //is important since we update
					 //the LSB of Rcode_e with the
					 //the return status
					

	DBGENTER("InfRemWins\n");
try {

	//
	// Log an event since this is an important event to monitor (at
	// least initially)
	//
NONPORT("Change the following for transport independence")
	WINSEVT_LOG_INFO_D_M(pWrkItm->AddOfRemWins.Add.IPAdd,
				WINS_EVT_INF_REM_WINS);

	//
	// Start a dialogue to send the update version number request
	//	

   	//
   	// Init the pEnt field to NULL so that ECommEndDlg (in the
   	// exception handler) called as a result of an exception from
   	// behaves fine.
   	//
   	DlgHdl.pEnt = NULL;

	ECommStartDlg(
		&pWrkItm->AddOfRemWins,
		COMM_E_RPL,
		&DlgHdl	
		     );	


	RplMsgfFrmUpdVersNoReq(
				&ReqBuff[COMM_N_TCP_HDR_SZ],
				pWrkItm->NodeToReg.pName,
				pWrkItm->NodeToReg.NameLen,
				&ReqBuffLen
			      );
					

	//
	// Send the "Update Version number" request
	//
	ECommSndCmd(
			&DlgHdl,
			&ReqBuff[COMM_N_TCP_HDR_SZ],
			ReqBuffLen,
			&pRspBuff,
			&RspBuffLen
			);
	//
	// decipher the reponse to get the result code sent by the
	// remote WINS
	//			
	RplMsgfUfmUpdVersNoRsp(
				pRspBuff + 4,  //past the opcode
				(LPBYTE)&Rcode_e
			      );

	if (Rcode_e != NMSMSGF_E_SUCCESS)
	{
		DBGPRINT0(ERR, "Remote WINS could not update the version no. of its record");
		WINSEVT_LOG_M(pWrkItm->AddOfRemWins.Add.IPAdd, WINS_EVT_REM_WINS_CANT_UPD_VERS_NO);
FUTURES("Take some corrective action -- maybe")

	}

	//
	// deallocate the request and response buffers
	//
#if 0
	WinsMscDealloc(pReqBuff);
#endif
	ECommFreeBuff(pRspBuff - COMM_HEADER_SIZE);

 } // end of try block
		
except (EXCEPTION_EXECUTE_HANDLER) {

	DWORD  ExcCode = GetExceptionCode();
	DBGPRINT1(EXC, "InfRemWins: Got exception (%x)\n", ExcCode );
	if (ExcCode == WINS_EXC_COMM_FAIL)
	{
		DBGPRINT1(ERR, "InfRemWins: Could not inform WINS (%x) that it should update the version number for a record", pWrkItm->AddOfRemWins.Add.IPAdd);	
		//
		//insert a timer request for retrying
		//
		
FUTURES("Incorporate code to insert a timer request so that we can retry")
	}
	else
	{
		//severe error.
		DBGPRINT0(ERR, "InfRemWins: Some severe error was encountered\n");
	}
	WINSEVT_LOG_M(ExcCode, WINS_EVT_INF_REM_WINS_EXC);
   }	
	//
	// End the dialogue
	//
	ECommEndDlg( &DlgHdl );
	
	DBGLEAVE("InfRemWins\n");
	return;

} // InfRemWins()


STATUS
ProcAddList(
	PCHL_REQ_WRK_ITM_T	pReqWrkItm,
	PNMSMSGF_CNT_ADD_T	pCntAdd,
	LPBOOL			pfAdded
	)

/*++

Routine Description:
	
Arguments:
	pWrkItm - the work item that got queued to the name challenge
		  manager
	pCntAdd - List of addresses returned on a query

Externals Used:
	None
	
Return Value:
	None

Error Handling:

Called by:
	
	ProcRsp	

Side Effects:

Comments:
	The function will never be called when the state
	of the entry to register is a TOMBSTONE or if the entry to register
	is a group.

--*/
{	
	DWORD  i, n;
	DWORD  NoOfAddsToReg;
	STATUS RetStat = WINS_SUCCESS;
        PNMSDB_GRP_MEM_ENTRY_T  pMem;
        PCOMM_ADD_T  pAddInRsp;
	
	DBGENTER("ProcAddList\n");
	*pfAdded = FALSE;  //no address of conflicting entry has yet been
			   //added to list of addresses of record to register

	//
	// If the node to register is a unique record
	//
	if (pReqWrkItm->NodeToReg.EntTyp == NMSDB_UNIQUE_ENTRY)
	{
		NoOfAddsToReg = 1;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].Add =
						pReqWrkItm->AddToReg;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].OwnerId =
						pReqWrkItm->NodeToReg.OwnerId;
		pReqWrkItm->NodeToReg.NodeAdds.Mem[0].TimeStamp =
						pReqWrkItm->NodeToReg.TimeStamp;
		pReqWrkItm->NodeToReg.NodeAdds.NoOfMems = 1;
						
	}
	else  // has to be multihomed (see comment above)
	{
	   NoOfAddsToReg = pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;

	   //
	   // The addresses are already there in NodeToReg.NodeAdds structure
	   //
	
	}

	//
	// If the address(es) to register are not a subset of the addresses
	// returned (i.e. atleast one address to register is not there in
	// the list returned), we return FAILURE.
	//

	//
	// Loop over all addresses to register
	//
	for (i=0; i < NoOfAddsToReg; i++)
	{
		//
		// Compare with each address returned to see if there is
		// a match. Note: pCntAdd->NoOfAdds is > 1 (this function
		// isn't called otherwise).
		//
		for (n=0; n < pCntAdd->NoOfAdds; n++)
		{
PERF("use pointer arithmetic")
			if (pReqWrkItm->NodeToReg.NodeAdds.Mem[i].Add.Add.IPAdd ==
					pCntAdd->Add[n].Add.IPAdd)
			{
				//
				// There is a match, break out so that we can
				// can get to the next address in the list of
				// addresses to register
				//
				break;
			}
		}

		//
		// if there was no match, we have an address to register that
		// either the queried (challenged) node does not have or refuses
		// to divulge to us.  We must reject the registration/refresh
		//
		if (n == pCntAdd->NoOfAdds)
		{
			RetStat = WINS_FAILURE;
			break;
		}
      }

      //
      // The address(es) to register are a subset of the addresses returned
      // by the node (on a query)
      //
      if ( RetStat == WINS_SUCCESS)
      {
       	DWORD Index;

        //
        // Remove those members in the conflicting record that are
        // not in the list returned by the node
        //
	for (
		    i=0, pMem = pReqWrkItm->NodeAddsInCnf.Mem;
			i < min(pReqWrkItm->NodeAddsInCnf.NoOfMems,
				 NMSMSGF_MAX_NO_MULTIH_ADDS);
			i++, pMem++
		    )
        {
		    pAddInRsp =  pCntAdd->Add;
		    for (n=0; n < pCntAdd->NoOfAdds; n++, pAddInRsp++)
		    {
PERF("use pointer arithmetic")
			   if (pMem->Add.Add.IPAdd == pAddInRsp->Add.IPAdd)
			   {
				//
				// There is a match, break out so that we can
				// can get to the next address in the list of
				// addresses in the conflicting record
				//
				break;
			   }
		     }
             if (n == pCntAdd->NoOfAdds)
             {
                //
                // remove the conflicting member from the list
                // This is done by setting its address to NONE.  Later
                // on, we simply won't add this address.
                //
                DBGPRINT3(CHL, "ProcAddList: Removing member (%x) from list of name = (%s)[%x]\n", pMem->Add.Add.IPAdd, pReqWrkItm->NodeToReg.Name, pReqWrkItm->NodeToReg.Name[15]);
                pMem->Add.Add.IPAdd = INADDR_NONE;

             }
        }

        DBGPRINT0(CHL, "ProcAddList: Add conflicting record members\n");

	//
	// The record in conflict has to be ACTIVE
	// (otherwise this function wouldn't have been called -- See
	// the clash functions in nmsnmh.c).  We add all those addresses
	// in the active conflicting record to the list of addresses in
	// the record to register that are not there in it already
	//

	//
	// Add to list of addresses to register all the addresses in
	// the conflicting record.  Note: The conflicting record
	// will not have any address in common with the record
	// to register (common addresses were removed in the clash
	// handling functions of nmsnmh.c via MemInGrp())
	//
	
	//
	// NOTE: the NoOfMems of the NodeAddsInCnf field is guaranteed
	// to be > 0
	//
        //
        // Also NOTE: If the challenged node returned us a list > 25 members
        // long and our list of members to register can no accommodate
        // all the members that need to be added, we will just add those
        // that can be added without violating the NMSMSGF_MAX_NO_MULTIH_ADDS
        // constraint.  The members added could be 0 if we already have
        // the first 25 in our list.  Neverthless we will update our
        // db entry.  This is because some of the conflicting record's
        // members may be old. They will get removed this way (we don't
        // compare the list returned by the challenged node with what is
        // in the conflicting record currently, so old entries will be
        // there until they are scavenged or fall off).
        //
	Index = pReqWrkItm->NodeToReg.NodeAdds.NoOfMems;
	pMem = pReqWrkItm->NodeAddsInCnf.Mem;
	for (   i=0;
		i < min(pReqWrkItm->NodeAddsInCnf.NoOfMems,
				 (NMSMSGF_MAX_NO_MULTIH_ADDS - Index));
			i++, pMem++
	     )
	{
		//
		// we need to add the conflicting record's
		// address into the registering record's
		// list of addresses
		//
                if (pMem->Add.Add.IPAdd != INADDR_NONE)
                {
		  pReqWrkItm->NodeToReg.NodeAdds.Mem[
			 	pReqWrkItm->NodeToReg.NodeAdds.NoOfMems
						] = *pMem;
		  pReqWrkItm->NodeToReg.NodeAdds.NoOfMems++;
                }
	}	
		
	//
	// Setting *pfAdded to TRUE will increment the version number.
	// We do want to increment the version number because
	// the reason we are here means one of the following:
	//
	//  	1)We got a refresh (unique) for an address not in the
	//        conf. rec.
	//	2)We got a registration for an address that is/is not
	// 	  there in the conflicting record.
	//
	//   For the first case above, we definitely want to increment
	//   the version no.  For the second case, it is not strictly
	//   required but is preferable for syncing up entries at
	//   different WINS servers right away.
	//
	*pfAdded = TRUE;

	//
	// If the record to register was a unique record
	// change its type to MULTIHOMED.
	//
	if ( NMSDB_ENTRY_UNIQUE_M(pReqWrkItm->NodeToReg.EntTyp) )
	{
		pReqWrkItm->NodeToReg.EntTyp = NMSDB_MULTIHOMED_ENTRY;
	}

      }

      DBGLEAVE("ProcAddList\n");
      return(RetStat);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nmsscv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        nmsscv.c

Abstract:
        This module contains functions that implement the functionality
        associated with scavenging

Functions:
        NmsScvInit,
        ScvThdInitFn,
        DoScavenging
        ReconfigScv

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Apr-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include "wins.h"
#include "winsevt.h"
#include "nms.h"
#include "nmsnmh.h"
#include "winsmsc.h"
#include "winsdbg.h"
#include "winsthd.h"
#include "winscnf.h"
#include "nmsdb.h"
#include "winsque.h"
#include "nmsscv.h"
#include "rpl.h"
#include "rplpull.h"
#include "rplmsgf.h"
#include "comm.h"
#include "winsintf.h"
#include "winstmm.h"




#ifdef WINSDBG
#define  SCV_EVT_NM                TEXT("ScvEvtNm")
#else
#define  SCV_EVT_NM                NULL
#endif

//
// The no. of retries and the time interval (in secs) between each retry
// when trying to establish comm. with a WINS for the purpose of verifying
// old active replicas in the local db
//

#define         VERIFY_NO_OF_RETRIES                0        //0 retries
#define                VERIFY_RETRY_TIME_INTERVAL        30        //30 secs


//
// We get rid of extraneous log files every 3 hours.
//
FUTURES("Use symbols for times - defined in winscnf.h")
#define         ONE_HOUR                   3600
#define         THREE_HOURS                10800
#define         TWENTY_FOUR_HOURS          (3600 * 24)
#define         THREE_DAYS                 (TWENTY_FOUR_HOURS * 3)

#define         PERIOD_OF_LOG_DEL          THREE_HOURS
#define         PERIOD_OF_BACKUP           TWENTY_FOUR_HOURS



#define         LOG_SCV_MUL_OF_REF_INTVL   6

/*
 *        Local Macro Declarations
 */
//
// macro to set the state of a record in an in-memory data structure to
// that specified as an arg. if it has timed out.  We check whether
// CurrTime is greater than pRec Timestamp before doing the other if test
// because these numbers otherwise the subtraction will produce a positive
// number even if current time is older than the timestamp (say the date
// on the pc was changed)
//
#define SET_STATE_IF_REQD_M(pRec, CurrentTime, TimeInterval, State, Cntr)   \
                {                                                           \
                        pRec->fScv = FALSE;                                 \
                        if (CurrentTime >= (time_t)(pRec)->TimeStamp)       \
                        {                                                   \
                                NMSDB_SET_STATE_M(                  \
                                                  (pRec)->Flag,     \
                                                  (State)           \
                                                 );                 \
                                (pRec)->NewTimeStamp = (pRec)->TimeStamp +  \
                                                         TimeInterval;  \
                                        (pRec)->fScv = TRUE;            \
                                        NoOfRecsScv++;                  \
                                        (Cntr)++;                       \
                        }                                               \
                }

#define DO_SCV_EVT_NM                TEXT("WinsDoScvEvt")

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
*/

HANDLE                NmsScvDoScvEvtHdl;//event signaled to initiate scavenging

//
// The min. version number to start scavenging from (for local records)
//
VERS_NO_T          NmsScvMinScvVersNo;
volatile BOOL      fNmsScvThdOutOfReck;
DWORD              sMcastIntvl;

/*
 *        Local Variable Definitions
*/
FUTURES("Put all these in a structure and allocate it. Initialize sBootTime")
FUTURES("in nms.c")

STATIC time_t      sBootTime;       //Boot Time
STATIC time_t      sLastRefTime;    //Last time we looked for active
                                    // entries
STATIC time_t      sLastVerifyTime; //Last time we looked for replicais
STATIC time_t      sLastFullVerifyTime; //Last time we did full validation
STATIC time_t      sLastAdminScvTime;   //Last time admin. did scavenging
STATIC time_t      sLastTombTime;   //Last time we looked for replica
                                    // tombstones


STATIC BOOL        sfAdminForcedScv;  //set to TRUE if the administrator
                                      //forces scavenging
STATIC time_t      sLastDbNullBackupTime;//Last time we deleted extraneous
                                         //log files
STATIC time_t      sLastDbBackupTime; //Last time we last did full backup
#if MCAST > 0
STATIC time_t      sLastMcastTime; //Last time we last did full backup
#endif

/*
 *        Local Function Prototype Declarations
 */
STATIC
STATUS
DoScavenging(
        PNMSSCV_PARAM_T  pScvParam,
        BOOL             fSignaled,
        LPBOOL           pfResetTimer,
        LPBOOL           pfSpTimeOver
        );
STATIC
DWORD
ScvThdInitFn(
        IN LPVOID pThdParam
        );

STATIC
VOID
ReconfigScv(
 PNMSSCV_PARAM_T  pScvParam
        );

STATIC
VOID
UpdDb(
        IN  PNMSSCV_PARAM_T      pScvParam,
        IN  PRPL_REC_ENTRY_T     pStartBuff,
        IN  DWORD                NoOfRecs,
        IN  DWORD                NoOfRecsToUpd
     );

STATIC
STATUS
VerifyDbData(
        PNMSSCV_PARAM_T       pScvParam,
        time_t                CurrentTime,
        DWORD                 Age,
        BOOL                  fForce,
        BOOL                  fPeriodicCC
        );

STATIC
STATUS
PickWinsToUse(
 IN PCOMM_ADD_T pVerifyWinsAdd,
 IN PCOMM_ADD_T pOwnerWinsAdd,
 IN BOOL        fUseRplPnr,
 OUT LPBOOL     pfNonOwnerPnr,
 OUT LPBOOL     pRplType
 );

STATIC
STATUS
EstablishCommForVerify(
  PCOMM_ADD_T pWinsAdd,
  PCOMM_HDL_T pDlgHdl
);

STATIC
VOID
PullAndUpdateDb(
  PCOMM_HDL_T  pDlgHdl,
  PCOMM_ADD_T  pWinsAdd,
  PRPL_REC_ENTRY_T pRspBuff,
  DWORD        WinsIndex,
  VERS_NO_T    MinVersNo,
  VERS_NO_T    MaxVersNo,
  DWORD        RplType,
  DWORD        NoOfLocalRecs,
  time_t       CurrentTime,
  PNMSSCV_PARAM_T pScvParam,
  BOOL         fNonOwnerPnr,
  LPDWORD      pTotNoOfPulledRecs
 );

STATIC
__inline
VOID
FreeDbMemory(
     LPVOID pStartBuff,
     DWORD  NoOfLocalDbRecs,
     PWINSTHD_TLS_T pTls
 );

STATIC
VOID
ChkConfNUpd(
#if SUPPORT612WINS > 0
        IN  PCOMM_HDL_T       pDlgHdl,
#endif
        IN  PCOMM_ADD_T       pOwnerWinsAdd,
        IN  DWORD             RplType,
        IN  DWORD             OwnerId,
        IN  PRPL_REC_ENTRY_T  *ppLocalDbRecs,
        IN  LPBYTE            pPulledRecs,
        IN  DWORD             *pNoOfLocalDbRecs,
        IN  time_t            CurrentTime,
        IN  DWORD             VerifyTimeIntvl,
        IN  BOOL              fNonOwnerPnr,
        OUT LPDWORD           pNoOfPulledRecs,
        OUT PVERS_NO_T        pMaxVersNo
        );

STATIC
VOID
CompareWithLocalRecs(
        IN     VERS_NO_T        VersNo,
        IN     LPBYTE           pName,
        IN     NMSDB_ENTRY_STATE_E  RecState_e,
        IN OUT PRPL_REC_ENTRY_T *ppLocalDbRecs,
        IN OUT DWORD            *pNoOfLocalRecs,
        IN     time_t           CurrentTime,
        IN     BOOL             fNonOwnerPnr,
        IN OUT DWORD            *pNoOfRecsDel,
        OUT    PNMSSCV_REC_ACTION_E  pRecAction_e
        );
STATIC
VOID
DoBackup(
        PNMSSCV_PARAM_T  pScvParam,
        LPBOOL           pfThdPrNormal
      );

#if MCAST > 0
VOID
DoMcastSend(
   DWORD_PTR CurrentTime,
   DWORD Code,
   DWORD fNow
 );
#endif
//
// function definitions start here
//

VOID
NmsScvInit(
        VOID
        )

/*++

Routine Description:
        This function is called to initialize the scavenger thread

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        //
        // Create the  event handle signaled when scavenging has to be
        // initiated.  This  event is signaled by an RPC thread
        // to start scavenging
        //
        WinsMscCreateEvt(
                          DO_SCV_EVT_NM,
                          FALSE,                //auto-reset
                          &NmsScvDoScvEvtHdl
                        );

        //
        // initialize sLastTombTime (used for determining if we need to look for
        // tombstones of replicas) and sLastVerifyTime to current time.
        // Don't forget RefreshTime
        //
        (void)time(&sBootTime);
        sLastVerifyTime     = //fall through
        sLastTombTime       = //fall through
        sLastFullVerifyTime = //fall through
        sLastAdminScvTime   = //fall through
        sLastRefTime        = sBootTime;


        //
        // Initialize the queue used by the scavenger thread
        //
        WinsQueInit(TEXT("NmsScvEvt"), &QueWinsScvQueHd);


        //
        // Create the Scavenger thread
        //
        WinsThdPool.ScvThds[0].ThdHdl = WinsMscCreateThd(
                          ScvThdInitFn,
                          NULL,
                          &WinsThdPool.ScvThds[0].ThdId
                        );


        //
        // Init WinsThdPool properly
        //
        WinsThdPool.ScvThds[0].fTaken  = TRUE;
        WinsThdPool.ThdCount++;

        return;
}

VOID
GetIntervalToDefSpTime(
  LPDWORD pTimeInt
)

/*++

Routine Description:
  This function finds the time interval in seconds upto the Default Specific
  time.

Arguments:
   OUT pTimeInt - Time Interval in seconds

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{

   SYSTEMTIME CurrTime;
   GetSystemTime(&CurrTime);

   //
   // If default time hour is greater then current hour, add 3600
   // for the number of hours it is ahead. Then subtract the the
   // number of minutes and seconds in the current time
   //
   if (WINSCNF_DEF_CC_SP_HR > CurrTime.wHour)
   {
      *pTimeInt = (WINSCNF_DEF_CC_SP_HR - CurrTime.wHour) * 3600;
      *pTimeInt -= ((CurrTime.wMinute * 60) + (CurrTime.wSecond));
   }
   else //default hour is same or less than current hour
   {
       *pTimeInt = (CurrTime.wHour - WINSCNF_DEF_CC_SP_HR) * 3600;
       *pTimeInt += (CurrTime.wMinute * 60) + (CurrTime.wSecond);
   }
   return;

}

DWORD
ScvThdInitFn(
        IN LPVOID pThdParam
        )

/*++

Routine Description:
        This function is the initialization function for the scavenger
        thread

Arguments:
        pThdParam - Not used

Externals Used:
        None

Return Value:

   Success status codes --   should never return
   Error status codes  --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        BOOL            fSignaled = FALSE;
        HANDLE          ThdEvtArr[3];
        DWORD           IndexOfHdlSignaled;
        NMSSCV_PARAM_T  ScvParam;
        DWORD           SleepTime;
        time_t          CurrentTime;
        BOOL            fThdPrNormal;
        DWORD           TimeInt;
        QUE_SCV_REQ_WRK_ITM_T  WrkItm;
        BOOL            fResetTimer = TRUE;
        time_t          AbsTime;
        time_t          LastCC;
        BOOL            fTimerRunning = FALSE;
        BOOL            fSpTimeOver = FALSE;

        UNREFERENCED_PARAMETER(pThdParam);


        ThdEvtArr[0] = NmsTermEvt;
        ThdEvtArr[1] = WinsCnf.CnfChgEvtHdl;
        ThdEvtArr[2] = QueWinsScvQueHd.EvtHdl;
try {
        /*

           Initialize the thread with the database
        */
        NmsDbThdInit(WINS_E_NMSSCV);
        DBGMYNAME("Scavenger Thread");

        //
        // get the scavenging parameters from the configuration structure.
        // Note; There is no need for any synchronization here since
        // we are executing in the main thread (process is initalizing
        // at invocation).
        //
        ScvParam.ScvChunk          = WinsCnf.ScvChunk;
        ScvParam.RefreshInterval   = WinsCnf.RefreshInterval;
        ScvParam.TombstoneInterval = WinsCnf.TombstoneInterval;
        ScvParam.TombstoneTimeout  = WinsCnf.TombstoneTimeout;
        ScvParam.VerifyInterval    = WinsCnf.VerifyInterval;
        ScvParam.PrLvl             = WinsCnf.ScvThdPriorityLvl;

        //
        // Load up the CC parameters
        //
        ScvParam.CC.TimeInt        = WinsCnf.CC.TimeInt;
        ScvParam.CC.fSpTime        = WinsCnf.CC.fSpTime;
        ScvParam.CC.SpTimeInt      = WinsCnf.CC.SpTimeInt;
        ScvParam.CC.MaxRecsAAT     = WinsCnf.CC.MaxRecsAAT;
        ScvParam.CC.fUseRplPnrs    = WinsCnf.CC.fUseRplPnrs;

        sMcastIntvl                = WinsCnf.McastIntvl;

       //
       // if backup path is not NULL, copy it into ScvParam structure
       //
       if (WinsCnf.pBackupDirPath != NULL)
       {
                (VOID)strcpy(ScvParam.BackupDirPath, WinsCnf.pBackupDirPath);
       }
       else
       {
                ScvParam.BackupDirPath[0] = EOS;
       }
       //
       // Use a stack variable WrkItm.  Schedule it with the timer thread
       // if required (will happen only if the CC key is present).
       //
FUTURES("Set two work items - for two timer requests. One to fire off at a")
FUTURES("specific time.  The other one for the time interval")
       WrkItm.Opcode_e = WINSINTF_E_VERIFY_SCV; //verify replicas
       WrkItm.Age      = 0;                     //no matter how recent
       WrkItm.fForce   = TRUE;                  //force verification even if
                                                //we did it recently

LOOP:
  try {

        while (TRUE)
        {
                sfAdminForcedScv = FALSE;

                SleepTime = min(min(sMcastIntvl, ScvParam.RefreshInterval),
                                         PERIOD_OF_LOG_DEL);
                if (fResetTimer)
                {
                    if (fTimerRunning)
                    {
                         //
                         // Delete the old timer request.  This should
                         // deallocate it
                         //
                         DBGPRINT0(SCV, "ScvThdInit: Deleting Timer requests\n");
                         WinsTmmDeleteReqs(WINS_E_NMSSCV);
                         fTimerRunning = FALSE;
                    }
                    //
                    // If the time interval for CC is not MAXULONG, it means
                    // user wants CC to be done. TimeInt will be MAXULONG if
                    // there is no Wins\Paramaters\CC key in the registry
                    //
                    if (ScvParam.CC.TimeInt != MAXULONG)
                    {
                      //
                      // if no specific time was indicated, use default (2 am).
                      //
                      if (!fSpTimeOver)
                      {
                        if (!ScvParam.CC.fSpTime)
                        {
                         //
                         // Get the current hour. Schedule a wakeup at exact
                         // 2 am.
                         //
                         GetIntervalToDefSpTime(&TimeInt);
                        }
                        else
                        {
                          TimeInt = ScvParam.CC.SpTimeInt;
                        }
                      }
                      else
                      {
                         TimeInt = ScvParam.CC.TimeInt;
                      }

                      DBGPRINT1(SCV, "ScvThdInit: TimeInt is (%d)\n", TimeInt);

                      // Insert a timer request.  Let the Timer thread create
                      // a work item for it.
                      //
                      (VOID)time(&AbsTime);
                      if( !fSpTimeOver )
                      {
                          AbsTime += (time_t)TimeInt;
                          LastCC = AbsTime;
                      }
                      else
                      {
                          do
                          {
                              LastCC += (time_t)TimeInt;
                          }
                          while( LastCC <= (AbsTime + WINSCNF_MIN_VALID_INTER_CC_INTVL));
                          AbsTime = LastCC;
                      }
                      WinsTmmInsertEntry(
                           NULL,
                           WINS_E_NMSSCV,
                           QUE_E_CMD_SET_TIMER,
                           FALSE,  //not used presently
                           AbsTime,
                           TimeInt,
                           &QueWinsScvQueHd,
                           &WrkItm,
                           0,
                           NULL
                            );
                      fTimerRunning = TRUE;
                      fResetTimer   = FALSE;
                   }
                }

                //
                // Do a timed wait until signaled for termination
                //
                // Multiply the sleep time by 1000 since WinsMscWaitTimed
                // function expects the time interval in msecs.
                //
#ifdef WINSDBG
                {
                   time_t ltime;
                   (VOID)time(&ltime);
                   DBGPRINT2(SCV, "ScvThdInitFn: Sleeping for (%d) secs.  Last scavenging took = (%d secs)\n", SleepTime, ltime - CurrentTime);
                }
#endif
                WinsMscWaitTimedUntilSignaled(
                                ThdEvtArr,
                                sizeof(ThdEvtArr)/sizeof(HANDLE),
                                &IndexOfHdlSignaled,
                                SleepTime * 1000,
                                &fSignaled
                                        );

                //
                // We can be signaled for termination, configuration change,
                // by the admin to do general or specific scavenging or by
                // the timer thread
                //
                if (fSignaled)
                {
                      if (IndexOfHdlSignaled == 0)
                      {
                              WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
                      }
                      else
                      {
                        if (IndexOfHdlSignaled == 1)
                        {
                           ReconfigScv(&ScvParam);

                           //
                           // Reset the timer
                           //
                           fResetTimer = TRUE;
                           continue;
                        }

                        //
                        // else, this must be the signal to initiate scavenging
                        // (by the admin. or the timer thread)
                        //
                        sfAdminForcedScv = TRUE;
                      }
                }

           //
           // Get the current time and check if we need to do scavenging
           //
           (void)time(&CurrentTime);

           if (
                ( (CurrentTime > sLastRefTime)
                        &&
                ((CurrentTime - sLastRefTime) >= (time_t)ScvParam.RefreshInterval))
                                ||
                   sfAdminForcedScv
              )
           {

                //
                // Do scavenging
                //
                NmsDbOpenTables(WINS_E_NMSSCV);
                //DBGPRINT0(ERR, "SCVTHDINITFN: OPENED tables\n");
                (VOID)DoScavenging(&ScvParam, fSignaled, &fResetTimer, &fSpTimeOver);
                NmsDbCloseTables();
                //DBGPRINT0(ERR, "SCVTHDINITFN: CLOSED tables\n");

                fTimerRunning = !fResetTimer;

          }
          //
          // If enough time has expired to warrant a purging of old log
          // files, do it (check done in DoBackup). We don't do this
          // on an admin. trigger since it may take long.
          //
         if (!sfAdminForcedScv)
         {
#if MCAST > 0
                 DoMcastSend(CurrentTime, COMM_MCAST_WINS_UP, FALSE);
#endif

                 fThdPrNormal = TRUE;
                 DoBackup(&ScvParam, &fThdPrNormal);
         }

    }  // end of while (TRUE)
} //end of inner try {..}

except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("ScvThdInit");

        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SCV_EXC);
 }
        goto LOOP;
} //end of outer try {..}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("ScvThdInit");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_SCV_EXC);

        //
        // Let us terminate the thread gracefully
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);

        }

        //
        // We should never get here
        //
        return(WINS_FAILURE);
}

STATUS
DoScavenging(
        PNMSSCV_PARAM_T        pScvParam,
        BOOL                   fSignaled,
        LPBOOL                 pfResetTimer,
        LPBOOL                 pfSpTimeOver
        )

/*++

Routine Description:
        This function is responsible for doing all scavenging

Arguments:
        None

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        ScvThdInitFn()

Side Effects:

Comments:
        None
--*/

{
        PRPL_REC_ENTRY_T        pStartBuff;
        PRPL_REC_ENTRY_T        pRec;
        DWORD                   BuffLen;
        DWORD                   NoOfRecs = 0;
        time_t                  CurrentTime;
        DWORD                   NoOfRecsScv;  //no of records whose state has
                                              //been affected
        DWORD                   TotNoOfRecsScv = 0;  //Total no of records
                                                     //whose state has
                                                     //been affected
        VERS_NO_T               MyMaxVersNo;
        DWORD                   i;            //for loop counter
        DWORD                   RecCnt;
        LARGE_INTEGER           n;            //for loop counter
        LARGE_INTEGER           Tmp;
        DWORD                   State;        //stores state of a record
        VERS_NO_T               VersNoLimit;
        DWORD                   NoOfRecChgToRelSt  = 0;
        DWORD                   NoOfRecChgToTombSt = 0;
        DWORD                   NoOfRecToDel           = 0;
        DWORD                   MaxNoOfRecsReqd = 0;
        BOOL                    fLastEntryDel = FALSE;
        PWINSTHD_TLS_T          pTls;
        PRPL_REC_ENTRY_T        pTmp;
        BOOL                    fRecsExistent = FALSE;
        VERS_NO_T               MinScvVersNo;
#ifdef WINSDBG
        DWORD                   SectionCount = 0;
#endif
        PQUE_SCV_REQ_WRK_ITM_T  pScvWrkItm;
        PQUE_SCV_REQ_WRK_ITM_T  pClientWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T  pTmmWrkItm;
        QUE_SCV_OPC_E           Opcode_e;
        DWORD                   Age;
        STATUS                  RetStat;
        BOOL                    fForce;
        BOOL                    fPeriodicCC = FALSE;


      DBGENTER("DoScavenging\n");
      *pfResetTimer = FALSE;
      while (TRUE)
      {

try {
        if (fSignaled)
        {
              RetStat = QueRemoveScvWrkItm((LPVOID *)&pScvWrkItm);
              if (RetStat == WINS_NO_REQ)
              {
                    break;
              }
              else
              {
                    //
                    //  If we got signaled by the timer thread, get the pointer
                    //  to the local WrkItm of ScvThdInitFn()
                    //
                    if (pScvWrkItm->CmdTyp_e == QUE_E_CMD_TIMER_EXPIRED)
                    {
                      DBGPRINT0(SCV, "DoScavenging: Timer Thd. triggered scavenging\n");
                      pClientWrkItm = ((PQUE_TMM_REQ_WRK_ITM_T)(pScvWrkItm))->pClientCtx;
                      fPeriodicCC   = TRUE;

                      if (!*pfResetTimer)
                      {
                         *pfResetTimer = TRUE;
                      }

                      //
                      // If *pfSpTimeOver is false, it means that the timer
                      // thread wokr us up at SpTime specified in registry
                      // (or at 2am if SpTime) was not specifid in registry.
                      // Set *pfSpTimeOver to TRUE so that from hereon we
                      // use TimeInterval specified in the registry as
                      // the time interval
                      //
                      if (!*pfSpTimeOver)
                      {
                        *pfSpTimeOver = TRUE;
                      }
                    }
                    else
                    {
                      pClientWrkItm = pScvWrkItm;
                    }


                    Opcode_e = pClientWrkItm->Opcode_e;
                    Age      = pClientWrkItm->Age;
                    fForce   = (BOOL)pClientWrkItm->fForce;
                    if (*pfResetTimer)
                    {
                      WinsTmmDeallocReq((PQUE_TMM_REQ_WRK_ITM_T)pScvWrkItm);
                    }
                    else
                    {
                      //
                      // Free the admin. initiated rpc work item
                      //
                      WinsMscHeapFree(NmsRpcHeapHdl, pScvWrkItm);
                    }
              }
        }
        else
        {
                //
                // timer expiry of the wait call
                //
                Opcode_e = WINSINTF_E_SCV_GENERAL;
                Age      = pScvParam->VerifyInterval;
                fForce   = FALSE;         // no forceful scavenging
        }


        if (sfAdminForcedScv && !fPeriodicCC)
        {
           WinsIntfSetTime( NULL,  WINSINTF_E_ADMIN_TRIG_SCV );
           DBGPRINTTIME(SCV, "STARTING AN ADMIN. TRIGGERED SCAVENGING CYCLE ", LastATScvTime);
           DBGPRINTTIME(DET, "STARTING AN ADMIN. TRIGGERED SCAVENGING CYCLE ", LastATScvTime);
        }
        else
        {
           WinsIntfSetTime( NULL, WINSINTF_E_PLANNED_SCV);
           DBGPRINTTIME(SCV, "STARTING A SCAVENGING CYCLE ", LastPScvTime);
           DBGPRINTTIME(DET, "STARTING A SCAVENGING CYCLE ", LastPScvTime);
        }

        //
        // get the current time
        //
        (void)time(&CurrentTime);

        if (Opcode_e == WINSINTF_E_SCV_GENERAL)
        {

          WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCVENGING_STARTED);
          //
          // record current time in sLastRefTime
          //
          sLastRefTime = CurrentTime;
          EnterCriticalSection(&NmsNmhNamRegCrtSec);
          //
          // Store the max. version number in a local since the max. version
          // number is incremented by several threads
          //
          NMSNMH_DEC_VERS_NO_M(
                             NmsNmhMyMaxVersNo,
                             MyMaxVersNo
                            );
          //
          // synchronize with RplPullPullSpecifiedRange
          //
          MinScvVersNo = NmsScvMinScvVersNo;

          LeaveCriticalSection(&NmsNmhNamRegCrtSec);

          //
          // Set thread priority to the level indicated in the WinsCnf
          // structure
          //
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );

          // log a detailed event showing the range of version_numbers that
          // are being scavenged. This helps finding out why some particuler
          // record is stalled in the database. (If it doesn't fall in this
          // range it means the scavenger is not even looking at it).
          WinsEvtLogDetEvt(
              TRUE,                 // Informational event
              WINS_EVT_SCV_RANGE,   // event ID
              NULL,                 // NULL filename
              __LINE__,             // line number where this event is logged
              "dddd",               // data section format
              MinScvVersNo.LowPart, MinScvVersNo.HighPart,  // data: 2nd, 3rd words
              MyMaxVersNo.LowPart, MyMaxVersNo.HighPart);   // data: 4th, 5th words

          Tmp.QuadPart = pScvParam->ScvChunk;
          for (
                n.QuadPart = MinScvVersNo.QuadPart; // min. version no. to
                                                    //start from
                LiLeq(n, MyMaxVersNo);      // until we reach the max. vers. no
                                            // no third expression here
            )
          {
                BOOL        fGotSome = FALSE;

                //
                // The max. version number to ask for in one shot.
                //
                VersNoLimit.QuadPart = LiAdd(n, Tmp);

                //
                // If my max. version number is less than the version number
                // computed above, we do not specify a number for the max.
                // records.  If however, my max. vers. no is more, we specify
                // the number equal to the chunk specified in Tmp
                //
                if (LiLeq(MyMaxVersNo, VersNoLimit))
                {
                        MaxNoOfRecsReqd = 0;
                }
                else
                {
                        MaxNoOfRecsReqd = Tmp.LowPart;
                }

                // log a detailed event saying what are the exact records that are retrieved
                // from the database for scavenging. This helps finding out whether the loop is
                // not broken earlier that expected leaving records not scavenged.
                WinsEvtLogDetEvt(
                      TRUE,                                         // Informational event
                      WINS_EVT_SCV_CHUNK,                           // event ID
                      NULL,                                         // NULL filename
                      __LINE__,                                     // line number where this event is logged
                      "ddddd",                                      // data section format
                      MaxNoOfRecsReqd,                              // data: 2nd word
                      n.LowPart, n.HighPart,                        // data: 3rd, 4th words
                      MyMaxVersNo.LowPart, MyMaxVersNo.HighPart);   // data: 5th, 6th words

                /*
                * Call database manager function to get all the records. owned
                * by us. No need to check the return status here
                */
                NmsDbGetDataRecs(
                          WINS_E_NMSSCV,
                          pScvParam->PrLvl,
                          n,
                          MyMaxVersNo,  //Max vers. no
                          MaxNoOfRecsReqd,
                          FALSE,          //we want data recs upto MaxVers
                          FALSE,          //not interested in replica tombstones
                          NULL,           //must be NULL since we are not
                                          //doing scavenging of clutter
                          &NmsLocalAdd,
                          FALSE,           //both dynamic & static records should be considered
                          WINSCNF_RPL_DEFAULT_TYPE, //no use here
                          (LPVOID *)&pStartBuff,
                          &BuffLen,
                          &NoOfRecs
                        );


                //
                // If no of records retrieved is 0, we should break out of
                // the loop
                //
                if (NoOfRecs == 0)
                {

                        //
                        // deallocate the heap that was  created
                        //
                        // NmsDbGetDataRecs always allocates a buffer (even if
                        // the number of records is 0).  Let us deallocate it
                        //
                        GET_TLS_M(pTls);
                        ASSERT(pTls->HeapHdl != NULL);
                        WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
                        WinsMscHeapDestroy(pTls->HeapHdl);
                        break;
                }


                fGotSome = TRUE;
                if (!fRecsExistent)
                {
                        fRecsExistent = TRUE;
                }
                NoOfRecsScv  = 0;        // init the counter to 0

                (void)time(&CurrentTime);

                for (
                        i = 0, pRec = pStartBuff;
                        i < NoOfRecs;
                        i++
                    )
                {

                        State =  NMSDB_ENTRY_STATE_M(pRec->Flag);

                        switch (State)
                        {

                            case(NMSDB_E_ACTIVE):
                                // don't touch active static records
                                if (!NMSDB_IS_ENTRY_STATIC_M(pRec->Flag))
                                {
                                    SET_STATE_IF_REQD_M(
                                            pRec,
                                            CurrentTime,
                                            pScvParam->TombstoneInterval,
                                            NMSDB_E_RELEASED,
                                            NoOfRecChgToRelSt
                                                       );
                                }
                                break;

                            case(NMSDB_E_RELEASED):
                                // a static record can't become released, but who knows...
                                // just making sure we don't touch statics in this case
                                if (!NMSDB_IS_ENTRY_STATIC_M(pRec->Flag))
                                {
                                    SET_STATE_IF_REQD_M(
                                            pRec,
                                            CurrentTime,
                                            pScvParam->TombstoneTimeout,
                                            NMSDB_E_TOMBSTONE,
                                            NoOfRecChgToTombSt
                                                       );
                                }
                                break;

                            case(NMSDB_E_TOMBSTONE):

FUTURES("Redesign, so that the if condition is not executed multiple times");
                                //
                                //If there are records to delete and we have
                                //been up and running for at least 3 days, go
                                //ahead and delete them.  The records should
                                //have replicated to atleast one partner by
                                //now.
                                if ((CurrentTime - sBootTime) >= THREE_DAYS ||
                                    sfNoLimitChk)
                                {
                                  SET_STATE_IF_REQD_M(
                                        pRec,
                                        CurrentTime,
                                        pScvParam->TombstoneTimeout, //no use
                                        NMSDB_E_DELETED,
                                        NoOfRecToDel
                                                   );
                                }
                                break;

                           default:
                                DBGPRINT1(EXC, "DoScavenging: Weird State of Record (%d)\n", State);
                                WINSEVT_LOG_M(WINS_EXC_FAILURE, WINS_EVT_SFT_ERR);
                                // Just change the state of the record to tombstone and continue
                                // with scavenging.
                                NMSDB_SET_STATE_M(pRec->Flag, NMSDB_E_TOMBSTONE);
                                break;
                        }

                        pRec = (PRPL_REC_ENTRY_T)(
                                   (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );
                }


                //
                // Make pTmp point to the last record in the
                // buffer.
                //
                pTmp = (PRPL_REC_ENTRY_T)(
                                    (LPBYTE)pRec -   RPL_REC_ENTRY_SIZE);

                //
                // If one or more records need to be scavenged
                //
                if (NoOfRecsScv > 0)
                {
                        if  (NoOfRecToDel > 0)
                        {

                           //
                           // If the most recent record in this chunk has
                           // to be deleted, let us record that fact in a
                           // boolean.
                           // If in the scavenging of the next chunk, the
                           // most recent record is not deleted, the boolean
                           // will be reset.  At this point we don't know
                           // whether or not there is even another record
                           // more recent than this one (the next time, we
                           // retrieve records, we may not get any)
                           //
CHECK("This if test is most probably not required. Get rid of it")
                           if (LiLeq(pTmp->VersNo, MyMaxVersNo))
                           {
                                //
                                // If entry is marked for deletion
                                //
                                if (NMSDB_ENTRY_DEL_M(pTmp->Flag))
                                {
                                        fLastEntryDel = TRUE;
                                }
                                else
                                {
                                        fLastEntryDel = FALSE;
                                }
                           }

                        }
                        else
                        {
                                fLastEntryDel = FALSE;
                        }


                        UpdDb(
                                pScvParam,
                                pStartBuff,
                                NoOfRecs,
                                NoOfRecsScv
                             );
                        TotNoOfRecsScv += NoOfRecsScv;
                }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET,"DoScavenging: NO RECORDS NEED TO BE SCAVENGED AT THIS TIME\n");
                }
#endif


                //
                // get pointer to TLS for accessing the heap hdl later on
                //
                GET_TLS_M(pTls);

                //
                // if we specified a max. no. and the no. of recs retrieved
                // is less than that, clearly there are no more records to
                // retrieve.  Get rid of the buffer and break out of the loop
                //
                if ((MaxNoOfRecsReqd > 0) && (NoOfRecs < MaxNoOfRecsReqd))
                {
                        //
                        // Since the number of records we retrieved were
                        // less than the max. we had specified, it means that
                        // there are no more records to retrieve. Break out of
                        // the for loop
                        //

                        //
                        // destroy the heap that was allocated
                        //
                        for (RecCnt=0, pRec = pStartBuff; RecCnt<NoOfRecs; RecCnt++)
                        {
                            WinsMscHeapFree(pTls->HeapHdl, pRec->pName);
                            pRec = (PRPL_REC_ENTRY_T)(
                                   (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );
                        }

                        WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
                        WinsMscHeapDestroy(pTls->HeapHdl);
                        break;
                }
                //
                // Set n to the highest version number retrieved if it is
                // more than what n would be set to prior to the next
                // iteration.
                //
                // At the next iteration, n will be compared with the highest
                // version number we have. If equal, then we don't have to
                // iterate anymore (useful when the highest version number
                // is very high but there are one or more records with low
                // version numbers
                //
                if (LiGtr(pTmp->VersNo, VersNoLimit))
                {
                        n = pTmp->VersNo;
                }
                else
                {
                        n = VersNoLimit;
                }

                //
                // destroy the heap that was allocated
                //
                for (RecCnt=0, pRec = pStartBuff; RecCnt<NoOfRecs; RecCnt++)
                {
                     WinsMscHeapFree(pTls->HeapHdl, pRec->pName);
                     pRec = (PRPL_REC_ENTRY_T)(
                                   (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );
                }

                WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
                WinsMscHeapDestroy(pTls->HeapHdl);

           } // end of for loop for looping over records

           WINSEVT_LOG_INFO_D_M(TotNoOfRecsScv, WINS_EVT_SCV_RECS);
           WINSDBG_INC_SEC_COUNT_M(SectionCount);


           //
           // If the last scavenging action was a deletion, it means that
           // we deleted the highest version numbered record owned by
           // us.  Let us therefore update the Special record that records
           // this version number.
           //
           if (fLastEntryDel)
           {
                WinsMscSetThreadPriority(
                                    WinsThdPool.ScvThds[0].ThdHdl,
                                    THREAD_PRIORITY_NORMAL
                                         );

                (VOID)NmsDbUpdHighestVersNoRec(
                                NULL,  //no pTls
                                MyMaxVersNo,
                                TRUE  //enter critical section
                                        );
                WinsMscSetThreadPriority(
                                    WinsThdPool.ScvThds[0].ThdHdl,
                                          pScvParam->PrLvl
                                        );
           }
           (void)time(&CurrentTime);
           //
           // Let us get rid of the replica tombstones if sufficient time has
           // elapsed since the last time we did this. Exception: If the
           // administrator has requested scavenging, let us do it now.
           // Even if admin. requests it we don't do it unless we have been
           // up and running for atleast 3 days.  This is in line with our
           // philosophy of being absolutely robust even when admin. makes
           // mistakes.
           // sfNoLimitChk allows testers to override this 3 day limitations.
           if (
               ( ((CurrentTime > sLastTombTime)
                        &&
                 (CurrentTime - sLastTombTime) > (time_t)min(
                                            pScvParam->TombstoneTimeout,
                                            pScvParam->TombstoneInterval
                                               ) )
                                ||
                sfAdminForcedScv
               )
                        &&
                ((CurrentTime - sBootTime >= THREE_DAYS) || fForce || sfNoLimitChk)
              )
          {
                NMSSCV_CLUT_T  ClutterInfo;
                WinsIntfSetTime(
                                NULL,
                                WINSINTF_E_TOMBSTONES_SCV
                                );

                NoOfRecsScv  = 0;
                NoOfRecToDel = 0;

                ClutterInfo.Interval            = pScvParam->TombstoneTimeout;
                ClutterInfo.CurrentTime         = CurrentTime;
                ClutterInfo.fAll                = FALSE;  //not used but
                                                          //let us set it

                /*
                * Call database manager function to get all the
                * replicas that are tombstones
                */
                DBGPRINT0(DET, "DoScavenging: GETTING REPLICA TOMBSTONES\n");
                NmsDbGetDataRecs(
                                  WINS_E_NMSSCV,
                                  pScvParam->PrLvl,
                                  n,              //no use in this call
                                  MyMaxVersNo,    //no use in this call
                                  0,              //no use in this call
                                  TRUE,           //no use in this call
                                  TRUE,           //Get only replica tombstones
                                  &ClutterInfo,
                                  &NmsLocalAdd,   //no use in this call
                                  FALSE,          //both dyn & static should be taken
                                  WINSCNF_RPL_DEFAULT_TYPE, //no use here
                                  (LPVOID *)&pStartBuff,
                                  &BuffLen,
                                  &NoOfRecs
                                 );

                if(NoOfRecs > 0)
                {

                     for (
                        i = 0, pRec = pStartBuff;
                        i < NoOfRecs;
                        i++
                        )
                      {
                          NMSDB_SET_STATE_M(pRec->Flag, NMSDB_E_DELETED);
                          pRec->fScv   = TRUE;
                          NoOfRecToDel = NoOfRecs;
                          pRec = (PRPL_REC_ENTRY_T)(
                                          (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );

                      }

                      //
                      // If one or more replicas needs to be deleted
                      // call UpdDb
                      //
                      DBGPRINT1(DET, "DoScavenging: %d REPLICAS WILL BE DELETED\n", NoOfRecs);
                      UpdDb(
                               pScvParam,
                               pStartBuff,
                               NoOfRecs,
                               NoOfRecs    //NoOfRecsScv
                               );

                      if (fForce)
                      {
                         DBGPRINT0(SCV, "DoScavenging: FORCEFUL SCAVENGING OF REPLICA TOMBSTONES\n");
                         WINSEVT_LOG_M(WINS_SUCCESS, WINS_EVT_FORCE_SCV_R_T);
                      }

                      WINSEVT_LOG_INFO_D_M(NoOfRecsScv, WINS_EVT_SCV_RPLTOMB);
                }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET, "DoScavenging: NO REPLICA TOMBSTONES DELETED\n");
                }
#endif


                //
                // destroy the heap that was allocated
                //
                GET_TLS_M(pTls);
                //
                // destroy the heap that was allocated
                //
                for (RecCnt=0, pRec = pStartBuff; RecCnt<NoOfRecs; RecCnt++)
                {
                     WinsMscHeapFree(pTls->HeapHdl, pRec->pName);
                     pRec = (PRPL_REC_ENTRY_T)(
                                   (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE
                                                 );
                }
                WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
                WinsMscHeapDestroy(pTls->HeapHdl);

                //
                // record current time in sLastTombTime
                //
                sLastTombTime = CurrentTime;

          } // end of if (test if replica tombstones need to be processed)

           WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCVENGING_COMPLETED);
        }

         WINSDBG_INC_SEC_COUNT_M(SectionCount);

         if (Opcode_e != WINSINTF_E_SCV_GENERAL)
         {
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );
         }
         //
         // If we are due for a verification or if we are being forced to do
         // it by the admin., do it.  Note: Timer Thread initiated verification
         // is always forced.  An admin. initiated one may or may not be forced.
         // We force the admin. to specify the kind of verification he wants.
         // If he chooses to do a forceful one, then we give him a warning.
         // about the overhead of this (specially if a number of admins. are
         // doing forceful verification around the same time or one after
         // another
         //
         if (
                ((CurrentTime > sLastVerifyTime)
                                &&
                ((CurrentTime - sLastVerifyTime) > (time_t)pScvParam->VerifyInterval))
                                ||
                fForce
                                ||

                (sfAdminForcedScv && (CurrentTime - sLastAdminScvTime) >= ONE_HOUR )
            )
         {

                // we might want to always log normal events for consistency checking
                // since this operation happens normally only when initiated by the
                // administrator or at about 24hrs, if configured 
                // (or reg param ..Parameters\ConsistencyCheck:TimeInterval)
                // --ft: #384489: if this is an administrator initiated action...
                //if (sfAdminForcedScv)
                //..log the event as a normal one
                   WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CCCHECK_STARTED);
                //else
                //..log it as a detailed event only.
                //   WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CCCHECK_STARTED);

                WinsIntfSetTime(
                                NULL,
                                WINSINTF_E_VERIFY_SCV
                                );
                //
                // get all active replicas that are older than the
                // verify interval. Contact the owner WINS to verify their
                // validity
                //
                //DBGPRINT1(ERR, "DoScavenging: pScvParam is (%x)\n", pScvParam);
                (VOID)VerifyDbData(pScvParam, CurrentTime, Age, fForce, fPeriodicCC);
                //WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_SCV_CLUTTER);

                // --ft: #384489: see comment above.
                //if (sfAdminForcedScv)
                //..log the event as a normal one
                    WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CCCHECK_COMPLETED);
                //else
                //..log it as a detailed event only.
                //  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CCCHECK_COMPLETED);
                sLastVerifyTime = CurrentTime;

         }

         WINSDBG_INC_SEC_COUNT_M(SectionCount);


 }  // end of try ..
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("DoScavenging");
        DBGPRINT1(EXC, "DoScavenging: Section Count (%d)\n", SectionCount);
        DBGPRINT5(EXC, "DoScavenging: Variables - i (%d), NoOfRecs (%d), \
                NoOfRecsScv (%d), pStartBuff (%p), pRec (%p)\n",
                i, NoOfRecs, NoOfRecsScv, pStartBuff, pRec
                 );

        if (GetExceptionCode() != WINS_EXC_COMM_FAIL)
        {
               //
               // Set thd. priority back to normal
               //
               WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                         );
                //
                // This is serious.  Let us reraise the exception so that
                // WINS comes down
                //
                //WINS_RERAISE_EXC_M();

                //
                // just return so that we close tables in the caller function
                //
                return(WINS_FAILURE);
        }
 }

          //
          // Set thd. priority back to normal
          //
          WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                         );
        if (Opcode_e == WINSINTF_E_SCV_GENERAL)
        {
          //
          //If we were not able to retrieve any owned records in this scavenging
          // cycle, adjust the min. scv vers. no.  Synchronize with
          // RplPullPullSpecifiedRange
          //
          if (!fRecsExistent)
          {
                //
                // NmsScvMinScvVersNo may be greater than MyMaxVersNo
                // (This may happen if we did not find any local records
                // last time around and no registrations have taken
                // place since then).
                //
                if (LiGtr(MyMaxVersNo, NmsScvMinScvVersNo))
                {

                  //
                  //
                  // Change the Low end of the range  that
                  // we will use it at the next Scavenging cycle
                  //
                  EnterCriticalSection(&NmsNmhNamRegCrtSec);

                  //
                  // Set the Min. Scv. Vers. no to 1 more than the max. vers.
                  // no. we used when searching for records to scavenge.
                  //
                  NMSNMH_INC_VERS_NO_M(MyMaxVersNo, MyMaxVersNo);
                  NmsScvMinScvVersNo = MyMaxVersNo;
                  LeaveCriticalSection(&NmsNmhNamRegCrtSec);
               }
         }

         //
         // If we are not executing a work item from the queue, break out
         // of the while loop, else continue (to get the next work item)
         // if there
         //
         if (!fSignaled)
         {
           break;
         }
       }
      } // end of while
      DBGPRINT0(SCV, "SCAVENGING CYCLE ENDED\n");
      DBGLEAVE("DoScavenging\n");
      return(WINS_SUCCESS);
}

VOID
ReconfigScv(
 PNMSSCV_PARAM_T  pScvParam
        )

/*++

Routine Description:
        This function is called to reinit the scavenging params

Arguments:
        pScvParam - Structure storing the scavenging params

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ScvThdInitFn
Side Effects:

Comments:
        None
--*/

{
        DBGENTER("ReconfigScv\n");
        //
        // Extract the parameters that are related
        // to scavenging and go back to doing the timed
        // wait.  Since WinsCnf can change any time, we
        // operate with copies. Also, the priority of this
        // thread is changed outside of this critical section
        // See DoScavenging().
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);
try {
        pScvParam->ScvChunk          = WinsCnf.ScvChunk;
        pScvParam->RefreshInterval   = WinsCnf.RefreshInterval;
        pScvParam->TombstoneInterval = WinsCnf.TombstoneInterval;
        pScvParam->TombstoneTimeout  = WinsCnf.TombstoneTimeout;
        pScvParam->PrLvl                 = WinsCnf.ScvThdPriorityLvl;

        //
        // Load up the CC parameters
        //
        pScvParam->CC.TimeInt        = WinsCnf.CC.TimeInt;
        pScvParam->CC.fSpTime        = WinsCnf.CC.fSpTime;
        pScvParam->CC.SpTimeInt      = WinsCnf.CC.SpTimeInt;
        pScvParam->CC.MaxRecsAAT     = WinsCnf.CC.MaxRecsAAT;
        pScvParam->CC.fUseRplPnrs    = WinsCnf.CC.fUseRplPnrs;

        //
        // If the backup path has changed, start using it.
        //
        if (WinsCnf.pBackupDirPath != NULL)
        {
          if (strcmp(WinsCnf.pBackupDirPath, pScvParam->BackupDirPath))
          {
                   strcpy(pScvParam->BackupDirPath, WinsCnf.pBackupDirPath);
          }
        }
        else
        {
                   pScvParam->BackupDirPath[0] = EOS;
        }
 }
finally {
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
}

        DBGLEAVE("ReconfigScv\n");
        return;
}

#ifdef WINSDBG
#pragma optimize ("", off)
#endif

VOID
UpdDb(
        IN  PNMSSCV_PARAM_T        pScvParam,
        IN  PRPL_REC_ENTRY_T        pStartBuff,
        IN  DWORD                NoOfRecs,
        IN  DWORD                NoOfRecsToUpd
     )

/*++

Routine Description:

        This function is called to update the DB

Arguments:
        pScvParam  - Scavenging params
        pStartBuff - Buffer containing records processed by DoScavenging()
        NoOfRecs   - No of records in the above buffer
        NoofRecsToUpd - No of records that need to be modified in the db

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        DoScavenging

Side Effects:

Comments:
        None
--*/

{
        DWORD                   i;
        DWORD                   NoUpdated = 0; //No of records that have been
                                           //updated
        PRPL_REC_ENTRY_T        pRec = pStartBuff;

        DBGENTER("UpdDb\n");

        //
        // Set the current index to be the clustered index
        //
        NmsDbSetCurrentIndex(
                        NMSDB_E_NAM_ADD_TBL_NM,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
        //
        // Update the database now
        //
        for (
                i = 0;
                i < NoOfRecs;
                i++
            )
        {

                //
                // if the record was updated, update the db
                //
                if (pRec->fScv)
                {
                       if (NmsDbQueryNUpdIfMatch(
                                                pRec,
                                                pScvParam->PrLvl,
                                                TRUE,        //chg pr. lvl
                                                WINS_E_NMSSCV
                                                ) == WINS_SUCCESS
                           )
                       {
                          NoUpdated++;  // no of records that we
                                        //have updated in the db
                       }
                       else
                       {
                          DBGPRINT0(ERR, "DoScavenging: Could not scavenge a record\n");
                          WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SCV_ERR);
                       }
                }

                //
                //  see if we are done
                //
                if (NoUpdated == NoOfRecsToUpd)
                {
                  break;
                }

                pRec = (PRPL_REC_ENTRY_T)(
                                        (LPBYTE)pRec + RPL_REC_ENTRY_SIZE
                                                 );
        }  // end of for loop

        DBGPRINT1(FLOW, "LEAVE: SCAVENGING: UpdDb. Records Updated = (%d)\n",  NoUpdated);
        return;
} // UpdDb()

#ifdef WINSDBG
#pragma optimize ("", on)
#endif



STATUS
VerifyDbData(
        PNMSSCV_PARAM_T       pScvParam,
        time_t                CurrentTime,
        DWORD                 Age,
        BOOL                  fForce,
        BOOL                  fPeriodicCC
        )

/*++

Routine Description:
        This function is called to remove any clutter that might have
        accumulated in the db.  For each owner, excepting self, in the
        db, it gets the version numbers of the active records that are
        older than the verify time interval. It then contacts the owner
        WINS to verify their validity

Arguments:
        pScvParam  - pointer to the scavenging parameters

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        DoScavenging

Side Effects:

Comments:
        None
--*/

{

        DWORD                   MaxOwnerIdFound;
        volatile DWORD          i;
        NMSSCV_CLUT_T           ClutterInfo;
        PRPL_REC_ENTRY_T        pStartBuff;
        DWORD                   BuffLen;
        DWORD                   NoOfLocalDbRecs;
        COMM_ADD_T              OwnerWinsAdd;
        COMM_ADD_T              VerifyWinsAdd;
        PCOMM_ADD_T             pWinsAdd;
        VERS_NO_T               MinVersNo, MaxVersNo;
        PNMSDB_WINS_STATE_E     pWinsState_e;
        PVERS_NO_T              pStartVersNo;
        NMSDB_WINS_STATE_E      WinsState_e;
        COMM_HDL_T              DlgHdl;
        PWINSTHD_TLS_T          pTls;
        static DWORD            sFirstOwnerId = 1;
        DWORD                   FirstOwnerId;
        DWORD                   NoOfPulledRecs;
        DWORD                   TotNoOfPulledRecs = 0;
        DWORD                   LastOwnerId;
        BOOL                    fNonOwnerPnr;
        DWORD                   TotPulledRecsFromOneWins;
        BOOL                    fDlgStarted = FALSE;
        BOOL                    fFirstTime;
        PRPL_REC_ENTRY_T        pLastEntry;
        STATUS                  RetStat;
        DWORD                   RplType;
        BOOL                    fPulledAtLeastOnce;
        VERS_NO_T               MaxVersNoSave;


        DBGENTER("VerifyDbData\n");

        //
        // Init the structure used by NmsDbGetDataRecs()
        //
        ClutterInfo.Interval            = pScvParam->VerifyInterval;
        ClutterInfo.CurrentTime         = CurrentTime;
        ClutterInfo.Age                 = Age;
        ClutterInfo.fAll                = TRUE;

        //
        // Set thread priority to NORMAL
        //
        WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                               );

        //
        // Cleanup the owner-address table if it requires cleaning
        //
        NmsDbCleanupOwnAddTbl(&MaxOwnerIdFound);

try {

        //
        // If it is an admin. forced verification or the one that happens
        // due to the verify interval being over, do a full validation
        //
        if (!fPeriodicCC)
        {
              FirstOwnerId       = 1;
              sLastFullVerifyTime = CurrentTime;
        }
        else
        {
            //
            // Periodic verification.  Skip the owners we verified earlier
            //
            if (sFirstOwnerId >= MaxOwnerIdFound)
            {
                sFirstOwnerId = 1;
            }
            FirstOwnerId = sFirstOwnerId;
        }
        LastOwnerId         = MaxOwnerIdFound;

        //
        // for each owner in the db, excluding self, do the following.
        //
        for (i = FirstOwnerId; i <= LastOwnerId; i++)
        {

                //
                // If it is periodic verification and we have pulled more than
                // the max. threshold specified for one particular cycle,
                // break out of the loop
                //
                if (fPeriodicCC && (TotNoOfPulledRecs >= pScvParam->CC.MaxRecsAAT))
                {
                      break;

                }

                //
                // Get all ACTIVE replicas that are older than verify interval.
                //
                ClutterInfo.OwnerId = i;

                //
                // We need to synchronize with the Pull thread which can
                // change the NmsDbOwnAddTbl table.  The entry may have
                // been deleted by the Pull thread (DeleteWins), so we
                // should be ready for access violation
                //
                EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                RPL_FIND_ADD_BY_OWNER_ID_M(
                        i, pWinsAdd, pWinsState_e, pStartVersNo);

                //
                // The Wins entry should be there.
                //
                ASSERT(pWinsAdd);
                OwnerWinsAdd     = *pWinsAdd;
                WinsState_e      = *pWinsState_e;
                LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

                //
                // If WINS is not active, log a record and continue to
                // the next WINS.  It is possible for WINS to get deleted
                // to between the time we get its records and the time
                // we check the own-add table for its entry.
                //

                if (
                      (WinsState_e == NMSDB_E_WINS_DOWN) ||
                      (WinsState_e == NMSDB_E_WINS_DELETED)
                   )
                {

                        //
                        // if there are records in the db, then the
                        // state of WINS in the in-memory table can not
                        // be deleted
                        //
                        DBGPRINT2(SCV, "VerifyDbData: WINS with index = (%d) and IP Address = (%x) is either down or deleted \n", i, OwnerWinsAdd.Add.IPAdd);
                        continue;
                }



                WINS_ASSIGN_INT_TO_LI_M(MinVersNo, 0);
                fFirstTime = TRUE;
                TotPulledRecsFromOneWins = 0;
                fPulledAtLeastOnce = FALSE;

                //
                // Save the max. vers. no. that we have in the
                // pRplPullOwnerVersNo table in a local.
                //
                EnterCriticalSection(&RplVersNoStoreCrtSec);
#ifdef WINSDBG
                try {
#endif
                  MaxVersNoSave =  (pRplPullOwnerVersNo + i)->VersNo;
#ifdef WINSDBG
                } //end of try { .. }
                finally {
#endif
                   LeaveCriticalSection(&RplVersNoStoreCrtSec);
#ifdef WINSDBG
                }
#endif
                do
                {
                  NoOfLocalDbRecs = 0;
//                  DBGPRINT1(ERR, "VerifyDbData:1 pScvParam is (%x)\n", pScvParam);
                  MaxVersNo.QuadPart = 0;
                  NmsDbGetDataRecs(
                          WINS_E_NMSSCV,
                          pScvParam->PrLvl,
                          MinVersNo,
                          MaxVersNo,     //not used in this call
                          0,
                          TRUE,       //fUpToLimit set to TRUE
                          FALSE,       //not interested in replica tombstones
                          &ClutterInfo,
                          &OwnerWinsAdd,        //Wins Address - not used
                          FALSE,       //dyn + static recs required
                          WINSCNF_RPL_DEFAULT_TYPE, //no use here
                          (LPVOID *)&pStartBuff,
                          &BuffLen,
                          &NoOfLocalDbRecs
                        );


                  GET_TLS_M(pTls);
                  ASSERT(pTls->HeapHdl != NULL);

                  WinsMscChkTermEvt(
#ifdef WINSDBG
                             WINS_E_NMSSCV,
#endif
                             FALSE
                                );

PERF("Optimize so that we reuse a dlg session if we need to go to the same")
PERF("pnr in a subsequent iteration")
                   //
                   // If this is the first time, we pick a WINS and establish
                   // communications with it. Note: If the max. vers. no
                   // in pRplOwnerVersNo for this WINS is 0, we continue on
                   // to the next WINS in our list.
                   //
                   // We don't care whether or not we were able to retrieve
                   // any records from the db.  If we retrieved 0 but the Wins's
                   // pRplPullOwnerVersNo entry has a positive entry, it means
                   // we are out of synch
                   //
                   if (fFirstTime)
                   {
                      if (MaxVersNoSave.QuadPart == 0)
                      {
                              ASSERT(NoOfLocalDbRecs == 0);
                              DBGPRINT2(SCV, "VerifyDbData: WINS with index = (%d) and address = (%x) has pRplPullOwnerVersNo value of 0. SKIPPING IT\n", i, OwnerWinsAdd.Add.IPAdd);

                              FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                              break;
                      }

                      //
                      // Pick the pnr to use for verification
                      //
                      if (PickWinsToUse(
                          &VerifyWinsAdd,
                          &OwnerWinsAdd,
                          pScvParam->CC.fUseRplPnrs,
                          &fNonOwnerPnr,
                          &RplType) != WINS_SUCCESS)
                      {
                           //
                           // Any error that needed to be logged has already
                           // been logged. Just return success.
                           //
                           FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                           return (WINS_SUCCESS);
                      }


                      //
                      // Establish communication with it.  If we can not
                      // establish comm. with it, break out of the loop
                      //
                      RetStat = EstablishCommForVerify(&VerifyWinsAdd, &DlgHdl);

                      if (RetStat == WINS_FAILURE)
                      {
                         FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                         break;  //go on to the next WINS in the list of owners
                      }
                      fDlgStarted = TRUE;

                      //
                      // get the min and max version numbers of the active
                      // replicas
                      //
                      MinVersNo.QuadPart  = 1;        //pStartBuff->VersNo;
                      fFirstTime = FALSE;
                } // if first time

                {

                  //
                  //Must not pull a version number that is > what we
                  //have in our table to avoid conflicting with the
                  //pull thread.
                  //
                  MaxVersNo =  MaxVersNoSave;
                }
                ASSERT(MaxVersNo.QuadPart <= MaxVersNoSave.QuadPart);

                DBGPRINT5(DET, "VerifyDbData: Going to pull records in the range (%d %d) to (%d %d) from Wins with owner id = (%d)\n",
                                MinVersNo.HighPart, MinVersNo.LowPart,
                                MaxVersNo.HighPart, MaxVersNo.LowPart,
                                i
                             );

                try
                {
                    //
                    // Pull the records in the range from the WINS
                    //
                    PullAndUpdateDb(
                           &DlgHdl,
                           &OwnerWinsAdd,
                           pStartBuff,
                           i,
                           MinVersNo,
                           MaxVersNo,
                           RplType,
                           NoOfLocalDbRecs,
                           CurrentTime,
                           pScvParam,
                           fNonOwnerPnr,
                           &TotPulledRecsFromOneWins
                                      );
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    // just in case some exception is raised while pulling the records,
                    // bail this owner only, not the entire scavenge process
                    FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);
                    break;
                }

                if (!fPulledAtLeastOnce)
                {
                      fPulledAtLeastOnce = TRUE;
                }
                //
                // deallocate the memory block that was  allocated
                //
                // NmsDbGetDataRecs always allocates a buffer (even if
                // the number of records is 0).  Let us deallocate it
                //
                FreeDbMemory(pStartBuff, NoOfLocalDbRecs, pTls);

                //
                // Make the min. version number 1 more than the the
                // max. vers. no. we used last time
                //
                NMSNMH_INC_VERS_NO_M(MaxVersNo, MinVersNo);

               } while (LiLtr(MaxVersNo,MaxVersNoSave));

               if (fDlgStarted)
               {
                 ECommEndDlg(&DlgHdl);
                 fDlgStarted = FALSE;
               }
               if ((WinsCnf.LogDetailedEvts > 0) &&
                   fPulledAtLeastOnce)
               {
                    WinsEvtLogDetEvt(TRUE, WINS_EVT_CC_NO_RECS, NULL,
                           __LINE__, "ddd", TotPulledRecsFromOneWins,
                             OwnerWinsAdd.Add.IPAdd, VerifyWinsAdd.Add.IPAdd);

                    DBGPRINT3(SCV, "VerifyDbData: WINS pulled (%d) records owned by WINS= (%x) from WINS = (%x) for doing CC\n",
TotPulledRecsFromOneWins, OwnerWinsAdd.Add.IPAdd, VerifyWinsAdd.Add.IPAdd);
              }

              //
              // Total no. of records pulled so far
              //
              TotNoOfPulledRecs += TotPulledRecsFromOneWins;
       } //end of for loop for looping over owners

       //
       // We are done for this cycle.  If this was a CC verify, set
       // sFirstOwnerId to the index of the WINS to start from in the next
       // periodic CC cycle
       //
       if (fPeriodicCC)
       {
          sFirstOwnerId = i;
       }


 }  // end of try
except(EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("VerifyDbData");
        DBGPRINT2(EXC, "VerifyDbData:  i is (%d),  MaxOwnerIdFound is (%d)\n",i, MaxOwnerIdFound);

        //--ft: bug #422659--
        // if an exception happens between EstablishCommForVerify and ECommEndDlg
        // we need to make sure we close the connection - otherwise the connection
        // remains active and the sender WINS eventually get stucked in send().
        if (fDlgStarted)
            ECommEndDlg(&DlgHdl);

        WINS_RERAISE_EXC_M();
        }

        //
        // Set the priority back the old level
        //
        WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          pScvParam->PrLvl
                         );

        DBGLEAVE("VerifyDbData\n");
        return(WINS_SUCCESS);
} // VerifyDbData()

STATUS
PickWinsToUse(
 IN PCOMM_ADD_T pVerifyWinsAdd,
 IN PCOMM_ADD_T pOwnerWinsAdd,
 IN BOOL        fUseRplPnrs,
 OUT LPBOOL     pfNonOwnerPnr,
 OUT LPBOOL     pfRplType
 )

/*++

Routine Description:
  This function picks a WINS to verify the active replicas with

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
    PRPL_CONFIG_REC_T  pRplPnr;
    DWORD              IndexOfPnrToUse;
    STATUS             RetStat = WINS_SUCCESS;

    *pfNonOwnerPnr = FALSE;

    DBGENTER("PickWinsToUse\n");
    //
    // If the admin. specified that we should just use
    // our replication partners for consistency checking,
    // pick a replication partner for this.
    //

    *pfNonOwnerPnr = FALSE;
    EnterCriticalSection(&WinsCnfCnfCrtSec);
    try {
       pRplPnr = RplGetConfigRec(RPL_E_PULL, NULL, pOwnerWinsAdd);
       if (fUseRplPnrs)
       {
         //
         // If this guy is not a partner but there are other partners that
         // we can pick from, pick one
         //
         if (pRplPnr == NULL)
         {
               if (WinsCnf.PullInfo.NoOfPushPnrs > 0)
               {
                 //
                 // Just use one of the pnrs.  Pick one at
                 // random
                 //
                 *pfRplType     = WinsCnf.PullInfo.RplType;

                 srand((unsigned)time(NULL));
                 IndexOfPnrToUse = rand() % WinsCnf.PullInfo.NoOfPushPnrs;

                 *pVerifyWinsAdd = ((PRPL_CONFIG_REC_T)((LPBYTE)WinsCnf.PullInfo.pPullCnfRecs + (IndexOfPnrToUse * RPL_CONFIG_REC_SIZE)))->WinsAdd;


                 *pfNonOwnerPnr = TRUE;
               }
               else
               {
                   DBGPRINT0(ERR, "PickWinsToUse: CC checking NOT DONE since no partners are there\n");
                   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_CC_FAILED);
                   RetStat = WINS_FAILURE;
               }
         }
         else
         {
            *pfRplType = pRplPnr->RplType;

         }
       } // if (fUseRplPnr)
       else
       {
          *pfRplType = (pRplPnr != NULL) ? pRplPnr->RplType : WinsCnf.PullInfo.RplType;
       }
  } // end if try {..}
  finally {
          LeaveCriticalSection(&WinsCnfCnfCrtSec);

          if (RetStat == WINS_SUCCESS)
          {
            //
            // If we are to communicate with the owner WINS, set *pVerifyWinsAdd
            // since it was not set above.
            //
            if (!*pfNonOwnerPnr)
            {
              *pVerifyWinsAdd = *pOwnerWinsAdd;
            }
            DBGPRINT3(DET, "VerifyDbData: Using pnr no = (%d) with address = (%x) for verification of records owned by WINS (%x)\n", IndexOfPnrToUse, pVerifyWinsAdd->Add.IPAdd, pOwnerWinsAdd->Add.IPAdd)
          }
  }
  DBGLEAVE("PickWinsToUse\n");
  return (RetStat);
} //PickWinsToUse()

STATUS
EstablishCommForVerify(
  PCOMM_ADD_T pWinsAdd,
  PCOMM_HDL_T pDlgHdl
)

/*++

Routine Description:
    This function is called to setup communication with a WINS

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
     //DWORD  NoOfRetries = 0;
     BOOL   fAbort = FALSE;
     STATUS RetStat = WINS_SUCCESS;

     DBGENTER("EstablishCommForVerify\n");
     //
     // We try a certain number of times to establish a
     // a dialogue.  Currently, it is 1.
     //
     do
     {
          try {
             ECommStartDlg( pWinsAdd, WINS_E_NMSSCV, pDlgHdl );
          }
          except(EXCEPTION_EXECUTE_HANDLER) {
             DBGPRINTEXC("VerifyDbData");
             if (GetExceptionCode() == WINS_EXC_COMM_FAIL)
             {
               DBGPRINT1(EXC, "VerifyDbData: Could not start a dlg with WINS at address (%x)\n", pWinsAdd->Add.IPAdd);

               //--ft: 07/10/00 commented out since VERIFY_NO_OF_RETRIES is 0 anyhow so the test is always false.
               //if (NoOfRetries++ < VERIFY_NO_OF_RETRIES)
               //{
               //       Sleep(VERIFY_RETRY_TIME_INTERVAL);
               //       continue;
               //}
               RetStat = WINS_FAILURE;
            }
            else
            {
               //
               // This is a serious error. Log and abort the verify cycle
               //
               WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
               RetStat = WINS_FAILURE;
            }
        } // end of exception handler
        break;
    } while (TRUE);
    if (RetStat == WINS_FAILURE)
    {
        DBGPRINT1(ERR, "EstablishCommForVerify: Could not start dlg with WINS at address (%x)\n", pWinsAdd->Add.IPAdd);
    }
     DBGLEAVE("EstablishCommForVerify\n");
     return(RetStat);
}  // EstablishCommForVerify()

VOID
PullAndUpdateDb(
  PCOMM_HDL_T  pDlgHdl,
  PCOMM_ADD_T  pOwnerWinsAdd,
  PRPL_REC_ENTRY_T pRspBuff,
  DWORD        WinsIndex,
  VERS_NO_T    MinVersNo,
  VERS_NO_T    MaxVersNo,
  DWORD        RplType,
  DWORD        NoOfLocalDbRecs,
  time_t       CurrentTime,
  PNMSSCV_PARAM_T pScvParam,
  BOOL         fNonOwnerPnr,
  LPDWORD      pTotNoPulledFromOneWins
 )

/*++

Routine Description:
   This pulls the records in the range specified and then updates the db
   accordingly

Arguments:

Externals Used:
	None

	
Return Value:

  NONE

Error Handling:

Called by:
        VerifyDbData()
Side Effects:

Comments:
	None
--*/

{

      LPBYTE                  pBuffOfPulledRecs;
      VERS_NO_T               VersNo;
      DWORD                   NoOfPulledRecs;

      DBGENTER("PullAndUpdateDb\n");
      while (TRUE)
      {
             //
             //Pull the records in the range min-max determined
             //above
             //
             RplPullPullEntries(
                                    pDlgHdl,
                                    WinsIndex,
                                    MaxVersNo,
                                    MinVersNo,
                                    WINS_E_NMSSCV,
                                    &pBuffOfPulledRecs,
                                    FALSE,     //do not want to update counters
                                    RplType
                                  );


             //
             // Update the DB. All valid records are updated.
             // The invalid  records  are deleted from the db
             //

             ChkConfNUpd(
#if SUPPORT612WINS > 0
                      pDlgHdl,
#endif
                      pOwnerWinsAdd,
                      RplType,
                      WinsIndex,
                      &pRspBuff,
                      pBuffOfPulledRecs,
                      &NoOfLocalDbRecs,
                      CurrentTime,
                      pScvParam->VerifyInterval,
                      fNonOwnerPnr,
                      &NoOfPulledRecs,
                      &VersNo
                         );

             *pTotNoPulledFromOneWins += NoOfPulledRecs;

              //
              // Free the response buffer
              //
              ECommFreeBuff(pBuffOfPulledRecs - COMM_HEADER_SIZE);

              //
              //If vers. no. pulled is smaller than the Max. Vers
              //no, specified, check if it is because of the limit
              //we have set  for the max. number or records that
              //can be replicated  at a time.  If yes, pull again.
              //
              if (
                           LiLtr(VersNo, MaxVersNo)
                                      &&
                          (NoOfPulledRecs == RPL_MAX_LIMIT_FOR_RPL)
                 )
              {
                       MinVersNo = VersNo;
                       NMSNMH_INC_VERS_NO_M(MinVersNo, MinVersNo);
                       continue;
              }
              break;   //break out of the loop
      } //end of while (pulled all records in the range from pnr)_
      DBGLEAVE("PullAndUpdateDb\n");
      return;
} // PullAndUpdateDb()

__inline
VOID
FreeDbMemory(
     LPVOID pStartBuff,
     DWORD  NoOfLocalDbRecs,
     PWINSTHD_TLS_T pTls
 )

/*++

Routine Description:
   Frees the memory allocated by NmsDbGetDataRecs()

Arguments:


Externals Used:
	None

	
Return Value:

       NONE

Error Handling:

Called by:
           VerifyDbData()
Side Effects:

Comments:
	None
--*/

{
       PRPL_REC_ENTRY_T        pRec;
       DWORD                   RecCnt;

       for (
               RecCnt=0, pRec = pStartBuff;
               RecCnt < NoOfLocalDbRecs;
               RecCnt++
           )
       {
            WinsMscHeapFree(pTls->HeapHdl, pRec->pName);
            pRec = (PRPL_REC_ENTRY_T)( (LPBYTE)pRec +  RPL_REC_ENTRY_SIZE );
       }
       WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
       WinsMscHeapDestroy(pTls->HeapHdl);
       return;
} // FreeDbMemory ()

VOID
ChkConfNUpd(
#if SUPPORT612WINS > 0
        IN PCOMM_HDL_T pDlgHdl,
#endif
        IN  PCOMM_ADD_T         pOwnerWinsAdd,
        IN  DWORD               RplType,
        IN  DWORD               OwnerId,
        IN  PRPL_REC_ENTRY_T    *ppLocalDbRecs,
        IN  LPBYTE              pRspBuff,
        IN  DWORD               *pNoOfLocalDbRecs,
        IN  time_t              CurrentTime,
        IN  DWORD               VerifyTimeIntvl,
        IN  BOOL                fNonOwnerPnr,
        OUT LPDWORD             pNoOfPulledRecs,
        OUT PVERS_NO_T          pMaxVersNo
        )
/*++

Routine Description:
        This function compares the records that have been pulled from
        a WINS with those in its local db.  If the comparison is successful,
        the record's timestamp in the local db is updated.  If the
        comparison is unsuccessful (i.e. the record in the local db has
        no match in the list of records pulled from the remote WINS, the
        record is deleted in the local db

Arguments:
        pLocalDbRecs - Address of buffer holding the local active replicas
        pRspBuff     - Buffer containing records pulled from the remote WINS
        NoOfLocalDbRecs - No of local replicas in the above buffer


Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        VerifyDbData()

Side Effects:

Comments:
        None
--*/
{
        DWORD            NoOfPulledRecs;
        BYTE             Name[NMSDB_MAX_NAM_LEN];
        DWORD            NameLen;
        BOOL             fGrp;
        DWORD            NoOfAdds;
        COMM_ADD_T       NodeAdd[NMSDB_MAX_MEMS_IN_GRP * 2];  //twice the # of
        VERS_NO_T        VersNo;
        LPBYTE           pTmp = pRspBuff + 4;                //past the opcode
        DWORD            i, j;
        PRPL_REC_ENTRY_T pRecLcl;
        DWORD            NoOfRecsDel = 0;
        PRPL_REC_ENTRY_T pStartOfLocalRecs = *ppLocalDbRecs;
        DWORD            MvNoOfLocalDbRecs = *pNoOfLocalDbRecs;
        DWORD            Flag;
        DWORD            NoOfRecsUpd = 0;
        DWORD            NoOfRecsIns = 0;
        struct in_addr   InAddr;
#if SUPPORT612WINS > 0
    BOOL       fIsPnrBeta1Wins;
#endif

        DBGENTER("ChkConfNUpd\n");


        //
        // Set the current index to be the clustered index
        //
        NmsDbSetCurrentIndex(
                        NMSDB_E_NAM_ADD_TBL_NM,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
#if SUPPORT612WINS > 0
    COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fIsPnrBeta1Wins);
#endif

        /*
         * Get the no of records from the response and also the first record
         * if there is at least one record in the buffer
        */
        RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                        &pTmp,
                        &NoOfPulledRecs,
                        Name,
                        &NameLen,
                        &fGrp,
                        &NoOfAdds,
                        NodeAdd,
                        &Flag,
                        &VersNo,
                        TRUE /*Is it first time*/
                               );


        if (WinsCnf.LogDetailedEvts > 0)
        {
            PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
            PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
            DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

            WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Verification"), __LINE__, "ddd", IpPartner, pOwnerWinsAdd->Add.IPAdd, NoOfPulledRecs);
        }

        DBGPRINT3(SCV, "ChkConfNUpd: pulled Records - (%d), local records - (%d), local records Buf (%p)\n",
                        NoOfPulledRecs, *pNoOfLocalDbRecs, pStartOfLocalRecs);


        *pNoOfPulledRecs = NoOfPulledRecs;
        if (NoOfPulledRecs > 0)
        {

                NMSSCV_REC_ACTION_E RecAction_e;


                //
                // After this function returns, all local records that have
                // a version number < the version record of the pulled record
                // will be marked deleted.  Also, if there is a local record
                // with the same version number as the pulled record but a
                // different name it will be marked for deletion and fAddDiff
                // will be set to TRUE so that we register the pulled record
                // A local record with the same name and version number as
                // the pulled one will be updated (timestamp only) in the db.
                //
                CompareWithLocalRecs(
                                VersNo,
                                Name,
                                NMSDB_ENTRY_STATE_M(Flag),
                                &pStartOfLocalRecs,
                                &MvNoOfLocalDbRecs,
                                CurrentTime,
                                fNonOwnerPnr,
                                &NoOfRecsDel,
                                &RecAction_e
                              );
                //
                // If RecAction_e is NMSSCV_E_INSERT and the record is
                // marked as DELETED, it means that the pulled record
                // has the same version number but a different name.
                // This should never happen in a consistent system of
                // WINS servers.  The fact that it happened means that
                // the administrator has goofed up.  The remote WINS server
                // has started afresh (new database) or its database got
                // corrupted.  If any of the above did happen, the
                // administrator should have made sure that at startup,
                // the WINS server was starting from a version counter
                // value that was not less than what any of the other WINS
                // servers thought it to be in.
                //
                // To bring the database upto snuff, this WINS server will
                // register this replica.  If there is a clash, it will
                // be handled appropriately.  One can think of this as
                // a pulling in of replicas at replication time.
                //
                for (
                        i = 0, pRecLcl = *ppLocalDbRecs;
                        pRecLcl < pStartOfLocalRecs;
                        i++
                    )
                {
                    //
                    //
                    // We update/delete the record depending upon the
                    // Flag value set by Compare
                    // not interested in the return code
                    //
                    pRecLcl->NewTimeStamp = (DWORD)CurrentTime + VerifyTimeIntvl;
                    NmsDbQueryNUpdIfMatch(
                                pRecLcl,
                                THREAD_PRIORITY_NORMAL,
                                FALSE,        //don't change pr. lvl
                                WINS_E_NMSSCV
                                );
                    NoOfRecsUpd++;
                    pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                        RPL_REC_ENTRY_SIZE);

                }

                //
                // register the replica if it needs to be inserted
                //
                if (RecAction_e == NMSSCV_E_INSERT)
                {
                        RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                     );
                         NoOfRecsIns++;
                }

                //
                // Do until we have covered all the local records.
                //
                for (i=1; MvNoOfLocalDbRecs > 0; i++)
                {
                        //
                        // if we have retrieved all the pull records, use a
                        // version number that is > the highest in the local
                        // db recs cache so that all the records more than
                        // the highest version # pulled get deleted -
                        // Check out CompareWithLocalRecs()
                        //
                        if (i < NoOfPulledRecs)
                        {
                          RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                fIsPnrBeta1Wins,
#endif
                                &pTmp,
                                &NoOfPulledRecs,
                                Name,
                                &NameLen,
                                &fGrp,
                                &NoOfAdds,
                                NodeAdd,
                                &Flag,
                                &VersNo,
                                FALSE /*Is it first time*/
                                       );

                         }
                         else
                         {
                               //
                               // Find out if this is the end of replica records.
                               // if we pulled exactly RPL_MAX_LIMIT_FOR_RPL, then that
                               // may mean that there is more to come. In that case we just
                               // get out of the loop and pull next lot.
                               //
                               // otherwise, this is the last record from the replica.
                               // we set VerNo to highest value so that all the local records
                               // more than the highest vers no of the pulled records get
                               // deleted.
                               //
                               if ( RPL_MAX_LIMIT_FOR_RPL == NoOfPulledRecs )
                               {
                                   break;
                               } else {
                                   if (VersNo.HighPart != MAXLONG)
                                   {
                                     VersNo.LowPart  = MAXULONG;
                                     VersNo.HighPart = MAXLONG;
                                   }
                               }
                         }
                        //
                        //See if there is a hit with a local record.  If there
                        //is a hit, we update the time stamp of the hit
                        //record, else we delete it
                        //
                        // First set, pRecLcl to the address of the first
                        // local record since pStartOfLocalRecs can be changed
                        // by this function. Actually, there is no need to
                        // do this. pRecLcl will be set already
                        //
                        pRecLcl = pStartOfLocalRecs;
                        CompareWithLocalRecs(
                                VersNo,
                                Name,
                                NMSDB_ENTRY_STATE_M(Flag),
                                &pStartOfLocalRecs,
                                &MvNoOfLocalDbRecs,
                                CurrentTime,
                                fNonOwnerPnr,
                                &NoOfRecsDel,
                                &RecAction_e
                              );


                         //
                         // All records upto the new first local record should
                         // be updated/deleted
                         //
                         for (
                                j = 0;
                                pRecLcl < pStartOfLocalRecs;
                                j++
                                )
                         {
                                  //
                                  //We update/delete the record depending
                                  //upon the Flag value set by Compare
                                  // not interested in the return code
                                  //

                                  pRecLcl->NewTimeStamp = (DWORD)CurrentTime + VerifyTimeIntvl;
                                  NmsDbQueryNUpdIfMatch(
                                                pRecLcl,
                                                THREAD_PRIORITY_NORMAL,
                                                FALSE,   //don't change pr. lvl
                                                WINS_E_NMSSCV
                                                );
                                  NoOfRecsUpd++;
                                  pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                                        RPL_REC_ENTRY_SIZE);

                        }

                        //
                        // register the replica if it needs to be inserted
                        //
                        if (RecAction_e == NMSSCV_E_INSERT)
                        {
                                RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                        );
                               NoOfRecsIns++;
                        }
                }

                //
                // Whatever records were not retrieved must be retrieved
                // now and then inserted
                //
                for (j=i; j < NoOfPulledRecs; j++)
                {

                          RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                fIsPnrBeta1Wins,
#endif
                                &pTmp,
                                &NoOfPulledRecs,
                                Name,
                                &NameLen,
                                &fGrp,
                                &NoOfAdds,
                                NodeAdd,
                                &Flag,
                                &VersNo,
                                FALSE /*Is it first time*/
                                       );

                                RplPullRegRepl(
                                        Name,
                                        NameLen,
                                        Flag,
                                        OwnerId,
                                        VersNo,
                                        NoOfAdds,
                                        NodeAdd,
                                        pOwnerWinsAdd,
                                        RplType
                                        );
                               NoOfRecsIns++;

                }
        }
        else // we got 0 records from the remote WINS server.  It means that
             // all the active replicas for this WINS need to be deleted
        {
               //
               // We delete records only if the pnr with which we are doing
               // verification is the owner of the records
               //
               VersNo.QuadPart  = 0;
               if (!fNonOwnerPnr)
               {
                pRecLcl = *ppLocalDbRecs;

                //
                // Change state of all replicas that we retrieved to deleted
                //
                for (i = 0; i < *pNoOfLocalDbRecs; i++)
                {
                        NMSDB_SET_STATE_M(pRecLcl->Flag,  NMSDB_E_DELETED);

                        //
                        //
                        // We update/delete the record depending upon the
                        // Flag value set by Compare
                        // not interested in the return code
                        //
                        NmsDbQueryNUpdIfMatch(
                                pRecLcl,
                                THREAD_PRIORITY_NORMAL,
                                FALSE,        //don't change pr. lvl
                                WINS_E_NMSSCV
                                );
                        pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl +
                                        RPL_REC_ENTRY_SIZE);
                        NoOfRecsDel++;
                }
               }

        }

        //
        // Update our couters/pointers for the next iterations.
        // see PullAndUpdateDb routine.
        //
        *pMaxVersNo = VersNo;
        *ppLocalDbRecs = pStartOfLocalRecs;
        *pNoOfLocalDbRecs = MvNoOfLocalDbRecs;

        if (WinsCnf.LogDetailedEvts > 0)
        {
           InAddr.s_addr = htonl(pOwnerWinsAdd->Add.IPAdd);
           WinsEvtLogDetEvt(TRUE, WINS_EVT_CC_STATS, NULL, __LINE__, "sddd", inet_ntoa(InAddr), NoOfRecsIns, NoOfRecsUpd, NoOfRecsDel);

        }
        DBGPRINT4(DET, "ChkConfNUpd: Wins = (%s). NO OF RECS INSERTED = (%d); NO OF RECORDS UPDATED = (%d); NO OF RECS DELETED = (%d)\n", inet_ntoa(InAddr), NoOfRecsIns, NoOfRecsUpd,  NoOfRecsDel);



        DBGLEAVE("ChkConfNUpd\n");

        return;
} // ChkConfNUpd()

VOID
CompareWithLocalRecs(
        IN     VERS_NO_T            VersNo,
        IN     LPBYTE               pName,
        IN     NMSDB_ENTRY_STATE_E  RecState_e,
        IN OUT PRPL_REC_ENTRY_T     *ppLocalDbRecs,
        IN OUT DWORD                *pNoOfLocalRecs,
        IN     time_t               CurrentTime,
        IN     BOOL                 fNonOwnerPnr,
        IN OUT DWORD                *pNoOfRecsDel,
        OUT    PNMSSCV_REC_ACTION_E     pRecAction_e
        )

/*++

Routine Description:
        This function checks if the pulled record is in the buffer containing
        local active replicas.  If it is, it is marked for update (timestamp)
        If it is not, then all replicas in the buffer that have a version
        stamp < the pulled record are marked for deletion

Arguments:
        VersNo       - Version no. of the pulled record
        pName        - Name in the pulled record
        ppLocalDbRecs - ptr to address of buffer containing one or more
                        local active replicas
        pNoOfLocalRecs - count of records in the above buffer
        pNoOfRecsDel   - count of records to be deleted

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        ChkConfNUpd()

Side Effects:

Comments:
        None
--*/

{

        DWORD                        i;
        PRPL_REC_ENTRY_T        pRecLcl = *ppLocalDbRecs;
#ifdef UNICODE
        WCHAR        NameLcl[WINS_MAX_FILENAME_SZ];
        WCHAR        NameRem[WINS_MAX_FILENAME_SZ];
#endif

        //
        // default is don't insert.
        //
        *pRecAction_e = NMSSCV_E_DONT_INSERT;

        //
        // Loop over all local replicas
        //
        for(i=0; i < *pNoOfLocalRecs; i++)
        {
                //
                // if version number of pulled record is less, we should get the
                // next pulled record from the response buffer. We should
                // insert this one into our db
                //
                if (LiLtr(VersNo, pRecLcl->VersNo))
                {

#if 0
                        //
                        // We don't insert tombstones
                        //
                        if (RecState_e == NMSDB_E_ACTIVE)
#endif
                        //
                        // Even tombstones are inserted because we may
                        // have just got rid of the active record (lower
                        // version number than this tombstone). The above
                        // is TRUE only when pulling from an owner WINS
                        //
                        if ((RecState_e == NMSDB_E_ACTIVE) || !fNonOwnerPnr)
                        {
                           *pRecAction_e = NMSSCV_E_INSERT;
                        }
                        break;
                }
                else
                {
                  //
                  // if version number is same, we need to update this record
                  // in our local db.  We mark it for update. Caveat:
                  // if we are verifying with a non-owner, we don't mark
                  // record for deletion. We just keep it since we don't
                  // know who is more current (we or our replication partner)
                  //
                  if (LiEql(VersNo, pRecLcl->VersNo))
                  {
                        if (
                            !(RtlCompareMemory(pRecLcl->pName, pName,
                                   pRecLcl->NameLen) == pRecLcl->NameLen)
                                         &&
                             !fNonOwnerPnr
                           )
                        {
                                DBGPRINT2(DET, "CompareWithLocalRecs: Names are DIFFERENT. Name to Verify (%s), Name pulled (%s).\nThis could mean that the remote WINS server restarted with a vers. counter value < the value in the previous invocation.\n",
 pRecLcl->pName/*pRecLcl->Name*/, pName);
FUTURES("Replace the local record with the pulled record")
                                NMSDB_SET_STATE_M(pRecLcl->Flag, NMSDB_E_DELETED);
                                (*pNoOfRecsDel)++;

                                //
                                // Insert record regardless of its state
                                // (ACTIVE or TOMBSTONE)
                                //
                                *pRecAction_e = NMSSCV_E_INSERT;

                        }
                        i++;  //increment i so that we don't compare the
                              //the next pulled record with all local records
                              //upto the one we just compared this pulled
                              //record with
                        break;
                  }
                  else
                  {
                        //
                        // For the non-owner case, since we don't know whether
                        // our pnr is more/less current than us, we don't delete
                        // the local record
                        //
                        if (!fNonOwnerPnr)
                        {
                          //
                          // version number is greater than record in
                          // our local db. We delete our local db record
                          //
                          NMSDB_SET_STATE_M(pRecLcl->Flag, NMSDB_E_DELETED);
                          (*pNoOfRecsDel)++;
                        }
                  }
                }
                pRecLcl = (PRPL_REC_ENTRY_T)((LPBYTE)pRecLcl + RPL_REC_ENTRY_SIZE);
        }

        //
        // Adjust the pointer in the buffer of local replicas so that next
        // time we are called in this verify cycle, we don't look at
        // the replicas we have already seen. Also, adjust the count.
        //
        *ppLocalDbRecs = (PRPL_REC_ENTRY_T)(
                           (LPBYTE)(*ppLocalDbRecs) + (i * RPL_REC_ENTRY_SIZE)
                                           );
        *pNoOfLocalRecs = *pNoOfLocalRecs - i;
        return;

} //CompareWithLocalRecs


VOID
DoBackup(
        PNMSSCV_PARAM_T  pScvParam,
        LPBOOL           pfThdPrNormal
      )
/*++

Routine Description:


Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        time_t CurrentTime;

        (void)time(&CurrentTime);

        //
        // if logging is on and sufficient time has elapsed to warrant a
        // another backup.
        //
        if (WinsCnf.fLoggingOn &&
                (CurrentTime - sLastDbNullBackupTime) >= PERIOD_OF_LOG_DEL)
        {

#ifdef WINSDBG
                 IF_DBG(HEAP_CNTRS)
                 {
                     WinsSetFlags(WINSINTF_MEMORY_INFO_DUMP | WINSINTF_HEAP_INFO_DUMP | WINSINTF_QUE_ITEMS_DUMP);
                  }
#endif
                DBGPRINT0(DET, "DoBackup: Will do backup now\n");

                if (!*pfThdPrNormal)
                {
                  //
                  // Set thread priority back to normal
                  //
                  WinsMscSetThreadPriority(
                          WinsThdPool.ScvThds[0].ThdHdl,
                          THREAD_PRIORITY_NORMAL
                         );
                  *pfThdPrNormal = TRUE;
                }

                if (pScvParam->BackupDirPath[0] != EOS)
                {
                  if (
                    (CurrentTime - sLastDbBackupTime) > PERIOD_OF_BACKUP)
                  {
                        if (NmsDbBackup(pScvParam->BackupDirPath,
                                                        NMSDB_FULL_BACKUP)
                                                    != WINS_SUCCESS)
                        {
                          //
                          // Failed to do full backup, just get rid of the
                          // log files.
                          //
                          DBGPRINT0(ERR, "DOING BACKUP to NULL\n");
                          NmsDbBackup(NULL, 0);

                        }
                        else
                        {

                          sLastDbBackupTime = CurrentTime;

                         }
                  }
                  else
                  {
                          DBGPRINT0(ERR, "DOING BACKUP to NULL\n");
                          NmsDbBackup(NULL, 0);
                  }
                }
                else
                {
                        //
                        // Can not do full backup, just get rid of the
                        // log files.
                        //
                        DBGPRINT0(ERR, "DOING BACKUP to NULL\n");
                        NmsDbBackup(NULL, 0);
                }
                sLastDbNullBackupTime = CurrentTime;
        }
        return;
}

#if MCAST > 0
VOID
DoMcastSend(
   DWORD_PTR CurrentTime,
   DWORD Code,
   DWORD fNow
 )
{
  if (fNow || (CurrentTime - sLastMcastTime) >=  sMcastIntvl)
  {
      CommSendMcastMsg(Code);
      if (!fNow)
      {
         sLastMcastTime = CurrentTime;
      }
  }
  return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nmsmsgf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	nmsmsgf.c

Abstract:

  This module contains the functions for formatting and unformatting
  the various messages that are sent and/or received from nbt nodes.
  It also contains the function called by the NBT threads to service
  a name request

Functions:

	NmsMsgfProcNbtReq
	GetName
	GetOtherInfo
	NmsMsgfFrmNamRspMsg
	FrmNamRegRsp
	FrmNamRelRsp
	FrmNamQueryRsp
	FormatQueryRspBuff
	FormatName
	NmsMsgfFrmNamQueryReq
	NmsMsgfFrmNamRelReq
	NmsMsgfFrmWACK
	NmsMsgfUfmNamRsp
	
Author:

	Pradeep Bahl (PradeepB)  	Dec-1992

Revision History:

--*/
/*
 Includes
*/

#include "wins.h"
#include "nms.h"
#include "nmsdb.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"
#include "nmsmsgf.h"
#include "nmsnmh.h"
#include "nmschl.h"
#include "comm.h"
#include "winsintf.h"


/*
  defines
*/


#define NAME_HEADER_SIZE	12	 /* header size (bytes before the Ques
					  * name section of a name packet
					  */

#define NAME_FORMAT_MASK	0xC0      /*top two bits of a byte*/
#define NODE_TYPE_MASK          0x60      /*bit 13 and 14 of NBFLAGs field */
#define SHIFT_NODE_BITS		5	  //shift the node bits in the byte
					  //containing them by this amount
#define LENGTH_MASK		0x3F      /*6 LSBs of the top byte of the
					   * QuesNamSec field
					   */
#define GROUP_BIT_MASK		0x80	   /*bit 7 of the 1st byte (MSB)of the
					    *16 bit NBFLAGS field
					   */
/*
 *  Max length of a Name (including label length octets) in RFC packet
*/
#define RFC_MAX_NAM_LEN  	255

//
// Max size of internal name as derived from the rfc packet name
//
#define MAX_SIZE_INTERNAL_NAME	(RFC_MAX_NAM_LEN - 16)	
					 //This should be = (255 - 16)
					 //since the max size of the netbios
					 //name (with scope attached) can be
					 //be 255.  The first 32 bytes
					 //are encoded. These map to 16
					 //bytes in the internal name


/*
* Max length of a label in a name
*/
#define RFC_MAX_LABEL_LEN	63


/*
 * Sizes of the various fields in the name service packets received or sent
 * by the WINS server.  These sizes are specified in RFC 1002
 */
#define RFC_LEN_QTYP	(2)
#define RFC_LEN_QCLS	(2)
#define RFC_LEN_TTL	(4)
#define RFC_LEN_RDLEN	(2)	
#define RFC_LEN_NBFLAGS	(2)
#define RFC_LEN_NBADD	(4)
#define RFC_LEN_RRTYP	(2)
#define RFC_LEN_RRCLS	(2)
#define RFC_LEN_RRPTR	(2)	

#define RFC_LEN_QTYP_N_QCLS	(RFC_LEN_QTYP + RFC_LEN_QCLS) /* page 10 -
							       *RFC 1002
							       */
#define RFC_LEN_RRTYP_N_RRCLS	(RFC_LEN_RRTYP + RFC_LEN_RRCLS) /* page 11 -
							         *RFC 1002
							         */

/*
 * The following is used by FrmNamQueryRsp in its calculation to determine
 * if the name query buffer would be big enough for the response
*/

#define RFC_LEN_TTL_N_RDLEN	(RFC_LEN_TTL + RFC_LEN_RDLEN)

#define RFC_LEN_RR_N_TTL	(RFC_LEN_RRTYP_N_RRCLS + RFC_LEN_TTL)

#define RFC_LEN_RR_N_TTL_N_RDLEN_N_NBF (RFC_LEN_RR_N_TTL + \
				    RFC_LEN_RDLEN +  RFC_LEN_NBFLAGS)


//
// Length of NBFLAGS and the NB address
//
#define RFC_LEN_NBF_N_NBA	(RFC_LEN_NBFLAGS + RFC_LEN_NBADD)

#define RFC_LEN_RDLEN_N_NBF	(RFC_LEN_RDLEN + RFC_LEN_NBFLAGS)
//
// Length of the RDLEN, NB flags and NB address section. Page 13 of RFC 1002
//
#define RFC_LEN_RDLEN_N_NBF_N_NBA  (RFC_LEN_RDLEN + RFC_LEN_NBF_N_NBA)
/*
 * Size of the TTL, RDLEN, NB Flags and NB address section
*/
#define RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA	(RFC_LEN_TTL + RFC_LEN_RDLEN_N_NBF_N_NBA)

/*
 The value of the 3rd and 4 th byte of the first long of the response packets
 for the different name requests.  The bytes are numbered from the start of
 the pkt.

 Note: for a negative response the Rcode value (4 LSBs of the 4th byte of the
 message) has to be ORed with the LBFW values

*/
#define RFC_NAM_REG_RSP_OPC	  	(0xAD) /*+ve registration response*/
#define RFC_NAM_REG_RSP_4THB		(0x80) /*4th byte of the above pkt */
#define RFC_NAM_REL_RSP_OPC      	(0xB4) /*+ve release response*/
#define RFC_NAM_REL_RSP_4THB		(0x00) /*4th byte of the above pkt*/
						

#define RFC_NAM_QUERY_RSP_OPC_NO_T    (0x85)  /*+ve query resp (complete)*/
#define RFC_NAM_QUERY_RSP_OPC_T       (0x87)  /*+ve query resp (truncated)*/
#define RFC_NAM_QUERY_RSP_4THB	      (0x80)  /*4th byte of the above pkt */


/*
 * Values of different fields in RFC response packet
 */


/*
   QD Count and AN count fields of the Name Reg. Rsp pkt
*/
#define RFC_NAM_REG_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_REG_RSP_ANCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_ANCNT_2NDB    (0x01)

/*
   NS Count and AR count fields of the Name Reg. Rsp pkt
*/

#define RFC_NAM_REG_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_REG_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_REG_RSP_ARCNT_2NDB    (0x00)

/*
   QD Count and AN count fields of the Name Rel. Rsp pkt
*/
#define RFC_NAM_REL_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_REL_RSP_ANCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_ANCNT_2NDB    (0x01)

/*
   NS Count and AR count fields of the Name Rel. Rsp pkt
*/

#define RFC_NAM_REL_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_REL_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_REL_RSP_ARCNT_2NDB    (0x00)

/*
   QD Count and AN count fields of the Name Query. Rsp pkt
*/

#define RFC_NAM_QUERY_RSP_QDCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_QDCNT_2NDB    (0x00)
#define RFC_NAM_QUERY_RSP_ANCNT_1STB    (0x00)

#define RFC_NAM_QUERY_POS_RSP_ANCNT_2NDB    (0x01)
#define RFC_NAM_QUERY_NEG_RSP_ANCNT_2NDB    (0x00)

/*
   NS Count and AR count fields of the Name Query. Rsp pkt
*/
#define RFC_NAM_QUERY_RSP_NSCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_NSCNT_2NDB    (0x00)
#define RFC_NAM_QUERY_RSP_ARCNT_1STB    (0x00)
#define RFC_NAM_QUERY_RSP_ARCNT_2NDB    (0x00)



/*
 * NB and IN fields of the name query response pkt
 * Page 21 and 22 of RFC 1002
*/

/*
  Positive name query response
*/
#define RFC_NAM_QUERY_POS_RSP_NB_1STB	(0x00)
#define RFC_NAM_QUERY_POS_RSP_NB_2NDB	(0x20)
#define RFC_NAM_QUERY_POS_RSP_IN_1STB	(0x00)
#define RFC_NAM_QUERY_POS_RSP_IN_2NDB	(0x01)

/*
  Negative name query response
*/
#define RFC_NAM_QUERY_NEG_RSP_NB_1STB	(0x00)
#define RFC_NAM_QUERY_NEG_RSP_NB_2NDB	(0x0A)
#define RFC_NAM_QUERY_NEG_RSP_IN_1STB	(0x00)
#define RFC_NAM_QUERY_NEG_RSP_IN_2NDB	(0x01)

/*
   name query request opcode byte and 4th byte
*/
#define RFC_NAM_QUERY_REQ_OPCB		(0x01)
#define RFC_NAM_QUERY_REQ_4THB		(0x0)

/*
   name query request QDCOUNT and ANCOUNT bytes
*/
#define RFC_NAM_QUERY_REQ_QDCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QDCNT_2NDB	(0x01)
#define RFC_NAM_QUERY_REQ_ANCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_ANCNT_2NDB	(0x00)

/*
   name query request NSCOUNT and ARCOUNT bytes
*/
#define RFC_NAM_QUERY_REQ_NSCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_NSCNT_2NDB	(0x00)
#define RFC_NAM_QUERY_REQ_ARCNT_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_ARCNT_2NDB	(0x00)

/*
   name query request QTYP and QCLS bytes
*/
#define RFC_NAM_QUERY_REQ_QTYP_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QTYP_2NDB	(0x20)
#define RFC_NAM_QUERY_REQ_QCLS_1STB	(0x00)
#define RFC_NAM_QUERY_REQ_QCLS_2NDB	(0x01)

/*
   name release request opcode byte and 4th byte
*/
#define RFC_NAM_REL_REQ_OPCB		(0x30)
#define RFC_NAM_REL_REQ_4THB		(0x00)

/*
   name release request QDCOUNT and ANCOUNT bytes
*/
#define RFC_NAM_REL_REQ_QDCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_QDCNT_2NDB	(0x01)
#define RFC_NAM_REL_REQ_ANCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_ANCNT_2NDB	(0x00)

/*
   name release request NSCOUNT and ARCOUNT bytes
*/
#define RFC_NAM_REL_REQ_NSCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_NSCNT_2NDB	(0x00)
#define RFC_NAM_REL_REQ_ARCNT_1STB	(0x00)
#define RFC_NAM_REL_REQ_ARCNT_2NDB	(0x01)

/*
   name release request QTYP and QCLS bytes
*/
#define RFC_NAM_REL_REQ_QTYP_1STB	(0x00)
#define RFC_NAM_REL_REQ_QTYP_2NDB	(0x20)
#define RFC_NAM_REL_REQ_QCLS_1STB	(0x00)
#define RFC_NAM_REL_REQ_QCLS_2NDB	(0x01)
/*
   name Release request RRTYP and RRCLS bytes
*/
#define RFC_NAM_REL_REQ_RRTYP_1STB	(0x00)
#define RFC_NAM_REL_REQ_RRTYP_2NDB	(0x20)
#define RFC_NAM_REL_REQ_RRCLS_1STB	(0x00)
#define RFC_NAM_REL_REQ_RRCLS_2NDB	(0x01)

/*
   WACK opcode byte and 4th byte
*/
#define RFC_WACK_OPCB		(0xBC)
#define RFC_WACK_4THB		(0x0)

/*
   WACK QDCOUNT and ANCOUNT bytes
*/
#define RFC_WACK_QDCNT_1STB	(0x0)
#define RFC_WACK_QDCNT_2NDB	(0x0)
#define RFC_WACK_ANCNT_1STB	(0x0)
#define RFC_WACK_ANCNT_2NDB	(0x1)

/*
   WACK NSCOUNT and ARCOUNT bytes
*/
#define RFC_WACK_NSCNT_1STB	(0x0)
#define RFC_WACK_NSCNT_2NDB	(0x0)
#define RFC_WACK_ARCNT_1STB	(0x0)
#define RFC_WACK_ARCNT_2NDB	(0x0)
/*
  WACK  RRTYP and RRCLS bytes
*/
#define RFC_WACK_RRTYP_1STB	(0x00)
#define RFC_WACK_RRTYP_2NDB	(0x20)
#define RFC_WACK_RRCLS_1STB	(0x00)
#define RFC_WACK_RRCLS_2NDB	(0x01)

// WACK RDLENGTH Field

#define RFC_WACK_RDLENGTH_1STB	(0x0)
#define RFC_WACK_RDLENGTH_2NDB	(0x02)

/*
 Local variable declarations
*/


/*
 Local function declarations
*/
/*
 *GetName -- Extract name out of packet
*/
STATIC
VOID
GetName(
	IN  OUT LPBYTE  *ppName,
	IN  OUT LPBYTE 	pName,
	OUT     LPDWORD   pNameLen
	);
/*
 * Format Name - Format (encode) name for placing in RFC packet
*/
STATIC
VOID
FormatName(
	IN     LPBYTE pNameToFormat,
	IN     DWORD  LengthOfName,
	IN OUT LPBYTE *ppFormattedName
	);
/*
 * GetOtherInfo -- Get information (excluding the name) from the pkt
 */
STATIC
STATUS
GetOtherInfo(
	IN NMSMSGF_NAM_REQ_TYP_E   Opcode_e,
	IN LPBYTE		   pRR,	   /*point to the RR_NAME section in the
				   	    *name registration packet
					    */
	IN   INT	           QuesNamSecLen, //Size of Ques name section
	OUT  LPBOOL		   pfGrp,         //Flag -- unique/group entry
	OUT  PNMSMSGF_CNT_ADD_T    pCntAdd, 	  //Address	
	OUT  PNMSMSGF_NODE_TYP_E   pNodeTyp_e     //Node Type if unique
	);

/*
 * FrmNamRegRsp - Format name registration response
*/
STATIC
STATUS
FrmNamRegRsp(
  PCOMM_HDL_T 		pDlgHdl,
  PNMSMSGF_RSP_INFO_T	pRspInfo
);


/*
 * FrmNamRelRsp - Format name release response
*/
STATIC
STATUS
FrmNamRelRsp(
  PCOMM_HDL_T 		   pDlgHdl,
  PNMSMSGF_RSP_INFO_T	   pRspInfo
);

#if 0
/*
 * FrmNamQueryRsp - Format name query response
*/
STATIC
STATUS
FrmNamQueryRsp(
  IN  PCOMM_HDL_T 	   	pDlgHdl,
  PNMSMSGF_RSP_INFO_T	        pRspInfo
);
#endif

/*
 * FormatQueryRspBuff - Format name query response buffer
*/
STATIC
STATUS
FormatQueryRspBuff(
   IN  LPBYTE 		 	pDest,
   IN  LPBYTE 		 	pSrc,
   IN  PNMSMSGF_RSP_INFO_T	pRspInfo,
   IN  BOOL		 	fTrunc
  	);



/*
	function definitions
*/

STATUS
NmsMsgfProcNbtReq(
	PCOMM_HDL_T	pDlgHdl,
        MSG_T		pMsg,
	MSG_LEN_T	MsgLen
	)

/*++

Routine Description:

  This function is called by an nbt request thread after it dequeues an nbt
  request message from the work-queue.  The function unformats the message
  and then calls the appropriate function to process it.


Arguments:
	pDlgHdl  - Dlg Handle
	pMsg	 - Message Buffer (contains that RFC packet containing
			the request received from an NBT node)	
	MsgLen   - Length of above buffer

Externals Used:
	None

Called by:

	NbtThdInitFn() in nms.c
Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes  --  WINS_FAILURE

--*/

{

	NMSMSGF_NAM_REQ_TYP_E Opcode;
	BYTE		      Name[NMSDB_MAX_NAM_LEN];
	DWORD		      NameLen;   		/*length of name */
        DWORD		      QuesNamSecLen;   		/*length of question
							 *name  section in
							 *packet
					                 */
	NMSMSGF_NODE_TYP_E    NodeTyp_e = NMSMSGF_E_PNODE;
//	BOOL		      fRefresh;

	NMSMSGF_CNT_ADD_T     CntAdd;
	COMM_ADD_T            Address;	
	BOOL	              fGrp;        /*flag indicating whether the name
					    *is a Unique/Group Netbios name.
					    *fGrp is TRUE if the name is a
					    *group name, else it is FALSE
				            */
	BOOL		     fBuffFreed = FALSE; //indicates whether buffer has
						 //been freed or not

	LPBYTE	pTmp  = (LPBYTE)pMsg;
	LPBYTE  pTmp2;

	DBGENTER("NmsMsgfProcNbtReq\n");

try {	
	// get the opcode
	Opcode = (NMS_OPCODE_MASK & *(pTmp + 2)) >> 3;

#ifdef JIM
	{
	 BYTE	TransId = *pTmp;
	 ASSERT(TransId == 0x80);
	}
#endif
		
	/*
	* make pTmp point to the Question Section. All name request
	* packets have a name header of standard size (RFC 1002) at the top
	*/
	pTmp += NAME_HEADER_SIZE;

	/*
	 * Extract the name ind store in Name. GetName will update pTmp to
	 * point just beyond  the name in the question section
	*/
	pTmp2 = pTmp;	/*save pTmp so that when GetName returns we can
			 * determine the length of the question name section
		         */

	GetName(
		&pTmp,
		Name,
		&NameLen
	       );

	QuesNamSecLen = (ULONG) (pTmp - pTmp2);

	pTmp += RFC_LEN_QTYP_N_QCLS; /* skip past the ques. type and ques.
				      * class fields  We don't need to examine
				      * these.  The question type field
		      		      * will always be NB and question class
				      *field will always be INTERNET
		    		      */
#ifdef  TESTWITHUB
	//
	// Check if the broadcast bit is set. If yes, drop the pkt.
	//
	if (*(pMsg + 3) & 0x10)
	{
		DBGPRINT2(SPEC, "Broadcast pkt BEING DROPPED; name is (%s). Opcode is (%d)\n", Name, Opcode);
#if 0
		printf("Broadcast pkt BEING DROPPED; name is (%s). Opcode is (%d)\n", Name, Opcode);
#endif
		ECommFreeBuff(pMsg);		
		ECommEndDlg(pDlgHdl);
		return(WINS_SUCCESS);
	}
#endif

	//
	// Let us set the flag to TRUE.  If any of the following called
	// functions raises an exception, then it is a requirement that
	// it does so only after freeing the buffer (i.e. it must catch
	// all exceptions, free the buffer and then reraise the
	// exception - if it wants)
	//
	fBuffFreed = TRUE;

	//
	// If the 16th character is a 1B switch it with the 1st character.
	// This is done to support Browsing.  Browsers want a list of all
	// names with 16th character being 1B.  Putting 1B as the
	// 1st character enables WINS to find all 1B names quickly.
	//
	NMSMSGF_MODIFY_NAME_IF_REQD_M(Name);

	/*
	 * Switch on the type of request as determined by the Opcode
	*/
	switch(Opcode)
	{
	
	   /*
	    name registration and refresh are handled the same way
	   */
	   case(NMSMSGF_E_NAM_REF):		
	   case(NMSMSGF_E_NAM_REF_UB):		
		DBGPRINT0(FLOW, "It is a name refresh request\n");

	   case(NMSMSGF_E_NAM_REG): 	/* fall through */
	   case(NMSMSGF_E_MULTIH_REG): 	/* fall through */

		/*
		* Get the flag indicating whether the request is a group
		* registration or a  unique name registration.  The IP
		* address(es) is (are) also retrieved
		*/
		GetOtherInfo(
			   Opcode,
			   pTmp,
			   QuesNamSecLen,
			   &fGrp,
			   &CntAdd,
			   &NodeTyp_e
			 );		
		//
		// If it is not a group or a multihomed registration or
		//
		if (!fGrp  && (Opcode != NMSMSGF_E_MULTIH_REG))
		{
			/*
			 * Register the unique name
			*/
			NmsNmhNamRegInd(
				pDlgHdl,
				Name,
				NameLen,
				CntAdd.Add,
				(BYTE)NodeTyp_e,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				Opcode == NMSMSGF_E_NAM_REG ? FALSE : TRUE,
				NMSDB_ENTRY_IS_NOT_STATIC,	
				FALSE    //is it admin flag ?
					);
		}
		else  //it is a group or is mutihomed
		{
			/*
			 * Register the group name
			*/
			NmsNmhNamRegGrp(
				 pDlgHdl,
				 Name,
				 NameLen,
				 &CntAdd,
				 (BYTE)NodeTyp_e,
				 pMsg,
				 MsgLen,
				 QuesNamSecLen,
				 fGrp ? NMSDB_NORM_GRP_ENTRY : (Opcode == NMSMSGF_E_MULTIH_REG) ? NMSDB_MULTIHOMED_ENTRY : NMSDB_NORM_GRP_ENTRY,
                         //passing NMSDB_NORM_GRP_ENTRY for spec. grp is fine
                         //see NmsNmhNamRegGrp()
				 Opcode == NMSMSGF_E_NAM_REG ? FALSE : TRUE,
				 NMSDB_ENTRY_IS_NOT_STATIC,	
				 FALSE    //is it admin ?
				       );
		}

		break;

	   case(NMSMSGF_E_NAM_QUERY):

#if 0
		Address.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
		Address.AddLen    = sizeof(COMM_IP_ADD_T);
		COMM_GET_IPADD_M(pDlgHdl, &Address.Add.IPAdd);
#endif

#if 0
		//
		// NOTE: Multiple NBT threads could be doing this simultaneously
		//
		//  This is the best I can do without a critical section
		//
FUTURES("The count may not be correct when retrieved by an RPC thread")
		WinsIntfStat.Counters.NoOfQueries++;
#endif
		/*
		  Query the name
		*/
		NmsNmhNamQuery(
				pDlgHdl,
				Name,
				NameLen,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				FALSE,		// is it admin flag
				NULL		//should be non NULL only in
						//an RPC thread
			      );
		break;
	

	   case(NMSMSGF_E_NAM_REL):

		GetOtherInfo(
			   NMSMSGF_E_NAM_REL,
			   pTmp,
			   QuesNamSecLen,
			   &fGrp,
			   &CntAdd,
			   &NodeTyp_e
			 );		

		
		//
		// We should pass down to NmsNmhNamRel function the
		// address of the client requesting name release, not
		// the address passed in the RFC pkt.  The address
		// will be used by NmsDbRelRow to check if the client
		// is authorized to release the record
		//
		Address.AddTyp_e  = COMM_ADD_E_TCPUDPIP;
		Address.AddLen    = sizeof(COMM_IP_ADD_T);
		COMM_GET_IPADD_M(pDlgHdl, &Address.Add.IPAdd);

		/*
		 * Release the name
		*/
		NmsNmhNamRel(
				pDlgHdl,
				Name,
				NameLen,
				&Address,
				fGrp,
				pMsg,
				MsgLen,
				QuesNamSecLen,
				FALSE    //is it admin flag ?
			    );
		break;

	   default:

		fBuffFreed = FALSE;
		DBGPRINT1(EXC, "NmsMsgfProcNbtReq: Invalid Opcode\n", Opcode);
		WINS_RAISE_EXC_M(WINS_EXC_PKT_FORMAT_ERR);
		WINSEVT_LOG_M(Opcode, WINS_EVT_INVALID_OPCODE);

		break;
	}
	
  }
except(EXCEPTION_EXECUTE_HANDLER)  {
	DBGPRINTEXC("NmsMsgfProcNbtReq");

        if (GetExceptionCode() == WINS_EXC_NBT_ERR)
        {
                WINS_RERAISE_EXC_M();
        }

	//
	//  Free the message buffer if not already freed, delete the
	//  dialogue if it is a UDP dialogue.
	//	
	if (!fBuffFreed)
	{
		ECommFreeBuff(pMsg);		
		ECommEndDlg(pDlgHdl);
	}
   }


	DBGLEAVE("NmsMsgfProcNbtReq\n");
        return(WINS_SUCCESS);	
}


VOID
GetName(
	IN  OUT LPBYTE    *ppName,
	IN  OUT LPBYTE 	  pName,
	OUT LPDWORD   pNameLen
	)

/*++

Routine Description:

	This function is called to retrieve the name from the name
	request packet.

Arguments:

	ppName   -- address of ptr to question section in datagram received
	pName	 -- Address of array to hold the name. It is assumed that this is
                atleast NMSMSGF_RFC_MAX_NAM_LEN long.
	pNameLen -- address of variable to hold length of name

Externals Used:
	None

Called by:
	NmsNmhProcNbtReq	

Comments:
	None
	
Return Value:

	None
--*/

{

   INT	  HighTwoBits;  	//First two bits of Question Name section
   INT	  Length;      		//length of label  in Question Name section
   BYTE	  ch;
   LPBYTE pNmInPkt = *ppName;
   INT    inLen   = NMSMSGF_RFC_MAX_NAM_LEN;  // Store the length of the name.


   *pNameLen = 0;

   /*
	Get the high two bits of the first byte of the Question_NAME
	section.  The bits have to be 00.  If they are not, something
	is really wrong.
   */

   if ((HighTwoBits = (NAME_FORMAT_MASK & *pNmInPkt)) != 0)
   {
       goto BadFormat;
   }

   /*
   *	Get the length of the label. Length, extracted this way, is
   *    guranteed to be <= 63.
   */
   Length = LENGTH_MASK & *pNmInPkt;


   pNmInPkt++;	//increment past the length byte


   /*
    *  Decode the first label of the name (the netbios name without the
    *   scope).
    */

   while(Length > 0 )
   {
       ch = *pNmInPkt++ - 'A';
	*pName++  = (ch << 4) | (*pNmInPkt++ - 'A');
	(*pNameLen)++;
	Length -= 2;
   }	

   inLen -= Length;

  /*
     Extract the netbios scope if present
	The netbios scope is not in encoded form
  */
  while(TRUE)
  {
        /*
        * if length byte is not 0, there is a netbios scope.
	* We make sure that if the packet is ill-formed (i.e. the
        * length of the name (including the length bytes) is > 255, we raise
	* an exception. Since *pNameLen is counting the number of bytes
	* in the name that we are forming, we need to compare it with
	* (255 - 16) = 239 since the first 32 bytes of the netbios name
	* map to 16 bytes of our internal name.
        */
   	if (*pNmInPkt != 0)
   	{
		if (*pNameLen > MAX_SIZE_INTERNAL_NAME)
		{
            goto BadFormat;
		}

        if ( --inLen <= 0) {
            goto BadFormat;
        }
	        *pName++ = '.';
		(*pNameLen)++;
   		Length = LENGTH_MASK & *pNmInPkt;

        // check that the we have enough space remaining in the input buffer.
        //
        if ( (inLen -= Length) <= 0 ) {
            goto BadFormat;
        }

		++pNmInPkt;  	//increment past length byte

   		while(Length-- != 0)
        	{
			*pName++ = *pNmInPkt++;
			(*pNameLen)++;
   		}	
   	}
	else
	{
		++pNmInPkt;  	//increment past end  byte (00)
		break;
	}
   }

    if (--inLen >= 0) {
        *pName++ = 0;   /* EOS	*/
    } else {
        goto BadFormat;
    }

   (*pNameLen)++;   //include 0 in the name's length so that it is stored
		    //in the db.  Check out FormatName too since it expects
		    //the length to include this 0

   *ppName  = pNmInPkt; //init the ppName ptr to point just past the name

   return;

BadFormat:
   // log error and raise an exception
   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_PKT_FORMAT_ERR);
   WINS_RAISE_EXC_M(WINS_EXC_PKT_FORMAT_ERR);

   return;
}




STATUS
GetOtherInfo(
	NMSMSGF_NAM_REQ_TYP_E 	   Opcode_e,
	IN LPBYTE		   pRR,	   /*point to the RR_NAME section in the
				   	    *name registration packet
					    */
	IN   INT	           QuesNamSecLen, /*size of Ques name section*/
	OUT  LPBOOL		   pfGrp,  /*flag -- unique/group entry	*/
	OUT  PNMSMSGF_CNT_ADD_T    pCntAdd, /*Counted address array*/
	OUT  PNMSMSGF_NODE_TYP_E   pNodeTyp_e
	)

/*++

Routine Description:
	The function is called to retrieve information other than the
	the name from the pkt

Arguments:
	pRR  	      - address of RR_NAME section in the request packet
	QuesNamSecLen - length of the question names section in the request pkt
	pfGrp	      - TRUE if it is a group registration request
	pAddress      - Address contained in the request
        NodeTyp_e     - Type of node doing the registeration (P, B, M)


Externals Used:
	None

Called by:
	NmsMsgfProcNbtReq

Comments:
	None
	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
	INT	HighTwoBits;
	BYTE    *pTmp = pRR;
	LONG UNALIGNED	*pTmpL;


	/*
	 * RR_NAME section should contain a pointer to the Question Section. So
	 * we could skip it.  We are not, however,  just in case another
	 * implementation of NBT does not follow the recommendations of the
	 * RFC and passes us the full name in RR_NAME section
	*/
   	if ((HighTwoBits = NAME_FORMAT_MASK & *pTmp) == 0)
   	{
	
		/*
		 * skip the name (same size as in question_name section) and the
		 * RR_TYPE, RR_CLASS, TTL and RDLENGTH fields
		*/
		pTmp += QuesNamSecLen + RFC_LEN_RRTYP_N_RRCLS +
				RFC_LEN_TTL + RFC_LEN_RDLEN;

   	}
	else
	{
	  	/*
		 * skip the pointer bytes (2), RR_TYPE, RR_CLASS, TTL, and
		 * RDLENGTH flds
	        */
	  	pTmp += RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS + RFC_LEN_TTL
		  	  + RFC_LEN_RDLEN;
	}

	
	/*
	 * RFC 1002 - page 12 and 14.
	 *
	 * First 16 buts of the RData section (right after the RDLEN section
	 * has its top most bit set to 0 if the registration is for a group
	*/
	*pfGrp = GROUP_BIT_MASK & *pTmp;  // get the group bit

	/*
	 *Next two MS bits indicate the node type
	*/
	*pNodeTyp_e = (NODE_TYPE_MASK & *pTmp) >> SHIFT_NODE_BITS;
	
	/*
	* Get the IP address.  IP address is 2 bytes away,
	*/
	pTmp += 2;

NONPORT("Port when porting to NON TCP/IP protocols")

	pCntAdd->NoOfAdds = 1;

	/*
 	*  Use ntohl to get the address which is a long in the correct
 	*  byte order
	*/
	pTmpL	= (LPLONG)pTmp;
	pCntAdd->Add[0].Add.IPAdd = ntohl(*pTmpL);
	pCntAdd->Add[0].AddTyp_e  = COMM_ADD_E_TCPUDPIP;
	pCntAdd->Add[0].AddLen    = sizeof(COMM_IP_ADD_T);

	if (Opcode_e == NMSMSGF_E_MULTIH_REG)
	{
		USHORT   RdLen;
		USHORT   NoOfAddsLeft;

		//
		// We are going to register a group of addresses
		//

		//
		// Extract the RDLEN (decrement the pointer)
		//
		RdLen = (USHORT)((*(pTmp - RFC_LEN_RDLEN_N_NBF) << 8) +
				*(pTmp - RFC_LEN_RDLEN_N_NBF + 1));

		NoOfAddsLeft = ((RdLen - RFC_LEN_NBFLAGS)/COMM_IP_ADD_SIZE) - 1;
		if (NoOfAddsLeft >= NMSMSGF_MAX_NO_MULTIH_ADDS)
		{
			DBGPRINT0(FLOW, "The packet for multi-homed registration has more than the max. number of ip addresses supported for a multi-homed client. \n");
			
			WINSEVT_LOG_M(
					NoOfAddsLeft,
					WINS_EVT_LIMIT_MULTIH_ADD_REACHED
				     );
			NoOfAddsLeft = NMSMSGF_MAX_NO_MULTIH_ADDS - 1;
		}

		//
		// Get the remaining addresses
		//
		pTmp += RFC_LEN_NBADD;
		for(
				;  //null first expr
			pCntAdd->NoOfAdds < (DWORD)(NoOfAddsLeft + 1);
			pTmp += RFC_LEN_NBADD, pCntAdd->NoOfAdds++
		   )
		{
			
		  pCntAdd->Add[pCntAdd->NoOfAdds].Add.IPAdd =
						ntohl(*((LPLONG)pTmp));
		  pCntAdd->Add[pCntAdd->NoOfAdds].AddTyp_e  =
						COMM_ADD_E_TCPUDPIP;
		  pCntAdd->Add[pCntAdd->NoOfAdds].AddLen    =
						sizeof(COMM_IP_ADD_T);
		}
	}

	return(WINS_SUCCESS);
}





STATUS
NmsMsgfFrmNamRspMsg(
   PCOMM_HDL_T			pDlgHdl,
   NMSMSGF_NAM_REQ_TYP_E   	NamRspTyp_e,
   PNMSMSGF_RSP_INFO_T		pRspInfo
  	)

/*++

Routine Description:
	This function is called to format a response message for sending
	to an nbt node.

Arguments:
	pDlgHdl	     -- Dlg Handle
	NameRspTye_e -- Type of response message (registration, query, release)
			that needs to be formatted.
	pRspInfo     -- Response Info.

Externals Used:
	None

Called by:
	NmsNmhNamRegInd, NmsNmhNamRegGrp, NmsNmhNamRel, NmsNmhNamQuery

Comments:
	None
	
Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

--*/

{
	STATUS	RetStat = WINS_SUCCESS;
   	LPBYTE 	pReqBuff  = pRspInfo->pMsg;
   	LPBYTE 	pNewBuff  = pReqBuff;

	//
	// Switch on type of response
	//
	switch(NamRspTyp_e)
	{
	  	case(NMSMSGF_E_NAM_REG):  /* fall through */
	  	case(NMSMSGF_E_NAM_REF):
	  	case(NMSMSGF_E_NAM_REF_UB):

		   (VOID)FrmNamRegRsp(
			pDlgHdl,
			pRspInfo
			       );
		    break;

		case(NMSMSGF_E_NAM_QUERY):

#if 0
		   FrmNamQueryRsp(
			pDlgHdl,
			pRspInfo
				 );
#endif
   		   (VOID)FormatQueryRspBuff(
				pNewBuff,   //ptr to buffer to fill
				pReqBuff,   // ptr to req buffer
				pRspInfo,
				FALSE   //no danger of truncation since
				        //we never send more than 25 ip add
					//in the response
				   );

		    break;

		case(NMSMSGF_E_NAM_REL):

		   (VOID)FrmNamRelRsp(
				pDlgHdl,	
				pRspInfo
			      	     );

		    break;

		default:

		    // error
		    RetStat = WINS_FAILURE;
		    break;
	}

	return(RetStat);
}


STATUS
FrmNamRegRsp(
  PCOMM_HDL_T 		pDlgHdl,
  PNMSMSGF_RSP_INFO_T	pRspInfo
)

/*++

Routine Description:
	This function formats a positive or a negative name registration
	response.

Arguments:

   pDlgHdl  -- Dialogue Handle
   pRspInfo -- Information used to format the response pkt

Externals Used:
	None

Called by:
	NmsMsgfFrmNamRspMsg
Comments:
	None
	
Return Value:

   Success status codes --
   Error status codes  --

--*/

{

   LPBYTE 	pTmpB = pRspInfo->pMsg + 2;
   BYTE         SavedByte;


   /*
	We will use the same buffer that carried the request.  Simple
	moves will be done.  These should be faster than doing
	all the construction from scratch
   */


   /*
     Set the the Transaction Id, Opcode, NMFlags and Rcode field
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_OPC;
   *pTmpB++  =  RFC_NAM_REG_RSP_4THB + pRspInfo->Rcode_e;


   /*
     Set the QD count and the AN count fields
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_QDCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_QDCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ANCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ANCNT_2NDB;

   /*
    Set the NSCOUNT and ARCOUNT fields
   */
   *pTmpB++  =  RFC_NAM_REG_RSP_NSCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_NSCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ARCNT_1STB;
   *pTmpB++  =  RFC_NAM_REG_RSP_ARCNT_2NDB;

   /*
	Increment the pointer past the Question_Class Section
	RR_NAME, RR_TYPE, and RR_CLASS of response are same as
	Question_Name, Question_Type, and Question_Class of
	nbt request.
   */

   pTmpB +=  pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

   SavedByte = *pTmpB & NAME_FORMAT_MASK; //save the format bits of RR section

CHECK("In case of a negative response, does it matter what I put in the TTL")
CHECK("field. It shouldn't matter -- RFC is silent about this")
   //
   // put the TTL in the response
   //
   *pTmpB++ = (BYTE)(pRspInfo->RefreshInterval >> 24);
   *pTmpB++ = (BYTE)((pRspInfo->RefreshInterval >> 16) & 0xFF);
   *pTmpB++ = (BYTE)((pRspInfo->RefreshInterval >> 8) & 0xFF);
   *pTmpB++ = (BYTE)(pRspInfo->RefreshInterval & 0xFF);

   /*
	Move memory that is after RR_NAME into appropriate place

	First we check what form the name in the RR_NAME section is.
	It should be in pointer form (pointer to the QuesNamSec) but
	could be in the regular form.
   */

   if (SavedByte == 0)
   {
	DWORD RRSecLen = pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

	// RR_NAME is as big as the Question_name section.
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RRSecLen,
		RFC_LEN_RDLEN_N_NBF_N_NBA
		     );

   }
   else
   {
	// RR_NAME is a ptr so it takes up 2 bytes.
   	WINSMSC_MOVE_MEMORY_M(
		      pTmpB,
		      pTmpB + RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS,
		      RFC_LEN_RDLEN_N_NBF_N_NBA
		     );
   }

   pTmpB 	    +=   RFC_LEN_RDLEN_N_NBF_N_NBA;
   pRspInfo->MsgLen =    (ULONG) (pTmpB - (LPBYTE)pRspInfo->pMsg);

   return(WINS_SUCCESS);
}



STATUS
FrmNamRelRsp(
  PCOMM_HDL_T 		   pDlgHdl,
  PNMSMSGF_RSP_INFO_T      pRspInfo
)

/*++

Routine Description:

  This function formats a positive or negative name query response.
  The request buffer is made use of for the response.

Arguments:

   pDlgHdl  -- Dialogue Handle
   pRspInfo -- Response Info

Externals Used:
	None

Called by:
	NmsMsgfFrmRspMsg()
Comments:
	None
	
Return Value:

   Success status codes --
   Error status codes  --

--*/

{
   LPBYTE 	pTmpB = pRspInfo->pMsg + 2;
   //LPBYTE 	pTmpB2;


   /*
	We will use the same buffer that carried the request.  Simple
	moves will be done.  These should be faster than doing
	all the construction from scratch
   */

   /*
     Set the the Transaction Id, Opcode, NMFlags and Rcode field
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_OPC;
   *pTmpB++  =  RFC_NAM_REL_RSP_4THB + pRspInfo->Rcode_e;


   /*
     Set the QD count and the AN count fields
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_QDCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_QDCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ANCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ANCNT_2NDB;

   /*
    Set the NSCOUNT and ARCOUNT fields
   */
   *pTmpB++  =  RFC_NAM_REL_RSP_NSCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_NSCNT_2NDB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ARCNT_1STB;
   *pTmpB++  =  RFC_NAM_REL_RSP_ARCNT_2NDB;


   /*
	Increment the pointer past the Question_Class Section
	RR_NAME, RR_TYPE, and RR_CLASS of response are same as
	Question_Name, Question_Type, and Question_Class of
	nbt request.
   */
   pTmpB += pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

   if ((*pTmpB & NAME_FORMAT_MASK) == 0)
   {
	DWORD RRSecLen = pRspInfo->QuesNamSecLen + RFC_LEN_QTYP_N_QCLS;

	// RR_NAME is as big as the Question_name section.
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RRSecLen,
		RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA
		     );
  }	
  else
  {
	// RR_NAME is a ptr so it takes up 2 bytes. 2 + 4 = 6	
   	WINSMSC_MOVE_MEMORY_M(
		pTmpB,
		pTmpB + RFC_LEN_RRPTR + RFC_LEN_RRTYP_N_RRCLS,
		RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA
		     );
   }
   pTmpB += RFC_LEN_TTL_N_RDLEN_N_NBF_N_NBA;

#if 0
// not needed. We always return the NBFLAGS and Address of the requestor
   pTmpB2 =  pTmpB - RFC_LEN_NBFLAGS - RFC_LEN_NBADD;

   //
   // Set the NBFLAGS field
   //
   if (pRspInfo->EntTyp == NMSDB_SPEC_GRP_ENTRY)
   {
   	*pTmpB2++     = 0x80;
   	*pTmpB2++     = 0x00;
   }
   else
   {
	   COMM_IP_ADD_T IPAdd =  pRspInfo->pNodeAdds->Mem[0].Add.Add.IPAdd;
           if (pRspInfo->EntTyp == NMSDB_NORM_GRP_ENTRY)
	   {
   		*pTmpB2++     = 0x80;
	   }
	   else  //it is a unique entry
	   {
   	   	*pTmpB2++     = pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
	   }
   	   *pTmpB2++     = 0x00;

	   *pTmpB2++ = (BYTE)(IPAdd >> 24);        //MSB
	   *pTmpB2++ = (BYTE)((IPAdd >> 16) % 256);
	   *pTmpB2++ = (BYTE)((IPAdd >> 8) % 256);
	   *pTmpB2++ = (BYTE)(IPAdd % 256); 	   //LSB
	
   }
#endif

   pRspInfo->MsgLen = (ULONG) (pTmpB  - (LPBYTE)pRspInfo->pMsg);
   return(WINS_SUCCESS);

}


#if 0

STATUS
FrmNamQueryRsp(
  IN  PCOMM_HDL_T 	   	pDlgHdl,
  IN  PNMSMSGF_RSP_INFO_T      	pRspInfo
)

/*++

Routine Description:
	This function formats a name query response

Arguments:
   pDlgHdl -- Dialogue Handle
   pRspInfo -- Response Info

Externals Used:
	None

Called by:
	NmsNmhFrmRspMsg()

Comments:
	None
	
Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Comments:  Not used currently.  Will make use of it when we have the
	   potential to send more data than can fit in a query response
	   datagram

--*/

{
   BOOL		fTrunc    = FALSE;
   LPBYTE 	pReqBuff  = pRspInfo->pMsg;
   LPBYTE 	pNewBuff  = pReqBuff;
   STATUS	RetStat   = WINS_SUCCESS;

FUTURES("Currently, since we never send more than 25 addresses, there is no")
FUTURES(" danger of overflowing the buffer.  In the future, if we ever change")
FUTURES("that, we should unconditinalize the code below, compile it and check")
FUTURES("it out.  It needs to be modified.  The computation of the size")
FUTURES("is faulty")
   DWORD	RspLen    = 0;
   BYTE		*pTmpB	  = NULL;




   /*
	If this is to be sent as a datagram we will use the same buffer
        that carries the request.

	If it is to be sent on a TCP connection
	we will still use the same buffer if it is a negative name query
	response. If, however, a positive name query response has to be
	sent, we will allocate a buffer storing the response

   */


   if ((!COMM_IS_TCP_MSG_M(pDlgHdl))
   {

	/*
	In the following there is no need to check fGrp flag but
	let us do it for insurance
	*/
	if ((Rcode_e == NMSMSGF_E_SUCCESS) && (NodeAdds.fGrp))
	{
		/*
	  	Check if we need to set the truncation bit in the
	  	datagram.

	  	To do the above,

		Compute the size of the buffer required to house all
		the information and compare with the datagram size
		*/

		if (
			(
			  RspLen = pDlgHdl->MsgLen + RFC_LEN_TTL_N_RDLEN +
				(NodeAdds.NoOfMems * sizeof(COMM_IP_ADD_T))
			)
				> COMM_DATAGRAM_SIZE
		   )
		{
			fTrunc = TRUE;
		}
        }
   }
   else // TCP message with Rcode_e of success
   {

	if (
		(
		  RspLen = *pMsgLen + RFC_LEN_TTL_N_RDLEN +
				(NodeAdds.NoOfMems * sizeof(COMM_IP_ADD))
		)
				> COMM_DATAGRAM_SIZE
	    )
	{
		WinsMscAlloc(RspLen, &pNewBuff);
		if (pNewBuff == NULL)
		{
		   return(WINS_FAILURE);
		}
	}



	*ppMsg = pNewBuff;
	Status = FormatQueryRspBuff(
			pNewBuff,   //ptr to buffer to fill
			pReqBuff,   // ptr to req buffer
			pRspInfo,
			ftrunc
				   );

	WinsMscHeapFree(
			CommUdpBuffHeapHdl,
			pReqBuff
		       ); // get rid of the old buffer


	return(Status);

   }

   RetStat = FormatQueryRspBuff(
			pNewBuff,   //ptr to buffer to fill
			pReqBuff,   // ptr to req buffer
			pRspInfo,
			fTrunc
				   );

   return(RetStat);

}
#endif


STATUS
FormatQueryRspBuff(
   IN  LPBYTE 		   pDest,
   IN  LPBYTE 		   pSrc,
   IN  PNMSMSGF_RSP_INFO_T pRspInfo,
   IN  BOOL		   fTrunc
  	)

/*++

Routine Description:
	This function formats the response for a name query request
	
Arguments:
	pDest - Buffer to contain the formatted response
	pSrc  - Buffer containing the formatted request
	pRspInfo - Response Information
	fTrunc   - whether the response packet is to have the truncation bit set

Externals Used:
	None

Called by:
	FrmNamQueryRsp()

Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE
--*/

{

        DWORD   no;
	LPBYTE  pDestB	  = pDest;
	DWORD	LenOfAdds;
	DWORD	IPAdd;

	*pDestB++ = *pSrc;
	*pDestB++ = *(pSrc + 1);

   	/*
     	The Transaction Id, Opcode, NMFlags and Rcode field
   	*/
   	*pDestB++ =
		( *(pSrc + 2) |
		      ((fTrunc == FALSE)
		           ? RFC_NAM_QUERY_RSP_OPC_NO_T
	                   : RFC_NAM_QUERY_RSP_OPC_T)
		);

	*pDestB++ = RFC_NAM_QUERY_RSP_4THB + pRspInfo->Rcode_e;

   	/*
     	 *	Set the QD count and the AN count fields
   	*/
	*pDestB++  =  RFC_NAM_QUERY_RSP_QDCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_QDCNT_2NDB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ANCNT_1STB;

   	*pDestB++  =  (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS) ?
			RFC_NAM_QUERY_POS_RSP_ANCNT_2NDB
			: RFC_NAM_QUERY_NEG_RSP_ANCNT_2NDB;

   	/*
    	Set the NSCOUNT and ARCOUNT fields
   	*/
	*pDestB++  =  RFC_NAM_QUERY_RSP_NSCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_NSCNT_2NDB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ARCNT_1STB;
	*pDestB++  =  RFC_NAM_QUERY_RSP_ARCNT_2NDB;
	
        pSrc  += pDestB - pDest;

   	/*
	Increment the counter past the Question_Name Section (which is known
	as the RR_NAME section here).

	Use MoveMemory here instead of Copy Memory.  Move Memory handles
	overlapped copies which will happen if pDest and pSrc are
	pointing to the same buffer
   	*/

   	WINSMSC_MOVE_MEMORY_M(
		pDestB,
		pSrc,
		pRspInfo->QuesNamSecLen
		     );

	pDestB +=  pRspInfo->QuesNamSecLen;

	if (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS)
	{
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_NB_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_NB_2NDB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_IN_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_POS_RSP_IN_2NDB;  //RFC 1002 -- page 22
	}
	else
	{
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_NB_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_NB_2NDB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_IN_1STB;  //RFC 1002 -- page 22
	  *pDestB++ = RFC_NAM_QUERY_NEG_RSP_IN_2NDB;  //RFC 1002 -- page 22
	}

	if (!fTrunc)
        {

	  if (pRspInfo->Rcode_e == NMSMSGF_E_SUCCESS)
	  {

CHECK("In case of a negative response, does it matter what I put in the TTL")
CHECK("field. It shouldn't matter -- RFC is silent about this")
	  	/*
	    	  Put 0 in the TTL field. TTL field will not be looked at by the
	    	  Client.
	        */
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;

		//
		// Get the RDLENGTH value
		//
	        LenOfAdds = pRspInfo->pNodeAdds->NoOfMems *
				(RFC_LEN_NBFLAGS  + sizeof(COMM_IP_ADD_T));

		*pDestB++ = (BYTE)(LenOfAdds >> 8);    //MSB
		*pDestB++ = (BYTE)(LenOfAdds % 256);   //LSB

		//
		// Put the NBFLAGS here
		//
		if (
			(pRspInfo->EntTyp != NMSDB_UNIQUE_ENTRY)
		   )
		{	
                        BYTE Nbflags;
                        DWORD StartIndex;
                        if ( pRspInfo->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                        {
			        Nbflags =
                                   pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
                        }
                        else
                        {
                                //
                                // it is a group (normal/special)
                                //
                                Nbflags = 0x80;
                        }
                        //
                        // It is a group (normal or special) or a multihomed
                        // entry
                        //
                        if (pRspInfo->pNodeAdds->NoOfMems &&
                            WinsCnf.fRandomize1CList &&
                            NMSDB_SPEC_GRP_ENTRY == pRspInfo->EntTyp ) {
                            StartIndex = rand() % pRspInfo->pNodeAdds->NoOfMems;;
                        } else {
                            StartIndex = 0;
                        }
                        for (no = StartIndex; no < pRspInfo->pNodeAdds->NoOfMems; no++)
                        {

                          *pDestB++ = Nbflags;
                          *pDestB++ = 0x0;
                          IPAdd =   pRspInfo->pNodeAdds->Mem[no].Add.Add.IPAdd;
                              NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
                            }
                        for (no = 0; no < StartIndex; no++)
                        {

                          *pDestB++ = Nbflags;
                          *pDestB++ = 0x0;
                          IPAdd =   pRspInfo->pNodeAdds->Mem[no].Add.Add.IPAdd;
                              NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
                            }

		}
		else
		{
			//
			// It is a unique entry
			//
			*pDestB++ = pRspInfo->NodeTyp_e << NMSDB_SHIFT_NODE_TYP;
			*pDestB++ = 0x0;
		        IPAdd =   pRspInfo->pNodeAdds->Mem[0].Add.Add.IPAdd;
		        NMSMSGF_INSERT_IPADD_M(pDestB, IPAdd);
		}
	  }
	  else  //this is a negative name query response
	  {
	  	/*
	    	  Put 0 in the TTL field. TTL field will not be looked at by the
	    	  Client.
	        */
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;
                *pDestB++  = 0;

		/*
		  Put 0 in the RDLENGTH field since we are not passing any
		  address(es)
		*/
                *pDestB++  = 0;
                *pDestB++  = 0;

	  }
CHECK("When a truncated response is sent to the client, is it ok to not")
CHECK("Send any field after the RR_NAME section.  RFC is silent about this")
CHECK("For now, it is ok, since we will never have a situation where a ")
CHECK("truncated response needs to be sent")

         pRspInfo->MsgLen = (ULONG) (pDestB - pDest);

	}
	else
	{
	  //this is a truncated response (does not have any field after
	  //RR_NAME section
          pRspInfo->MsgLen = (ULONG) (pDestB - pDest);
	}

   return(WINS_SUCCESS);

}


VOID
FormatName(
	IN     LPBYTE pNameToFormat,
	IN     DWORD  NamLen,
	IN OUT LPBYTE *ppFormattedName
	)

/*++

Routine Description:
	This function is called to format a name


Arguments:
	pNameToFormat  -- Name to format
	LengthOfName   -- Length of Name
	pFormattedName -- Name after it has been formatted


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
	Note: This function should be called to format only those names
	       whose length as indicated by NameLen includes the ending
	       0. All names stored in the database are valid.
	
--*/

{
	LPBYTE  pTmpB    = *ppFormattedName;
	DWORD	Length;
	LPBYTE  pSaveAdd = pTmpB;  //save address of length octet

	
FUTURES("take out the check below to improve performance")
	//
	//  If NamLen is more then what is prescribed in RFC 1002,
	//  there is something really wrong.  This calls for raising
	//  an exception
	//
	if (NamLen > RFC_MAX_NAM_LEN)
	{
		WINS_RAISE_EXC_M(WINS_FATAL_ERR);
	}

	pTmpB++;		//skip the length octet.  We will write to
				//it later. We have stored the address in
				//pSaveAdd
	NamLen--;		//decrement Namelen since we always store
				//0 at the end of the name. NameLen includes
				//this extra byte
	for (
		Length = 0;
		(*pNameToFormat != '.') && (NamLen != 0);
		Length += 2, NamLen--
	   )
	{
		*pTmpB++ = 'A' + (*pNameToFormat >> 4);
		*pTmpB++ = 'A' + (*pNameToFormat++ & 0x0F);
	}

	*pSaveAdd = (BYTE)Length;
	
	while(NamLen != 0)
	{

		pNameToFormat++;     //increment past the '.'
		pSaveAdd  = pTmpB++; //save add; skip past length octet
			
		NamLen--;	     //to account for the '.'

		for (
			Length = 0;
			(*pNameToFormat != '.') && (NamLen != 0);
			Length++, NamLen--
	   	    )
		{
			*pTmpB++ = *pNameToFormat++;
		}

FUTURES("take out the check below to improve performance")
		//
		// Make sure there is no weirdness
		//
		if (Length > RFC_MAX_LABEL_LEN)
		{
			WINS_RAISE_EXC_M(WINS_FATAL_ERR);
		}
	
		*pSaveAdd = (BYTE)Length;
		if (NamLen == 0)
		{
			break;   //reached end of name
		}

	}

	*pTmpB++         = EOS;
	*ppFormattedName = pTmpB;
	return;
}
	
VOID
NmsMsgfFrmNamQueryReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen
	)

/*++

Routine Description:

	This function formats a name query request packet

Arguments:
	TransId  	-  Transaction Id. to use
	pMsg    	-  Msg Buffer to format
	pMsgLen 	-  Length of formatted message
	pNameToFormat   -  Name to format
	NameLen		-  Length of Name
	

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	HandleWrkItm in nmschl.c

Side Effects:

Comments:
	None
--*/

{
	LPBYTE   pTmpB = pMsg;

	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = (BYTE)(TransId >> 8);
	*pTmpB++ = (BYTE)(TransId & 0xFF);
	

	*pTmpB++ = RFC_NAM_QUERY_REQ_OPCB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_4THB;
			
	*pTmpB++ = RFC_NAM_QUERY_REQ_QDCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QDCNT_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ANCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ANCNT_2NDB;

	*pTmpB++ = RFC_NAM_QUERY_REQ_NSCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_NSCNT_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ARCNT_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_ARCNT_2NDB;

	FormatName(pNameToFormat, NameLen, &pTmpB);
	
	*pTmpB++ = RFC_NAM_QUERY_REQ_QTYP_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QTYP_2NDB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QCLS_1STB;
	*pTmpB++ = RFC_NAM_QUERY_REQ_QCLS_2NDB;

	*pMsgLen = (ULONG) (pTmpB - pMsg);
	return;	
}


VOID
NmsMsgfFrmNamRelReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	)
/*++

Routine Description:

	This function formats a name release request packet

Arguments:
	TransId  	-  Transaction Id. to use
	pMsg    	-  Msg Buffer to format
	pMsgLen 	-  Length of formatted message
	pNameToFormat   -  Name to format
	NameLen		-  Length of Name
	NodeTyp_e	-  Type of Node
	NodeAdd	        -  IP address of node
	

Externals Used:
	None

	
Return Value:
	None

Error Handling:

Called by:
	HandleWrkItm() in nmschl.c
Side Effects:

Comments:
	None
--*/
{

	LPBYTE   pTmpB = pMsg;


	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = (BYTE)(TransId >> 8);
	*pTmpB++ = (BYTE)(TransId & 0xFF);

	*pTmpB++ = RFC_NAM_REL_REQ_OPCB;
	*pTmpB++ = RFC_NAM_REL_REQ_4THB;
			
	*pTmpB++ = RFC_NAM_REL_REQ_QDCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QDCNT_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_ANCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_ANCNT_2NDB;

	*pTmpB++ = RFC_NAM_REL_REQ_NSCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_NSCNT_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_ARCNT_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_ARCNT_2NDB;

	FormatName(pNameToFormat, NameLen, &pTmpB);
	
	*pTmpB++ = RFC_NAM_REL_REQ_QTYP_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QTYP_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_QCLS_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_QCLS_2NDB;


	*pTmpB++ = 0xC0;
	*pTmpB++ = 0x0C;  //Name is at offset 12 from start of message
	
	*pTmpB++ = RFC_NAM_REL_REQ_RRTYP_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRTYP_2NDB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRCLS_1STB;
	*pTmpB++ = RFC_NAM_REL_REQ_RRCLS_2NDB;

	//
	// TTL
	//
	*pTmpB++ =  0;
	*pTmpB++ =  0;
	*pTmpB++ =  0;
	*pTmpB++ =  0;

	//
	// RDLENGTH field
	//
	*pTmpB++ = 0x0;
	*pTmpB++ = 0x6; 	//number of bytes to follow


	//
	// NBFLAGS word  (Bit 15 is Group bit (0); bit 13 and 14 are node
	// type bits, rest of the bits are reserved
	//
	*pTmpB++ = NodeTyp_e << 13;
	*pTmpB++ = 0;

	//
	// Store the IP address. MSB first, LSB last (Network Byte Order)
	//
	NMSMSGF_INSERT_IPADD_M(pTmpB, pNodeAdd->Add.IPAdd);
	
	*pMsgLen = (ULONG) (pTmpB - pMsg);
	return;	
}

VOID
NmsMsgfFrmWACK(
  IN  LPBYTE			pBuff,
  OUT LPDWORD			pBuffLen,
  IN  MSG_T	   		pMsg,
  IN  DWORD			QuesNamSecLen,
  IN  DWORD			WackTtl
	)

/*++

Routine Description:
	This function is called to format a WACK for a name registration
	request.

Arguments:

	Buff	      - Buffer to be filled up with WACK msg fields
	pBuffLen      - size of Buffer
	pMsg          - Request Message received
	QuesNamSecLen - Length of Ques Nam Sec of the request message
	WackTtl       - TTL in msecs

Externals Used:
	None

	
Return Value:

	None

Error Handling:

Called by:
	NmsChlHdlNamReg()

Side Effects:

Comments:
	
--*/

{
	LPBYTE   pTmpB = pBuff;
	LPBYTE   pName = pMsg + NAME_HEADER_SIZE;
	DWORD	 Ttl;

	//
	// Compute the TTL in secs (WackTtl is in msecs)
	//
	Ttl = WackTtl / 1000;
	if (WackTtl % 1000 > 0)
	{
		Ttl++;
	}

	/*
	 * Put the Transaction Id in
	*/	
	*pTmpB++ = *pMsg;
	*pTmpB++ = *(pMsg + 1);
	

	*pTmpB++ = RFC_WACK_OPCB;
	*pTmpB++ = RFC_WACK_4THB;
			
	*pTmpB++ = RFC_WACK_QDCNT_1STB;
	*pTmpB++ = RFC_WACK_QDCNT_2NDB;
	*pTmpB++ = RFC_WACK_ANCNT_1STB;
	*pTmpB++ = RFC_WACK_ANCNT_2NDB;

	*pTmpB++ = RFC_WACK_NSCNT_1STB;
	*pTmpB++ = RFC_WACK_NSCNT_2NDB;
	*pTmpB++ = RFC_WACK_ARCNT_1STB;
	*pTmpB++ = RFC_WACK_ARCNT_2NDB;

	WINSMSC_COPY_MEMORY_M(
			pTmpB,
			pName,
			QuesNamSecLen
		     );
			
	pTmpB  += QuesNamSecLen;

	
	*pTmpB++ = RFC_WACK_RRTYP_1STB;
	*pTmpB++ = RFC_WACK_RRTYP_2NDB;
	*pTmpB++ = RFC_WACK_RRCLS_1STB;
	*pTmpB++ = RFC_WACK_RRCLS_2NDB;

	//
	// TTL
	//
	*pTmpB++ =  (BYTE)(Ttl >> 24);
	*pTmpB++ =  (BYTE)((Ttl >> 16) % 256);
	*pTmpB++ =  (BYTE)((Ttl >> 8) % 256);
	*pTmpB++ =  (BYTE)(Ttl % 256);


	*pTmpB++ = RFC_WACK_RDLENGTH_1STB;
	*pTmpB++ = RFC_WACK_RDLENGTH_2NDB;


	//
	// Store the Opcode and NM_FLAGS field.  These fields can	
	// be retrieved directly from the 3rd and 4th byte of the message
	//
	*pTmpB++ = *(pMsg + 2);
	*pTmpB++ = *(pMsg + 3);

		
	*pBuffLen = (ULONG) (pTmpB - pBuff);

	return;	

}




STATUS
NmsMsgfUfmNamRsp(
	IN  LPBYTE		       pMsg,
	OUT PNMSMSGF_NAM_REQ_TYP_E     pOpcode_e,
	OUT LPDWORD		       pTransId,
	OUT LPBYTE		       pName,
	OUT LPDWORD 		       pNameLen,
	OUT PNMSMSGF_CNT_ADD_T	       pCntAdd,
	//OUT PCOMM_IP_ADD_T	       pIpAdd,
	OUT PNMSMSGF_ERR_CODE_E	       pRcode_e,
    OUT BOOL                       *fGroup
	)

/*++

Routine Description:


	The function unformats the response message

Arguments:
	pMsg      - Msg received (to unformat)	
	pOpcde_e  - Opcode
	pTransId  - Transaction Id.
	pName     - Name
	pNameLen  - Name length returned.
	pIpAdd    - IP address
	pRcode_e  - error type (or success)

Externals Used:
	None

Called by:
	ProcRsp in NmsChl.c


Comments:
	None
	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

--*/

{
	LPBYTE 		       pTmpB   = pMsg;

	//	
	// get the opcode. Extracts the 4 bits in the 3rd byte (bit 11-bit 14)
	//
	*pOpcode_e = (NMS_OPCODE_MASK & *(pTmpB + 2)) >> 3;

	if (    (*pOpcode_e != NMSMSGF_E_NAM_QUERY) &&	
	        (*pOpcode_e != NMSMSGF_E_NAM_REL)
	   )
	{

		*pOpcode_e = NMSMSGF_E_INV_REQ;
		return(WINS_FAILURE);

	}

	//
	// Get the transaction id
	//
	*pTransId  = (DWORD)((*pTmpB  << 8) + *(pTmpB + 1));
//	*pTransId |= (DWORD)(*(pTmpB + 1));

	//
	// get the Rcode_e
	//
	*pRcode_e =  *(pTmpB + 3) % 16;
	
	
	/*
	* make pTmpB point to the RR Section. All name request/response
	* packets have a name header of standard size (RFC 1002) at the top
	*/

	pTmpB += NAME_HEADER_SIZE;

	/*
	 * Extract the name ind store in Name. GetName will update pTmp to
	 * point just beyond  the name in the RR section
	*/

	GetName(
		&pTmpB,
		pName,
		pNameLen
	       );


	//
	//  If it is a negative name query response we are done
	//
	if (
		(*pOpcode_e == NMSMSGF_E_NAM_QUERY)  &&
	   	(*pRcode_e != NMSMSGF_E_SUCCESS)
	   )
	{
		return(WINS_SUCCESS);
	}
	else
	{
	     DWORD  i;

	     pTmpB += RFC_LEN_RR_N_TTL;
		
	     pCntAdd->NoOfAdds =
			((*pTmpB << 8) + *(pTmpB + 1))/RFC_LEN_NBF_N_NBA;	
	     pTmpB += RFC_LEN_RDLEN;
         // 15th bit in NBFLAGS indicates if this is a group name
         *fGroup = (*pTmpB & 0x80 ? TRUE:FALSE);
         pTmpB += RFC_LEN_NBFLAGS;

	     //
             // we have either positive query response or a response to a
	     // release
             //
	     for (	i = 0;
#if 0
			i < min(pCntAdd->NoOfAdds, NMSMSGF_MAX_NO_MULTIH_ADDS);
#endif
			i < min(pCntAdd->NoOfAdds, NMSMSGF_MAX_ADDRESSES_IN_UDP_PKT);
		        i++
                 )
	     {
	        //
	        // Get the IP address.  This macro will increment pTmpB by
		// 4
	        //
	        NMSMSGF_RETRIEVE_IPADD_M(pTmpB, pCntAdd->Add[i].Add.IPAdd);	
		pCntAdd->Add[i].AddTyp_e = COMM_ADD_E_TCPUDPIP;
		pCntAdd->Add[i].AddLen	 = sizeof(PCOMM_IP_ADD_T);
		pTmpB += RFC_LEN_NBFLAGS;
	    }
	}

	return(WINS_SUCCESS);
}


VOID
NmsMsgfSndNamRsp(
  PCOMM_HDL_T pDlgHdl,
  LPBYTE      pMsg,
  DWORD       MsgLen,
  DWORD       BlockOfReq
 )
{
  NMSMSGF_NAM_REQ_TYP_E Opcode;
  DWORD             NameLen;          //length of name
  DWORD             QuesNamSecLen;    //length of question name section in
                                      //packet
  DWORD             Length;

  LPBYTE  pTmp  = (LPBYTE)pMsg;
  LPBYTE  pTmp2;
  NMSMSGF_RSP_INFO_T RspInfo;
  static DWORD   sNoOfTimes = 0;

  DBGPRINT1(DET, "NmsMsgfSndNamRsp: BlockOfReq is (%d)\n", BlockOfReq);
  // get the opcode
  Opcode = (NMS_OPCODE_MASK & *(pTmp + 2)) >> 3;

  //
  // if it is a release request, we drop the datagram
  //
  if (Opcode == NMSMSGF_E_NAM_REL)
  {
        ECommFreeBuff(pMsg);
        ECommEndDlg(pDlgHdl);
        return;
  }

  /*
  * make pTmp point to the Question Section. All name request
  * packets have a name header of standard size (RFC 1002) at the top
  */
  pTmp += NAME_HEADER_SIZE;
  pTmp2 = pTmp;

  NameLen = LENGTH_MASK & *pTmp;
  pTmp  += NameLen + 1;  //pt pTmp to past the first label
  NameLen /= 2;

  while (TRUE)
  {
   if (*pTmp != 0)
   {
       if (NameLen > MAX_SIZE_INTERNAL_NAME)
       {
          ECommFreeBuff(pMsg);
          ECommEndDlg(pDlgHdl);
          return;
       }
       Length = LENGTH_MASK & *pTmp;
       NameLen += Length + 1;
       pTmp += Length + 1;     //increment past length and label
   }
   else
   {
       pTmp++;
       break;
   }
  }

  QuesNamSecLen = (ULONG) (pTmp - pTmp2);


  RspInfo.RefreshInterval = 300 * BlockOfReq;  // 5 mts
  RspInfo.Rcode_e         = NMSMSGF_E_SUCCESS;
  RspInfo.pMsg            = pMsg;
  RspInfo.MsgLen          = MsgLen;
  RspInfo.QuesNamSecLen   = QuesNamSecLen;

  NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );


  return;

}


#if 0
STATUS
NmsMsgfFrmNamRegReq(
  IN  DWORD			TransId,
  IN  MSG_T	   		pMsg,
  OUT PMSG_LEN_T      	        pMsgLen,
  IN  LPBYTE			pNameToFormat,
  IN  DWORD			NameLen,
  IN  NMSMSGF_NODE_TYP_E        NodeTyp_e,
  IN  PCOMM_ADD_T		pNodeAdd
	)

/*++

Routine Description:

	This function is called to format a name registration request

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
 		
Side Effects:

Comments:
	This fn gets called when a remote WINS has to be told to
	increment the version number of 	
--*/
{

	//
	// Lets format a name release request since this is exactly the
	// same as a name registration request except for the 2nd and
	// 3rd bytes (counting from 0) which house the opcode and
	// nmflags.  We will set these bytes apprropriately after
	// the following call
	//
	NmsMsgfNamRelReq(
  		TransId,
  		pMsg,
  		pMsgLen,
  		pNameToFormat,
  		NameLen,
  		NodeTyp_e,
  		pNodeAdd
			);


	*(pMsg + 2) = 0x29;
	*(pMsg + 3) = 0x00;

	return;	
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\wins.c ===
int
dummy()
{
return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\winsint.c ===
int
dummy()
{
return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nmsdb.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:
        nmsdb.c



Abstract:

        This module contains the functions used to interface with the
        database engine of choice.  Currently that engine is the JetBlue
        engine

Functions:
        NmsDbInit
        NmsDbInsertRowInd
        NmsDbInsertRowGrp
        NmsDbRelRow
        NmsDbQueryRow
        NmsDbUpdateRow
        NmsDbSeekNUpdateRow
        NmsDbGetDataRecs
        StoreGrpMems
        CreateTbl
        InitColInfo
        ReadOwnAddTbl
        NmsDbWriteOwnAddTbl
        NmsDbThdInit
        UpdateDb
        NmsDbUpdateVersNo
        NmsDbEndSession
        GetGrpMem
        NmsDbRelRes
        GetMaxVersNos
        InsertGrpMemsInCol
        NmsDbSetCurrentIndex
        NmsDbUpdNQueryIfMatch
        SetSystemParams

Portability:

        This module is portable to different platforms.
        It is not portable across different engines


Author:

        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/


/*
        Includes
*/
#include <time.h>
#include <stdio.h>
#include <ctype.h>
#include "wins.h"
#include "nms.h"
#include "nmsnmh.h"
#include "winsthd.h"        //

#include "esent.h"        //blue jet engine's header file

#include "nmsdb.h"        //
#include "winsmsc.h"        //
#include "winscnf.h"        //
#include "winsevt.h"        //
#include "comm.h"        //
#include "rpl.h"
#include "rplpull.h"
#include "rplpush.h"
#include "winsintf.h"
#include "nmfilter.h"

/*
 *        Local Macro Declarations
 */
#define NAMUSR                "admin"
#define PASSWD                ""

#define SYS_DB_PATH        ".\\wins\\system.mdb"
#define TEMP_DB_PATH       ".\\wins\\winstmp.mdb"
#define CHKPOINT_PATH      ".\\wins"
#define LOGFILE_PATH       CHKPOINT_PATH

// this constants are gone from the jet600 (ese.h) header file. But we still need
// these constants for jet500/jet200 code path.
#define JET_bitIndexClustered		0x00000010
#define JET_bitCommitFlush          0x00000001  /* commit and flush page buffers. */

#define INIT_NO_PAGES_IN_DB         1000        //initial size of database in pages
#define MAX_FIXED_FLD_LEN        255        //maximum size of a fixed field



#define PAD_FOR_REC_HEAP        1000        //pad to use when creating the
                                        //heap for getting records from
                                        //the db.  This pad is to take
                                        //care of heap creation overhead
                                        // and for allocating memory for
                                        // group members.


#define MAX_RECS_BEFORE_COMMIT    100    //max records to retrieve in
                                         //NmsDbGetDataRecs before doing a
                                         //commit
//
// Owner Id of the special record that stores the version number
// of an owned record deleted or replaced with a replica
//

//
// Don't want to wrap around to a negative number. Keep a pad of 16 just
// for the heck of it.
//
#define OWNER_ID_OF_SPEC_REC        0x7FFFFFF0
#define OWNER_ID_OF_SPEC_REC_OLD   250

//
// This determines the max. size (in bytes) of the buffer allocated the
// first time a  range of records need to retrived.
//
#define INIT_NO_OF_ENTRIES        1000

#define NO_COLS_NAM_ADD_TBL         6        //no. of cols in Name Ip table
#define NO_COLS_OWN_ADD_TBL         5        //no. of cols in Name Ip table

//
// Passed as third arg to JetCreateDatabase
//
#define CONNECT_INFO         ";COUNTRY=1; LANGID=0x0409; CP=1252"

//
// Maximum number of sessions that can be active at any one time
//
// There can be a max of MAX_CNCRNT_STATIC_INITS (3 currently; check
// winsintf.c) going on at any one time.
//
#define  MAX_NO_SESSIONS        (NMS_MAX_RPC_CALLS + WINSTHD_MAX_NO_NBT_THDS + \
                                 WINSTHD_NO_RPL_THDS + WINSTHD_NO_SCV_THDS +\
                                 WINSTHD_NO_CHL_THDS + WINSCNF_MAX_CNCRNT_STATIC_INITS )


#pragma warning(4:4532)     // Turn off return from __finally block warning until this code is cleaned
                            // up to use __leave correctly.

#define RET_M(JetRetStat)                                        \
                {                                                \
              DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n", \
                                      (JetRetStat), __LINE__);                \
                 WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);  \
                 return(WINS_FAILURE);                                \
                }


#define CALL_M(fn)                                                      \
                {                                                       \
                 JET_ERR _JetRetStat;                                   \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                        RET_M(_JetRetStat);                              \
                 }                                                      \
                }
// this macro always requires JetRetStat local variable to receive the return value.
#define CALL_N_JMP_M(fn, label)                                                      \
                {                                                       \
                 if ((JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                       DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n", \
                                      (JetRetStat), __LINE__);                \
                       WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);  \
                       goto label;                                      \
                 }                                                      \
                }
#define CALL_N_RAISE_EXC_IF_ERR_M(fn)                                   \
                {                                                       \
                 JET_ERR _JetRetStat;                                   \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)            \
                 {                                                      \
                   DBGPRINT2(ERR, "Jet Error: _JetRetStat is (%d). Line is (%d)\n", \
                                        _JetRetStat, __LINE__);         \
                   WINSEVT_LOG_M(_JetRetStat, WINS_EVT_DATABASE_ERR);   \
                   WINS_RAISE_EXC_M(WINS_EXC_FAILURE);                  \
                 }                                                      \
                }

#if 0
#define COMMIT_M(pSesId)                                                \
                {                                                       \
                        (JetRetStat) = JetCommitTransaction(            \
                                        *pSesId, JET_bitCommitFlush);   \
                        if (JetRetStat != JET_errSuccess)               \
                        {                                               \
                               DBGPRINT1(ERR, "COMMIT FAILED: JetRetStat is (%d). \n", \
                                        (JetRetStat));                  \
                                WINSEVT_LOG_M((JetRetStat), WINS_EVT_COMMIT_ERR);  \
                        }                                               \
                        pTls->fTransActive = FALSE;                     \
                }

#define ROLLBACK_M(pSesId)                                               \
                {                                                        \
                        WINS_TLS_T        _pTls;                         \
                        JET_SESID        _SessId;                        \
                        JET_ERR  _JetRetStat;                            \
                        if (pSesId == NULL) { GET_TLS_M(_pTls); ASSERT(_pTls != NULL)}                                                                     \
                        _JetRetStat = JetRollback(                         \
                                        _pTls->SesId, JET_bitRollbackAll));\
                        if (_JetRetStat != JET_errSuccess)                 \
                        {                                                  \
                               DBGPRINT1(ERR, "ROllBACK FAILED: JetRetStat is (%d). \n",                                                                   \
                                        _JetRetStat);                      \
                                WINSEVT_LOG_M(_JetRetStat, WINS_EVT_ROLLBACK_ERR);                                                                         \
                        }                                                  \
                        _pTls->fTransActive = FALSE;                       \
                }
#endif

#define JETRET_M(fn)                                                        \
                {                                                           \
                 JET_ERR _JetRetStat;                                       \
                 if ((_JetRetStat = (fn)) != JET_errSuccess)                \
                 {                                                          \
                   DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",                                                                          \
                                        _JetRetStat, __LINE__);             \
                   WINSEVT_LOG_M(_JetRetStat, WINS_EVT_DATABASE_ERR);       \
                   return(_JetRetStat);                                     \
                 }                                                          \
                }


/*
 *        Local Typedef Declarations
 */


/*
 FLD_T -- describes various attributes of a fld/col of a table
*/
typedef struct _FLD_T {
        PBYTE                        pName;        //name of field
        WORD                        FldTyp;        //field type (unsigned byte, long, etc)
        BOOL                        fIndex; //Is it an index field
        BOOL                        fUnique;//Is the field value supposed to be unq
        PBYTE                        pIndex; //Index name
        PBYTE                        pb;
        DWORD                        Cb;
        DWORD                         Fid;    //field id.
        } FLD_T, *PFLD_T;


/*
 *        Global Variable Definitions
*/


/*
 NmsDbNoOfOwners -- This is the number of  owners that are in the
        owner id to address mapping table.  This variable is set
        by NmsDbInit (when it reads in the above table) and subsequently
        by the replicator

        This variable is protected by a critical section (not used at
        initialization time)

*/

DWORD   NmsDbNoOfOwners          = 0;  //No. of owners in the Nam - Add table


/*
 NmsDbOwnAddTbl -- This is the in-memory table that stores the mappings
                 between the owner id and the addresses.

                This table is initialized at init time with the database
                table NMSDB_OWN_ADD_TBL_NM if it exists.

                subsequently, more entries may be inserted into this
                table at replications as WINS learns of other WINS owners

                The insertions into this table are tagged at the end.
                In case of a configuration change, an entry may get
                flagged as DELETED, in which case it can be reused.
                This particular facet concering deletion is not
                operational currently

                This table is used by RPL_FIND_ADD_BY_OWNER_ID_M and
                by RplFindOwnrId

*/

PNMSDB_ADD_STATE_T      pNmsDbOwnAddTbl;
DWORD                   NmsDbTotNoOfSlots = NMSDB_MAX_OWNERS_INITIALLY;
CRITICAL_SECTION        NmsDbOwnAddTblCrtSec;

VERS_NO_T               NmsDbStartVersNo;
WINS_UID_T              NmsDbUid;

//
// Must be initialized to 0.  It is used by JetInit, JetBeginSession,
// JetGetSystemParameter, JetSetSystemParameter, and JetTerm
//
//  Only JetInit and JetSetSystemParameter take it by reference.  Only
//  JetInit modifies it (Cheen Liao - 2/2/94).
//
JET_INSTANCE            sJetInstance = 0;

/*
 Name of the database file.

 This name will be read from the registry.  For now, we are STATICally
 initializing the file name.
*/
FUTURES("when jet is internationalized, use WINSCNF_DB_NAME")
//BYTE        NmsDbDatabaseFileName[WINS_MAX_FILENAME_SZ] = WINSCNF_DB_NAME_ASCII;


//
// STATICs for storing information about the special record that stores the
// max. version number of an updated local record (one that got deleted or
// replaced by a replica)
//
STATIC BOOL        sfHighestVersNoRecExists = FALSE;

//
// Choose a name that is not likely to be used by any NBT client
//
STATIC LPBYTE        spHighestVersNoRecNameOld = "xx--WINS--xx";
STATIC LPBYTE        spHighestVersNoRecName = "xx--WINS--xx--DHCP--xx--DNS--xx--GARBAGE1--1EGABRAG";  //more than a valid netbios name can store

//
// Stores the version number stored in the special record.
//
STATIC VERS_NO_T sHighestVersNoSaved;

BOOL   fConvJetDbCalled;         //set to TRUE when the convert process has
                                 //been invoked. Checked in NmsDbInit
BOOL   fDbIs200;                 //set to TRUE when the convert process has
                                 //been invoked to convert 200 series db to latest format.
                                 //Checked in NmsDbInit.
BOOL   fDbIs500;                 //set to TRUE when the convert process has
                                 //been invoked to convert 500 series db to latest format.
                                 //Checked in NmsDbInit
/*
 *        Local Variable Definitions
 */

/*
 Values indicating the type of index to be formed on a field.
*/

#define CLUSTERED         0
#define NOINDEX                1
#define PRIMARYPART        2

/*
  sNamAddTblRow

  Metadata about table that maps Names to IP addresses

  Note: The third and fourth fields are not used even though they are
        initialized.
*/

STATIC FLD_T        sNamAddTblRow[NO_COLS_NAM_ADD_TBL] =
        {
        { "name",      JET_coltypBinary,       CLUSTERED,   TRUE, "dname"  },
        { "address",   JET_coltypLongBinary,   NOINDEX,     FALSE, NULL    },
        { "flags",     JET_coltypLong,         NOINDEX,     FALSE, NULL    },
#if NEW_OWID
        { "ownerid",   JET_coltypLong, PRIMARYPART, TRUE, "ownerid"},
#else
        { "ownerid",   JET_coltypUnsignedByte, PRIMARYPART, TRUE, "ownerid"},
#endif
        { "versionno", JET_coltypCurrency,     PRIMARYPART, FALSE,"Version"},
        { "timestamp", JET_coltypLong,         NOINDEX,     FALSE, NULL    }
        };

/*
 The index of various fields in a row of Name -- Add table
*/

#define NAM_ADD_NAME_INDEX       0
#define NAM_ADD_ADDRESS_INDEX    1
#define NAM_ADD_FLAGS_INDEX      2
#define NAM_ADD_OWNERID_INDEX    3
#define NAM_ADD_VERSIONNO_INDEX  4
#define NAM_ADD_TIMESTAMP_INDEX  5

/*
  sOwnAddTblRow

  Metadata about table that maps owner ids to addresses
*/
STATIC FLD_T        sOwnAddTblRow[NO_COLS_OWN_ADD_TBL] =
        {
#if NEW_OWID
        { "OwnerId",   JET_coltypLong, CLUSTERED, TRUE, "OwnerId"  },
#else
        { "OwnerId",   JET_coltypUnsignedByte, CLUSTERED, TRUE, "OwnerId"  },
#endif
        { "address",   JET_coltypBinary,       NOINDEX,   0,     "Address" },
        { "state",     JET_coltypUnsignedByte, NOINDEX,   0,     "State" },
        { "versionno", JET_coltypCurrency,     NOINDEX, FALSE,    "Version"},
        { "uid",       JET_coltypLong,         NOINDEX, FALSE,    "Uid"}
        };

#ifdef WINSDBG
DWORD   NmsDbDelDelDataRecs;
DWORD   NmsDbDelQueryNUpdRecs;
#endif

/*
 The index of various fields in a row of Owner Id -- Add table
*/

#define OWN_ADD_OWNERID_INDEX        0
#define OWN_ADD_ADDRESS_INDEX        1
#define OWN_ADD_STATE_INDEX        2
#define OWN_ADD_VERSIONNO_INDEX 3
#define OWN_ADD_UID_INDEX       4


#if DYNLOADJET

DYN_LOAD_JET_VERSION  DynLoadJetVersion = DYN_LOAD_JET_600;
int NAM_ADD_OWNERID_SIZE;
int OWN_ADD_OWNERID_SIZE;
LPBYTE BASENAME;


NMSDB_JETFTBL_T NmsDbJetFTbl[] = {
#if _X86_
Init,
"JetInit@4", 145, NULL,
Term,
"JetTerm@4", 167, NULL,
Term2,
"JetTerm2@8", 167, NULL,           //Jet200 does not have a JetTerm2
SetSystemParameter,
"JetSetSystemParameter@20", 165, NULL,
BeginSession,
"JetBeginSession@16", 104, NULL,
EndSession,
"JetEndSession@8", 124, NULL,
CreateDatabase,
"JetCreateDatabase@20", 112, NULL,
AttachDatabase,
"JetAttachDatabase@12", 102, NULL,
DetachDatabase,
"JetDetachDatabase@8", 121, NULL,
CreateTable,
"JetCreateTable@24", 115, NULL,
DeleteTable,
"JetDeleteTable@12", 120, NULL,
GetTableColumnInfo,
"JetGetTableColumnInfo@24", 137, NULL,
GetColumnInfo,
"JetGetColumnInfo@28", 127, NULL,
AddColumn,
"JetAddColumn@28", 101, NULL,
CreateIndex,
"JetCreateIndex@28", 113, NULL,
BeginTransaction,
"JetBeginTransaction@4", 105, NULL,
CommitTransaction,
"JetCommitTransaction@8", 109, NULL,
Rollback,
"JetRollback@8", 160, NULL,
CloseDatabase,
"JetCloseDatabase@12",  107, NULL,
CloseTable,
"JetCloseTable@8", 108, NULL,
OpenDatabase,
"JetOpenDatabase@20",  148, NULL,
OpenTable,
"JetOpenTable@28", 149, NULL,
Delete,
"JetDelete@8", 116, NULL,
Update,
"JetUpdate@20", 168, NULL,
RetrieveColumn,
"JetRetrieveColumn@32", 157, NULL,
SetColumn,
"JetSetColumn@28", 162, NULL,
PrepareUpdate,
"JetPrepareUpdate@12", 151, NULL,
GetCurrentIndex,
"JetGetCurrentIndex@16", 128, NULL,
SetCurrentIndex,
"JetSetCurrentIndex@12", 164, NULL,
Move,
"JetMove@16", 147, NULL,
MakeKey,
"JetMakeKey@20", 146, NULL,
Seek,
"JetSeek@12", 161, NULL,
Backup,
"JetBackup@12", 103, NULL,
Restore,
"JetRestore@8", 156, NULL
#else
Init,
"JetInit", 145, NULL,
Term,
"JetTerm", 167, NULL,
Term2,
"JetTerm2", 167, NULL,           //Jet200 does not have a JetTerm2
SetSystemParameter,
"JetSetSystemParameter", 165, NULL,
BeginSession,
"JetBeginSession", 104, NULL,
EndSession,
"JetEndSession", 124, NULL,
CreateDatabase,
"JetCreateDatabase", 112, NULL,
AttachDatabase,
"JetAttachDatabase", 102, NULL,
DetachDatabase,
"JetDetachDatabase", 121, NULL,
CreateTable,
"JetCreateTable", 115, NULL,
DeleteTable,
"JetDeleteTable", 120, NULL,
GetTableColumnInfo,
"JetGetTableColumnInfo", 137, NULL,
GetColumnInfo,
"JetGetColumnInfo", 127, NULL,
AddColumn,
"JetAddColumn", 101, NULL,
CreateIndex,
"JetCreateIndex", 113, NULL,
BeginTransaction,
"JetBeginTransaction", 105, NULL,
CommitTransaction,
"JetCommitTransaction", 109, NULL,
Rollback,
"JetRollback", 160, NULL,
CloseDatabase,
"JetCloseDatabase",  107, NULL,
CloseTable,
"JetCloseTable", 108, NULL,
OpenDatabase,
"JetOpenDatabase",  148, NULL,
OpenTable,
"JetOpenTable", 149, NULL,
Delete,
"JetDelete", 116, NULL,
Update,
"JetUpdate", 168, NULL,
RetrieveColumn,
"JetRetrieveColumn", 157, NULL,
SetColumn,
"JetSetColumn", 162, NULL,
PrepareUpdate,
"JetPrepareUpdate", 151, NULL,
GetCurrentIndex,
"JetGetCurrentIndex", 128, NULL,
SetCurrentIndex,
"JetSetCurrentIndex", 164, NULL,
Move,
"JetMove", 147, NULL,
MakeKey,
"JetMakeKey", 146, NULL,
Seek,
"JetSeek", 161, NULL,
Backup,
"JetBackup", 103, NULL,
Restore,
"JetRestore", 156, NULL
#endif _X86_
  };


#else

#if NEW_OWID
#define NAM_ADD_OWNERID_SIZE    sizeof(DWORD)
#else
#define NAM_ADD_OWNERID_SIZE    sizeof(BYTE)
#endif
#define OWN_ADD_OWNERID_SIZE    NAM_ADD_OWNERID_SIZE

#endif   //DYNLOADJET
/*
 *        Local Function Prototype Declarations
*/

/* prototypes for functions local to this module go here */
STATIC
STATUS
CreateTbl(
        JET_DBID        DbId,
        JET_SESID        SesId,
        JET_TABLEID        *pTblId,
        NMSDB_TBL_NAM_E        TblNam_e //enumerator value for table to create
        );

STATIC
STATUS
InitColInfo (
        JET_SESID        SesId,
        JET_TABLEID        TblId,
        NMSDB_TBL_NAM_E        TblNam_e
        );

STATIC
STATUS
ReadOwnAddTbl(
        JET_SESID          SesId,
        JET_DBID          DbId,
        JET_TABLEID     TblId
        );

STATIC
JET_ERR
UpdateDb (
   JET_SESID             SesId,
   JET_TABLEID             TblId,
   PNMSDB_ROW_INFO_T pRowInfo,
   ULONG             TypOfUpd

       );


STATIC
STATUS
GetGrpMem (
        IN JET_SESID                 SesId,
        IN JET_TABLEID                      TblId,
        IN PNMSDB_ROW_INFO_T          pRowInfo,
        IN DWORD_PTR                  CurrentTime,
        IN OUT PNMSDB_STAT_INFO_T pStatInfo,
//        IN OUT PNMSDB_NODE_ADDS_T pNodeAdds,
        IN BOOL                          fIsStatic,
        OUT LPBOOL                  pfIsMem
        );

STATIC
STATUS
GetMaxVersNos(
        JET_SESID         SesId,
        JET_TABLEID        TblId
        );

STATIC
__inline
VOID
StoreSpecVersNo(
   VOID
);
STATIC
JET_ERR
InsertGrpMemsInCol(
        JET_SESID                SesId,
        JET_TABLEID                TblId,
        PNMSDB_ROW_INFO_T        pRowInfo,
        ULONG                    TypeOfUpd
         );
STATIC
VOID
StoreGrpMems(
   IN  PWINSTHD_TLS_T    pTls,
   IN  WINS_CLIENT_E     WinsClient_e,
   IN  LPBYTE            pName,
   IN  int               ThdPrLvl,
   IN  JET_SESID         SesId,
   IN  JET_TABLEID       TblId,
   IN  BOOL              fIsStatic,
   OUT PRPL_REC_ENTRY_T  pRspBuff
        );

STATIC
STATUS
SetSystemParams(
        BOOL fBeforeInit
        );

STATIC
VOID
UpdHighestVersNoRecIfReqd(
        IN PWINSTHD_TLS_T        pTls,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T        pStatInfo
        );

STATIC
STATUS
InitializeJetDb(
        PWINSTHD_TLS_T   pTls,
        LPBOOL           pfInitCallSucc,
        LPBOOL           pfDatabaseOpened
        );

STATIC
STATUS
AllocTls(
  LPVOID *ppTls
);

STATUS
ObliterateWins(
       DWORD        i,
       PCOMM_ADD_T  pWinsAdd
      );

#if DYNLOADJET
STATUS
SetForJet(
  VOID
 );
#endif //DYNLOADJET

STATUS
ConvertJetDb(
        JET_ERR             JetRetStat
 );
/*
        function definitions start here
*/

STATUS
NmsDbInit(
        VOID
        )

/*++

Routine Description:

        This function initializes the database manager component of the Name
        Space Manager Component

        It does the following

                calls _tzset to init global variables used by time().  These
                global variables are set so that convertion of UST to local
                time is done (for instance when time() is called)by
                taking into account the timezone information.

                Initialize the database engine

                Start a session with the db engine

                Create and attach to a database file

                Create (and open)  the name-address mapping table
                Create (and open)  the owner-address mapping table

                create a clustered and primary index on the name-address table
                create a clustered index on the owner-address table


        Note: if the database already exists, it

                Attaches to it

                Opens the Name IP address Mapping table

Arguments:
        None

Externals Used:
        NmsDbOwnAddTblCrtSec


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

called by:
        main function of WINS

Side Effects:

Comments:
        None
--*/

{
        JET_ERR             JetRetStat;
        PWINSTHD_TLS_T       pTls;
        BOOL                 fFirstTime = TRUE;

        if (AllocTls(&pTls) != WINS_SUCCESS)
        {
            return(WINS_FAILURE);
        }
        _tzset();        /*
                           func. uses TZ variable to assign values
                           to three global variables used by time().  This is
                           so that  Universal Coordinated Time to may be
                           adjusted to local time (timezone correction)
                        */


#if DYNLOADJET
       if (SetForJet() != WINS_SUCCESS)
       {
              return(WINS_FAILURE);
       }
#endif
       //
       // Set Jet System params (ignore return status)
       //
       (VOID)SetSystemParams(TRUE);

        //
        // Initialize the critical section for protecting the in-memory
        //table NmsDbOwnAddTbl
        //
        // Note: This table is read and written to during stable state by
        //       the Pull thread and the RPC threads executing WinsStatus()
        //
        // Check out RplFindOwnerId in rplpull.c
        //
        InitializeCriticalSection(&NmsDbOwnAddTblCrtSec);

        /*
          Initialize the Jet engine.  This must be the first call
          unless JetSetSystemParameter is called to set system
          parameters.  In that case, this call should be after that
        */
        while(TRUE)
        {
          BOOL  fInitCallSucc;
          BOOL  fDatabaseOpened;

          if (InitializeJetDb(pTls, &fInitCallSucc, &fDatabaseOpened) !=
                                        WINS_SUCCESS)
          {
             DWORD  NoOfRestoresDone = 0;
             if (fFirstTime && !fDbIs200 && !fDbIs500)
             {
                //
                // If we have a backup path, attempt to do a restore
                //
                if (WinsCnf.pBackupDirPath != NULL)
                {

                        DBGPRINT1(DET, "NmsDbInit: Doing Restore from path (%s)\n", WinsCnf.pBackupDirPath);
                        //
                        // If session is active, terminate it since we need
                        // call JetInit again. That requires that first we
                        // call JetTerm which does not expect any session to
                        // be active

                        //
                        if (fNmsMainSessionActive)
                        {
                                //
                                // Close tables opened in the session
                                //
                                NmsDbCloseTables();
                                if (fDatabaseOpened)
                                {
                                    CALL_M(JetCloseDatabase(
                                         pTls->SesId,
                                         pTls->DbId,
                                         0  //find out what grbit can be
                                            //used
                                          )
                                      );
                                }
                                CALL_M(JetEndSession(
                                        pTls->SesId,
                                        0
                                              )
                                          );
                                fNmsMainSessionActive = FALSE;

                        }
                        //
                        // if JetInit was successful, term jet activity
                        //
                        if (fInitCallSucc)
                        {
                                NmsDbRelRes();
                        }

                        //
                        // We will try JetRestore a max of two times.
                        //
                        while(NoOfRestoresDone++ < 2)
                        {
                          if (DynLoadJetVersion >= DYN_LOAD_JET_500)
                          {
                          JetRetStat = JetRestore(WinsCnf.pBackupDirPath,  NULL);

                          }
                          else
                          {
                          JetRetStat = JetRestore(WinsCnf.pBackupDirPath, 0, NULL, 0);

                          }
                          if (JetRetStat != JET_errSuccess)
                          {
                             if ( (
                                    (JetRetStat == JET_errBadLogVersion)
                                                ||
                                    (JetRetStat == JET_errBadLogSignature)
                                                 ||
                                    (JetRetStat == JET_errInvalidLogSequence)
                                     )
                                                  &&
                                     (NoOfRestoresDone == 1)
                               )
                             {
                                TCHAR  LogFilePath[WINS_MAX_FILENAME_SZ];

#define LOG_FILE_SUFFIX        TEXT("jet*.log")
                                WinsMscConvertAsciiStringToUnicode(
                                      WinsCnf.pLogFilePath, (LPBYTE)LogFilePath, sizeof(LogFilePath)/sizeof(TCHAR));
                                //
                                // Delete log files
                                //
                                WinsMscDelFiles(TRUE, LOG_FILE_SUFFIX, LogFilePath);
                                continue;
                             }

                             WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);
                             CALL_M(JetRetStat);

                           }
                           WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_DB_RESTORED);
                           break;  // break out of while loop
                        } // end of while()

                        fFirstTime = FALSE;
PERF("remove if not required")
                        sJetInstance = 0;        //defensive programming


#if 0
                        //
                        // Start a session again
                        //
                        if (AllocTls(&pTls) != WINS_SUCCESS)
                        {
                            return(WINS_FAILURE);
                        }
                        //
                        // Set Jet System params (ignore return status)
                        //
                        (VOID)SetSystemParams(TRUE);
#endif
                        continue;
                }

                WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);

                //
                // There is no back up path specified in the registry.  Return
                //
                return(WINS_FAILURE);
            }
            else
            {
                if (!fDbIs200 && !fDbIs500)
                {
                  WinsMscPutMsg(WINS_EVT_DB_RESTORE_GUIDE);
                }
                else
                {
                  //
                  // If we are converting to NT 5.0, DynLoadJetVersion=DYN_LOAD_JET_600
                  //
                  if ( DynLoadJetVersion == DYN_LOAD_JET_600 ) {

                      //
                      // Put a pop-up and log an event based on which version
                      // of Jet database we are converting from.
                      //
                      if (!fConvJetDbCalled)
                      {
                        WINSEVT_LOG_INFO_D_M(
                            WINS_SUCCESS,
                            fDbIs200 ? WINS_EVT_DB_CONV_351_TO_5_GUIDE
                                     : WINS_EVT_DB_CONV_4_TO_5_GUIDE);
                        // As per bug#339015 remove popups
                        // WinsMscPutMsg(
                        //    fDbIs200 ? WINS_EVT_DB_CONV_351_TO_5_GUIDE
                        //             : WINS_EVT_DB_CONV_4_TO_5_GUIDE);
                      }
                      else
                      {
                        //WinsMscPutMsg(WINS_EVT_TEMP_TERM_UNTIL_CONV_TO_5);
                      }
                  }
                  //
                  // If we are converting to NT 4.0, DynLoadJetVersion=DYN_LOAD_JET_500
                  //
                  else if(DynLoadJetVersion == DYN_LOAD_JET_500) {
                      if (!fConvJetDbCalled)
                      {
                        WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_DB_CONV_GUIDE);
                        WinsMscPutMsg(WINS_EVT_DB_CONV_GUIDE);
                      }
                      else
                      {
                         WinsMscPutMsg(WINS_EVT_TEMP_TERM_UNTIL_CONV);
                      }
                  }else {
                      //
                      // We should never come here.
                      //
                      ASSERT(FALSE);
                  }


                }

                //
                // We got an error a second time.  Return
                //
                return(WINS_FAILURE);
            }
        }
        break;  //break out of the while loop
      } // end of while(TRUE)

      //
      // Init Push records if required
      //
       RPLPUSH_INIT_PUSH_RECS_M(&WinsCnf);

        NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, NmsDbStartVersNo);

        //
        // Set our UID to be the time when the db got initialized
        //
        {
            time_t  timeNow;
            (void)time(&timeNow);

            NmsDbUid = (DWORD)timeNow;
        }
        return(WINS_SUCCESS);
}
STATUS
AllocTls(
  LPVOID *ppTls
)

/*++

Routine Description:
    This function is called to allocate TLS

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
    NmsDbInit

Side Effects:

Comments:
	
--*/

{
        PWINSTHD_TLS_T  pTls;
        WinsMscAlloc( sizeof(WINSTHD_TLS_T),  ppTls);
        pTls = *ppTls;

        pTls->fNamAddTblOpen = FALSE;
        pTls->fOwnAddTblOpen = FALSE;

        /*
         * Let us store the address in the TLS storage
        */
        if (!TlsSetValue(WinsTlsIndex, pTls))
        {
                DWORD Error;
                Error = GetLastError();
                DBGPRINT1(ERR, "NmsDbAllocTlc: TlsSetValue returned error. Error = (%d)\n", Error);
                WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT);
                return(WINS_FAILURE);
        }
        return(WINS_SUCCESS);
}

STATUS
InitializeJetDb(
        PWINSTHD_TLS_T   pTls,
        LPBOOL           pfInitCallSucc,
        LPBOOL           pfDatabaseOpened
        )

/*++

Routine Description:
        This function opens the Jet db and tables

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/


{
        JET_ERR         JetRetStat;
        JET_SESID       SesId;
        JET_DBID        DbId;
        BOOL            fOwnAddTblCreated = FALSE; /*indicates whether the
                                                   owner id to address
                                                     mapping table was created
                                                     at init time
                                                   */

        *pfDatabaseOpened = FALSE;

        JetRetStat = JetInit(&sJetInstance);
        DBGPRINT1(ERR, "JetInit returning (%d)\n", (JetRetStat));

        if (JetRetStat != JET_errSuccess)
        {
           *pfInitCallSucc = FALSE;
           if ((JetRetStat == JET_errDatabase200Format) || (JetRetStat == JET_errDatabase500Format))
           {
               ConvertJetDb(JetRetStat);

            }
           else
           {

             //
             // We could have got an error  because the LogFilePath
             // is messed up in the registry.  We try again, this time using
             // the default log file path.
             //
             // Most of the time, we get FileNotFound error.  We have seen
             // "bad signature" error once.  Let us just do this for all
             // errors.  The situation will not be any worse than before if
             // JetInit fails again.
             //
             // Set the default log path
             //
             SetSystemParams(FALSE);
             JetRetStat = JetInit(&sJetInstance);
           }
           CALL_M(JetRetStat);
        }

        *pfInitCallSucc = TRUE;

        /*
          Start a session.
        */
        CALL_M( JetBeginSession(
                        sJetInstance,
                        &pTls->SesId,
                        NAMUSR,
                        PASSWD  )
               );

        fNmsMainSessionActive = TRUE;
        SesId = pTls->SesId;

        //
        // Create/Open the database
        //
        if ((JetRetStat = JetCreateDatabase(
                                SesId,
//                                NmsDbDatabaseFileName,
                                WinsCnf.pWinsDb,
                                CONNECT_INFO,
                                &pTls->DbId,
                                0        //grbit; Don't want exclusive use
                              )) == JET_errDatabaseDuplicate
           )


        {

                //
                // let us attach to the database.  This is required for
                // opening databases that were created in a different
                // directory (Ian -- 11/23/93).  We will get a warning
                // if the database was created in this very directory
                //
                JetRetStat = JetAttachDatabase( SesId, WinsCnf.pWinsDb/*NmsDbDatabaseFileName*/, 0 );
                if (
                        (JetRetStat != JET_wrnDatabaseAttached)
                                  &&
                        (JetRetStat != JET_errSuccess)
                   )
                {
                        if ((JetRetStat == JET_errDatabase200Format) || (JetRetStat == JET_errDatabase500Format))
                        {
                           //
                           // Start the convert process
                           //

                            JetRetStat = ConvertJetDb(JetRetStat);
                            *pfInitCallSucc = TRUE;

                         }

                    CALL_M(JetRetStat);
                }

                //
                // If JetRetStat is success, it means ...
                //
                // The new db path is different from the old one.  We need
                // to detach so that Jet forgets about the old one. We then
                // attach to the new one again
                //
                if (JetRetStat == JET_errSuccess)
                {
                       CALL_M(JetDetachDatabase(SesId, NULL));
                       CALL_M(JetAttachDatabase(SesId, WinsCnf.pWinsDb, 0 ));
                }
                CALL_M(JetOpenDatabase(
                                        SesId,
                                        //NmsDbDatabaseFileName,
                                        WinsCnf.pWinsDb,
                                        NULL, /*the default engine*/
                                        &pTls->DbId,
                                        0
                                       )
                       );
                *pfDatabaseOpened = TRUE;

                DbId = pTls->DbId;
                JetRetStat = JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &pTls->NamAddTblId
                                        );


                //
                // If the name-address mapping table was not found, create it
                //
                if (JetRetStat == JET_errObjectNotFound)
                {

                   DBGPRINT0(INIT, "InitializeJetDb:Creating Name-Address table\n");
                   CALL_M(CreateTbl(
                                        DbId,
                                        SesId,
                                        &pTls->NamAddTblId,
                                        NMSDB_E_NAM_ADD_TBL_NM
                                            )
                         );
                   //
                   // Set this so that we close the table when we end the
                   // session
                   //
                   pTls->fNamAddTblOpen = TRUE;

                }
                else
                {

                   CALL_M(JetRetStat);
                   pTls->fNamAddTblOpen = TRUE;
                   //
                   // get and store in in-memory data structure, the
                   // information about the columns of the name-address
                   // mapping table
                   //
                   CALL_M(InitColInfo(
                        SesId,
                        pTls->NamAddTblId,
                        NMSDB_E_NAM_ADD_TBL_NM
                            ));

                   //
                   // get the max. version numbers of records owned
                   // by different owners.  These will be stored in
                   // the RplPullOwnerVersNo table
                   //
                   CALL_M(GetMaxVersNos(
                        SesId,
                        pTls->NamAddTblId
                                ));

                }

                //
                // Open the owner-address mapping table
                //
                JetRetStat = JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &pTls->OwnAddTblId
                                        );
                if (JetRetStat == JET_errObjectNotFound)
                {

                   DBGPRINT0(INIT, "InitializeJetDb:Creating Owner-Address table\n");
                   //
                   // Create the ownerid-address mapping table
                   //
                   CALL_M(CreateTbl(
                                DbId,
                                SesId,
                                &pTls->OwnAddTblId,
                                NMSDB_E_OWN_ADD_TBL_NM
                                  )
                          );

                   //
                   // Set this so that we close the table when we
                   // end the session
                   //
                   pTls->fOwnAddTblOpen = TRUE;
                   fOwnAddTblCreated = TRUE;
                }
                else
                {
                   pTls->fOwnAddTblOpen = TRUE;
                   CALL_M(InitColInfo(
                                SesId,
                                pTls->OwnAddTblId,
                                NMSDB_E_OWN_ADD_TBL_NM
                                   )
                           );

                }
        }
        else  //if database file was not existent and has now been created
        {
                 if (JetRetStat == JET_errSuccess)
                 {
                     DBGPRINT0(INIT, "InitializeJetDb: Database file was not there. It has been created\n");
                     *pfDatabaseOpened = TRUE;
                     DbId = pTls->DbId;

                     //
                     // Create the name -address mapping table
                     //
                     CALL_M(CreateTbl(
                             DbId,
                             SesId,
                             &pTls->NamAddTblId,
                             NMSDB_E_NAM_ADD_TBL_NM
                                        )
                           );

                     pTls->fNamAddTblOpen = TRUE;
                     //
                     // Create the ownerid-address mapping table
                     //
                     CALL_M(CreateTbl(
                             DbId,
                             SesId,
                             &pTls->OwnAddTblId,
                             NMSDB_E_OWN_ADD_TBL_NM
                                    )
                           );

                     pTls->fOwnAddTblOpen = TRUE;
                     fOwnAddTblCreated = TRUE;
                }
                else
                {
                    *pfDatabaseOpened = FALSE;
                    RET_M(JetRetStat);
                }
        }

        //
        // Allocate the NmsDbOwnAddTbl table in memory
        //
        WinsMscAlloc(
                    sizeof(NMSDB_ADD_STATE_T) * NmsDbTotNoOfSlots,
                    &pNmsDbOwnAddTbl
                         );

        /*
          If the Owner - Address table was there, read its contents into
          an in-memory table
        */

FUTURES("Pass ptr to an in-memory table instead of having ReadOwnAddTbl")
FUTURES("assume that one is present")

        if (!fOwnAddTblCreated)
        {
                ReadOwnAddTbl(
                        SesId,
                        DbId,
                        pTls->OwnAddTblId
                             );
        }

        //
        // Set the current index on the name-address table to the
        // clustered index
        //

        CALL_M(
                JetSetCurrentIndex( SesId,
                                    pTls->NamAddTblId,
                                    NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                          )
                      );

       return(WINS_SUCCESS);

} // end InitialiazeJetDb


STATUS
NmsDbInsertRowInd(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function inserts a unique name-IP address mapping row in the
        name-IP address mapping table.  In case of a conflict, it returns
        an error status and information about the conflicting
        record that includes


                Status -- group/unique
                IP address(es) of the conflicting record (one address if
                  it was a unique record, one or more if it was
                  a special group).
                state   -- the state of the record (active/released/tombstone)



Arguments:
        pRowInfo    - Info. about the row to insert
        pStatusInfo - Contains status of the operation + info about the
                      conflicting record, if the registration conflicted
                      with an entry in the db.

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegInd

Side Effects:

Comments:
        None
--*/
{

     DWORD              FldNo      = 0;
     JET_ERR            JetRetStat;
     DWORD              FlagVal    = 0;  //flag value of record
     DWORD              ActFldLen  = 0;  //length of fld retrieved
     JET_TABLEID        TblId;
     JET_SESID          SesId;
     PWINSTHD_TLS_T     pTls;
     BOOL               fWaitDone = FALSE;

     GET_TLS_M(pTls);
     ASSERT(pTls != NULL);
     TblId  = pTls->NamAddTblId;
     SesId  = pTls->SesId;

     pStatusInfo->StatCode = NMSDB_SUCCESS;

     JetRetStat = UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepInsert
                             );

     if ( JetRetStat == JET_errKeyDuplicate )
     {
                  pStatusInfo->StatCode = NMSDB_CONFLICT;

                  /*
                   *        retrieve the conflicting record's
                   *    flag byte.
                  */
                  CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
                        );

                  if ((JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                            )) ==  JET_errSuccess
                     )
                 {

                         // retrieve the flags column
                         CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                &ActFldLen,
                                0,
                                NULL
                                          )
                              );


                        pStatusInfo->EntTyp  = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                        pStatusInfo->fStatic = NMSDB_IS_ENTRY_STATIC_M(FlagVal);
                        pStatusInfo->EntryState_e =
                                                NMSDB_ENTRY_STATE_M(FlagVal);

                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {

FUTURES("Remove this RETINFO thing.  Presumably, it is not needed")
                                /* It is a unique entry*/
                                JET_RETINFO RetInfo;

                                RetInfo.itagSequence = 1;
                                RetInfo.cbStruct     = sizeof(JET_RETINFO);
                                RetInfo.ibLongValue  = 0;

                                          // retrieve the ip address column
                                          CALL_M(
                                   JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                     &(pStatusInfo->NodeAdds.Mem[0].Add),
                                     sizeof(COMM_ADD_T),
                                     &ActFldLen,
                                     0,
                                     &RetInfo
                                                         )
                                      );
                                pStatusInfo->NodeAdds.NoOfMems = 1;

                         }
                         else
                         {
                             if (NMSDB_ENTRY_MULTIHOMED_M(pStatusInfo->EntTyp))
                             {
                                   //
                                   // If status is active, we get the
                                   // group members
                                   //
                                   if (pStatusInfo->EntryState_e ==
                                                        NMSDB_E_ACTIVE)
                                   {
                                        BOOL        fIsMem;

#if 0
//NOTE: No need to do the following, since we don't care about the value of
//fIsMem returned GetGrpMem()
                                         pRowInfo->NodeAdds.NoOfMems   = 1;
                                         pRowInfo->NodeAdds.Mem[0].Add =
                                                        *(pRowInfo->pNodeAdd);
#endif

PERF("If entry in conflict is STATIC, we don't need to get grp members")
PERF("except maybe for multihomed entries. Checkout Clash functions (nmsnmh.c)")
                                        if (GetGrpMem(
                                                SesId,
                                                TblId,
                                                pRowInfo,
                                                pRowInfo->TimeStamp - ((pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) ? WinsCnf.RefreshInterval : WinsCnf.VerifyInterval) ,
                                                pStatusInfo,
                                                pStatusInfo->fStatic,
                                                &fIsMem
                                                  ) != WINS_SUCCESS)
                                         {

                                                return(WINS_FAILURE);

                                         }

                                        //
                                        // If all members are expired, then
                                        // mark entry in conflict as a
                                        // TOMBSTONE (for the benefit of
                                        // ClashAtRegInd and ClashAtReplUniqueR)
                                        //
                                        if (pStatusInfo->NodeAdds.NoOfMems == 0)
                                        {
                                                pStatusInfo->EntryState_e =
                                                        NMSDB_E_RELEASED;
                                        }

                                  }
                                  else
                                  {
                                        pStatusInfo->NodeAdds.NoOfMems = 0;
                                  }
                             }
                        }

#if !NEW_OWID
                       pStatusInfo->OwnerId = 0;
#endif

                        /*
                         * Retrieve the owner Id column.
                        */
                        CALL_M(
                                   JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &pStatusInfo->OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                                         )
                                      );

                        //
                        // Just in case we challenge this entry and it
                        // happens to be multihomed, we would need to add
                        // it as a member (see ProcAddList).
                        //
                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {
                                pStatusInfo->NodeAdds.Mem[0].OwnerId =
                                                       pStatusInfo->OwnerId;
                                //
                                // Put the current time stamp as the time
                                // stamp of the member. Though not strictly
                                // correct, it is ok.  We don't
                                // need to retrieve the time stamp of the
                                // conflicting record this way.
                                //
                                if (pStatusInfo->OwnerId ==
                                        NMSDB_LOCAL_OWNER_ID)
                                {
                                        pStatusInfo->NodeAdds.Mem[0].TimeStamp
                                               = pRowInfo->TimeStamp;
                                }
                        }

                        //
                        // If the conflicting record is owned by the local
                        // WINS, we must retrieve the version number.  This
                        // is used to determine whether the special record
                        // storing the highest version number of the
                        // local records should be updated (refer:
                        // NmsDbUpdateRow, NmsDbSeekNUpd, NmsScvDoScavenging,
                        // NmsDbUpdHighestVersNoRec)
                        //
                        if (pStatusInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
                        {

                                      //
                                      // Retrieve the version number
                                      //
                                      CALL_M( JetRetrieveColumn(
                                          SesId,
                                          TblId,
                                          sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                          &(pStatusInfo->VersNo),
                                          sizeof(VERS_NO_T),
                                          &ActFldLen,
                                          0,
                                          NULL
                                                             )
                                          );


                        }


                }
                else  //could not seek to the record
                {
#if 0
// use the following code only if there is a thread somewhere in WINS that
// updates the db without first entering the NmsNmhNamRegCrtSec critical
// section.

//
// For registration done by RPLPULL thread where the version number is not
// incremented, we do not have to enter the above critical section.  Currently
// we do enter it.  If in the future we stop doing so, we will uncomment the
// following code.
//
                        if (!fWaitDone)
                        {
                           WINSEVT_LOG_INFO_M(
                                                WINS_SUCCESS,
                                                WINS_EVT_CANT_FIND_REC
                                             );
                           Sleep(10);        //sleep for 10 msecs to let the other
                                        //thread commit/rollback the transaction
                                        //that is inserting a record that caused
                                        //the conflict


                           //
                           // Set flag to TRUE so that if we get the same
                           // error again, we can log an error and raise
                           // an exception
                           //
                           fWaitDone = TRUE;
                           continue;  //iterate one more time
                        }
#endif

                        /*
                         * We should never get here.  Something major is wrong
                         * (probably with Jet)
                         */
                        DBGPRINT1(EXC, "NmsDbInsertRowInd: Could not seek to conflicting record. WEIRD. Error is (%d)\n", JetRetStat);
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                        ASSERTMSG(0, "SEEK ERROR");
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

                }  // end of else

        }  //no duplicate

        CALL_M(JetRetStat);

        return(WINS_SUCCESS);
}


STATUS
NmsDbInsertRowGrp(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function inserts a group name-IP address mapping row in the
        name-IP address mapping table. It first seeks on the name to see
        if there is an entry with that name.  if yes, it retrieves the
        information about the conflicting record for the benefit of the
        calling function and returns.

        Information retrieved includes
                Status -- group/unique
                IP addresses pertaining to the entry
                state   -- the state of the record (active/released/tombstone)


Arguments:

        pRowInfo    - Info. about the row to insert
        pStatusInfo - Contains status of the operation + info about the
                      conflicting record, if the registration conflicted
                      with an entry in the db.

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/
{

        DWORD       FldNo       = 0;
        JET_ERR     JetRetStat;
        DWORD       FlagVal     = 0;     //flag value of record that is
                                         //retrieved
        DWORD       ActFldLen   = 0;     //length of fld retrieved
        BOOL        fFound      = FALSE; //set to TRUE if Address is found in
                                         //group
        BOOL        fWaitDone     = FALSE;

        JET_RETINFO     RetInfo;
        JET_SESID        SesId;
        JET_TABLEID     TblId;
        PWINSTHD_TLS_T        pTls;

             GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
             TblId  = pTls->NamAddTblId;
             SesId  = pTls->SesId;

        pStatusInfo->StatCode         = NMSDB_SUCCESS;

        //
        // So that we repeat the whole while loop in case we are not
        // able to seek after a conflict
        //
        JetRetStat = UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepInsert
                             );


        if ( JetRetStat == JET_errKeyDuplicate )
        {
                pStatusInfo->StatCode = NMSDB_CONFLICT;

                CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                JET_bitNewKey
                                    )
                     );

                 if ((JetRetStat = JetSeek(
                            SesId,
                            TblId,
                            JET_bitSeekEQ
                           )) ==  JET_errSuccess
                    )
                 {

                            // retrieve the flags column
                            CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                                );

                            pStatusInfo->EntryState_e =
                                                NMSDB_ENTRY_STATE_M(FlagVal);
                            pStatusInfo->EntTyp  =
                                            (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                            pStatusInfo->fStatic =
                                             NMSDB_IS_ENTRY_STATIC_M(FlagVal);

                            if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
                            {
                                  /* It is a unique entry*/


FUTURES("Remove this RETINFO thing.  Presumably, it is not needed")
                                /* It is a unique entry*/

                                RetInfo.itagSequence = 1;
                                RetInfo.cbStruct     = sizeof(JET_RETINFO);
                                RetInfo.ibLongValue  = 0;

                                // retrieve the ip address column
                                CALL_M(
                                  JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                     &(pStatusInfo->NodeAdds.Mem[0].Add),
                                     sizeof(COMM_ADD_T),
                                     &ActFldLen,
                                     0,
                                     &RetInfo
                                                  )
                                      );

                                pStatusInfo->NodeAdds.NoOfMems = 1;
                            }
                            else //it is a group entry or a multihomed entry
                            {

                                if (pStatusInfo->EntTyp != NMSDB_NORM_GRP_ENTRY)
                                {
                                    //
                                    // If status is active, we get the
                                    // group members
                                    //
                                    if (pStatusInfo->EntryState_e ==
                                                        NMSDB_E_ACTIVE)
                                    {
                                        BOOL        fIsMem;
PERF("If entry in conflict is STATIC, we don't need to get grp members")
PERF("except maybe for multihomed entries. Checkout Clash functions (nmsnmh.c)")
                                        if (GetGrpMem(
                                                SesId,
                                                TblId,
                                                pRowInfo,
                                                pRowInfo->TimeStamp - ((pRowInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) ? WinsCnf.RefreshInterval : WinsCnf.VerifyInterval),
                                                pStatusInfo,
                                                pStatusInfo->fStatic,
                                                &fIsMem
                                                  ) != WINS_SUCCESS)
                                        {
                                                return(WINS_FAILURE);
                                        }
                                        //
                                        // If all members are expired, then
                                        // mark entry in conflict as a
                                        // RELEASED (for the benefit of
                                        // ClashAtRegGrp and ClashAtReplGrpMemR)
                                        //
                                        if (pStatusInfo->NodeAdds.NoOfMems == 0)
                                        {
                                                pStatusInfo->EntryState_e =
                                                        NMSDB_E_RELEASED;
                                        }

                                    }
                                    else
                                    {
                                        pStatusInfo->NodeAdds.NoOfMems = 0;
                                    }
                                }

                        }

#if !NEW_OWID
                       pStatusInfo->OwnerId = 0;
#endif
                        /*
                          Retrieve the owner Id column.
                        */
                        CALL_M(
                                  JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &pStatusInfo->OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                                         )
                              );

                        //
                        // Just in case we challenge this entry and it
                        // happens to be multihomed, we would need to add
                        // it as a member (see ProcAddList).
                        //
                        if (NMSDB_ENTRY_UNIQUE_M(pStatusInfo->EntTyp))
                        {
                                pStatusInfo->NodeAdds.Mem[0].OwnerId =
                                                       pStatusInfo->OwnerId;
                                if (pStatusInfo->OwnerId ==
                                        NMSDB_LOCAL_OWNER_ID)
                                {
                                     //
                                     // Put the current time stamp as the time
                                     // stamp of the member. Though not strictly
                                     // correct, it is ok.  We don't
                                     // need to retrieve the time stamp of the
                                     // conflicting record this way.
                                     //
                                     pStatusInfo->NodeAdds.Mem[0].TimeStamp
                                               = pRowInfo->TimeStamp;
                                }
                        }

                        //
                        // If the conflicting record is owned by the local
                        // WINS, we must retrieve the version number.  This
                        // is used to determine whether the special record
                        // storing the highest version number of the
                        // local records should be updated (refer:
                        // NmsDbUpdateRow, NmsDbSeekNUpd, NmsScvDoScavenging,                                // NmsDbUpdHighestVersNoRec)
                        //
                        if (pStatusInfo->OwnerId == NMSDB_LOCAL_OWNER_ID)
                        {
                                      //
                                      // Retrieve the version number
                                      //
                                      CALL_M( JetRetrieveColumn(
                                          SesId,
                                          TblId,
                                          sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                          &(pStatusInfo->VersNo),
                                          sizeof(VERS_NO_T),
                                          &ActFldLen,
                                          0,
                                          NULL
                                                             )
                                          );


                        }
                //        break; //break out of the while loop
                   }
                   else
                   {
#if 0
                        if (!fWaitDone)
                        {
                                   WINSEVT_LOG_INFO_M(
                                        WINS_SUCCESS,
                                        WINS_EVT_CANT_FIND_REC
                                                       );

                                   Sleep(10);        //sleep for 10 msecs to let
                                                //the other
                                                //thread commit/rollback the
                                                //transaction that is
                                                //inserting a record that
                                                //caused a conflict


                                   //
                                   // Set flag to TRUE so that if we get the same
                                   // error again, we can log an error and raise
                                  // an exception
                                   //
                                   fWaitDone = TRUE;
                                   continue;         //iterate one more time
                        }
#endif
                        /*
                         * We should never get here.  Something major is wrong.
                         * Either our current index is not on the name column or
                        * there is something wrong with JET
                        */
                        DBGPRINT1(EXC, "NmsDbInsertRowGrp: Could not seek to conflicting record. WEIRD. Error is (%d)\n", JetRetStat);
                        ASSERTMSG(0, "SEEK ERROR");
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

               }

          }  // not a duplicate

          CALL_M(JetRetStat);
       return(WINS_SUCCESS);
}




STATUS
NmsDbRelRow(
        IN  PNMSDB_ROW_INFO_T            pRowInfo,
        OUT PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++

Routine Description:

        This function releases a record in the database.  Releasing
        requires
                mark state as released
                update time stamp
                mark self as owner

Arguments:
        pRowInfo    - Information about the record to release
        pStatusInfo -  Status of operation

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRelRow

Side Effects:

Comments:
        None
--*/
{

        DWORD   FldNo            = 0;
        JET_ERR JetRetStat;
        DWORD    Ownerid = NMSDB_LOCAL_OWNER_ID;
#if NEW_OWID
        DWORD    OldOwnerId;
#else
        DWORD    OldOwnerId = 0;
#endif
        DWORD   FlagVal    = 0;      //flag value of record that is retrieved
        DWORD   ActFldLen  = 0;      //length of fld retrieved
        BOOL    fFound     = FALSE;  //set to TRUE if Address is found in group
        BOOL    fToRelease = TRUE;   //will be changed to false only for
                                     //a special group
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        JET_RETINFO     RetInfo;
        BYTE            EntTyp;
#ifdef WINSDBG
        BOOL            fUpd = FALSE;
#endif

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId                = pTls->NamAddTblId;
        SesId                = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                SesId,
                TblId,
                pRowInfo->pName,
                pRowInfo->NameLen,
                JET_bitNewKey
                          )
              );

         if ( (JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                                  )
              ) ==  JET_errRecordNotFound
            )
         {
                /*
                 We return success, since the record is not there.

                 This situation can  happen under the following
                 condition.

                        The client sends a name release to another WINS
                        which has not yet got the replica of the record.


                In the second case above, returning a positive name release
                request is ok even though the entry has not been released.
                It will eventually get released as a result of it not being
                refreshed or at the occurrence of a conflict.

                */

NOTE("Currently, NETBT always goes to the local WINS server for registrations")
NOTE("So, if a record is not in this db, it better not be in netbt tables too")
NOTE("If NETBT changes the above semantic in the future i.e. starts going")
NOTE("to a non-local WINS for reg., we should set pStatusInfo->fLocal to TRUE")
NOTE("here")
                return(WINS_SUCCESS);
         }
         else
         {
                if (JetRetStat != JET_errSuccess)
                {
                        DBGPRINT1(ERR,
                                "NmsDbRelRow: Seek returned Error (%d)\n",
                                                JetRetStat);
                        return(WINS_FAILURE);
                }
         }

         // retrieve the flags column
         CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &FlagVal,
                        sizeof(FlagVal),
                        &ActFldLen,
                        0,
                        NULL
                                  )
                );

         //
         // Set the fLocal flag if this entry was registered by this node
         //
         pStatusInfo->fLocal = NMSDB_IS_ENTRY_LOCAL_M(FlagVal);

         if (!NMSDB_ENTRY_ACT_M(FlagVal))
         {

                /*
                 The entry is already released.  This can happen
                 because of the following reasons

                   --client sent a repeat name release since it did not
                     get the response to the earlier one (maybe it got
                     lost or maybe because of a timing window where WINS
                     has sent a response just around the time the client
                     does the retry

                   --entry got released due to no refresh (all refreshes got
                     lost.


                Returning a positive name release is fine.  If the client
                has not got the first one (because it got lost, it will get
                the second one).  If it has now received the first response,
                it will just ignore the second one
                */

CHECK("Make sure that NBT will ignore the second one")

                return(WINS_SUCCESS);
         }


        EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
        //
        // If we got a release for a unique entry but the entry
        // we found is a group entry or vice-versa, return
        // NO_SUCH_ROW status.
        //
        if (
              (
                NMSDB_ENTRY_UNIQUE_M(EntTyp)
                        &&
                   NMSDB_ENTRY_GRP_M(pRowInfo->EntTyp)
              )
                         ||
              (
                NMSDB_ENTRY_GRP_M(EntTyp)
                        &&
                   !NMSDB_ENTRY_GRP_M(pRowInfo->EntTyp)
              )
           )
        {
                DBGPRINT0(ERR, "NmsDbRelRow: Request to release a record with a type (unique/group) than the one for which the release was sent has been ignored\n");
PERF("Remove this logging to increase speed")
                // per bug #336889 remove this
//                WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_REL_TYP_MISMATCH);
                pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                return(WINS_SUCCESS);
        }

         pStatusInfo->EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);

         //
         // If it is a dynamic release request but the entry found is STATIC,
         // we return SUCCESS.
         //
         // Note: Even though the address in the release request may be
         // different from one in the STATIC record, we return SUCCESS.
         //
         // This is to save overhead for the majority of cases (99%) where
         // the addresses are going to be the same.
         //
         if (!pRowInfo->fAdmin && (NMSDB_IS_ENTRY_STATIC_M(FlagVal) &&
                         !NMSDB_ENTRY_USER_SPEC_GRP_M(pRowInfo->pName, pStatusInfo->EntTyp)))
         {
                return(WINS_SUCCESS);
         }

         if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
         {
                  /* retrieve the ip address column*/

                  RetInfo.itagSequence = 1;
                  RetInfo.cbStruct     = sizeof(JET_RETINFO);
                  RetInfo.ibLongValue  = 0;

                  CALL_M( JetRetrieveColumn(
                                  SesId,
                                  TblId,
                                  sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                  &(pStatusInfo->NodeAdds.Mem[0].Add),
                                  sizeof(COMM_ADD_T),
                                  &ActFldLen,
                                  0,
                                  &RetInfo
                                                     )
                             );


                  pStatusInfo->NodeAdds.NoOfMems = 1;

                  //
                  // Extract the Node Type from the Flags byte
                  //
                  pStatusInfo->NodeTyp =  (BYTE)NMSDB_NODE_TYPE_M(FlagVal);

                //
                // if the address of the entry to be released does not
                // match the address of the client requesting the release
                // and it is not an administrative action, we do not release
                // the entry
                //
                if (
                        (pRowInfo->pNodeAdd->Add.IPAdd !=
                                pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd)
                                        &&
                           (!pRowInfo->fAdmin)
                   )

                {
                        DBGPRINT3(ERR, "NmsDbRelRow: Request to release a record (%s) with a different IP address (%x) than that in the release request (%x) has been ignored\n", pRowInfo->pName, pRowInfo->pNodeAdd->Add.IPAdd, pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd);
                        pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
#if 0 //per bug #336875
                        if (WinsCnf.LogDetailedEvts)
                        {
                          WinsEvtLogDetEvt(TRUE, WINS_EVT_REL_ADD_MISMATCH, TEXT("nmsdb"), __LINE__, "sdd", pRowInfo->pName, pRowInfo->pNodeAdd->Add.IPAdd,
                             pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd);
                        }
#endif
//                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_REL_ADD_MISMATCH);
                        return(WINS_SUCCESS);
                }
        }
        else  // it is a group entry (Normal or Special) or a multihomed entry
        {
                //
                // if it is a special group/multihomed entry, we need to do a
                // number of things
                //
                if (!NMSDB_ENTRY_NORM_GRP_M(pStatusInfo->EntTyp))
                {
                        BOOL   fIsMem;

                        //
                        // Init the following fields since they are used to
                        // by GetGrpMem (for determining fIsMem)
                        //
                        pRowInfo->NodeAdds.NoOfMems   = 1;
                        pRowInfo->NodeAdds.Mem[0].Add = *(pRowInfo->pNodeAdd);

                        //
                        // get all non-expired group/multihomed members
                        //
                        if (GetGrpMem(
                                SesId,
                                TblId,
                                pRowInfo,
                                pRowInfo->TimeStamp,
                                pStatusInfo,
                                NMSDB_IS_ENTRY_STATIC_M(FlagVal),
                                &fIsMem
                                 ) != WINS_SUCCESS)
                        {
                                return(WINS_FAILURE);
                        }

                        //
                        // If client is not a member of the group (maybe it
                        // never registered or if it did, maybe its entry
                        // has timed out.)  We return SUCCESS
                        //
CHECK("Maybe we should return NO_SUCH_ROW here. This will then result")
CHECK("in a NAM_ERR being returned to the client. Also, is there any")
CHECK("need to keep members around even if they have timed out just so")
CHECK("that we don't release a spec. group due to a request from a client")
CHECK("that was never a member. ")
                        if ((!fIsMem) || (pStatusInfo->NodeAdds.NoOfMems == 0))
                        {
                           pStatusInfo->StatCode = NMSDB_SUCCESS;
                           return(WINS_SUCCESS);
                        }
                        else  //client is a member of the group/multihomed list
                        {
                                DWORD i;
                                DWORD n = 0;

                                //
                                // Save the address of the client in a local
                                // var.
                                //
                                COMM_IP_ADD_T  IPAdd =
                                             pRowInfo->NodeAdds.Mem[0].
                                                        Add.Add.IPAdd;
                                //
                                // Init the no. of mems fields of the address
                                // structure to store to 0
                                //
                                pRowInfo->NodeAdds.NoOfMems = 0;

                                //
                                // remove the client from the active list by
                                // storing all other members in the NodeAdds
                                // field of ROW_INFO_T structure. Note:
                                // if there is an address match, we remove
                                // the member irrespective of its ownership.
                                // Also note:  This code is not reachable
                                // for a static record (see above)
                                // unless it is an admin request.
                                //
                                for (i = 0;
                                     i < pStatusInfo->NodeAdds.NoOfMems;
                                     i++
                                     )
                                {
                                        if (
                                 pStatusInfo->NodeAdds.Mem[i].Add.Add.IPAdd
                                          != IPAdd                                                                              )
                                        {
                                                pRowInfo->NodeAdds.Mem[n++]
                                                 = pStatusInfo->NodeAdds.Mem[i];
                                                pRowInfo->NodeAdds.NoOfMems++;
                                        }

                                }
                                //
                                // If there is at least one group/multihomed
                                // member, we do not release the row
                                //
                                if (pRowInfo->NodeAdds.NoOfMems != 0)
                                {
                                        fToRelease = FALSE;
                                }
                        } //end of else
                }
        }

        /*
         * Retrieve the owner Id column.
        */
        CALL_M(
                  JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &OldOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                  );

        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat = JetPrepareUpdate(
                        SesId,
                        TblId,
                        JET_prepReplace
                                 );
        if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnNoWriteLock)
           )
        {
                RET_M(JetRetStat);
        }


        //
        // If we have to release a record not owned by us, let us change
        // it into a tombstone.  This will result in replication of the same.
        // We want this to shorten the db inconsistency window between our
        // db and the db of the WINS that owns this record.
        //
        // Consider the following situation: Client A registers AA at WINS A
        // It then releases AA at WINS B. On a reboot, it registers at WINS A.
        // Subsequent refreshes also go to WINS A.  Since AA was active at WINS
        // A when the registration after the release (at B) came in, the
        // version number wouldn't be incremented and so the record will not
        // replicate again.  B will continue to have the released record
        // until it becomes a tombstone and gets replicated.
        //
        if (fToRelease)
        {
             //
             // Get rid of released state altogether
             //
           if (OldOwnerId != Ownerid)
           {
             FlagVal |= (NMSDB_E_TOMBSTONE << NMSDB_SHIFT_STATE);
             //
             // Strictly speaking, for a record that has been turned into
             // a tombstone, we should be using the tombstonetimeout value,
             // we don't do that here.  Since such a record never went through
             // the released state, we set the expiry to the aggregate of the
             // tombstone interval and tombstone timeout (to doubly safeguard
             // against it getting deleted prematurely - long weekend and
             // everything).
             //
             pRowInfo->TimeStamp +=
                  WinsCnf.TombstoneInterval + WinsCnf.TombstoneTimeout;
             DBGPRINT3(DET, "NmsDbRelRow: Changing from ACTIVE TO TOMBSTONE. Name = (%s),Old and new OwnerId (%d/%d)\n",
                       pRowInfo->pName, OldOwnerId,Ownerid);
FUTURES("Use macro in winevt.h.  Make it a warning")
#if 0 //per bug #336889
             if (WinsCnf.LogDetailedEvts > 0)
             {
                 WinsEvtLogDetEvt(TRUE, WINS_EVT_REL_DIFF_OWN, NULL, __LINE__, "sd", pRowInfo->pName,
                                  OldOwnerId);
             }
#endif

           }
           else
           {
             FlagVal |= (NMSDB_E_RELEASED << NMSDB_SHIFT_STATE);
             pRowInfo->TimeStamp += WinsCnf.TombstoneInterval;
           }
        }
        else        //hit only for a special group/multihomed entry
        {


                pRowInfo->TimeStamp += WinsCnf.RefreshInterval;
                //
                //Set the address field with the new member list
                //
                CALL_M( InsertGrpMemsInCol(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        JET_prepReplace
                                          )
                      );

        }
        /*
                Set flags column
                Even though not required for special groups, we set it
                to save ourselves an if test (an if test will impact 99% of the
                client releases).
          */
         CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                 )
               );

         //
         // Since we are taking over ownership of this record, we must
         // update the version number also, else there can be a conflict
         //
         if (OldOwnerId != NMSDB_LOCAL_OWNER_ID)
         {
            /* Set the owner byte        */
            CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &Ownerid,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                 )
               );
            // set the the version number column
            CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );
#ifdef WINSDBG
             fUpd = TRUE;
             pRowInfo->EntryState_e = NMSDB_E_RELEASED;
#endif

         }



         /* set the timestamp column         */
         CALL_M( JetSetColumn(
                                pTls->SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),  /*change type to TIME_STAMP_T
                                                 *later*/
                                0,
                                NULL /*optional info */
                                 )
               );


#ifndef WINSDBG
        CALL_M(JetUpdate (
                        SesId,
                        TblId,
                        NULL,
                        0L,
                        NULL
                         )
              );
#else
     JetRetStat =  JetUpdate (  SesId,  TblId,   NULL,  0L,  NULL);
     ASSERT(JetRetStat != JET_errKeyDuplicate);
     if (JetRetStat == JET_errKeyDuplicate)
     {
        WinsEvtLogDetEvt(FALSE, WINS_EVT_DATABASE_UPD_ERR, NULL, __LINE__,
             "sdd", pRowInfo->pName, Ownerid, FlagVal);
     }
     CALL_M(JetRetStat);
#endif

  } // end of try block
finally {

        if (AbnormalTermination())
        {
                CALL_M(JetRollback(SesId, JET_bitRollbackAll));
        }
        else
        {
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                if (OldOwnerId != NMSDB_LOCAL_OWNER_ID)
                {
                      //
                      // No need to send any push notification since we do
                      // not wish to replicate this change.
                      //
                      // Also, no need to call NMSNMH_INC_VERS_COUNTER_M since
                      // it is ok not to check against threshold if the
                      // version number got incremented because of a release.
                      //
                      NMSNMH_INC_VERS_NO_M(NmsNmhMyMaxVersNo, NmsNmhMyMaxVersNo);
                }
        }
 }
        NMSNMH_UPD_UPD_CTRS_M(fUpd, TRUE, pRowInfo);
        return(WINS_SUCCESS);
}

STATUS
NmsDbQueryRow(
        IN  PNMSDB_ROW_INFO_T        pRowInfo,
        OUT PNMSDB_STAT_INFO_T  pStatusInfo
)

/*++
Routine Description:

        This function queries a record in the database.

Arguments:

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamQuery

Side Effects:

Comments:
        None
--*/
{

        DWORD       FldNo      = 0;
        DWORD       FlagVal    = 0;     //flag value of record that is retrieved
        DWORD       ActFldLen  = 0;     //length of fld retrieved
        BOOL        fFound     = FALSE; //set to TRUE if Address is found in group

        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T        pTls;
        STATUS                RetStat = WINS_SUCCESS;

        pStatusInfo->NodeAdds.NoOfMems = 1;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M(JetBeginTransaction(pTls->SesId));
try {
        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
              );

         if ( JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekEQ
                     ) ==  JET_errSuccess
            )
         {

            // retrieve the flags column
            CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &FlagVal,
                        sizeof(FlagVal),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );


            pStatusInfo->EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
            pStatusInfo->fLocal = NMSDB_IS_ENTRY_LOCAL_M(FlagVal);
            pStatusInfo->NodeTyp = (BYTE)((FlagVal & NMSDB_BIT_NODE_TYP) >> NMSDB_SHIFT_NODE_TYP);

            if (pStatusInfo->EntTyp == NMSDB_UNIQUE_ENTRY)
            {
                /* It is a unique entry*/

                /*
                 * check the flag field to determine if it is
                 * released or a tombstone.   Get the address if
                 * the entry is ACTIVE or if it is an admin query
                */
                if ((NMSDB_ENTRY_ACT_M(FlagVal)) || pRowInfo->fAdmin)
                {

                        JET_RETINFO RetInfo;

                           /* retrieve the ip address column*/

                       RetInfo.itagSequence = 1;
                       RetInfo.cbStruct     = sizeof(JET_RETINFO);
                       RetInfo.ibLongValue  = 0;

                          CALL_M( JetRetrieveColumn(
                                  SesId,
                                  TblId,
                                  sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                  &(pStatusInfo->NodeAdds.Mem[0].Add),
                                  sizeof(COMM_ADD_T),
                                  &ActFldLen,
                                  0,
                                  &RetInfo
                                                     )
                             );

                       pStatusInfo->NodeAdds.NoOfMems = 1;

                }
                else  // the unique entry is released or a tombstone
                {
                    /*
                        If the state is anything other than active, return
                        no such row
                    */
                    pStatusInfo->StatCode          = NMSDB_NO_SUCH_ROW;

                }

           }
           else // it is a group/multihomed record
           {

                /*
                  Check whether this is a normal group or a special group.

                  For normal group, we return the subnet broadcast
                  address.  This means that we have to find the subnet
                  mask for the network from which the request came.

                  For now, we return all 1s (-1).  This
                  indicates the broadcast address on the
                  local subnet (Vol 1, 2, 3 of Comer for the naive)
                */

                if (pStatusInfo->EntTyp == NMSDB_NORM_GRP_ENTRY)
                {

                   DBGPRINT0(FLOW, "Record queried is a normal group record\n");
                   //
                   //  If it is not a TOMBSTONE, return the subnet mask.
                   //  We return the subnet mask even when the state is
                   //  RELEASED because the group may be active at another
                   //  WINS server
                   //
                   if (!(NMSDB_ENTRY_TOMB_M(FlagVal)) || pRowInfo->fAdmin)
                   {
                        pStatusInfo->NodeAdds.Mem[0].Add.Add.IPAdd = 0xFFFFFFFF;
                   }
                   else  //state is tombstone
                   {
                      pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                   }

                }
                else        // it is a special group/multihomed entry
                {

                        BOOL        fIsMem;

                           DBGPRINT1(FLOW, "Record queried is a %s record\n",
                          NMSDB_ENTRY_SPEC_GRP_M(pStatusInfo->EntTyp) ?
                                "SPECIAL GROUP" : "MULTIHOMED");

#if 0
//NOTE: No need to do the following, since we don't care about the value of
//fIsMem returned GetGrpMem()
                         pRowInfo->NodeAdds.NoOfMems   = 1;
                        pRowInfo->NodeAdds.Mem[0].Add = *(pRowInfo->pNodeAdd);
#endif

                        //
                        // We return only the active members.
                        //
                        // Remember:
                        // A special group/multihomed entry is released when
                        // all its members have timed out.  A member times out
                        // only if it is a non-STATIC entry, is owned by the
                        // local WINS, and has not been refreshed within the
                        // refresh time interval.  All owned entries get
                        // released if they are not refreshed.  A member also
                        // gets removed if a release is received for it.
                        // Now, an owned multihomed entry/special group can have
                        // members owned by other WINS servers. The only member we
                        // may get is one that belongs to the local WINS
                        // for which the WINS got a release earlier (but
                        // the member was not removed)
                        //

                        if (NMSDB_ENTRY_ACT_M(FlagVal) || pRowInfo->fAdmin )
                        {
                                //
                                // Get all non-expired members unless it is
                                // is a STATIC record in which case get all
                                // members regardless of whether or not they
                                // have expired.
                                //
                                // NOTE: For some cases we also want to return expired
                                // members. e.g WINSA has name FOO with members (A,B)
                                // and WINSB has name FOO with members B. WINSA owns the
                                // member B. When B is expired on WINSA and if the replication
                                // is broken for extended period of time, then we still
                                // want to return member B from WINSA. Consider passing TRUE
                                // for the fStatic parameter.
                                GetGrpMem(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        pRowInfo->TimeStamp,
                                        pStatusInfo,
                                        NMSDB_IS_ENTRY_STATIC_M(FlagVal),
                                        &fIsMem
                                         );

                                if ((pStatusInfo->NodeAdds.NoOfMems == 0)
                                        && !pRowInfo->fAdmin)
                                {
                                        pStatusInfo->StatCode =
                                                NMSDB_NO_SUCH_ROW;
                                }
                        }
                        else  //special group/multihomed entry is a tombstone
                        {
                                pStatusInfo->NodeAdds.NoOfMems = 0;
                                pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                        }

                        //
                        // If the group/multihomed entry does not have any
                        // members (i.e. all members have timed out, change
                        // the state of the entry to RELEASED
                        //
FUTURES("Maybe change the state of the group to released now")

                } // it is a special group or multihomed entry
           }
        }
        else
        {
           RetStat = WINS_FAILURE;
        }

        //
        // If this function was invoked in an RPC thread and all
        // operation upto now have succeeded, let us get the owner Id and
        // version number of the record
        //
        if ((pRowInfo->fAdmin) && (RetStat == WINS_SUCCESS))
        {

            pStatusInfo->EntryState_e  =  NMSDB_ENTRY_STATE_M(FlagVal);
            pStatusInfo->fStatic       = NMSDB_IS_ENTRY_STATIC_M(FlagVal);

#if !NEW_OWID
pStatusInfo->OwnerId = 0;
#endif
            /*
             * Retrieve the owner Id column.
            */
            CALL_M(
                  JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &pStatusInfo->OwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                  );
              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pStatusInfo->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

             //
             // get the timestamp field
             //
             CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pStatusInfo->TimeStamp),
                        sizeof(pStatusInfo->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );
        }
}
finally {
        CALL_M(JetRollback(pTls->SesId, JET_bitRollbackAll));
        }
        return(RetStat);
}

STATUS
NmsDbUpdateRow(
        IN   PNMSDB_ROW_INFO_T        pRowInfo,
        OUT  PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function replaces a conflicting row in the database with the
        row passed.  It expects the currency to be on the record

Arguments:
        pRowInfo    - Information about the record to insert/replace
        pStatusInfo - Status of operation and information about the conflicting
                      record if the update resulted in a conlfict (only for
                      an insert)

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NBT request thread -- NmsNmhNamRegInd()

Side Effects:

Comments:
        None
--*/
{

        JET_TABLEID     TblId;
        JET_SESID        SesId;
        PWINSTHD_TLS_T        pTls;
#ifdef WINSDBG
        JET_ERR     JetRetStat;
#endif

        pTls  = TlsGetValue(WinsTlsIndex);

        // No need to check whether pTls is NON-NULL.  It has to be

        TblId = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        pStatusInfo->StatCode = NMSDB_SUCCESS;


#ifndef WINSDBG
         /*
          * Replace the row
         */
         CALL_M(
                UpdateDb(
                        SesId,
                        TblId,
                        pRowInfo,
                        JET_prepReplace
                         )
               );
#else

    JetRetStat =   UpdateDb( SesId,  TblId,  pRowInfo, JET_prepReplace );

    if (JetRetStat == JET_errKeyDuplicate)
    {
            BYTE Tmp[20];
            WinsEvtLogDetEvt(FALSE, WINS_EVT_DB_ERR, NULL, __LINE__,
              "sssdd", pRowInfo->pName, _itoa(pRowInfo->VersNo.LowPart, Tmp, 10), _itoa(pStatusInfo->VersNo.LowPart, Tmp, 10), pRowInfo->OwnerId, pStatusInfo->OwnerId);
            DBGPRINT5(ERR, "NmsDbUpdateRow: Could not replace row\nName=(%s);Owner id = (%d);Vers. no = (%d)\nNew owner id = (%d); New Vers.No = (%d)\n",
           pRowInfo->pName, pStatusInfo->OwnerId, pStatusInfo->VersNo.LowPart,
           pRowInfo->OwnerId, pRowInfo->VersNo.LowPart);

            return(WINS_FAILURE);
    }
    else
    {
        CALL_M(JetRetStat);
    }
#endif

        //
        // NOTE: This call must be made after the UpdateDb above
        // because otherwise we will need to seek to the record
        // to be replaced
        //
        UpdHighestVersNoRecIfReqd(pTls, pRowInfo, pStatusInfo);

        return(WINS_SUCCESS);
}

STATUS
NmsDbSeekNUpdateRow(
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
)

/*++
Routine Description:

        This function seeks to a conflicting record and then replaces it
        in the database with the row passed.


Arguments:
        pRowInfo - Contains name to query
        pStatusInfo - Information about the name queried


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ChlUpdDb (Name Challenge thread) in NmsChl.c

Side Effects:

Comments:
        Currently, this function is called only by the Name Challenge manager.
        When it starts getting called by another component, we would need
        to make sure that comparison of the owner id. retrieved from the
        row to be replaced with the one we retrieved prior to handing the
        request to the name challenge manager is the correct action for all
        situations.
--*/
{

        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
#if NEW_OWID
        DWORD            OwnerId;
#else
        DWORD            OwnerId = 0;
#endif
        DWORD           ActFldLen;
        JET_ERR         JetRetStat;
        STATUS          RetStat = WINS_SUCCESS;

        pTls  = TlsGetValue(WinsTlsIndex);

        //
        // No need to check whether pTls is NON-NULL.  It has to be
        //
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;
        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pRowInfo->pName,
                        pRowInfo->NameLen,
                        JET_bitNewKey
                          )
                        );

        if ((JetRetStat = JetSeek(
                SesId,
                TblId,
                JET_bitSeekEQ
                    )) ==  JET_errSuccess
            )
         {


                //
                // Before replacing the row, let us check whether it is still
                // owned by the same owner.  We check this because during the
                // window in which this challenge thread was working, the
                // replicator might have pulled in records from another WINS
                // server and updated the row with another row or a local
                // nbt request might have resulted in the row getting updated
                // (if it was a replica first). In either of the two cases
                // above, we do not want to update the row.
                //

                /*
                 * Retrieve the owner Id column.
                */
                   CALL_M(
                           JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                &ActFldLen,
                                0,
                                NULL
                                           )
                     );

                if (OwnerId == pStatusInfo->OwnerId)
                {

                    /*
                     * Replace the row
                    */
                    CALL_M(
                        UpdateDb(
                                SesId,
                                TblId,
                                pRowInfo,
                                JET_prepReplace
                                 )
                          );

                    //
                    // NOTE: This call must be made after the UpdateDb above
                    // because otherwise we will need to seek to the record
                    // to be replaced
                    //
                    UpdHighestVersNoRecIfReqd(pTls, pRowInfo, pStatusInfo);
                }
         }
         else
         {
                /*
                 * Means that some other thread (other than challenger),
                 * deleted the record. It has to be an rpc thread since
                 * an NBT thread would release the record, not delete it
                */
                WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                RetStat = WINS_FAILURE;
        //        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
         }

         return(RetStat);
}



STATUS
NmsDbGetDataRecs(
        IN  WINS_CLIENT_E   Client_e,
        IN  OPTIONAL INT    ThdPrLvl,
        IN  VERS_NO_T       MinVersNo,
        IN  VERS_NO_T       MaxVersNo,
        IN  DWORD           MaxNoOfRecsReqd,
        IN  BOOL            fUpToLimit,
        IN  BOOL            fOnlyReplTomb OPTIONAL,
        IN  PNMSSCV_CLUT_T  pClutter,
        IN  OUT PCOMM_ADD_T  pWinsAdd,
        IN  BOOL            fOnlyDynRecs,
        IN  DWORD           RplType,
        OUT LPVOID          *ppRBuf,
        OUT LPDWORD         pRspBufLen,
        OUT LPDWORD         pNoOfRecs
)

/*++
Routine Description:

        This function returns all the records in the range MinVersNo to
        MaxVersNo that are owned by the WINS server at address pWinsAdd.

Arguments:
        Client_e  - id of client that called this function (Pull handler in
                    replicator or the scavenger thread)
        ThdPrLvl  - priority level of the scavenger thread
        MinVersNo, MaxVersNo - range of version numbers to retrieve
        MaxNoOfRecsReqd - Max. number of records required
        fUpToLimit - Set to TRUE, if the max. version number arg is to
                     be ignored and records upto the last one in the db
                     have to be retrieved
        fOnlyReplTomb  - Only tombstones desired (valid if Client_e is NMSSCV)
        pWinsAdd   - Wins whose records need to be retrieved (owner WINS)
        ppRbuf           - Buffer to contain the records
        pRspBufLen - size of the buffer
        pNoOfRecs  - No of records in the buffer

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        DoScavenging(), UpdDb in nmsscv.c,
        HandleSndEntriesReq() in rplpush.c

Side Effects:

Comments:
        This function changes the index on the name address table to
        clustered index.

        This function has grown over time.  It needs to be streamlined.

--*/
{
        JET_ERR             JetRetStat;
        DWORD                OwnerId;
        DWORD               ActFldLen; //length of fld retrieved
        VERS_NO_T           VersNoDiff;
        VERS_NO_T           TmpNoOfEntries;
        LPBYTE              pStartBuff;
        DWORD               SaveBufLen;
        BYTE                EntTyp; //type of entry (unique/group/special group)
        PRPL_REC_ENTRY_T    pRspBuf;
        JET_TABLEID         TblId;
        JET_SESID           SesId;
        PWINSTHD_TLS_T      pTls;
#if NEW_OWID
        DWORD                RecordOwnerId;
#else
        DWORD               RecordOwnerId = 0;
#endif
        STATUS              RetStat = WINS_SUCCESS;
        VERS_NO_T           DefNo;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               InitHeapSize;
        DWORD               MemSize;

#ifdef WINSDBG
        DWORD               StartTime;
        DWORD               EndTime;
#endif
        DWORD               CommitCnt = 1;   //do not set to any other value
        BOOL                fTransCommitted;
//        LPVOID              pCallersAdd, pCallersCaller;

        DBGENTER("NmsDbGetDataRecs\n");
//        RtlGetCallersAddress(&pCallersAdd, &pCallersCaller);
//        DbgPrint("Callers Address = (%x)\nCallersCaller = (%x)\n", pCallersAdd, pCallersCaller);

#ifdef WINSDBG
        if (!fOnlyReplTomb)
        {
           struct in_addr InAddr;
           if (!fUpToLimit)
           {
                InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                if (MaxNoOfRecsReqd == 0)
                {
                  DBGPRINT5(DET, "NmsDbGetDataRecs:Will retrieve records in the range (%lu %lu) to (%lu %lu) of WINS having address = (%s)\n",
                                MinVersNo.HighPart,
                                MinVersNo.LowPart,
                                MaxVersNo.HighPart,
                                MaxVersNo.LowPart,
                                inet_ntoa(InAddr)
                         );
                }
                else
                {
                  DBGPRINT4(DET, "NmsDbGetDataRecs:Will retrieve a max. of %d records starting from (%lu %lu) version number of WINS having address = (%s)\n",
                                MaxNoOfRecsReqd,
                                MinVersNo.HighPart,
                                MinVersNo.LowPart,
                                inet_ntoa(InAddr)
                         );
                }
           }
           else
           {
                   if (pWinsAdd)
                   {
                       InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                       DBGPRINT3(DET, "NmsDbGetDataRecs: Will retrieve all records starting from version no (%d %d) for WINS (%s)\n", MinVersNo.HighPart, MinVersNo.LowPart, inet_ntoa(InAddr));


                   }
                   else
                   {
                       //
                       // fToLimit = TRUE and fOnlyReplTomb = FALSE means we
                       // are interested only in (active) replicas
                       //
                       DBGPRINT1(DET, "NmsDbGetDataRecs: Will retrieve all active replica records older than verify interval for WINS with owner id = (%d)\n",
                                pClutter->OwnerId);

                   }

           }
        }
        else
        {
               DBGPRINT1(DET, "NmsDbGetDataRecs: Will retrieve %s replica tombstones\n", fUpToLimit ? "all" : "specified range");
        }
#endif

        //
        // initialize the default no. that determines the size of the
        // buffer to allocate in case the range specified by the Max and
        // Min Vers. No args is > it
        //
PERF("Move this to NmsDbInit")
        WINS_ASSIGN_INT_TO_VERS_NO_M(DefNo, INIT_NO_OF_ENTRIES);
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        pTls->HeapHdl = NULL;  //make it NULL so that the caller can determine
                               //whether this function allocated a heap
                               //before returning (normally/abnormally)

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;



        /*
          allocate a buffer using some rough calculations.  Note: The
          calculations help only if the difference between MaxVersNo and
          MinVersNo is less than the predefined number (of records) we use for
          allocating a buffer.  if the difference is > this predefined number,
          we use the predefined number since it might still suffice considering
          that  there may be gaps between version numbers of records falling
          in the  Min-Max range
        */
        if ((!fOnlyReplTomb) && (!fUpToLimit))
        {
           //
           // If a max. number has been specified, use that one.
           // Currently, only the scavenger thread specifies a non-zero
           // value for MaxNoOfRecsReqd
           //
           if (MaxNoOfRecsReqd == 0)
           {

             VersNoDiff.QuadPart =  LiSub(MaxVersNo,MinVersNo);

             //
             // If client is the push thread, since we will never send more
             // than RPL_MAX_LIMIT_FOR_RPL records, do not allocate more
             // memory than is required.
             //
             //
             if (Client_e == WINS_E_RPLPUSH)
             {
               LARGE_INTEGER        TmpNo;
               WINS_ASSIGN_INT_TO_LI_M(TmpNo, RPL_MAX_LIMIT_FOR_RPL);
               if (LiGtr(VersNoDiff, TmpNo))
               {
                        VersNoDiff = TmpNo;
               }
             }
             NMSNMH_INC_VERS_NO_M( VersNoDiff, VersNoDiff );
           }
           else
           {
                VersNoDiff.QuadPart  = MaxNoOfRecsReqd;
           }

           TmpNoOfEntries = LiGtr(VersNoDiff, DefNo) ? DefNo : VersNoDiff;
       }
       else
       {
                TmpNoOfEntries = DefNo;
       }

        //
        // Store the memory size for the records.  Note: This
        // does not contain the memory for the name and addresses
        // (in case of a special group or a multihomed entry). The
        // sizes for these will be added as we store each record.
        //
        MemSize     = RPL_REC_ENTRY_SIZE *  (TmpNoOfEntries.LowPart + 1);
        *pRspBufLen = MemSize + 10000; //for good measure;



        //
        // We will create a heap with the above amount of memory plus a
        // pad for heap overhead.  We add TmpNoOfEntries.LowPart * 17
        // since each record will have memory allocated for the name.
        // Names in general will be 17 bytes long (we attach a NULL at the
        // end when registering names).
        //
        if (Client_e == WINS_E_RPLPUSH)
        {
                InitHeapSize = (*pRspBufLen * 4) + (TmpNoOfEntries.LowPart * 17)                                         + PAD_FOR_REC_HEAP;
        }
        else
        {
                InitHeapSize = *pRspBufLen + (TmpNoOfEntries.LowPart * 17)
                                        + PAD_FOR_REC_HEAP;
        }


        //
        // Create the heap
        //
        pTls->HeapHdl = WinsMscHeapCreate(0, InitHeapSize);

        pRspBuf = WinsMscHeapAlloc(pTls->HeapHdl, MemSize);

        pStartBuff  = (LPBYTE)pRspBuf;        //save start of buffer
        SaveBufLen  = MemSize;                //save size of buffer
        *ppRBuf     = pStartBuff;
        *pNoOfRecs  = 0;

        //
        // If we are not acquiring just tombstones
        //
        if (!fOnlyReplTomb)
        {
            //
            // Actually, we can call RplFindOwnerId for Scavenger thread
            // We choose not to do so to avoid some overhead -- see the
            // comment in the else block.
            //
            if (Client_e != WINS_E_NMSSCV)
            {
              BOOL  fAllocNew =  FALSE;
#if 0
              BOOL  fAllocNew =
                              (Client_e == WINS_E_WINSRPC) ? FALSE : TRUE;
              //
              // The following function enters a critical section.
              //
              // We do not want this function to allocate an
              // an entry in the OwnAddTbl table for the Wins if we
              // are executing in a RPC thread.  We want to add
              // a WINS address - Owner Id mapping in the above table
              // (if not existent) only as a result of normal (as versus
              // administrator initiated) actions of the WINS.
              //
              //  NOTE: if there is no entry for the WINS address in the
              //  in-memory owner address table, the administrative
              //  action to retrieve records for a non-existent WINS will
              //  fail later on (as it should). Check out WinsGetDbRecs
              //
#endif
            try {
              if (RplFindOwnerId(
                            pWinsAdd,
                            &fAllocNew,
                            &OwnerId,
                            WINSCNF_E_IGNORE_PREC,
                            WINSCNF_LOW_PREC
                            ) != WINS_SUCCESS
                  )
                {
                        DBGPRINT1(ERR, "NmsDbGetDataRecs: Could not find owner id of address = (%x)\n", pWinsAdd->Add.IPAdd);
                        //
                        // The client may not look at the return value, but
                        // it will look at the *pNoOfRecs value and thus
                        // determine that there are no records.
                        //
                        return(WINS_FAILURE);
                }
             }
            except(EXCEPTION_EXECUTE_HANDLER) {
                        DWORD  ExcCode = GetExceptionCode();
                        DBGPRINT1(EXC, "NmsDbGetDataRecs: Got exception %x",
                                        ExcCode);
                        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_RETRIEVE_DATA_RECS);
                        return(WINS_FAILURE);
                }
            }
            else
            {
                //
                // Executed by scavenger thread. pClutter will not be NULL
                // if we are verifying the validity of old replicas
                //
                if (!pClutter)
                {
                  //
                  // The scavenger thread calls this function either to
                  // get all replica tombstones, to get records owned
                  // by the local WINS or verify the validity of old active
                  // replicas. We therefore do not need to call the
                  // RplFindOwnerId function (not calling it lets us avoid a
                  // executing a chunk of code and also saves us from entering
                  // a  critical section)
                  //
                  OwnerId = 0;
                }
                else
                {
                  //
                  // We are just interested in active replicas that are older
                  // than the verify interval
                  //
                  OwnerId = (BYTE)pClutter->OwnerId;
                }
            }
        }
        else
        {
                //
                // Tombstones are to be retrieved.
                //
                // Actually we should enter a critical section prior to
                // retrieving the value of NmsDbNoOfOwners since it
                // can be changed by the Pull thread.  We choose not to
                // do so in order to save some overhead.  Even if we
                // get the wrong value (very low probability), we will
                // know of it when we do the seek.  If we get <=1 when
                // it is actually more than 1, it is still ok since we
                // will get the right value next time (or next to next)
                //
FUTURES("Enter critical section to get NmsDbNoOfOwners.  Raise priority")
FUTURES("before doing so")
                if (NmsDbNoOfOwners > 1)
                {
                        //
                        // We are interested in getting tombstones of
                        // replicas only. Tombstones on entries owned
                        // by the local WINS will be retrieved separately
                        // (every time we check whether owned entries need
                        // to be released or made tombstones)
                        //
                        OwnerId            = 1;
#if 0
                        MinVersNo.LowPart  = 0;
                        MinVersNo.HighPart = 0;
#endif
                        MinVersNo.QuadPart  = 0;
                }
                else
                {
                        DBGPRINT0(FLOW, "NmsDbGetDataRecs: This DB HAS NO REPLICAS IN IT\n");
                        DBGLEAVE("NmsDbGetDataRecs\n");

                        //
                        // The buffer allocated above will get deallocated
                        // in UpdDb (in nmsscv.c)
                        //
                        //*ppRBuf = pStartBuff;
                        return(WINS_SUCCESS);
                }
        }

        /*
        *  start a transaction
        */
        CALL_M( JetBeginTransaction(SesId) );
        fTransCommitted = FALSE;
try {
        /*
         * Use primary index now
        */
        CALL_M( JetSetCurrentIndex(
                                SesId,
                                TblId,
                                NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                                        //first component of the key
                          )
              );

        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );

        if (JetRetStat == JET_errRecordNotFound)
        {
                //
                // This is an error only if the function was called in the
                // PUSH thread (HandleSndEntriesRsp()). If it was called
                // in the Scavenger thread (DoScavenging()), it may not be an
                // error.  This is because when scavenging, we start with
                // the lowest version number possible (1) in specifying a
                // range the size of WinsCnf.ScvChunk. We them make successive
                // calls for getting the next batch of records in equal
                // sized ranges that occur in tandem until we reach the
                // highest version number of owned records as indicated
                // by NmsNmhMyMaxVersNo. It is thus very much possible that
                // the ranges specified at the lower end of the list of
                // ranges are devoid of records
                //
                if (Client_e == WINS_E_RPLPUSH)
                {
                        DBGPRINT5(ERR, "Weird.  Could not locate even one record in the range (%d %d) - (%d %d) of owner with id (%d)\n",
                        MinVersNo.HighPart,
                        MinVersNo.LowPart,
                        MaxVersNo.HighPart,
                        MaxVersNo.LowPart,
                        OwnerId);

                        WINSEVT_LOG_M(
                                        WINS_FAILURE,
                                        WINS_EVT_CANT_FIND_ANY_REC_IN_RANGE
                                     );

                        //
                        // Don't free memory.  It will get freed later by
                        // HandleSndEntriesRsp/DoScavenging.  In case the caller
                        // is HandleSndEntriesRsp(), what will happen is that
                        // it will send a response with 0
                        // records (i.e. no records).  The Pull Pnr will
                        // find this out and will continue to function normally
                        //
                        // The response with 0 records is doing the work of a
                        // negative (error) response.
                        //
                        RetStat = WINS_FAILURE;
                }
#ifdef WINSDBG
                else  // has to be WINS_E_NMSSCV or WINS_E_WINSRPC
                {
                        DBGPRINT0(DET, "NmsDbGetDataRecs: Did not find even one record in the db.  Maybe all got deleted\n");
                }
#endif
        }
        else  //JetSeek did not return JET_errRecordNotFound.
        {

CHECK("It may be better to count the number of records first and allocate")
CHECK(" a buffer big enough to store all of them (i.e. take a hit once")
CHECK(" than a small hit of an if test in every iteration. ")
           //
           // Do until there are no more records in the database to retrieve
           //

           //
           // We are assured of there being at least one record since the
           // JetSeek succeeded (if not for the owner we are interested in
           // then for the next one).
           // We can therefore safely use the do .. while() construct
           //
           // *NOT REALLY.  It seems that JetSeek can return JET_wrnSeekNE
           // even when there are no records in the db.  In such a case,
           // our JetRetrieveColumn will fail with a CurrencyNot there error
           //
CHECK("Check with IAN JOSE")

#ifdef WINSDBG
           //(void)time(&StartTime);
           StartTime = GetTickCount();
#endif
           do
           {
               //
               // If the number of records has exceeded what can be stored
               // in our buffer, allocate another buffer of double the size
               // and use that.
               //
               if (*pNoOfRecs > TmpNoOfEntries.LowPart)
               {
                    UINT_PTR   Offset = (LPBYTE)pRspBuf - pStartBuff;

                    //
                    // Not a bad place to check whether WINS has been
                    // terminated.  Scavenger thread can take a long time
                    // to go through the entire db if it is large and so
                    // a net stop can take a long time to finish.  This
                    // check here should speed up net stop.
                    //
                    if (Client_e == WINS_E_NMSSCV)
                    {
                          WinsMscChkTermEvt(
#ifdef WINSDBG
                              WINS_E_NMSSCV,
#endif
                              TRUE
                                      );

                    }
                    DBGPRINT1(FLOW, "NmsDbGetDataRecs: No of Records (%d) are more than what we can store in our buffer.  We will allocate a new one\n", *pNoOfRecs);
#if 0
                    TmpNoOfEntries = LiXMul(TmpNoOfEntries, 2);
#endif

                    TmpNoOfEntries.QuadPart = TmpNoOfEntries.QuadPart * 2;
                    ASSERT(!(TmpNoOfEntries.HighPart & 0x80000000));
                    ASSERT(TmpNoOfEntries.LowPart < 0xFFFFFFFF);


                    MemSize = RPL_REC_ENTRY_SIZE * ((DWORD)TmpNoOfEntries.QuadPart + 1);
                    pRspBuf = HeapReAlloc(pTls->HeapHdl,
                                          HEAP_GENERATE_EXCEPTIONS |
                                          HEAP_ZERO_MEMORY,
                                          pStartBuff, MemSize);


                    DBGPRINT1(DET, "NmsDbGetDataRecs: Doing a realloc in thd\n", pTls->ThdName);
                    //
                    // Save the start position of the new buffer
                    //
                    pStartBuff  = (LPBYTE)pRspBuf;

                    *ppRBuf     = pStartBuff;

                    //
                    // Make pRspBuf point to just past the last record
                    // inserted
                    //
                    pRspBuf    =  (PRPL_REC_ENTRY_T)(pStartBuff + Offset);

                    //
                    // Add the length we incremented *pRspBufLen by to
                    // the new memory size
                    //
                    *pRspBufLen = (*pRspBufLen - SaveBufLen) + MemSize;

                    //
                    // Store the new length in SaveBufLen
                    //
                    SaveBufLen  = MemSize;

              }

              JetRetStat = JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                            );

#if 0
//apparently with 118.6 we don't need to execute this code
             //
             // if currency is not on a record, then this means that
             // this is our first iteration of the do loop.  JetSeek above
             // must have returned JET_wrnSeekNE.  See comment above.
             //
             // A continue will result in us doing a JetMove and getting
             // out of this loop.  We do a 'continue' instead of a break
             // since a break would involve a search of the termination
             // handler which is an expensive operation (but then maybe
             // JetMove may also be an expensive operation even though it is
             // done in memory)
             //
PERF("Is it better to break out of the loop. Check with Ian regarding JetMove")
             if (JetRetStat == JET_errNoCurrentRecord)
             {
                ASSERT(*pNoOfRecs == 0);
                continue;
             }
             else
#endif
             {
                //
                // check that we don't have some other error here
                //
FUTURES("Yet another hack to workaround jet bugs = 7-11-94")
                if (JetRetStat == JET_errRecordDeleted)
                {
                     DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",
                                      JetRetStat, __LINE__);
                     continue;

                }
                CALL_M(JetRetStat);
             }
PERF("In case fOnlyReplTomb is true, retrieve the state field first")
              //
              // if only tombstones are required, it means that we need
              // all tombstones irrespective of owner
              //
              if (!fOnlyReplTomb)
              {
                 if (RecordOwnerId != OwnerId )
                 {
                   //
                   // We have exhausted all records for the owner. Break out
                   // of the loop
                   //
                  break;
                 }
              }


              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pRspBuf->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if only tombstones are required, it means that we need
              // all tombstones irrespective of version number
              //
              if (
                  (!fOnlyReplTomb)
                        &&
                  (!fUpToLimit)
                        &&
                  LiGtr(pRspBuf->VersNo, MaxVersNo)
                 )
              {
                 //
                 // We have acquired records upto MaxVersNo.  Break out
                 // of the loop
                 //
                 break;
              }


              //
              // Retrieve the flags byte
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &(pRspBuf->Flag),
                        sizeof(pRspBuf->Flag),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if we were asked to retrieve only dynamic records and
              // this record is static, skip it.
              //
              if (fOnlyDynRecs && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a STATIC record but were asked to retrieve only dynamic records\n");
                        continue;
              }

              //
              // retrieve the name
              //
              CALL_M(JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        //pRspBuf->Name,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &(pRspBuf->NameLen),
                        0,
                        NULL  ) );

             //
             // if name length is > 255, jet is returning an invalid value.
             // Make the length equal to the max. length we can have for
             // a netbios name.  Also, log an event
             //
             if (pRspBuf->NameLen > WINS_MAX_NAME_SZ)
             {
                 WINSEVT_LOG_M(pRspBuf->NameLen, WINS_EVT_NAME_TOO_LONG);
                 DBGPRINT1(ERR, "NmsDbGetDataRecs: Name length is too long = (%x)\n", pRspBuf->NameLen);
                 pRspBuf->NameLen = WINS_MAX_NS_NETBIOS_NAME_LEN;
             }


             //
             // This macro will allocate memory and store the name in it
             //
             NMSDB_STORE_NAME_M(pTls, pRspBuf, Name, pRspBuf->NameLen);

              //
              // We need to retrieve the address field if we are in the
              // PUSH thread or an RPC thread
              //
              if (Client_e != WINS_E_NMSSCV)
              {
                    //
                    // If the record is released, go to the next record
                    //
                    if(
                         (Client_e == WINS_E_RPLPUSH)
                                 &&
                         (NMSDB_ENTRY_REL_M(pRspBuf->Flag))

                      )
                    {
                        DBGPRINT0(DET,
        "NmsDbGetDataRecs: ENCOUNTERED A RECORD IN THE RELEASED STATE\n");

                        continue;
                    }

                   EntTyp = (BYTE)((pRspBuf->Flag & NMSDB_BIT_ENT_TYP));
                   if (
                        (EntTyp == NMSDB_UNIQUE_ENTRY)
                                    ||
                        (EntTyp == NMSDB_NORM_GRP_ENTRY)
                      )
                   {
                      /* It is a unique entry*/
                      pRspBuf->fGrp = (EntTyp == NMSDB_UNIQUE_ENTRY) ?
                                                        FALSE : TRUE;
                      CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRspBuf->NodeAdd,
                                 sizeof(COMM_ADD_T),
                                &ActFldLen,
                                0,
                                NULL
                                        )
                            );

                   }
                   else  // it is a special group or a multihomed entry
                   {


                      //
                      // Even if the entry is a multihomed entry, we set the
                      // fGrp flag to TRUE so that the formatting function
                      // works properly (called by PUSH thread).  The EntTyp
                      // will be used to decipher whether it is a multihomned
                      // entry or not
                      //
FUTURES("Remove this hacky mechanism")
                      pRspBuf->fGrp =
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? TRUE : FALSE;

                     /*
                     *  get member addresses.
                     *
                     * If we are in an RPC thread, we want to get the members
                     * even if they are expired.  We can do that by
                     * passing a TRUE value for the STATIC flag parameter.
                     */
                     StoreGrpMems(
                             pTls,
                             Client_e,
                             pRspBuf->pName,
                             ThdPrLvl,
                             SesId,
                             TblId,
                             (WINS_E_WINSRPC == Client_e ? TRUE
                                                         : NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag)),
                             pRspBuf
                            );


                   //
                   // if the record is active but has no members,
                   // don't send it. It is possible that all
                   // members of the group  expired after the last scavenging
                   // cycle.  This record will be marked RELEASED at the next
                   // scavenging cycle.
                   // For now ignore the record
                   //
                   if (
                        (pRspBuf->NoOfAdds == 0)
                                &&
                        (NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                      )
                   {
                        if (Client_e == WINS_E_RPLPUSH)
                        {
                           DBGPRINT2(FLOW, "NmsDbGetDataRecs: Active Group (Version # %d %d) has no members. So it is not being replicated\n", pRspBuf->VersNo.HighPart, pRspBuf->VersNo.LowPart/*pRspBuf->Name*/);

                          continue;
                        }
                        else
                        {
                             //
                             //Must be an RPC thread.
                             //Change the state to released so that the
                             //record shows up as released when displayed
                             //
                             NMSDB_CLR_STATE_M(pRspBuf->Flag);
                             NMSDB_SET_STATE_M(pRspBuf->Flag, NMSDB_E_RELEASED);

                        }
                   }
                }  // end of else


                //
                // Adjust the size to be passed to the push thread
                //
                if (Client_e == WINS_E_RPLPUSH)
                {
                      *pRspBufLen += pRspBuf->NameLen;
                      if ((EntTyp == NMSDB_MULTIHOMED_ENTRY) ||
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY)
                         )
                      {
                        *pRspBufLen +=
                               (pRspBuf->NoOfAdds * sizeof(COMM_ADD_T) * 2);
                      }
                }

                //
                // If client is the RPC thread, retrieve the timestamp
                //
                if (Client_e == WINS_E_WINSRPC)
                {
                   //
                   // get the timestamp field
                   //
                       CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );
                   if (!fOnlyDynRecs && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag)
                           && (OwnerId == NMSDB_LOCAL_OWNER_ID) && NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                   {
                          pRspBuf->TimeStamp = MAXLONG;
                   }
                }
              }
              else  //client is the scavenger thread
              {
#if 0
                 //
                 // We don't scavenge STATIC records.  This record will be
                 // static only if fOnlyDynRecs is FALSE.  This means we
                 // should not skip it.  VerifyClutter is taking place
                 //
                 if (NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
                 {

                        DBGPRINT0(FLOW,
                          "NmsDbGetDataRecs: Encountered a STATIC record\n"
                                 );
                        continue;
                 }
#endif

                 //
                 // If only tombstones are required and this record is not
                 // a tombstone, go to the next record
                 //
                 if (fOnlyReplTomb && !NMSDB_ENTRY_TOMB_M(pRspBuf->Flag))
                 {
                        continue;
                 }

                 //
                 // pClutter will not be NULL if this function was called
                 // by the scavenger thread to either retrieve replica
                 // tombstones or to retrieve replicas  for consistency
                 // checking
                 //
                 if (pClutter && !fOnlyReplTomb)
                 {
                         //
                         // Want all replicas
                         // for consistency checking
                         //
                         if ( !pClutter->fAll)
                         {
                             //
                             // just interested in active records
                             //
                             if (!NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                             {
                                continue;
                             }
                         }
                 }

                 //
                 // get the timestamp field
                 //
                 CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );


                if (pClutter)
                {
                  //
                  // if we are retrieving clutter, check the time stamp
                  // unless this is a static record
                  //
                  if( !fOnlyReplTomb)
                  {
FUTURES("We need to skip this for owned static records only, not for all")
//                    if (!NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
                    {
                      //
                      // if this record is not old enough, we are not interested
                      //
                      if (
                         pClutter->Age  &&
                         (pRspBuf->TimeStamp >  (DWORD)pClutter->CurrentTime)
                         )
                      {
                        continue;
                      }
                   }
                  }
                  else
                  {
                    //
                    // We want replica tombstones.
                    //
                    if (NMSDB_ENTRY_TOMB_M(pRspBuf->Flag))
                    {
                      if (pClutter->CurrentTime < (time_t)pRspBuf->TimeStamp)
                      {
                        continue;
                      }
                    }

                  }
               }

              } // end of else (Client is the scavenger thread)

#if 0
                     {
//if above jet call returns 1004, print this out - for debugging only
                        DBGPRINT4(ERR, "NmsDbGetDataRecs: ERROR 1004 OWNER ID=(%d); Version No = (%d %d); Flags = (%d)\n", OwnerId, pRspBuf->VersNo.HighPart, pRspBuf->VersNo.LowPart, pRspBuf->Flag);
                        DBGPRINT3(ERR, "NmsDbGetDataRecs: ERROR = 1004; Name = (%s); Len=(%d), Add=(%x)\n", Name, pRspBuf->NameLen, pRspBuf->NodeAdd[0].Add.IPAdd);
                     }
                     CALL_M(JetRetStat);
#endif

#if 0
             //
             // Apply the RplType filter on the record
             // PDC names and special groups, check if it is a unique/mh
             // non PDC name. If yes, skip it.
             //
             if (
                   (RplType & WINSCNF_RPL_SPEC_GRPS_N_PDC) &&
                   !NMSDB_ENTRY_SPEC_GRP_M(EntTyp) &&
                   !(NMSDB_IS_IT_PDC_NM_M(Name))
                )
             {

                     DBGPRINT2(RPLPUSH, "NmsDbGetDataRecs: non 1B unique record = (%s)[16th char = %x) being skipped\n", Name, Name[15]);
                     continue;

             }
#endif


             //
             // increment the counter and the pointer to past the last record.
             //
             pRspBuf = (PRPL_REC_ENTRY_T)((LPBYTE)pRspBuf + RPL_REC_ENTRY_SIZE);
             (*pNoOfRecs)++;

             if (Client_e == WINS_E_RPLPUSH)
             {
                    if (*pNoOfRecs == RPL_MAX_LIMIT_FOR_RPL)
                    {
                             break;
                    }
             }

             //
             // if we have retrieved the max. number asked for, break out of
             // the loop
             //
             if ((MaxNoOfRecsReqd > 0) && (*pNoOfRecs >= MaxNoOfRecsReqd))
             {
                break;
             }

             //
             // If this is the scavenger thread, let us give the version store
             // a breather after a certain number of records have been retrieved
             //
#if 0
             if ((Client_e == WINS_E_NMSSCV) && (*pNoOfRecs/CommitCnt >= WINSCNF_SCV_CHUNK))
#endif
             if (*pNoOfRecs/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
             {

                //
                // Let us commit the transaction to free up the version store
                //
                CALL_M(
                        JetCommitTransaction(SesId, JET_bitCommitFlush)
                            );
                fTransCommitted = TRUE;
                CommitCnt++;
                CALL_M( JetBeginTransaction(SesId) );
                fTransCommitted = FALSE;

             }



          } while(JetMove(SesId, TblId, JET_MoveNext, 0) >= 0);
#ifdef WINSDBG
           EndTime = GetTickCount();
           DBGPRINT2(TM, "NmsDbGetDataRecs: Retrieved %d records in %d secs\n",
                                *pNoOfRecs, StartTime - EndTime);
#endif
     }  // end of else

} // end of try {..}
finally {
                if (AbnormalTermination())
                {
                        DWORD EvtCode;
                        DBGPRINT0(ERR,
                                "NmsDbGetDataRecs: Terminating abnormally\n");
                        if (Client_e == WINS_E_WINSRPC)
                        {
                                EvtCode = WINS_EVT_RPC_EXC;
                        }
                        else
                        {
                                EvtCode = (Client_e == WINS_E_RPLPUSH) ?
                                                WINS_EVT_RPLPUSH_EXC :
                                                WINS_EVT_SCV_EXC;
                        }
                        WINSEVT_LOG_M(WINS_FAILURE, EvtCode);
                        RetStat = WINS_FAILURE;
                }
                //*ppRBuf = pStartBuff;
                DBGPRINT1(FLOW, "NmsDbGetDataRecs:Retrieved %d records\n",
                                        *pNoOfRecs);

                //
                // If the no of records retrieved is 0, log an informational
                // message.  The reason for 0 records being retrieved could
                // be that all records are released
                //
                if (*pNoOfRecs == 0)
                {
                        WINSEVT_STRS_T  EvtStrs;
                        EvtStrs.NoOfStrs = 1;
                        if (Client_e == WINS_E_RPLPUSH)
                        {
                                //EvtStrs.pStr[0] = TEXT("Replicator Push");
                                if (WinsCnf.LogDetailedEvts > 0)
                                {
                                  WinsEvtLogDetEvt(TRUE,
WINS_EVT_NO_RPL_RECS_RETRIEVED, NULL, __LINE__, "ddddd", pWinsAdd != NULL ? pWinsAdd->Add.IPAdd : 0, MinVersNo.LowPart, MinVersNo.HighPart, MaxVersNo.LowPart, MaxVersNo.HighPart);
                                //WINSEVT_LOG_INFO_STR_D_M( WINS_EVT_NO_RPL_RECS_RETRIEVED, &EvtStrs );
                               }
                        }
                        else
                        {
                                // Per bug#339152 remove this.
                                //EvtStrs.pStr[0] = (Client_e == WINS_E_NMSSCV) ?TEXT("Scavenging") : TEXT("Client");
                                //WINSEVT_LOG_INFO_STR_D_M( WINS_EVT_NO_RECS_RETRIEVED, &EvtStrs );
                        }

                }
                //
                // We are done. Let us commit the transaction
                //
                if (!fTransCommitted)
                {
                    CALL_M(
                        JetCommitTransaction(SesId, JET_bitCommitFlush)
                            );
                }
        }

        DBGLEAVE("NmsDbGetDataRecs\n");
        return(RetStat);
}


VOID
StoreGrpMems(
   IN  PWINSTHD_TLS_T       pTls,
   IN  WINS_CLIENT_E        Client_e,
   IN  LPBYTE               pName,
   IN  INT                  ThdPrLvl,
   IN  JET_SESID            SesId,
   IN  JET_TABLEID          TblId,
   IN  BOOL                 fStatic,
   IN  PRPL_REC_ENTRY_T     pRspInfo
        )

/*++

Routine Description:
        This function retrieves all the addresses in the group record
        and stores them in the data structure passed to it

Arguments:
        Client_e - Client (indicates the thread) calling this function
        ThdPrLvl - The normal priority level of thread (is looked at only
                   if the client is WINS_E_NMSSCV (scavenger thread)
        SesId    - Id of this thread's session with the db
        TblId    - Id of the name-address table
        fStatic  - indicates whether the entry is STATIC
        RspInfo  - Contains members of a special group (after this function
                    is done)

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        NmsDbGetDataRecs

Side Effects:

Comments:
        This function assumes that a heap has been created for use by this
        thread.  Currently, this function is called only by NmsDbGetDataRecs
--*/

{
        BOOL                        fIsMem;
        NMSDB_ROW_INFO_T        RowInfo;
        NMSDB_STAT_INFO_T        StatusInfo;
        DWORD                        i;        //for loop counter
        DWORD                        n = 0;        //indexes NodeAdd array
        PNMSDB_WINS_STATE_E        pWinsState_e;
        PCOMM_ADD_T                pWinsAdd;
        PVERS_NO_T              pStartVersNo;
        PWINS_UID_T             pUid;

        //
        // init to 0
        //
        RowInfo.NodeAdds.Mem[0].Add.Add.IPAdd = 0;
        RowInfo.pName = pName;

        //
        // Get and store the current time.
        //
        (void)time(&RowInfo.TimeStamp);

        //
        // get all active group members
        //
        GetGrpMem(
                SesId,
                TblId,
                &RowInfo,
                RowInfo.TimeStamp,
                &StatusInfo,
                fStatic,
                &fIsMem
                  );

        pRspInfo->NoOfAdds = StatusInfo.NodeAdds.NoOfMems;

        //
        // If we are in the scavenger thread, raise our priority level to
        // normal before entering the critical section.
        //
        if (Client_e == WINS_E_NMSSCV)
        {
                    WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        THREAD_PRIORITY_NORMAL
                                        );
        }

        if (pRspInfo->NoOfAdds > 0)
        {
           //
           // Allocate memory to store group members
           //
           pRspInfo->pNodeAdd = WinsMscHeapAlloc(
                               pTls->HeapHdl,
                               StatusInfo.NodeAdds.NoOfMems *
                                        sizeof(COMM_ADD_T) * 2
                               );
        }
        else
        {
           pRspInfo->pNodeAdd = NULL;
        }

        //
        // This critical section guards us against simultaenous updates
        // to the NmsDbOwnAddTbl (accessed by RPL_FIND_ADD_BY_OWNER_ID_M
        // macro) by the PULL thread
        //
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
try {
        //
        // Store the group members
        //
        for (i=0; i<StatusInfo.NodeAdds.NoOfMems; i++)
        {
                RPL_FIND_ADD_BY_OWNER_ID_M(
                                StatusInfo.NodeAdds.Mem[i].OwnerId,
                                pWinsAdd,
                                pWinsState_e,
                                pStartVersNo
                                          );
                //
                // First address is the address of the owner WINS
                // Second address is the address of the member
                //
                *(pRspInfo->pNodeAdd + n)   = *pWinsAdd;
                n++;
                *(pRspInfo->pNodeAdd + n)   = StatusInfo.NodeAdds.Mem[i].Add;
                n++;
        }
 }
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode =  GetExceptionCode();
        DBGPRINT1(EXC, "StoreGrpMems. Got Exception %x", ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_GRP_MEM_PROC_EXC);
        }

        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

        if (Client_e == WINS_E_NMSSCV)
        {
                //
                // revert to old priority level
                //
                    WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        ThdPrLvl
                                        );
        }

        return;
}


STATUS
CreateTbl(
        JET_DBID        DbId,
        JET_SESID        SesId,
        JET_TABLEID        *pTblId,
        NMSDB_TBL_NAM_E        TblNam_e //enumerator value for table to create
        )

/*++

Routine Description:
        This function creates a table.

Arguments:
        DbId    - Database Id.
        SesId   - Session Id.
        pTblId  - Id of the table created
        TblNm_e - Identifies the table to create


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
        None
--*/

{
#define LANGID                 0x0409
#define CP                1252

        BYTE                 TmpCol[MAX_FIXED_FLD_LEN];
        DWORD                FldNo;        /*counter for fields        */
        JET_TABLEID        TblId;  /*id of table created*/
        JET_COLUMNDEF        columndef;

        //
        // Init fields of columndef that do not change between additions of
        // columns
        //
        columndef.cbStruct  = sizeof(columndef);
        columndef.columnid  = 0;
        columndef.cp            = CP;
        columndef.langid    = LANGID;
        columndef.cbMax     = 0;
        columndef.grbit     = 0;

        /*
         Switch on Table Name
        */
        switch(TblNam_e)
        {

            /*
                The Name to Address Mapping table needs to be created
            */
            case(NMSDB_E_NAM_ADD_TBL_NM):

                  /*
                        Create the Nam IP address mapping table
                  */
                  CALL_M( JetCreateTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_TBL_PGS,
                                NMSDB_NAM_ADD_TBL_DENSITY,
                                &TblId
                                        )
                        );

NOTE("DDL such as AddColumn and CreateIndex on a table in shared access mode")
NOTE("will return an error unless we are at transaction level 0 (i.e no Begin")
NOTE("transaction).  If done on a table in exclusive mode, it is ok -- Ian ")
NOTE("10/16/93")
                 //
                 // In order to open the table with shared access, we need
                 // to close the handle returned from CreateTable (this
                 // one has deny read access flag set) and open the
                 // table for shared access
                 //
                 CALL_M(JetCloseTable(
                                SesId,
                                TblId
                                    )
                       );

                CALL_M(JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_NAM_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &TblId
                                        )
                     );

                  *pTblId = TblId;

                  /*
                        Add columns
                  */
                  for ( FldNo=0 ; FldNo < NO_COLS_NAM_ADD_TBL ; ++FldNo )
                  {

                    columndef.coltyp    = sNamAddTblRow[FldNo].FldTyp;
                    CALL_M( JetAddColumn (
                        SesId,                 // user
                        TblId,                 // table id
                        sNamAddTblRow[FldNo].pName,         // fld name
                        &columndef,                         // columndef
                        NULL,                                    // default value
                        0,                                 // default value length
                        &sNamAddTblRow[FldNo].Fid         // field id
                                        )
                          );
                  }


                  /*
                *   Create clustered index (in ascending order) on the name field.
                *
                *   In NT5.0 (Jet600), we do not create the cluster key.  The
                *   primary index is the one on which Jet clusters.  The primary
                *   key should be smaller, because in Jet600 Jet uses primary key
                *   bookmarks, meaning that the bookmark length will be entirely
                *   dependent on the length of the primary key.Jonathan Liem (1/7/97)
                *
                *   Rule for creating index:
                *
                *   The index key contains a sequence of concatenated
                *   column names, in order of key significance, each
                *   of which is null terminated and prefixed with either
                 *   '+' or '-', indicating ascending or descending.  The
                *   entire sequence must be double null terminated.
                *
               */

                sprintf( TmpCol, "+%s",
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].pName );

                TmpCol[ 2 +
                 strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName )
                      ] = '\0';

                if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                    CALL_M(
                            JetCreateIndex(
                              SesId,
                              TblId,
                              NMSDB_NAM_ADD_CLUST_INDEX_NAME,  // name of index
                              JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull,
                              TmpCol,
                              3 +
                               strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName),
                              NMSDB_NAM_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                page to  be used*/
                                          )
                           );
                } else {
                    CALL_M(
                            JetCreateIndex(
                              SesId,
                              TblId,
                              NMSDB_NAM_ADD_CLUST_INDEX_NAME,  // name of index
                              JET_bitIndexClustered | JET_bitIndexUnique | JET_bitIndexDisallowNull,
                              TmpCol,
                              3 +
                               strlen( sNamAddTblRow[NAM_ADD_NAME_INDEX].pName),
                              NMSDB_NAM_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                page to  be used*/
                                          )
                           );

                }

CHECK("What exactly does DENSITY argument do for us")

               /*
                 * Create Primary Index using the ownerid and the version cols
               */
               sprintf( TmpCol, "+%s",
                        sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName
                       );

               sprintf(
               &TmpCol[2 + strlen(sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName)],
                          "+%s", sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName
                       );

               TmpCol[ 4 +
                         strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName ) +
                         strlen(sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName)
                       ] = '\0';


               if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                   CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_NAM_ADD_PRIM_INDEX_NAME,  // name of index
                            JET_bitIndexUnique, //in jet600 dont need primary index.
                            TmpCol,
                            5 +
                             strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName) +
                             strlen( sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName),

                            NMSDB_NAM_ADD_PRIM_INDEX_DENSITY /*% space on each
                                                               page to  be used*/
                                        )
                          );

               } else {
                   CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_NAM_ADD_PRIM_INDEX_NAME,  // name of index
                            JET_bitIndexPrimary, //primary index is unique by def.
                            TmpCol,
                            5 +
                             strlen( sNamAddTblRow[NAM_ADD_OWNERID_INDEX].pName) +
                             strlen( sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].pName),

                            NMSDB_NAM_ADD_PRIM_INDEX_DENSITY /*% space on each
                                                               page to  be used*/
                                        )
                          );


               }

               break;


          case(NMSDB_E_OWN_ADD_TBL_NM):

                  /*
                        Create the Owner address mapping table
                  */

                  CALL_M( JetCreateTable(
                        SesId,
                        DbId,
                        NMSDB_OWN_ADD_TBL_NM,
                        NMSDB_OWN_ADD_TBL_PGS,
                        NMSDB_OWN_ADD_TBL_DENSITY,
                        &TblId
                                        )
                        );

                 //
                 // In order to open the table with shared access, we need
                 // to close the handle returned from CreateTable (this
                 // one has deny read access flag set) and open the
                 // table for shared access
                 //
                 CALL_M(JetCloseTable(
                                SesId,
                                TblId
                                    )
                       );

                CALL_M(JetOpenTable(
                                SesId,
                                DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access (no bit set)
                                &TblId
                                        )
                        );
                  *pTblId = TblId;

                  /*
                        Add columns
                  */
                  for ( FldNo=0 ; FldNo < NO_COLS_OWN_ADD_TBL ; ++FldNo )
                  {
                    JET_COLUMNDEF        columndef;

                    columndef.cbStruct  = sizeof(columndef);
                    columndef.columnid  = 0;
                    columndef.coltyp    = sOwnAddTblRow[FldNo].FldTyp;
                    columndef.cp        = 1252;
                    columndef.langid        = 0x0409;
                    columndef.cbMax     = 0;
                    columndef.grbit     = 0;

                    CALL_M( JetAddColumn(
                        SesId,                         // user
                        TblId,                 // table id
                        sOwnAddTblRow[FldNo].pName,         // fld name
                        &columndef,                         // columndef
                        NULL,                                    // default value
                        0,                                 // default value lenght
                        &sOwnAddTblRow[FldNo].Fid    // field id.
                                        )
                          );
                  } //end of for loop


                /*


                Insertions into this table will be in the order of increasing
                owner ids. with the owner id. 0 always referring to the local
                WINS.

                The state of an entry in the table can be active or down or
                deleted.

                As an aside (this comment is out of context here, but anyway..)

                deleted entries are removed at boot time. Also, all records
                owned by the WINS of a deleted entry are removed from the
                Name Address table at boot time.i This functionality is a
                future enhancement

                */

               /*
                *   Create clustered index
               */
                sprintf( TmpCol, "+%s",
                        sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName
                       );

                TmpCol[ 2 +
                  strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName )] = '\0';

                if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
                    CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_OWN_ADD_CLUST_INDEX_NAME,  // name of index
                            JET_bitIndexPrimary | JET_bitIndexUnique,
                            TmpCol,
                            3 +
                             strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName),
                            NMSDB_OWN_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                 page to alloc
                                                              */
                                        )
                         );
                } else{
                    CALL_M( JetCreateIndex(
                            SesId,
                            TblId,
                            NMSDB_OWN_ADD_CLUST_INDEX_NAME,  // name of index
                            JET_bitIndexClustered | JET_bitIndexUnique,
                            TmpCol,
                            3 +
                             strlen( sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].pName),
                            NMSDB_OWN_ADD_CLUST_INDEX_DENSITY /*% space on each
                                                                 page to alloc
                                                              */
                                        )
                         );
                }

CHECK("Do we need to set this")
                /*
                *  Set the clustered index as the current index
                */
                       CALL_M(
                        JetSetCurrentIndex( SesId,
                                            TblId,
                                            NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                          )
                      );

                break;
          default:
                        DBGPRINT1(ERR, "CreateTbl: Invalid Tbl id (%d)\n",
                                TblNam_e);
                        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                        return(WINS_FAILURE);
                        break;
        } //end of switch

        return(WINS_SUCCESS);
}

STATUS
InitColInfo (
        JET_SESID        SesId,
        JET_TABLEID        TblId,
        NMSDB_TBL_NAM_E        TblNam_e
        )

/*++

Routine Description:

        This function is called to get information about the different
        columns of a table

Arguments:
        SesId    - Session Id
        TblId    - Id. of open table
        TblNam_e - Indicator or table


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit (Main Thread of the process)

Side Effects:

Comments:
        None
--*/
{
        JET_COLUMNDEF        ColumnDef;
        PFLD_T                pRow     = NULL;
        DWORD                FldNo    = 0;
        DWORD                NoOfCols = 0;
        STATUS RetStat = WINS_SUCCESS;

        /*
         Switch on Table Name
        */
        switch(TblNam_e)
        {

            /*
                The Name to Address Mapping table needs to be created
            */
            case(NMSDB_E_NAM_ADD_TBL_NM):

                   pRow     = sNamAddTblRow;
                   NoOfCols = NO_COLS_NAM_ADD_TBL;
                   break;

            case(NMSDB_E_OWN_ADD_TBL_NM):

                   pRow     = sOwnAddTblRow;
                   NoOfCols = NO_COLS_OWN_ADD_TBL;
                   break;

            default:

                DBGPRINT1(ERR, "InitColInfo: Invalid Tbl id (%d)\n",
                                TblNam_e);
                WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                RetStat = WINS_FATAL_ERR;

                break;
        }



        /*
          Get info about columns
        */
       for ( FldNo=0 ; FldNo < NoOfCols; ++FldNo )
       {

            CALL_M( JetGetTableColumnInfo (
                        SesId,                         // user session
                        TblId,                         // table id
                        pRow[FldNo].pName,         // fld name
                        &ColumnDef,                 // columndef
                        sizeof(ColumnDef),
                        JET_ColInfo                //info level 0
                                     )
                  );


            pRow[FldNo].Fid = ColumnDef.columnid; // field id
       }

       return(RetStat);
}


STATUS
ReadOwnAddTbl(
        JET_SESID          SesId,
        JET_DBID          DbId,
        JET_TABLEID     TblId
        )

/*++

Routine Description:

        This function is called to read all the entries of the Owner - Address
        mapping table into the in-memory data structure

        It is called at init time

Arguments:
        SesId
        DbId
        TblId

Externals Used:
        NmsDbOwnAddTbl

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsDbInit()

Side Effects:

Comments:
        No need to start a transaction in this since it is called only
        by NmsDbInit (at initialization time)
--*/
{


        PNMSDB_ADD_STATE_T        pOwnAddTbl = NULL;
        DWORD                     i, n;
        LONG                      ActFldLen;
        DWORD                     cOwners    = 0;
        JET_ERR                   JetRetStat;
#if NEW_OWID
        DWORD                      OwnerId;
#else
        DWORD                      OwnerId = 0;
#endif

        DWORD                      LastOwnerId = 0;
        BOOL                      fLogged = FALSE;
        STATUS                    RetStat = WINS_SUCCESS;

        DBGENTER("ReadOwnAddTbl\n");


        pOwnAddTbl = pNmsDbOwnAddTbl;

        /*
        * Setting the index will move the database cursor to the first record
        *in the table.
        */
        CALL_M(
                JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                  )
              );

        /*
        * Loop until the end of the table is reached. We are retrieving
        * records in the order of increasing owner ids.
        */
        do
        {

             //
             // retrieve the OwnerId column
             //
             JetRetStat =
                   JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].Fid,
                        &OwnerId,
                        OWN_ADD_OWNERID_SIZE,
                        &ActFldLen,
                        0,
                        NULL
                                 );


              if (JetRetStat == JET_errNoCurrentRecord)
              {
                  //
                  // If this is not the first iteration of the loop, then
                  // there is something seriously wrong.  Log an error and
                  // raise exception
                  //
                  if (NmsDbNoOfOwners != 0)
                  {
                        DBGPRINT0(EXC,
                          "There is no current record to retrieve from\n");
                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                  }
                  else
                  {
                        DBGPRINT0(ERR,
                           "ReadOwnAddTbl: There are no records in this table.");
                        WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_NO_RECS_IN_OWN_ADD_TBL);
                  }

                  break;   //break out of the loop
              }
              else
              {
                CALL_M(JetRetStat);
              }

              // the (OwnerId<->Addr) table is not large enough to contain a slot at index OwnerId.
              // the table has to be enlarged in order to cover this index.
              if (NmsDbTotNoOfSlots <= OwnerId)
              {
                  DWORD newNoOfSlots = max(NmsDbTotNoOfSlots*2, OwnerId+1);

                  WINSMSC_REALLOC_M(
                      sizeof(NMSDB_ADD_STATE_T) * newNoOfSlots,
                      &pOwnAddTbl);

                  pNmsDbOwnAddTbl = pOwnAddTbl;
                  NmsDbTotNoOfSlots = newNoOfSlots;

                  // Enlarge the (OwnerId<->VersNo) table if it is not at least as large as (OwnerId<->Addr) table.
                  if (RplPullMaxNoOfWins < NmsDbTotNoOfSlots)
                  {
                      RplPullAllocVersNoArray(&pRplPullOwnerVersNo, NmsDbTotNoOfSlots);
                      RplPullMaxNoOfWins = NmsDbTotNoOfSlots;
                  }

                  DBGPRINT2(
                      DET,
                      "ReadOwnAddTbl: Table sizes updated: (OwnerId<->Addr)[%d]; (OwnerId<->VersNo)[%d]\n",
                      NmsDbTotNoOfSlots,
                      RplPullMaxNoOfWins);
              }

              //
              // If this is the first wins server's owner id then this has
              // to be zero.
              //
              if (cOwners == 0)
              {
                  ASSERT(OwnerId == 0);
                  if (OwnerId > 0)
                  {
                       DBGPRINT1(ERR, "Database error.  The first owner in the owner-add table has owner id of  (%d)\n",  OwnerId);

                        WINSEVT_LOG_M(
                              WINS_FAILURE,
                              WINS_EVT_DB_INCONSISTENT
                             );

                       WINS_RAISE_EXC_M(WINS_EXC_DB_INCONSISTENT);

                  }
              }
              else
              {
                  //
                  // Mark all entries in NmsDbOwnerAddTbl for which we did
                  // not find an owner id as deleted.
                  //
                  for (i = LastOwnerId + 1; i < OwnerId; i++)
                  {
                       (pNmsDbOwnAddTbl + i)->WinsState_e = NMSDB_E_WINS_DELETED;
                  }
              }

              // retrieve the address column
             JetRetStat =
                   JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->WinsAdd),
                        sizeof(COMM_ADD_T),
                        &ActFldLen,
                        0,
                        NULL
                                 );

              DBGPRINT2(INIT, "ReadOwnAddTable: Owner Id (%d) - Address (%x)\n",
                        OwnerId, (pNmsDbOwnAddTbl + OwnerId)->WinsAdd.Add.IPAdd);

              // retrieve the state column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->WinsState_e),
                        sizeof(BYTE),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

              // retrieve the version number column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->StartVersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

              // retrieve the Uid  column
              CALL_M(
                JetRetrieveColumn(
                        SesId,
                        TblId,
                        sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                        &((pNmsDbOwnAddTbl + OwnerId)->Uid),
                        sizeof(WINS_UID_T),
                        &ActFldLen,
                        0,
                        NULL
                                 )
                    );

//                pOwnAddTbl++; //increment ptr to point to next array element
                LastOwnerId = OwnerId;
                cOwners++;

        }  while(
                JetMove(
                        SesId,
                        TblId,
                        JET_MoveNext,
                        0 //grbit - use default (i.e. we want next record
                       ) >= 0
             );

        //
        // Compare the count of owners found in the Owner-Address mapping
        // table with the count we determined from the Name-Address mapping
        // table (see GetMaxVersNos()).  If the count is less
        // the database is in an inconsistent state.  This can
        // mean any of the following:
        //
        //  1) WINS crashed in the middle of replication and recovery was not
        //     done properly prior to this invocation
        //
        //  2) The database got trashed due to some other external factors.
        //
        // This error condition is serious enough to warrant an exception.
        // This should terminate WINS.
        //
        // The  count can be more but not less.  This is because when a
        // WINS comes up, it registers itself in the Owner-Address mapping
        // table.  So it is possible that it might have gone down before
        // registering anything.  Also, it is possible for all records owned
        // by a WINS server to be deleted.
        //
        if (cOwners < NmsDbNoOfOwners)
        {
                DBGPRINT2(ERR, "Database is inconsistent.  The number of owners in the nam-add table (%d) is >  in the own-add table (%d)\n",
                        NmsDbNoOfOwners,
                        cOwners);

                WINSEVT_LOG_M(
                              WINS_FAILURE,
                              WINS_EVT_DB_INCONSISTENT
                             );

                WINS_RAISE_EXC_M(WINS_EXC_DB_INCONSISTENT);
        }

        //
        // Set the global equal to the number of owner records found in
        // the owner-address table. If the global is < Cowners it means that
        // the records owned by one or more WINS servers whose addresses were
        // found in the owner - address mapping table have expired  in our
        // name - address mapping table.
        //
#if 0
FUTURES("Do not include the WINS server that have a non-active state in the")
FUTURES("cOwners count")
        NmsDbNoOfOwners = cOwners;
#endif
        //
        // Set the global to 1 more than the highest owner id found. This
        // is done because we use this global to go over all entries in
        // the NmsDbOwnAddTbl table (at several places - for example,
        // RplFindOwnerId)
        //
        NmsDbNoOfOwners = OwnerId + 1;

        //
        // Do a sanity check.  Make sure that there is no owner id with address
        // same as ours.  If there is such an owner id, mark the state as
        // deleted.
        //
        // If the db at WINS A is used at WINS B and WINS A was and is a
        // a partner of WINS B, we will have this situation.  WINS B will
        // see its records that got replicated to WINS A in the table at
        // a non-zero (i.e. non-local partner) index.  The 0th index is
        // always claimed by the local WINS (WINS B in this example), so
        // we can not have another index with the same address.  Having it
        // will cause clutter and also some unnecessary overhead at replication
        // where a partner that gets the mappings can ask for version numbers
        // that don't exist (if highest version number of records at the
        // non-zero index is > that at 0 index). Admitted that eventually,
        // the prior stated situation will no longer exist since the max.
        // version number at index 0 will become > that at the non-zero index.
        //
        DBGPRINT0(DET, "ReadOwnAddTbl: Do a sanity check on the list of owners\n");
        for (i = 1; i < NmsDbNoOfOwners; i++)
        {
                //
                // If address is same as ours and state is ACTIVE, mark it
                // deleted and get rid of all the database records.
                //
                if (
                        (WINSMSC_COMPARE_MEMORY_M(&(pNmsDbOwnAddTbl+i)->WinsAdd,
                            &NmsLocalAdd, sizeof(COMM_ADD_T))
                                   == sizeof(COMM_ADD_T))
                                        &&
                        ((pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                   )

                {

                      //
                      // Tell the sc. to wait since ObliterateWins can take
                      // a long time.
                      //
                      ENmsWinsUpdateStatus(MSECS_WAIT_WHEN_DEL_WINS);
                      RetStat = ObliterateWins(i, &(pNmsDbOwnAddTbl+i)->WinsAdd);

                }
        }

        //
        // Check for other duplicates
        //
        for (i = 1; i < NmsDbNoOfOwners; i++)
        {
           DWORD OwnerIdToDel;
           for (n = i + 1; n < NmsDbNoOfOwners; n++)
           {
                if ((WINSMSC_COMPARE_MEMORY_M(&(pNmsDbOwnAddTbl+i)->WinsAdd,
                            &(pNmsDbOwnAddTbl+n)->WinsAdd, sizeof(COMM_ADD_T))
                                   == sizeof(COMM_ADD_T))
                                        &&
                        ((pNmsDbOwnAddTbl+i)->WinsState_e ==
                              (pNmsDbOwnAddTbl+n)->WinsState_e)
                    )
                {
                    if ( (pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                    {
                          if (!fLogged)
                          {
                                WINSEVT_LOG_M(WINS_FAILURE,
                                       WINS_EVT_DUP_ENTRY_IN_DB);
                                fLogged = TRUE;

                          }
                          OwnerIdToDel =
                            LiLeq((pRplPullOwnerVersNo+i)->VersNo,
                                    (pRplPullOwnerVersNo+n)->VersNo)  ? i : n;

                          ENmsWinsUpdateStatus(MSECS_WAIT_WHEN_DEL_WINS);
                          RetStat = ObliterateWins(OwnerIdToDel,
                                        &(pNmsDbOwnAddTbl+OwnerIdToDel)->WinsAdd);
                    }
                }
           }
        }
        DBGPRINT1(DET, "ReadOwnAddTbl. No of owners found = (%d)\n", NmsDbNoOfOwners);
        return(RetStat);
}

STATUS
ObliterateWins(
       DWORD        OwnerToDel,
       PCOMM_ADD_T  pWinsAdd
      )

/*++

Routine Description:
     This function gets rid of all information pertaining to a WINS.

Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	This function assumes that it is being called at init time. So, when
    calling NmsDbDelDataRecs, it does not request the same to enter a
    critical section
--*/

{
          VERS_NO_T        MinVersNo;
          VERS_NO_T        MaxVersNo;
          WINS_ASSIGN_INT_TO_LI_M(MinVersNo, 0);

          DBGENTER("ObliterateWins\n");
          //
          // Set MaxVersNo to 0 also so that all records get
          // deleted
          //
          MaxVersNo = MinVersNo;

          WinsEvtLogDetEvt(TRUE, WINS_EVT_DUP_ENTRY_DEL, NULL, __LINE__, "ds", OwnerToDel, pWinsAdd->Add.IPAdd);

          (pNmsDbOwnAddTbl+OwnerToDel)->WinsState_e = NMSDB_E_WINS_DELETED;
          NmsDbWriteOwnAddTbl(
                             NMSDB_E_DELETE_REC,
                             OwnerToDel,
                             NULL,
                             NMSDB_E_WINS_DELETED,
                             NULL, NULL
                             );
          //
          // delete all the records in the database.
          //
          if (NmsDbDelDataRecs( OwnerToDel, MinVersNo, MaxVersNo, FALSE, FALSE) != WINS_SUCCESS)          {
               return(WINS_FAILURE);
          }


          WINS_ASSIGN_INT_TO_VERS_NO_M((pRplPullOwnerVersNo+OwnerToDel)->VersNo, 0);
          WINS_ASSIGN_INT_TO_VERS_NO_M((pRplPullOwnerVersNo+OwnerToDel)->StartVersNo, 0);
          //(pRplPullOwnerVersNo+OwnerToDel)->OldUid = 0;

          WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_WINS_ENTRY_DELETED);

          DBGLEAVE("ObliterateWins\n");
          return(WINS_SUCCESS);
}

STATUS
NmsDbWriteOwnAddTbl (
        IN NMSDB_TBL_ACTION_E         TblAct_e,
        IN DWORD                          OwnerId,
        IN PCOMM_ADD_T                  pWinsAdd,
        IN NMSDB_WINS_STATE_E        WinsState_e,
        IN PVERS_NO_T           pStartVersNo,
        IN PWINS_UID_T          pUid
        )

/*++

Routine Description:

        This function is called to insert or modify a record in the
        owner id to address mapping table

Arguments:
        TblAct_e - the action to perform (Insert, delete, modify)
        OwnerId  - id of owner
        pWinsAdd - Address of owner (can be NULL when action is to delete)
        WinsState_e - State of record in the table
        pStartVersNo - version number this WINS started from

Externals Used:
        NmsDbNoOfOwners

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        InitOwnAddTbl() in commapi.c, RplFindOwnerId

Side Effects:

Comments:
        None
--*/
{

        JET_ERR         JetRetStat;
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        STATUS          RetStat = WINS_SUCCESS;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        DBGPRINT2(FLOW, "ENTER: WriteOwnAddTbl. Action = (%d) for Owner id = (%d)\n", TblAct_e, OwnerId);

        TblId  = pTls->OwnAddTblId;
        SesId  = pTls->SesId;

        switch(TblAct_e)
        {
                case(NMSDB_E_INSERT_REC):

                        CALL_M(JetBeginTransaction(SesId));
                try {
                          CALL_M(JetPrepareUpdate(
                                                 SesId,
                                                 TblId,
                                                 JET_prepInsert
                                                 )
                              );


                        // add first column (ownerid field)
                        CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_OWNERID_INDEX].Fid,
                                      &OwnerId,
                                      OWN_ADD_OWNERID_SIZE,
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add 2nd column (this is the address field)
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                                      pWinsAdd,
                                      sizeof(COMM_ADD_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );


                            // add the 3rd column (this is the state byte
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                                      &WinsState_e,
                                      sizeof(BYTE),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add the 4th column (this is the Vers. No
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                                      pStartVersNo,
                                      sizeof(VERS_NO_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            // add the 5th column (this is the Uid)
                            CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                                      pUid,
                                      sizeof(WINS_UID_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                        CALL_M( JetUpdate (
                                                SesId,
                                                TblId,
                                                NULL,
                                                0,
                                                NULL
                                              ));
                }
                finally        {
                        if (AbnormalTermination())
                        {
                                DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not insert record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                CALL_M(JetRollback(SesId, JET_bitRollbackAll));
                                RetStat = WINS_FAILURE;
                        }
                        else
                        {
                                NmsDbNoOfOwners++;
                                CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
                        }
                  }
                        break;


                //
                // This case will be executed as a result of
                // administrative actions or when the database (owner-address
                // mapping table) shows that it was used earlier by a WINS
                // at a different address (see ReadOwnAddTbl())
                //
                case(NMSDB_E_MODIFY_REC):
                        CALL_M( JetMakeKey(
                                        SesId,
                                        TblId,
                                        &OwnerId,
                                        OWN_ADD_OWNERID_SIZE,
                                        JET_bitNewKey
                                          )
                                      );

                         if ( JetSeek(
                                        SesId,
                                        TblId,
                                        JET_bitSeekEQ
                                         ) ==  JET_errSuccess
                                )
                        {

                           CALL_M(JetBeginTransaction(SesId));

                         try {
                             JetRetStat = JetPrepareUpdate(
                                                 SesId,
                                                 TblId,
                                                 JET_prepReplace
                                                 );
                           if (
                                  (JetRetStat != JET_errSuccess)
                                                &&
                                  (JetRetStat != JET_wrnNoWriteLock)
                              )
                           {
                                RET_M(JetRetStat);
                           }

                                // add 2nd column (this is the address field)
                                CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_ADDRESS_INDEX].Fid,
                                      pWinsAdd,
                                      sizeof(COMM_ADD_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );


                                // add the 3rd column (this is the state byte
                                CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_STATE_INDEX].Fid,
                                      &WinsState_e,
                                      sizeof(BYTE),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                               // add the 4th column (this is the Vers. No
                              CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_VERSIONNO_INDEX].Fid,
                                      pStartVersNo,
                                      sizeof(VERS_NO_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                              // add the 5th column (this is the Uid)
                              CALL_M( JetSetColumn(
                                      SesId,
                                      TblId,
                                      sOwnAddTblRow[OWN_ADD_UID_INDEX].Fid,
                                      pUid,
                                      sizeof(WINS_UID_T),
                                      0,
                                      NULL /*optional info */
                                            )
                              );

                            CALL_M( JetUpdate (
                                                SesId,
                                                TblId,
                                                NULL,
                                                0,
                                                NULL
                                              ));

                            }
                         finally {
                                if (AbnormalTermination())
                                {
                                    DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not modify record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                    CALL_M(JetRollback(SesId,
                                                JET_bitRollbackAll));
                                    RetStat = WINS_FAILURE;
                                }
                                else
                                {
                                        CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));

                                }
                              }
                        }
                        else  //did not find record
                        {
                                DBGPRINT0(EXC, "NmsDbOwnAddTbl: Weird: Could not seek to a record is to be modified\n");
                                WINSEVT_LOG_M(
                                      WINS_FAILURE,
                                      WINS_EVT_SFT_ERR
                                     );
                                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);

                        }
                        break;

                case(NMSDB_E_DELETE_REC):
                        CALL_M( JetMakeKey(
                                        SesId,
                                        TblId,
                                        &OwnerId,
                                        OWN_ADD_OWNERID_SIZE,
                                        JET_bitNewKey
                                          )
                                      );

                         if ( JetSeek(
                                        SesId,
                                        TblId,
                                        JET_bitSeekEQ
                                         ) ==  JET_errSuccess
                                )
                        {
                          try {
                           CALL_M(JetBeginTransaction(SesId));
                           CALL_M(JetDelete(SesId, TblId));
                           DBGPRINT1(SCV, "WriteOwnAddTbl: Deleted owner id = (%d) from table\n", OwnerId);
                             }
                        finally {
                                if (AbnormalTermination())
                                {
                                    DBGPRINT0(ERR,
                                        "NmsDbWriteOwnAddTbl: Could not delete record in  Owner to Address Mapping Tbl\n");
                                WINSEVT_LOG_M(
                                                WINS_FAILURE,
                                                WINS_EVT_CONFLICT_OWN_ADD_TBL
                                             );
                                    CALL_M(JetRollback(SesId,
                                                JET_bitRollbackAll));
                                    RetStat = WINS_FAILURE;
                                }
                                else
                                {
                                        //
                                        // NOTE: Do not decrement
                                        // NmsDbNoOfOwners since that indicates
                                        // the number of WINS owners in the
                                        // in-memory table (in all states)
                                        //
                                        CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));

                                }
                              } // end of finally
                        }
                        else  //did not find record
                        {
                                DBGPRINT0(EXC, "NmsDbOwnAddTbl: Weird: Could not seek to a record  to be deleted \n");
                                WINS_RAISE_EXC_M(WINS_EXC_FATAL_ERR);
                        }

                        break;

                default:
                   DBGPRINT1(ERR, "Invalid Action Code - (%d)\n", TblAct_e);
                   WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                   RetStat = WINS_FAILURE;
                   break;

        }

        DBGLEAVE("WriteOwnAddTbl\n");
        return(RetStat);
}

VOID
NmsDbThdInit(
        WINS_CLIENT_E        Client_e
            )

/*++

Routine Description:
        This function is called by each thread that wishes to init with
        the database.

Arguments:
        Client_e - indicates which thread it is

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        The init functions of the various threads

Side Effects:

Comments:
        This function is not to be called by the manin thread of the process
        That thread calls the NmsDbInit function.
--*/

{
        PWINSTHD_TLS_T        pTls        = NULL;
        DWORD                Error   = 0;
        BOOL                fRetVal = TRUE;

        WinsMscAlloc(sizeof(WINSTHD_TLS_T),  &pTls);
#ifdef WINSDBG
        pTls->Client_e = Client_e;
#endif

        //
        // Start a session.
        //
FUTURES("When security story regarding JET is complete, we might want to")
FUTURES("change the following. Until then, this should do")
        CALL_N_RAISE_EXC_IF_ERR_M( JetBeginSession(
                        sJetInstance,
                        &pTls->SesId,
                        NAMUSR,
                        PASSWD
                                )
              );

        //
        // Open the database
        //
        CALL_N_RAISE_EXC_IF_ERR_M( JetOpenDatabase(
                        pTls->SesId,
                        //NmsDbDatabaseFileName,
                        WinsCnf.pWinsDb,
                        NULL,                   /*the default engine*/
                        &pTls->DbId,
                        0   //shared access
                               )
               );

        /*
         * Let us set the TLS storage
         */
        fRetVal = TlsSetValue(WinsTlsIndex, pTls);

        if (!fRetVal)
        {
                Error   = GetLastError();
                WINSEVT_LOG_M(Error, WINS_EVT_CANT_INIT_W_DB);
                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
        }
        else
        {
                //
                // RPC threads come and go.  Since the count NmsTotalTermThdCnt
                // represents the number of threads that need to be terminated
                // at process termination time we include only those threads
                // that we are guaranteed to have in the process (with active
                // db sessions).
                //
                // Also, the main thread is always accounted for in the
                // NmsTotalTrmThdCnt counter.
                //
                if ((Client_e != WINS_E_WINSRPC) && (Client_e != WINS_E_NMS))
                {
                   //
                   // Increment the count of threads that have initialized
                   // with the db engine.  This count will be used by the
                   // main thread to determine the number of threads that
                   // must wait for prior to terminating the process.
                   //
                   EnterCriticalSection(&NmsTermCrtSec);
                   NmsTotalTrmThdCnt++;
                   LeaveCriticalSection(&NmsTermCrtSec);
                }
        }
        return;
}


JET_ERR
UpdateDb (
   JET_SESID             SesId,
   JET_TABLEID             TblId,
   PNMSDB_ROW_INFO_T pRowInfo,
   ULONG             TypOfUpd
       )

/*++

Routine Description:
        This function is called to insert a record in the name - address
        mapping table of the database

Arguments:
        SesId    - Session Id
        TblId    - Table Id
        pRowInfo - Row to insert
        TypOfUp  - Type of Update (insertion or replacement)

Externals Used:
        None


Return Value:

   Success status codes -- JET_ErrSuccess
   Error status codes   -- Jet error status codes

Error Handling:

Called by:
        NmsDbInsertRowInd,
        NmsDbUpdateRow
Side Effects:

Comments:
        None
--*/

{

        DWORD                      EntryFlag = 0;
        JET_ERR                    JetRetStat;
        //JET_SETINFO                SetInfo;
#ifdef WINSDBG
        BOOL                      fUpd = FALSE;
#endif

        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat =  JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 TypOfUpd
                                );

        //
        // Starting from rel118.0, JetPrepareUpdate can return
        // JET_wrnNoWriteLock when called to replace a record at
        // transaction level 0.  We should just ignore it
        //
        if  (JetRetStat != JET_errSuccess)
        {
                if (
                        !((JetRetStat == JET_wrnNoWriteLock)
                                &&
                        (TypOfUpd == JET_prepReplace))
                   )
                {
                     RET_M(JetRetStat);
                }
        }

        // add first column (clustered index)
        if (TypOfUpd != JET_prepReplace)
        {
             JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                0,
                                NULL /*optional info */
                                )
                    );
        }


PERF("Make check for unique record first. Also, remove the shifting")
PERF("NodeType field for spec. grp.  When we start doing this")
PERF("do not set NodeType to 0 in NmsNmhReplGrpMem in nmsnmh.c")
        if (
                NMSDB_ENTRY_SPEC_GRP_M(pRowInfo->EntTyp)
                                ||
                NMSDB_ENTRY_MULTIHOMED_M(pRowInfo->EntTyp)
           )
        {
                 EntryFlag  = pRowInfo->EntTyp
                                        |
                             (pRowInfo->NodeTyp << NMSDB_SHIFT_NODE_TYP)
                                        |
                              (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                        |
                              (pRowInfo->fLocal ? NMSDB_BIT_LOCAL : 0)
                                        |
                              (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);

                 JETRET_M( InsertGrpMemsInCol(
                                        SesId,
                                        TblId,
                                        pRowInfo,
                                        TypOfUpd
                                            )
                         );
        }
        else   // it is a unique entry or a normal group entry
        {
                 if (NMSDB_ENTRY_NORM_GRP_M(pRowInfo->EntTyp))
                 {
                         EntryFlag  = pRowInfo->EntTyp
                                        |
                                     (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                        |
                                 (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);
                 }
                 else  // it is a Unique entry
                 {
                    EntryFlag   =
                         pRowInfo->EntTyp
                                |
                         (pRowInfo->NodeTyp << NMSDB_SHIFT_NODE_TYP)
                                |
                         (pRowInfo->fLocal ? NMSDB_BIT_LOCAL : 0)
                                |
                         (pRowInfo->fStatic << NMSDB_SHIFT_STATIC)
                                |
                         (pRowInfo->EntryState_e << NMSDB_SHIFT_STATE);

                 }
FUTURES("If in the future, we support more than one address for a unique name")
FUTURES("we will check pRowInfo for the number of addresses (another field)")
FUTURES("and then specify the right size to JetSetColumn below")

                //
                // add second column (IP address)
                //
                // Note: Even though for Normal groups there is no need to
                // set the address, we do it anyway.  This is to save
                // an if test which wlll slow down the registrations (inside
                // a critical section) of unique entries (form the bulk
                // of registration traffic).
                //
FUTURES("Don't distinguish between unique and group entries. Store Time stamp")
FUTURES("and owner id along with address in case of unique entry.  This will")
FUTURES("help get rid of some code from this function")

//                JetRetStat =  JetSetColumn(
                   JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                pRowInfo->pNodeAdd,
                                sizeof(COMM_ADD_T),
                                //Grbit,
                                0,
                                //pSetInfo
                                NULL /*optional info */
                                )
                         );

        }

        // add third column (this is the flag byte        */
        JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &EntryFlag,
                                sizeof(EntryFlag),
                                0,
                                NULL /*optional info */
                                )
                              );


        //
        // If the version number is not to be incremented, there is no
        // need to increment the owner id.  It must remain the same.
        //
        if (pRowInfo->fUpdVersNo)
        {
             // add 4th column (this is the owner byte        */
             JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &pRowInfo->OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                )
              );


                // add 5th column (this is the version number long(DWORD)
                JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

#ifdef WINSDBG
                fUpd = TRUE;
#endif
        }

        //
        // When the conflict is between two internet group entries,
        // (replica -- Tombstone, database entry -- Active), we do
        // not update the timestamp (Check out -- ClashAtReplGrpMems
        // in nmsnmh.c to get a better insight into this).
        //
        if (pRowInfo->fUpdTimeStamp)
        {
                // add 6th column (this is the time stamp)        */
                JETRET_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                              );
        }

        JetRetStat = JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                               );
 } // end of try block
 finally {
         if (AbnormalTermination() || JetRetStat != JET_errSuccess)
         {
                CALL_M(JetRollback(SesId, JET_bitRollbackAll));
         }
         else
         {
                CALL_M(JetCommitTransaction(SesId, /*CommitGrBit |*/ JET_bitCommitFlush));
         }
    }

#ifdef WINSDBG
       if (JetRetStat == JET_errSuccess)
       {

                NMSNMH_UPD_UPD_CTRS_M(fUpd, TypOfUpd != JET_prepReplace ? FALSE : TRUE, pRowInfo);
       }
#endif

       return(JetRetStat);
}


STATUS
NmsDbUpdateVersNo (
        BOOL                        fAfterClash,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T      pStatusInfo
       )

/*++

Routine Description:
        This function is called to update a record in the name - address
        mapping table of the database.


Arguments:
        fAfterClash  - indicates whether the update is being done after
                       a conflict resolution.

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsNmhReplRegInd,
Side Effects:

Comments:
        None
--*/

{
        JET_TABLEID     TblId;
        JET_SESID        SesId;
        PWINSTHD_TLS_T        pTls;
        STATUS                 RetStat = WINS_SUCCESS;
        JET_ERR                JetRetStat;
        DWORD                ActFldLen;

        DBGENTER("NmsDbUpdVersNo\n");
        pTls  = TlsGetValue(WinsTlsIndex);

        // No need to check whether pTls is NON-NULL.  It has to be

        TblId = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        pStatusInfo->StatCode = NMSDB_SUCCESS;

        CALL_M( JetMakeKey(
                SesId,
                TblId,
                pRowInfo->pName,
                pRowInfo->NameLen,
                JET_bitNewKey
                          )
              );

         if ( (JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                                  )
              ) ==  JET_errRecordNotFound
            )
         {
                if (fAfterClash)
                {
                   /*
                    There is some serious error.
                    This condition should never occur because this thread
                    got a conflict on a record earlier while inside the
                    NmsNmhNamRegCrtSec.  Since the thread never got out of the
                    critical section prior to calling this function, there is
                    no reason why we should now not be able to find the record
                  */
                  DBGPRINT1(ERR,
                        "NmsDbUpdateVersNo: Could not find record (%s) -- WEIRD\n", pRowInfo->pName);
                  WINSEVT_LOG_M(JetRetStat, WINS_EVT_F_CANT_FIND_REC);
                  ASSERTMSG(0, "SEEK ERROR");
                  return(WINS_FAILURE);
                }
                else
                {
                  DBGPRINT1(DET,
                        "NmsDbUpdateVersNo: Could not find record (%s). It might have been deleted\n", pRowInfo->pName);
                  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_CANT_FIND_REC);
                  return(WINS_SUCCESS);
                }
         }
         else
         {
                if (JetRetStat != JET_errSuccess)
                {
                        DBGPRINT1(ERR,
                                "NmsDbRelRow: Seek returned Error (%d)\n",
                                                JetRetStat);

                        WINSEVT_LOG_M(JetRetStat, WINS_EVT_DATABASE_ERR);
                        return(WINS_FAILURE);
                }
        }
        CALL_M(JetBeginTransaction(SesId));
try {
        JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepReplace
                                );
        if ((JetRetStat != JET_errSuccess) && (JetRetStat != JET_wrnNoWriteLock))
        {
                CALL_M(JetRetStat);
        }

FUTURES("Remove adding of name")
#if 0
        // add first column (clusterred index)
        CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                pRowInfo->pName,
                                pRowInfo->NameLen,
                                0,
                                NULL /*optional info */
                                )
                  );
#endif
        //
        // retrieve the owner id field for doing sanity check
        //
#if !NEW_OWID
pStatusInfo->OwnerId = 0;
#endif
               CALL_M(
                   JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &pStatusInfo->OwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                         )
                );

        //
        // If this WINS does not own the record, raise an exception
        //
        // This should never happen since we never left the critical
        // section after the clash.
        //
        if(pStatusInfo->OwnerId != NMSDB_LOCAL_OWNER_ID)
        {
                if (fAfterClash)
                {
                  pStatusInfo->StatCode = NMSDB_NO_SUCH_ROW;
                  WINSEVT_LOG_M(pStatusInfo->OwnerId, WINS_EVT_RECORD_NOT_OWNED);
                  DBGPRINT1(EXC,
        "NmsDbUpdVersNo: Record with name (%s) not owned by this WINS\n",
                        pRowInfo->pName);
                  WINS_RAISE_EXC_M(WINS_EXC_RECORD_NOT_OWNED);
                }
                else
                {
                  DBGPRINT1(DET,
                        "NmsDbUpdateVersNo: The record with name (%s) is no longer owned by this WINS", pRowInfo->pName);
                  WINSEVT_LOG_INFO_D_M(WINS_SUCCESS, WINS_EVT_RECORD_NOT_OWNED);
                  return(WINS_SUCCESS);
                }
        }

        // add 5th column (this is the version number long(DWORD)        */
        CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &(pRowInfo->VersNo),
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
              );


        //
        // determine if the time stamp needs to be updated
        //
        if (pRowInfo->fUpdTimeStamp)
        {
                // add 6th column (this is the time stamp)        */
                CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &(pRowInfo->TimeStamp),
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                              );
        }
        CALL_M( JetUpdate (
                        SesId,
                        TblId,
                        NULL,
                        0L,
                        NULL
                        )
              );
} // end of try ..
finally {
        if (AbnormalTermination())
        {
                CALL_M(JetRollback(SesId, JET_bitRollbackAll));
        }
        else
        {
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
        }
  }


       DBGLEAVE("NmsDbUpdVersNo\n");
       return(RetStat);
}

STATUS
NmsDbEndSession (
        VOID
        )

/*++

Routine Description:

        This function closes the table, the database and ends the session

Arguments:
        None

Externals Used:
        WinsTlsIndex

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:
        Errors are logged

Called by:
        WaitUntilSignaled in nms.c (by an nbt thread when it is signaled by
        the main thread for termination purposes)
Side Effects:

Comments:
        None
--*/
{

        PWINSTHD_TLS_T        pTls;
        STATUS                RetStat = WINS_SUCCESS;

        pTls  = TlsGetValue(WinsTlsIndex);
        if (pTls == NULL)
        {
                RetStat = WINS_FAILURE;
        }
        else
        {

                if (pTls->fNamAddTblOpen)
                {
                    CALL_M(JetCloseTable(
                                pTls->SesId,
                                pTls->NamAddTblId
                                    )
                       );
                }

                if (pTls->fOwnAddTblOpen)
                {
                        CALL_M(JetCloseTable(
                                pTls->SesId,
                                pTls->OwnAddTblId
                                    )
                                      );

                }

                CALL_M(JetCloseDatabase(
                                pTls->SesId,
                                pTls->DbId,
                                0  //find out what grbit can be used for
                                    )
                       );


                CALL_M(JetEndSession(
                              pTls->SesId,
                              0   //find out what grbit can be used for
                             )
                      );

        }

        //
        // deallocate the TLS storage
        //
        WinsMscDealloc(pTls);

        return(RetStat);

}


STATUS
GetGrpMem (
        IN JET_SESID              SesId,
        IN JET_TABLEID            TblId,
        IN PNMSDB_ROW_INFO_T      pRowInfo,
        IN DWORD_PTR              CurrentTime,
//        IN OUT PNMSDB_NODE_ADDS_T pNodeAdds,
        IN OUT PNMSDB_STAT_INFO_T pStatInfo,
        IN BOOL                   fStatic,
        OUT LPBOOL                pfIsMem
        )

/*++

Routine Description:
        This function is called to get all the active members of a
        special group

Arguments:
        SesId    - Id of the session started with the db
        TblId    - Id of the name -address mapping table
        pRowInfo - Used to pass current time and address of the client
                   (when the client sends the release request)
        pNodeAdds - group memnbers that are still active
        fStatic   - indicates whether the record is STATIC or not.
        pfIsMem   - indicates whether the client is a member of the group


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
  NmsDbRelRow,  NmsDbInsertRowGrp

Side Effects:

Comments:
        None
--*/

{
        DWORD                      i;
        DWORD                      No = 0;        //needs to be inited here
        JET_RETINFO                RetInfo;
        DWORD                      ActFldLen = 0;
        DWORD                      TimeToExpire;
        NMSDB_GRP_MEM_ENTRY_T      GrpMem;
        JET_ERR                    JetRetStat;

        *pfIsMem = FALSE;        //Assume that the client is not a member
                                 //of the group

        /* retrieve the number of addresses info*/
        RetInfo.itagSequence = 1;
        RetInfo.cbStruct     = sizeof(JET_RETINFO);
        RetInfo.ibLongValue  = 0;

        JetRetStat = JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                        &pStatInfo->NodeAdds.NoOfMems,
                        sizeof(pStatInfo->NodeAdds.NoOfMems),
                        &ActFldLen,
                        0,
                        &RetInfo
                                );

        if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnBufferTruncated)
           )
        {
                   CALL_M(JetRetStat);
        }

        ASSERT(pStatInfo->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);

        DBGPRINT1(FLOW, "GetGrpMems: No Of members in group (expired and non-expired) are (%d)\n", pStatInfo->NodeAdds.NoOfMems);

NOTE("Remove this check once JET is error free")
        if (pStatInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
            WINSEVT_STRS_T  EvtStrs;
            WCHAR String[NMSDB_MAX_NAM_LEN];
            EvtStrs.NoOfStrs = 1;
            (VOID)WinsMscConvertAsciiStringToUnicode(
                        pRowInfo->pName,
                        (LPBYTE)String,
                        NMSDB_MAX_NAM_LEN);
            EvtStrs.pStr[0] = String;
            pStatInfo->NodeAdds.NoOfMems = 0;
            WINSEVT_LOG_STR_M(WINS_EVT_DATABASE_CORRUPTION, &EvtStrs);

        }
        RetInfo.ibLongValue  = sizeof(pStatInfo->NodeAdds.NoOfMems);
        for (i=0; i < pStatInfo->NodeAdds.NoOfMems; i++)
        {
           JetRetStat = JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &GrpMem,
                                sizeof(GrpMem),
                                &ActFldLen,
                                0,
                                &RetInfo
                                     );
           if (
                (JetRetStat != JET_errSuccess)
                        &&
                (JetRetStat != JET_wrnBufferTruncated)
              )
           {
                   CALL_M(JetRetStat);
           }



           //
           // If the grp has expired, set TimeToExpire to 0
           //
           if (CurrentTime >= GrpMem.TimeStamp)
           {
                TimeToExpire = 0;
           }
           else
           {
                TimeToExpire = 1;
           }


           //
           // If this is a STATIC record but not a user defined spec. grp or
           // if the member was registered by another WINS or if
           // the member is still active, keep it (i.e. return it
           // in the NodeAdds array.)  We drop all non-owned members which
           // have expired.
           //
           // Note 1C groups are special even if user defines them in the
           // lmhosts file
           //
           if (
                (fStatic &&  (!(NMSDB_ENTRY_USER_SPEC_GRP_M(pRowInfo->pName, pStatInfo->EntTyp))))
                        ||
                  (GrpMem.OwnerId != NMSDB_LOCAL_OWNER_ID)
                        ||
                  TimeToExpire
               )
           {

                   pStatInfo->NodeAdds.Mem[No++] = GrpMem;
                   if (pRowInfo->NodeAdds.Mem[0].Add.Add.IPAdd
                                        == GrpMem.Add.Add.IPAdd)
                   {
                        *pfIsMem = TRUE;
                   }
           }

           if (No == NMSDB_MAX_MEMS_IN_GRP)
           {
               /*
                * Group limit reached
                */
               break;
           }
           RetInfo.ibLongValue  += sizeof(GrpMem);

        } //end of for

        pStatInfo->NodeAdds.NoOfMems = No;

        DBGPRINT1(FLOW, "GetGrpMems: No Of non-expired members in group are (%d)\n", pStatInfo->NodeAdds.NoOfMems);
#ifdef WINSDBG
        if (pStatInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
        DBGPRINT4(SPEC, "GetGrpMems: No Of non-expired members in group %s are (%d). Vers. No to insert is (%d %d)\n", pRowInfo->pName, pStatInfo->NodeAdds.NoOfMems, pRowInfo->VersNo.HighPart, pRowInfo->VersNo.LowPart);
        }
#endif
        return(WINS_SUCCESS);
}
VOID
NmsDbRelRes(
        VOID
        )

/*++

Routine Description:

        This function releases all the resources held by the Database Engine
        (JET)

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        WinsMain

Side Effects:

Comments:
        This function must be called by the thread that did the attach.
    So, it has to be the main thread.
--*/
{
//        PWINSTHD_TLS_T        pTls;
        JET_ERR  JetRetStat = JET_errSuccess;
 //       JET_SESID SesId;
//        BOOL      fOutOfReck;

        DBGENTER("NmsDbRelRes\n");

      //
      // Call JetTerm only if there is no abrupt termination.  Currently,
      // JetTerm will hang if it is called without all sessions being
      // terminated.  Terminating abruptly without calling JetTerm
      // is sort of equivalent to power failure kind of situation.
      // Recovery will happen under the covers the next time WINS server
      // is invoked -- Ian Jose 10/18/93.
      //
      if (!fNmsAbruptTerm /*&& !fOutOfReck*/)
      {
            DBGPRINT0(DET, "NmsDbRelRes: JetTerm being called\n");

#if DYNLOADJET
            if (DynLoadJetVersion >= DYN_LOAD_JET_500)
            {
              (VOID)JetTerm2(sJetInstance, JET_bitTermComplete);//no need to check to the return value
            }
            else
#endif
            {
              (VOID)JetTerm(sJetInstance);//no need to check to the return value
            }
      }
      DBGLEAVE("NmsDbRelRes\n");
      return;
}





STATUS
GetMaxVersNos(
        JET_SESID         SesId,
        JET_TABLEID        TblId
        )

/*++

Routine Description:
        This function is called at initialization time to get the
        max version number for records owned by different WINS servers
        in the database.

Arguments:
        SesId - Jet Session id
        TblId - Table Id of the Name-Address Mapping table

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
        This function is called at initialization time.  If in the future,
        it gets called during stable state, we need to have a critical section
        around the update of NmsDbNoOfOwners var.
--*/

{
#if NEW_OWID
        DWORD  OwnerId;
#else
        DWORD   OwnerId = 0;
#endif
        DWORD   ActFldLen;
        JET_ERR        JetRetStat;
        BOOL    fOnlyReplicas = FALSE;
        BOOL        fFirstIter = TRUE;

        WINS_ASSIGN_INT_TO_VERS_NO_M(sHighestVersNoSaved, 0);

        /*
         * Set the primary index as the current index
        */
        CALL_M( JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
                      );

PERF("Remove this Move since when we set the index, we are automatically")
PERF("positioned on the first row")
        //
        // Move to the first record in the name - address mapping table
        //
        JetRetStat = JetMove(
                        SesId,
                        TblId,
                        JET_MoveFirst,
                        0                //no grbit
                        );
        //
        // The following error indicates that either our database
        // is empty or has garbage.  I will assume for now that it
        // is empty.  If it contains garbage, we will know soon enough
        //
        if (JetRetStat == JET_errNoCurrentRecord)
        {
FUTURES("Be more robust. Check if db contains garbage")
                DBGPRINT0(ERR,
                        "GetMaxVersNos: There are no records in the db\n");
                WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_NO_RECS_IN_NAM_ADD_TBL);
                NmsDbNoOfOwners = 0;
                return(WINS_SUCCESS);
        }

        CALL_M(JetRetStat);

        //
        // The fact that we are here means that there is atleast one record
        // in our db
        //

        //
        // Get the owner id and max version numbers of all owners in the
        // table
        //
        do
        {

                //
                // Retrieve the owner Id column.
                //
                CALL_M(
                        JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &OwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     0,
                                     NULL
                                       )
                        );

                if (fFirstIter)
                {
                        if (OwnerId != 0)
                        {
                           // The last owner id to be retrieved is not 0 means
                           // that there is no record owned by us
                           //
                           fOnlyReplicas = TRUE;
                        }
                        fFirstIter = FALSE;
                }


                 //
                 // Specify an owner id that is 1 more than what we retrieved
                 //
                 OwnerId += 1;

                 // in case this is not the special record...
                 if ((OwnerId - 1) != OWNER_ID_OF_SPEC_REC)
                 {
                     // ...expand the ownerid - versNo array to at least OwnerId slots
                     if (RplPullMaxNoOfWins < OwnerId)
                     {
                         DWORD newMaxNoOfWins = max(RplPullMaxNoOfWins * 2, OwnerId);

                         RplPullAllocVersNoArray(&pRplPullOwnerVersNo, newMaxNoOfWins);
                         RplPullMaxNoOfWins = newMaxNoOfWins;
                         DBGPRINT1(DET, "ReadOwnAddTbl: No of slots in RPL_OWNER_VERS_NO_ARRAY has been increased to %d\n", RplPullMaxNoOfWins);
                     }
                 }

                 //
                 // Construct a partial key made of owner id.
                 //
                 CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
                        );

                  //
                  // Seek to the record that has a key that is Less than or
                  // Equal to the OwnerId value.
                  //
                  // Since we have specified a partial key (saying in effect
                  // that the other component of the key is NULL), JetSeek
                  // must return wrnSeekNotEqual since it will never find
                  // a record with NULL for the second component of the index
                  // -- Ian 7/13/93
                  //
                  JetRetStat = JetSeek(
                                              SesId,
                                              TblId,
                                              JET_bitSeekLE
                                      );
                  ASSERT(JetRetStat == JET_wrnSeekNotEqual);
#ifdef WINSDBG
                  if (JetRetStat != JET_wrnSeekNotEqual)
                  {
                      DBGPRINT1(ERR, "GetMaxVersNos: JetSeek returned (%d)\n", JetRetStat);
                  }
#endif


                   //
                   // retrieve the version number of the record on which we
                   // are positioned.  This is the max vers. number pertaining
                   // to OwnerId. If the Owner Id is one more than the
                   // owner id. we have assigned to the special record,
                   // then store the version number retrieved into
                   // sHighestVersNoSaved
                   //
                   CALL_M(
                           JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                             ((OwnerId - 1 ) == OWNER_ID_OF_SPEC_REC) ?
                                &sHighestVersNoSaved :
                                &(pRplPullOwnerVersNo+OwnerId - 1)->VersNo,
                             sizeof(VERS_NO_T),
                             &ActFldLen,
                             0,
                             NULL
                                                 )
                          );

                   if ((OwnerId - 1) == OWNER_ID_OF_SPEC_REC )
                   {
                       ASSERT(!sfHighestVersNoRecExists);
                       if (sfHighestVersNoRecExists)
                       {
                          DBGPRINT0(ERR, "GetMaxVersNo: ERROR: SOFTWARE BUG - Found both the old and new spec. owner id records. They are MUTUALLY EXCLUSIVE\n");
                          WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                       }
                       StoreSpecVersNo();
                       DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  sHighestVersNoSaved.HighPart, sHighestVersNoSaved.LowPart);
                       continue;
                   }
                   else
                   {
                      //
                      // If the owner id is == what used to be the owner id.
                      // of the special record, it means that we have a pre-SUR
                      // beta2 db.  We should delete this name to get rid of
                      // clutter.  We should mark the pRplPullOwnerVersNo slot
                      // empty since it was initialized above.
                      //
                      if ((OwnerId - 1) == OWNER_ID_OF_SPEC_REC_OLD )
                      {
                          LPBYTE Name[NMSDB_MAX_NAM_LEN];
                          DWORD  NameLen;

                          //
                          // If the name is == spHighestVersNoRecNameOld, delete
                          // this record.  This is the old special record
                          // we had. Save the vers. no. in a local
                          //
                          // NOTE: the length of the spec. rec. name is < 16
                          // bytes so it is not a valid netbios name
                          //
                          CALL_M( JetRetrieveColumn(
                                        SesId,
                                        TblId,
                                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                        Name,
                                        NMSDB_MAX_NAM_LEN,
                                        &NameLen,
                                        0,
                                        NULL));

                         if ((NameLen == sizeof(spHighestVersNoRecNameOld)) && RtlEqualMemory((PVOID)Name, spHighestVersNoRecNameOld, NameLen))
                         {
                              sHighestVersNoSaved =
                                (pRplPullOwnerVersNo+OwnerId - 1)->VersNo;
                              (pRplPullOwnerVersNo+OwnerId - 1)->VersNo.QuadPart = 0;
                              CALL_M(JetDelete(SesId, TblId));
                              StoreSpecVersNo();
                              DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  sHighestVersNoSaved.HighPart, sHighestVersNoSaved.LowPart);
                              continue;
                         }
                      }
                   }
                   DBGPRINT3(INIT, "GetMaxVersNo: Owner Id - (%d) : Vers No. (%d %d)\n", (OwnerId - 1),  (pRplPullOwnerVersNo+OwnerId - 1)->VersNo.HighPart,
(pRplPullOwnerVersNo+OwnerId - 1)->VersNo.LowPart);


                   NmsDbNoOfOwners++;        //count of owners found in the db

        }  while(
                JetMove(SesId, TblId, JET_MoveNext, 0) == JET_errSuccess
               );



        //
        // Check if the version counter's value is < that of the highest
        // version found for owned records
        // (found when we did the search  in the while loop above. Use
        // whichever is higher as the  version counter)
        //
        if (!fOnlyReplicas)
        {
           //
           // We need to increment the Vers. No. Counter to point to the
           // number to be given to the next record
           //
           if (LiGeq(
                        pRplPullOwnerVersNo->VersNo,
                        NmsNmhMyMaxVersNo
                     )
              )
           {
                //
                // Initialize NmsNmhMyMaxVersNo.  Remember this counter
                // always contains the next version number to be given
                // to a record. So, we must increment the count contained
                // in RplPullOwnerVersNo[0] by 1
                //
                NMSNMH_INC_VERS_NO_M(
                                pRplPullOwnerVersNo->VersNo,
                                NmsNmhMyMaxVersNo
                                  );

               //
               // Since we found records in the db, we take the conservative
               // approach here, and set the Min Scv Vers. no to 1.  If
               // the first record has a very high version no. the scavenger
               // thread will update the NmsScvMinVersNo to that value.
               //
               // We need to scavenge from this version onwards.
               //
               NmsScvMinScvVersNo.QuadPart  = 1;

               return(WINS_SUCCESS);
           }

        }

        //
        // Since we are here it means that when we searched for records
        // belonging to the local WINS, we did not find any record
        // We may or may not have found the special record.  If we did find it
        // it means that all the local records of the WINS were either
        // deleted or replaced by replicas in its previous incarnation.
        //

        //
        // If we found the special record, let us initialize RplPullOwnerVersNo
        // entry for the local WINS
        //
        if (sfHighestVersNoRecExists)
        {
                pRplPullOwnerVersNo->VersNo =  NmsNmhMyMaxVersNo;

                //
                // Increment the counter since it must always have a
                // value to be given to the next local record we insert or
                // update.
                //
CHECK("May not be necessary")
                NMSNMH_INC_VERS_NO_M(
                                NmsNmhMyMaxVersNo,
                                NmsNmhMyMaxVersNo
                                  );

               if (fOnlyReplicas)
               {
                 //
                 // We need to scavenge from this version onwards.
                 //
                 NmsScvMinScvVersNo = NmsNmhMyMaxVersNo;
               }
               else
               {
                 NmsScvMinScvVersNo.QuadPart  = 1;
               }
         }

         return(WINS_SUCCESS);
}

__inline
VOID
StoreSpecVersNo(
   VOID
)

/*++

Routine Description:

 This function conditionally updates NmsNmhMyMaxVersNo to a number that is 1
 more than the version. no. found in the special owner id. record.

Arguments:

      None

Externals Used:

   NmsNmhMyMaxVersNo,
   sfHighestVersNoExists
	
Return Value:

  None

Error Handling:

Called by:
        GetMaxVersNos()

Side Effects:

Comments:
	None
--*/

{
        sfHighestVersNoRecExists = TRUE;

        //
        // If the version counter's value is < that of
        // the special record, update it.
        //
        //
        // NOTE: If the registry specified a number for the
        // version counter, then NmsNmhMyMaxVersNo would be
        // having that value, else it would be 1
        //
        if (LiLtr(NmsNmhMyMaxVersNo, sHighestVersNoSaved))
        {
                NMSNMH_INC_VERS_NO_M( sHighestVersNoSaved, NmsNmhMyMaxVersNo);

        }

       return;
}

JET_ERR
InsertGrpMemsInCol(
        JET_SESID                SesId,
        JET_TABLEID                TblId,
        PNMSDB_ROW_INFO_T        pRowInfo,
        ULONG                    TypOfUpd
         )

/*++

Routine Description:
        This function is called to insert members of a special group
        in the address column field of the name - address mapping table

Arguments:
        SesId            - Session Id.
        TblId       - Table Id.
        pRowInfo    - Contains the member info
        fOverwrite  - Whether members in the list above would overwrite the
                      ones already there


Externals Used:
        sNamAddTblRow


Return Value:

   Success status codes --  JET_errSuccess
   Error status codes   --  Jet error codes

Error Handling:

Called by:
        NmsDbRelRow, UpdateDb

Side Effects:

Comments:
        None
--*/
{

        JET_SETINFO    SetInfo;
        DWORD          i;
        JET_ERR        JetRetStat = JET_errSuccess; //needs to be inited here

        DBGENTER("InsertGrpMemsInCol\n");
        SetInfo.itagSequence = 1;  //has to be 1 always
        SetInfo.ibLongValue  = 0;
        SetInfo.cbStruct     = sizeof(JET_SETINFO);

        ASSERT(pRowInfo->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);

#ifdef WINSDBG
        if (NMSDB_ENTRY_MULTIHOMED_M(pRowInfo->EntTyp) && pRowInfo->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
           DBGPRINT4(SPEC, "InsertGrpMemsInCol: Name is (%s); No Of Mems are (%d); Version number is (%d %d)\n", pRowInfo->pName, pRowInfo->NodeAdds.NoOfMems, pRowInfo->VersNo.HighPart, pRowInfo->VersNo.LowPart);
        }
#endif
        //
        // Set the # of Members field.  This is always the first
        // field
        //
        if (TypOfUpd == JET_prepReplace)
        {

//          SetInfo.ibLongValue  = sizeof(pRowInfo->NodeAdds.NoOfMems);
          JETRET_M(JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                NULL,
                                0,
                                JET_bitSetSizeLV,
                                &SetInfo /*optional info */
                                )
                            );
 //         SetInfo.ibLongValue  = 0;
        }
        JETRET_M(JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRowInfo->NodeAdds.NoOfMems,
                                sizeof(pRowInfo->NodeAdds.NoOfMems),
                                JET_bitSetAppendLV,
                                &SetInfo /*optional info */
                                )
                            );
        for (
             i=0;
             i < pRowInfo->NodeAdds.NoOfMems && JetRetStat == JET_errSuccess;
             i++
            )
        {

                DBGPRINT3(DET, "InsertGrpMemsInCol: Inserted member (%d) with address (%X) and owner id (%d)\n", i, pRowInfo->NodeAdds.Mem[i].Add.Add.IPAdd,
                        pRowInfo->NodeAdds.Mem[i].OwnerId
                         );

CHECK("Check this on a MIPS machine")
                //
                // Set the GrpMem
                //
                JetRetStat =  JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRowInfo->NodeAdds.Mem[i],
                                sizeof(NMSDB_GRP_MEM_ENTRY_T),
                                JET_bitSetAppendLV,
//                                TypOfUpd == JET_prepReplace ? JET_bitSetOverwriteLV : JET_bitSetAppendLV,
                                &SetInfo /*optional info */
                                    );

        } // end of for
        DBGLEAVE("InsertGrpMemsInCol\n");
        return(JetRetStat);
}


STATUS
NmsDbSetCurrentIndex(
        IN NMSDB_TBL_NAM_E        TblNm_e,
        IN LPBYTE                pIndexNam
        )
/*++

Routine Description:
        This function is called to set the index on a table

Arguments:
        TblNm_e - Identifies the table whose index needs to be set
        pIndexNm - Name of index to be set

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PWINSTHD_TLS_T        pTls;
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        /*
         * Use primary index now
        */
               CALL_M( JetSetCurrentIndex(
                                pTls->SesId,
                                TblNm_e == NMSDB_E_NAM_ADD_TBL_NM ?
                                        pTls->NamAddTblId :
                                        pTls->OwnAddTblId,
                                pIndexNam
                                   )
              );

        return(WINS_SUCCESS);
}



STATUS
NmsDbQueryNUpdIfMatch(
        LPVOID                pRecord,
        int                ThdPrLvl,
        BOOL                fChgPrLvl,
        WINS_CLIENT_E        Client_e
                )

/*++

Routine Description:
        This function is called to query a record and then update it only
        if it matches the timestamp of the record supplied

Arguments:
        pRecord      - Record supplied
        ThdPrLvl     - Priority level of the thread
        fChgPrLvl    - TRUE, if priority level of the thread needs to be changed

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        UpdDb in nmsscv.c, WinsRecordAction in winsintf.c

Side Effects:

Comments:
        This function must be called only when the index on the name
        address table has been set to the clustered index column.
--*/
{

        BYTE                     State;
        DWORD                    TimeStamp = 0;
        DWORD                    ActFldLen;
        JET_TABLEID              TblId;
        JET_SESID                SesId;
        PWINSTHD_TLS_T           pTls;
        PRPL_REC_ENTRY_T         pRec = pRecord;
        JET_ERR                  JetRetStat;
        BOOL                     fIncVersNo = FALSE;
#if NEW_OWID
        DWORD                     OwnerId;
#else
        DWORD                    OwnerId = 0;
#endif
        BOOL                     fAbort = FALSE;


        DBGENTER("NmsDbQueryNUpdIfMatch\n");

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        State = (BYTE)NMSDB_ENTRY_STATE_M(pRec->Flag);

#if 0
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
#endif

        //
        // Make sure you enter the critical section
        // prior to deleting a record.  This is because
        // another thread may be seeking to it after
        // conflicting with it.  If we delete the
        // record without entering the critical
        // section, the thread may not
        // find the record.  This would cause it to
        // raise an exception.
        //
        if (fChgPrLvl)
        {
                //
                // Set the priority to NORMAL. We
                // don't want to delay normal
                // priority threads by getting
                // starved of cpu time inside
                // the critical section.
                //
                  WinsMscSetThreadPriority(
                        WinsThdPool.ScvThds[0].ThdHdl,
                        THREAD_PRIORITY_NORMAL
                                );
        }
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
try {

        //
        // Seek to the record
        //
        CALL_M( JetMakeKey(
                        SesId,
                        TblId,
//                        pRec->Name,
                        pRec->pName,
                        pRec->NameLen,
                        JET_bitNewKey
                          )
                        );

        if (JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekEQ
                    ) ==  JET_errSuccess
            )
        {
                BOOL                     fUpdSpecRec = FALSE;
                VERS_NO_T             RecVersNo;
                VERS_NO_T             MyMaxVersNo;

                //
                // If we are doing scavenging, we need to make sure that
                // while we were examining the records, the record that
                // we want to update now, did not get updated.  To check
                // that we retrieve the timestamp of the record
                //
                if (Client_e == WINS_E_NMSSCV)
                {
                    //
                    // retrieve the time stamp
                    //
                        CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &TimeStamp,
                                sizeof(TimeStamp),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                        );
                }

                //
                // if timestamp is the same, we have our record.
                // we don't need to check any other field.  Exception: If we
                // are an RPC thread, whether or not we update the
                // record is independent of the timestamp that the
                // record may have now
                //
                if (
                        (pRec->TimeStamp == TimeStamp)
                                ||
                        (Client_e == WINS_E_WINSRPC)
                       )
                {
                        //
                        // if state of the record is deleted, we need to
                        // delete it from the database.
                        //
                        if (State == NMSDB_E_DELETED)
                        {

                                //
                                // If Client is an RPC thread, first retrieve
                                // the owner id and version number of the
                                // record to delete
                                //

                                if (Client_e == WINS_E_WINSRPC)
                                {

                                         CALL_M( JetRetrieveColumn(
                                        SesId,
                                        TblId,
                                        sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                        &OwnerId,
                                        NAM_ADD_OWNERID_SIZE,
                                        &ActFldLen,
                                        0,
                                        NULL
                                                     )
                                          );

                                   if (OwnerId == NMSDB_LOCAL_OWNER_ID)
                                   {
                                            //
                                            // Retrieve the version number
                                            //
                                            CALL_M( JetRetrieveColumn(
                                                SesId,
                                                TblId,
                                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                                &RecVersNo,
                                                sizeof(VERS_NO_T),
                                                &ActFldLen,
                                                0,
                                                NULL
                                                     )
                                          );

                                      //
                                      // get the highest version number used
                                      // up until now.
                                      //
                                      NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo,
                                                        MyMaxVersNo);

                                      //
                                      // If the record to be deleted has
                                      // the this highest version number we
                                      // must update the special record
                                      //
                                      if(LiEql(RecVersNo, MyMaxVersNo))
                                      {
                                          fUpdSpecRec = TRUE;
                                      }
                                   }
                                }
                                CALL_M(JetDelete(
                                                SesId,
                                                TblId
                                                )
                                        );
#ifdef WINSDBG
                                NmsDbDelQueryNUpdRecs++;
#endif
                                DBGPRINT2(SCV, "NmsDbQueryNUpdIfMatch: Deleted the record with name = (%s);16th char (%X)\n", pRec->pName, *(pRec->pName + 15));

                                //
                                // This can be TRUE only in an RPC thread
                                //
                                if (fUpdSpecRec)
                                {
                                        NmsDbUpdHighestVersNoRec(
                                                        pTls,
                                                        MyMaxVersNo,
                                                        FALSE //don't enter Crt
                                                              //sec
                                                        );
                                }
                        }
                        else    // we need to set the Flag field and in the
                                      //case of a tombstone record update the version
                                      //stamp
                        {
                                CALL_M(JetBeginTransaction(SesId));
                            try {
                                JetRetStat = JetPrepareUpdate(
                                                SesId,
                                                TblId,
                                                JET_prepReplace
                                                           );
                                if (
                                        (JetRetStat != JET_errSuccess)
                                                &&
                                        (JetRetStat != JET_wrnNoWriteLock)
                                      )
                                {
FUTURES("When Jet becomes stable, replace RET_M with a raise_exception")
                                        //
                                        // this should result in the execution
                                        // of the finally clause
                                        //
                                        RET_M(JetRetStat);
                                }

                                if (Client_e == WINS_E_WINSRPC)
                                {

                                        DWORD FlagVal;
                                        BYTE EntryType;
                                        BYTE NewEntryType;

                                        //
                                        // Retrieve the flags byte
                                        //
                                         // retrieve the flags column
                                         CALL_M( JetRetrieveColumn(
                                                        SesId,
                                                        TblId,
                                                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                                        &FlagVal,
                                                        sizeof(FlagVal),
                                                        &ActFldLen,
                                                        0,
                                                        NULL
                                                          )
                                                      );
                                        EntryType = (BYTE)NMSDB_ENTRY_TYPE_M(FlagVal);
                                        NewEntryType = (BYTE)NMSDB_ENTRY_TYPE_M(pRec->Flag);

                                        //
                                        // A unique/normal group record
                                        // can not be changed to a multihomed/
                                        // special group record unless the
                                        // address column too is changed
                                        //
                                        if (
                                            (
                                             (
                                              EntryType == NMSDB_UNIQUE_ENTRY
                                                          ||
                                              EntryType ==
                                                        NMSDB_NORM_GRP_ENTRY
                                             )
                                                        &&
                                             (
                                                 NewEntryType ==
                                                        NMSDB_SPEC_GRP_ENTRY
                                                        ||
                                                 NewEntryType ==
                                                        NMSDB_MULTIHOMED_ENTRY
                                             )
                                           )
                                                        ||
                                           (
                                             (
                                                 EntryType ==
                                                        NMSDB_SPEC_GRP_ENTRY
                                                        ||
                                                 EntryType ==
                                                        NMSDB_MULTIHOMED_ENTRY
                                             )
                                                        &&
                                             (
                                              NewEntryType == NMSDB_UNIQUE_ENTRY
                                                          ||
                                              NewEntryType ==
                                                        NMSDB_NORM_GRP_ENTRY
                                             )
                                          )
                                         )
                                      {

                                          DBGPRINT0(ERR, "NmsDbQueryNUpdIfMatch: SORRY, Can not change to an incompatibe address format record. (Unique/Normal Group) to (Multihomed/Spec. Group) or vice-versa disallowed\n");

PERF("Do not return like this. finally block search is expensive")
                                          fAbort = TRUE;
                                          return(WINS_FAILURE);

                                      }

                                } // end of if (client is RPC)

                                //
                                // Update the flags field
                                //
                                CALL_M( JetSetColumn(
                                                    SesId,
                                                    TblId,
                                                    sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                                 &pRec->Flag,
                                                 sizeof(pRec->Flag),
                                                 0,
                                                 NULL /*optional info */
                                                       )
                                               );

                                  /* Update the timestamp column         */
                                  CALL_M( JetSetColumn(
                                                SesId,
                                                TblId,
                                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                                &(pRec->NewTimeStamp),
                                                sizeof(DWORD),  /*change type
                                                                   *to
                                                                   *TIME_STAMP_T
                                                                   *later
                                                                 */
                                                0,
                                                NULL /*optional info */
                                                     )
                                               );
                                //
                                // If the state of the record is a Tombstone
                                // or ACTIVE, we need to update the version
                                // number.
                                //
                                if (
                                           (State == NMSDB_E_TOMBSTONE)
                                                ||
                                        (State == NMSDB_E_ACTIVE)
                                      )
                                {

                                        VERS_NO_T VersNo;

                                        VersNo = NmsNmhMyMaxVersNo;


                                        //
                                        // Make local WINS the owner if
                                        // we are in an RPC thread.  We
                                        // have to make the local WINS the
                                        // owner in order to update the
                                        // version stamp.  Also, note that if
                                        // this is not the RPC thread then
                                        // this has to be the scavenger thread
                                        // (FYI: A scavenger thread never
                                        // changes a replica into a tombstone)
                                        //
                                        if (Client_e == WINS_E_WINSRPC)
                                        {
                                             DWORD OwnerId=NMSDB_LOCAL_OWNER_ID;

                                             /* Set the owner byte        */
                                             CALL_M( JetSetColumn(
                                                     SesId,
                                                     TblId,
                                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                                     &OwnerId,
                                                     NAM_ADD_OWNERID_SIZE,
                                                     0,
                                                     NULL /*optional info */
                                                         )
                                                       );
                                             //
                                             // Update the version number field
                                             // so that this record gets
                                             // propagated eventually
                                             //
                                             CALL_M( JetSetColumn(
                                                    SesId,
                                                  TblId,
                                                  sNamAddTblRow[
                                                  NAM_ADD_VERSIONNO_INDEX].Fid,
                                                  &VersNo,
                                                  sizeof(VERS_NO_T),
                                                  0,
                                                  NULL /*optional info */
                                                )
                                                    );

                                             fIncVersNo = TRUE;
                                        }
                                        else
                                        {
                                           //
                                           // This is the scavenger thread.
                                           // If the new state is not ACTIVE,
                                           // update the version number since
                                           // the state is TOMBSTONE.
                                           // if the state is ACTIVE, then it
                                           // means that we are doing a
                                           // a revalidation of old replicas
                                           // (i,e, the VerifyClutter() called
                                           // us).
                                           // The version number should stay
                                           // the same.
                                           //
                                           if (State != NMSDB_E_ACTIVE)
                                           {
                                               // if the current record is replica dont touch
                                               // the version #.
                                               CALL_M( JetRetrieveColumn(
                                                          SesId,
                                                          TblId,
                                                          sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                                          &OwnerId,
                                                          NAM_ADD_OWNERID_SIZE,
                                                          &ActFldLen,
                                                          0,
                                                          NULL));

                                               if (NMSDB_LOCAL_OWNER_ID == OwnerId) {
                                                   //
                                                   // Update the version number field
                                                   //
                                                   CALL_M( JetSetColumn(
                                                          SesId,
                                                        TblId,
                                                        sNamAddTblRow[
                                                        NAM_ADD_VERSIONNO_INDEX].Fid,
                                                        &VersNo,
                                                          sizeof(VERS_NO_T),
                                                        0,
                                                        NULL /*optional info */
                                                          )
                                                       );

                                                  fIncVersNo = TRUE;
                                               }

                                           }
                                        }


                                }  // if (state is ACTIVE or TOMBSTONE)

                                //
                                // Update the record
                                //
                                CALL_M(JetUpdate (
                                        SesId,
                                        TblId,
                                        NULL,
                                        0L,
                                        NULL
                                                 )
                                              );
                        } // end of try block
                        finally {
                                if (AbnormalTermination())
                                {
                                   CALL_M(JetRollback(SesId,
                                                JET_bitRollbackAll));
                                }
                                else
                                {
                                   CALL_M(JetCommitTransaction(SesId,
                                                JET_bitCommitFlush));
                                }
                         }
                                if (fIncVersNo)
                                {
                                        NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                           );

                                        RPL_PUSH_NTF_M(
                                                  RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                                }

                        } // New state is not DELETED

                }  // if (Timestamps equal or client is RPC)
#ifdef WINSDBG
                else
                {

                        DBGPRINT0(FLOW, "NmsDbQueryNUpdIfMatch: TimeStamp of record has changed\n");
                }
#endif
        }
        else  //seek failed
        {
                DBGPRINT3(FLOW, "NmsDbQueryNUpdIfMatch: Could not find record(%s[%x]) whose state has to be changed to (%d)\n",
                   pRec->pName, *(pRec->pName + 15),
                   NMSDB_ENTRY_STATE_M(pRec->Flag));

                //
                // Two different threads (RPC or Scavenger) can be calling
                // this function.  It is possible that either might have
                // deleted the record.  We should not raise an exception
                // here
                //
//                WINS_RAISE_EXC_M(WINS_EXC_FAILURE);

        }

} // end of try { ..}

finally {
        if (AbnormalTermination() && !fAbort)
        {
                DBGPRINT0(ERR, "NmsDbQueryNUpdIfMatch: Abnormal Termination\n");
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);

        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        if (fChgPrLvl)
        {
                WinsMscSetThreadPriority(
                                        WinsThdPool.ScvThds[0].ThdHdl,
                                        ThdPrLvl
                                        );
        }

  }  //end of finally

        DBGLEAVE("NmsDbQueryNUpdIfMatch\n");
        return(WINS_SUCCESS);

} // NmsDbQueryNUpdIfMatch

STATUS
SetSystemParamsJet600(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    BOOL          fFreeMem = TRUE;
    CHAR        DbFileDir[WINS_MAX_FILENAME_SZ];   //path to database file directory
    DBGENTER("SetSystemParam600\n");
    if (fBeforeInit)
    {
        CHAR    *p;

        // extract the directory path where database file will be created
        strcpy(DbFileDir, WinsCnf.pWinsDb);
        if (p = strrchr(DbFileDir, '\\')) {
            p++ ;
            *p = '\0';
        } else {
            return WINS_FAILURE;
        }

        //
        // set this to enable version checking.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramCheckFormatWhenOpenFail,
                        1,
                        NULL
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramExceptionAction,
                        JET_ExceptionMsgBox,
                        NULL
                           )
                );

        //
        // Path for the checkpoint file jet.chk to be located
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSystemPath,
                        0,
                        DbFileDir
                           )
                );
        //
        // Basename to use for jet*.log and jet.chk
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramBaseName,
                        0,
                        BASENAME
                           )
                );
        //
        // Max size of the log file in kb.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramLogFileSize,
                        1024,    //set to one full meg (#96543)
                        NULL    //ignored
                           )
                );
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );
PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramCacheSizeMax,   // JET_paramMaxBuffers,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );

                // Cheen: min cache size should be at-least 4 times the size of no of sessions
                // o/w it can lead to deadlock.
                ASSERT( WinsCnf.NoOfDbBuffers > MAX_NO_SESSIONS*4 );
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramCacheSizeMin,
                                MAX_NO_SESSIONS * 4,
                                NULL        //ignored
                                   )
                        );

                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                // 8/5/99
                // The previous value was 16M (42x15 pages of 16K each ~= 16M).
                // This value seems to be a bit too small so bump it to 32M.
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages,
                                MAX_NO_SESSIONS * 50, //number of 16K pages
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                // Jonathan Liem (1/6/97)
                // JET_paramMaxOpenTableIndexes is removed. It is merged with
                // JET_paramMaxOpenTables.  So if you used to set JET_paramMaxOpenIndexes
                // to be 2000 and JET_paramMaxOpenTables to be 1000, then for
                // new Jet, you need to set JET_paramMaxOpenTables to 3000.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables,
                                112,    //was 56     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)

                // Jonathan Liem (1/6/97)
                // JET_paramBfThrshldLowPrcnt and JET_paramBfThrhldHighPrcnt are changed
                // to JET_paramStartFlushThreshold and JET_paramStopFlushThreshold.  The
                // old ones are percent of given number of buffers (set through JET_paramMaxBuffer),
                // the new ones are absolute value so that we can set low threshold less
                // than 1 percent.
                //
                //
                // The min number of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramStartFlushThreshold,
                                (WinsCnf.NoOfDbBuffers * 1)/100,
                                NULL        //ignored
                                   )
                        );

                //
                // The max number of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramStopFlushThreshold,
                                (WinsCnf.NoOfDbBuffers * 2)/100,
                                NULL        //ignored
                                   )
                        );



                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramRecovery,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                        // this is gone in jet600.dll   cheen liao 1/6/96

                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramWaitLogFlush,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //

                        //
                        // set the log file path
                        //
                        if (WinsCnf.pLogFilePath == NULL)
                        {
                                //
                                // We should use the same directory as
                                // the one for system.mdb file
                                //
                                WinsCnf.pLogFilePath = LOGFILE_PATH;
                                fFreeMem = FALSE;
                        }

                        DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                        //
                        // Set the log file path.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogFilePath,
                                        0,        //ignored
                                        WinsCnf.pLogFilePath
                                        //pLogFilePath
                                                   )
                                              );

                        //
                        // Free this memory.  It is not needed any more
                        //
                        if (fFreeMem)
                        {
                           WinsMscDealloc(WinsCnf.pLogFilePath);
                        }
                }
    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;
}

STATUS
SetSystemParamsJet500(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    DBGENTER("SetSystemParam500\n");
    if (fBeforeInit)
    {
        //
        // Path for the checkpoint file jet.chk to be located
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSystemPath_OLD,
                        0,
                        CHKPOINT_PATH
                           )
                );
        //
        // Basename to use for jet*.log and jet.chk
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramBaseName_OLD,
                        0,
                        BASENAME
                           )
                );

        //
        // Max size of the log file in kb.
        //
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramLogFileSize_OLD,
                        1024,    //set to one full meg (#96543)
                        NULL    //ignored
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath_OLD,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );

PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxBuffers_OLD,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );
                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages_OLD,
                                MAX_NO_SESSIONS * 6, //10-4-95 Bump it up more
                                //MAX_NO_SESSIONS * 2,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables_OLD,
                                56,     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors_OLD,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the number of index description blocks
                // This is one per table/index.  We have two tables
                // each with two indices. We use 9 (see comment for
                // FCBs above).  Default value is 300.
                // Size of each is 128 bytes.
                //

                    CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramMaxOpenTableIndexes_OLD,
                                    56,         //18 + 10,
                                    NULL        //ignored
                                       )
                            );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables_OLD ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenDatabases_OLD,
                                MAX_NO_SESSIONS * 4, //*2,
                                NULL        //ignored
                                   )
                        );

                //
                // The min percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldLowPrcnt_OLD,
                                80,
                                NULL        //ignored
                                   )
                        );

                //
                // The max percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldHighPrcnt_OLD,
                                100,
                                NULL        //ignored
                                   )
                        );


                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions_OLD,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        30, // JET_paramRecovery not available,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers_OLD,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                            CALL_M(JetSetSystemParameter(
                                            &sJetInstance,
                                            (JET_SESID)0,        //SesId - ignored
                                            18, //JET_paramLogFlushThreshold,
                                            20,        //20 sectors dirtied causes
                                                    //flush
                                            NULL        //ignored
                                                   )
                                            );


                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramWaitLogFlush_OLD,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //

                        //
                        // set the log file path
                        //
FUTURES("Use DEFAULT_LOG_PATH after putting it in a header file")
                        if (WinsCnf.pLogFilePath == NULL)
                        {
                                //
                                // We should use the same directory as
                                // the one for system.mdb file
                                //

//                                pLogFilePath = ".\\wins";
                                WinsCnf.pLogFilePath = LOGFILE_PATH;
                        }
                        else
                        {
#if 0
#ifdef UNICODE
                                CHAR        AsciiLogFilePath[WINS_MAX_FILENAME_SZ];
                                WinsMscConvertUnicodeStringToAscii(
                                        (LPBYTE)WinsCnf.pLogFilePath,
                                        AsciiLogFilePath,
                                        WINS_MAX_FILENAME_SZ
                                                );
                                pLogFilePath = (LPBYTE)AsciiLogFilePath;
#else
                                pLogFilePath = (LPBYTE)WinsCnf.pLogFilePath;
#endif
#endif
                        }

                        DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                        //
                        // Set the log file path.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogFilePath_OLD,
                                        0,        //ignored
                                        WinsCnf.pLogFilePath
                                        //pLogFilePath
                                                   )
                                              );

                }

    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath_OLD,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;
}

STATUS
SetSystemParamsJet200(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --
--*/

{
    JET_ERR         JetRetStat;
    BOOL          fFreeMem = TRUE;
    DBGENTER("SetSystemParam200\n");
    if (fBeforeInit)
    {
        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramSysDbPath_OLD,
                        0,
                        SYS_DB_PATH        //ignored
                           )
                );

        CALL_M(JetSetSystemParameter(
                        &sJetInstance,
                        (JET_SESID)0,        //SesId - ignored
                        JET_paramTempPath_OLD,
                        0,
                        TEMP_DB_PATH        //ignored
                           )
                );
PERF("Check the following two things")
                //
                // We want some aggressive flushing.  The performance impact
                // is very trivial - Ian Jose 7/12/93
                //

                //
                // The max number of buffers for database usage
                //
                // The default number is 500.  600 events are allocated
                // for 500 buffers -- Ian 10/21/93.  Each buffer is
                // 4K.  By keeping the number small, we impact performamce
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxBuffers_OLD,
                                WinsCnf.NoOfDbBuffers,//200,
                                NULL        //ignored
                                   )
                        );
                //
                // The max. number of buffers to store old version of a
                // a record (snapshot at the start of a transaction)
                // Each version store is 16k bytes. A version store
                // stores structures that hold information derived from
                // a snapshot of the database prior to an insert (20 bytes
                // roughly) or update (size of the record + 20 bytes).
                //
                // For small transactions (i.e. a transaction around each
                // update), this number should be >= the max. number of
                // sessions that can be updating/inserting at the same time.
                // Each session will have one version bucket. Since 16k of
                // version bucket size can result in a lot of wastage per
                // session (since each record is < .5k, and on the average
                // around 50 bytes), it may be better to specify the
                // max. size of the version bucket (<< 16k).  Ian will
                //provide a system param for this if we absolutely need it
                //
                // 3/4/93
                //16kBytes should be enough for the transactions WINS does,
                //but if all the sessions are in transactions at the same time
                //and they all happen to have their small transactions traverse
                //2 buckets then the peak requirement is 2 buckets per session.
                //We could shorten the buckets to 8kBytes, or 4kBytes, and you
                //could allocate 2 per session?
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxVerPages_OLD,
                                MAX_NO_SESSIONS * 6, //10-4-95 Bump it up more
                                //MAX_NO_SESSIONS * 2,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the File Control Block Param
                //
                // This is the max. number of tables that can be open
                // at any time.  If multiple threads open the same table
                // they use the same FCB. FCB is 1 per table/index.
                // Now, for a create database, we need atleast 18 FCBS
                // and 18 IDBS.  However apart from create database and
                // ddl operations, we don't need to have these tables open.
                // Default value is 300. Size of an FCB is 112 bytes.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenTables_OLD,
                                56,     //18 + 10,
                                NULL        //ignored
                                   )
                        );


                //
                // Set the File Usage Control Block to 100.
                // This parameter indicates the max. number of cursors
                // that can be open at any one time.  This is
                // therefore dependent on the the max. number of sessions
                // that we can have running concurrently.  For each session,
                // there would be 4 cursors (for the two tables) + a certain
                // number of internal cursors.  For good measure we add
                // a pad. Default value is 300. Size of each is 200 bytes.
                // We use MAX_SESSIONS * 4 + pad
                // (around 100)
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxCursors_OLD,
                                (MAX_NO_SESSIONS * 8 /*4*/) + 32,
                                NULL        //ignored
                                   )
                        );

                //
                // Set the number of index description blocks
                // This is one per table/index.  We have two tables
                // each with two indices. We use 9 (see comment for
                // FCBs above).  Default value is 300.
                // Size of each is 128 bytes.
                //

                    CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramMaxOpenTableIndexes_OLD,
                                    56,         //18 + 10,
                                    NULL        //ignored
                                       )
                            );

                //
                // Set the Sort Control block.
                // This should be 1 per concurrent Create Index.
                // Default value is 20. Size of each is 612 bytes.
                // In the case of WINS, the main thread creates the
                // indices.  We should be setting it to 1. Let us
                // however set it to 3.
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxTemporaryTables_OLD ,
                                10,         //1 + 2,
                                NULL        //ignored
                                   )
                        );
                //
                // Set the Number for the Database Attribute Blocks
                //
                // This is max. number of Open Databases done.  Since we
                // can have a max of MAX_NO_SESSIONS at one time. This should
                // be equal to that number (since we have just one database)
                // Default number is 100. Size is 14 bytes
                //
                // JET_paramMaxOpenDatabase is removed.   Jonathan Liem (1/6/97)
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxOpenDatabases_OLD,
                                MAX_NO_SESSIONS * 4, //*2,
                                NULL        //ignored
                                   )
                        );

                //
                // The min percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldLowPrcnt_OLD,
                                80,
                                NULL        //ignored
                                   )
                        );

                //
                // The max percentage of buffers not yet dirtied before
                // background flushing begins
                //
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramBfThrshldHighPrcnt_OLD,
                                100,
                                NULL        //ignored
                                   )
                        );


                //
                // The max. number of sessions that can be open at any time
                //
                // Note: Jet does not preallocate resources corresponding
                // to the max. value.  It allocates them dynamically upto
                // the limit -- according to Ian Jose 7/12/93
                //
                // When checked with Ian again on 10/21, he said that they are
                // allocated STATICally
                //
CHECK("Make sure the comment above remains true")
FUTURES("Make sure the comment above remains true")
                CALL_M(JetSetSystemParameter(
                                &sJetInstance,
                                (JET_SESID)0,        //SesId - ignored
                                JET_paramMaxSessions_OLD,
                                MAX_NO_SESSIONS,
                                NULL        //ignored
                                   )
                        );

                //
                // Turn on logging if not prohibited by administrator
                //
                if (WinsCnf.fLoggingOn)
                {

FUTURES("Internationalize the following when jet is internationalized")
                        //
                        // Turn logging (recovery) on
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        30,                 // JET_paramRecovery_OLD not available,
                                        0,        //ignored
                                        "on"
                                                       )
                                        );


                        //
                        // The number of log sectors.  Each sector is
                        // 512 bytes.  We should keep the size more than
                        // the threshold so that if the threshold is reached
                        // and flushing starts, Jet can still continue to
                        // log in the spare sectors.  Point to note is that
                        // if the log rate is faster than the flush rate, then
                        // the Jet engine thread will not be able to log when
                        // the entire buffer is filled up.  It will then wait
                        // until space becomes available.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogBuffers_OLD,
                                        30,        //30 sectors
                                        NULL        //ignored
                                               )
                                        );

                        //
                        // Set the number of log buffers dirtied before they
                        // are flushed.  This number should always be less than
                        // the number for LogBuffers so that spare sectors
                        // are there for concurrent logging.  Also, we should
                        // make this number high enough to handle burst of
                        // traffic.
                        //
                            CALL_M(JetSetSystemParameter(
                                            &sJetInstance,
                                            (JET_SESID)0,        //SesId - ignored
                                            18, // JET_paramLogFlushThreshold,
                                            20,        //20 sectors dirtied causes
                                                    //flush
                                            NULL        //ignored
                                                   )
                                            );


                        //
                        // Set the wait time (in msecs) to wait prior to
                        // flushing the log on commit transaction to allow
                        // other users (sessions) to share the flush
                        //
                        //
                        // This is the time after which the user (a session)
                        // will ask the log manager to flush.  If we specify
                        // 0 here than it means flush every time a transaction
                        // commits.  In the WINS server case, every insertion
                        // or modification is done under an implicit
                        // transaction.  So, it means that there will be
                        // a flush after every such transaction.  It has
                        // been seen on a 486/66 (Cheen Liao) machine that
                        // it takes roughly 16 msecs to do the flush.  The
                        // time it takes to do the flush is dependent upon
                        // the type of disk (how fast it is), the CPU speed,
                        // the type of file system etc. We can for now
                        // go with the assumption that it is in the range
                        // 15-25 msecs.  I am pushing for this WaitTime to
                        // be made a session specific param so that it can
                        // be changed on the fly if the admin. finds that
                        // the WINS server is slow due to the WaitTime being
                        // very low or if it finds it to be so large that
                        // in case of a crash, there is possibility to loose
                        // a lot of data.
                        //
                        // Making this session specific is also very important
                        // for replication where we do want to set it to
                        // a high value (high enough to ensure that most
                        // of the records that need to be inserted are
                        // inserted before a flush action takes place.  The
                        // wait time would be set every time a bunch of
                        // records are pulled in for replication. It will
                        // be computed based on the number of records pulled
                        // in and the time it takes to insert one record in the
                        // jet buffer. The wait time should preferably be < than
                        // the above computed time (it does not have to be).
                        //
                        // NOTE: In the Pull thread, I will need to start
                        // two sessions, one for updating the OwnerId-Version
                        // number table (0 wait time) and the other to
                        // update the name-address mapping table (wait time
                        // computed based on the factors mentioned above)

                        //
                        // The following will set the WaitLogFlush time for
                        // all sessions.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramWaitLogFlush_OLD,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //

                        //
                        // set the log file path
                        //
FUTURES("Use DEFAULT_LOG_PATH after putting it in a header file")
                        if (WinsCnf.pLogFilePath == NULL)
                        {
                                //
                                // We should use the same directory as
                                // the one for system.mdb file
                                //

//                                pLogFilePath = ".\\wins";
                                WinsCnf.pLogFilePath = LOGFILE_PATH;
                                fFreeMem = FALSE;
                        }
                        else
                        {
#if 0
#ifdef UNICODE
                                CHAR        AsciiLogFilePath[WINS_MAX_FILENAME_SZ];
                                WinsMscConvertUnicodeStringToAscii(
                                        (LPBYTE)WinsCnf.pLogFilePath,
                                        AsciiLogFilePath,
                                        WINS_MAX_FILENAME_SZ
                                                );
                                pLogFilePath = (LPBYTE)AsciiLogFilePath;
#else
                                pLogFilePath = (LPBYTE)WinsCnf.pLogFilePath;
#endif
#endif
                        }

                        DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                        //
                        // Set the log file path.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogFilePath_OLD,
                                        0,        //ignored
                                        WinsCnf.pLogFilePath
                                        //pLogFilePath
                                                   )
                                              );

                        //
                        // Free this memory.  It is not needed any more
                        //
                        if (fFreeMem)
                        {
                           WinsMscDealloc(WinsCnf.pLogFilePath);
                        }
                }

    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath_OLD,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;

}

STATUS
SetSystemParams(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        if (DynLoadJetVersion >= DYN_LOAD_JET_600) {

            return SetSystemParamsJet600( fBeforeInit );
        }
        else if (DynLoadJetVersion == DYN_LOAD_JET_500)
        {

            return SetSystemParamsJet500( fBeforeInit );

        } else {

            return SetSystemParamsJet200( fBeforeInit );
        }
}


VOID
UpdHighestVersNoRecIfReqd(
        PWINSTHD_TLS_T                pTls,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T        pStatInfo
        )

/*++

Routine Description:
        This function is called to check if the record being replaced is
        the highest version number record owned by the local WINS. If so,
        the special record that records the highest version number reached
        for local records is updated to reflect the version number of the
        record to be replaced

Arguments:

        pTls          - ptr to thread local storage,
        pRowInfo - ptr to info of record to store in db
        pStatInfo - ptr to info of record to replace in db

Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        NmsDbUpdateRow, NmsDbSeekNUpdate

Side Effects:

Comments:
        This function is always called from inside the NmsNmhNamRegCrtSec
--*/
{
        VERS_NO_T        MyMaxVersNo;

        //
        //  Decrement the value of the vers. no. counter by 1
        //
        NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo,
                            MyMaxVersNo
                           );

        //
        // If a local record is being replaced by a replica, then only are we
        // interested in updating the special record
        //
        if ((pStatInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) && (pRowInfo->OwnerId
                        != NMSDB_LOCAL_OWNER_ID))
        {
                //
                // Check if the local record to be replaced has the highest
                // version number that we know of for local records
                //
                if (LiEql(pStatInfo->VersNo, MyMaxVersNo))
                {
                        //
                        // Update (or insert) the special record that records
                        // the highest version number reached
                        //
                        NmsDbUpdHighestVersNoRec(pTls, MyMaxVersNo, FALSE);
                }
        }

        return;
}

STATUS
NmsDbUpdHighestVersNoRec(
        IN PWINSTHD_TLS_T        pTls,
        IN VERS_NO_T                MyMaxVersNo,
        IN BOOL                        fEnterCrtSec
        )

/*++

Routine Description:

        This function is called to update the record that stores the
        highest version number reached for entries owned by the local WINS.

Arguments:
        pTls - Thread local storage

Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        NmsDbDoScavenging, UpdHighestVersNoRecIfReqd() in nmsdb.c

Side Effects:

Comments:
        None
--*/

{
        DWORD            OwnerId    = OWNER_ID_OF_SPEC_REC;
        DWORD           FldNo      = 0;
        JET_ERR         JetRetStat;
        DWORD           ActFldLen  = 0;  //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        DWORD           FlagVal = 0;
        COMM_ADD_T      Add;

        DBGENTER("NmsDbUpdHighestVersNoRec\n");

        //
        // pTls should be non NULL if this function was called by
        // UpdHighestVersNoRecIfReqd()
        //
        if (pTls == NULL)
        {
                GET_TLS_M(pTls);
                ASSERT(pTls != NULL);
        }
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        /*
        *  Set the clustered index as the current index
        */
        CALL_M(
                JetSetCurrentIndex( SesId,
                                            TblId,
                                            NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                  )
                      );
        //
        //
        //if called by UpdHighestVersNoRecIfReqd(), fEnterCrtSec should be
        // FALSE
        //
        if (fEnterCrtSec)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
        }

try {


        //
        // If the special record exists in the db, seek to it
        //
        if (sfHighestVersNoRecExists)
        {
             DBGPRINT2(DET, "NmsDbUpdHighestVersNoRec: REPLACING SPECIAL OWNER ID RECORD. New Version # = (%d %d)\n", MyMaxVersNo.HighPart, MyMaxVersNo.LowPart);
             //
             // If the special record's version number is less than the
             // version number passed to us, replace it with the new one
             //
             if (
                 (fEnterCrtSec == FALSE) ||
                 (LiGtr(MyMaxVersNo, sHighestVersNoSaved))
                 )
             {
                  CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        spHighestVersNoRecName,
                        sizeof(spHighestVersNoRecName),
                        JET_bitNewKey
                          )
                        );

                  CALL_M(JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                            )
                        );


                  CALL_M(JetBeginTransaction(SesId));
        try{
                  JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepReplace
                                );

                  if (
                     (JetRetStat != JET_errSuccess)
                               &&
                     (JetRetStat != JET_wrnNoWriteLock)
                     )
                  {
                       RET_M(JetRetStat);
                  }

                  //
                  // Update the version number
                  //
                  // add 5th column (this is the version number long(DWORD)
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &MyMaxVersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

                  //
                  // Update the record
                  //
                  CALL_M(JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                   )
                               );
        }
        finally {
                  if (AbnormalTermination())
                  {
                        CALL_M(JetRollback(SesId, JET_bitRollbackAll));
                  }
                  else
                  {
                        CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                          sHighestVersNoSaved = MyMaxVersNo;
                  }
               }
           }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET, "NmsDbUpdHighestVersNoRec: The record has a higher version number the one we wish to store. NO UPDATE IS BEING MADE\n");
                }
#endif
        }
        else  // special record not there
        {
           DWORD TimeStamp = MAXLONG;
           DBGPRINT2(DET, "NmsDbUpdHighestVersNoRec: INSERTING SPECIAL OWNER ID RECORD. Version # = (%d %d)\n", MyMaxVersNo.HighPart, MyMaxVersNo.LowPart);
                CALL_M(JetBeginTransaction(SesId));
           try {
                  JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepInsert
                                );

                  if (
                     (JetRetStat != JET_errSuccess)
                               &&
                     (JetRetStat != JET_wrnNoWriteLock)
                     )
                  {
                       RET_M(JetRetStat);
                  }

                 //
                 // Set the name
                 //
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                spHighestVersNoRecName,
                                sizeof(spHighestVersNoRecName),
                                0,
                                NULL /*optional info */
                                )
                    );



                 /* Set the owner byte        */
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                 )
                               );

                  //
                  // Set the version number
                  //
                  // add 5th column (this is the version number long(DWORD)
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &MyMaxVersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

                 //
                 // Set the flags column.  We mark it STATIC so that
                 // the scavenger thread does not pick it up for                                 // scavenging. Even if that were not the case, we still need
                 // to set this column  to avoid a JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecs).
                 //
                 NMSDB_SET_STATIC_M(FlagVal);
                 NMSDB_SET_STATE_M(FlagVal, NMSDB_E_ACTIVE);
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                 )
                               );

                 //
                 // set the timestamp column to avoid getting a
                 // JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecsByName).
                 //
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &TimeStamp,
                                sizeof(DWORD),  /*change type to TIME_STAMP_T
                                                 *later*/
                                0,
                                NULL /*optional info */
                                 )
                                    );

                 //
                 // set this address column  to avoid a JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecsByName).
                 //
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &Add,
                                sizeof(Add),
                                0,
                                NULL /*optional info */
                                 )
                               );
                  //
                  // Update the record
                  //
                  JetRetStat = JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                    );

            } // end of try block
            finally {

                  if (AbnormalTermination())
                  {
                        CALL_M(JetRollback(SesId, JET_bitRollbackAll));
                  }
                  else
                  {
                        if (JetRetStat == JET_errSuccess)
                        {
                          CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                        }
                        else
                        {
                          CALL_M(JetRollback(SesId, JET_bitRollbackAll));
                        }

                        //
                        // The only time we will get KeyDuplicate is if somebody
                        // entered the special name in the db.  In such a
                        // situation, we should mark the record as existent
                        // such that next time we end up replacing the
                        // offensive record. Replacing this record can be
                        // done right now but at this stage it is not worth
                        // the time required to test it. In any case, the
                        // probability of problems due to this are miniscule.
                        //
                        if ( (JetRetStat == JET_errSuccess) ||
                             (JetRetStat == JET_errKeyDuplicate))
                        {
#ifdef WINSDBG
                           if (JetRetStat == JET_errKeyDuplicate)
                           {
                                DBGPRINT0(ERR, "NmsDbUpdHighestVersNoRec: DUPLICATE SPECIAL OWNER ID RECORD\n");
                           }
#endif
                           sHighestVersNoSaved      = MyMaxVersNo;
                           sfHighestVersNoRecExists = TRUE;
                        }
                  }
               }
        }


 } // end of try { .. }
finally {
          if (fEnterCrtSec)
          {
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
          }

 }
        DBGLEAVE("NmsDbUpdHighestVersNoRec\n");
        return(WINS_SUCCESS);
}

STATUS
NmsDbDelDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo,
        BOOL             fEnterCrtSec,
        BOOL             fFragmentedDel
        )

/*++

Routine Description:
        This function is called to delete a specified range of records
        of a WINS from the local db

Arguments:
        pWinsAdd  - Address of owner WINS
        MinVersNo - Min. Vers. No
        MaxVersNo = Max. Vers. No

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        WinsDelDbRecs

Side Effects:

Comments:
        This function is called in the Pull thread or an RPC thread.
        On exit, it sets the index to the clustered index on the
        name-address table
--*/

{
        JET_ERR         JetRetStat;
        DWORD           ActFldLen; //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        VERS_NO_T       VersNo;
#if NEW_OWID
        DWORD            RecordOwnerId;
#else
        DWORD            RecordOwnerId = 0;
#endif

        DWORD           NoOfRecsUpd = 0;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fAllToBeDeleted = FALSE;
        //BOOL            fTransActive = FALSE;
        BOOL            fEntered = FALSE;
        DWORD           Count = 0;
        LONG            RetVal;

        DBGENTER("NmsDbDelDataRecs\n");


        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        if (fEnterCrtSec)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                fEntered = TRUE;
        }
        if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, VersNo);
        }
        else
        {
               if (WinsCnf.State_e != WINSCNF_E_INITING)
               {
                  EnterCriticalSection(&RplVersNoStoreCrtSec);
                  VersNo = (pRplPullOwnerVersNo+dwOwnerId)->VersNo;
                  LeaveCriticalSection(&RplVersNoStoreCrtSec);
               }
               else
               {
                   VersNo = (pRplPullOwnerVersNo+dwOwnerId)->VersNo;
               }
        }

        //
        // If both minimum and maximum version numbers specified are 0,
        // it means all the records of the WINS need to be deleted
        //
        if (LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo))
        {
                fAllToBeDeleted = TRUE;
        }
#if 0
        else
        {
                if (LiGtr(MinVersNo, VersNo))
                {
                      DBGPRINT4(DET, "NmsDbDelDataRecs: Wrong range to delete. Min. Vers. no (%d %d) is > the max. (%d %d) that this WINS server knows of.\n",
                        MinVersNo.HighPart, MinVersNo.LowPart,
                        VersNo.HighPart, VersNo.LowPart,
                        );

                       LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                       return(WINS_FAILURE);
                 }

                 //
                 // We should never attempt to delete a record that is not in
                 // our database currently
                 //
                 MaxVersNo = LiGtr(MaxVersNo, VersNo) ? VersNo : MaxVersNo;
        }
#endif

try {

        //
        // Let us make sure that the special record points to the highest
        // version number that we know of for local records.  Note:
        // When there is atleast one record of a higher version number
        // than the highest version numbered record to be deleted,
        // there is no need to update the special record. Checking
        // whether this is the case would be more overhead (in general).
        //We therefore use the strategem of always updating the special record.
        //
        if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                NmsDbUpdHighestVersNoRec(pTls, VersNo, FALSE);
        }

        //
        // Don't start a transaction since if the number of records are
        // huge, the transaction can become long in duration and JetDelete
        // may return an "out of Memory" error.
        //
        // Ian's comments on 8/26/94
        //
        // If you call JetDelete outside of any transaction, then JET
        // internally wraps a begin transction/commit trnasaction around the
        // delete.  Another user at transaction level 0 will immediately see
        // this change, but another user in a transction, i.e. at transaction
        // level 1 or greater, will not see this change until they return to
        // transaction level 0.

        //
        // Thus, you do not have to delete records in a transaction, unless
        // you are deleting multiple records which must be deleted atomically,
        // or which must be seen to be deleted atomically.
        //

        //CALL_M(JetBeginTransaction(SesId));
        //fTransActive = TRUE;

        do {

        if (fFragmentedDel && fEnterCrtSec && !fEntered)
        {
                 EnterCriticalSection(&NmsNmhNamRegCrtSec);
                 fEntered = TRUE;
        }

        CALL_M( JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &dwOwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                                        //first component of the key
                          )
              );

        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );

        if (JetRetStat != JET_errRecordNotFound)
        {
           do {

                   CALL_M(JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                     )
                    );

                   //
                   // if only tombstones are required, it means that we need
                   // all tombstones irrespective of owner
                   //
                   if (RecordOwnerId != dwOwnerId )
                   {
                      //
                      // We have exhausted all records for the owner. Break out
                      // of the loop
                      //
                      RetVal = -1; //to break out of the out loop
                      break;
                   }


                  //
                  // Retrieve the version number
                  //
                  CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &VersNo,
                                sizeof(VERS_NO_T),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                          );

                 //
                 // If MaxVersNo is not zero and VersNo retrieved is
                 // greater than it, break out of the loop.
                 //
                 // NOTE: fAllToBeDeleted is used instead of LiEqlZero()
                 // since the latter is a function call and would be
                 // costlier (this is the reason, why fAllToBeDeleted exists)
                 //
                 if (!fAllToBeDeleted && LiGtr(VersNo, MaxVersNo))
                 {
                     //
                     // We have acquired records upto MaxVersNo.  Break out
                     // of the loop
                     //
                     RetVal = -1;  // to break out of the outer loop
                     break;
                 }

                CALL_M(JetDelete(
                                SesId,
                                TblId
                                )
                        );

#ifdef WINSDBG
                 NmsDbDelDelDataRecs++;
#endif
                 NoOfRecsUpd++;
             } while(
                ((RetVal = JetMove(SesId, TblId, JET_MoveNext, 0)) >= 0)
                                    &&
                (++Count < 50)
                    );

             if (fFragmentedDel && fEntered)
             {
                 LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                 fEntered = FALSE;
                 MinVersNo = VersNo;
                 Count = 0;
             }
             if (RetVal < 0)
             {
                  break;
             }
        }
        else
        {
                DBGPRINT0(DET, "NmsDbDelDataRecs: There are no records to delete\n");
                RetStat = WINS_SUCCESS;
                break;
        }
      } while (TRUE);
} // end of try
finally {
#if 0
        if (AbnormalTermination())
        {
                if (fTransActive)
                {
                        CALL_M(JetRollback(SesId, JET_bitRollbackAll));
                }
        }
        else
        {
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
        }
#endif
        DBGPRINT3(SCV, "NmsDbDelDataRecs: Deleted records of owner id = (%d) in the range (%x - %x)\n", dwOwnerId, MinVersNo, VersNo);
        if (fEntered)
        {
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }



        //
        // Change the index to clustered
        //
        CALL_M( JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                   )
              );
  } // end of finally

        WinsEvtLogDetEvt(TRUE, WINS_EVT_DEL_RECS, NULL, __LINE__, "ddddd",
                  dwOwnerId, MinVersNo.LowPart, MinVersNo.HighPart,
                             VersNo.LowPart, VersNo.HighPart);

        DBGPRINT1(DET, "NmsDbDelDataRecs: No. Of. records deleted = (%d)\n",                        NoOfRecsUpd);
        DBGLEAVE("NmsDbDelDataRecs\n");
        return(RetStat);
}

STATUS
NmsDbTombstoneDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This function is called to tombstone a specified range of records
        of a WINS from the local db

Arguments:
        pWinsAdd  - Address of owner WINS
        MinVersNo - Min. Vers. No
        MaxVersNo = Max. Vers. No

Externals Used:
        None

Return Value:

Called by:
        WinsTombstoneDbRecs

Side Effects:

Comments:
        This function is called on RPC thread.
        On exit, it sets the index to the clustered index on the
        name-address table
--*/

{
        JET_ERR         JetRetStat;
        DWORD           ActFldLen; //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        DWORD            RecordOwnerId = 0;
        DWORD           NoOfRecsUpd = 0;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fAllToBeTombstoned = FALSE;
        DWORD           Count = 0;
        LONG            RetVal;
        BOOL            fIncVersNo;
        VERS_NO_T       VersNo;
        DWORD           FlagVal;
        BOOL            LockHeld = FALSE;
        BOOL            UpdateOwnerId = FALSE;
        DWORD_PTR       NewTimeStamp;
        time_t                  CurrentTime;
        DWORD           dwNewOwnerId;

        DBGENTER("NmsDbTombstoneDataRecs\n");


        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        (void)time(&CurrentTime);
        NewTimeStamp = CurrentTime + WinsCnf.TombstoneTimeout;
        DBGPRINT1(DET, "NmsDbTombstoneDataRecs: The new tombstone Time is %.19s\n",
                  asctime(localtime(&NewTimeStamp)));

        if (NMSDB_LOCAL_OWNER_ID != dwOwnerId) {
            UpdateOwnerId = TRUE;
            dwNewOwnerId = NMSDB_LOCAL_OWNER_ID;
        }

        // If both minimum and maximum version numbers specified are 0,
        // it means all the records of the WINS need to be deleted
        if (LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo)){
            if (NMSDB_LOCAL_OWNER_ID == dwOwnerId) {
                MaxVersNo = NmsNmhMyMaxVersNo;
            } else {
                fAllToBeTombstoned = TRUE;
            }
        }

        CALL_N_JMP_M( JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   ),
                      Cleanup
              );
        CALL_N_JMP_M( JetMakeKey(
                                SesId,
                                TblId,
                                &dwOwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                          ),
                      Cleanup
              );
        CALL_N_JMP_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                          ),
                      Cleanup
              );
        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );
        if (JetRetStat == JET_errRecordNotFound) {
                DBGPRINT0(DET, "NmsDbTombstoneDataRecs: There are no records to tombstone\n");
                RetStat = WINS_FAILURE;
                goto Cleanup;
        }
        if (JetRetStat != JET_errSuccess && JetRetStat != JET_wrnSeekNotEqual) {
            DBGPRINT1(ERR, "NmsDbTombstoneDataRecs: JetSeek failed with %ld\n",JetRetStat);
            RetStat = WINS_FAILURE;
            goto Cleanup;
        }
        while (TRUE) {
            // tombstone 50 recs at a time so that we dont hold crit section
            // for long time.
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
            LockHeld = TRUE;

            do {
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                         SesId,
                         TblId,
                         sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                         &RecordOwnerId,
                         NAM_ADD_OWNERID_SIZE,
                         &ActFldLen,
                         0,
                         NULL),
                    Cleanup
                );
                if (RecordOwnerId != dwOwnerId ){
                  // We have exhausted all records for the owner. Break of the loop
                  goto Cleanup;
                }
                // Retrieve the version number
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                            SesId,
                            TblId,
                            sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                            &VersNo,
                            sizeof(VERS_NO_T),
                            &ActFldLen,
                            0,
                            NULL),
                    Cleanup
                );

                DBGPRINT2(DET, "NmsDbTombstoneDataRecs: tombstone record - (%lx - %lx)\n", VersNo.HighPart, VersNo.LowPart);
                // If MaxVersNo is not zero and VersNo retrieved is
                // greater than it, break out of the loop.
                if (!fAllToBeTombstoned && LiGtr(VersNo, MaxVersNo)){
                    // We have acquired records upto MaxVersNo.  Break of the loop
                    goto Cleanup;
                }
                // retrieve the flags column
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                            SesId,
                            TblId,
                            sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                            &FlagVal,
                            sizeof(FlagVal),
                            &ActFldLen,
                            0,
                            NULL
                            ),
                    Cleanup
                );

                CALL_N_JMP_M(JetBeginTransaction(SesId),Cleanup);
                try {
                    CALL_N_RAISE_EXC_IF_ERR_M( JetPrepareUpdate(
                                                    SesId,
                                                    TblId,
                                                    JET_prepReplace
                                                    )
                    );

                    // make it tombstone.
                    NMSDB_SET_STATE_M(FlagVal,NMSDB_E_TOMBSTONE);

                    // Update the flags field
                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                )
                    );

                    VersNo = NmsNmhMyMaxVersNo;

                    // Update the version number field so that this record gets
                    // propagated eventually
                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &VersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                    );

                    if (UpdateOwnerId) {
                        CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                    SesId,
                                    TblId,
                                    sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                    &dwNewOwnerId,
                                    NAM_ADD_OWNERID_SIZE,
                                    0,
                                    NULL /*optional info */
                                    )
                        );
                    }


                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &NewTimeStamp,
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                    );

                    // Update the record
                    CALL_N_RAISE_EXC_IF_ERR_M(JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                )
                    );

                } // end of try block
                finally {
                    if (AbnormalTermination()){
                        CALL_N_JMP_M(JetRollback(SesId,JET_bitRollbackAll), Cleanup);
                    }else{
                        CALL_N_JMP_M(JetCommitTransaction(SesId,JET_bitCommitFlush), Cleanup);
                        NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                        NoOfRecsUpd++;
                    }
                }
            } while(((RetVal = JetMove(SesId, TblId, JET_MoveNext, 0)) >= 0)&&(++Count < 50));

            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
            LockHeld = FALSE;
            DBGPRINT2(SCV, "NmsDbTombstoneDataRecs: tombstoned records %ld, RetVal %ld, \n", Count, RetVal);
            Count = 0;
            if (RetVal < 0) {
                break;
            }
        }

        DBGPRINT3(SCV, "NmsDbTombstoneDataRecs: tombstone records of owner id = (%d) in the range (%x - %x)\n", dwOwnerId, MinVersNo, VersNo);
        WinsEvtLogDetEvt(TRUE, WINS_EVT_DEL_RECS, NULL, __LINE__, "ddddd",
                  dwOwnerId, MinVersNo.LowPart, MinVersNo.HighPart,
                             VersNo.LowPart, VersNo.HighPart);


Cleanup:
        // Change the index to clustered
        JetSetCurrentIndex(
            pTls->SesId,
            pTls->NamAddTblId,
            NMSDB_NAM_ADD_CLUST_INDEX_NAME
            );


        if (!LockHeld) {
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
        }
        if (NoOfRecsUpd)  RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);


        DBGPRINT1(DET, "NmsDbTombstoneDataRecs: No. Of. records tombstoned = (%d)\n",NoOfRecsUpd);
        DBGLEAVE("NmsDbTombstoneDataRecs\n");
        return(RetStat);
}


STATUS
NmsDbSetFlushTime(
        DWORD WaitTime
        )

/*++

Routine Description:
        This function is called to set a session specific flush time

Arguments:
        WaitTime - Time in msecs to wait after a commit

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/
{
        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);


        if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
            CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    pTls->SesId,
                                    JET_paramWaitLogFlush,
                                    WaitTime,
                                    NULL        //ignored
                                           )
                                    );
        } else {
            CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    pTls->SesId,
                                    JET_paramWaitLogFlush_OLD,
                                    WaitTime,
                                    NULL        //ignored
                                           )
                                    );
        }

        return(WINS_SUCCESS);
}

STATUS
NmsDbOpenTables(
        WINS_CLIENT_E        Client_e //client
        )

/*++

Routine Description:
        This function opens one or both of name-address mapping and
        owner-address mapping tables.  It further starts a transaction

Arguments:

        Client_e - Client

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        //
        // Open the name to address mapping table
        //

        CALL_N_RAISE_EXC_IF_ERR_M( JetOpenTable(
                        pTls->SesId,
                        pTls->DbId,
                        NMSDB_NAM_ADD_TBL_NM,
                        NULL, /*ptr to parameter list; should be
                                       *non-NULL only if a query is being
                                       *opened (not the case here)*/
                        0,  /*Length of above parameter list*/
                        0,  //shared access
                        &pTls->NamAddTblId
                             )
              );

//        DBGPRINT2(SPEC, "NmsDbOpenTables: OPENED NAME-ADD table for client = (%d). Table id is (%x)\n", Client_e, pTls->NamAddTblId);

        pTls->fNamAddTblOpen = TRUE;

        /*
         *  If the client is not the replicator (i.e. it is the Name Space
         *  Manager (Nbt thread) or an RPC thread, we want to set the current
         *  index on the Name Address Mapping table to the clustered index.
         *  We are not interested in the Owner to Address Mapping table in the
         *  database (it has already been read into the in-memory table
         *  NmsDbOwnAddTbl which is what we are interested in).
         */
        if (
                (Client_e != WINS_E_RPLPULL)
                        &&
                (Client_e != WINS_E_RPLPUSH)
                        &&
                (Client_e != WINS_E_NMSSCV)
           )
        {
                /*
                  Set the clustered index as the current index
                */
                       CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                        pTls->SesId,
                        pTls->NamAddTblId,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                 )
                            );

        }
        else
        {
                /*
                 * The client is a replicator thread.
                 */
                if (Client_e == WINS_E_RPLPUSH)
                {
                        /*
                           * Set the primary index as the current index
                        */
                               CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                        pTls->SesId,
                                        pTls->NamAddTblId,
                                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                                   )

                                            );
                }
                else  // it is the PULL thread
                {

                        /*
                           *Set the clustered index as the current index
                        */
                               CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                                pTls->SesId,
                                                pTls->NamAddTblId,
                                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                                   )
                                          );
                }

                CALL_N_RAISE_EXC_IF_ERR_M( JetOpenTable(
                                pTls->SesId,
                                pTls->DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL only if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access
                                &pTls->OwnAddTblId
                                          )
                      );

 //               DBGPRINT2(SPEC, "NmsDbOpenTables: Opened OWN-ADD table for client = (%d). Table id is (%x)\n", Client_e, pTls->OwnAddTblId);

                pTls->fOwnAddTblOpen = TRUE;

                /*
                  Set the clustered index as the current index
                */
                       CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                pTls->SesId,
                                pTls->OwnAddTblId,
                                NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                           )

                            );
        }

        return(WINS_SUCCESS);
}

STATUS
NmsDbCloseTables(
        VOID
        )

/*++

Routine Description:
        This function is called to close the tables that were opened

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        if (pTls->fNamAddTblOpen)
        {
                CALL_N_RAISE_EXC_IF_ERR_M(JetCloseTable(
                                pTls->SesId,
                                pTls->NamAddTblId
                                    )
                       );

//               DBGPRINT1(SPEC, "NmsDbCloseTables: CLOSED NAME-ADD table. Table id is (%x)\n", pTls->NamAddTblId);
                pTls->fNamAddTblOpen = FALSE;
        }

        if (pTls->fOwnAddTblOpen)
        {
                CALL_N_RAISE_EXC_IF_ERR_M(JetCloseTable(
                                pTls->SesId,
                                pTls->OwnAddTblId
                                    )
                                      );
//                DBGPRINT1(SPEC, "NmsDbCloseTables: CLOSED NAME-ADD table. Table id is (%x)\n", pTls->OwnAddTblId);
                pTls->fOwnAddTblOpen = FALSE;
        }

        return(WINS_SUCCESS);
}



STATUS
NmsDbGetNamesWPrefixChar(
        IN  BYTE                         PrefixChar,
        OUT PWINSINTF_BROWSER_INFO_T     *ppInfo,
        OUT LPDWORD                         pEntriesRead
        )

/*++

Routine Description:
        This function retrieves all records starting with PrefixChar

Arguments:
        PrefixChar        - Prefix character
        ppInfo          - address of pointer to info structure
        pEntriesRead        - Entries read

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        WinsGetNames

Side Effects:

Comments:
        None
--*/

{
        PWINSTHD_TLS_T  pTls;
        volatile DWORD           Iter = 0;
        JET_SESID       SesId;
        JET_TABLEID     TblId;
        JET_ERR         JetRetStat;
        DWORD           Flag;
        DWORD           ActFldLen;  //length of fld retrieved
        PWINSINTF_BROWSER_INFO_T     pInfo;
        STATUS          RetStat = WINS_SUCCESS;

        DWORD           CommitCnt = 1;          //the number of commits already done - do not change
        BOOL            fTransCommitted = TRUE; // says whether the last commit should be done or not
        DWORD           dwEntriesAvailable;     // number of records for which storage is available


        DBGENTER("NmsDbGetNamesWPrefixChar\n");

        //
        // Initialize the out args to default values
        //
        *pEntriesRead = 0;
        *ppInfo       = NULL;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        SesId = pTls->SesId;
        TblId = pTls->NamAddTblId;

        CALL_M(JetBeginTransaction(SesId));
        fTransCommitted = FALSE;
try {

        // dwEntriesAvailable shows how many records were found during the first iteration
        // (when it is incremented) and how many records are to be read during the second
        // iteration (when it is decremented)
        dwEntriesAvailable = 0;

        //
        // We iterate a max of two times, the first time to get the
        // count of records and the second time to get the records
        //
        while(Iter < 2)
        {
           //
           // Seek to the first record starting with 1B character
           //
           CALL_N_JMP_M( JetMakeKey(
                        SesId,
                        TblId,
                        &PrefixChar,
                        sizeof(BYTE),
                        JET_bitNewKey
                          ), ErrorProc
                        );
           if ((JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekGE
                                  )) != JET_errRecordNotFound)
           {

                BYTE  Name[NMSDB_MAX_NAM_LEN];
                DWORD NameLen;

                if (JetRetStat != JET_wrnSeekNotEqual)
                {
                        CALL_N_JMP_M(JetRetStat, ErrorProc);
                }

                //
                // Move one record at a time until we get to a record that
                // does not have 1B as the starting prefix.
                //
                do
                {
                    BOOL bFiltered;

                    //
                    // retrieve the name
                    //
                    CALL_N_JMP_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &NameLen,
                        0,
                        NULL
                                     ), ErrorProc
                         );

                    //
                    // Check if the first character is 1B
                    //
                    if (Name[0] != PrefixChar)
                    {
                        break;
                    }
                    if ((NameLen < WINS_MAX_NS_NETBIOS_NAME_LEN) || (Name[NameLen - 2] == 0))
                    {
                        continue;
                    }

                    // --ft:10/18/00
                    // Add 1B name filtering here, if there is a filter specified for 1B names
                    //
                    EnterCriticalSection(&g_cs1BFilter);
                    bFiltered = IsNmInFilter(g_p1BFilter, Name, WINS_MAX_NS_NETBIOS_NAME_LEN-1);
                    LeaveCriticalSection(&g_cs1BFilter);
                    
                    if (!bFiltered)
                        continue;
                    //
                    // --tf

                    if (Iter == 1)
                    {

                      //
                      // Retrieve the flag byte
                      //
                      CALL_N_JMP_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &Flag,
                                sizeof(Flag),
                                &ActFldLen,
                                0,
                                NULL
                                     ), ErrorProc
                                  );


                      if (!NMSDB_ENTRY_ACT_M(Flag))
                      {
                           continue;
                      }

                      // specify the length of the string otherwise RPC
                      // will transport up to the first '\0'. For shorter names this would lead
                      // to loosing the record type on the way..
                      pInfo->dwNameLen = NameLen;
                      pInfo->pName = midl_user_allocate(NameLen + 1);
                      RtlMoveMemory(pInfo->pName, Name, NameLen);

                      // add this to make sure RPC doesn't go over limits.
                      // RPC is seeing pName as 'string' which makes it to pick up bytes
                      // up to the first '\0'.
                      // This hides a bug for names that contain extended chars (with '\0'
                      // somewhere in the middle) but fixing this breaks compatibility with
                      // Win2K (querying Win2K results in RPC not being able to unmarshall
                      // the responses and causing WinsGetBrowser to fail entirely).
                      pInfo->pName[NameLen] = '\0';

                      //
                      // Swap the first and 16th byte
                      //
                      WINS_SWAP_BYTES_M(pInfo->pName,
                                        pInfo->pName + 15
                                       );
                      pInfo++;

                      // increment the number of records that have been retrieved
                      (*pEntriesRead)++;

                      // check if there remains storage for more entries
                      dwEntriesAvailable--;

                      // if no memory available, break the loop
                      if (dwEntriesAvailable == 0)
                          break;

                    }
                    else
                    {
                        dwEntriesAvailable++;
                        // increment pEntriesRead here just to be able to control
                        // the granularity of [BeginTransaction()..CommitTransaction()] during both
                        // iterations
                        (*pEntriesRead)++;
                    }

                   //
                   // decrease the granularity of [BeginTransaction()..CommitTransaction()] intervals
                   //
                   if (*pEntriesRead/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
                   {
                       CALL_M(
                                JetCommitTransaction(SesId, JET_bitCommitFlush)
                                    );
                       fTransCommitted = TRUE;
                       CommitCnt++;
                       CALL_M( JetBeginTransaction(SesId) );
                       fTransCommitted = FALSE;
                   }

                } while(JetMove(SesId, TblId, JET_MoveNext, 0) >= 0);

                //
                // If we found records, allocate memory to store them
                //
                if ((Iter == 0) && (dwEntriesAvailable != 0))
                {
                   *ppInfo        =  midl_user_allocate(dwEntriesAvailable *
                                           sizeof(WINSINTF_BROWSER_INFO_T));
                   pInfo = *ppInfo;
                   // reset the pEntriesRead, as from now on it will really count the records that have been retrieved.
                   *pEntriesRead = 0;
                }
                else
                {
                    // either two iterations already done, or no entries detected during the first iteration.
                    // break the loop in either case, otherwise AV could happen or even worse, other locations
                    // from the memory space of the same process might get overwritten.
                    break;
                }

                Iter++;
         }
         else
         {
              //
              // If we failed in the first seek, initialize the out vars
              // to indicate that there are no records.  If we failed in
              // the second seek, set return status to WINS_FAILURE, so
              // that we do any cleanup that is required
              //
              if (Iter == 0)
              {
                *pEntriesRead = 0;
                *ppInfo       = NULL;
              }
              else
              {
                 RetStat = WINS_FAILURE;
              }
              break;    //break out of the while loop
         }

         //
         // if no entries were read from the db, break;
         //
         if (dwEntriesAvailable == 0)
         {
              break;
         }

     } // end of while
  }
except(EXCEPTION_EXECUTE_HANDLER) {
           DWORD ExcCode = GetExceptionCode();
           DBGPRINT1(EXC, "NmsDbGetNamesWPrefixChar. Got Exception (%x)",
                                        ExcCode);
           WINSEVT_LOG_M(ExcCode, WINS_EVT_BROWSER_NAME_EXC);
           RetStat = WINS_FAILURE;
        }

        if (RetStat == WINS_SUCCESS)
        {
             goto Done;
        }
ErrorProc:
        //
        // if memory was allocated, do cleanup
        //
        if (*ppInfo != NULL)
        {
             //
             // If any memory was allocated for names, free it
             //
             pInfo = *ppInfo;
             while (*pEntriesRead > 0)
             {
                 midl_user_free(pInfo++->pName);
                 (*pEntriesRead)--;
             }
             //
             // Free the main block
             //
             midl_user_free(*ppInfo);

             //
             // Reinit the out args to indicate no records to the client
             //
             *ppInfo       = NULL;
             *pEntriesRead = 0;
        }
        RetStat = WINS_FAILURE;

Done:

        if (!fTransCommitted)
            CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
        DBGLEAVE("NmsDbGetNamesWPrefixChar\n");
        return(RetStat);

} // NmsDbGetNamesWPrefixChar

STATUS
NmsDbCleanupOwnAddTbl(
        LPDWORD        pNoOfOwners
        )

/*++

Routine Description:
        This function is called by the scavenger thread to cleanup
        the OwnAdd Table
Arguments:
        SesId - Jet Session id
        TblId - Table Id of the Name-Address Mapping table

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
     This function returns the highest owner id found.
--*/

{
        DWORD           OwnerId;
#if NEW_OWID
        DWORD           TmpOwnerId;
#else
        DWORD           TmpOwnerId = 0;
#endif
        DWORD          ActFldLen;
        JET_ERR        JetRetStat;
        PWINSTHD_TLS_T pTls;
        JET_SESID      SesId;
        JET_TABLEID    TblId;
        BOOL           fNoOfOwnersInited = FALSE;
        DWORD          No;
        STATUS         RetStat = WINS_SUCCESS;

        DBGENTER("NmsDbCleanupOwnAddTbl\n");
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        SesId = pTls->SesId;
        TblId = pTls->NamAddTblId;

        /*
         * Set the primary index as the current index
        */
        CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
                      );

        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        *pNoOfOwners = NmsDbNoOfOwners;
try {

        OwnerId = NmsDbNoOfOwners;
        do
        {

                  DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: will seek for owner less than = (%d)\n", OwnerId);
                 //
                 // Construct a partial key made of owner id.
                 //
                 CALL_N_RAISE_EXC_IF_ERR_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
                        );

                  //
                  // Seek to the record that has a key that is Less than or
                  // Equal to the OwnerId value.
                  //
                  // Since we have specified a partial key (saying in effect
                  // that the other component of the key is NULL), JetSeek
                  // must return wrnSeekNotEqual since it will never find
                  // a record with NULL for the second component of the index
                  // -- Ian 7/13/93
                  //
                  JetRetStat = JetSeek(
                                              SesId,
                                              TblId,
                                              JET_bitSeekLE
                                      );

                  //
                  // If we found a record
                  //
                  if (JetRetStat != JET_errRecordNotFound)
                  {
                    ASSERT(JetRetStat == JET_wrnSeekNotEqual);

                    /*
                     * Retrieve the owner Id column.
                    */
                       CALL_N_RAISE_EXC_IF_ERR_M(
                          JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &TmpOwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     JET_bitRetrieveFromIndex,
                                     NULL
                                                 )
                                      );

                   if(!fNoOfOwnersInited)
                   {
                     //
                     // We want to return the highest owner id that we find.
                     // not the number of owners.  The param. name is
                     // misleading
                     //
                     *pNoOfOwners      = TmpOwnerId;
                     fNoOfOwnersInited = TRUE;
                   }

                  DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: records found for owner id = (%d)\n", TmpOwnerId);
                   //
                   // Mark all those records in the owner-address table
                   // that don't have corresponding records in the
                   // name - address table
                   //
                   if (OwnerId >= 1)
                   {
                     for (No = OwnerId - 1; No > TmpOwnerId; No--)
                     {

                        if ((pNmsDbOwnAddTbl+No)->WinsState_e ==
                                                NMSDB_E_WINS_ACTIVE)
                        {
                          //
                          // We may have deleted this entry in an earlier
                          // invocation.  If so, we bypass the deletion here.
                          //
                          if ((pNmsDbOwnAddTbl+No)->WinsState_e !=
                                                      NMSDB_E_WINS_DELETED)
                          {
                             DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: Deleting WINS with owner id = (%d)\n", No);
                             (pNmsDbOwnAddTbl+No)->WinsState_e = NMSDB_E_WINS_DELETED;
                             NmsDbWriteOwnAddTbl(
                                        NMSDB_E_DELETE_REC,
                                        No,
                                        NULL,
                                        NMSDB_E_WINS_DELETED,
                                        NULL,
                                        NULL
                                          );
                          }
                          else
                          {
                               DBGPRINT1(DET, "NmsDbCleanupOwnAddTbl: Owner Id (%d) is already in DELETED state\n", OwnerId);
                          }
                        }

                     }


                     //
                     // Make OwnerId = the max owner id that we found.
                     //
                     OwnerId = TmpOwnerId;
                   }
                   else
                   {
                        //
                        // Owner Id is 0, our job is done
                        //
                        break;
                   }
                }
                else  //record not found
                {
                           if(!fNoOfOwnersInited)
                           {
                                //
                                // Since fNoOfOwnersInited is FALSE, we
                                // did not find even one record
                                //
                                DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: THERE IS NOT EVEN ONE REPLICA RECORD IN THE DB. No of owners in Own-Add Tbl are (%d)\n",
                                        NmsDbNoOfOwners
                                        )
                                *pNoOfOwners      = 0;
                           }
                           if (OwnerId > 0)
                           {
                               for (No = OwnerId - 1; No > 0; No--)
                               {

                               DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: Deleting WINS with owner id = (%d)\n", No);
                               if ((pNmsDbOwnAddTbl+No)->WinsState_e ==
                                                NMSDB_E_WINS_ACTIVE)
                               {
                                   (pNmsDbOwnAddTbl+No)->WinsState_e =
                                                     NMSDB_E_WINS_DELETED;
                                   NmsDbWriteOwnAddTbl(
                                        NMSDB_E_DELETE_REC,
                                        No,
                                        NULL,
                                        NMSDB_E_WINS_DELETED,
                                        NULL,
                                        NULL
                                          );
                               }

                               } // end of for
                           }
                           //
                           // No more records in the db. Break out of the loop
                           //
                           break;
                }

        } while (TRUE);
} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "NmsDbCleanupOwnAddTbl: Got exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_CLEANUP_OWNADDTBL_EXC);
        RetStat = WINS_FAILURE;
        }

        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
        DBGLEAVE("NmsDbCleanupOwnAddTbl\n");
        return(RetStat);
}


STATUS
NmsDbBackup(
    LPBYTE  pBackupPath,
    DWORD   TypeOfBackup
    )

/*++

Routine Description:
    This function is called to backup the jet db

Arguments:
    pBackupPath - backup dir
    fIncremental - indicates whether the backup is incremental/full

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{
  JET_ERR   JetRetStat;
  DWORD     RetStat = WINS_SUCCESS;
  static BOOL      sFullBackupDone = FALSE;
  BOOL        fBackupChanged = FALSE;

  DBGENTER("NmsDbBackup\n");
  if (pBackupPath != NULL)
  {
     DBGPRINT2(FLOW, "NmsDbBackup:Backup path = (%s).\n Type of Backup = (%s)\n", pBackupPath, TypeOfBackup == NMSDB_FULL_BACKUP ? "FULL" : "INCREMENTAL");
  }
  else
  {
     DBGPRINT0(FLOW, "NmsDbBackup. Null Backup path\n");
  }

  //
  // If we have to do an incremental backup to a non-null directory and we
  // haven't ever done a full back in this instance of WINS, we do a full
  // backup
  //
  if ((pBackupPath != NULL) && (TypeOfBackup  != NMSDB_FULL_BACKUP) && !sFullBackupDone)
  {
       TypeOfBackup = NMSDB_FULL_BACKUP;
       fBackupChanged = TRUE;
  }
      if (DynLoadJetVersion >= DYN_LOAD_JET_500)
      {
          JetRetStat = JetBackup(pBackupPath, (ULONG)TypeOfBackup, NULL);

      }
      else
      {
          JetRetStat = JetBackup(pBackupPath, (ULONG)TypeOfBackup);

      }
      if (JetRetStat != JET_errSuccess)

      {

          DBGPRINT3(ERR, "NmsDbBackup: Could not do %s backup to dir (%s). Error from JetBackup is (%d)\n", TypeOfBackup == NMSDB_FULL_BACKUP ? "FULL" : "INCREMENTAL", pBackupPath, JetRetStat);

          WinsEvtLogDetEvt(FALSE, WINS_EVT_BACKUP_ERR, NULL, __LINE__,
                    "sd", pBackupPath, JetRetStat);

          RetStat = WINS_FAILURE;
      }
      else
      {
        //
        // Backup was successful. Let us set the static flag to indicate that.
        //
        if (fBackupChanged)
        {
          sFullBackupDone = TRUE;
          fBackupChanged  = FALSE;
        }
      }


  DBGLEAVE("NmsDbBackup\n");
  return(RetStat);
}


STATUS
NmsDbGetDataRecsByName(
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           Location,
  DWORD           NoOfRecsDesired,
  PCOMM_ADD_T     pWinsAdd,
  DWORD           TypeOfRecs,
  LPVOID          *ppRBuf,
  LPDWORD         pRspBuffLen,
  LPDWORD         pNoOfRecsRet
 )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
        JET_ERR             JetRetStat = JET_errSuccess;
        DWORD                OwnerId;
        DWORD               ActFldLen; //length of fld retrieved
        VERS_NO_T           TmpNoOfEntries;
        LPBYTE              pStartBuff;
        DWORD               SaveBufLen;
        BYTE                EntTyp; //type of entry (unique/group/special group)
        PRPL_REC_ENTRY2_T   pRspBuf;
        JET_TABLEID         TblId;
        JET_SESID           SesId;
        PWINSTHD_TLS_T      pTls;
#if NEW_OWID
        DWORD                RecordOwnerId;
#else
        DWORD               RecordOwnerId = 0;
#endif
        STATUS              RetStat = WINS_SUCCESS;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               InitHeapSize;
        LONG                MoveDir = JET_MoveNext;
        DWORD               MemSize;

#ifdef WINSDBG
        DWORD               StartTime;
        DWORD               EndTime;
#endif

        BOOL            fAllocNew;
        BOOL            fTransCommitted = TRUE; // says whether the last commit should be done or not
        DWORD           CommitCnt = 1;          //the number of commits already done - do not change

        DBGENTER("NmsDbGetDataRecsByName\n");

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


#ifdef WINSDBG
         if (pWinsAdd != NULL)
         {
           struct in_addr  InAddr;
           InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
           DBGPRINT3(DET, "NmsDbGetDataRecsByName:Will retrieve %d records starting from record with name (%s) of WINS having address = (%s)\n",
                   NoOfRecsDesired, pName, inet_ntoa(InAddr) );
         }
         else
         {
           DBGPRINT2(DET, "NmsDbGetDataRecsByName:Will retrieve %d records starting from record with name (%s)\n", NoOfRecsDesired, pName);
         }
#endif

        //
        // initialize the default no. that determines the size of the
        // buffer to allocate in case the range specified by the Max and
        // Min Vers. No args is > it
        //
PERF("Move this to NmsDbInit")
        WINS_ASSIGN_INT_TO_VERS_NO_M(TmpNoOfEntries, NoOfRecsDesired);
        pTls->HeapHdl = NULL;  //make it NULL so that the caller can determine
                               //whether this function allocated a heap
                               //before returning (normally/abnormally)


        //
        // Store the memory size for the records.  Note: This
        // does not contain the memory for the name and addresses
        // (in case of a special group or a multihomed entry). The
        // sizes for these will be added as we store each record.
        //
//        MemSize     = RPL_REC_ENTRY_SIZE *  (TmpNoOfEntries.LowPart + 1);
        MemSize     = RPL_REC_ENTRY2_SIZE *  (DWORD)(TmpNoOfEntries.QuadPart + 1);
        *pRspBuffLen = MemSize + 10000; //for good measure;


        //
        // We will create a heap with the above amount of memory plus a
        // pad for heap overhead.  We add TmpNoOfEntries.LowPart * 17
        // since each record will have memory allocated for the name.
        // Names in general will be 17 bytes long (we attach a NULL at the
        // end when registering names).
        //
//        InitHeapSize = *pRspBuffLen + (TmpNoOfEntries.LowPart * 17)
        InitHeapSize = *pRspBuffLen + ((DWORD)(TmpNoOfEntries.QuadPart * 17)
                                        + PAD_FOR_REC_HEAP);

        //
        // Create the heap
        //
        pTls->HeapHdl = WinsMscHeapCreate(0, InitHeapSize);

        pRspBuf = WinsMscHeapAlloc(pTls->HeapHdl, MemSize);

        pStartBuff  = (LPBYTE)pRspBuf;        //save start of buffer
        SaveBufLen  = MemSize;                //save size of buffer
        *pNoOfRecsRet  = 0;

        *ppRBuf  = pStartBuff;

        //
        // Actually, we can call RplFindOwnerId for Scavenger thread
        // We choose not to do so to avoid some overhead -- see the
        // comment in the else block.
        //
        if (pWinsAdd != NULL)
        {
          fAllocNew =  FALSE;
          try {
              if (RplFindOwnerId(
                            pWinsAdd,
                            &fAllocNew,
                            &OwnerId,
                            WINSCNF_E_IGNORE_PREC,
                            WINSCNF_LOW_PREC
                            ) != WINS_SUCCESS
                  )
                {
                        //
                        // The client may not look at the return value, but
                        // it will look at the *pNoOfRecs value and thus
                        // determine that there are no records.
                        //
                        return(WINS_FAILURE);
                }
             }
            except(EXCEPTION_EXECUTE_HANDLER) {
                        DWORD  ExcCode = GetExceptionCode();
                        DBGPRINT1(EXC,
                              "NmsDbGetDataRecsByName: Got exception %x",
                                        ExcCode);
                        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_RETRIEVE_DATA_RECS);
                        return(WINS_FAILURE);
                }

               //
               //It is ok not to enter a critical section here since even if
               //the array entry is being changed at this time, the repercussion
               //  of us seeing the old value is insignificant
               //
               if ((OwnerId != NMSDB_LOCAL_OWNER_ID) && LiEqlZero((pRplPullOwnerVersNo+OwnerId)->VersNo))
               {
                 DBGPRINT2(DET, "NmsDbGetDataRecsByName: WINS with address = (%x) and owner id = (%d) has 0 records in the db\n", pWinsAdd->Add.IPAdd, OwnerId);
                 return(WINS_SUCCESS);
               }
        }
        /*
        *  start a transaction
        */

        CALL_M(JetBeginTransaction(pTls->SesId));
        fTransCommitted = FALSE;
try {
        if ((pName != NULL) || ((pName == NULL) && (Location != WINSINTF_END)))
        {
          CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pName,
                        NameLen,
                        JET_bitNewKey
                          )
              );

          JetRetStat = JetSeek(  SesId,  TblId,  JET_bitSeekGE);
          if (
             (JetRetStat == JET_errRecordNotFound)
                   ||
             ((JetRetStat != JET_errSuccess) && (JetRetStat != JET_wrnSeekNotEqual))
             )
          {
                //DBGPRINT0(ERR, "Weird.  Could not locate even one record\n");

                //WINSEVT_LOG_M(WINS_FAILURE,WINS_EVT_CANT_FIND_ANY_REC_IN_RANGE);

                //
                // Don't free memory.  It will get freed later.
                //

                //
                // Don't use macro CALL_M since that will call return
                // which will cause overhead since the system will
                // search for a termination handler. We don't want
                // that for the case where there are no records in the db
                //
                if (JetRetStat != JET_errRecordNotFound)
                {
#ifdef WINSDBG
                   DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",
                                      JetRetStat, __LINE__);
#endif
                   WINSEVT_LOG_D_M(JetRetStat, WINS_EVT_DATABASE_ERR);
                   RetStat = WINS_FAILURE;
                }

          }
       }
       else
       {
            CALL_M(JetMove(
                     SesId,
                     TblId,
                     JET_MoveLast,
                     //Location == WINSINTF_END ? JET_MoveLast : JET_MoveFirst,
                     0)
                   );


       }
CHECK("Check with IAN JOSE")
       //
       // We are assured of there being at least one record since the
       // JetSeek succeeded (if not for the owner we are interested in
       // then for the next one).
       // We can therefore safely use the do .. while() construct
       //
       // *NOT REALLY.  It seems that JetSeek can return JET_wrnSeekNE
       // even when there are no records in the db.  In such a case,
       // our JetRetrieveColumn will fail with a CurrencyNot there error
       //

     //
     // If we found an exact match or a name greater than the search string,
     // retrieve the record.
     //
     if ((RetStat == WINS_SUCCESS) && (JetRetStat != JET_errRecordNotFound))
     {

       UINT nLoops = 0;

       if (Location == WINSINTF_END)
       {
                MoveDir = JET_MovePrevious;

       }
#ifdef WINSDBG
           //(void)time(&StartTime);
           StartTime = GetTickCount();
#endif
           do
           {
              nLoops++;

              CALL_M(JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                        ));

               if ((pWinsAdd != NULL) && (RecordOwnerId != OwnerId))
               {
                   //
                   // We have exhausted all records for the owner. Break out
                   // of the loop
                   //
                  continue;
               }
               else
               {
                    if (RecordOwnerId == OWNER_ID_OF_SPEC_REC)
                    {
                          continue;
                    }
               }

              pRspBuf->OwnerId = RecordOwnerId;
              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pRspBuf->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

                //
                // retrieve the name
                //
                CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &(pRspBuf->NameLen),
                        0,
                        NULL
                                     )
                  );

             //
             // if name length is > 255, jet is returning an invalid value.
             // Make the length equal to the max. length we can have for
             // a netbios name.  Also, log an event
             //
             if (pRspBuf->NameLen > WINS_MAX_NAME_SZ)
             {
                 WINSEVT_LOG_M(pRspBuf->NameLen, WINS_EVT_NAME_TOO_LONG);
                 DBGPRINT1(ERR, "NmsDbGetDataRecsByName: Name length is too long = (%x)\n", pRspBuf->NameLen);
                 pRspBuf->NameLen = WINS_MAX_NS_NETBIOS_NAME_LEN;
             }
             //
             // This macro will allocate memory for the name
             //
             NMSDB_STORE_NAME_M(pTls, pRspBuf, Name, pRspBuf->NameLen);

             //
             // Adjust the size to be passed to the push thread
             //
             *pRspBuffLen += pRspBuf->NameLen;

              //
              // Retrieve the flags byte
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &(pRspBuf->Flag),
                        sizeof(pRspBuf->Flag),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if we were asked to retrieve only static records and
              // this record is not a static record, skip it.
              //
              if ((TypeOfRecs & WINSINTF_STATIC) && !NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a dynamic record but were asked to retrieve only static records\n");
                        continue;
              }
              if ((TypeOfRecs & WINSINTF_DYNAMIC) && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a static record but were asked to retrieve only dynamic records\n");
                        continue;
              }

              EntTyp = (BYTE)((pRspBuf->Flag & NMSDB_BIT_ENT_TYP));
              if (
                        (EntTyp == NMSDB_UNIQUE_ENTRY)
                                    ||
                        (EntTyp == NMSDB_NORM_GRP_ENTRY)
                 )
              {
                      /* It is a unique entry*/
                      pRspBuf->fGrp = (EntTyp == NMSDB_UNIQUE_ENTRY) ?
                                                        FALSE : TRUE;
                      CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRspBuf->NodeAdd,
                                 sizeof(COMM_ADD_T),
                                &ActFldLen,
                                0,
                                NULL
                                        )
                            );

               }
               else  // it is a special group or a multihomed entry
               {

                      //
                      // Even if the entry is a multihomed entry, we set the
                      // fGrp flag to TRUE so that the formatting function
                      // works properly (called by PUSH thread).  The EntTyp
                      // will be used to decipher whether it is a multihomned
                      // entry or not
                      //
FUTURES("Remove this hacky mechanism")
                      pRspBuf->fGrp =
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? TRUE : FALSE;

                     /*
                     *  get member addresses.
                     *
                     * This function is only called on RPC thread.  We want to get
                     * the members, even if they are expired.  We can do that by
                     * passing a TRUE value for the STATIC flag parameter.
                     * NmsDbGetDataRecsByName is the only way to get all the members
                     * including the expired ones.
                     */
                     StoreGrpMems(
                             pTls,
                             WINS_E_WINSRPC,
                             pRspBuf->pName,
                             0,     //not accessed by StoreGrpMems if Client_e
                                    //is not WINS_E_NMSSCV
                             SesId,
                             TblId,
                             TRUE, // NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag),
                             (PRPL_REC_ENTRY_T)pRspBuf
                            );

                   if (
                        (pRspBuf->NoOfAdds == 0)
                                &&
                        (NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                      )
                   {
                          //
                          //change the state to released so that the
                          //record shows up as released when displayed
                          //
                          NMSDB_CLR_STATE_M(pRspBuf->Flag);
                          NMSDB_SET_STATE_M(pRspBuf->Flag, NMSDB_E_RELEASED);
                   }

                     *pRspBuffLen +=
                           (pRspBuf->NoOfAdds * sizeof(COMM_ADD_T) * 2);

               }

                //
                // get the timestamp field
                //
                CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );

                if (NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag) &&
                    (RecordOwnerId == NMSDB_LOCAL_OWNER_ID) &&
                    NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                {
                    pRspBuf->TimeStamp = MAXLONG;
                }


             //
             // increment the counter and the pointer to past the last record.
             //
             pRspBuf = (PRPL_REC_ENTRY2_T)((LPBYTE)pRspBuf + RPL_REC_ENTRY2_SIZE);
             (*pNoOfRecsRet)++;

             //
             // if we have retrieved the max. number asked for, break out of
             // the loop
             //
             if (*pNoOfRecsRet == NoOfRecsDesired)
             {
                      break;
             }

             //
             // decrease the granularity of [BeginTransaction()..CommitTransaction()] intervals
             //
             if (*pNoOfRecsRet/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
             {
                nLoops = 0;
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                fTransCommitted = TRUE;
                CommitCnt++;
                CALL_M(JetBeginTransaction(SesId));
                fTransCommitted = FALSE;
             }

          } while(JetMove(SesId, TblId, MoveDir/*JET_MoveNext*/, 0) >= 0);
#ifdef WINSDBG
           EndTime = GetTickCount();
           DBGPRINT2(TM, "NmsDbGetDataRecs: Retrieved %d records in %d secs\n",
                                *pNoOfRecsRet, StartTime - EndTime);
#endif
   } // if RetStat == WINS_SUCCESS
} // end of try {..}
finally {
                if (AbnormalTermination())
                {
                        DBGPRINT0(ERR,
                            "NmsDbGetDataRecsByName: Terminating abnormally\n");
                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_RPC_EXC);
                        RetStat = WINS_FAILURE;
                }
                DBGPRINT1(FLOW, "NmsDbGetDataRecsByName:Retrieved %d records\n",
                                        *pNoOfRecsRet);

                //
                //
                // We are done. Let us commit the transaction if it is not yet committed
                //
                if (!fTransCommitted)
                    CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
        }

        DBGLEAVE("NmsDbGetDataRecsByName\n");
        return(RetStat);
}


STATUS
NmsDbEndTransaction(
  VOID
 )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       WinsMscChkTermEvt
Side Effects:

Comments:
	None
--*/

{
       PWINSTHD_TLS_T pTls;
       DBGENTER("NmsDbEndTransaction\n");
       GET_TLS_M(pTls);
       ASSERT(pTls != NULL);
       CALL_M(
                    JetCommitTransaction(pTls->SesId, JET_bitCommitFlush)
             );
       DBGLEAVE("NmsDbEndTransaction\n");
       return(WINS_SUCCESS);
}

#if DYNLOADJET
STATUS
SetForJet(
  VOID
 )
{
  HMODULE DllHandle;
  DWORD   Error;
  LPTSTR  pDllName;

#ifdef WINS_INTERACTIVE
  DynLoadJetVersion = getenv("JET500") ?  DYN_LOAD_JET_500
                                        : (getenv("JET200") ?  DYN_LOAD_JET_200 : DYN_LOAD_JET_600);
#endif

  DBGENTER("SetForJet\n");

  if (DynLoadJetVersion == DYN_LOAD_JET_500)
  {
    pDllName = TEXT("jet500.dll");
    NAM_ADD_OWNERID_SIZE = sizeof(DWORD);
    BASENAME = "j50";
    sNamAddTblRow[3].FldTyp = JET_coltypLong;
    sOwnAddTblRow[0].FldTyp = JET_coltypLong;
  }
  else if (DynLoadJetVersion == DYN_LOAD_JET_600 ) {
      // jet600.dll is now called esent.dll!
      pDllName = TEXT("esent.dll");
      NAM_ADD_OWNERID_SIZE = sizeof(DWORD);
      BASENAME = "j50";
      sNamAddTblRow[3].FldTyp = JET_coltypLong;
      sOwnAddTblRow[0].FldTyp = JET_coltypLong;

  }
  else
  {
    pDllName = TEXT("jet.dll");
    NAM_ADD_OWNERID_SIZE = sizeof(BYTE);
    BASENAME = "jet";
    sNamAddTblRow[3].FldTyp = JET_coltypUnsignedByte;
    sOwnAddTblRow[0].FldTyp = JET_coltypUnsignedByte;
  }


  DBGPRINT2(ERR,"SetForJet: loading DLL %ws: version %ld\n", pDllName, DynLoadJetVersion);

  OWN_ADD_OWNERID_SIZE = NAM_ADD_OWNERID_SIZE;

  //
  // Load the DLL that contains the service.
  //

  DllHandle = LoadLibrary( pDllName );
  if ( DllHandle == NULL )
  {
        Error = GetLastError();
        DBGPRINT2(ERR,"SetForJet: Failed to load DLL %ws: %ld\n", pDllName, Error);
        return(WINS_FAILURE);
  }
  else
  {
         DWORD i;
         for (i=0; i < NMSDB_SIZEOFJETFTBL; i++)
         {
            CHAR chFnName[64];
            LPSTR pAt;
            LPSTR pFnName;

            pFnName = (LPSTR)NmsDbJetFTbl[i].pFName;
#if _X86_
            if ( DynLoadJetVersion != DYN_LOAD_JET_200) {
                strcpy(chFnName,NmsDbJetFTbl[i].pFName);
                pAt = strrchr(chFnName,'@');
                if (pAt != NULL)
                {
                    *pAt = '\0';
                    pFnName = chFnName;
                }
            }
#endif
            if ((NmsDbJetFTbl[i].pFAdd = (JETPROC)GetProcAddress(DllHandle,
                      (DynLoadJetVersion >= DYN_LOAD_JET_500) ? pFnName : ULongToPtr(NmsDbJetFTbl[i].FIndex))) == NULL)
            {
              DBGPRINT2(ERR, "SetForJet: Failed to get address of function %s: %ld\n", NmsDbJetFTbl[i].pFName, GetLastError());
              return(WINS_FAILURE);
            }
            else
            {
              DBGPRINT3(DET, "SetForJet: Got address of function %s (%d): %p\n", NmsDbJetFTbl[i].pFName, i, NmsDbJetFTbl[i].pFAdd);

            }
         }

  }
  return(WINS_SUCCESS);
}
#endif


//
// Name of the process that converts jet200 db to jet500 db format
//
CHECK("Unicode from results in an exception from CreateProcess")
//#define JETCONVDB             TEXT("jetconv WINS /@")

VOID
RecoverJetDb(
    DYN_LOAD_JET_VERSION    JetVersion
    )
/*++
    This routine recovers the database by calling JetInit/JetTerm on
    the database.
Argument:
    JetVersion - The version of the jet to use when recovering the db.
--*/
{
    DYN_LOAD_JET_VERSION  JetVersionSv = DynLoadJetVersion;

    ASSERT(DYN_LOAD_JET_500 <= JetVersion );

    //
    // First JetTerm the current jet engine.
    //
    NmsDbRelRes();

    //
    // now load the appropriate version jet dll.
    //
    DynLoadJetVersion = JetVersion;

    SetForJet();


    //
    // set system params and jetinit.
    //
    SetSystemParams(TRUE);

    JetInit(&sJetInstance);

    //
    // finally, JetTerm this jet dll.
    //
    NmsDbRelRes();

    DynLoadJetVersion = JetVersionSv;
    return;
}

#define JETCONVDB200             "jetconv WINS /200 /@"
#define JETCONVDB500             "jetconv WINS /500 /@"

STATUS
ConvertJetDb(
    JET_ERR         JetRetStat
 )
{
    BOOL RetVal;
    PROCESS_INFORMATION ProcInfo = {0};
    STARTUPINFOA StartInfo = {0};
    LPSTR      pArg;



    DBGPRINT1(DET, "ConvertJetDb: Converting %s\n", (JetRetStat == JET_errDatabase200Format)
                                                    ? JETCONVDB200 : JETCONVDB500);

    if (JetRetStat == JET_errDatabase200Format)
    {

         fDbIs200 = TRUE;
         if (DynLoadJetVersion == DYN_LOAD_JET_500)
         {
               //
               // Can not run jet200 using jet500.dll on NT5.0
               //

               DBGPRINT0(ERR, "Can not run jet200 using jet500.dll on NT5.0\n");
               return WINS_FAILURE;

         } else if (DynLoadJetVersion == DYN_LOAD_JET_600){
             pArg = JETCONVDB200;
         } else {
             ASSERT(FALSE);
             return WINS_FAILURE;
         }

    } else if ( JetRetStat == JET_errDatabase500Format ) {

        if (DynLoadJetVersion == DYN_LOAD_JET_600)
        {
              // before we start the conversion, we need to bring the db to
              // consistent state. The 351 to 4.0 conversion tool (upg351db.exe)
              // did this from within the tool but the 4.0 to 5.0 tool
              // does not do this from within the tool so we need to do it here.
              RecoverJetDb( DYN_LOAD_JET_500 );

              // Start the convert process
              //
              pArg = JETCONVDB500;
              fDbIs500 = TRUE;

        } else {
            ASSERT(FALSE);
            return WINS_FAILURE;

        }

    }

    //return WINS_FAILURE;

    StartInfo.cb = sizeof(StartInfo);
    //

    // Create the convert process to do the conversion.  This process
    //
    DBGPRINT0(DET, "ConvertJetDb - creating convert process\n");
    RetVal =  CreateProcessA(
                             NULL,        //
                             pArg,
                             NULL,         //default proc. sec.
                             NULL,         //default thread. sec.
                             FALSE,        //don't inherit handles
                             DETACHED_PROCESS, //no creation flags
                             NULL,        //default env.
                             NULL,        //current drv/dir. same as creator
                             &StartInfo,        //no startup info
                             &ProcInfo        //no process info.
                             );
    if (!RetVal)
    {
         DBGPRINT1(ERR, "ConvertJetDb: Create process failed with error (%x)\n", GetLastError());
         return(WINS_FAILURE);
    }

    fConvJetDbCalled = TRUE;

    //
    // Log an event.
    //
    DBGPRINT0(DET, "ConvertJetDb - returning\n");

//    WINSEVT_LOG_M(WINS_SUCCESS, WINS_EVT_TEMP_TERM_UNTIL_CONV);
    return(WINS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\nms\nmsnmh.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        nmsnmh.c

Abstract:

        This module contains functions of the name handler component of the
        name space manager of WINS.

        The name handler is responsible for handling all name registrations,
        name refreshes, name requests, and name releases.


Functions:
        NmsNmhNamRegInd         - Register Unique Name
        NmsNmhNamRegGrp         - Register Group Name
        NmsNmhNamRelease        - Release a name
        NmsNmhNamQuery          - Query a name
         .....
         .....

Portability:
        This module is portable

Author:
        Pradeep Bahl (PradeepB)          Dec-1992

Revision History:

        Modification date        Person           Description of modification
        -----------------        -------          ----------------------------
--*/

/*
        Includes
*/

#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "wins.h"
#include "nmsdb.h"
#include "comm.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsmsgf.h"
#include "nmschl.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsmsc.h"
#include "winsque.h"
#include "rpl.h"
#include "winsintf.h"



/*
 *        Local Macro Declarations
 */

/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */

VERS_NO_T           NmsNmhMyMaxVersNo;             //max. vers. no of entries owned
                                           //by this wins
VERS_NO_T           NmsNmhIncNo;                          //a large integer initialized to 1
CRITICAL_SECTION   NmsNmhNamRegCrtSec;     //for name registrations and
                                           //refreshes

/*
 *        Local Variable Definitions
 */


/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */

//
// Send response to name release request
//
STATIC
STATUS
SndNamRelRsp(
        PCOMM_HDL_T                pDlgHdl,
        PNMSMSGF_RSP_INFO_T   pRspInfo
        );

//
// Send response to name query request
//
STATIC
STATUS
SndNamQueryRsp(
        PCOMM_HDL_T              pDlgHdl,
        PNMSMSGF_RSP_INFO_T   pRspInfo
        );


//
// handle clash at name registration of a unique entry
//
STATIC
STATUS
ClashAtRegInd (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfAddMem,
        OUT PBOOL               pfAddDiff,
        OUT PBOOL                pfRetPosRsp
 );


//
// handle clash at name registration of a group entry
//
STATIC
STATUS
ClashAtRegGrp (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRetPosRsp
 );

//
// handle clash at the name registration of unique entry's replica
//
STATIC
VOID
ClashAtReplUniqueR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfInformWins
 );

//
// handle clash at the name registration of group entry's replica
//
STATIC
VOID
ClashAtReplGrpR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfUpdTimeStamp,
        OUT PBOOL                pfInformWins

 );

//
// check if the entry to register is a member of the special group found in
// the db
//
STATIC
BOOL
MemInGrp(
        IN PCOMM_ADD_T         pAddToReg,
        IN PNMSDB_STAT_INFO_T  pEntryInCnf,
        IN PBOOL               pfOwned,
        IN BOOL                fRemoveReplica
        );

STATIC
VOID
RemoveAllMemOfOwner(
      PNMSDB_STAT_INFO_T pEntry,
      DWORD OwnerId
 );
//
// Do a union of two special groups
//
STATIC
BOOL
UnionGrps(
        IN PNMSDB_ROW_INFO_T        pEntryToReg,
        IN PNMSDB_STAT_INFO_T        pEntryInCnf
        );

FUTURES("use when internet group masks are used")
#if 0
STATIC
BYTE
HexAsciiToBinary(
        LPBYTE pByte
        );
STATIC
BOOL
IsItSpecGrpNm(
        LPBYTE pName
        );
#endif

//
//  Function definitions
//



STATUS
NmsNmhNamRegInd(
        IN PCOMM_HDL_T          pDlgHdl,
        IN LPBYTE               pName,
        IN DWORD                NameLen,
        IN PCOMM_ADD_T          pNodeAdd,
        IN BYTE                 NodeTyp, //change to take Flag byte
        IN MSG_T                pMsg,
        IN MSG_LEN_T            MsgLen,
        IN DWORD                QuesNamSecLen,
        IN BOOL                 fRefresh,
        IN BOOL                 fStatic,
        IN BOOL                 fAdmin
        )

/*++

Routine Description:
        This function registers a unique name in the directory database.


Arguments:
        pDlgHdl         - Dialogue Handle
        pName           - Name to be registered
        NameLen         - Length of Name
        NodeTyp         - Whether nbt node doing the registration is a P or M                                   node
        pNodeAdd        - NBT node's address
        NodeTyp         - Type of Node (B, M, P)
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fRefresh        - Is it a refresh request
        fStatic         - Is it a STATIC entry
        fAdmin          - Is it an administrative action


Externals Used:
        NmsNmhNamRegCrtSec, NmsNmhMyMaxVersNo


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/

{


        NMSDB_ROW_INFO_T   RowInfo;    // contains row info
        NMSDB_STAT_INFO_T  StatusInfo; /* error status and associated
                                        * info returned by the NmsDb func
                                        */
        BOOL               fChlBeingDone = FALSE; //indicates whether
                                                  //challenge is being
                                         //done
        BOOL               fUpdate;      //indicates whether conflicting entry
                                         //needs to be overwritten
        BOOL               fUpdVersNo;   //indicates whether version number
                                         //needs to be incremented
        BOOL               fChallenge;   //indicates whether a challenge needs
                                        //to be done
        time_t             ltime;        //stores time since Jan 1, 1970
                                                 //is a browser name
        BOOL               fAddDiff;     //indicates that the address is diff
        BOOL               fAddMem;      //indicates whether member should be
                                         //added to the multihomed entry
        BOOL               fRetPosRsp;

        NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SUCCESS;
        STATUS             RetStat = WINS_SUCCESS;
        NMSMSGF_RSP_INFO_T RspInfo;
#ifdef WINSDBG
        DWORD              StartTimeInMsec;
       // DWORD              EndTimeInMsec;
#endif
        //DBG_PERFMON_VAR

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is
        *
        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        DBGENTER("NmsNmhNamRegInd\n");

        //
        // if the 16th char is 0x1C or 0x1E, reject the registration
        // since these names are reserved.
        //
        if ((*(pName + 15) == 0x1C) || (*(pName + 15) == 0x1E))
        {
                RspInfo.RefreshInterval = 0;
                Rcode_e = NMSMSGF_E_RFS_ERR;
                goto SNDRSP;
        }

        RowInfo.pName = pName;

        DBGPRINT3(FLOW, "NmsNmhNamRegInd: %s name to register -- (%s). 16th char is (%x)\n", fStatic ? "STATIC" : "DYNAMIC", RowInfo.pName, *(RowInfo.pName+15));

        RowInfo.NameLen         =  NameLen;
        RowInfo.pNodeAdd        =  pNodeAdd;
        RowInfo.NodeTyp         =  NodeTyp; //Node type (B, P or M node)
        RowInfo.EntTyp          =  NMSDB_UNIQUE_ENTRY;  // this is a unique
                                                        //registration
        (void)time(&ltime);      //time() does not return any error code

        RowInfo.EntryState_e    = NMSDB_E_ACTIVE;
        RowInfo.OwnerId         = NMSDB_LOCAL_OWNER_ID;
        RowInfo.fUpdVersNo      = TRUE;
        RowInfo.fUpdTimeStamp   = TRUE;
        RowInfo.fLocal          = !(fStatic || fAdmin) ? COMM_IS_IT_LOCAL_M(pDlgHdl) : FALSE;
        RowInfo.fStatic         = fStatic;
        RowInfo.fAdmin          = fAdmin;
//        RowInfo.CommitGrBit     = 0;

FUTURES("Currently there we don't check to see whether the address in the")
FUTURES("packet is same as the address of the node that sent this request")
FUTURES("RFCs are silent about this.  Investigate")

        //
        // Check if it is a browser name.  If yes, it requires
        // special handling
        //
        if (!NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
        {

                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //DBG_START_PERF_MONITORING

                //
                // Put expiry time here
                //
                ltime += WinsCnf.RefreshInterval;
                RowInfo.TimeStamp       = (fStatic ? MAXLONG_PTR: ltime);


PERF("Adds to critical section code. Improve perf by getting rid of this")
PERF("Administrator would then get a cumulative count of reg and ref")
                if (!fRefresh)
                {
                        WinsIntfStat.Counters.NoOfUniqueReg++;
                }
                else
                {
                        WinsIntfStat.Counters.NoOfUniqueRef++;
                }


               //
               // Set the refresh interval field. We must do this
               // from within the WinsCnfCnfCrtSec or NmsNmhNamRegCrtSec
               // critical section (synchronize with main thread doing
               // reinitialization or with an RPC thread)
               //
               RspInfo.RefreshInterval = WinsCnf.RefreshInterval;

                /*
                   * Store version number
                */
                RowInfo.VersNo = NmsNmhMyMaxVersNo;

        try {
#ifdef WINSDBG
                IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

                /*
                 *   Insert record in the directory
                */
                RetStat = NmsDbInsertRowInd(
                                          &RowInfo,
                                          &StatusInfo
                                            );
#ifdef WINSDBG
                IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRegInd: Time in NmsDbInsertRowInd is = (%d msecs). RetStat is (%d)\n", GetTickCount() - StartTimeInMsec,
RetStat); }
#endif
                if (RetStat == WINS_SUCCESS)
                {
                   /*
                     * If there is a conflict, do the appropriate
                    *  processing
                   */
                   if (StatusInfo.StatCode == NMSDB_CONFLICT)
                   {
                       DBGPRINT0(FLOW, "NmsNmhNamRegInd: Name Conflict\n");
                       ClashAtRegInd(
                                        &RowInfo,
                                        &StatusInfo,
                                        fRefresh,
                                        &fUpdate,
                                        &fUpdVersNo,
                                        &fChallenge,
                                        &fAddMem,
                                        &fAddDiff,
                                        &fRetPosRsp
                                       );

PERF("Change the order of if tests to improve performance")
                       if (fChallenge)
                       {
                                DBGPRINT0(FLOW,
            "NmsNmhNamRegInd: Handing name registration to challenge manager\n");
                                WinsIntfStat.Counters.NoOfUniqueCnf++;

                                //
                                //Ask the Name Challenge component to take
                                //it from here
                                //
                                NmsChlHdlNamReg(
                                        NMSCHL_E_CHL,
                                        WINS_E_NMSNMH,
                                        pDlgHdl,
                                        pMsg,
                                        MsgLen,
                                        QuesNamSecLen,
                                        &RowInfo,
                                        &StatusInfo,
                                        NULL
                                               );
                                fChlBeingDone = TRUE;
                        }
                        else
                            {
                                if (fUpdate)
                                {
                                    if (!fUpdVersNo)
                                    {
                                        RowInfo.fUpdVersNo = FALSE;
                                    }
                                    else
                                    {
                                       WinsIntfStat.Counters.NoOfUniqueCnf++;
                                    }
//                                    RowInfo.CommitGrBit     = JET_bitCommitLazyFlush;
                                    RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                                 );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                                   if ((RetStat != WINS_SUCCESS) || (StatusInfo.StatCode != NMSDB_SUCCESS))
                                   {
                                        Rcode_e = NMSMSGF_E_SRV_ERR;
                                   }
                                   else //we succeeded in inserting the row
                                   {

                                        DBGPRINT1(FLOW,
                                          "%s Registration Done after conflict \n",
                                           fStatic ? "STATIC" : "DYNAMIC");
                                        if (fUpdVersNo)
                                        {
                                               NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                                      );
                                          //
                                          // Send a Push Notification if required
                                          //
                                          DBGIF(fWinsCnfRplEnabled)
                                          RPL_PUSH_NTF_M(
                                          (WinsCnf.PushInfo.fAddChgTrigger == TRUE) ? fAddDiff : RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                                        }
                                   }
                           }
                           else  // no simple update required
                           {
                             if (fRetPosRsp)
                             {
                                Rcode_e = NMSMSGF_E_SUCCESS;
                             }
                             else
                             {
                               if (fAddMem)
                               {

                                 DWORD i;
                                 PNMSDB_GRP_MEM_ENTRY_T pRowMem =
                                        &RowInfo.NodeAdds.Mem[1];
                                 PNMSDB_GRP_MEM_ENTRY_T pCnfMem =
                                        StatusInfo.NodeAdds.Mem;

                                 //
                                 // Add the new member
                                 //
                                 // Note: first member in RowInfo.NodeAdds is the
                                 // one we tried to register.  We tack on
                                 // all the members found in the conflicting
                                 // record to it
                                 //
                                 RowInfo.NodeAdds.Mem[0].OwnerId =
                                                NMSDB_LOCAL_OWNER_ID;

                                   RowInfo.NodeAdds.Mem[0].TimeStamp =
                                              ltime;

                                 RowInfo.NodeAdds.Mem[0].Add = *pNodeAdd;

                                 for (
                                        i = 0;
                                        i < min(StatusInfo.NodeAdds.NoOfMems,
                                                (NMSDB_MAX_MEMS_IN_GRP - 1));
                                                i++, pRowMem++, pCnfMem++)
                                 {
                                   *pRowMem =  *pCnfMem;
                                 }
                                 RowInfo.NodeAdds.NoOfMems =
                                        StatusInfo.NodeAdds.NoOfMems + 1;

                                 RowInfo.EntTyp   = NMSDB_MULTIHOMED_ENTRY;
                                 RowInfo.pNodeAdd = NULL;
                                 if (!fUpdVersNo)
                                 {
                                   RowInfo.fUpdVersNo = FALSE;
                                 }

                                 RetStat = NmsDbUpdateRow(
                                                &RowInfo,
                                                &StatusInfo
                                                    );

                                 if ((RetStat == WINS_SUCCESS) && (StatusInfo.StatCode == NMSDB_SUCCESS))
                                 {
                                   if (fUpdVersNo)
                                   {

                                    NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                     //
                                     // Send a Push notification if required
                                     //
                                       DBGIF(fWinsCnfRplEnabled)
                                     RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);

                                   }
                                }
                                else
                                {
                                   Rcode_e = NMSMSGF_E_SRV_ERR;
                                }
                               }
                               else
                               {
                                 DBGPRINT1(FLOW,
                                        " %s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC"
                                       );
                                 DBGPRINT1(DET, "%s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
                                 Rcode_e = NMSMSGF_E_ACT_ERR;
                               }

                           }
                         }
                        }
                     }
                     else  //no conflict means success
                     {

                                DBGPRINT1(FLOW,
                                      "%s Registration Done. No conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
#if 0
                                DBGPRINT1(SPEC,
                                        " %s Registration Done. No conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC");
#endif

                                       NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                           );
                                //
                                // Send a Push Notification if required
                                //
                                DBGIF(fWinsCnfRplEnabled)
                                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);

                      }
                }
                else //RetStat != WINS_SUCCESS
                {
                        Rcode_e = NMSMSGF_E_SRV_ERR;
                }
             } // end of try block
             except (EXCEPTION_EXECUTE_HANDLER) {
                        DBGPRINTEXC("NmsNmhNamRegInd");
                        DBGPRINT3(EXC, "NmsNmhNamRegInd. Name is (%s), Version No  (%d %d)\n", RowInfo.pName, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);

                        WinsEvtLogDetEvt(FALSE, WINS_EVT_REG_UNIQUE_ERR,
                            NULL, __LINE__, "sddd", RowInfo.pName,
                            GetExceptionCode(),
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

                        Rcode_e = NMSMSGF_E_SRV_ERR;
              }
              LeaveCriticalSection(&NmsNmhNamRegCrtSec);
//              DBG_PRINT_PERF_DATA
        }
        else
        {
                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Set the refresh interval field
                //
                RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // The name registration was for a browser name.
                // We always return a positive response
                //
                Rcode_e = NMSMSGF_E_SUCCESS;

        }

SNDRSP:
        //
        // Send a response only if we did not hand over the request to the
        // name challenge manager and if it is neither a STATIC initialization
        // request nor a rpc request
        //
        if ((!fChlBeingDone) && (!fStatic) && (!fAdmin))
        {

                DBGPRINT1(FLOW,
                   "NmsNmhNamRegInd: Sending %s name registration response\n",
                           Rcode_e == NMSMSGF_E_SUCCESS ? "positive" :
                                                "negative" );

                RspInfo.Rcode_e         = Rcode_e;
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );
        }

        //
        // If it is an RPC request, we need to return a success or a failure
        // indication.
        //
        if (fAdmin)
        {
                if (Rcode_e != NMSMSGF_E_SUCCESS)
                {
                        DBGLEAVE("NmsNmhNamRegInd\n");
                        return(WINS_FAILURE);
                }
        }

        DBGLEAVE("NmsNmhNamRegInd\n");
        return(WINS_SUCCESS);
}

STATUS
NmsNmhNamRegGrp(
        IN PCOMM_HDL_T          pDlgHdl,
        IN PBYTE                pName,
        IN DWORD                NameLen,
        IN PNMSMSGF_CNT_ADD_T   pCntAdd,
        IN BYTE                 NodeTyp, //change to take Flag byte
        IN MSG_T                pMsg,
        IN MSG_LEN_T            MsgLen,
        IN DWORD                QuesNamSecLen,
        IN DWORD                TypeOfRec,
        IN BOOL                 fRefresh,
        IN BOOL                 fStatic,
        IN BOOL                 fAdmin
        )

/*++

Routine Description:
        This function registers a group record.

        Special group:
                the name is registered with the IP address in the member list
        Normal group
                the name is registered with single address (to avoid
                                special casing. The address is not used)


        In case the group registration succeeds, a positive name registration
        response is sent, else a negative name registration response is sent.


Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pNodeAdd        - NBT node's address
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fStatic                - Is it a STATIC entry
        fAdmin                - Is it an administrative action



Externals Used:
        NmsNmhNamRegCrtSec, NmsNmhMyMaxVersNo

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T   RowInfo;       // contains row info
        NMSDB_STAT_INFO_T  StatusInfo;   /* error status and associated
                                          * info returned by the NmsDb func
                                          */
        BOOL                   fChlBeingDone = FALSE; //indicates whether
                                                  //challenge is being
                                                  //done
        BOOL                   fAddMem;    //indicates whether member should be
                                           //added to the group
        BOOL                   fUpdate;    //indicates whether conflicting entry
                                           //needs to be overwritten
        BOOL                   fUpdVersNo; //inidicates whether version number
                                           //needs to be incremented
        BOOL                   fChallenge; //indicates whether a challenge needs
                                           //to be done
        time_t                 ltime;      //stores time since Jan 1, 1970

        BOOL                   fIsSpecial = FALSE;  //Is this a special group
        NMSMSGF_ERR_CODE_E Rcode_e = NMSMSGF_E_SUCCESS;
        STATUS                 RetStat = WINS_SUCCESS;
        BOOL                   fRetPosRsp;
        NMSMSGF_RSP_INFO_T     RspInfo;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif

        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhNamRegGrp\n");

        /*
        *  initialize the row info. data structure with the data to insert into
        *  the row.  The data passed is

        *  Name, NameLen, IP address, group/unique status,
        *  timestamp, version number
        */
        RowInfo.pName = pName;
        RowInfo.pNodeAdd = NULL;

        DBGPRINT4(FLOW, "NmsNmhNamRegGrp: %s Name (%s) to register -- (%s). 16th char is (%x)\n", fStatic ? "STATIC" : "DYNAMIC", RowInfo.pName, TypeOfRec == NMSDB_MULTIHOMED_ENTRY ? "MULTIHOMED" : "NORMAL/SPECIAL GROUP", *(RowInfo.pName + 15));

        RowInfo.NameLen   = NameLen;
        (void)time(&ltime); //time does not return any error code

        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        ltime += WinsCnf.RefreshInterval;
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        //Initialize this
        RspInfo.RefreshInterval = 0;
PERF("Stop checking for 1B name in nmsmsgf.c. Do the switch in RegInd and ")
PERF("RegGrp function. That way, we will save some cycles for the grp reg/ref")
        //
        // do the initialization based on the type of group.
        //
        //  Note: If the name qualifies as a special group name, then
        //        even if it is a multihomed, we mark it as a special group
        //
        if (NMSDB_IS_IT_SPEC_GRP_NM_M(pName) || (TypeOfRec == NMSDB_SPEC_GRP_ENTRY))
//      if (IsItSpecGrpNm(pName))
        {
              DWORD i;
              RowInfo.EntTyp =  NMSDB_SPEC_GRP_ENTRY; // this is a special grp
                                                      //registration
              RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
              for (i = 0; i < pCntAdd->NoOfAdds; i++)
              {
                   RowInfo.NodeAdds.Mem[i].Add      = pCntAdd->Add[i];
                   RowInfo.NodeAdds.Mem[i].OwnerId  = NMSDB_LOCAL_OWNER_ID;

                   //
                   // Put expiration time here.  WE PUT A MAXULONG FOR A STATIC
                   // SPECIAL GROUP MEMBER ONLY (I.E. NOT FOR MH NAMES).  This
                   // would require changes to MemInGrp().
                   //
FUTURES("set MAXULONG for mh members also")
                   RowInfo.NodeAdds.Mem[i].TimeStamp = ((fStatic && (TypeOfRec == NMSDB_SPEC_GRP_ENTRY)) ? MAXLONG_PTR : ltime);
              }

              //
              // Init pNodeAdd field to NULL.  This field is checked by
              // QueInsertChlReqWrkItm called by NmsChlHdlNamReg (called
              // to hand over a challenge request to the name challenge mgr).
              //
              RowInfo.pNodeAdd = NULL;
        }
        else  // normal group or a multi-homed registration
        {
          //
          // if the name is not mh, it means that it is a group. The
          // registration for this group may have come with the MULTIHOMED
          // opcode (meaning it is a multihomed node registering the group)
          // (see nmsmsgf.c)
          //
          if (TypeOfRec != NMSDB_MULTIHOMED_ENTRY)
          {
              if (*pName != 0x1B)
              {
                RowInfo.pNodeAdd  = &pCntAdd->Add[0];
                RowInfo.EntTyp    = NMSDB_NORM_GRP_ENTRY;
                RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
                RowInfo.NodeAdds.Mem[0].Add      = pCntAdd->Add[0];
                RowInfo.NodeAdds.Mem[0].OwnerId  = NMSDB_LOCAL_OWNER_ID;
                RowInfo.NodeAdds.Mem[0].TimeStamp = ltime; // put current time
              }
              else
              {
                //
                // a 1B name is for browser use. We can not let this one
                // preempt it
                //
NOTE("TTL is not being set. This shouldn't break UB nodes, but you never know")
                Rcode_e = NMSMSGF_E_RFS_ERR;
                goto SNDRSP;
              }
          }
          else
          {
             //
             // It is a multihomed entry
             //
             if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
             {
                /*
                *  Enter Critical Section
                */
                EnterCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // Set the refresh interval field
                //
                RspInfo.RefreshInterval = WinsCnf.RefreshInterval;
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);

                //
                // The name registration was for a browser name.
                // We always return a positive response
                //
                Rcode_e = NMSMSGF_E_SUCCESS;
                goto SNDRSP;

            }
            else
            {

                   DWORD i;
                   if (*(RowInfo.pName+15) == 0x1E)
                   {
                        Rcode_e = NMSMSGF_E_RFS_ERR;
                        goto SNDRSP;
                   }
                   RowInfo.NodeAdds.NoOfMems         = pCntAdd->NoOfAdds;
                   for (i = 0; i < pCntAdd->NoOfAdds; i++)
                   {
                          RowInfo.NodeAdds.Mem[i].Add      = pCntAdd->Add[i];
                          RowInfo.NodeAdds.Mem[i].OwnerId  = NMSDB_LOCAL_OWNER_ID;
                          RowInfo.NodeAdds.Mem[i].TimeStamp = ltime; // put current time
                   }
                   RowInfo.EntTyp    = NMSDB_MULTIHOMED_ENTRY;
             }
          }
        }

        RowInfo.TimeStamp     = (fStatic ? MAXLONG_PTR: ltime);
        RowInfo.OwnerId       = NMSDB_LOCAL_OWNER_ID;
        RowInfo.EntryState_e  = NMSDB_E_ACTIVE;
        RowInfo.fUpdVersNo    = TRUE;
        RowInfo.fUpdTimeStamp = TRUE;
        RowInfo.fLocal          = !(fStatic || fAdmin) ? COMM_IS_IT_LOCAL_M(pDlgHdl) : FALSE;
        RowInfo.fStatic       = fStatic;
        RowInfo.fAdmin        = fAdmin;
//        RowInfo.CommitGrBit   = 0;

        //
        // Put this initialization here even though it is not required for
        // special group groups. This is to save cycles in
        // the critical section (check UpdateDb in nmsdb.c; if
        // we don't initialize this for special groups, we have to
        // put an if test (with associated & to get the type of record
        // bits) versus an or.
        //
        RowInfo.NodeTyp       =  NodeTyp; //Node type (B, P or M node)


        /*
         * Enter Critical Section
        */
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING
PERF("Adds to critical section code. Improve perf by getting rid of this")
PERF("Administrator would then get a cumulative count of reg and ref")
        if (!fRefresh)
        {
                WinsIntfStat.Counters.NoOfGroupReg++;
        }
        else
        {
                WinsIntfStat.Counters.NoOfGroupRef++;
        }

        //
        // Set the refresh interval field. We must do this
        // from within the WinsCnfCnfCrtSec or NmsNmhNamRegCrtSec
        // critical section
        //
        RspInfo.RefreshInterval = WinsCnf.RefreshInterval;

        /*
         * Store version number
        */
        RowInfo.VersNo        = NmsNmhMyMaxVersNo;

try
  {
#ifdef WINSDBG
        IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

        /*
        * Insert record in the directory
        */
        RetStat = NmsDbInsertRowGrp(
                                &RowInfo,
                                &StatusInfo
                           );

#ifdef WINSDBG
        IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRegGrp: Time in NmsDbInsertRowGrp is = (%d msecs). RetStat is (%d)\n", GetTickCount() - StartTimeInMsec, RetStat); }
#endif

       if (RetStat == WINS_SUCCESS)
       {
        /*
        * If there is a conflict, do the appropriate processing
        */
        if (StatusInfo.StatCode == NMSDB_CONFLICT)
        {

          RetStat = ClashAtRegGrp(
                        &RowInfo,
                        &StatusInfo,
                        fRefresh,  // will never be TRUE for a multihomed reg
                        &fAddMem,
                        &fUpdate,
                        &fUpdVersNo,
                        &fChallenge,
                        &fRetPosRsp
                        );

          if (RetStat == WINS_SUCCESS)
          {

                  //
                  //  If fChallenge is set, it means that we should challenge the
                  //  node in conflict.
                  //
                  if (fChallenge)
                  {
                          WinsIntfStat.Counters.NoOfGroupCnf++;
                        fChlBeingDone = TRUE;
                          NmsChlHdlNamReg(
                                NMSCHL_E_CHL,
                                WINS_E_NMSNMH,
                                pDlgHdl,
                                pMsg,
                                MsgLen,
                                QuesNamSecLen,
                                &RowInfo,
                                &StatusInfo,
                        //        &StatusInfo.NodeAdds.Mem[0].Add,
                                NULL
                               );
                  }
                  else
                  {
                        if (fUpdate)
                        {
                                //
                                // In case of a special group, we could
                                // be updating the row without incrementing
                                // its version number (the row is not owned
                                // by us)
                                //
                                   if (!fUpdVersNo)
                                   {
                                       RowInfo.fUpdVersNo   = FALSE;
                                }
                                else
                                {
                                          WinsIntfStat.Counters.NoOfGroupCnf++;
                                }

FUTURES("Check return status of NmsDbUpdateRow instead of checking StatCode")
                                RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                       );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                                if ((RetStat != WINS_SUCCESS) || (StatusInfo.StatCode != NMSDB_SUCCESS))
                                {
                                    Rcode_e = NMSMSGF_E_SRV_ERR;
                                }
                                else //we succeeded in inserting the row
                                {
                                    DBGPRINT1(FLOW,
                                      "%s Registration Done after conflict.\n",
                                           fStatic ? "STATIC" : "DYNAMIC");

                                        if (fUpdVersNo)
                                        {
                                                NMSNMH_INC_VERS_COUNTER_M(
                                                        NmsNmhMyMaxVersNo,
                                                        NmsNmhMyMaxVersNo
                                                               );

                                                //
                                                // Send a Push notification if
                                                // required
                                                //
                                                  DBGIF(fWinsCnfRplEnabled)
                                                   RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                                    NULL);
                                        }
                                }
                     }
                     else
                     {
                           //
                           // if a member needs to be added
                           //
                           if (fAddMem)
                           {

                               DWORD i;
                               PNMSDB_GRP_MEM_ENTRY_T pRegMem = &RowInfo.NodeAdds.Mem[RowInfo.NodeAdds.NoOfMems];
                               PNMSDB_GRP_MEM_ENTRY_T pCnfMem = StatusInfo.NodeAdds.Mem;
PERF("Needs to be optimized")

                               //
                               // Add the new member
                               //
                               // Note: Members in RowInfo.NodeAdds are the
                               // ones we tried to register.  We tack on
                               // all the members found in the conflicting
                               // record to it. A special group will have
                               // just one member; a multihomed record can
                               // have 1-NMSDB_MAX_MEMS_IN_GRP members.
                               //
                               // We always prefer locally registered
                               // group members to those that registered at
                               // other name servers.
                               //
                               for (
                                   i = 0;
                                   i < min(StatusInfo.NodeAdds.NoOfMems,
                                         (NMSDB_MAX_MEMS_IN_GRP - RowInfo.NodeAdds.NoOfMems));
                                   i++)
                               {
                                 *pRegMem++ = *pCnfMem++;
                               }
                               RowInfo.NodeAdds.NoOfMems += i;
                               RowInfo.pNodeAdd           = NULL;

                               //
                               // The situations where this would be
                               // FALSE is 1) when the member already exists,
                               // is owned by us and is in a record owned
                               // by us also. 2) a MH record clashes with a 
                               // non-owned MH record
                               //
                               if (!fUpdVersNo)
                               {
                                    RowInfo.fUpdVersNo = FALSE;
//                                  ASSERT(StatusInfo.OwnerId == NMSDB_LOCAL_OWNER_ID);
                               }
//                             RowInfo.CommitGrBit     = JET_bitCommitLazyFlush;
                               RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                                    );
                                if ((RetStat == WINS_SUCCESS) && (StatusInfo.StatCode == NMSDB_SUCCESS))
                                {
                                    if (fUpdVersNo)
                                    {
                                            NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                        //
                                        // Send a Push notification if required
                                        //
                                        DBGIF(fWinsCnfRplEnabled)
                                        RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);
                                    }
                               }
                               else
                               {
                                        DBGPRINT3(ERR, "NmsNmhNamRegGrp: Could not add member to the special group (%s[%x]). No Of Members existent are (%d)\n", RowInfo.pName, RowInfo.pName[15], RowInfo.NodeAdds.NoOfMems - 1);
                                        Rcode_e = NMSMSGF_E_SRV_ERR;
                               }
                           }
                           else
                           {
                             if (!fRetPosRsp)
                             {
                                 DBGPRINT1(FLOW,
                                        " %s Registration Failed. Conflict\n",
                                        fStatic ? "STATIC" : "DYNAMIC"
                                       );
                                 Rcode_e = NMSMSGF_E_ACT_ERR;
                             }
                           }
                        }
                        }
                } //RetStat from ClashAtRegGrp != WINS_SUCCESS
                else
                {
                        Rcode_e = NMSMSGF_E_SRV_ERR;
                }
       }
       else  //no conflict means success
       {
                DBGPRINT2(FLOW, "%s %s Registration Done. No conflict\n",
                                fStatic ? "STATIC" : "DYNAMIC",
                                TypeOfRec == NMSDB_MULTIHOMED_ENTRY ? "MULTIHOMED" : "GROUP");
                       NMSNMH_INC_VERS_COUNTER_M(
                                        NmsNmhMyMaxVersNo,
                                        NmsNmhMyMaxVersNo
                                       );
                DBGIF(fWinsCnfRplEnabled)
                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
       }
      }
      else  //RetStat != SUCCESS
      {
        Rcode_e = NMSMSGF_E_SRV_ERR;

      }
     } // end of try block

except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamRegGrp");
                WinsEvtLogDetEvt(FALSE, WINS_EVT_REG_GRP_ERR,
                            NULL, __LINE__, "sddd", RowInfo.pName,
                            GetExceptionCode(),
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

//                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_REG_GRP_ERR);
                Rcode_e = NMSMSGF_E_SRV_ERR;
        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_PRINT_PERF_DATA;

SNDRSP:
        //
        // Send a response only if we did not hand over the request to the
        // name challenge manager and if it is neither a STATIC initialization
        // request nor a rpc request
        //
        if ((!fChlBeingDone) && (!fStatic) && (!fAdmin))
        {

                DBGPRINT1(FLOW,
                   "NmsNmhNamRegGrp: Sending %s name registration response\n",
                           Rcode_e == NMSMSGF_E_SUCCESS ? "positive" :
                                                "negative" );

                RspInfo.Rcode_e         = Rcode_e;
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                NmsNmhSndNamRegRsp( pDlgHdl, &RspInfo );
        }

        //
        // If it is an RPC request, we need to return a success or a failure
        // indication.
        //
        if (fAdmin)
        {
                if (Rcode_e != NMSMSGF_E_SUCCESS)
                {
                            DBGLEAVE("NmsNmhNamRegGrp\n");
                        return(WINS_FAILURE);
                }
        }

        DBGLEAVE("NmsNmhNamRegGrp\n");
        return(WINS_SUCCESS);

}

#if 0
__inline
BYTE
HexAsciiToBinary(
        LPBYTE pByte
        )

/*++

Routine Description:
        This function converts two bytes (each byte contains the ascii
        equivalent of a hex character in the range 0-F) to a binary
        representation

Arguments:


Externals Used:
        None


Return Value:


Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        BYTE  Byte = 0;
        DWORD Nibbles = 0;
        do
        {
          if (*pByte >= '0' && *pByte <= '9')
          {
                Byte += (*pByte - '0') << (Nibbles * 4);
          }
          else
          {
                Byte += (*pByte - 'A') << (Nibbles * 4);
          }
          pByte++;
        } while (++Nibbles < 2);
        return(Byte);
}

BOOL
IsItSpecGrpNm(
        LPBYTE pName
        )

/*++

Routine Description:
        This function is called to check whether the name is a special
        (internel group)

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        DWORD        Index;
        DWORD   ByteIndex;
        BYTE    TmpName[16];
        LPBYTE  pTmpName = TmpName;
        LPBYTE  pSpecGrpMaskByte;
        LPBYTE  pSpecGrpMask;


        if (NMSDB_IS_IT_DOMAIN_NM_M((pName)))
        {
                return(TRUE);
        }
        else
        {
                //
                // if spec. grp mask were specified in the registry
                //
                if (WinsCnf.SpecGrpMasks.NoOfSpecGrpMasks > 0)
                {
                        //
                        // for each spec. grp mask, && it with the name
                        // and then see if the result is same as
                        // the mask.  If yes, then the name is a special group
                        //
                        for (
                                Index = 0,
                                pSpecGrpMask =
                                        WinsCnf.SpecGrpMasks.pSpecGrpMasks;
                                Index < WinsCnf.SpecGrpMasks.NoOfSpecGrpMasks;
                                Index++, pSpecGrpMask += WINSCNF_SPEC_GRP_MASK_SZ + 1
                            )
                        {
                                for (
                                        ByteIndex = 0, pSpecGrpMaskByte =
                                                        pSpecGrpMask;
                                        ByteIndex < WINSCNF_SPEC_GRP_MASK_SZ;
                                        ByteIndex++, pName++
                                    )
                                {
                                        *pTmpName++ = *pName &&
                                           HexAsciiToBinary(pSpecGrpMaskByte);

                                        //
                                        // Increment by 2 since we have two
                                        // bytes in the mask for each
                                        // character in the name
                                        //
                                        pSpecGrpMaskByte += 2;

                                }
                                if (WINSMSC_COMPARE_MEMORY_M(TmpName, pSpecGrpMask, WINSCNF_SPEC_GRP_MASK_SZ) == WINSCNF_SPEC_GRP_MASK_SZ)
                                {
                                        return(TRUE);
                                }
                                //
                                // iterate in order to get the next mask
                                //
                        }
                }
        }
        return(FALSE);
}
#endif
STATUS
NmsNmhNamRel(
        IN PCOMM_HDL_T                pDlgHdl,
        IN LPBYTE                pName,
        IN DWORD                NameLen,
        IN PCOMM_ADD_T                pNodeAdd,
        IN BOOL                        fGrp,
        IN MSG_T                pMsg,
        IN MSG_LEN_T                MsgLen,
        IN DWORD                QuesNamSecLen,
        IN BOOL                        fAdmin
        )

/*++

Routine Description:
        This function releases a record.

        In case the release succeeds, a positive name release
        response is sent, else a negative name release response is sent.

Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fAdmin                - Is it an administrative action

Externals Used:
        NmsNmhNamRegCrtSec

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T   RowInfo;      // contains row info
        NMSDB_STAT_INFO_T  StatusInfo;         /* error status and associated
                                         *  info returned by the NmsDb func
                                         */
        time_t                   ltime;  //stores time since Jan 1, 1970
        STATUS                   RetStat = WINS_FAILURE;
        NMSMSGF_RSP_INFO_T RspInfo;
        BOOL                   fBrowser = FALSE;
        BOOL                   fExcRecd = FALSE;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhNamRel\n");
        /*
        *    Initialize the row info. data structure with the data to insert
        *    into the row.  The data passed is Name, NameLen, IP address,
        *    group/unique status, timestamp, version number
        */

        RowInfo.pName     = pName;
        RowInfo.NameLen   = NameLen;

        DBGPRINT2(FLOW,
         "NmsNmhNamRel: Name To Release = %s. 16th char is (%x)\n",
                                RowInfo.pName, *(RowInfo.pName+15));

        (void)time(&ltime); //time does not return any error code
        RowInfo.TimeStamp    = ltime;     //put the current time here
        RowInfo.OwnerId      = NMSDB_LOCAL_OWNER_ID;
        RowInfo.pNodeAdd     = pNodeAdd;
        RowInfo.fAdmin       = fAdmin;

        //
        //
        // If the release is for a group, mark it as a NORMAL or a SPECIAL
        // GROUP.
        //
        if (fGrp)
        {

                //
                // Since the group bit was set in the release request pkt
                // set the EntTyp field of RowInfo to NORM_GRP (or SPEC_GRP)
                // to indicate to the callee that we want to release a group
                //
                RowInfo.EntTyp                    = NMSDB_NORM_GRP_ENTRY;
        }
        else
        {
                //
                // The entry to release can be a unique or multihomed. We
                // put UNIQUE for lack of knowing better.
                //
                RowInfo.EntTyp                    = NMSDB_UNIQUE_ENTRY;
                if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
                {
                        //
                        // It is a browser name. We always return a positive
                        // name release response.
                        //
                        fBrowser             = TRUE;
                        StatusInfo.StatCode = NMSDB_SUCCESS;
						StatusInfo.fLocal = FALSE;
                        RetStat             = WINS_SUCCESS;
                }
        }


        //
        // If it is a browser name that needs to be released, we just send
        // a positive response
        //
        if (!fBrowser)
        {
             //
             // Enter the critical section since we will be updating the record
             //
             EnterCriticalSection(&NmsNmhNamRegCrtSec);


             /*
              * Store version number (in case we change ownership to self)
             */
             RowInfo.VersNo = NmsNmhMyMaxVersNo;

             //DBG_START_PERF_MONITORING
//             WinsIntfStat.Counters.NoOfRel++;
        try {
             //
             // Release the record in the directory.
             //
#ifdef WINSDBG
             IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif
             StatusInfo.fLocal = FALSE;
             RetStat = NmsDbRelRow( &RowInfo,  &StatusInfo );
#ifdef WINSDBG
             IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamRelRow: Time in NmsDbRelRow is = (%d). RetStat is (%d msecs)\n", GetTickCount() - StartTimeInMsec,
RetStat); }
#endif

            }
       except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamRel");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_NAM_REL_ERR);
                RspInfo.Rcode_e = NMSMSGF_E_SRV_ERR;
                fExcRecd = TRUE;
            }
            if (!fExcRecd && (StatusInfo.StatCode == NMSDB_SUCCESS))
            {
              WinsIntfStat.Counters.NoOfSuccRel++;
            }
            else
            {
              WinsIntfStat.Counters.NoOfFailRel++;
            }

            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
            //DBG_PRINT_PERF_DATA
       }


        //
        // Send a response only it is not an administrator initiated request
        //
        if (!fAdmin)
        {
                if (!fExcRecd)
                {
                        RspInfo.Rcode_e =
                                ((StatusInfo.StatCode == NMSDB_SUCCESS)
                                && (RetStat == WINS_SUCCESS)) ?
                                 NMSMSGF_E_SUCCESS :
                                 NMSMSGF_E_ACT_ERR;
                }
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;

                //
                // If it is a locally registered name, mark it as such
                //
                if (StatusInfo.fLocal)
                {
                     COMM_SET_LOCAL_M(pDlgHdl);
                }

                //
                //Note: We always return the NodeType and Address that we got
                //in the request pkt. So the above fields are all that
                //need to be initialized
                //
                DBGPRINT1(FLOW, "NmsNmhNamRel: Name Release was %s\n",
                                RspInfo.Rcode_e == NMSMSGF_E_SUCCESS ?
                                        "SUCCESSFUL" : "FAILURE" );
#if 0
                WINSEVT_LOG_IF_ERR_M(
                               SndNamRelRsp(
                                pDlgHdl,
                                &RspInfo
                                    ),
                        WINS_EVT_SND_REL_RSP_ERR
                    );
#endif
                SndNamRelRsp( pDlgHdl,  &RspInfo);

        }
        else  // an RPC request
        {
                if (
                        (StatusInfo.StatCode != NMSDB_SUCCESS)
                                ||
                        (RetStat != WINS_SUCCESS)
                   )
                {
                        DBGLEAVE("NmsNmhNamRel\n");
                        return(WINS_FAILURE);
                }

        }
        DBGLEAVE("NmsNmhNamRel\n");
        return(WINS_SUCCESS);

} //NmsNmhNamRel()





STATUS
NmsNmhNamQuery(
        IN PCOMM_HDL_T                pDlgHdl,  //dlg handle
        IN LPBYTE                pName,          //Name to release
        IN DWORD                NameLen,  //length of name to release
        IN MSG_T                pMsg,          //length of message
        IN MSG_LEN_T                MsgLen,          //length of message
        IN DWORD                QuesNamSecLen, //length of question name
                                              //sec. in msg
        IN BOOL                        fAdmin,
        OUT PNMSDB_STAT_INFO_T        pStatInfo
  )

/*++

Routine Description:
        This function queries a record.


        In case the query succeeds, a positive name query
        response is sent, else a negative name query response is sent.

Arguments:

        pDlgHdl                - Dialogue Handle
        pName                - Name to be registered
        NameLen                - Length of Name
        pMsg            - Datagram received (i.e. the name request)
        Msglen          - Length of message
        QuesNamSecLen   - Length of the Question Name Section in the RFC packet
        fAdmin                - Is it an administrative action
        pStatInfo        - ptr to row information retrieved by this function


Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:


Called by:
        NmsMsgfProcNbtReq, WinsRecordAction

Side Effects:

Comments:
        None
--*/
{


        NMSDB_ROW_INFO_T      RowInfo;      // contains row info
        NMSDB_STAT_INFO_T     StatusInfo;   /* error status and associated
                                            *info returned by the NmsDb func
                                            */
        time_t                      ltime;
        STATUS                      RetStat  = WINS_SUCCESS;
        BOOL                      fBrowser = FALSE;
        BOOL                      fExcRecd = FALSE;
        NMSMSGF_RSP_INFO_T    RspInfo;
#ifdef WINSDBG
        DWORD                  StartTimeInMsec;
//        DWORD                  EndTimeInMsec;
#endif

        DBGENTER("NmsNmhNamQuery\n");

        /*
         *  Initialize the row info. data structure with the
         *  name of the entry to query
         *
        */
        RowInfo.pName   = pName;
        RowInfo.NameLen = NameLen;
        RowInfo.fAdmin  = fAdmin;

        DBGPRINT2(FLOW,
         "NmsNmhNamQuery: Name To Query = %s. 16th char is (%x)\n",
                                RowInfo.pName, *(RowInfo.pName+15));
        //
        // get the current time.
        //
        // This is required when querying special groups
        //
        (void)time(&ltime); //time does not return any error code
        RowInfo.TimeStamp    = ltime; // put current time here

        //
        // This initialization is required when query is for a special group
        //
CHECK("I don't think this is required now. Check NmsDbQueryRow")
        RowInfo.NodeAdds.Mem[0].Add.Add.IPAdd = 0;  //init to 0 since GetGrpMem
                                                    //looks at it


FUTURES("Don't check. Let it query. The query will fail")
        if (NMSDB_IS_IT_BROWSER_NM_M(RowInfo.pName))
        {
                //
                // It is a browser name. We always return a negative
                // name query response.
                //
                fBrowser             = TRUE;
                StatusInfo.StatCode = NMSDB_SUCCESS;
                RetStat             = WINS_FAILURE;
        }
        else
        {
        try {

#ifdef WINSDBG
           IF_DBG(TM) { StartTimeInMsec = GetTickCount(); }
#endif

           //
           // Query the record in the directory.
           //
           RetStat = NmsDbQueryRow(
                                &RowInfo,
                                &StatusInfo
                                             );
#ifdef WINSDBG
          IF_DBG(TM) { DBGPRINT2(TM, "NmsNmhNamQuery: Time in NmsDbQueryRow is = (%d). RetStat is (%d msecs)\n", GetTickCount() - StartTimeInMsec, RetStat); }
#endif
               } // end of try block
        except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhNamQuery");
                WINSEVT_LOG_D_M(GetExceptionCode(), WINS_EVT_NAM_QUERY_ERR);
                RspInfo.Rcode_e = NMSMSGF_E_SRV_ERR;
                fExcRecd = TRUE;
             }
        }


        //
        // Do the following only if not invoked in an RPC thread (i.e. via
        // an administrator)
        //
        if (!fAdmin)
        {
                //
                // if no exception was raised
                //
                if (!fExcRecd)
                {

FUTURES("Rcode for neg, response should be different for different error cases")
                    RspInfo.Rcode_e =
                                ((StatusInfo.StatCode == NMSDB_SUCCESS)
                                && (RetStat == WINS_SUCCESS)) ?
                                 NMSMSGF_E_SUCCESS :
                                 NMSMSGF_E_NAM_ERR;

                    if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                    {

                      DBGPRINT1(SPEC,
                                "Name queried has the fLocal flag set to %d\n",
                                StatusInfo.fLocal);

                      if (!StatusInfo.fLocal)
                      {
                        //
                        //  if this was a query for a special group, we
                        //  need to query the corresponding 1B name
                        //
#ifdef WINSDBG
                        if (NMSDB_IS_IT_DOMAIN_NM_M(RowInfo.pName))
                        {
                            DBGPRINT2(SPEC,
                                         "Answer 1C query (%d members). %s1B prepended\n",
                                         StatusInfo.NodeAdds.NoOfMems,
                                         WinsCnf.fAdd1Bto1CQueries ? "" : "No ");
                        }
#endif

                        if (NMSDB_IS_IT_DOMAIN_NM_M(RowInfo.pName) &&
                            WinsCnf.fAdd1Bto1CQueries)
                        {
                          NMSDB_ROW_INFO_T        StatusInfo2;
                          BOOL                        fExc = FALSE;
                          *(RowInfo.pName+15) = 0x1B;
                          WINS_SWAP_BYTES_M(RowInfo.pName, RowInfo.pName+15);
                          try {

                               //
                               // Query the record in the directory.
                               //
                               RetStat = NmsDbQueryRow(
                                &RowInfo,
                                &StatusInfo2
                                             );

                                  } // end of try block
                           except (EXCEPTION_EXECUTE_HANDLER) {
                              DBGPRINTEXC("NmsNmhNamQuery: Querying 1B name");
                              WINSEVT_LOG_D_M(
                                        GetExceptionCode(),
                                        WINS_EVT_NAM_QUERY_ERR
                                           );
                              fExc = TRUE;
                                 }

                           //
                           // If there was no exception or failure, add the
                           // address for the 1B name to the list. Ideally,
                           // we should check if the address is already there
                           // and if so not add it.  If not there but the
                           // number of members is < NMSDB_MAX_MEMS_IN_GRP, we
                           // should add the address at the begining shifting
                           // the other members one slot to the right (
                           // instead of replacing the last member with the
                           // first).  Checking for presence or doing the
                           // shifting will consume a lot of cycles, so it
                           // is not being done.
                           //

                           if ((RetStat != WINS_FAILURE) && !fExc)
                           {
                                if (
                                        StatusInfo.NodeAdds.NoOfMems <
                                                NMSDB_MAX_MEMS_IN_GRP
                                   )
                                {
                                   StatusInfo.NodeAdds.Mem[
                                        StatusInfo.NodeAdds.NoOfMems++] =
                                             StatusInfo.NodeAdds.Mem[0];
                                   StatusInfo.NodeAdds.Mem[0] =
                                                StatusInfo2.NodeAdds.Mem[0];
                                }
                                else
                                {
                                   StatusInfo.NodeAdds.Mem[NMSDB_MAX_MEMS_IN_GRP- 1]
                                        = StatusInfo.NodeAdds.Mem[0];
                                   StatusInfo.NodeAdds.Mem[0] =
                                        StatusInfo2.NodeAdds.Mem[0];
                                }
                           }
                        }
                       }   //if (!StatusInfo.fLocal)
                       else
                       {
                            COMM_SET_LOCAL_M(pDlgHdl);
                       }

                     } //if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                } //if (!ExcCode)
                RspInfo.pMsg                = pMsg;
                RspInfo.MsgLen          = MsgLen;
                RspInfo.QuesNamSecLen   = QuesNamSecLen;
                RspInfo.NodeTyp_e       = StatusInfo.NodeTyp;
                RspInfo.EntTyp          = StatusInfo.EntTyp;
                RspInfo.pNodeAdds       = &StatusInfo.NodeAdds;


                //
                // NOTE: Multiple NBT threads could be doing this simultaneously
                //
                //  This is the best I can do without a critical section
                //
NOTE("The count may not be correct if we have multiple worker threads")
                if (RspInfo.Rcode_e == NMSMSGF_E_SUCCESS)
                {
                        WinsIntfStat.Counters.NoOfSuccQueries++;
                }
                else
                {
#if TEST_DATA > 0
                    DWORD BytesWritten;

                    if (NmsFileHdl != INVALID_HANDLE_VALUE)
                    {
                        pName[NameLen - 1] = '\n';
                        pName[NameLen] = '\0';
                        if (!WriteFile(NmsFileHdl,
                                  pName,
                                  NameLen + 1,
                                  &BytesWritten,
                                  NULL
                                 )
                           )
                        {
                                DBGPRINT1(ERR, "Could not write name (%s) to file\n", pName);
                        }
                    }

#endif
                        WinsIntfStat.Counters.NoOfFailQueries++;
                }

                DBGPRINT1(FLOW, "NmsNmhNamQuery: %s in querying record\n",
                                RspInfo.Rcode_e == NMSMSGF_E_SUCCESS ?
                                        "SUCCEEDED" : "FAILED" );
                WINSEVT_LOG_IF_ERR_M(
                        SndNamQueryRsp(
                          pDlgHdl,
                          &RspInfo
                                      ),
                     WINS_EVT_SND_QUERY_RSP_ERR
                     );
        }
        else
        {
                //
                // We are in an RPC thread.
                //
                if (
                        (RetStat != WINS_SUCCESS)
                                ||
                        (StatusInfo.StatCode != NMSDB_SUCCESS)
                   )
                {
                        DBGLEAVE("NmsNmhNamQuery\n");
                        return(WINS_FAILURE);
                }
                else
                {
                        DWORD i;

                        pStatInfo->NodeAdds.NoOfMems =
                                        StatusInfo.NodeAdds.NoOfMems;
                        for (i=0; i < StatusInfo.NodeAdds.NoOfMems; i++)
                        {
                          pStatInfo->NodeAdds.Mem[i].Add =
                                        StatusInfo.NodeAdds.Mem[i].Add;

                          pStatInfo->NodeAdds.Mem[i].OwnerId =
                                        StatusInfo.NodeAdds.Mem[i].OwnerId;

                          pStatInfo->NodeAdds.Mem[i].TimeStamp =
                                        StatusInfo.NodeAdds.Mem[i].TimeStamp;
                        }

                        pStatInfo->VersNo    = StatusInfo.VersNo;
                        pStatInfo->OwnerId   = StatusInfo.OwnerId;
                        pStatInfo->EntTyp    = StatusInfo.EntTyp;
                        pStatInfo->TimeStamp = StatusInfo.TimeStamp;
                        pStatInfo->NodeTyp   = StatusInfo.NodeTyp;
                        pStatInfo->EntryState_e   = StatusInfo.EntryState_e;
                        pStatInfo->fStatic   = StatusInfo.fStatic;

                }

        }
        DBGLEAVE("NmsNmhNamQuery\n");
        return(WINS_SUCCESS);
} //NmsNmhNamQuery()


VOID
NmsNmhSndNamRegRsp(
        IN  PCOMM_HDL_T                              pDlgHdl,
        IN  PNMSMSGF_RSP_INFO_T        pRspInfo
        )

/*++

Routine Description:
        This function sends the name registration response to the nbt client.


Arguments:

        pDlgHdl                - Dialogue Handle
        pRspInfo         - pointer to the response info structure

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        DBGENTER("NmsNmhSndNamRegRsp\n");

        /*
         *        format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_REG,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );
        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("NmsNmhSndNamRegRsp\n");
        return;

} //NmsNmhSndNamRegRsp()


FUTURES("change return type of this function to VOID")
STATUS
SndNamRelRsp(
        IN PCOMM_HDL_T                 pDlgHdl,
        IN PNMSMSGF_RSP_INFO_T   pRspInfo
        )

/*++

Routine Description:
        This function sends the name release response to the nbt client.


Arguments:
        pDlgHdl                - Dialogue Handle
        pRspInfo         - Response Info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        DBGENTER("SndNamRelRsp\n");

        /*
                format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_REL,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );

        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("SndNamRelRsp\n");
        return(WINS_SUCCESS);

} // SndNamRelRsp()

STATUS
SndNamQueryRsp(
        IN PCOMM_HDL_T                 pDlgHdl,
        IN PNMSMSGF_RSP_INFO_T   pRspInfo
        )

/*++

Routine Description:
        This function sends the name registration response to the nbt client.

Arguments:
        pDlgHdl                - Dialogue Handle
        pRspInfo         - Response Info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        DBGENTER("SndNamQueryRsp\n");

        /*
                format the name registration response packet
        */
        NmsMsgfFrmNamRspMsg(
                        pDlgHdl,
                        NMSMSGF_E_NAM_QUERY,
                        pRspInfo
                           );
        /*
         *        Call COMM to send it.  No need to check the return status
        */
        (VOID)ECommSndRsp(
                        pDlgHdl,
                        pRspInfo->pMsg,
                        pRspInfo->MsgLen
                   );

FUTURES("When we start supporting responses > COMM_DATAGRAM_SIZE, the ")
FUTURES("deallocation call will have to change")
        /*
         *  Deallocate the Buffer
        */
        ECommFreeBuff(pRspInfo->pMsg);

        DBGLEAVE("SndNamQueryRsp\n");
        return(WINS_SUCCESS);

} // SndNamQueryRsp()

STATUS
ClashAtRegInd (
        IN  PNMSDB_ROW_INFO_T    pEntryToReg,
        IN  PNMSDB_STAT_INFO_T   pEntryInCnf,
        IN  BOOL                 fRefresh,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfAddDiff,
        OUT PBOOL                pfRetPosRsp
 )

/*++

Routine Description:

        This function is called when there is a clash at the registrationo                 of a unique entry sent by an NBT node

Arguments:
        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        fRefresh     -- indicates whether it is a registration or a refresh
                        (used only when the clash is with a multihomed entry)
        pfUpdate  -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge  -- TRUE means that conflicting entry should be challenged
        pfAddDiff    -- TRUE means that the address of the conflicting entry
                        needs to be changed (besides other fields like timestamp                        owner id, etc).  If *pfChallenge is TRUE, this field
                        is FALSE since *pfChallenge of TRUE implies address
                        change when the challenge succeeds

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegInd,  NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        STATUS                 RetStat = WINS_SUCCESS;
        DWORD                  CompAddRes;  /*Result of comparing addresses*/
        BOOL                   fOwned;
        BOOL                   fFound;

        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;
        BOOL                   fContToDyn = FALSE;

        DBGENTER("ClashAtRegInd\n");
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfAddMem     = FALSE;
        *pfAddDiff    = FALSE;
        *pfRetPosRsp  = FALSE;

        //
        // If the conflicting record was statically initialized and
        //
        if (  pEntryInCnf->fStatic )
        {
                DBGPRINT0(FLOW, "ClashAtRegInd: Clash with a STATIC record\n");


                //
                // If entry in conflict is a unique/multihomd entry, we
                // compare the address.
                //
                //
                // Since in the majority of cases, the conflict will be
                // with a unique record, we first check whether the
                // conflicting record is unique.  This saves some cyles.
                // The alternative way would have been to check whether
                // conflicting record is a group and if not do the for loop
                // For the case where the record was unique, the for loop
                // would have executed only once.
                //
                if (NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp))
                {
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                );
                }
                else
                {
                        DWORD  NoOfEnt;
                        PNMSDB_GRP_MEM_ENTRY_T pCnfMem;

                        //
                        // Entry in conflict is a group or a mh entry
                        //
                        CompAddRes = COMM_DIFF_ADD;
                        if (fRefresh &&
                              NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                        {
                           pCnfMem   =  pEntryInCnf->NodeAdds.Mem;
                           for (NoOfEnt = 0;
                                NoOfEnt < pEntryInCnf->NodeAdds.NoOfMems;
                                pCnfMem++, NoOfEnt++)
                           {
                                  //
                                  // save on cycles by comparing just the IP
                                  // address.
                                  //
NONPORT("Change to stuff within #if 0 #endif when more than one transport")
NONPORT("is supported")
                                  if (pCnfMem->Add.Add.IPAdd ==
                                               pEntryToReg->pNodeAdd->Add.IPAdd)
                                  {
                                            CompAddRes = COMM_SAME_ADD;
                                            break;
                                  }
                           } // compare refresh add. with each add in the static
                             // mh entry
                        } //a refresh clashed with a static mh entry
                }  // conflicting entry is either multihomed or a group
#if 0
                //
                // Compare with address when the entry in conflict is
                // not a group.
                //
                // NOTE: For multihomed entry, we are comparing with the
                // first (perhaps only) address.  Strictly speaking, we
                // should compare with all addresses, but this will add
                // to overhead for the majority of cases. See FUTURES
                // above.
                //
                if (!NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                {
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                );
                }
                else
                {
                        CompAddRes = COMM_DIFF_ADD;
                }
#endif
                //
                // If the record to register is not a STATIC record, we
                // return right away.  We don't update a STATIC record with a
                // dynamic record in this function (do it in NmsDbQueryNUpd when
                // called in an RPC thread -- see winsintf.c)
                //
                // If however the record to register is also STATIC, then we
                // overwrite the one in the db with it.
                //
                if (pEntryToReg->fStatic)
                {
                         //
                         // If addresses are different, we need to propagate
                         // the change right away. So, set the fAddDiff flag.
                         //
                         if  (CompAddRes == COMM_DIFF_ADD)
                         {
                                *pfAddDiff   = TRUE;
                         }

                        *pfUpdate    = TRUE;

                         //
                         // If the address changed or if we replaced a STATIC
                         // replica, we should update the version number
                         // to initiate replication
                         //
                         if (
                              (pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID)
                                        ||
                               *pfAddDiff
                            )
                         {
                                *pfUpdVersNo = TRUE;
                         }

                }
                else  // entry to register is dynamic
                {
                         //
                         // If addresses are the same, we return a positive
                         // response
                         //
                         if (CompAddRes == COMM_SAME_ADD)
                         {
                                *pfRetPosRsp   = TRUE;
                         }
                         else
                         {
                              if (fPStatic  &&
                                       !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                              {
                                   fContToDyn = TRUE;
                              }
                         }
                }
                //
                // If we don't need to conduct the tests meant for dynamic
                // records, return
                //
                if (!fContToDyn)
                {
                  DBGLEAVE("ClashAtRegInd\n");
                  return(WINS_SUCCESS);
                }
        }

        if (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
        {
           switch(StateOfEntryInCnf_e)
           {

                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;

                         CompAddRes = ECommCompAdd(
                                &pEntryInCnf->NodeAdds.Mem[0].Add,
                                pEntryToReg->pNodeAdd
                                                );
                         if (CompAddRes == COMM_DIFF_ADD)
                         {
                                *pfAddDiff = TRUE;
                         }
                         break;

                case(NMSDB_E_RELEASED):

                         CompAddRes = ECommCompAdd(
                                &pEntryInCnf->NodeAdds.Mem[0].Add,
                                pEntryToReg->pNodeAdd
                                                );

                        switch(CompAddRes)
                        {
                           case(COMM_SAME_ADD):
                                *pfUpdate    = TRUE;

#if 0
                                //
                                // If database record is a replica, we need
                                // to overwrite it with the new one (owned by
                                // the local WINS).  This means that we must
                                // update the version number to cause
                                // propagation
                                //
                                if (
                                        pEntryInCnf->OwnerId !=
                                                pEntryToReg->OwnerId
                                   )
                                {
                                   *pfUpdVersNo = TRUE;
                                }
#endif
                                //
                                // update the version number.  Maybe this
                                // record never replicated to one or more
                                // WINS servers before.  We should
                                // update the version number so that it gets
                                // replicated
                                //
                                *pfUpdVersNo = TRUE;

                                break;

                            //
                            // address is not same
                            //
                            default:

                                *pfUpdate     = TRUE;
                                *pfUpdVersNo  = TRUE;
                                *pfAddDiff    = TRUE;
                                break;
                         }
                        break;

                case(NMSDB_E_ACTIVE):

                         //
                         // We do the following only if the entry in
                         // conflict is a unique entry
                         //
                         //  If it is a group entry (normal group), we give
                         //  up trying to register.
                         //
                        CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                         );

                        switch(CompAddRes)
                        {
                                    case(COMM_SAME_ADD):
                                        //
                                        // If it is a repeat name reg.
                                        // just update the timestamp
                                        //
                                        if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                        {
                                                *pfUpdate = TRUE;
                                        }
                                        else
                                        {
                                                //
                                                // Clash is with a replica
                                                // Update both the owner id and
                                                // and the version number
                                                //
                                                *pfUpdate     = TRUE;
                                                *pfUpdVersNo  = TRUE;
                                        }
                                        break;

                                       default:


                                            *pfChallenge = TRUE;

                                          //
                                          // No need to set the pAddDiff
                                          // flag.  The above flag implies that
                                          //
                                       break;
                         }
                         break;


                default:
                        DBGPRINT1(ERR,
                         "ClashAtRegInd: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        RetStat = WINS_FAILURE;
                        break;

              }
        }
        else  //conflicting entry is a group or a multihomed entry
        {
                //
                // There are two type of group records
                //
                // Normal group -- do not contain any addresses in them so there
                //                 is no challenge to be done here.
                // Special group -- store addresses in them but the members are
                //                  not supposed to be challenged.
                //
CHECK("According to the Func. Spec. Page 14, footnote 3, we are supposed")
CHECK("to reject the unique registration regardless of the state of a group")
CHECK("--Normal or Special. Think this one through")
                if (
                        (NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                                        &&
                        (StateOfEntryInCnf_e == NMSDB_E_TOMBSTONE)
                   )
                {
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;
                }
                else  // conflicting record is  not a tombstone special group
                {
                        if (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                        {
                             //
                             // If the multihomed entry is active
                             //
                             if(StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                             {

                                DBGPRINT3(SPEC, "ClashAtRegInd: Name to reg = (%s), Vers. No (%d, %d)\n", pEntryToReg->pName, pEntryToReg->VersNo.HighPart, pEntryToReg->VersNo.LowPart);
                                //
                                // MemInGrp will remove the entry from the
                                // conflicting record if present.  That is what
                                // we want.
                                //
                                fFound = MemInGrp(
                                            pEntryToReg->pNodeAdd,
                                            pEntryInCnf,
                                            &fOwned, FALSE);


                                //
                                // If this is a refresh
                                //
                                if (fFound && fRefresh)
                                {
                                        DBGPRINT0(DET, "ClashAtRegInd: Refresh of a multihomed entry. Simple Update will be done\n");

                                        *pfAddMem = TRUE;
                                        if (!fOwned)
                                        {
                                                //
                                                // It is a refresh for an
                                                // address that is not owned
                                                // by the local WINS
                                                //
                                                *pfUpdVersNo = TRUE;
                                        }
                                }
                                else  //either address was not found or it
                                      //is a registration
                                {
                                        //
                                        // It is a registration, or a refresh
                                        // for an address not found in the
                                        // multihomed record.
                                        //
                                        // The active multihomed entry needs to
                                        // be challenged if there is atleast one                                        // address left in it.
                                        //
                                        if (pEntryInCnf->NodeAdds.NoOfMems > 0)
                                        {
                                           DBGPRINT0(DET, "ClashAtRegInd: Clash with a multihomed entry. Atleast one address is different. Resorting to challenge\n");
                                           *pfChallenge = TRUE;
                                        }
                                        else
                                        {
                                           DBGPRINT0(DET, "ClashAtRegInd: Clash with a multihomed entry. Addresses match. Will do simple update\n");

                                                //ASSERT(fFound);
                                                if (!fOwned)
                                                {
                                                        *pfUpdVersNo = TRUE;
                                                }

                                                //
                                                // Update the entry
                                                //
                                                *pfUpdate = TRUE;
                                        }
                                }
                             }
                             else //multihomed entry in conflict is a
                                  //tombstone or released
                             {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                             }
                        }
                        //
                        // if the conflicting entry is not a tombstone special
                        // group and is not multihomed (i.e. it is a normal
                        // group or active/released special group), we
                        // do nothing (i.e. reject the registration)
                        //
                }
        }

        DBGLEAVE("ClashAtRegInd\n");
        return(RetStat);

} // ClashAtRegInd()

STATUS
ClashAtRegGrp (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        IN  BOOL                fRefresh,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRetPosRsp
 )

/*++

Routine Description:

        This function is called when there is a clash at registration time
        of a group entry

Arguments:

        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        pfAddMem     -- TRUE means that the member should be added to group
        pfUpdate     -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge  -- TRUE means that conflicting entry should be challenged
        pfRetPosRsp  -- TRUE means that we should return a positive response.
                        This will be TRUE only if all other flags are
                        FALSE

Externals Used:
        None

Return Value:
   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        STATUS                 RetStat                    = WINS_SUCCESS;
        BOOL                   fOwned;
        DWORD                  i;
        BOOL                   fFound;

        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;
        BOOL                   fContToDyn = FALSE;


        DBGENTER("ClashAtRegGrp\n");

        *pfAddMem     = FALSE;
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfRetPosRsp  = FALSE;

        //
        // If the conflicting record was statically initialized and
        // we haven't been told to treat static records as P-static or
        // if the record to register is also a static record, do the following.
        //
        if ( pEntryInCnf->fStatic )
        {
                DBGPRINT0(FLOW, "ClashAtRegGrp: Clash with a STATIC record\n");
                if (pEntryToReg->fStatic)
                {
                        if (
                                ((pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                                                &&
                                (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY))
                                               ||
                                ((pEntryToReg->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                                                &&
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY))
                           )
                        {
                            // *pfAddMem = TRUE;
                            //
                            // We are not interested in finding out whether
                            // the address exists or not.  If it exists, it
                            // won't after the following call.
                            //
                            for (i=0; i < pEntryToReg->NodeAdds.NoOfMems; i++)
                            {

                               (VOID)MemInGrp(&pEntryToReg->NodeAdds.Mem[i].Add,
                                             pEntryInCnf,
                                             &fOwned, FALSE);
                               //
                               //fOwned will be FALSE if either the address does
                               //not exist or if it existed but was owned by
                               //another WINS server. For both cases, we update
                               //the version number.
                               //NOTE: In case the address exists but is a
                               //permanent one (TimeStamp == MAXULONG), fOwned
                               //returned will be TRUE. This will result
                               //in us skipping the update.
                               //Currently MAXULONG is there only for static
                               //SG members.
                               //
                               if (!*pfUpdVersNo && !fOwned)
                               {
                                *pfUpdVersNo  = TRUE;
                                *pfAddMem     = TRUE;
                               }
                             }
                             if (!*pfUpdVersNo)
                             {
                                 *pfRetPosRsp = TRUE;

                             }
                       } // both are special groups or mh names
                       else
                       {
                             *pfUpdate    = TRUE;
                             *pfUpdVersNo = TRUE;
                       }
                }
                else  // entry to register is a dynamic entry
                {
                        //
                        // We send a positive response if a normal group
                        // clashes with a statically initialized normal group
                        //
                        if ( NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp) )
                        {
                                if (NMSDB_ENTRY_NORM_GRP_M(pEntryInCnf->EntTyp))
                                {
                                   *pfRetPosRsp = TRUE;
                                }
                                //
                                // if the entry in conflict is a special group, we add
                                // this (potential) new group member to the list of members.
                                // Note: we do not touch multi-homed or unique static
                                // entry.
                                //
                                else if ( NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp) )
                                {
                                   //
                                   //NOTE: In case the address exists but is a
                                   // perm. one (TimeStamp == MAXULONG), fOwned
                                   // returned will be TRUE. This will result
                                   // in us skipping the update. Currently
                                   // MAXULONG is there only for static
                                   // SG members.
                                   //
                                   (VOID)MemInGrp(
                                             &pEntryToReg->NodeAdds.Mem[0].Add,
                                             pEntryInCnf,
                                             &fOwned, TRUE);
                                    if (!fOwned)
                                    {
                                      *pfUpdVersNo  = TRUE;
                                      *pfAddMem     = TRUE;
                                      pEntryToReg->fStatic = TRUE;
                                      pEntryToReg->EntTyp = NMSDB_SPEC_GRP_ENTRY;
                                    }
                                } else {
                                    //
                                    // the entry in conflict is either unique or multihomed
                                    //
                                    DBGPRINT1(FLOW, "ClashAtRegGrp: Conflict of a NORM. GRP (to reg) with a STATIC ACTIVE %s entry.\n",
                                    NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ? "MULTIHOMED" : "UNIQUE");
                                    //
                                    // if we are told to treat static as P-Static, then do the challenge etc.
                                    //
                                    if (fPStatic)
                                    {
                                          fContToDyn = TRUE;
                                    }

								}
                        }
                        else
                        {
                            if (
                                  (NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp))
                                                &&
                                  (NMSDB_ENTRY_SPEC_GRP_M(pEntryToReg->EntTyp))
                               )
                            {

                                  //
                                  // Always send a positive response, even
                                  // though we are not adding the address to
                                  // the list
                                  //
                                  *pfRetPosRsp = TRUE;
                            }   // both entries are special group entries
                            else
                            {
                               if (fPStatic && !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp))
                               {
                                     fContToDyn = TRUE;
                               }
                               else
                               {
                                  if (
                                   NMSDB_ENTRY_MULTIHOMED_M(pEntryToReg->EntTyp)
                                        &&
                                   (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ||
                                    NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp))
                                     )
                                   {
                                     DWORD NoOfMem;
                                     PNMSDB_GRP_MEM_ENTRY_T pCnfMem =
                                                pEntryInCnf->NodeAdds.Mem;
                                     for (NoOfMem=0;
                                       NoOfMem < pEntryInCnf->NodeAdds.NoOfMems;
                                            pCnfMem++, NoOfMem++)
                                     {
                                        //
                                        // if addresses are same, break out of
                                        // the loop
                                        //
                                        if (pCnfMem->Add.Add.IPAdd ==
                                        pEntryToReg->NodeAdds.Mem[0].Add.Add.IPAdd)
                                        {
                                                *pfRetPosRsp = TRUE;
                                                break;
                                        } //addresses match
                                      } //for loop over all members
                                    } //both entries are multihomed
                                  } // Either PStatic flag is not set or the
                                    // conflicting entry is not a group
                               } //one of the entries is not a special group
                        } //one of the entries is not a normal group
                } //entry to reg is dynamic

                //
                // If we don't need to conduct the tests meant for dynamic
                // records, return
                //
                if (!fContToDyn)
                {
                   DBGLEAVE("ClashAtRegGrp\n");
                   return(WINS_SUCCESS);
                }
        }

        //
        // We are here means that entry in conflict is either dynamic or
        // should be treated as a dynamic entry (p-dynamic)
        //

        if (pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
        {
             if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
             {
                   //
                   // If the entry is not active it means that it has
                   // no members.
                   //
                   // If it is active, we add the member if
                   // not there already.
                   //
                   if (StateOfEntryInCnf_e != NMSDB_E_ACTIVE)
                   {
                           *pfUpdate    = TRUE;
                           *pfUpdVersNo = TRUE;

                   }
                   else // entry in conflict is an ACTIVE dynamic SG entry
                   {

                        //
                        // If Entry to register is static, we have got to
                        // do an update if for no other reason than to change
                        // the flags.
                        //
                        if (pEntryToReg->fStatic)
                        {
                             *pfAddMem     = TRUE;
                             *pfUpdVersNo  = TRUE;
                             for (i = 0;i < pEntryToReg->NodeAdds.NoOfMems;i++)
                             {
                                (VOID)MemInGrp(
                                         &pEntryToReg->NodeAdds.Mem[i].Add,
                                         pEntryInCnf,
                                         &fOwned,
                                         FALSE // no need to remove replica
                                              );
                             }
                        }
                        else // entry to register is a dynamic SG entry
                        {

                          //
                          // We need to update the entry if for no other
                          // reason than to update the time stamp
                          //
                          *pfAddMem     = TRUE;

                          //
                          // We are not interested in finding out whether
                          // the address exists or not.  If it exists, it
                          // won't after the following call.
                          //
                          fFound = MemInGrp(&pEntryToReg->NodeAdds.Mem[0].Add,
                                             pEntryInCnf,
                                             &fOwned,
                                             FALSE //no need to remove replica
                                                   //mem. That will be high
                                                   //overhead
                                                );
                           //
                           // If entry is either not there or the record is
                           // a replica increment the version number.
                           //
                           if (!fFound ||
                                (pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID))
                           {
                              *pfUpdVersNo  = TRUE;
                           }

                        }
                   }
             }
             else  //entry in conflict is a normal group or a
                   //unique/multihomed entry
             {
                if (pEntryInCnf->EntTyp == NMSDB_NORM_GRP_ENTRY)
                {
CHECK("I may not want to update it. Check it")
                            *pfUpdate    = TRUE;
                            *pfUpdVersNo = TRUE;
                }
                else  //conflicting entry is a unique/multihomed entry
                {
                        if (StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                        {
                                 DBGPRINT1(FLOW, "ClashAtRegGrp: Conflict of a SPEC. GRP (to reg) with an ACTIVE %s entry.  Resorting to challenge\n",
                         NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp) ?
                         "MULTIHOMED" : "UNIQUE");
                                if (
                                        (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                                &&
                                        (pEntryInCnf->NodeAdds.NoOfMems > 0))
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                pEntryInCnf->EntTyp)
                                   )
                                {
                                        *pfChallenge = TRUE;
                                }
                                else
                                {
                                    *pfUpdate    = TRUE;
                                    *pfUpdVersNo = TRUE;
                                }
                        }
                        else  // unique/multihomed entry is either released
                              // or a tombstone
                        {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                        }
                }
             }
        }
        else   // Entry to register is a normal group/multihomed entry
        {
           //
           // If entry is a normal group
           //
           if (NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp))
           {
             switch(StateOfEntryInCnf_e)
             {

                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate    = TRUE;
                        *pfUpdVersNo = TRUE;
                        break;

                case(NMSDB_E_RELEASED):

                        if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                        {
                                *pfUpdate    = TRUE;
                                *pfUpdVersNo = TRUE;
                        }
                        else  //Normal group entry
                        {
                                //
                                // If the owner id is the same (i.e.
                                // local WINS is the owner)
                                //
                                if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                {
                                        *pfUpdate = TRUE;  //this should
                                                           //update the
                                                              //time stamp
                                }
                                else
                                {
                                        //
                                        // Update the owner id., timestamp
                                        // and version number
                                        //
                                        *pfUpdate    = TRUE;
                                        *pfUpdVersNo = TRUE;
                                }
                        }
                        break;

                //
                // Entry to register is an ACTIVE normal group entry
                // and it is clashing with an ACTIVE records in the db
                //
                case(NMSDB_E_ACTIVE):

                        if (
                                (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                        ||
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                           )
                        {
                             DBGPRINT1(FLOW, "ClashAtRegGrp: Normal Grp (to Reg) Conflicting with an ACTIVE %s entry.  Resorting to Challenge\n",
                                pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY ?                                        "UNIQUE" : "MULTIHOMED");
                                if (
                                        (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                                &&
                                        (pEntryInCnf->NodeAdds.NoOfMems > 0))
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                pEntryInCnf->EntTyp)
                                   )
                                {
                                        *pfChallenge = TRUE;
                                }
                                else
                                {
                                    *pfUpdate    = TRUE;
                                        *pfUpdVersNo = TRUE;
                                }
                        }
                        else
                        {
                             if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                             {
                                        DBGPRINT0(FLOW, "ClashAtRegGrp: Conflicting entry is an ACTIVE spec. group entry. NO UPDATE WILL BE DONE \n");

                             }
                             else //entry in cnf is an active normal group entry
                             {

                                   DBGPRINT0(FLOW, "ClashAtRegGrp: Conflicting entry is an ACTIVE normal group entry. Do a simple update \n");
                                   *pfUpdate    = TRUE;
                                   if (pEntryInCnf->OwnerId !=
                                                NMSDB_LOCAL_OWNER_ID)
                                   {
                                      *pfUpdVersNo = TRUE;
                                   }
                             }

                        }
                        break;

                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        //
                        DBGPRINT1(ERR,
                         "ClashAtRegGrp: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        RetStat = WINS_FAILURE;
                        break;
             } // end of switch
          }
          else  // entry to register is a multihomed entry
          {
                switch(StateOfEntryInCnf_e)
                {
                        //
                        // If entry in database is a tombstone, we overwrite it
                        //
                        case(NMSDB_E_TOMBSTONE):
                            *pfUpdate    = TRUE;
                            *pfUpdVersNo = TRUE;
                            break;

                        //
                        // A released entry unless it is a normal group is
                        // overwritten
                        //
                        case(NMSDB_E_RELEASED):

                          if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                          {
                                *pfUpdate    = TRUE;

                                //
                                // Even if the entry in conflict is a multihomed                                // entry, we update the version number.
                                //
                                *pfUpdVersNo = TRUE;
                          }
                          break;

                        case(NMSDB_E_ACTIVE):

                                //
                                // we resort to a challenge only if the
                                // conflicting entry is a unique or
                                // multihomed entry
                                //
                                if (
                                        NMSDB_ENTRY_MULTIHOMED_M(
                                                        pEntryInCnf->EntTyp
                                                            )
                                                ||
                                        NMSDB_ENTRY_UNIQUE_M(
                                                        pEntryInCnf->EntTyp
                                                            )
                                   )
                                {
                                        if (NMSDB_ENTRY_MULTIHOMED_M(
                                                pEntryInCnf->EntTyp)
                                           )
                                        {

                                                BOOL  fFound;
                                                DWORD i;

                                                for ( i = 0;
                                                      i < pEntryToReg->NodeAdds.NoOfMems;                                                       i++
                                                    )
                                                {

                                                   //
                                                   // If found, MemInGrp will
                                                   // remove the address from
                                                   // the Mem array of the
                                                   // conflicting record
                                                   //
                                                      fFound = MemInGrp(
                                                          &pEntryToReg->NodeAdds.Mem[i].Add,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);
                                                   //
                                                   // Address not found,
                                                   // continue to the next
                                                   // address
                                                   //
                                                   if (!fFound)
                                                   {
                                                        continue;
                                                   }

                                                   //
                                                   // if not owned by this WINS
                                                   // the version number must
                                                   // be updated if we end up
                                                   // just updating the entry (
                                                   // i.e. if fAddMem gets set
                                                   // to TRUE down below)
                                                   //
                                                   if (!fOwned)
                                                   {
                                                        *pfUpdVersNo = TRUE;
                                                   }
                                                }

                                                //
                                                // If all addresses to register
                                                // are already there in the
                                                // conflicting record and it
                                                // is a refresh or if the
                                                // addresses to register are
                                                // same as in the conflicting
                                                // record, we need to update
                                                // the timestamp and possibly
                                                // the version number (see
                                                // above).  There is no need to
                                                // do any challenge
                                                // here.
                                                //
                                                if (
                        //
                        // Note the following code would be executed only
                        // if we start supporting our own opcode for multihomed
                        // refresh (the need for this will arise if we go
                        // with the approach of refreshing multiple addresses
                        // simultaneously).
                        //
FUTURES("May need the code within #if 0 and #endif in the future. See ")
FUTURES("the comment above")
#if 0
                                                    (
                                                    (i == pEntryToReg->NodeAdds.NoOfMems)
                                                          &&
                                                        fRefresh
                                                    )
                                                         ||
#endif
                                                    (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                  )
                                                {
                        DBGPRINT0(DET, "ClashAtRegGrp: Clash between two multihomed entries.  The addresses are the same. Simple update will be done\n");
                                                    *pfAddMem = TRUE;
                                                }
                                                else
                                                {
                                                  //
                                                  // We do a challenge even
                                                  // if the conflicting entry's
                                                  // addresses are a superset
                                                  // of the addresses in the
                                                  // entry to register
                                                  //
                        DBGPRINT0(DET, "ClashAtRegGrp: Clash between two multihomed entries.  Atleast one address is different. Resorting to a challenge\n");
                                                   //
                                                   // The  multihomed entry
                                                   // needs to be challenged
                                                   //
                                                      *pfChallenge = TRUE;
                                                }
                                        }
                                        else
                                        {

                                              //
                                              // If there is any address in
                                              // the multihomed entry to
                                              // register that is different
                                              // than the address in the unique
                                              // entry, we need to challenge
                                              // the unique entry
                                              //
                                              if (
                                            (pEntryToReg->NodeAdds.NoOfMems > 1)
                                                        ||

                                            (WINSMSC_COMPARE_MEMORY_M(
                                              &pEntryToReg->NodeAdds.Mem[0].Add.Add.IPAdd,
                                                  &pEntryInCnf->NodeAdds.Mem[0].Add.Add.IPAdd, sizeof(COMM_IP_ADD_T))
                                                        != sizeof(COMM_IP_ADD_T)                                             )
                                                )

                                             {
                DBGPRINT0(DET, "ClashAtRegGrp: Clash between multihomed entry (to reg) and active unique entry. At least one address differs. Resorting to challenge\n");
                                                //
                                                // The  unique entry
                                                // needs to be challenged
                                                //
                                                *pfChallenge = TRUE;
                                             }
                                             else
                                             {
                DBGPRINT0(DET, "ClashAtRegGrp: Clash between multihomed entry (to reg) and active unique entry. Addresses same. Simple update will be done\n");
                                                //
                                                // Update the entry in the db
                                                //
                                                *pfUpdate    = TRUE;
                                                *pfUpdVersNo = TRUE;

                                             }
                                        }
                                }
#ifdef WINSDBG
                                else
                                {
                                        DBGPRINT1(FLOW, "ClashAtRegGrp: CLASH OF A MULTIHOMED ENTRY WITH AN ACTIVE %s GROUP ENTRY. NO UPDATE WILL BE DONE\n", NMSDB_ENTRY_NORM_GRP_M(pEntryInCnf->EntTyp) ? "NORMAL" : "SPECIAL");

                                }
#endif

                                break;
                }
          }

        }

        DBGLEAVE("ClashAtRegGrp\n");
        return(RetStat);

} //ClashAtRegGrp()


BOOL
MemInGrp(
        IN PCOMM_ADD_T              pAddToReg,
        IN PNMSDB_STAT_INFO_T       pEntryInCnf,
        IN PBOOL                    pfOwned,
        IN BOOL                     fRemoveReplica
        )

/*++

Routine Description:

        This function is called to check if the address of the entry to register
        is in the list of addresses in the conflicting entry.


Arguments:
        pAddToReg   - Address to Register
        pEntryInCnf - Entry in conflict

        fRemoveReplica - This will be set if the caller wants this function
                          to remove a replica member.
                          A replica (the last one in the list) will be replaced
                          only if there is no match and the number of members
                          in the list is hitting the limit.

Externals Used:
        None

Return Value:

        TRUE if the entry to register is a member of the group
        FALSE otherwise

Error Handling:

Called by:
        ClashAtRegGrp
Side Effects:

Comments:
        The two entries in conflict are special group entries.
        fRemoveReplica  will be set to TRUE only by ClashAtRegGrp when
        registering a  special group (because we prefer a local member to a
        replica)

        NOTE: if the member that matches is a permanent member as indicated
              by the timestamp (== MAXULONG), then it is not replaced.
--*/

{
        DWORD                         no;
        BOOL                          fFound = FALSE;
        DWORD                         RetVal;
        DWORD                         i;
        PNMSDB_GRP_MEM_ENTRY_T  pMem = pEntryInCnf->NodeAdds.Mem;
        BOOL                        fRplFound = FALSE;
        DWORD                   RplId = 0;                // id. of replica to
                                                        // remove.
        DWORD                   NoOfMem;

        DBGENTER("MemInGrp\n");

        *pfOwned = FALSE;

#ifdef WINSDBG
        if (pEntryInCnf->NodeAdds.NoOfMems > NMSDB_MAX_MEMS_IN_GRP)
        {
           DBGPRINT2(EXC, "MemInGrp: No of Mems in Cnf entry = (%d); Add of entry to reg. is (%x)\n", pEntryInCnf->NodeAdds.NoOfMems, pAddToReg->Add.IPAdd);
        }
#endif

        ASSERT(pEntryInCnf->NodeAdds.NoOfMems <= NMSDB_MAX_MEMS_IN_GRP);
        NoOfMem =  min(pEntryInCnf->NodeAdds.NoOfMems, NMSDB_MAX_MEMS_IN_GRP);

        //
        // Compare each member in the conflicting record against the member to
        // be  registered
        //
        for (no = 0; no < NoOfMem ; no++, pMem++ )
        {
                //
                // if the caller wants us to remove a replica member
                // for the case where there is no match
                //
                if (fRemoveReplica)
                {
                        //
                        // If the member in the conflicting record is a
                        // replica, save its index if it is more than
                        // the one we saved earlier.
                        //
                        if (pMem->OwnerId != NMSDB_LOCAL_OWNER_ID)
                        {
                                fRplFound = TRUE;
                                if (no > RplId)
                                {
                                        RplId          = no;
                                }
                        }
                }


                RetVal = (ULONG) WINSMSC_COMPARE_MEMORY_M(
                                pAddToReg,
                                &pMem->Add,
                                sizeof(COMM_ADD_T)
                           );

                if (RetVal == sizeof(COMM_ADD_T))
                {
                        //
                        // if this is a permanent member, let us set
                        // fOwned to TRUE since we do not want to
                        // replace this member. The caller will check
                        // fOwned and if TRUE will not replace it.
                        // Currently, MAXULONG can be there only for
                        // static SG members
                        if (pMem->TimeStamp == MAXLONG_PTR)
                        {
                          ASSERT(NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp));
                          *pfOwned = TRUE;
                          break;
                        }
                        fFound = TRUE;

PERF("The following is a convoluted and potentially high overhead way")
PERF("to handle a refresh for a member (i.e. when member is owned by us")
PERF("We take it out here and then add it later (with current time stamp)")
PERF("in NmsNmhNamRegGrp.  Improve this by using the code that is between.")
PERF("#if 0 and #endif. Also, when updating db, just overwrite the affected")
PERF("entry instead of writing the whole record")
                         //
                         //if the member is owned by us, *pfOwned is set to
                         //TRUE
                         //
                         if  ( pMem->OwnerId == NMSDB_LOCAL_OWNER_ID )
                         {
                                *pfOwned = TRUE;
                         }

                        //
                        // Get rid of the member whose address is the
                        // same.  The client will insert an entry for the
                        // member with the local WINS as the owner
                        // and the current timestamp.
                        //
                        for(
                             i = no;
                             i < (NoOfMem - 1);
                             i++, pMem++
                            )
                          {
                                   *pMem = *(pMem + 1);
                          }
                        --NoOfMem;
                        break;
               }
        }
        pEntryInCnf->NodeAdds.NoOfMems = NoOfMem;

        //
        // if we were asked to remove replica on no match, check if a
        // replica member was found.  Note: We remove a replica to make
        // space for a member that we got. We don't need to remove a replica
        // if there is space left in the group
        //
        if (
                fRemoveReplica &&
                !fFound &&
                fRplFound &&
                (pEntryInCnf->NodeAdds.NoOfMems == NMSDB_MAX_MEMS_IN_GRP)
            )
        {
                //
                // Remove the replica
                //
                for (
                        i = RplId, pMem = &pEntryInCnf->NodeAdds.Mem[RplId];
                        i < (pEntryInCnf->NodeAdds.NoOfMems - 1);
                        i++, pMem++
                    )
                {

                          *pMem = *(pMem + 1);

                }
                --(pEntryInCnf->NodeAdds.NoOfMems);
//                fFound = TRUE;
        }

        DBGLEAVE("MemInGrp\n");
        return(fFound);
} //MemInGrp()


VOID
RemoveAllMemOfOwner(
      PNMSDB_STAT_INFO_T pEntry,
      DWORD OwnerId
 )

/*++

Routine Description:
    Removes all members that are owned by OwnerId

Arguments:


Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
   DWORD NoOfMems = pEntry->NodeAdds.NoOfMems;
   PNMSDB_GRP_MEM_ENTRY_T pMem = &pEntry->NodeAdds.Mem[NoOfMems-1];

   DBGPRINT1(FLOW, "ENTER: RemoveAllMemOfOwner: Owner Id= (%d)\n", OwnerId);
   //
   // loop over all members of the entry starting from the last one
   //
   for (; NoOfMems > 0; NoOfMems--, pMem--)
   {
       //
       // If owner id matches, we need to remove it and decrement the
       // count
       //
       if (pMem->OwnerId == OwnerId)
       {
           DWORD No;
           DBGPRINT1(DET, "RemoveAllMemOfOwner: Removing Member with address = (%x)\n", pMem->Add.Add.IPAdd);
           //
           // shift all following members one position to the left
           //
           memcpy( pMem, (pMem + 1),
                   sizeof(NMSDB_GRP_MEM_ENTRY_T)*(pEntry->NodeAdds.NoOfMems - NoOfMems));
           pEntry->NodeAdds.NoOfMems--;
       }
   }
   DBGPRINT1(FLOW, "LEAVE: RemoveAllMemOfOwner. No Of Mems in Conflicting record = (%d)\n", pEntry->NodeAdds.NoOfMems);
   return;
}


VOID
ClashAtReplUniqueR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfInformWins
 )

/*++

Routine Description:

        This function is called when there is a clash at replication time
        between  a replica that is unique and an entry in the database

Arguments:

        pReplToReg  -- Replica that couldn't be registered due to conflict
        pEntryInCnf -- Entry in conflict
        pfUpdate    -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE
        pfChallenge -- TRUE means that conflicting entry should be challenged
        pfRelease   -- TRUE means that conflicting entry's node should be
                       asked to release the name.

                       If both pfChallenge and pfRelease are TRUE, then it
                       means that the conflicting entry should first be
                       challenged.  If the challenge fails, the node should
                       be asked to release the name. If the challenge succeeds,
                       no release need be sent
        pfInformWins -- Inform remote WINS from which we received the replica
                        about the outcome
        pfAddChgd    -- Indicates that the address got changed

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        NmsNmhReplRegInd

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        DWORD                  CompAddRes;  /*Result of comparing addresses*/
        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;

        DBGENTER("ClashAtReplUniqueR\n");
        *pfUpdate     = FALSE;
        *pfUpdVersNo  = FALSE;
        *pfChallenge  = FALSE;
        *pfRelease    = FALSE;
        *pfInformWins = FALSE;

        if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
            *pfUpdate = TRUE;
            DBGPRINT0(DET,
                    "ClashAtUniqueR: overwrite replica by same owner replica \n");
            return;
        }

        //
        // If the conflicting record was statically initialized we
        // return right away, unless the replica is also a STATIC or
        // belongs to the same owner.
        //
        if (pEntryInCnf->fStatic)
        {
                DBGPRINT0(DET, "ClashAtReplUniqueR: Clash with a STATIC record\n");
                //
                // If we have been asked to treat static records as
                // P-Static, then if the conflicting entry is not a group
                // we continue on, else we return.
                //
                if (!(fPStatic && !NMSDB_ENTRY_GRP_M(pEntryInCnf->EntTyp)))
                {
//                          WINSEVT_LOG_INFO_D_M(WINS_FAILURE, WINS_EVT_REPLICA_CLASH_W_STATIC);
                    if (WinsCnf.LogDetailedEvts > 0)
                    {
                       WinsEvtLogDetEvt(FALSE, WINS_EVT_REPLICA_CLASH_W_STATIC,
                        NULL, __LINE__, "s", pEntryToReg->pName);
                    }
                      return;

                }
        }
        else
        {
                //
                // a STATIC replica always replaces a dynamic entry.
                //
                if (pEntryToReg->fStatic)
                {
                        *pfUpdate = TRUE;
                        return;
                }
        }

        if (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
        {
           switch(StateOfEntryInCnf_e)
           {

                case(NMSDB_E_TOMBSTONE):   //fall through
                case(NMSDB_E_RELEASED):

                        *pfUpdate    = TRUE;
                        break;

                case(NMSDB_E_ACTIVE):

                        if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                        {

                                 CompAddRes = ECommCompAdd(
                                        &pEntryInCnf->NodeAdds.Mem[0].Add,
                                        pEntryToReg->pNodeAdd
                                                        );

                                switch(CompAddRes)
                                {
                                      case(COMM_DIFF_ADD):

                                        //
                                        // If entry in conflict is active
                                        // and owned by us,
                                        // tell the node of the entry to
                                        // release the name.  In other
                                        // words we always replace it
                                        // with the replica.
                                        //

                                        if (pEntryInCnf->OwnerId
                                                == NMSDB_LOCAL_OWNER_ID)
                                        {
                                                *pfChallenge     = TRUE;
                                                *pfRelease       = TRUE;
                                        //      *pfInformWins    = TRUE;
                                        }
                                        else  //D is a replica
                                        {
                                                //
                                                // replace with replica
                                                //
                                            //  *pfChallenge     = TRUE;
                                                *pfUpdate        = TRUE;
                                        }

                                        break;

                                    //
                                    // D and R  (database entry and replica
                                    // have same address)
                                    //
                                    default:
                                           *pfUpdate     = TRUE;
                                           break;
                                }
                         }
                         else   //entry to register is a Tombstone (has to be)
                         {
                                ASSERT(StateOfEntryToReg_e == NMSDB_E_TOMBSTONE);
                                //
                                // If we own the entry in the db, we need to
                                // increment its version number
                                //
                                if (pEntryInCnf->OwnerId
                                                == NMSDB_LOCAL_OWNER_ID)
                                {
                                        //
                                        // We update the version number of the
                                        // entry in the database
                                        //
                                        *pfUpdVersNo = TRUE;
                                }
                                else  //the entry in conflict is a replica
                                {
                                   //
                                   // Both replicas have the same owner.
                                   //
                                   if (
                                        pEntryInCnf->OwnerId ==
                                                  pEntryToReg->OwnerId
                                      )
                                   {
                                        *pfUpdate = TRUE;
                                   }
#ifdef WINSDBG
                                   else
                                   {
                                        DBGPRINT0(FLOW, "ClashAtReplUniqueR: Clash between two replicas with different owner ids.  Replica in db is active while one received is a tombstone. Db will not be updated\n");
                                   }
#endif

                                }

                         }
                         break;


                default:
                        //
                        // Some weirdness.
                        // Set this the pfUpdate to TRUE so that we overwrite this record.
                        *pfUpdate = TRUE;
                        DBGPRINT1(ERR,
                         "ClashAtReplUniqueR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_BAD_RECORD);
                        break;

              }
        }
        else  // the entry in conflict is a group (normal or special) entry or
              // a multihomed entry
        {
                //
                // do nothing if it is a normal group or if it is an active
                // special group.  If it is a special group and it is not
                // active, it can be replaced
                //
                if  (
                        (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                                &&
                        (StateOfEntryInCnf_e != NMSDB_E_ACTIVE)
                    )
                {
CHECK("Check with the latest spec. to make sure the following is correct")
                        //
                        // Replace with replica
                        //
                        *pfUpdate = TRUE;
                }
                else
                {
                        if (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                        {
                                if (StateOfEntryInCnf_e == NMSDB_E_ACTIVE)
                                {
                                        if (StateOfEntryToReg_e ==
                                                        NMSDB_E_ACTIVE)
                                        {
                                                if (pEntryInCnf->OwnerId ==
                                                        pEntryToReg->OwnerId
                                                   )
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: ACTIVE unique replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                        *pfUpdate = TRUE;
                                                }
                                                else
                                                {
//
//  Put within #if 0 and #endif if we want to challenge an entry regardless of
// who owns it (can result in challenges across WAN lines)
//
//#if 0
                                                     if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
//#endif
                                                  {

                                                    BOOL  fOwned;


                                                    //
                                                    // If found, MemInGrp
                                                    // will remove the
                                                    // address from
                                                    // the Mem array of the
                                                    // conflicting record
                                                    //
                                                    (VOID) MemInGrp(
                                                          pEntryToReg->
                                                            pNodeAdd,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);

                                                    if (pEntryInCnf->NodeAdds.NoOfMems != 0)
                                                    {
                                                      RemoveAllMemOfOwner(
                                                        pEntryInCnf,
                                                        pEntryToReg->OwnerId);
                                                    }
                                                    //
                                                    // Active unique replica
                                                    // has the same address as
                                                    // the owned active
                                                    // multihomed record.Replace
                                                    //
                                                    if (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                    {

                                                        *pfUpdate = TRUE;
                                                    }
                                                    else
                                                    {
                                                      //
                                                      // An active unique
                                                      // replica has clashed
                                                      // with an active
                                                      // owned multihomed entry.
                                                      // The multihomed entry
                                                      // needs to be challenged
                                                      //
                                                      *pfChallenge = TRUE;

//
// Comment out #if 0 if we want to challenge regardless of ownership
//
#if 0
                                                     if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                                     {
#endif
                                                      *pfRelease   = TRUE;
#if 0
                                                     }
#endif
                                                     // *pfInformWins = TRUE;
                                                    }
                                                  }
//
//  Put within #if 0 and #endif if we want to challenge an entry regardless of
// who owns it (can result in challenges across WAN lines). See above
//
//#if 0
                                                  else
                                                  {
CHECK("Maybe, we should not do any update in this case")
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: ACTIVE unique replica with an ACTIVE MULTIHOMED replica (diff owner). Simple Update will be done\n");

                                                        *pfUpdate = TRUE;
                                                  }
//#endif
                                                }
                                        }
                                        else // entry to register is a TOMBSTONE
                                        {
                                                if (pEntryInCnf->OwnerId ==
                                                        pEntryToReg->OwnerId
                                                   )
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: TOMBSTONE unique replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                        *pfUpdate = TRUE;
                                                }
                                                else
                                                {
                                                        DBGPRINT0(DET, "ClashAtReplUniqueR: TOMBSTONE unique replica with an ACTIVE MULTIHOMED entry (different owners). No Update will be done\n");
                                                }
                                        }
                                }
                                else // state of multihomed entry in Db is
                                     // not active. We need to replace it
                                     // with the replica
                                {
                                        *pfUpdate = TRUE;
                                }

                        }
                        else
                        {

                                DBGPRINT0(FLOW,
                                         "ClashAtReplUniqueR: Clash is either with a normal group or an active special group. No update will be done to the db\n");
                        }
                }


        }
        DBGLEAVE("ClashAtReplUniqueR\n");
        return;
} //ClashAtReplUniqueR()

VOID
ClashAtReplGrpR (
        IN  PNMSDB_ROW_INFO_T        pEntryToReg,
        IN  PNMSDB_STAT_INFO_T        pEntryInCnf,
        OUT PBOOL                pfAddMem,
        OUT PBOOL                pfUpdate,
        OUT PBOOL                pfUpdVersNo,
        OUT PBOOL                pfRelease,
        OUT PBOOL                pfChallenge,
        OUT PBOOL                pfUpdTimeStamp,
        OUT PBOOL                pfInformWins
 )

/*++

Routine Description:

        This function is called when there is a clash at replication time
        betweeen a replica that is a group and an entry in the database.

Arguments:

        pEntryToReg  -- Entry that couldn't be registered due to conflict
        pEntryInCnf  -- Entry in conflict
        pfAddMem     -- TRUE means that the members in the replica should be
                        added to  the group entry in the database
        pfUpdate     -- TRUE means Entry should overwrite the conflicting one
        pfUpdVersNo  -- TRUE means Entry's version number should be incremented
                        This arg. can never be TRUE if *pfUpdate is not TRUE

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        NmsNmhNamRegGrp

Side Effects:

Comments:
        None
--*/

{

        NMSDB_ENTRY_STATE_E    StateOfEntryToReg_e = pEntryToReg->EntryState_e;
        NMSDB_ENTRY_STATE_E    StateOfEntryInCnf_e = pEntryInCnf->EntryState_e;
        BOOL                       fMemInGrp            = FALSE;
        DWORD                       i;
        //
        // We are reading a long value.  This operation is atomic
        //
        BOOL                   fPStatic = WinsCnf.fPStatic;

        DBGENTER("ClashAtReplGrpR\n");
        *pfAddMem          = FALSE;
        *pfUpdate          = FALSE;
        *pfUpdVersNo       = FALSE;
        *pfRelease         = FALSE;
        *pfChallenge       = FALSE;
        *pfUpdTimeStamp    = TRUE;
        *pfInformWins      = FALSE;

        if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
            *pfUpdate = TRUE;
            DBGPRINT0(DET,
                    "ClashAtReplGrpR: overwrite replica by same owner replica \n");
            return;
        }

        //
        // If the conflicting record was statically initialized we
        // return right away unless the replica and the conflicting
        // entry belong to the same owner and the replica is also a
        // STATIC record.
        //
        if (pEntryInCnf->fStatic)
        {
                DBGPRINT0(DET,
                        "ClashAtReplGrpR: Conflict with a STATIC entry\n");



              //
              // if both records are user defined special groups, do
              // same conflict handling as you would when a
              // the conflicting record is a dynamic record
              //
              if (!((NMSDB_ENTRY_USER_SPEC_GRP_M(pEntryToReg->pName, pEntryToReg->EntTyp)) &&
                    (NMSDB_ENTRY_SPEC_GRP_M(pEntryInCnf->EntTyp))))
              {
                 if ((NMSDB_ENTRY_NORM_GRP_M(pEntryToReg->EntTyp)) &&
                    (NMSDB_ENTRY_USER_SPEC_GRP_M(pEntryToReg->pName, pEntryInCnf->EntTyp)))
                 {

NOTE("Currently, NORM GRP can have the wrong owner id. since this is not")
NOTE("replicated.  The owner id. of the WINS being pulled from is used")
                          *pfAddMem       = UnionGrps(
                                                     pEntryToReg,
                                                     pEntryInCnf
                                                    );
                           if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                           {
                                    *pfUpdVersNo    = *pfAddMem;
                           }
                           pEntryToReg->EntTyp = NMSDB_SPEC_GRP_ENTRY;
                           return;

                 }
                 else
                 {

                   //
                   // If static records need to be treated as P-static and
                   // the conflicting entry as well as the entry to register
                   // are multihomed, we continue on, else we return
                   //
                   if (!(fPStatic && (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp)) && (NMSDB_ENTRY_MULTIHOMED_M(pEntryToReg->EntTyp))))
                   {
                    if (WinsCnf.LogDetailedEvts > 0)
                    {
                       WinsEvtLogDetEvt(FALSE, WINS_EVT_REPLICA_CLASH_W_STATIC,
                        NULL, __LINE__, "s", pEntryToReg->pName);
//                         WINSEVT_LOG_INFO_D_M(WINS_FAILURE, WINS_EVT_REPLICA_CLASH_W_STATIC);
                    }
                     return;
                   }
                }
              }
        }

        if (pEntryToReg->EntTyp == NMSDB_SPEC_GRP_ENTRY)
        {
             switch(StateOfEntryInCnf_e)
             {
                case(NMSDB_E_TOMBSTONE):
                        *pfUpdate = TRUE;
                        break;
                case(NMSDB_E_RELEASED):
                        if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                        {
                                *pfUpdate = TRUE;
                        }
                        break;

                case(NMSDB_E_ACTIVE):

                       if (pEntryInCnf->EntTyp == NMSDB_SPEC_GRP_ENTRY)
                       {
                          if (StateOfEntryToReg_e == NMSDB_E_TOMBSTONE)
                          {
                            if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                            {
                                *pfUpdTimeStamp = FALSE;
                                *pfUpdVersNo    = TRUE;
                                // we should propagate this change right away
                                // because others think this is a tombstone
                                // record.

                                RPL_PUSH_NTF_M(RPL_PUSH_PROP, NULL, NULL, NULL);

                            }
                            else
                            {
                                //
                                // SG Tombstone replica clashed with a SG
                                // Active replica.  We
                                // replace it (in other words, make it a
                                // tombstone).  It makes sense since if this
                                // SG was really active, it would be owned
                                // by another owner (any time a member is
                                // registered, the ownership becomes that
                                // of the registering WINS).
                                // and so if this name is really active,
                                // the owner wins will push it back
                                // as active.
                                //
                                *pfUpdate = TRUE;

                                // In order to propagate this
                                // conflict to the owner quickly, trigger
                                // push with propagation unless owner himself
                                // sent this tombstone.
                                if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId) {
                                    RPL_PUSH_NTF_M(RPL_PUSH_PROP, NULL, NULL, NULL);
                                }

                                DBGPRINT0(FLOW, "ClashAtReplGrpR: TOMBSTONE spec. grp. replica clashed with ACTIVE spec. grp replica. No update will be done\n");
                            }
                          }
                          else //EntryToReg is ACTIVE
                          {
                                   *pfAddMem       = UnionGrps(
                                                         pEntryToReg,
                                                         pEntryInCnf
                                                        );
                                   if (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                   {
                                        *pfUpdVersNo    = *pfAddMem;
                                   }
                          }
                       }
                       else  //Entry in conflict is an active normal group
                             //or unique/multihomed entry
                       {
                         if  (
                                (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                ||
                                (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                             )
                         {
                                //
                                // The following means that we are overwriting
                                // an active unique entry with an active or
                                // tombstone special group replica.
                                //
                                if (
                                    (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                                &&
                                    (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                  )
                                {
        DBGPRINT0(DET, "ClashAtReplGrpR: Active spec. grp replica clashed with owned active unique/multihomed entry. Owned entry will be released\n");
                                    *pfRelease = TRUE;
                                }
                                else
                                {
                                   if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                   {
        DBGPRINT0(DET, "ClashAtReplGrpR: Spec. grp replica clashed with same owner's active/multihomed entry. Simple update will be done\n");
                                        *pfUpdate = TRUE;
                                   }
                                }
                         }
#ifdef WINSDBG
                        else
                        {
                                DBGPRINT0(FLOW, "ClashAtReplGrpR: Clash is with an active normal group. No change needs to be made to the db\n");
                        }
#endif
                       }
                      break;
                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        // Set this the pfUpdate to TRUE so that we overwrite this record.
                        *pfUpdate = TRUE;
                        DBGPRINT1(ERR,
                         "ClashAtReplGrpR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_BAD_RECORD);
                        break;
          } //end of switch
        }
        else   // Entry to register is a normal group entry or a multihomed
               // entry
        {
           if (pEntryToReg->EntTyp == NMSDB_MULTIHOMED_ENTRY)
           {
             switch(StateOfEntryInCnf_e)
             {
                   case(NMSDB_E_TOMBSTONE):
                          *pfUpdate = TRUE;
                          break;
                   case(NMSDB_E_RELEASED):
                          if (pEntryInCnf->EntTyp != NMSDB_NORM_GRP_ENTRY)
                          {
                                *pfUpdate = TRUE;
                          }
                          break;
                   case(NMSDB_E_ACTIVE):
                        if (
                              (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                ||
                              (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                           )
                        {
                                if (StateOfEntryToReg_e == NMSDB_E_TOMBSTONE)
                                {
                                        //
                                        // if Db entry is a replica
                                        //
                                        if (
                                                pEntryInCnf->OwnerId !=
                                                   NMSDB_LOCAL_OWNER_ID
                                           )
                                        {
                                          //
                                          // if replica to reg and replica in
                                          // in db have the same owner,
                                          // we replace the active db entry
                                          // with the tombstone replica
                                          //
                                          if (pEntryInCnf->OwnerId
                                                == pEntryToReg->OwnerId)
                                          {
                                                *pfUpdate = TRUE;
                                          }
#ifdef WINSDBG
                                          else
                                          {
                                                DBGPRINT1(DET, "ClashAtReplGrpR:CLASH BETWEEN TOMBSTONE MULTIHOMED REPLICA WITH AN ACTIVE %s REPLICA IN DB. REPLICAS HAVE DIFFERENT OWNERS.  DB REPLICA WILL NOT BE UPDATED\n",
        NMSDB_ENTRY_UNIQUE_M(pEntryInCnf->EntTyp) ? "UNIQUE" : "MULTIHOMED");
                                          }
#endif
                                         }
                                        else //db entry is active and is owned
                                             //by us.
                                        {
                                            //
                                            // Remove all members owned by the
                                            // WINS server that owns this
                                            // Tombstone replica from the
                                            // entry in  conflict.
                                           if (NMSDB_ENTRY_MULTIHOMED_M(pEntryInCnf->EntTyp))
                                           {
                                            BOOL  fFound = FALSE;
                                            BOOL  fAtLeastOneRm = FALSE;
                                            BOOL  fOwned;
                                            PNMSDB_GRP_MEM_ENTRY_T  pMem =
                                             pEntryToReg->NodeAdds.Mem;
                                            for ( i = 0;
                                                      i < pEntryToReg->NodeAdds.NoOfMems;                                                       i++, pMem++
                                                    )
                                            {
                                                   if (pMem->OwnerId == pEntryToReg->OwnerId)
                                                   {
PERF("Actually, we should only remove those members that are owned by the")
PERF("remote WINS server. The current way (members with same address removed")
PERF("is less efficient since it can result in challenges when the members")
PERF("that are removed refresh with the local WINS server")

                                                      //
                                                      // If found, MemInGrp will
                                                      // remove the address from
                                                      // the Mem array of the
                                                      // conflicting record
                                                      //
                                                      fFound = MemInGrp(
                                                          &pMem->Add,
                                                           pEntryInCnf,
                                                           &fOwned,
                                                           FALSE);
                                                       }
                                                       if (!fAtLeastOneRm && fFound)
                                                       {
                                                           fAtLeastOneRm = TRUE;
                                                       }

                                            }

                                            //
                                            // If atleast one member was
                                            // found, put in the new member
                                            // list in the db.
                                            //
                                            if (fAtLeastOneRm)
                                            {
                                                PNMSDB_GRP_MEM_ENTRY_T pCnfMem, pRegMem;
                                                pCnfMem = pEntryInCnf->NodeAdds.Mem;
                                                pRegMem = pEntryToReg->NodeAdds.Mem;
                                                for (i=0;
                                                      i < pEntryInCnf->NodeAdds.NoOfMems;                                                i++, pRegMem++,pCnfMem++
                                                    )
                                               {
                                                 *pRegMem = *pCnfMem;

                                               }
                                               pEntryToReg->NodeAdds.NoOfMems =
                                                pEntryInCnf->NodeAdds.NoOfMems;

                                               //
                                               // if no. of mems left is > 0, it
                                               // means that the record is
                                               // still active.
                                               //
                                               if (pEntryToReg->NodeAdds.NoOfMems != 0)
                                               {
                                                pEntryToReg->EntryState_e = NMSDB_E_ACTIVE;
                                               }
                                               //
                                               // Setting *pfAddMem to TRUE
                                               // ensures that the new list
                                               // gets in
                                               //

                                               *pfAddMem = TRUE;

                                            }
                                           }

                                            //
                                            //
                                            // We update the version number
                                            // of the entry in the database
                                            // to cause propagation
                                            //

                                            *pfUpdVersNo = TRUE;
                                        }
                                }
                                else  //State Of Entry to Reg has to be ACTIVE
                                {
                                        //
                                        // Clash of an ACTIVE multihomed replica
                                        // with an active unique/multihomed
                                        // entry. We need to challenge the
                                        // conflicting
                                        // entry
                                        //
                                        if (pEntryInCnf->OwnerId ==
                                                pEntryToReg->OwnerId)
                                        {
                                                DBGPRINT0(DET, "ClashAtReplGrpR: ACTIVE unique/multihomed replica with an ACTIVE MULTIHOMED replica (same owner). Update will be done\n");
                                                *pfUpdate = TRUE;
                                        }
                                        else
                                        {
//
// Uncomment if challenge is desired instead of a simple update
//
//#if 0
                                                    if (pEntryInCnf->OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID)
//#endif
                                                    {
                                                      DWORD i;
                                                      BOOL  fOwned;
                                                  PNMSDB_GRP_MEM_ENTRY_T pRegMem= pEntryToReg->NodeAdds.Mem;

                                                      for ( i = 0;
                                                        i <
                                                         pEntryToReg->NodeAdds.NoOfMems;
                                                         i++, pRegMem++ )
                                                      {

                                                           //
                                                           //If found, MemInGrp
                                                           // will remove the
                                                           // address from
                                                           // the Mem array of
                                                           // the conflicting
                                                           // record
                                                           //
                                                           (VOID) MemInGrp(
                                                            &pRegMem->Add,
                                                            pEntryInCnf, &fOwned,
                                                          FALSE);

                                                      }
                                                     if (pEntryInCnf->NodeAdds.NoOfMems != 0)
                                                     {
                                                      RemoveAllMemOfOwner(
                                                          pEntryInCnf,
                                                          pEntryToReg->OwnerId);

                                                      }
                                                      if (pEntryInCnf->NodeAdds.NoOfMems == 0)
                                                      {
 DBGPRINT0(DET, "ClashAtReplGrpR: Clash between active unique/multihomed with an owned unique/multihomed entry with subset/same address(es).  Simple update will be done\n");
                                                        *pfUpdate = TRUE;
                                                      }
                                                      else
                                                      {
                                                          //
                                                          //An active mh. rpl
                                                          //clashed with an
                                                          //active owned unique
                                                          //or multih entry.
                                                          //The multih entry
                                                          //needs to be
                                                          //challenged
                                                          //
 DBGPRINT0(DET, "ClashAtReplGrpR: Active multihomed replica with an owned unique/multihomed entry with one or more different address(es).  Challenge of owned entry will be done\n");
                                                       *pfChallenge = TRUE;
//
// Uncomment if challenge is desired instead of a simple update
//
#if 0
                                                    if (pEntryInCnf->OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID)
                                                    {
#endif
                                                       *pfRelease = TRUE;
                                                       //*pfInformWins = TRUE;
#if 0
                                                    }
#endif
                                                      }
                                                     }
//
// comment if challenge is desired instead of a simple update
//
//#if 0
                                                     else
                                                     {
                    DBGPRINT0(DET, "ClashAtReplGrpR: ACTIVE multihomed replica with an ACTIVE MULTIHOMED/UNIQUE replica (diff owner). Update will be done\n");

                                                        *pfUpdate = TRUE;
                                                     }
//#endif
                                              } // end of else (Entry to reg has
                                             // different owner than
                                             // conflicting entry

                                 } // end of else (EntryToReg is ACTIVE)
                   } //end of if entry in conflict is a unique/multihomed
#ifdef WINSDBG
                   else
                   {
                        DBGPRINT0(DET, "ClashAtReplGrpR: Clash of an active multihomed entry with an active group entry. No Update will be done\n");

                   }
#endif
                   break;
             }
           }
           else  //entry to register is a normal group entry
           {
             switch(StateOfEntryInCnf_e)
             {

                    case(NMSDB_E_RELEASED):

                              // fall through

                    case(NMSDB_E_TOMBSTONE):
                           *pfUpdate    = TRUE;
                           break;



                    case(NMSDB_E_ACTIVE):
                           if (
                                    (pEntryInCnf->EntTyp == NMSDB_UNIQUE_ENTRY)
                                                    ||
                                    (pEntryInCnf->EntTyp == NMSDB_MULTIHOMED_ENTRY)
                              )
                           {
                                  //
                                  // replace unique entry with this normal
                                  // group only if the group is active
                                  //
                                  if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                  {

  DBGPRINT0(DET, "ClashAtReplGrpR: Clash of ACTIVE normal group entry with an owned unique/multihomed entry in db. It will be released\n");
                                        if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                        {
                                                *pfRelease = TRUE;
                                        }
                                        else
                                        {
  DBGPRINT0(DET, "ClashAtReplGrpR: Clash of ACTIVE normal group entry with a replica unique/multihomed entry in db. Simple update will be done\n");
                                           *pfUpdate = TRUE;

                                        }
                                }
                        }
                        else // entry in conflict is a normal or special group
                        {

                                if (pEntryInCnf->EntTyp == NMSDB_NORM_GRP_ENTRY)
                                {
                                  //
                                  // We own it but so does another WINS.
                                  // We store the replica just in
                                  // case, all the clients have started
                                  // registering  with other WINS servers.
                                  //
                                  //
                                  // Aside: It is possible that members of
                                  // the normal  group are going to us and to
                                  // another WINS.  This is the worst case as
                                  // far as replication traffic is concerned.
                                  //
                                  //
                                  //If the owned entry is ACTIVE and the
                                  //pulled entry an out of date TOMBSTONE
                                  //(will only happen if WINS server we are
                                  //pulling from was down for a while), we
                                  //will not replace the record
                                  //
                                  if (pEntryInCnf->OwnerId ==
                                                NMSDB_LOCAL_OWNER_ID)
                                  {
                                        if (StateOfEntryToReg_e !=
                                                        NMSDB_E_TOMBSTONE)
                                        {
                                                *pfUpdate = TRUE;
                                        }
                                  }
#if 0
                                        if (pEntryInCnf->OwnerId == NMSDB_LOCAL_OWNER_ID)
                                        {
                                           //
                                           // update the version number to
                                           // cause propagation
                                           //
                                           *pfUpdVersNo = TRUE;
                                        }
#endif
                                             else
                                             {
                                                    //
                                                    // Entry owned is a replica.
                                                    // We need to update it with
                                                    // the new replica if the
                                                    // owner id is the same.
                                                    //
                                                    if (pEntryInCnf->OwnerId == pEntryToReg->OwnerId)
                                                    {
                                                        *pfUpdate = TRUE;
                                                    }
                                                    else
                                                    {
                                                        DBGPRINT0(DET, "ClastAtReplGrpR: Clash between two normal group replicas owned by different owners. No update is needed\n");
                                                    }

                                            }
                                }
#ifdef WINSDBG
                                //
                                // Actually we should never have a normal group
                                // clashing with a special group since only
                                // a name ending with 1c is a special group.
                                //
                                else // entry in conflict is a special group
                                {
                                   //
                                   // Since it is an active special
                                   // group entry there is no need to update it
                                   //
                                   if (StateOfEntryToReg_e == NMSDB_E_ACTIVE)
                                   {
                                        DBGPRINT0(DET, "ClashAtReplGrpR: Clash between an ACTIVE normal group replica and an active special group entry in the db. No Update will be done\n");
                                   }
                                   else
                                   {
                                      DBGPRINT0(DET, "ClashAtReplGrpR: Clash between a TOMBSTONE normal and an active SPEC GRP entry. Db won't be updated\n");
                                   }
                                }
#endif
                        }
                        break;

                default:
                        //
                        //  Something really wrong here. Maybe the
                        //  database got corrupted.
                        //
                        DBGPRINT1(ERR,
                         "ClashAtReplGrpR: Weird state of entry in cnf (%d)\n",
                          StateOfEntryInCnf_e
                                 );
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        WINS_RAISE_EXC_M(WINS_EXC_FAILURE);
                        break;
             }
          }

        }
        DBGLEAVE("ClashAtReplGrpR\n");
        return;

} //ClashAtReplGrpR()





STATUS
NmsNmhReplRegInd(
        IN LPBYTE          pName,
        IN DWORD           NameLen,
        IN PCOMM_ADD_T     pNodeAdd,
        IN DWORD           Flag,
        IN DWORD            OwnerId,
        IN VERS_NO_T       VersNo,
        IN PCOMM_ADD_T     pAddOfRemWins
        )

/*++

Routine Description:
        This function registers a replica in the directory database.

        A record in the database comprises of the following fields
                name
                IP address
                time stamp
                owner id.
                flags byte that contain the following information
                                group/unique status
                                node type (P or M)

                version number



Arguments:
        pName           - Name to be registered
        NameLen         - Length of Name
        Flag            - Flag word
        pNodeAdd        - NBT node's address
        OwnerId         - Owner if the record (WINS that registered it)
        VersNo                - Version Number

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:

        PullEntries in rplpull.c

Side Effects:

Comments:
        None
--*/

{


        NMSDB_ROW_INFO_T       RowInfo;    // contains row info
        NMSDB_STAT_INFO_T      StatusInfo; /* error status and associated
                                            * info returned by the NmsDb func
                                           */
        BOOL                   fUpdate;    //indicates whether conflicting entry
                                           //needs to be overwritten
        BOOL                   fUpdVersNo; //indicates whether version number
                                           //needs to be incremented
        BOOL                   fChallenge; //indicates whether a challenge needs
                                           //to be done
        BOOL                   fRelease;   //indicates whether a node should
                                           // be asked to release the name
        BOOL                   fInformWins; //indicates whether the remote WINS
                                            //has to be apprised of the clash
                                            //result. Can be TRUE only if both
                                            //fChallenge and fRelease are TRUE
        time_t                   ltime;     //stores time since Jan 1, 1970
        STATUS                   RetStat = WINS_SUCCESS;
        NMSCHL_CMD_TYP_E   CmdTyp_e;        //type of command specified to
                                            //NmsChl
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhReplRegInd\n");

        fUpdate =   FALSE;

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is

        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        RowInfo.pName     =  pName;
        RowInfo.NameLen   =  NameLen;
        RowInfo.pNodeAdd  =  pNodeAdd;
        RowInfo.NodeTyp   =  (BYTE)((Flag & NMSDB_BIT_NODE_TYP)
                                        >> NMSDB_SHIFT_NODE_TYP);
                                                  //Node type (B, P or M node)
        RowInfo.EntTyp    =  NMSDB_UNIQUE_ENTRY;  // this is a unique
                                                  //registration

        (void)time(&ltime); //time does not return any error code
        RowInfo.EntryState_e = NMSDB_ENTRY_STATE_M(Flag);
        RowInfo.OwnerId      = OwnerId;
        RowInfo.VersNo       = VersNo;
        RowInfo.fUpdVersNo   = TRUE;
        RowInfo.fUpdTimeStamp= TRUE;
        RowInfo.fStatic      = NMSDB_IS_ENTRY_STATIC_M(Flag);
        RowInfo.fLocal       = FALSE;
        RowInfo.fAdmin             = FALSE;
//        RowInfo.CommitGrBit   = 0;

        DBGPRINT4(DET, "NmsNmhReplRegInd: Name (%s);16th char (%X);State (%d); Entry is (%s)\n", RowInfo.pName, *(RowInfo.pName+15),RowInfo.EntryState_e, RowInfo.fStatic ? "STATIC" : "DYNAMIC");
       DBGPRINT2(DET,"Vers. No. is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);

        /*
        * Enter Critical Section
        */
PERF("Try to get rid of this or atleast minimise its impact")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING

try
  {
        if ( NMSDB_ENTRY_TOMB_M(Flag) ) {
            RowInfo.TimeStamp    =  ltime + WinsCnf.TombstoneTimeout;
        }
        else if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
            RowInfo.TimeStamp    =  ltime + WinsCnf.RefreshInterval;
        }
        else
        {
             RowInfo.TimeStamp    = ltime + WinsCnf.VerifyInterval;
        }

        /*
        *   Insert record in the directory
        */
        RetStat = NmsDbInsertRowInd(
                          &RowInfo,
                          &StatusInfo
                         );


      if (RetStat == WINS_SUCCESS)
      {
        /*
         * If there is a conflict, do the appropriate processing
        */
        if (StatusInfo.StatCode == NMSDB_CONFLICT)
        {

                DBGPRINT0(FLOW, "NmsNmhReplRegInd: Name Conflict\n");
                  ClashAtReplUniqueR(
                        &RowInfo,
                        &StatusInfo,
                        &fUpdate,
                        &fUpdVersNo,
                        &fChallenge,
                        &fRelease,
                        &fInformWins
                          );

                //
                // if we need to challenge a node or release a name
                // hand over the request to the name challenge manager
                //
                if ((fChallenge) || (fRelease))
                {

                    DBGPRINT0(FLOW,
                        "NmsNmh: Handing name registration to challenge manager\n");
                    /*
                     *        Ask the Name Challenge component to take it from
                     *        here
                    */
                    if (fChallenge)
                    {
                        if (fRelease)
                        {
                          if (!fInformWins)
                          {
                             //
                             // Set this since we use it when we do the release.
                             //
                             RowInfo.NodeAdds.NoOfMems        = 1;
                             RowInfo.NodeAdds.Mem[0].OwnerId  = OwnerId;
                             RowInfo.NodeAdds.Mem[0].TimeStamp   = RowInfo.TimeStamp;
                             RowInfo.NodeAdds.Mem[0].Add   = *pNodeAdd;

                             //
                             // Clash with active/multihomed
                             //
                             CmdTyp_e = NMSCHL_E_CHL_N_REL;
                          }
                          else
                          {
                             //
                             // We will never enter this code.
                             //
                             ASSERT(0);
                             CmdTyp_e = NMSCHL_E_CHL_N_REL_N_INF;
                          }
                       }
                       else
                       {
                             CmdTyp_e = NMSCHL_E_CHL;

                       }
                    }
                    else
                    {
                        if (fRelease)
                        {

                                if (!fInformWins)
                                {

                                        CmdTyp_e = NMSCHL_E_REL;
                                }
                                else
                                {
                                        //
                                        // We will never enter this code.
                                        //
                                        ASSERT(0);
                                        CmdTyp_e = NMSCHL_E_REL_N_INF;
                                }
                        }
                    }

                    NmsChlHdlNamReg(
                                CmdTyp_e,
                                WINS_E_RPLPULL,
                                NULL,
                                NULL,
                                0,
                                0,
                                &RowInfo,
                                &StatusInfo,
                                pAddOfRemWins
                                       );


            }
            else  // it is not a request for the name challenge manager
            {

                   //
                   //  If version number needs to be updated, do so
                   if (fUpdVersNo)
                   {
                        RowInfo.VersNo       = NmsNmhMyMaxVersNo;
                        RowInfo.fUpdTimeStamp = FALSE;
                        RetStat = NmsDbUpdateVersNo(
                                        TRUE,
                                        &RowInfo,
                                        &StatusInfo
                                       );
                        DBGPRINT1(FLOW,
                         "NmsNmhReplRegInd: Version Number changed to (%d)\n",
                          NmsNmhMyMaxVersNo);
                   }
                   else
                   {
                      if (fUpdate)
                      {

                           //
                           // The row needs to be updated
                           //
                           RetStat = NmsDbUpdateRow(
                                        &RowInfo,
                                        &StatusInfo
                                       );
                      }
                      else  //no update need be done
                      {
                        StatusInfo.StatCode = NMSDB_SUCCESS;
                        DBGPRINT0(FLOW,
                         "Repl Registration (unique entry) not needed for this Conflict\n");
                      }
                  }

FUTURES("Use WINS status codes. Get rid of NMSDB status codes -- Maybe")
                  if (
                       (RetStat != WINS_SUCCESS) ||
                       (StatusInfo.StatCode != NMSDB_SUCCESS)
                     )
                  {
                        RetStat = WINS_FAILURE;
                        DBGPRINT5(ERR, "NmsNmhReplUniqueR: Could not update Db with replica %s[%x] of Owner Id (%d) and Vers. No (%d %d)\n", RowInfo.pName, *(RowInfo.pName + 15), RowInfo.OwnerId, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);
                  }
                  else //we succeeded in inserting the row
                  {
                        DBGPRINT0(FLOW, "NmsNmhReplRegInd: Updated Db\n");
                        if (fUpdVersNo)
                        {
                          NMSNMH_INC_VERS_COUNTER_M(
                                        NmsNmhMyMaxVersNo,
                                        NmsNmhMyMaxVersNo
                                               );
                          //
                          // Send a Push Notification if required
                          //
                          DBGIF(fWinsCnfRplEnabled)
                          RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);

                        }

                 }
            }
       }
#ifdef WINSDBG
       else  //no conflict means success
       {

                DBGPRINT0(FLOW,
                  "NmsNmhReplRegInd:Replica Registration Done. No conflict\n");
       }
#endif

      } // end of if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
      else
      {
        DBGPRINT0(ERR, "NmsNmhReplRegInd: Could not register replica\n");
      }
#endif
    } // end of try block
except (EXCEPTION_EXECUTE_HANDLER) {
        DWORD   ExcCode = GetExceptionCode();

                DBGPRINTEXC("NmsNmhReplRegInd");
                DBGPRINT4(EXC, "NmsNmhNamReplRegInd. Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
          RowInfo.VersNo.LowPart, RowInfo.OwnerId);
                WinsEvtLogDetEvt(FALSE, WINS_EVT_RPL_REG_UNIQUE_ERR,
                            NULL, __LINE__, "sdddd", RowInfo.pName,
                            ExcCode,
                            pAddOfRemWins != NULL ? pAddOfRemWins->Add.IPAdd : 0,
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);

            if (WINS_EXC_BAD_RECORD == ExcCode && fUpdate) {
                // The row needs to be updated
                DBGPRINT4(EXC, "NmsNmhNamReplRegInd. Bad Record will overwitten by Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
                                  RowInfo.VersNo.LowPart, RowInfo.OwnerId);
                RetStat = NmsDbUpdateRow(&RowInfo,&StatusInfo);
                if ( WINS_SUCCESS == RetStat && NMSDB_SUCCESS == StatusInfo.StatCode ) {
                    NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                    // Send a Push Notification if required
                    DBGIF(fWinsCnfRplEnabled)
                    RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
                } else {
                    // dont let bad record stop replication.
                    RetStat = WINS_SUCCESS;
                }
            } else {
                RetStat = WINS_FAILURE;
            }
        }

    LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    //DBG_PRINT_PERF_DATA
    return(RetStat);

}  //NmsNmhReplRegInd()




STATUS
NmsNmhReplGrpMems(
        IN LPBYTE               pName,
        IN DWORD                NameLen,
        IN BYTE                 EntTyp,
        IN PNMSDB_NODE_ADDS_T   pGrpMem,
        IN DWORD                Flag,                 //change to take Flag byte
        IN DWORD                OwnerId,
        IN VERS_NO_T            VersNo,
        IN PCOMM_ADD_T          pAddOfRemWins
        )

/*++

Routine Description:
        This function is called to register a replica of a group

Arguments:
        pName   - Name of replica to register
        NameLen - Length of the name
        EntTyp  - Type of replica (Normal group or special group)
        pGrpMem - Address of array of group members
        Flag    - Flag word of replica record
        OwnerId - Owner Id
        VersNo  - Version No.

Externals Used:
        NmsNmhNamRegCrtSec


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --   WINS_FAILURE

Error Handling:

Called by:
        PullEntries() in rplpull.c

Side Effects:

Comments:
        None
--*/

{

        DWORD  i;
        NMSDB_ROW_INFO_T   RowInfo;
        time_t             ltime;
        NMSDB_STAT_INFO_T  StatusInfo;
        STATUS             RetStat = WINS_SUCCESS;
        BOOL               fUpdate;      //indicates whether conflicting entry
                                         //needs to be overwritten
        BOOL               fUpdVersNo;   //indicates whether version number
                                         //needs to be incremented
        BOOL               fAddMem;      //indicates whether a member needs to
                                         //be added
        BOOL               fRelease;     //indicates whether a node should
                                         // be asked to release the name
        BOOL               fChallenge;   //indicates whether a node should
                                         // be challenged (will be set to TRUE
                                         // only for the multihomed scenario)
        BOOL               fUpdTimeStamp;  //indicates whether the time stamp
                                         // of the entry should be changed
        BOOL               fInformWins;
        NMSCHL_CMD_TYP_E   CmdTyp_e;     //type of command specified to NmsChl
        //DBG_PERFMON_VAR

        DBGENTER("NmsNmhReplGrpMems\n");

        fUpdate =   FALSE;

        /*
        *  initialize the row info. data structure with the data to insert into
        *  the row.  The data passed is

        *  Name, NameLen, IP address, group/unique status,
        *  timestamp, version number
        */
        RowInfo.pName = pName;

        RowInfo.NameLen = NameLen;
        RowInfo.NodeAdds.NoOfMems = pGrpMem->NoOfMems;

PERF("Since this function will be called multiple times, it would be better")
PERF("to call time() in the caller (i.e. PullEntries)")
        (void)time(&ltime);         //time() does not return any error code

        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        if ( NMSDB_ENTRY_TOMB_M(Flag) ) {
            ltime += WinsCnf.TombstoneTimeout;
        }
        else if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
              ltime  +=  WinsCnf.RefreshInterval;
        }
        else
        {
              ltime  +=  WinsCnf.VerifyInterval;

        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);

        if (EntTyp != NMSDB_NORM_GRP_ENTRY)
        {
                if (EntTyp == NMSDB_MULTIHOMED_ENTRY)
                {
                   //
                   // For multihomed nodes
                   //
                   RowInfo.NodeTyp   =  (BYTE)((Flag & NMSDB_BIT_NODE_TYP)
                                                >> NMSDB_SHIFT_NODE_TYP);
                }
                else
                {
                   RowInfo.NodeTyp = 0;
                }

                //
                // It is a special group entry or a multihomed entry
                //
                for(i=0; i<pGrpMem->NoOfMems; i++)
                {
                   RowInfo.NodeAdds.Mem[i].Add       = pGrpMem->Mem[i].Add;
                   RowInfo.NodeAdds.Mem[i].OwnerId   = pGrpMem->Mem[i].OwnerId;
                   RowInfo.NodeAdds.Mem[i].TimeStamp = ltime;
#if 0
NOTE("Currently, the timestamp of the record or those of its members is not")
NOTE("replicated.  There is no need for this.  In the future, if a WINS server")
NOTE("starts looking at the timestamps of non-owned members of a special group")
NOTE("or a multihomed entry, we would need to replicate this")

                   RowInfo.NodeAdds.Mem[i].TimeStamp =
                                                   pGrpMem->Mem[i].TimeStamp;
#endif
                }

                RowInfo.pNodeAdd = NULL;
        }
        else  // replica is a normal group
        {
                RowInfo.pNodeAdd = &pGrpMem->Mem[0].Add;
                RowInfo.NodeAdds.Mem[0].Add       = pGrpMem->Mem[0].Add;
                RowInfo.NodeAdds.Mem[0].OwnerId   = pGrpMem->Mem[0].OwnerId;
                RowInfo.NodeAdds.Mem[0].TimeStamp = ltime;
                RowInfo.NodeTyp = 0;
        }

        RowInfo.EntTyp       =  EntTyp;
        RowInfo.OwnerId      =  (BYTE)OwnerId;           // this is a replica
        RowInfo.VersNo       =  VersNo;
        RowInfo.TimeStamp    =  ltime;
        RowInfo.EntryState_e =  NMSDB_ENTRY_STATE_M(Flag);
        RowInfo.fUpdVersNo   =  TRUE;
        RowInfo.fUpdTimeStamp=  TRUE;
        RowInfo.fStatic      =  NMSDB_IS_ENTRY_STATIC_M(Flag);
        RowInfo.fAdmin       =  FALSE;
        RowInfo.fLocal       =  FALSE;
//        RowInfo.CommitGrBit  =  0;

        DBGPRINT5(DET, "NmsNmhReplGrpMems: Name (%s);16th char (%X);State (%d); Static flag (%d); Entry is a %s\n", RowInfo.pName, *(RowInfo.pName+15), RowInfo.EntryState_e, RowInfo.fStatic,
        (EntTyp == NMSDB_NORM_GRP_ENTRY ? "NORMAL GROUP" : (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? "SPECIAL GROUP" : "MULTIHOMED"));
       DBGPRINT2(DET, "Vers. No. is (%d %d)\n", VersNo.HighPart, VersNo.LowPart);

        /*
        * Enter Critical Section
        */
PERF("Try to get rid of this or atleast minimise its impact")
        EnterCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_START_PERF_MONITORING
try  {
        RetStat = NmsDbInsertRowGrp(
                        &RowInfo,
                        &StatusInfo
                       );
       if (RetStat == WINS_SUCCESS)
       {
                /*
                * If there is a conflict, do the appropriate processing
                */
                if (StatusInfo.StatCode == NMSDB_CONFLICT)
                {

                         DBGPRINT0(FLOW, "NmsNmhReplGrpMems: Name Conflict\n");

                         ClashAtReplGrpR(
                                &RowInfo,
                                &StatusInfo,
                                &fAddMem,
                                &fUpdate,
                                &fUpdVersNo,
                                &fRelease,
                                &fChallenge,
                                &fUpdTimeStamp,
                                &fInformWins
                                        );

PERF("Might want to examine which cases happen most often and then rearrange")
PERF("this so that the most often expected cases come first in the following")
PERF("if tests")
                        //
                        // if fRelease or fChallenge (will be set only for
                        // multihomed case) is TRUE, we don't look at any other
                        // attributes
                        //
                        if (fRelease)
                        {
                                  DBGPRINT0(FLOW,
                                  "NmsNmhReplGrpMems: Handing name registration to challenge manager\n");

                                if (fChallenge)
                                {
                                   /*
                                    *Ask the Name Challenge comp to take it from
                                    *here. fInformWins will not ever by TRUE as
                                    * it stands currently 10/15/98 (has been
                                    * the case since the beginning).
                                   */
                                   CmdTyp_e = (fInformWins ?
                                                NMSCHL_E_CHL_N_REL_N_INF :
                                                        NMSCHL_E_CHL_N_REL);
                                }
                                else
                                {
                                   CmdTyp_e = NMSCHL_E_REL;
                                }

                                    NmsChlHdlNamReg(
                                                CmdTyp_e,
                                                WINS_E_RPLPULL,
                                                NULL,
                                                NULL,
                                                0,
                                                0,
                                                &RowInfo,
                                                &StatusInfo,
                                                pAddOfRemWins
                                                     );
                        }
                        else  // we need to handle this in this thread only
                        {
                           //
                           // If one or more members have to be added to the
                           // list already there (RowInfo.NodeAdds will have
                           // these new members)
                           //
                           if (fAddMem)
                           {

                                //
                                // The owner stays the same
                                //
                                //RowInfo.OwnerId = StatusInfo.OwnerId;

                                //
                                //  If vers number needs to be updated, do so
                                //
                                //  Note: This should never happen if the
                                //        record in the db is not owned by this
                                //        WINS
                                //
                                if (fUpdVersNo)
                                {
                                       //
                                       // The owner stays the same.  We will
                                       // never update the version number
                                       // unless it is owned by the local WINS
                                       //
                                       RowInfo.OwnerId = NMSDB_LOCAL_OWNER_ID;
                                       RowInfo.VersNo  = NmsNmhMyMaxVersNo;
                                       ASSERT(StatusInfo.OwnerId ==
                                                        NMSDB_LOCAL_OWNER_ID);
                                }

                                //
                                // If fUpdVersNo is not set, it means that
                                // the record is owned by another WINS. Because
                                // we are adding a member, we should change
                                // both the owner id and the version number
                                // to that of the current record. In other
                                // words, do an update. This will ensure that
                                // partners of this WINS will see the changed
                                // member list.
                                //
#if 0
                                else
                                {
                                    RowInfo.fUpdVersNo   =  FALSE;
                                }
#endif

                                RetStat =   NmsDbUpdateRow (
                                                &RowInfo,
                                                &StatusInfo
                                                         );
                           }
                           else // no member needs to be added
                           {
                                //
                                //  If vers number needs to be updated, do so
                                //
                                if (fUpdVersNo)
                                {
                                        RowInfo.VersNo    = NmsNmhMyMaxVersNo;
                                        //
                                        // we use the attribute fUpdTimeStamp
                                        // only if fUpdVersNo is TRUE (and
                                        // fAddMem == FALSE)
                                        //
                                        RowInfo.fUpdTimeStamp = fUpdTimeStamp;
                                        RetStat =   NmsDbUpdateVersNo(
                                                         TRUE,
                                                         &RowInfo,
                                                         &StatusInfo
                                                                       );
                                }
                                else
                                {
                                        //
                                        // If the entire record needs to be
                                        // updated do so.
                                        //
                                        if (fUpdate)
                                        {
                                                RetStat =   NmsDbUpdateRow(
                                                        &RowInfo,
                                                        &StatusInfo
                                                                    );
                                                DBGPRINT0(FLOW,
                                           "NmsNmhReplGrpMems: Updated Db\n");
                                        }
                                        else
                                        {
                                            StatusInfo.StatCode = NMSDB_SUCCESS;
                                            DBGPRINT0(FLOW,
                                                     "Repl Registration (group) not needed for this conflict\n");
                                        }
                                }  // vers no. not to be incremented
                           } // no member needs to be added

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - Maybe")
                           //we succeeded in inserting the row
                           if (
                              (RetStat != WINS_SUCCESS) ||
                              (StatusInfo.StatCode != NMSDB_SUCCESS)
                              )
                           {
                               RetStat = WINS_FAILURE;
                               DBGPRINT5(ERR, "NmsNmhReplGrpR: Could not update Db with replica %s[%x] of Owner Id (%d) and Vers. No (%d %d)\n", RowInfo.pName, *(RowInfo.pName + 15), RowInfo.OwnerId, RowInfo.VersNo.HighPart, RowInfo.VersNo.LowPart);
                           }
                           else
                           {
                                if (fUpdVersNo)
                                {
                                        NMSNMH_INC_VERS_COUNTER_M(
                                                NmsNmhMyMaxVersNo,
                                                NmsNmhMyMaxVersNo
                                                               );
                                        DBGIF(fWinsCnfRplEnabled)
                                        RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL,
                                                        NULL);

                                }
                           }
                        }  // need to handle it in this thread only
                 }
                 else  //no conflict means success
                 {

                        DBGPRINT0(FLOW,
                                "Replica Registration Done. No conflict\n");
                 }
        } // end of if (RetStat == WINS_SUCCESS)
#ifdef WINSDBG
        else
        {
                DBGPRINT0(ERR,
                        "NmsNmhReplGrpMems: Could not register replica\n");
        }
#endif
    } // end of try block
except (EXCEPTION_EXECUTE_HANDLER) {
         BYTE Tmp[20];
         DWORD   ExcCode = GetExceptionCode();
         DBGPRINT1(EXC, "NmsNmhReplGrpMems: Got exception (%d)\n",
                                        ExcCode);
         WinsEvtLogDetEvt(FALSE, WINS_EVT_RPL_REG_GRP_MEM_ERR,
                            NULL, __LINE__, "sdsdd", RowInfo.pName,
                            ExcCode,
                            pAddOfRemWins != NULL ? _itoa(pAddOfRemWins->Add.IPAdd, Tmp, 10) : "SEE AN EARLIER LOG",
                            RowInfo.VersNo.LowPart, RowInfo.VersNo.HighPart);
         if (WINS_EXC_BAD_RECORD == ExcCode && fUpdate) {
             // The row needs to be updated
             DBGPRINT4(EXC, "NmsNmhNamReplGrpMems. Bad Record will overwitten by Name is (%s), Version No  (%d %d); Owner Id (%d)\n", RowInfo.pName, RowInfo.VersNo.HighPart,
                               RowInfo.VersNo.LowPart, RowInfo.OwnerId);
             RetStat = NmsDbUpdateRow(&RowInfo,&StatusInfo);
             if ( WINS_SUCCESS == RetStat && NMSDB_SUCCESS == StatusInfo.StatCode ) {
                 NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                 // Send a Push Notification if required
                 DBGIF(fWinsCnfRplEnabled)
                 RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
             } else {
                 // dont let bad record stop replication.
                 RetStat = WINS_SUCCESS;
             }
         } else {
             RetStat = WINS_FAILURE;
         }

          RetStat = WINS_FAILURE;
        }

        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //DBG_PRINT_PERF_DATA
        DBGLEAVE("NmsNmhReplGrpMems\n");
        return(RetStat);

} //NmsNmhReplGrpMems()



BOOL
UnionGrps(
        PNMSDB_ROW_INFO_T        pEntryToReg,
        PNMSDB_ROW_INFO_T        pEntryInCnf
        )

/*++

Routine Description:
        This function is called to create a union of special groups

Arguments:
        pEntryToReg - Entry to register
        pEntryInCnf - Entry In conflict

Externals Used:
        None

Return Value:
        TRUE  if the union is a superset
        FALSE otherwise

Error Handling:

Called by:
        ClashAtReplGrpR

Side Effects:

Comments:
        None
--*/

{

        DWORD                         no;
        DWORD                         i, n;
        BOOL                        fFound;
        BOOL                        fToRemove;
        BOOL                        fUnion = FALSE;
        PNMSDB_GRP_MEM_ENTRY_T        pCnfMems;
        PNMSDB_GRP_MEM_ENTRY_T        pRegMems;
        PNMSDB_ADD_STATE_T        pOwnAddTbl = pNmsDbOwnAddTbl;
        BOOL                        fMemToReplaceFound;
        DWORD                        IdOfMemToReplace;
        DWORD                        EntryInCnfMemsBeforeUnion;
        DWORD                        EntryToRegMemsBeforeUnion;

        DBGENTER("UnionGrps\n");


        DBGPRINT2(DET, "UnionGrps: No Of Mems To register = (%d)\nNo Of Mems in Conflicting record = (%d)\n",
                                pEntryToReg->NodeAdds.NoOfMems,
                                pEntryInCnf->NodeAdds.NoOfMems
                   );
        //
        // Remember the number of members in the conflicting record before
        // performing the union. After the union, if the list grows, we make the
        // local wins owner of this record NMSDB_LOCAL_OWNER_ID. This causes
        // the verid to go up and hence will update the member list of this record
        // in our replication partner dbs.
        //
        EntryInCnfMemsBeforeUnion = pEntryInCnf->NodeAdds.NoOfMems;
        EntryToRegMemsBeforeUnion = pEntryToReg->NodeAdds.NoOfMems;

        //
        // First, remove all members from the conflicting record that
        // are owned by the WINS whose replica we pulled but are not
        // in the list of the remote WINS sever owned members of the replica
        //
        pCnfMems              = pEntryInCnf->NodeAdds.Mem;
        for (i=0; i < pEntryInCnf->NodeAdds.NoOfMems; )
        {
           if (pCnfMems->OwnerId == pEntryToReg->OwnerId)
           {
              pRegMems = pEntryToReg->NodeAdds.Mem;
              fToRemove = TRUE;
              for (no=0; no < pEntryToReg->NodeAdds.NoOfMems; no++, pRegMems++)
              {

                    if (pCnfMems->OwnerId != pRegMems->OwnerId)
                    {
                         //
                         // OwnerId is different from that of the replica,
                         // go to the next member in the list
                         //
                         continue;
                    }
                    else  //owner id same as that of replica member
                    {
                         if (pCnfMems->Add.Add.IPAdd != pRegMems->Add.Add.IPAdd)
                         {
                                  //
                                  // IP add. different, continue on so that
                                  // we compare with the next member in
                                  // the replica
                                  //
                                  continue;
                         }
                         else  //ip addresses are same
                         {
                                 fToRemove = FALSE;
                                 break;
                         }
                    }
              } // end of for
              if (fToRemove)
              {
                     PNMSDB_GRP_MEM_ENTRY_T pMem;
                     DBGPRINT4(FLOW, "UnionGrps: REMOVING conflicting member no = (%d) of (%s) with owner id. = (%d)  and address (%x)\n", i, pEntryToReg->pName, pCnfMems->OwnerId, pCnfMems->Add.Add.IPAdd);
                     pMem = pCnfMems;
                     for (n = i; n < (pEntryInCnf->NodeAdds.NoOfMems - 1); n++)
                     {
                        *pMem = *(pMem + 1);
                        pMem++;
                     }
                     pEntryInCnf->NodeAdds.NoOfMems--;
                     if (!fUnion)
                     {
                          fUnion = TRUE;
                     }
                     continue;
              }
           }
           i++;
           pCnfMems++;
        } // end of for (loop over conflicting members)

        //
        // For each member in the record to register, do the following..
        //
        pRegMems = pEntryToReg->NodeAdds.Mem;
        for(i=0; i < pEntryToReg->NodeAdds.NoOfMems; pRegMems++, i++)
        {
                    fFound = FALSE;

                  DBGPRINT3(DET, "UnionGrps: Member no (%d) of record to register has IP address = (%d) and owner id. = (%d)\n", i, pRegMems->Add.Add.IPAdd,
                               pRegMems->OwnerId
                          );
                  //
                  // Check against all members of the record in conflict
                  //
                  pCnfMems              = pEntryInCnf->NodeAdds.Mem;
                  fMemToReplaceFound = FALSE;
                  for(no=0; no < pEntryInCnf->NodeAdds.NoOfMems; no++, pCnfMems++)
                  {
                        DBGPRINT3(DET, "UnionGrps: Comparing with member (%d) of conflicting record. Member address is (%d) and owner id is (%d)\n",
                                no, pCnfMems->Add.Add.IPAdd, pCnfMems->OwnerId);

                        //
                        // If the address is the same and the owner Id is the
                        // same, we break out of the loop in order to check
                        // the next member of the record to register's list
                        //
                        if (
                                pCnfMems->Add.Add.IPAdd ==
                                        pRegMems->Add.Add.IPAdd
                           )
                        {
                                if ( pCnfMems->OwnerId == pRegMems->OwnerId )
                                {
                                        DBGPRINT3(DET, "UnionGrps: IP address = (%d) with owner id. of (%d) is already there in conflicting group (%s)\n",
                                        pRegMems->Add.Add.IPAdd,
                                        pRegMems->OwnerId,
                                        pEntryToReg->Name
                                                  );

                                        //
                                        // set fFound to TRUE so that this
                                        // member is not added to StoreMems
                                        // later on in this for loop.
                                        //
                                        fFound = TRUE;
                                }
                                else  //same IP address, but different owners
                                {
                                        DBGPRINT4(DET, "UnionGrps: IP address = (%d) (with owner id. of (%d)) is already there in conflicting group (%s) but is owned by (%d) \n",
                                        pRegMems->Add.Add.IPAdd,
                                        pRegMems->OwnerId,
                                        pEntryToReg->Name,
                                        pCnfMems->OwnerId,
                                                );
                                        fFound     = TRUE;

                                        //
                                        // if the timestamp is MAXULONG, then
                                        // we should not replace the owner id.
                                        //Currently MAXULONG is there only for
                                        //static SG members.
                                        //
                                        if (pCnfMems->TimeStamp != MAXLONG_PTR)
                                        {
                                         //
                                         // Replace the owner id of the member
                                         // in the conflicting record with that
                                         // of the member in the record to reg
                                         //
                                         pCnfMems->OwnerId = pRegMems->OwnerId;

                                         //
                                         // Set fUnion to TRUE so that the
                                         // caller of this function increments
                                         // the version count (only if the
                                         // conflicting record is owned; In such
                                         // a case, we want to propagate the
                                         // record)
                                         //
                                         fUnion = TRUE;
                                       }
                                }

                                //
                                // break out of the for loop;
                                // We are done with this member of the
                                // record to register
                                //
                                break;

                        }
                        else
                        {
                           //
                           // Addresses don't match.  If the member in the
                           // conflicting record is not owned by the local
                           // WINS it might be a candidate for replacement
                           // if we don't find a member with a matching
                           // address.  NOTE: a member with a timestamp of
                           // MAXULONG is not to be replaced.
                           // Currently, only a static SG member can have
                           // a MAXULONG value
                           //
                           if ((pCnfMems->OwnerId != NMSDB_LOCAL_OWNER_ID)
                                              &&
                              (pCnfMems->TimeStamp != MAXLONG_PTR))

                           {
                             if (
                                  !fMemToReplaceFound
                                        &&
                                  ((pOwnAddTbl + pCnfMems->OwnerId)->MemberPrec
                                                  <
                                  (pOwnAddTbl + pRegMems->OwnerId)->MemberPrec)

                                )
                             {
                                     fMemToReplaceFound = TRUE;
                                     IdOfMemToReplace   = no;
                             }
                           }

                        }
                 } // for (..) for looping over all mem. of conflicting record

                 //
                 // If we did not find the member in conflicting record
                 // we insert it into StoreMems if there are vacant slots
                 // at the end
                 //
                 if(!fFound)
                 {
                    if (pEntryInCnf->NodeAdds.NoOfMems < NMSDB_MAX_MEMS_IN_GRP)
                    {
                        //
                        //  add the member of the record to register to
                        //  StoreMems
                        //
                        pEntryInCnf->NodeAdds.Mem[
                                pEntryInCnf->NodeAdds.NoOfMems++] = *pRegMems;

                        fUnion = TRUE;
                   }
                   else
                   {
                        //
                        // if there is atleast one remote member of lower
                        // precedence value, replace it
                        //
                        if (fMemToReplaceFound)
                        {
                                pEntryInCnf->NodeAdds.Mem[IdOfMemToReplace] =
                                                                *pRegMems;
                                fUnion = TRUE;
                        }
                        //
                        // check the next member in the pulled in replica
                        //
                   }
                 }
        }  // end of for loop

        //
        // if the conflicting member list was changed,
        // Copy all information in pEntryInCnf->NodeAdds to
        // pEntryToReg->NodeAdds
        //
        if (fUnion)
        {
          pRegMems = pEntryToReg->NodeAdds.Mem;
          pCnfMems = pEntryInCnf->NodeAdds.Mem;
          for (
                        i=0;
                        i < pEntryInCnf->NodeAdds.NoOfMems;
                        i++, pRegMems++, pCnfMems++
              )
          {
                *pRegMems = *pCnfMems;
          }
          pEntryToReg->NodeAdds.NoOfMems = pEntryInCnf->NodeAdds.NoOfMems;
        }

        // if the new list is bigger, make the local wins the owner of this record.
        if ( pEntryInCnf->NodeAdds.NoOfMems > EntryInCnfMemsBeforeUnion &&
             pEntryInCnf->NodeAdds.NoOfMems > EntryToRegMemsBeforeUnion )
        {
            if ( pEntryInCnf->OwnerId != NMSDB_LOCAL_OWNER_ID ) {
                // change the timestamp to verifyinterval so that this record does not get
                // scavenged.
                time((time_t*)&(pEntryToReg->TimeStamp));
                pEntryToReg->TimeStamp += WinsCnf.VerifyInterval;
                pEntryInCnf->OwnerId = NMSDB_LOCAL_OWNER_ID;
                DBGPRINT3(DET, "UnionGrps: Conflicting mem# %d, registering record mem %d, new list# %d - ownership changed\n",
                          EntryInCnfMemsBeforeUnion, EntryToRegMemsBeforeUnion, pEntryInCnf->NodeAdds.NoOfMems);
            }
        }

        DBGPRINT1(FLOW,
                "UnionGrps: Union %s\n", (fUnion ? "DONE" : "NOT DONE"));
        DBGLEAVE("UnionGrps\n");
        return(fUnion);
} //UnionGrps

VOID
NmsNmhUpdVersNo(
        IN  LPBYTE                pName,
        IN  DWORD                NameLen,
        OUT LPBYTE                pRcode,
        IN  PCOMM_ADD_T         pWinsAdd
        )

/*++

Routine Description:
        This function is called to update the version number of a record

Arguments:

        pName                - Name to be registered
        NameLen                - Length of Name
        pRcode                - result of the operation
        WinsId          - Id of WINS that initiated this operation
                                (not used currently)

Externals Used:

        NmsNmhNamRegCrtSec

Return Value:
        None

Error Handling:

Called by:

        HandleUpdVersNoReq in rplpush.c

Side Effects:

Comments:
        NOTE: This function is supposed to be called only by the PUSH
        thread.  It should *NOT* be called by the PULL thread.  This
        is because of the inherent assumption made by this function
        regarding the type of index to set at the exit point of the function

--*/

{

        NMSDB_ROW_INFO_T   RowInfo;    // contains row info
        NMSDB_STAT_INFO_T  StatusInfo; /* error status and associated
                                        * info returned by the NmsDb func
                                        */
//        time_t                   ltime;        //stores time since Jan 1, 1970

        DBGENTER("NmsNmhUpdVersNo\n");

        /*
        * initialize the row info. data structure with the data to insert into
        * the row.  The data passed is

        * Name, NameLen, address, group/unique status,
        * timestamp, version number
        */
        RowInfo.pName         = pName;
        RowInfo.NameLen       =  NameLen;
        //(void)time(&ltime);               //time does not return any error code
        //RowInfo.TimeStamp     = ltime; // put current time here
        RowInfo.fUpdVersNo    = TRUE;
        RowInfo.fUpdTimeStamp = FALSE;
        RowInfo.fAdmin        = FALSE;        //does not really have to be set

        //
        // Set the current index to the name column
        //
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                            );
        /*
        * Enter Critical Section
        */
        EnterCriticalSection(&NmsNmhNamRegCrtSec);

        /*
          Store version number
        */
        RowInfo.VersNo        = NmsNmhMyMaxVersNo;

try {
           NmsDbUpdateVersNo(
                                        FALSE,
                                        &RowInfo,
                                        &StatusInfo
                                       );

FUTURES("Use WINS status codes. Get rid of NMSDB status codes - maybe")
           if (StatusInfo.StatCode != NMSDB_SUCCESS)
           {
                        *pRcode = NMSMSGF_E_SRV_ERR;
           }
           else
           {
                DBGPRINT0(FLOW, "NmsNmhUpdVersNo:Vers. No incremented \n");
                       NMSNMH_INC_VERS_COUNTER_M(
                                NmsNmhMyMaxVersNo,
                                NmsNmhMyMaxVersNo
                                       );
                *pRcode = NMSMSGF_E_SUCCESS;
                DBGIF(fWinsCnfRplEnabled)
                RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, pWinsAdd, NULL);
           }

  }
except (EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("NmsNmhUpdVersNo");
                WINSEVT_LOG_D_M(GetExceptionCode(),WINS_EVT_UPD_VERS_NO_ERR);
        }
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        //
        // Set the current index to the owner-version # columns
        //
        NmsDbSetCurrentIndex(
                                NMSDB_E_NAM_ADD_TBL_NM,
                                NMSDB_NAM_ADD_PRIM_INDEX_NAME
                            );
        return;
} //NmsNmhUpdVersNo()



/*
       Clash scenarios:

        Clash of a active unique replica with a normal group, any state:                        Keep the normal group.  Group may be a T because the router
                is down.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\rpl\rpl.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        rpl.c

Abstract:
        This module contains functions used by the COMSYS and NMS components
        of WINS.  It also contains functions used by both the Pull and Push
        handler components of the Replicator

Functions:
        RplInit
        RplInsertQue
        RplFindOwnerId
        RplPushProc

Portability:

        This module is portable


Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include <winsock2.h>
#include "nms.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsque.h"
#include "winsthd.h"
#include "comm.h"
#include "nmsnmh.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "rplpull.h"
#include "rplpush.h"


/*
 *        Local Macro Declarations
 */
#define INIT_REC_BUFF_HEAP_SIZE                1000            //1000 bytes

//
// defines for the local message sent by the replicator to the Push/Pull
// thread and for setting the opcode in such a message
//
#define LOCAL_RPL_MSG_SZ        (RPL_OPCODE_SIZE + COMM_BUFF_HEADER_SIZE + sizeof(LONG))
#define SET_OPCODE_M(pBuff, Opc)  {                                \
                                     *((pBuff) + LOCAL_RPL_MSG_SZ + 3) = \
                                                (Opc);                        \
                                  }
#define USER_PORTION_M(pMsg)        (pMsg + COMM_BUFF_HEADER_SIZE + sizeof(LONG))
#define USER_LEN_M(TotalLen)        (TotalLen - COMM_BUFF_HEADER_SIZE - sizeof(LONG))
/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */
HANDLE            RplWrkItmHeapHdl;
#if 0
HANDLE            RplRecHeapHdl;
#endif

HANDLE                RplSyncWTcpThdEvtHdl; //Sync up with the TCP thread
//
// critical section to guard the RplPullOwnerVersNo array
//
CRITICAL_SECTION  RplVersNoStoreCrtSec;

/*
 *        Local Variable Definitions
 */

//
// Critical Section that is instantiated only if this WINS server has
// one or more Push Partners
//
CRITICAL_SECTION  sPushNtfCrtSec;

/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */
STATUS
ERplInit(
        VOID
)

/*++

Routine Description:
        This function is called to initialize the replicator.

        It creates the PULL and PUSH threads

Arguments:
        pRplConfigRec        - A list of configuration records

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        Init() in nms.c

Side Effects:

Comments:
        Replicator connections are dynamic.  They are initiated when
        needed and terminated when they have served their purpose.

        If the connections were to be made STATIC, we would do the
        following in the above function:


        Start a dialogue with each pull partner.  Also
        creates a dialogue with each of the WINS servers that we have to
        send a notification to.
--*/
{

        STATUS         RetStat;


        //
        // Make a copy of the magic number
        //
        RplPullCnfMagicNo        = WinsCnf.MagicNo;


        /*
        * Create heap for allocating Rpl work items
        */
        DBGPRINT0(HEAP_CRDL, "ERplInit: Rpl Wrk. Item. Heap\n");
        RplWrkItmHeapHdl =  WinsMscHeapCreate(
                                0,    /*to have mutual exclusion        */
                                RPL_WRKITM_BUFF_HEAP_SIZE
                                        );

#if 0
        /*
        * Create heap for allocating memory for names that are longer
        * than 17 characters and for storing group members when the
        * number of members are > 5
        */
        RplRecHeapHdl =  WinsMscHeapCreate(
                                0,    /*to have mutual exclusion        */
                                INIT_REC_BUFF_HEAP_SIZE
                                        );
#endif

        /*
          We create a PULL thread regardless of whether or not there
          was a PULL record in the configuration info (in the registry).
          This is because another WINS could send this WINS a push
          notification.  This push notification will be received by the
          PUSH thread which will forward it to the PULL thread.

          Considering that a situation where an RQ server in a multi-RQ
          configuration not getting Push notifications or not pulling
          from another RQ server is rare, we go ahead and create the
          PULL thread.

          A redundent PULL thread is not much overhead. Creating a PULL thread
          on demand is going to be messier.
        */
        WinsMscCreateEvt(
                          TEXT("RplPullSynchWTcpThdEvtHd"),
                          FALSE,                 //auto-reset
                          &RplSyncWTcpThdEvtHdl
                        );


        //
        // Initialize the critical section that guards the
        // RplPullOwnerVersNo Table.
        //
        InitializeCriticalSection(&RplVersNoStoreCrtSec);

        RetStat = WinsMscSetUpThd(
                        &QueRplPullQueHd,
                        RplPullInit,
                        &WinsCnf,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].ThdHdl,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].ThdId
                             );

        if (RetStat == WINS_SUCCESS)
        {
                        WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].fTaken =
                                                                TRUE;
                        WinsThdPool.ThdCount++;  //increment the thread count
        }

        //
        //  initialize the sPushNtfCrtSec Critical Section.  This is
        //  used by ERplPushProc
        //
CHECK("Is this critical section needed. I don't think so")
        InitializeCriticalSection(&sPushNtfCrtSec);

        /*
        We create the PUSH thread regardless of whether or not there was
        any PUSH record in the configuration info in the registry.  This is
        because, other WINS servers could pull from this WINS or send it
        a push notification.


        Perhaps we should wait until the first connection from a PULL
        partner is received.  That however will complicate the design
        a bit more.   Considering that a situation where nobody is pulling
        from the RQ server is going to be rare in a multi-RQ server
        configuration, we just go ahead and create the PUSH thread now
        and keep the design simple and clean.
        */
PERF("Don't create the thread here. Let WinsQueInsertRplPushWrkItm create it")

        //
        // Set it to TRUE here before creating the thread instead of after
        // it has been created to escape the window where another thread
        // creates it from inside WinsQueInsertRplPushWrkItm (Not the
        // case currently)
        //
        fRplPushThdExists = TRUE;
        RetStat = WinsMscSetUpThd(
                        &QueRplPushQueHd,
                        RplPushInit,
                        &WinsCnf,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdHdl,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdId
                                );

        if (RetStat == WINS_SUCCESS)
        {
                WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].fTaken =
                                                                TRUE;
                WinsThdPool.ThdCount++;  //increment the thread count
        }
        else
        {
                fRplPushThdExists = FALSE;
        }
        return(WINS_SUCCESS);
}



STATUS
RplFindOwnerId (
        IN  PCOMM_ADD_T                 pWinsAdd,
        IN  OUT LPBOOL                  pfAllocNew,
        OUT DWORD UNALIGNED             *pOwnerId,
        IN  DWORD                       InitpAction_e,
        IN  DWORD                       MemberPrec
        )

/*++

Routine Description:

        The function finds the owner id correponding to a WINS server.

        It searches the OwnerIdAddTbl for a match.  If none is found, it
        creates a mapping in the table and returns with the same.

Arguments:
        pWinsAdd -- Address of WINS whose owner id is sought
        pfAllocNew -- On input, if TRUE, assign an owner id. if this WINS is
                      not known. On output indicates whether a new entry
                      was allocated or old one (deleted one) reused
        pOwnerId  -- Owner Id of WINS
        pNewStartVersNo - Start vers. no of this WINS.
        pOldStartVersNo - Start vers. no of this WINS that we have.
        pNewUid         - Uid of the WINS
        pOldUid         - Old Uid of the WINS


Externals Used:
        NmsDbOwnAddTbl

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsDbGetDataRecs, HandleUpdVersNoReq in rplpush.c

Side Effects:

Comments:
        This function is always called with either the last 4 arguments being
        NULL or non-NULL.
--*/

{
        DWORD                  i;
        STATUS                 RetStat       = WINS_SUCCESS;
        DWORD                  NoOfOwners;
        PNMSDB_ADD_STATE_T     pOwnAddTbl     = pNmsDbOwnAddTbl;
        BOOL                   fDelEntryFound = FALSE;
        DWORD                  OwnerIdOfFirstDelEntry;


        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        NoOfOwners = NmsDbNoOfOwners;
try {
        /*
        *        check OwnerIdAddTbl for a mapping
        */
        for (i = 0; i < NoOfOwners; i++, pOwnAddTbl++)
        {
                if (
                        (ECommCompAdd(
                                pWinsAdd,
                                &(pOwnAddTbl->WinsAdd)
                                       )  == COMM_SAME_ADD)
                                  ||
                        (pOwnAddTbl->WinsState_e ==
                                        NMSDB_E_WINS_DELETED)
                   )
                {


                        //
                        // if the state of WINS in the in-memory table is
                        // deleted, then we check if we are allowed (by the
                        // client of this function) to allocate a new
                        // entry (or reuse one that is deleted). If yes,
                        // we change the state of this WINS to ACTIVE
                        // and also update the database table
                        //
                        if (pOwnAddTbl->WinsState_e == NMSDB_E_WINS_DELETED)
                        {
                            if (!fDelEntryFound)
                            {
                              fDelEntryFound = TRUE;
                              OwnerIdOfFirstDelEntry = i;
                            }
                            continue;
                        }
                        else  // state is not deleted (means we found our entry)
                        {
#if 0
                                ModifyRec();
#endif

                                //
                                // Since we did not reuse an old one, set
                                // *pfAllocNew to FALSE
                                //
                                *pfAllocNew = FALSE;
                        }
                        *pOwnerId = i;
                        break;
                }
        }

        //
        // if we did not find any entry in the table ...
        //
        if (i == NoOfOwners)
        {
            //
            // If we are authorized to create an entry and we have one or
            // more vacant slots to do this ..
            //
            if (*pfAllocNew)
            {
                  //
                  // If we have a deleted entry, reuse it
                  //
                  if (fDelEntryFound)
                  {
                        pOwnAddTbl = pNmsDbOwnAddTbl+OwnerIdOfFirstDelEntry;
                        pOwnAddTbl->WinsState_e =  NMSDB_E_WINS_ACTIVE;
                        pOwnAddTbl->WinsAdd     = *pWinsAdd;

#if 0
                        AssignStartVersNo()
#endif

                        /*
                        * Write the record into the database table
                        */
                        NmsDbWriteOwnAddTbl(
                                        NMSDB_E_INSERT_REC,
                                        OwnerIdOfFirstDelEntry,
                                        pWinsAdd,
                                        NMSDB_E_WINS_ACTIVE,
                                        &pOwnAddTbl->StartVersNo,
                                        &pOwnAddTbl->Uid
                                           );
                        //
                        // The above function has incremented the
                        // number of owners. Since we reused
                        // a deleted entry, let us correct the
                        // count
                        //
                        NmsDbNoOfOwners--;
                        *pOwnerId = OwnerIdOfFirstDelEntry;
                  }
                  else  // we don't have a deleted entry
                  {
                       /*
                        * If mapping could not be found, create one and store it
                        *
                        *  Enter the critical section first since an RPC thread
                        *  may be accessing this table (WinsStatus())
                        */

                        if (i >= NmsDbTotNoOfSlots)
                        {

                           WINSMSC_REALLOC_M(
                             sizeof(NMSDB_ADD_STATE_T)*(NmsDbTotNoOfSlots * 2),
                             (LPVOID *)&pNmsDbOwnAddTbl
                                      );
                           pOwnAddTbl = pNmsDbOwnAddTbl + NmsDbTotNoOfSlots;
                           NmsDbTotNoOfSlots *= 2;
                           DBGPRINT1(DET, "RplFindOwnerId: NO OF SLOTS IN NMSDBOWNASSTBL HAS BEEN INCREASED TO %d\n", NmsDbTotNoOfSlots);

                           RplPullAllocVersNoArray(&pRplPullOwnerVersNo, (RplPullMaxNoOfWins * 2));
                           RplPullMaxNoOfWins *= 2;
                           DBGPRINT2(DET, "RplFindOwnerId: NO OF SLOTS IN NMSDBOWNADDTBL and in RPL_OWNER_VERS_NO_ARRAY HAS BEEN INCREASED TO (%d and %d)\n", NmsDbTotNoOfSlots, RplPullMaxNoOfWins);

                        }
                        pOwnAddTbl->WinsAdd     = *pWinsAdd;
                        pOwnAddTbl->WinsState_e = NMSDB_E_WINS_ACTIVE;
#if 0
                        InitStartVersNo()
#endif
                       *pOwnerId                       = i;

                       /*
                       * Write the record into the database table. The following
                       * call will increment NmsDbNoOfOwners
                       */
                       NmsDbWriteOwnAddTbl(
                           NMSDB_E_INSERT_REC,
                           i,
                           pWinsAdd,
                           NMSDB_E_WINS_ACTIVE,
                           &pOwnAddTbl->StartVersNo,
                           &pOwnAddTbl->Uid
                                   );

                }
           }
           else  //can't allocate a new one
           {

                //
                // if we weren't asked to allocate a new one, return a
                // failure code.  If we were asked to allocate a new one,
                // raise an exception (serious error)
                //
                RetStat     = WINS_FAILURE;
                *pfAllocNew = FALSE;
           }
        }
 }
 except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("RplFindOwnerId");
        RetStat = WINS_FAILURE;
        //
        // log a message
        //
  }
        //
        // if we were able to find the member or inserted it
        //
        if (RetStat != WINS_FAILURE)
        {
                if (
                        (InitpAction_e == WINSCNF_E_INITP)
                                ||
                        (
                           (InitpAction_e == WINSCNF_E_INITP_IF_NON_EXISTENT)
                                         &&
                           (*pfAllocNew)
                        )
                   )
                {
                        pOwnAddTbl->MemberPrec = MemberPrec;
                }

        }
        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
        return(RetStat);
}


STATUS
ERplInsertQue(
        WINS_CLIENT_E        Client_e,
        QUE_CMD_TYP_E        CmdType_e,
        PCOMM_HDL_T        pDlgHdl,
        MSG_T                pMsg,
        MSG_LEN_T        MsgLen,
        LPVOID                pClientCtx,
        DWORD           MagicNo
        )

/*++

Routine Description:
        This function is called to queue a replicator request

Arguments:
        Client_e - Client that is inserting the work item
        CmdType_e - Type of command to be specified in the work item
        pDlgHdl   - Dlg Hdl if relevant to the work item
        pMsg          - Message if this function is executing in a comm thread
        Msglen    - Length of the message
        pClientCtx - Context of the client to insert in the work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ParseMsg() in comm.c, HandleUpdNtf() in rplpush.c, etc

Side Effects:

Comments:
        None
--*/

{

FUTURES("Move all this to queue.c; Enter and leave critical sections")

        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T        pTmmWrkItm;

        QueAllocWrkItm(
                        RplWrkItmHeapHdl,
                        sizeof(QUE_RPL_REQ_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                      );

        switch(CmdType_e)
        {
          /*
            Wrk item queues by COMSYS (tcp listener thread) -- when a
                replicator  message has been received
          */
          case(QUE_E_CMD_REPLICATE_MSG):

                        pWrkItm->pMsg     = pMsg;
                        pWrkItm->MsgLen   = MsgLen;
                        pWrkItm->DlgHdl   = *pDlgHdl;
                        pWrkItm->CmdTyp_e = CmdType_e;

                        QueInsertRplPushWrkItm(
                                (PLIST_ENTRY)pWrkItm,
                                FALSE         //we are not in the crit. sec.
                                      );
                        break;

          //
          //  Work items are also queued as a result of
          //  administrative action
          //
          case(QUE_E_CMD_REPLICATE):
          case(QUE_E_CMD_PULL_RANGE):

                        DBGPRINT0(FLOW,
                   "RplInsertQue: PULL Trigger command from administrator\n"
                                 );

                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->pClientCtx = pClientCtx;
            pWrkItm->MagicNo    = MagicNo;
                        QueInsertWrkItm(
                                (PLIST_ENTRY)pWrkItm,
                                QUE_E_RPLPULL,
                                NULL
                                      );
                        break;

          /*
           *  Wrk items queued by the Timer Manager thread -- when a timeout
           *  has occurred.
          */

          //
          //  Currently, not being used by TMM. This if for future extensibility
          //  Tmm interfaces with different clients and it is better that
          //  that it be unaware of who the client is (see wintmm.c).  When
          //  in the future, there is a case where TMM acquires knowledge
          //  of who the client is, it can use the ERplInsertQue function
          //  for Rpl Client to notify it if the timer expiration.
          //
          case(QUE_E_CMD_TIMER_EXPIRED):

                        pTmmWrkItm             = pClientCtx;

                        pWrkItm->pClientCtx = pTmmWrkItm->pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;

                        QueInsertWrkItm(
                                        (PLIST_ENTRY)pWrkItm,
                                        QUE_E_UNKNOWN_TYPQ,
                                        pTmmWrkItm->pRspQueHd
                                               );
                        break;

          /*
           * Wrk item queues by the main thread -- when configuration
           * has changed
          */
          case(QUE_E_CMD_CONFIG):                //fall through
          case(QUE_E_CMD_DELETE_WINS):
          case(QUE_E_CMD_ADDR_CHANGE):

                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        QueInsertWrkItm(
                                        (PLIST_ENTRY)pWrkItm,
                                        QUE_E_RPLPULL,
                                        NULL
                                       );
                        break;


          /*
            Wrk item queued by an NBT thread -- when a certain number
            of updates have been exceeded

            It can also be queued by an RPC thread as a result of administrative            action.
          */
          case(QUE_E_CMD_SND_PUSH_NTF):
          case(QUE_E_CMD_SND_PUSH_NTF_PROP):

#ifdef WINSDBG
                        if (Client_e == WINS_E_WINSRPC)
                        {
                                DBGPRINT0(FLOW,
                  "RplInsertQue: PUSH trigger command from administrator\n");

                        }
#endif
                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->pMsg            = pMsg;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->MagicNo    = MagicNo;

                        QueInsertSndNtfWrkItm( (PLIST_ENTRY)pWrkItm);
                        break;

          //
          // Work item queued by the Push thread on getting an update
          // notification message from a remote WINS
          //
          case(QUE_E_CMD_HDL_PUSH_NTF):

PERF("currently we are not passing any pClientCtx. So we can take off this")
PERF("assignment")
                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->DlgHdl            = *pDlgHdl;
                        pWrkItm->pMsg            = pMsg;
                        pWrkItm->MsgLen     = MsgLen;
                        pWrkItm->MagicNo    = MagicNo;

                        QueInsertNetNtfWrkItm( (PLIST_ENTRY)pWrkItm);
                        break;

          default:
                        DBGPRINT1(ERR,
                                  "ERplInsertQue: Invalid client Id (%d)\n",
                                   Client_e
                                 );
                        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                        break;
        }

        return(WINS_SUCCESS);
}



FUTURES("Optimize so that records with Invalid metric are not looked at")
VOID
ERplPushProc(
        BOOL                fAddDiff,
        LPVOID          pCtx,
        PCOMM_ADD_T     pNoPushWins1,
        PCOMM_ADD_T     pNoPushWins2
        )

/*++

Routine Description:
        This function is called in an NBT thread or in the PULL thread
        to push notifications to remote WINS servers (Pull pnrs)

Arguments:
        fAddDiff - Indicates whether this function got called as a result of
                   address change
        pCtx     - ctx to be passed in the work item
        pNoPushWins1 - Add of wins to which a trigger should not be sent
        pNoPushWins2 - Add of wins to which a trigger should not be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        NmsNmhNamRegInd, NmsNmhNamRegGrp, NmsNmhReplRegInd, NmsNmhReplGrpMems,
        NmsNmhUpdVersNo, PullEntries in rplpull.c

Side Effects:

Comments:
        This function is called inside of the NmsNmhNamRegCrtSec section.
        There is no need for the thread to be within the WinsCnfCnfCrtSec
        since the thread (main thread) that changes WinsCnf structure
        enters the NmsNmsNamRegCrtSec (besides the WinsCnfCnfCrtSec)
        prior to changing WinsCnf.

--*/

{

        PRPL_CONFIG_REC_T        pCnfRec;
        COMM_IP_ADD_T                IPAdd1 = 0;
        COMM_IP_ADD_T                IPAdd2 = 0;

        if (fAddDiff)
        {
                if (pNoPushWins1)
                {
                        IPAdd1 = pNoPushWins1->Add.IPAdd;
                }
                if (pNoPushWins2)
                {
                        IPAdd2 = pNoPushWins2->Add.IPAdd;
                }
        }


        //
        // The trigger needs to be sent to all our Push Pnrs
        //
        pCnfRec =  WinsCnf.PushInfo.pPushCnfRecs;

        DBGPRINT2(RPL, "ERplPushProc: CurrVersNo is %d %d \n", NmsNmhMyMaxVersNo.HighPart, NmsNmhMyMaxVersNo.LowPart);
        if (!pCnfRec) {
            return;
        }
        //
        // Loop over all our Push pnrs
        //
        for (
                        ;
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {

                //
                // If the replication is not being done as a result of
                // an address change, then compare our current max. version
                // number with the last one at which we sent triggers to see
                // if the requisite number of updates have been made to
                // justify another trigger.
                //
                if (!fAddDiff)
                {
                   //
                   // If the Update count field is invalid, go to the next
                   // record
                   //
                   if (pCnfRec->UpdateCount == RPL_INVALID_METRIC)
                   {
                        continue;
                   }

           //
           // This function is always called from the macro, RPL_PUSH_NTF_M().
           // When called, NmsNmhMyMaxVersNo is always the version # to be given
           // to the next record. pCnfRec->LastVersNo is the version
           // that was given to the first record after the last update
           // notification or the first update since WINS invocation if
           // no update notification was sent on WINS invocation.
           //
                   if(
                        (LiSub(NmsNmhMyMaxVersNo, pCnfRec->LastVersNo)/pCnfRec->UpdateCount)
                           == 0
             )

          {
                        DBGPRINT0(RPL, "ERplPushProc: Update Count notification threshold not reached yet\n");
                        continue;
                  }
            }
            else
            {
                   //
                   // If fAddDiff flag is TRUE, it can either mean that
                   // this function got invoked as a result of a
                   // name registration done by an NBT thread that changed
                   // the address after conflict resolution or it can mean
                   // that replication trigger was sent by an administrator
                   // who desires its propagation along a fan out tree
                   // of WINS servers (we might be at the starting point of
                   // the tree (root of the tree triggered by the admin) or
                   // at another level.  If we are not at the root, we need
                   // to check the Push Partners to which we must not
                   // propagate (we don't want to propagate to the WINS that
                   // that propagated the trigger to us.
                   //
                   if (
                        (pCnfRec->WinsAdd.Add.IPAdd == IPAdd1)
                                        ||
                        (pCnfRec->WinsAdd.Add.IPAdd == IPAdd2)
                      )
                   {
                        continue;
                   }

FUTURES("Check whether we have just done replication with this WINS")
FUTURES("This check can be madei if we store the version numbers of")
FUTURES("all owners - in our db - that we replicated to this WINS in the")
FUTURES("last replication cycle in the configuration record of this WINS")
CHECK("Is storing this information - more memory - more cycles at replication")
CHECK("more cycles at reinitialization - etc worth the saving in cycles")
CHECK("at propagation time")

               }
CHECK("Do we need this critical section ??")

               EnterCriticalSection(&sPushNtfCrtSec);
          try
          {
                {
                   pCnfRec->LastVersNo = NmsNmhMyMaxVersNo;
           DBGPRINT0(RPL, "ERplPushProc: Update Count notification BEING SENT\n");
                   ERplInsertQue(
                                WINS_E_NMSNMH,
                                fAddDiff ? QUE_E_CMD_SND_PUSH_NTF_PROP :
                                        QUE_E_CMD_SND_PUSH_NTF,
                                NULL,                  //no need to pass dlg hdl
                                pCtx,                  //ctx
                                0,                   //msg length
                                pCnfRec,
                                pCnfRec->MagicNo
                                );
                }
          }
          except(EXCEPTION_EXECUTE_HANDLER)
          {
                DWORD ExcCode = GetExceptionCode();
                DBGPRINT1(EXC, "ERplPushProc: Got Exception (%x)\n", ExcCode);
                //
                // log a message
                //
                WINSEVT_LOG_M(ExcCode, WINS_EVT_PUSH_TRIGGER_EXC);
          }
                LeaveCriticalSection(&sPushNtfCrtSec);

        } // end of for loop

        return;

} // ERplPushProc()




PRPL_CONFIG_REC_T
RplGetConfigRec(
    RPL_RR_TYPE_E   TypeOfRec_e,
    PCOMM_HDL_T     pDlgHdl,
    PCOMM_ADD_T     pAdd
    )
/*++

Routine Description:

    This function is called to search the list of pull/push pnrs and
    return with the address of the pnr corresponding to the address passed
    in.

Arguments:
    RPL_RR_TYPE_E Type of record (pull/push)
    PCOMM_HDL_T   Dlg Hdl (implicit) of Pnr

Externals Used:
        None


Return Value:
    Address of Pnr's config structure or NULL

Error Handling:

Called by:
    Push thread & CheckIfDel() in Pull thread
Side Effects:

Comments:
        None
--*/

{
    PRPL_CONFIG_REC_T   pPnr;
    BOOL                fRplPnr = FALSE;
    COMM_ADD_T          WinsAdd;
    PCOMM_ADD_T         pWinsAdd = &WinsAdd;

    DBGENTER("GetConfigRec\n");

    EnterCriticalSection(&WinsCnfCnfCrtSec);
    if (TypeOfRec_e == RPL_E_PULL)
    {
        pPnr = WinsCnf.PullInfo.pPullCnfRecs;
    }
    else
    {
        pPnr = WinsCnf.PushInfo.pPushCnfRecs;
    }

   try {
          if (pPnr != NULL)
          {
                 if (pAdd == NULL)
                 {
                   COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl);
                 }
                 else
                 {
                       pWinsAdd = pAdd;
                 }

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("GetConfigRec");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
        }
     LeaveCriticalSection(&WinsCnfCnfCrtSec);

#ifdef WINSDBG
     if (fRplPnr)
     {
         DBGPRINT1(RPLPUSH, "LEAVING GetConfigRec - Pnr with address %x is in our list\n", pWinsAdd->Add.IPAdd);
     }
     else
     {
         if (pDlgHdl)
         {
           COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl);
           DBGPRINT1(RPLPUSH, "LEAVING GetConfigRec - Pnr with address %x is NOT in our list\n", pWinsAdd->Add.IPAdd);
         }

     }
#endif

    return(fRplPnr ? pPnr : NULL);
}

#if 0
VOID
ERplPushCompl(
        PCOMM_ADD_T     pNoPushWins
        )

/*++

Routine Description:
        This function is called by the PULL thread to push notifications
        to remote WINS servers that have an INVALID_METRIC in their
        UpdateCount field (Pull pnrs)

Arguments:
        pNoPushWins - Add of wins to which a trigger should not be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        This function is called inside of the NmsNmhNamRegCrtSec section.
        There is no need for the thread to be within the WinsCnfCnfCrtSec
        since the thread (main thread) that changes WinsCnf structure
        enters the NmsNmsNamRegCrtSec (besides the WinsCnfCnfCrtSec)
        prior to changing WinsCnf.

--*/

{

        VERS_NO_T                 CurrVersNo;
        PRPL_CONFIG_REC_T        pCnfRec;
        BOOL                        fPush;

        //
        // The trigger needs to be sent to all our Push Pnrs
        //
        pCnfRec =  WinsCnf.PushInfo.pPushCnfRecs;

        //
        // Let us get the current highest version no. of records owned by us
        //
        NMSNMH_DEC_VERS_NO_M(
                                  NmsNmhMyMaxVersNo,
                                  CurrVersNo
                                    );
        //
        // Loop over all our Push pnrs
        //
        for (
                        ;
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {

               //
               // If the Update count field is invalid, go to the next
               // record
               //
               if (
                         (pCnfRec->UpdateCount != RPL_INVALID_METRIC)
                                        ||
                         (pCnfRec->WinsAdd.Add.IPAdd == pNoPushWins)
                  )
               {
                        continue;
               }

               EnterCriticalSection(&sPushNtfCrtSec);
        try
        {
                {
                   pCnfRec->LastVersNo = CurrVersNo;
                   ERplInsertQue(
                                WINS_E_NMSNMH,
                                QUE_E_CMD_SND_PUSH_NTF,
                                NULL,                  //no need to pass dlg hdl
                                NULL,                  //no msg is there
                                0,                   //msg length
                                pCnfRec
                                );
                }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
                DBGPRINTEXC("ERplPushCompl:");
                //
                // log a message
                //
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_PUSH_TRIGGER_EXC);
                }

                LeaveCriticalSection(&sPushNtfCrtSec);
        }

        return;

} // ERplPushCompl()




//
// Cut and Paste from RplFindOwnerId
//
VOID
ModifyRec()
{
                                //
                                // The entry may have been inserted with a
                                // 0 start version counter value.  If we
                                // have a valid value now, put that in.
                                //
                                if (
                                     pNewStartVersNo != NULL
                                                &&
                                     (
                                       (LiNeq(pOwnAddTbl->StartVersNo,
                                                        *pNewStartVersNo))
                                                ||
                                       (pOwnAddTbl->Uid != *pNewUid)
                                     )

                                   )
                                {

                                        /*
                                         * Write the record into the database
                                         * table
                                        */
                                        NmsDbWriteOwnAddTbl(
                                                NMSDB_E_MODIFY_REC,
                                                i,
                                                pWinsAdd,
                                                NMSDB_E_WINS_ACTIVE,
                                                pNewStartVersNo,
                                                pNewUid
                                                           );

                                       *pOldStartVersNo =
                                                pOwnAddTbl->StartVersNo;
                                       *pOldUid =  pOwnAddTbl->Uid;
                                       //
                                       // Init the in-memory table's field
                                       //
                                       pOwnAddTbl->StartVersNo =
                                                        *pNewStartVersNo;
                                       pOwnAddTbl->Uid = *pNewUid;
                                }
                                else
                                {
                                        if (pOldStartVersNo != NULL)
                                        {
                                           *pOldStartVersNo =
                                                pOwnAddTbl->StartVersNo;

                                        }
                                        if (pOldUid != NULL)
                                        {
                                           *pOldUid = pOwnAddTbl->Uid;

                                        }
                                }
} //ModifyRec()
//
// Cut and paste from RplFindOwnerId
//
VOID
AssignStartVersNo()
{
                        //
                        // If we have a start version number for this
                        // WINS, use it to initialize the in-memory
                        // table field, else make the same 0.
                        //
                        if (pNewStartVersNo != NULL)
                        {
                           pOwnAddTbl->StartVersNo = *pNewStartVersNo;
                           pOwnAddTbl->Uid         = *pNewUid;

                           //
                           // Assign 0, since we didn't have any s.vers.
                           // # for this owner
                           //
                            WINS_ASSIGN_INT_TO_VERS_NO_M(
                                                *pOldStartVersNo, 0);

                           //
                           // Assign 0, since we didn't have any Uid
                           // for this owner
                           //
                           *pOldUid = 0;
                        }
                        else
                        {
                           //
                           // Assign 0, since we don't have any s.vers.
                           // # for this owner
                           //
                           WINS_ASSIGN_INT_TO_VERS_NO_M(
                                        pOwnAddTbl->StartVersNo, 0
                                                              );
                           //
                           // Assign 0, since we didn't have any Uid
                           // for this owner
                           //
                           pOwnAddTbl->Uid =  0;
                        }
} //AssignStartVersNo()
//
// Cut and paste from RplFindOwnerId()
//
InitStartVersNo()
{

                        if (pNewStartVersNo != NULL)
                        {
                          pOwnAddTbl->StartVersNo = *pNewStartVersNo;
                          WINS_ASSIGN_INT_TO_VERS_NO_M(*pOldStartVersNo,0);
                          pOwnAddTbl->Uid = *pNewUid;
                          *pOldUid = 0;
                        }
                        else
                        {
                          WINS_ASSIGN_INT_TO_VERS_NO_M(pOwnAddTbl->StartVersNo,0);
                          pOwnAddTbl->Uid = 0;
                        }
} //InitStartVersNo()
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\rpl\rplmsgf.c ===
/****
 TODO

        Change name of this module to one that indicates the module to be
        platform dependent
****/

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        rplmsgf.c


Abstract:
        This module contains functions to format and unformat messages
        sent between the replicators on different WINS servers


Functions:
        RplMsgfFrmAddVersMapReq--format send ip address - max version #
                                   records request
        RplMsgfFrmAddVersMapRsp--format response to send ip address - max
                                   version # request sent earlier

        RplMsgfFrmSndEntriesReq--format send data records  request

        RplMsgfFrmSndEntriesRsp--format response to "send data records"
                                     request

        RplMsgfUfmAddVersMapRsp--unformat  "send address - max version #"
                                 response

        RplMsgfUfmSndEntriesReq--unformat "send data records" request

        RplMsgfUfmSndEntriesRsp--unformat "send data records" response

        ....

Portability:

        This module is non-portable across different address families (different
        transports) since it relies on the address being an IP address.

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#ifdef DBGSVC
#include "nms.h"
#endif
#include "comm.h"
#include "nmsdb.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "winsevt.h"
#include "winsmsc.h"

/*
 *        Local Macro Declarations
 */

/*
  ENTRY_DELIM  -- Delimiter between data records (name-address mapping records)
                  in the message. The end of the message is marked by two of
                  these.

                  Since a data record starts with the length of the name
                  (which will never by FFFFFFFF), this delimiter serves us
                  fine.
*/
#define ENTRY_DELIM        0xFFFFFFFF                //-1

/*
 *        Local Typedef Declarations
*/



/*
 *        Global Variable Definitions
 */



/*
 *        Local Variable Definitions
 */



/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


FUTURES("Change to a macro")
PERF("Change to a macro")
VOID
RplMsgfFrmAddVersMapReq(
        IN  LPBYTE        pBuff,
        OUT LPDWORD        pMsgLen
        )

/*++

Routine Description:
        This function formats the message to request a remote WINS server's
        replicator to send the IP address - Max Version # mappings

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        GetVersNo() in rplpull.c
Side Effects:

Comments:
        None
--*/
{
        RPLMSGF_SET_OPC_M(pBuff, RPLMSGF_E_ADDVERSNO_MAP_REQ);
        *pMsgLen = 4;
        return;
}



VOID
RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN  RPLMSGF_MSG_OPCODE_E   Opcode_e,
        IN  LPBYTE                 pBuff,
        IN  DWORD                  BuffLen,
        IN  PRPL_ADD_VERS_NO_T     pOwnerAddVersNoMap,
        IN  DWORD                  MaxNoOfOwners,
        IN  DWORD                  InitiatorWinsIpAdd,
        OUT LPDWORD                pMsgLen
        )

/*++

Routine Description:

        This function formats the following two messages

        1)Response to the "send me IP address - version # map " request"

        2)Push Notification message.

        Both messages are identical except for the opcode



Arguments:

        Opcode_e              - Opcode indicating the message to send
        pBuff                 - Buffer to populate
        BuffLen               - Buffer length
        pOwnerAddVersNoMap    - Array of address to version numbers mappings.
                                The version number is the max version number
                                for the owner RQ server
        MaxNoOfOwners         - Max. No Of Owners in this WINS's db
        InitiatorWinsIpAdd    - Address of WINS that initiated the push.
        pMsgLen               - Actual length of buffer filled in

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        Push Handler (Push Thread)

Side Effects:

Comments:
        None
--*/

{
        LPLONG          pTmpL = (LPLONG)pBuff;
        LPBYTE          pTmpB = pBuff;
        DWORD           i;    //counter for looping over all records
        VERS_NO_T       StartVersNo;
        WINS_UID_T      Uid;

        //
        // Backward compatibility with pre-3.51 beta copies of WINS.
        //
        StartVersNo.QuadPart = 0;
        Uid                  = 1;

        RPLMSGF_SET_OPC_M(pTmpB, Opcode_e);

        pTmpL = (LPLONG)pTmpB;


        /*
         * Store number of records in the buffer
        */
        COMM_HOST_TO_NET_L_M( MaxNoOfOwners,  *pTmpL );

        pTmpL +=  1;

        //
        // To guard us (PUSH thread) against simultaneous updates to the
        // NmsDbOwnAddTbl array (by the PULL thread).  This array is
        // accessed by RPL_FIND_ADD_BY_OWNER_ID_M macro
        //

        /*
        *  Now, let us store all the records
        */
          for (i = 0; i < MaxNoOfOwners; i++)
        {


            /*
             *         We will send the V part of the address since the other
             *  end knows the T and L (more like XDR encoding where T is
             *        not sent)
            */

NONPORT("Do not rely on the address being a long here")

            /*
             *        As an optmization here, we make use of the fact that
             *        the address is an IP address and is therefore a long.
             *        When we start working with more than one address family or
             *        when the size of the IP address changes, we should change
             *        the code here.  For now, there is no harm in optimizing
             *        it
            */
           COMM_HOST_TO_NET_L_M(
                (pOwnerAddVersNoMap + i)->OwnerWinsAdd.Add.IPAdd, *pTmpL
                               );


           pTmpL++;  //advance to next 4 bytes

           /*
            * Store the version number
           */
            WINS_PUT_VERS_NO_IN_STREAM_M(
                                &((pOwnerAddVersNoMap + i)->VersNo),
                                pTmpL
                                        );

            pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE); //adv. the
                                                                  //pointer
#if SUPPORT612WINS > 0
      if (fPnrIsBeta1Wins == FALSE)
      {
#endif
           /*
            * Store the Start version number
           */
            WINS_PUT_VERS_NO_IN_STREAM_M( &StartVersNo, pTmpL );

            pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE); //adv. the
                                                                  //pointer
            COMM_HOST_TO_NET_L_M( Uid,  *pTmpL );
            pTmpL++;
#if SUPPORT612WINS > 0
      }
#endif

        }

        COMM_HOST_TO_NET_L_M( InitiatorWinsIpAdd,  *pTmpL );
        pTmpL++;

        //
        // Let us tell our client the exact length of the response message
        //
        *pMsgLen = (ULONG) ( (LPBYTE)pTmpL - (LPBYTE)pBuff );
        return;

} // RplMsgfFormatAddVersMapRsp()



VOID
RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN  LPBYTE        pBuff,
        IN  PCOMM_ADD_T pWinsAdd,
        IN  VERS_NO_T        MaxVersNo,
        IN  VERS_NO_T        MinVersNo,
        IN  DWORD       RplType, //for now
        OUT LPDWORD        pMsgLen
        )

/*++

Routine Description:

        This function is called to format a "send data entries" request for
        getting records belonging to a particular WINS server.

Arguments:
        pBuff     - Buffer that will store the request message
        pWinsAdd  - Address of the RQ server whose data records are being
                   sought
        MaxVersNo - Max. Version Number in the range of records sought
        MinVersNo - Min. Version Number in the range of records sought.
        pMsgLen   - Length of request message

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        PullEntries() in rplpull.c

Side Effects:

Comments:
        I might update this function to format a request for getting
        data records of more than one WINS server.

        For the sake of simplicity, I have chosen not to do so currently.
--*/
{
        LPBYTE            pTmpB = pBuff;
        LPLONG            pTmpL;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_SNDENTRIES_REQ);
        pTmpL = (LPLONG)pTmpB;

        /*
         * We will send the V part of the address since the other
         * end knows the T and L (more like XDR encoding where T is
         * not sent)
        */

NONPORT("Do not rely on the address being a long here")

        /*
         * As an optmization here, we make use of the fact that
         * the address is an IP address and is therefore a long.
         * When we start working with more than one address family or
         * when the size of the IP address changes, we should change
         * the code here.  For now, there is no harm in optimizing
         * it
        */

        COMM_HOST_TO_NET_L_M(pWinsAdd->Add.IPAdd, *pTmpL);


        pTmpL++;  //advance to next 4 bytes

        /*
        *  Store the max version number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&MaxVersNo, pTmpL);
        pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE);  //advance the
                                                                //pointer

        /*
         * Store the min version number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&MinVersNo, pTmpL);
        pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE);  //advance the
                                                                //pointer

#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
            COMM_HOST_TO_NET_L_M(RplType, *pTmpL);
            pTmpL++;
#if SUPPORT612WINS > 0
    }
#endif
        //
        // Let us tell the caller the exact length of the request message
        //
        *pMsgLen = (ULONG) ((LPBYTE)pTmpL - pBuff );

        return;

}


VOID
RplMsgfFrmSndEntriesRsp (
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN LPBYTE                pBuff,
        IN DWORD                NoOfRecs,
        IN LPBYTE                pName,
        IN DWORD                NameLen,
        IN BOOL                        fGrp,
        IN DWORD                NoOfAdds,
        IN PCOMM_ADD_T                pNodeAdd,
        IN DWORD                Flag,
        IN VERS_NO_T                VersNo,
        IN BOOL                        fFirstTime,
        OUT LPBYTE                *ppNewPos
        )

/*++

Routine Description:

        This function is used to format a "send entries" response.  The
        function is called once for each data entry record that needs to be
        sent.

        The first time, it is called (fFirstTime = TRUE), it puts the
        opcode and the first directory entry in the buffer. On subsequent
        calls the data entries passed are tacked on at the end of the
        buffer


Arguments:
        ppBuff - ptr to address of location to start storing the info from.
        NoOfRecs - No of records that are being sent.
        pName   - Name of unique entry or group
        NameLen - Length of name
        fGrp        - Indicates whether the name is a unique name or a group name
        NoOfAdds - No of addresses (useful if entry is a group entry)
        pNodeAdd - Ptr to address of node (if unique entry) or to list of
                   addresses if (entry group)
        Flag        - The flag word of the entry
        VersNo  - The version number of the entry
        fFirstTime - Indicates whether this is the first call in a sequence of
                     calls to this function for formatting a send data entries
                     response
        ppNewPos - contains the starting position for the next record


Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:

Side Effects:

Comments:
        NOTE NOTE NOTE

        The set of calls to this function result in a message
        containing records pertaining to one owner.  This is the owner
        whose records were requested by the PULL partner
--*/

{
        LPLONG            pTmpL = (LPLONG)pBuff;
        LPBYTE      pTmpB = pBuff;
        DWORD            i;                  /*counter for looping over all records*/


        if (fFirstTime)
        {

                //
                // In the first invocation, we need to offset the
                // pointer by the header size used by COMM code for
                // its header
                //
                // Due to the above, this formatting function is slightly
                // inconsistent with the other formatting functions that
                // don't do any offsetting.  Subsequent invocations do
                // not require any offseting.
                //

                RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_SNDENTRIES_RSP);
                pTmpL++;  //advance to next 4 bytes

                COMM_HOST_TO_NET_L_M(NoOfRecs, *pTmpL);
                pTmpL++;        //advance to next 4 bytes
                pTmpB = (LPBYTE)pTmpL;

        }

        /*
         * Store the length of the name
        */
        COMM_HOST_TO_NET_L_M(NameLen, *pTmpL);
        pTmpB += sizeof(LONG);

        /*
         *Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pTmpB, pName, NameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += NameLen;

        /*
        * let us align the next field at a long boundary
        */
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR) pTmpB  % sizeof(LONG));

        /*
        * Store the Flags field
        */
#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        pTmpL   = (LPLONG)pTmpB;
            COMM_HOST_TO_NET_L_M(Flag, *pTmpL);
            pTmpB += sizeof(LONG);
#if SUPPORT612WINS > 0
    }
    else
    {
       *pTmpB++ = (BYTE)Flag;
    }
#endif

        /*
        * Store the group flag
        */
        *pTmpB++ = (UCHAR)fGrp;

        //align it on a long boundary
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        pTmpL = (LPLONG)pTmpB;

        /*
        * Store the Version Number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&VersNo, pTmpL);

        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

        if (NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY)
        {
          /*
          *  We will send the V part of the address since the other
          *  and knows the T and L (more like XDR encoding where T is
          *  not sent)
          */

NONPORT("Do not rely on the address being a long here")

          /*
          * As an optmization here, we make use of the fact that
          * the address is an IP address and is therefore a long.
          * When we start working with more than one address family or
          * when the size of the IP address changes, we should change
          * the code here.  For now, there is no harm in optimizing
          * it
         */

         COMM_HOST_TO_NET_L_M(pNodeAdd->Add.IPAdd, *pTmpL);
         pTmpL++;

        }
        else        //it is a group or a multihomed entry
        {

                if (NMSDB_ENTRY_TYPE_M(Flag) != NMSDB_NORM_GRP_ENTRY)
                {

                        //
                        // we were passed a ptr to the address of the
                        // first member in a ptr instead of a pptr.
                        //
                        PCOMM_ADD_T        *ppNodeAdd = (PCOMM_ADD_T *)pNodeAdd;

                        //
                        // let us threfore initialize pNodeAdd to the address
                        // of the first member
                        //
                        pNodeAdd = *ppNodeAdd;

                        /*
                        *  It is a special group or a multihomed entry.
                        * store the number of addresses first
                        */
                        pTmpB = (LPBYTE)pTmpL;

FUTURES("If we start storing > 255 members in a group, then change the")
FUTURES("following (i.e. use COMM_HOST_TO_NET_L_M)")

                        *pTmpB++ = (BYTE)NoOfAdds;
                        pTmpB += sizeof(LONG) - 1;
                        DBGPRINT2(DET, "RplMsgfFrmSndEntriesRsp: NoOfAdds=(%d) in %s\n", NoOfAdds, NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_SPEC_GRP_ENTRY ?
                                "SPECIAL GROUP" : "MULTIHOMED");
                        pTmpL = (LPLONG)pTmpB;

                        /*
                        * Store all the addresses
                        *  Note: The No of addresses is an even number
                        *  because we
                        *  are passing two addresses for each member in the
                        *  list (that is what this function gets).  The first
                        *  address of the pair is the address of the member;
                        *  the second address of the pair is the address
                        *  of the WINS server that registered or refreshed the
                        *  member)
                       */
                        for (i = 0; i < NoOfAdds ; i++)
                        {
                                   COMM_HOST_TO_NET_L_M(
                                        pNodeAdd->Add.IPAdd,
                                        *pTmpL
                                                    );
                                  pNodeAdd++;  //increment to point to
                                             //address of member
                                  pTmpL++;
                                   COMM_HOST_TO_NET_L_M(
                                                pNodeAdd->Add.IPAdd,
                                                *pTmpL
                                                    );
                                  pNodeAdd++;  //increment to point to
                                             //address of owner
                                  pTmpL++;
                        }
                }
                else // it is a normal group
                {
                         COMM_HOST_TO_NET_L_M(pNodeAdd->Add.IPAdd, *pTmpL);
                         pTmpL++;
                }
        }

        /*
        * Store the end delimiter (2 row delimiters in sequence).
        */
        *pTmpL++ = ENTRY_DELIM;
        *pTmpL   = ENTRY_DELIM;

        /*
        * Init ppBuff to point to last delimiter, so that next entry if
        * there starts from that location.  If there is no other entry,
        * then two delimiters will be there to mark the end of the message
        */
        *ppNewPos = (LPBYTE)pTmpL;
        return;
}


VOID
RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
        IN      BOOL                fIsPnrBeta1Wins,
#endif
        IN      LPBYTE              pBuff,
        OUT     LPDWORD             pNoOfMaps,
        OUT     LPDWORD             pInitiatorWinsIpAdd,
        IN OUT  PRPL_ADD_VERS_NO_T  *ppAddVers
        )

/*++

Routine Description:

        This function unformats the request to the
        "give me address - version #" message

Arguments:
        pBuff     - Buffer that contains the response message
        pNoOfMaps - No of Address - Version # entries
        pAddVers  - array of structures storing add-version # mappings

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        GetVersNo() in rplpull.c

Side Effects:

Comments:
        pBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received
--*/
{
     DWORD               i = 0;
     PRPL_ADD_VERS_NO_T  pAddVers;
     VERS_NO_T           StartVersNo;
     WINS_UID_T          Uid;

     //
     // Get the No of Mappings
     //
     COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), *pNoOfMaps);
     ASSERT(*pNoOfMaps > 0);

     pBuff += sizeof(LONG);
     if (*pNoOfMaps > 0)
     {

        WinsMscAlloc(*pNoOfMaps * sizeof(RPL_ADD_VERS_NO_T), ppAddVers);
        pAddVers = *ppAddVers;

        //
        // get all the mappings
        //
        for(i=0; i < *pNoOfMaps ; i++, pAddVers++)
        {
           COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff),
                                pAddVers->OwnerWinsAdd.Add.IPAdd);
          pAddVers->OwnerWinsAdd.AddTyp_e = COMM_ADD_E_TCPUDPIP;
          pAddVers->OwnerWinsAdd.AddLen   = sizeof(COMM_IP_ADD_T);

          pBuff += sizeof(LONG);
          WINS_GET_VERS_NO_FR_STREAM_M(pBuff, &pAddVers->VersNo);

          pBuff += WINS_VERS_NO_SIZE;
#if SUPPORT612WINS > 0
          if (fIsPnrBeta1Wins == FALSE)
          {
#endif
            WINS_GET_VERS_NO_FR_STREAM_M(pBuff, &StartVersNo);

            pBuff += WINS_VERS_NO_SIZE;

            COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), Uid);
            pBuff += sizeof(LONG);
#if SUPPORT612WINS > 0
          }
#endif
        }
#if SUPPORT612WINS > 0
        if (fIsPnrBeta1Wins == FALSE)
        {
#endif
          if (pInitiatorWinsIpAdd != NULL)
          {
                COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), *pInitiatorWinsIpAdd);
           }
#if SUPPORT612WINS > 0
        }
#endif

     } // if (NoOfMaps > 0)
     return;
}


VOID
RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN         LPBYTE                     pBuff,
        OUT        PCOMM_ADD_T            pWinsAdd,
        OUT        PVERS_NO_T            pMaxVersNo,
        OUT        PVERS_NO_T            pMinVersNo,
        OUT     LPDWORD             pRplType
        )

/*++

Routine Description:

        This function unformats the "send entries request"

Arguments:
        pBuff          - buffer that holds the request
        pWinsAdd - memory that will hold the address of the
                   WINS whose records are being requested
        pMaxVersNo - Max. Vers. No requested
        pMinVersNo - Min. Vers. No requested

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleAddVersMapReq in rplpush.c

Side Effects:

Comments:
        pBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received)
--*/
{
        LPLONG        pTmpL = (LPLONG)pBuff;

NONPORT("Port when we start supporting different address families")
        pWinsAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
        COMM_NET_TO_HOST_L_M(*pTmpL, pWinsAdd->Add.IPAdd);
        pTmpL++;

        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pMaxVersNo);
        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);
        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pMinVersNo);

#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        if (pRplType != NULL)
        {
           pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

           //COMM_NET_TO_HOST_L_M(*pTmpL, *pRplType);
           *pRplType = WINSCNF_RPL_DEFAULT_TYPE;
        }
#if SUPPORT612WINS > 0
    }
    else
    {
         *pRplType = WINSCNF_RPL_DEFAULT_TYPE;
    }
#endif
        return;
}

//__inline
VOID
RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN OUT         LPBYTE                 *ppBuff,
        OUT     LPDWORD                pNoOfRecs,
        OUT     IN LPBYTE        pName,
        OUT     LPDWORD                pNameLen,
        OUT     LPBOOL                pfGrp,
        OUT     LPDWORD                pNoOfAdds,
        OUT        PCOMM_ADD_T        pNodeAdd,
        OUT     LPDWORD                pFlag,
        OUT     PVERS_NO_T        pVersNo,
        IN BOOL                        fFirstTime
        )

/*++

Routine Description:

        This function unformats the "send entries response"

        When it is called the first time (fFirstTime = TRUE), it
        returns the value for the NoOfRecs OUTARG and the first
        record.  The value of ppBuff is adjusted to point to just past
        the row delimiter.

        When called the second or subsequent times, the function returns with
        the next entry in the list, until all entries have been exhausted.

        The function finds out that it is at the end of the list when
        it encounters at ENTRY_DELIM in the first 'sizeof(LONG)' bytes in
        the buffer.

        When a group entry is returned, pNodeAdd is made to point to the
        start location in *ppBuff where the list of members are stored.
        The caller will have to use the COMM_NET_TO_HOST_L_M macro to
        convert each address to its host form.

        The above requires the caller to know the transport that is used
        (by the fact that it is extracting the IP address).  For the sake
        of overall optimization, this is considered ok (If we didn't do this,
        this function would have to allocate a buffer to store all the
        addresses for a group and return that)


Arguments:

        pNodeAdd -- This should point to an array of COMM_ADD_T structures.
                    Since we have a maximum of 25 group members,
                    the caller can use an auto array.

Externals Used:
        None


Return Value:

        NONE
Error Handling:

Called by:

Side Effects:

Comments:

        ppBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received)
        when the function is called the first time.  For subsequent calls,
        it would be at a row delimiter (ENTRY_DELIM)


--*/
{
        LPLONG        pTmpL = (LPLONG)*ppBuff;
        LPBYTE        pTmpB;


        if (fFirstTime)
        {
                COMM_NET_TO_HOST_L_M(*pTmpL, *pNoOfRecs);
                if (*pNoOfRecs == 0)
                {
                   return;
                }
                pTmpL++;
        }
        else
        {
                //
                // If we are pointing to a delimiter, then we have
                // reached the end of the list of data records.
                //
                if (*pTmpL == ENTRY_DELIM)
                {
                        DBGPRINT0(ERR, "RplMsgfUnfSndEntriesRsp:Weird. The function should not have been called\n");
                        /*
                          we have reached the end of the array, return
                          success.

                         Note: the caller should not have called us,
                          since we gave him the No of Recs value before (
                          the first time he called)
                        */
                        WINSEVT_LOG_M(
                                            WINS_FAILURE,
                                            WINS_EVT_SFT_ERR,
                                           );
                        return;
                }
        }

        pTmpB = (LPBYTE)pTmpL;

        /*
         * Store the length of the name.
        */
        COMM_NET_TO_HOST_L_M(*pTmpL, *pNameLen);
        if(*pNameLen > 255) {
            *pNoOfRecs = 0;
            return;
        }
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pName, pTmpB, *pNameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += *pNameLen;

        /*
        * The next field is at a long boundary.  So, let us adjust pTmpB
        */
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        /*
        * Store the Flags field
        */
#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        pTmpL   = (LPLONG)pTmpB;
            COMM_NET_TO_HOST_L_M(*pTmpL, *pFlag);
            pTmpB += sizeof(LONG);
#if SUPPORT612WINS > 0
    }
    else
    {
        *pFlag = (DWORD)*pTmpB++;
    }
#endif

        /*
        *  Store the group field
        */
        *pfGrp = *pTmpB++;

        //align it at a long boundary
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        pTmpL = (LPLONG)pTmpB;

        /*
        *  Store the Version Number
        */
        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pVersNo);
        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

        if (NMSDB_ENTRY_TYPE_M(*pFlag) == NMSDB_UNIQUE_ENTRY)
        {

NONPORT("Do not rely on the address being a long here")

          /*
          As an optmization here, we make use of the fact that
          the address is an IP address and is therefore a long.
          When we start working with more than one address family or
          when the size of the IP address changes, we should change
          the code here.  For now, there is no harm in optimizing
          code here
         */
         pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
         COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
         pNodeAdd->AddLen = sizeof(COMM_IP_ADD_T);
         pTmpL++;

        }
        else          //it is either a group entry or a multihomed entry
        {
                DWORD i;

             if(NMSDB_ENTRY_TYPE_M(*pFlag) != NMSDB_NORM_GRP_ENTRY)
             {
                /*
                * store the number of addresses first
                */
                pTmpB = (LPBYTE)pTmpL;

FUTURES("If we start storing > 255 members in a group, then change the")
FUTURES("following (i.e. use COMM_HOST_TO_NET_L_M)")

                *pNoOfAdds = *pTmpB++;
                pTmpB += sizeof(LONG) - 1;

                DBGPRINT2(FLOW, "RplMsgfUfrmSndEntriesRsp: NoOfAdds=(%d) in %s record \n", *pNoOfAdds, NMSDB_ENTRY_TYPE_M(*pFlag) == NMSDB_SPEC_GRP_ENTRY ? "SPECIAL GROUP": "MULTIHOMED");

                pTmpL = (LPLONG)pTmpB;


                /*
                 Init the pointer to the list of addresses

                 Note: The No of addresses is an even number because we
                        are passing two addresses for each member in the
                        list (that is what this function returns).  The first
                        address of the pair is the address of the member;
                        the second address of the pair is the address
                        of the WINS server that registered or refreshed the
                        member)
                */
                for (i = 0; i < *pNoOfAdds ; i++)
                {
NONPORT("this will have to be changed when we move to other address families")

                  //
                  // Get address of owner
                  //
                  pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                  pNodeAdd->AddLen   = sizeof(COMM_IP_ADD_T);
                   COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                  pNodeAdd++;
                  pTmpL++;

                  //
                  // Get address of member
                  //
                  pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                  pNodeAdd->AddLen   = sizeof(COMM_IP_ADD_T);
                   COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                  pNodeAdd++;
                  pTmpL++;
                }
           }
           else //it is a normal group
           {
                 pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                 COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                 pNodeAdd->AddLen = sizeof(COMM_IP_ADD_T);
                 pTmpL++;
           }
        }

        /*
        * Make the ptr point to the location after the ENTRY_DELIM
        */
        pTmpL++ ;

        /*
        * Init ppBuff to point to last delimiter, so that next entry if
        * there starts from that location.  If there is no other entry,
        * then two delimiters will be there to mark the end of the message
        */
        *ppBuff = (LPBYTE)pTmpL;

        return;
}

VOID
RplMsgfUfmPullPnrReq(
        LPBYTE                pMsg,
        DWORD                        MsgLen,
        PRPLMSGF_MSG_OPCODE_E pPullReqType_e
        )

/*++

Routine Description:

        This function unformats a message received from a WINS
        that is a pull partner

Arguments:


Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        Push Thread

Side Effects:

Comments:
        Change this function to a macro
--*/
{
        UNREFERENCED_PARAMETER(MsgLen);

        //
        //  First three bytes should be 0s.
        //
PERF("since we never use up more than 1 byte for the opcode, we can get")
PERF("rid of the first 3 assignements down below and retrieve the opcode")
PERF("directly from the 4th byte.  Make corresponding change in the formatting")
PERF("functions too")

        *pPullReqType_e |= *pMsg++ << 24;
        *pPullReqType_e |= *pMsg++ << 16;
        *pPullReqType_e |= *pMsg++ << 8;
        *pPullReqType_e  = *pMsg ;
        return;
}



VOID
RplMsgfFrmUpdVersNoReq(
        IN  LPBYTE        pBuff,
        IN  LPBYTE        pName,
        IN  DWORD        NameLen,
        OUT LPDWORD        pMsgLen
                )

/*++

Routine Description:

        This function is called to format an "update version number" request

Arguments:
        pBuff -   Buffer that will hold the formatted request
        pName -   Name in the name-address mapping db that needs to have
                  its version no. updated
        NameLen - Length of the name
        pMsgLen - Length of the formatted message

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        InfRemWins() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

        LPBYTE        pTmpB = pBuff;
        LPLONG  pTmpL = (LPLONG)pBuff;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_UPDVERSNO_REQ);
        pTmpL = (LPLONG)pTmpB;

        /*
         * Store the length of the name.
        */
        COMM_HOST_TO_NET_L_M(NameLen, *pTmpL);
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pTmpB, pName, NameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += NameLen;

        //
        // Find size of req buffer
        //
        *pMsgLen = (ULONG) (pTmpB - pBuff);

        return;
}

VOID
RplMsgfUfmUpdVersNoReq(
        IN   LPBYTE        pBuff,
        OUT  LPBYTE        pName,
        OUT  LPDWORD        pNameLen
                )

/*++

Routine Description:
        This function is called to unformat the "update version no" request
        sent by a remote WINS

Arguments:
        pBuff - Buffer holding the formatted request
        pName - Name whose version no. is to be updated
        pNameLen - Length of name

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        HandleUpdVersNoReq in rplpush.c
Side Effects:

Comments:
        None
--*/

{
        LPBYTE pTmpB = pBuff;
        LPLONG pTmpL = (LPLONG)pBuff;

        /*
         * Store the length of the name.
        */
        COMM_NET_TO_HOST_L_M(*pTmpL, *pNameLen);
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pName, pTmpB, *pNameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += *pNameLen;

        return;

}
VOID
RplMsgfFrmUpdVersNoRsp(
        IN LPBYTE                         pRspBuff,
        IN BYTE                                Rcode,
        OUT LPDWORD                         pRspBuffLen
        )

/*++

Routine Description:

        This function is called to send the response to the "update version
          # request"

Arguments:
        pRspBuff - Buffer to hold the formatted response
        Rcode    - result of the operation
        pRspBuffLen  - Length of response

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleUpdVersNoReq() in rplpush.c

Side Effects:

Comments:
        None
--*/

{

        LPBYTE        pTmpB = pRspBuff;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_UPDVERSNO_RSP);
        *pTmpB++ = Rcode;

        *pRspBuffLen = (ULONG) (pTmpB - pRspBuff);

        return;
}


FUTURES("change to a macro")
PERF("change to a macro")

VOID
RplMsgfUfmUpdVersNoRsp(
        IN  LPBYTE                         pRspBuff,
        OUT LPBYTE                        pRcode
        )

/*++

Routine Description:

        This function is called to unformat the response to the
        "update version number" request.

Arguments:
        pRspBuff  - Buffer holding the formatted response
        pRcode          - result of the update

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        InfRemWins() in nmschl.c

Side Effects:

Comments:
        Change to a macro
--*/

{
        *pRcode = *pRspBuff;
        return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\rpl\rplpull.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:
        Rplpull.c

Abstract:

        This module implements the pull functionality of the WINS replicator

Functions:

        GetReplicasNew
        GetVersNo
        RplPullPullEntries
        SubmitTimerReqs
        SubmitTimer
        SndPushNtf
        HdlPushNtf
        EstablishComm
        RegGrpRpl
        IsTimeoutToBeIgnored
        InitRplProcess
        Reconfig
        RplPullInit
        RplPullRegRepl

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include <stdlib.h>
#include <search.h>
#include "wins.h"
#include <winsock2.h>
#include "comm.h"
#include "assoc.h"
#include "winsque.h"
#include "rpl.h"
#include "rplpull.h"
#include "rplpush.h"
#include "rplmsgf.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winstmm.h"
#include "winsintf.h"

/*
 *        Local Macro Declarations
*/
//
// defines to use for retrying communication with a remote WINS on a
// communication failure exception (when trying to establish a connection).
//
// The retries are done before moving on in the list to the next WINS
// (if one is there).  When MAX_RETRIES_TO_BE_DONE retries have been done,
// we do not retry again until the next replication cycle at which
// time the whole process is repeated).
//
// The number of replication cycles this process of retries is to be
// continued is a registry parameter
//

//
// NOTE:
// Since TCP/IP's retry strategy has been improved (more retries than before)
// and made a registry parameter, we now probably don't need to do the retries
//
#define  MAX_RETRIES_TO_BE_DONE                (0)        //0 for testing only


//
// Time to wait before flushing for the Rpl Pull thread
//
#define FLUSH_TIME                (2000)        //2 secs

//
// Note: Don't make the retry time interval  too large since communications
//       with Remote WINS servers is established in sequence.   20 secs
//       is not bad.
//
#define  RETRY_TIME_INTVL                (20000)    //in millisecs

#define FIVE_MINUTES       300
/*
 *        Local Typedef Declarations
*/

/*
 *        Global Variable Definitions
 */

HANDLE    RplPullCnfEvtHdl;        //handle to event signaled by main
                                        //thread when a configuration change
                                        //has to be given to the Pull handler
                                        //thread


BOOL      fRplPullAddDiffInCurrRplCycle; //indicates whether the address
                                              //of any entry in this WINS's db
                                              //changed as a result of
                                              //replication

#if 0
BOOL      fRplPullTriggeredWins;   //indicates that during the current
                                         //replication cycle, one or more
                                         //WINS's were triggered.  This
                                         //when TRUE, then if the above
                                         //"AddDiff.." flag is TRUE, it means
                                         //that the PULL thread should trigger
                                        //all PULL Pnrs that have an INVALID
                                        //metric in their UpdateCount field
                                        //(of the RPL_CONFIG_T struct)

BOOL     fRplPullTrigger;        //Indication to the PULL thread to
                                        //trigger Pull pnrs since one or more
                                        //address changed.  fRplPullTriggerWins
                                        //has got be FALSE when this is true
#endif

BOOL     fRplPullContinueSent = FALSE;

//
//  This array is indexed by the owner id. of an RQ server that has entries in
//  our database.  Each owner's max. version number is stored in this array
//

PRPL_VERS_NOS_T pRplPullOwnerVersNo;
DWORD           RplPullMaxNoOfWins = RPL_MAX_OWNERS_INITIALLY;

DWORD           RplPullCnfMagicNo;    //stores the id. of the current WinsCnf
                                      //structure that the Pull thread
                                      // is operating with


/*
 *        Local Variable Definitions
*/
/*
        pPushPnrVersNoTbl -- Table whose some (or all) entries are
                              initialized at replication time.
*/
/*
 pPushPnrVersNoTbl

  This table stores the Max. version number pertaining to each WINS server
  that owns entries in the local database of Push Partners

  Note: The table is STATIC for now.  We might change it to be a dynamic one
        later.

  The first dimension indicates the Push Pnr.  The second dimension indicates
  the owner WINS that has records in the Push Pnr's local db
*/
STATIC PRPL_VERS_NOS_T  pPushPnrVersNoTbl;


//
// Var. that stores the handles to the timer requests that have been
// submitted
//
STATIC WINSTMM_TIMER_REQ_ACCT_T   SetTimeReqs;


STATIC BOOL        sfPulled = FALSE;//indicates whether the PULL thread pulled
                                  //anything from a WINS.  Set by PullEntries.
                                //Looked at by HdlPushNtf

/*
 *        Local Function Prototype Declarations
*/
STATIC
VOID
GetReplicasNew(
        IN PRPL_CONFIG_REC_T        pPullCnfRecs,
        IN RPL_REC_TRAVERSAL_E      RecTrv_e      //indicates how we have to
                                              //interpret the above list
        );

VOID
ConductChkNew(
    PPUSHPNR_DATA_T pPushPnrData,
    VERS_NO_T       vnMaxLocal,
    VERS_NO_T       vnMaxRemote);

STATIC
VOID
GetVersNo(
        PPUSHPNR_DATA_T        pPushPnrData  //info about Push Pnr
        );

STATIC
VOID
SubmitTimerReqs(
        IN  PRPL_CONFIG_REC_T        pPullCnfRecs
        );
STATIC
VOID
SubmitTimer(
        LPVOID                        pWrkItm,
        IN  PRPL_CONFIG_REC_T        pPullCnfRec,
        BOOL                        fResubmit
        );


STATIC
VOID
SndPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
HdlPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
EstablishComm(
        IN  PRPL_CONFIG_REC_T     pPullCnfRecs,
        IN  BOOL                  fAllocPushPnrData,
        IN  PPUSHPNR_DATA_T       *ppPushPnrData,
        IN  RPL_REC_TRAVERSAL_E   RecTrv_e,
        OUT LPDWORD               pNoOfPushPnrs
        );


STATIC
STATUS
RegGrpRepl(
        LPBYTE               pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T            VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd
        );

STATIC
BOOL
IsTimeoutToBeIgnored(
        PQUE_TMM_REQ_WRK_ITM_T  pWrkItm
        );
STATIC
VOID
InitRplProcess(
        PWINSCNF_CNF_T        pWinsCnf
 );

STATIC
VOID
Reconfig(
        PWINSCNF_CNF_T        pWinsCnf
  );

VOID
AddressChangeNotification(
        PWINSCNF_CNF_T        pWinsCnf
  );

STATIC
VOID
PullSpecifiedRange(
        PCOMM_HDL_T                     pDlgHdl,
        PWINSINTF_PULL_RANGE_INFO_T     pPullRangeInfo,
        BOOL                            fAdjMinVersNo,
        DWORD                           RplType

        );

STATIC
VOID
DeleteWins(
        PCOMM_ADD_T        pWinsAdd
  );

BOOL
AcceptPersona(
  PCOMM_ADD_T  pWinsAdd
 );

VOID
FilterPersona(
  PPUSHPNR_DATA_T   pPushData
 );

//
// Function definitions
//

DWORD
RplPullInit (
        LPVOID pWinsCnfArg
        )

/*++

Routine Description:
        This is the initialization (startup function) of the PULL thread.
        It does the following:

Arguments:
        pWinsCnfArg - Address of the WINS configuration block

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ERplInit

Side Effects:

Comments:
        None
--*/

{


        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        HANDLE                        ThdEvtArr[3];
        DWORD                        ArrInd;
        DWORD                        RetVal;
        BOOL                        fIsTimerWrkItm;               //indicates whether
                                                       //it is a timer wrk
                                                       //item
        PWINSCNF_CNF_T                pWinsCnf      = pWinsCnfArg;
        PRPL_CONFIG_REC_T        paPullCnfRecs = pWinsCnf->PullInfo.pPullCnfRecs;
        PRPL_CONFIG_REC_T        paCnfRec = paPullCnfRecs;

        SYSTEMTIME                LocalTime;
        BOOL                      bRecoverable = FALSE;

while(TRUE)
{
try
 {

    if (!bRecoverable)
    {
        //
        // Initialize self with the db engine
        //
        NmsDbThdInit(WINS_E_RPLPULL);
        NmsDbOpenTables(WINS_E_RPLPULL);
        DBGMYNAME("Replicator Pull Thread");

        //
        // Create the  event handle to wait for configuration changes.  This
        // event is signaled by the main thread when it needs to reinit
        // the Pull handler component of the Replicator
        //
        WinsMscCreateEvt(
                          RPL_PULL_CNF_EVT_NM,
                          FALSE,                //auto-reset
                          &RplPullCnfEvtHdl
                        );

        ThdEvtArr[0]    = NmsTermEvt;
        ThdEvtArr[1]        = QueRplPullQueHd.EvtHdl;
        ThdEvtArr[2]    = RplPullCnfEvtHdl;

        //
        // If logging is turned on, specify the wait time for flushing
        // NOTE: We override the wait time we specified for all sessions
        // for this thread because that wait time is too less (100 msecs) and
        // will cause unnecessary overhead.
        //
        if (WinsCnf.fLoggingOn)
        {
                //
                // Set flush time to 2 secs.
                //
                NmsDbSetFlushTime(FLUSH_TIME);
        }

        /*
                Loop forever doing the following:

                Pull replicas from the Pull Partners specified in the
                work item.

                Block on the event until signalled (it will get signalled
                  if one of the following happens:
                        1)the configuration changes
                        2)the timer for another replication expires
                        3)WINS is terminating

                do the needful
       */


        //
        // Wait until signaled by the TCP thd. Will be signaled after
        // the TCP listener thread has inserted an entry for the WINS
        // in the NmsDbOwnAddTbl
        //
        WinsMscWaitInfinite( RplSyncWTcpThdEvtHdl );


        //
        // Do startup replication only if there is atleast one PUSH pnr
        //
        if (paPullCnfRecs != NULL)
        {
try {
                InitRplProcess(pWinsCnf);
    }
except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("RplPullInit");
                DBGPRINT0(EXC, "RplPullInit: Exception during init time replication\n");
    }
        }

        NmsDbCloseTables();

        bRecoverable = TRUE;

    } // end if (!bRecoverable)

        while(TRUE)
        {
           /*
            *  Block until signalled
           */
           WinsMscWaitUntilSignaled(
                                ThdEvtArr,
                                3,
                                &ArrInd,
                                FALSE
                                );

           if (ArrInd == 0)
           {
                //WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_ORDERLY_SHUTDOWN);
                WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
           }

           /*
            * loop forever until all work items have been handled
           */
            while(TRUE)
           {

                /*
                 *  dequeue the request from the queue
                */
                RetVal = QueGetWrkItm(
                                        QUE_E_RPLPULL,
                                        (LPVOID)&pWrkItm
                                     );
                if (RetVal == WINS_NO_REQ)
                {
                        break;
                }

        WinsMscChkTermEvt(
#ifdef WINSDBG
                       WINS_E_RPLPULL,
#endif
                       FALSE
                        );

                fIsTimerWrkItm = FALSE;

                NmsDbOpenTables(WINS_E_RPLPULL);
                DBGPRINT1(RPLPULL, "RplPullInit: Dequeued a work item. Cmd Type is (%d)\n", pWrkItm->CmdTyp_e);

                switch(pWrkItm->CmdTyp_e)
                {
                    case(QUE_E_CMD_TIMER_EXPIRED):

                               //
                               // We may want to ignore this timeout if it
                               // pertains to a previous configuration
                               //
                               if (
                                     !IsTimeoutToBeIgnored(
                                        (PQUE_TMM_REQ_WRK_ITM_T)pWrkItm
                                                        )
                                  )
                               {
                                  WinsIntfSetTime(
                                                &LocalTime,
                                                WINSINTF_E_PLANNED_PULL);
#ifdef WINSDBG
                                  DBGPRINT5(REPL, "STARTING A REPLICATION CYCLE on %d/%d at %d.%d.%d (hr.mts.sec)\n",
                                        LocalTime.wMonth,
                                        LocalTime.wDay,
                                        LocalTime.wHour,
                                        LocalTime.wMinute,
                                        LocalTime.wSecond);
                                  DBGPRINT5(RPLPULL, "STARTING A REPLICATION CYCLE on %d/%d at %d.%d.%d (hr.mts.sec)\n",
                                        LocalTime.wMonth,
                                        LocalTime.wDay,
                                        LocalTime.wHour,
                                        LocalTime.wMinute,
                                        LocalTime.wSecond);
#endif
                                         GetReplicasNew(
                                     ((PQUE_TMM_REQ_WRK_ITM_T)pWrkItm)->
                                                                pClientCtx,
                                      RPL_E_VIA_LINK //use the pNext field to
                                                     //get to the next record
                                      );

                                  DBGPRINT0(RPLPULL, "REPLICATION CYCLE END\n");

                                  /*Resubmit the timer request*/
                                  SubmitTimer(
                                        pWrkItm,
                                        ((PQUE_TMM_REQ_WRK_ITM_T)pWrkItm)
                                                                ->pClientCtx,
                                        TRUE        //it is a resubmission
                                        );
                               }

                               //
                               // Set the flag so that we do not free
                               // the work item.  It was resubmitted
                               //
                               fIsTimerWrkItm = TRUE;
                               break;

                    //
                    // Pull in replicas
                    //
                    case(QUE_E_CMD_REPLICATE):

                            //
                            // Make sure that we are not using old info
                            //
                            if ((pWrkItm->MagicNo == RplPullCnfMagicNo) ||
                                ((PRPL_CONFIG_REC_T)(pWrkItm->pClientCtx))->fTemp)
                            {
                               WinsIntfSetTime(
                                                &LocalTime,
                                                WINSINTF_E_ADMIN_TRIG_PULL);
                               GetReplicasNew( pWrkItm->pClientCtx,
                                            RPL_E_NO_TRAVERSAL );
                                if (
                                       ((PRPL_CONFIG_REC_T)
                                                (pWrkItm->pClientCtx))->fTemp
                                   )
                                {
                                        WinsMscDealloc(pWrkItm->pClientCtx);
                                }
                            }
                            else
                            {
                               DBGPRINT0(ERR, "RplPullInit: Can not honor this request since the configuration under the PARTNERS key may have changed\n");
                               WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CNF_CHANGE);
                            }
                            break;

                    //
                    // Pull range of records
                    //
                    case(QUE_E_CMD_PULL_RANGE):

                            //
                            // Make sure that we are not using old info
                            //
                            if ((pWrkItm->MagicNo == RplPullCnfMagicNo)  ||
                                ((PRPL_CONFIG_REC_T)((PWINSINTF_PULL_RANGE_INFO_T)(pWrkItm->pClientCtx))->pPnr)->fTemp)
                            {
                                //
                                // Pull the specified range.  If the Pnr
                                // record is temp, this function will
                                // deallocate it.
                                //
                                PullSpecifiedRange(NULL, pWrkItm->pClientCtx, FALSE,
                                ((PRPL_CONFIG_REC_T)(((PWINSINTF_PULL_RANGE_INFO_T)(pWrkItm->pClientCtx))->pPnr))->RplType);

                                //
                                // Deallocate the client ctx
                                //
                                WinsMscDealloc(pWrkItm->pClientCtx);
                            }
                            else
                            {
                               DBGPRINT0(ERR, "RplPullInit: Can not honor this request since the configuration under the PARTNERS key may have changed\n");
                               WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CNF_CHANGE);
                            }
                            break;

                    //
                    //reconfigure
                    //
                    case(QUE_E_CMD_CONFIG):
                        Reconfig(pWrkItm->pClientCtx);
                        break;

                    //
                    // Delete WINS from the Owner Add table (delete records
                    // also
                    //
                    case(QUE_E_CMD_DELETE_WINS):
                        DeleteWins(pWrkItm->pClientCtx);
                        break;

                    //
                    // ip addr of this machine changed, modify the own - addr table
                    case(QUE_E_CMD_ADDR_CHANGE):
                        AddressChangeNotification(pWrkItm->pClientCtx);
                        break;
                    //
                    //Push notification. Local message from an NBT thread,
                    //from an RPC thread (Push Trigger) or from this thread
                    //itself
                    //
                    case(QUE_E_CMD_SND_PUSH_NTF_PROP):
                    case(QUE_E_CMD_SND_PUSH_NTF):

                        //
                        // Make sure that we are not using old info
                        //
                        if ((pWrkItm->MagicNo == RplPullCnfMagicNo)  ||
                            ((PRPL_CONFIG_REC_T)(pWrkItm->pClientCtx))->fTemp)
                        {

                          SndPushNtf(pWrkItm);
                        }
                        break;

                    //
                    //Push notification from a remote WINS. Forwarded to Pull
                    //thread by the Push thread
                    //
                    case(QUE_E_CMD_HDL_PUSH_NTF):

                          HdlPushNtf(pWrkItm);
                          break;

                    default:

                        DBGPRINT1(ERR,
                          "RplPullInit: Invalid command code = (%d)\n",
                                        pWrkItm->CmdTyp_e);
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        break;

                }  // end of switch

                NmsDbCloseTables();

                //
                // deallocate the work item only if it is not a timer work item
                // We don't deallocate a timer work item here because of two
                // reasons:
                //
                //   1) it is reused
                //   2) it is allocated from the timer work item heap
                //
                if (!fIsTimerWrkItm)
                {
                        /*
                        *    deallocate the work item
                        */
                        QueDeallocWrkItm( RplWrkItmHeapHdl,  pWrkItm );
                }
            } //while(TRUE) for getting all work items
         } //while (TRUE)
  } // end of try
except(EXCEPTION_EXECUTE_HANDLER)
 {
        if (bRecoverable)
        {
            DBGPRINTEXC("RplPullInit");
            WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_EXC);
        }
        else
        {
            DBGPRINTEXC("RplPullInit");
            WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_ABNORMAL_SHUTDOWN);

            //
            // If NmsDbThdInit comes back with an exception, it is possible
            // that the session has not yet been started.  Passing
            // WINS_DB_SESSION_EXISTS however is ok
            //
            WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }
 } // end of except {.. }
} // end of while(TRUE)


     //
     // We never reach here
     //
     ASSERT(0);
     return(WINS_FAILURE);
}

//////////////////////////////////////////////////////////////////////////////////
//------------------- GetReplicasNew() -------------------------------------------
// This call replaces the original GetReplicas() function due to several issues
// hidden in that one.
// ft: 06/06/2000
//
// Parameters:
// 1) pPullCnfRecs: gives the info about the partners where the records are to be pulled
// 2) RecvTrv_e: tells which of the partners from the first parameter should be involved
//    in the replication. This parameter can be either RPL_E_VIA_LINK, RPL_E_NO_TRAVERSAL
//    or RPL_E_IN_SEQ. It is used only at the end of the path:
//    EstablishComm()->WinsCnfGetNextRplCnfRec()
//
VOID
GetReplicasNew (
    IN PRPL_CONFIG_REC_T    pPullCnfRecs,   // info about the (pull) repl partners to use
    IN RPL_REC_TRAVERSAL_E  RecTrv_e        // repl partner retrieval method
    )
{
    // The type & variable naming here is confusing. We are not dealing with push
    // partners, but with pull partners, meaning "partners from which this server
    // is currently pulling records". This is how WINSSNAP & WINSMON are both naming
    // these kind of partners. I preserve though the original type naming (and hence
    // the original variable naming) just to limit the size of the change.
    PPUSHPNR_DATA_T       pPushPnrData;     // info on the connections to the partners
    DWORD                 nPushPnrData;     // number of elements in pPushPnrData
    DWORD                 i, j;             // general use counters

    DBGENTER("GetReplicasNew\n");

    // Establish communications with the Pull Partners
    // For each of the partners in the list, the call below attempts to open a connection
    // to the server (if needed). All the nPushPnrData partners to which the connection 
    // is established successfully are specified in the array (PPUSHPNR_DATA_T)pPushPnrData.
    EstablishComm(
        pPullCnfRecs,   // IN  - info about the replication partners
        TRUE,           // IN  - pPushPnrData should be allocated
        &pPushPnrData,  // OUT - info on the connections to the partners
        RecTrv_e,       // IN  - which of the partners should we connect to
        &nPushPnrData); // OUT - number of elements in pPushPnrData

    // NOTE: regardless the number of partners, pPushPnrData gets allocated so it will
    // be unconditionally deallocated later.
    //
    // --Checkpoint-------------
    // At this point, pPushPnrData[i].PushPnrId == i+1.
    // The link between pPushPnrData[i] and the corresponding RPL_CONFIG_REC_T is done
    // through (RPL_CONFIG_REC_T)pPushPnrData[i].pPullCnfRec
    // -------------------------
    //
    // Contact each of the partners in pPushPnrData and get its OwnerAddr<->VersNo maps.
    // The map of each partner is stored in (PRPL_ADD_VERS_NO)pPushPnrData[i].pAddVers
    // The size of the map is stored in (DWORD)pPushPnrData[i].NoOfMaps
    for (i = 0; i < nPushPnrData; ) // no 3rd part for this "for"
    {
        PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); // get pointer to the current partner

        try 
        {
            GetVersNo(pPnrData);
            i++;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            // an exception was raised inside GetVersNo()
            DWORD ExcCode = GetExceptionCode();

            // dump the error
            DBGPRINT2(
                EXC, "GetReplicasNew->GetVersNo(%x); hit exception = (%x).\n",
                pPnrData->pPullCnfRec->WinsAdd.Add.IPAdd,
                ExcCode);
            // log the error
            WINSEVT_LOG_M(
                ExcCode,
                (ExcCode == WINS_EXC_COMM_FAIL) ?  WINS_EVT_CONN_ABORTED :  WINS_EVT_SFT_ERR);

            // update the replication counters for that partner
            (VOID)InterlockedIncrement(&pPnrData->pPullCnfRec->NoOfCommFails);
            (VOID)InterlockedDecrement(&pPnrData->pPullCnfRec->NoOfRpls);

            // Delete the dialog
            ECommEndDlg(&pPnrData->DlgHdl);

            // If there is a persistent dialog, it has to be marked as 
            // "no longer active"
            if (pPnrData->fPrsConn)
                ECOMM_INIT_DLG_HDL_M(&(pPnrData->pPullCnfRec->PrsDlgHdl));

            // one of the partners could not be contacted, so
            // eliminate it from the pPnrData array
            nPushPnrData--;
            // adjust the array such that the active partners are kept compact
            // the PushPnrId is also changed to keep true the assertion
            // pPushPnrData[i].PushPnrId == i+1;
            if (i != nPushPnrData)
            {
                DWORD origPushPnrId = pPushPnrData[i].PushPnrId;

                // !!! whole PUSHPNR_DATA_T structure is copied here !!!
                pPushPnrData[i] = pPushPnrData[nPushPnrData];
                pPushPnrData[i].PushPnrId = origPushPnrId;
            }
            // since the counter "i" is not incremented, the partner that
            // has just been moved will be the one considered next
            continue;
        }  // end of exception handler
    }  // end of for loop for looping over Push Pnrs

    // --Checkpoint--------------
    // At this point, pPushPnrData contains only the partners for which a connection
    // could be established, nPushPnrData is updated to count only these partners
    // and the pPushPnrData[i].PushPnrId == i+1 still holds.
    // (PRPL_ADD_VERS_NO)pPushPnrData[i].pAddVers gives the map OwnerAddr<->VersNo as
    // known by that replication partner. (DWORD)pPushPnrData[i].NoOfMaps gives the
    // number of entries in the map.
    // --------------------------
    DBGPRINT1(RPLPULL, "GetReplicasNew: Active PushPnrs = (%d)\n", nPushPnrData);

    // do stuff only if there is at least someone to talk to
    if (nPushPnrData > 0)
    {
        // array giving info on what owner should be pulled from what repl partner
        // the array starts with the image of the local OwnerId<->VersNo mapping and
        // grows dynamically for as many new Owners are retrieved in the mappings
        // of the other replication partners.
        PPUSHPNR_TO_PULL_FROM_T pPushPnrToPullFrom;
        DWORD                   nPushPnrToPullFrom; // size of the array
        VERS_NO_T               vnLocalMax;         // maximum local version number

        // depending on the server's state, get the maximum local version number
        //
        // If WINS is "init time paused", RplPullOwnerversNo will
        // have the max. version no. of locally owned records. We
        // can not use NmsNmhMyMaxVersNo since it may have been
        // adjusted to a higher value
        //
        if (fWinsCnfInitStatePaused)
        {
            vnLocalMax =  pRplPullOwnerVersNo[0].StartVersNo;
        }
        else
        {
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
            NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, vnLocalMax) ;
            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }

        // Initialize (PPUSHPNR_TO_PULL_FROM_T)pPushPnrToPullFrom. This is copying the local
        // image of the OwnerId<->VersNo mapping. Any entry in this table having pPushPnrData
        // set to NULL means the local server has the highest VersNo for that particular Owner
        nPushPnrToPullFrom = NmsDbNoOfOwners;
        WinsMscAlloc(
            nPushPnrToPullFrom * sizeof(RPL_VERS_NOS_T),
            (LPVOID *)&pPushPnrToPullFrom);

        for (i = 0; i < NmsDbNoOfOwners; i++)
        {
            // avoid copying info for old owners that were deleted already from the
            // internal tables (pNmsDbOwnAddTbl & pPushPnrToPullFrom)
            // for those, the entry slot will look like (NULL, 0:0) so they basically
            // won't be taken into account for replication
            if (pNmsDbOwnAddTbl[i].WinsState_e != NMSDB_E_WINS_DELETED)
            {
                pPushPnrToPullFrom[i].pPushPnrData = NULL;
                pPushPnrToPullFrom[i].VersNo = pRplPullOwnerVersNo[i].VersNo;
            }
        }
        // reset the maximum local number to what we got before.
        pPushPnrToPullFrom[0].VersNo = vnLocalMax;

        // --Checkpoint--------------
        // At this point, pPushPnrToPullFrom is copying the OwnerId<->VersNo mapping
        // from the local server. Entry at index 0 contains the highest local VersNo,
        // all the others contain each owner's highest VersNo as it is known locally.
        // Each entry has pPushPnrData set to NULL as they don't refer yet to any
        // repl partner info. Later, pPushPnrData will point to the structure corresponding
        // to the repl partner with the highest VersNo for the corresponding owner.
        // --------------------------
    
        // We attempt now to do a merge of all the maps we got from each of the partners.
        // The merge means identifying which partner has the highest VersNo for
        // each of the OwnerAddr. In the same time, some of the OwnerAddr we just got
        // might not be already present in the local OwnerId<->OwnerAddr (pNmsDbOwnAddTbl)
        // and OwnerId<->VersNo (pRplPullOwnerVersNo)tables. So we need to get a new
        // OwnerId for these ones and adjust appropriately the internal tables & the
        // OwnerId<->OwnerAddr db table. This is done through RplFindOwnerId().
        //
        // for each active replication partner ...
        for (i = 0; i < nPushPnrData; i++)
        {
            // get pointer to the current partner's data
            PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); 

            // for each of the replication partner's map entry ...
            for (j = 0; j < pPnrData->NoOfMaps; j++)
            {
                // get the pointer to the current (OwnerAddr<->VersNo) map entry 
                PRPL_ADD_VERS_NO_T pPnrMapEntry = &(pPnrData->pAddVers[j]);
                BOOL               fAllocNew; // true if this is a brand new owner
                DWORD              OwnerId;

                // filter out owners that are not supposed to be accepted
                // (either a persona non-grata or not a persona grata)
                if (!AcceptPersona(&(pPnrMapEntry->OwnerWinsAdd)))
                    continue;

                // Locate or allocate an OwnerId for this owner
                // No need to enter the critical section RplOwnAddTblCrtSec since
                // only the Pull thread changes the NmsDbNoOfOwners value (apart
                // from the main thread at initialization).  RplFindOwnerId changes
                // this value only if it is asked to allocate a new entry)
                // Though NmsDbGetDataRecs (called by Rpc threads, Push thread, and
                // scavenger thread) calls RplFindOwnerId, that call is not asking
                // for new OwnerId allocation.
                fAllocNew = TRUE;
                RplFindOwnerId(
                    &(pPnrMapEntry->OwnerWinsAdd),
                    &fAllocNew,
                    &OwnerId,
                    WINSCNF_E_INITP_IF_NON_EXISTENT,
                    WINSCNF_LOW_PREC);

                if (nPushPnrToPullFrom < NmsDbNoOfOwners)
                {
                    // if this is an owner we didn't hear of yet, RplFindOwnerId is enlarging
                    // dynamically the internal tables (pNmsDbOwnAddTbl & pRplPullOwnerVersNo)
                    // so we need to do the same
                    nPushPnrToPullFrom = NmsDbNoOfOwners;

                    // note: the memory that is added to the array is zero-ed by the call
                    WINSMSC_REALLOC_M( 
                        nPushPnrToPullFrom * sizeof(RPL_VERS_NOS_T),
                        (LPVOID *)&pPushPnrToPullFrom);
                }

                // it is guaranteed now, OwnerId is within the range of the pPushPnrToPullFrom.
                if (fAllocNew)
                {
                    // if a new OwnerId was generated (either new slot into the tables or
                    // an old slot has been reused) this means the partner is coming up with
                    // a new owner: obviously he's the one having the most recent info on
                    // that partner (at least for now)
                    pPushPnrToPullFrom[OwnerId].pPushPnrData = pPnrData;
                    pPushPnrToPullFrom[OwnerId].VersNo = pPnrMapEntry->VersNo;
                }
                else
                {
                    // the owner already exists in the list, so we need to check whether the
                    // info on this owner is not more recent on a different partner (or on this
                    // local server)
                    if ( LiGtr(pPnrMapEntry->VersNo, pPushPnrToPullFrom[OwnerId].VersNo) )
                    {
                        // yes it is, so we need to update the entry in the pPushPndToPullFrom
                        // table such that it points to this partner and shows the new greater
                        // version number.
                        pPushPnrToPullFrom[OwnerId].VersNo       = pPnrMapEntry->VersNo;
                        pPushPnrToPullFrom[OwnerId].pPushPnrData = pPnrData;
                    }
                    // else the info is not the most recent one, so just ignore it.
                } // end checking the OwnerId
            } // end looping through partner's map entries
        } // end looping through the list of partners

        // --Checkpoint--------------
        // At this point pPushPnrToPullFrom contains the union of all the OwnerId<->VersNo mappings
        // from all the partners. Each entry contains the highest VersNo known across all partners
        // for the corresponding owner, and points to the partner that came with this info (or NULL
        // if the highest VersNo was already known locally).
        // --------------------------

        // start pulling each owner from the partner able to provide the most up-to-date information
        // (having the highest version number).
        // start doing so from the entry '1' in the pPushPnrToPullFrom since entry '0' corresponds
        // to the local owner. That one will be handled later
        for (i = 1; i < NmsDbNoOfOwners; i++)
        {
            PPUSHPNR_TO_PULL_FROM_T pPushPartner = &(pPushPnrToPullFrom[i]);
            VERS_NO_T vnToPullFrom;

            // if pPushPnrData member is null this means the local server has the highest version
            // number for this owner. So nothing to pull from anyone here
            // the same, if fDlgStarted is NULL this means that partner hit an exception previously
            // and its dialog has been shut down. Don't attempt to get back to that partner in this
            // case.
            if (pPushPartner->pPushPnrData == NULL ||
                !pPushPartner->pPushPnrData->fDlgStarted)
                continue;


            // set the local variable vnToPullFrom to the first version number that is not known
            // locally (one more than the highest known)
            NMSNMH_INC_VERS_NO_M(pRplPullOwnerVersNo[i].VersNo, vnToPullFrom);

            try
            {
                // eventually we got here: start pulling
                RplPullPullEntries(
                    &(pPushPartner->pPushPnrData->DlgHdl), // active dialog to use
                    i,                                     // owner id
                    pPushPartner->VersNo,                  // max VersNo
                    vnToPullFrom,                          // min VersNo
                    WINS_E_RPLPULL,                        // the client is the replicator
                    NULL,                                  // pointer to rsp buffer (used only by scavenger)
                    TRUE,                                  // update counters
                    pPushPartner->pPushPnrData->RplType);  // replication type for this partner
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD ExcCode = GetExceptionCode();
                // dump the error
                DBGPRINT2(
                    EXC,
                    "GetReplicasNew->RplPullPullEntries(%x): hit exception (%x)\n",
                    pPushPartner->pPushPnrData->pPullCnfRec->WinsAdd.Add.IPAdd,
                    ExcCode);
                // log the error
                WINSEVT_LOG_M(
                    WINS_FAILURE,
                    ExcCode == WINS_EXC_COMM_FAIL ?  WINS_EVT_CONN_ABORTED : WINS_EVT_SFT_ERR);

                // ----bug #120788----
                // If an exception happens at this point, the persistent connection is left open and it might just
                // happen that the remote partner is still pushing data. This could fill up the TCP window
                // and could have the sender blocked indefinitely in RplPushInit->HandleSndEntriesReq.
                // Because of this the remote sender will be unable to push out data, and given that the
                // same thread is the one that is sending out the VersNo table (see the beginning of this 
                // function) subsequent replications will not be possible over the same connection.
                // FIX: in case anything goes wrong such that we get to this exception handler
                // just close the connection even if it is persistent. This causes any remote WINS to break
                // out from HandleSndEntriesReq and avoid getting stuck.
                ECommEndDlg(&(pPushPartner->pPushPnrData->DlgHdl));

                // If there is a persistent dialog, it has to be marked as "no longer active"
                if (pPushPartner->pPushPnrData->fPrsConn)
                    ECOMM_INIT_DLG_HDL_M(&(pPushPartner->pPushPnrData->pPullCnfRec->PrsDlgHdl));

                // Closing the dialog is not enough. Some other owners might be pulled out from the same 
                // partner. We shouldn't allow that, so just ban that partner for this replication cycle.
                pPushPartner->pPushPnrData->fDlgStarted = FALSE;

                // since we dropped down this connection and we won't look at it further lets delete its
                // mapping also
                if (pPushPartner->pPushPnrData->NoOfMaps)
                    WinsMscDealloc(pPushPartner->pPushPnrData->pAddVers);

            } // end except handler
        } // end looping through owners list

        // --Checkpoint--------------
        // Nothing has changed in the pPushPnrToPullFrom array except probably some dialogs that were shut down
        // because of exceptions in RplPullPullEntries. Owners handled by these partners were simply skipped.
        // At this point all replication is done, the most recent information about each owner apart has been
        // brought down from the partners that were holding it.
        // --------------------------

        // one more thing is left to be done: Check whether there is not a remote WINS partner
        // pretending to have more up-to-date information about the local WINS.
        if (pPushPnrToPullFrom[0].pPushPnrData != NULL &&
            pPushPnrToPullFrom[0].pPushPnrData->fDlgStarted)
        {
            ConductChkNew(
                pPushPnrToPullFrom[0].pPushPnrData,
                vnLocalMax,
                pPushPnrToPullFrom[0].VersNo);
        }

        // release the pPushPnrToPullFrom buffer
        WinsMscDealloc(pPushPnrToPullFrom);

    } // end "if there are active partners" case

    // cleanup starts here..
    for (i = 0; i < nPushPnrData; i++)
    {
        PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); 

        if (pPnrData->fDlgStarted == TRUE)
        {
            if (!pPnrData->fPrsConn)
                ECommEndDlg(&(pPnrData->DlgHdl));

            //Deallocate the memory pointed to by PushPnrData structure
            if (pPnrData->NoOfMaps)
                WinsMscDealloc(pPnrData->pAddVers);
        }
    }

    // deallocate the memory containing push pnr info.
    WinsMscDealloc(pPushPnrData);

    // If Wins is in the init time paused state, unpause it.
    //
    if (fWinsCnfInitStatePaused)
    {
        //inform sc to send a continue to WINS.
        EnterCriticalSection(&RplVersNoStoreCrtSec);
        fRplPullContinueSent = TRUE;
        WinsMscSendControlToSc(SERVICE_CONTROL_CONTINUE);
        LeaveCriticalSection(&RplVersNoStoreCrtSec);
    }

    DBGLEAVE("GetReplicasNew\n");
}
//------------------- END OF GetReplicasNew() ------------------------------------
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//------------------- ConductChkNew() --------------------------------------------
// This call replaces the original ConductChk() function due to major redesign in
// replicator's code.
// ft: 06/06/2000
//
// Parameters:
// 1) pPushPnrData: points to the replication partner that seems to have more
//    up-to-date information on self
// 2) vnMaxLocal: maximum local version number as detected before the replication
//    started
// 3) vnMaxRemote: maximum version number of the local server as known by the
//    remote partner
//
VOID
ConductChkNew(
    PPUSHPNR_DATA_T pPushPnrData,
    VERS_NO_T       vnMaxLocal,
    VERS_NO_T       vnMaxRemote)
{
    RPL_CONFIG_REC_T           Pnr;
    WINSINTF_PULL_RANGE_INFO_T PullRangeInfo;
    BOOL                       fVersNoAdj = FALSE;

    DBGENTER("ConductChkNew\n");

    Pnr.WinsAdd           = pPushPnrData->WinsAdd;
    Pnr.MagicNo           = 0;
    Pnr.RetryCount        = 0;
    Pnr.LastCommFailTime  = 0;
    Pnr.LastCommTime      = 0;
    Pnr.PushNtfTries      = 0;
    Pnr.fTemp             = FALSE; // We want the buffer to be deallocated by thread

    PullRangeInfo.OwnAdd.Type  = WINSINTF_TCP_IP;
    PullRangeInfo.OwnAdd.Len   = sizeof(COMM_IP_ADD_T);
    PullRangeInfo.OwnAdd.IPAdd = NmsLocalAdd.Add.IPAdd;
    PullRangeInfo.MaxVersNo    = vnMaxRemote;
    PullRangeInfo.MinVersNo    = vnMaxLocal;
    PullRangeInfo.pPnr         = &Pnr;
    NMSNMH_INC_VERS_NO_M(PullRangeInfo.MinVersNo, PullRangeInfo.MinVersNo);

    DBGPRINT5(
        RPLPULL, "ConductCheckNew(%x): Checking range [%x:%x - %x:%x]\n",
        Pnr.WinsAdd.Add.IPAdd,
        vnMaxLocal.HighPart, vnMaxLocal.LowPart,
        vnMaxRemote.HighPart, vnMaxRemote.LowPart);

    // We are pulling our own records. We want to store all.
    PullSpecifiedRange(
        &(pPushPnrData->DlgHdl),
        &PullRangeInfo,
        TRUE,                       //adjust min to NmsNmhMyMaxVersNo.
        WINSCNF_RPL_DEFAULT_TYPE);

    // If the version number is greater than the version counter value (this is 
    // different from the first entry of RplPullOwnerVersNo table since we look
    // in the registry to determine its value).
    EnterCriticalSection(&NmsNmhNamRegCrtSec);
    if (LiGtr(vnMaxRemote, NmsNmhMyMaxVersNo))
    {
        NmsNmhMyMaxVersNo.QuadPart = vnMaxRemote.QuadPart + 1;
        fVersNoAdj = TRUE;
    }
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);

    if (fVersNoAdj)
    {
#ifdef WINSDBG
        vnMaxRemote.QuadPart += 1;
        DBGPRINT2(
            RPLPULL, "ConductCheck: Local VersNo adjusted to %x:%x\n",
            vnMaxRemote.HighPart, vnMaxRemote.LowPart);
#endif
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_ADJ_VERS_NO);
    }

    DBGLEAVE("ConductCheckNew\n");
}
//------------------- END OF ConductChkNew() ------------------------------------
//////////////////////////////////////////////////////////////////////////////////

VOID
GetVersNo(
        PPUSHPNR_DATA_T        pPushPnrData  //info about Push Pnr
        )

/*++

Routine Description:

        This function does the following:
                formats a "get address to Version Number mapping" request,
                sends it and waits for response
                Unformats the response


Arguments:
        pPushPnrData - Information about the Push Pnr which needs to
                       be contacted in order to get the version number
                       info.

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:

        Some optimization can be affected by the caller of this function
--*/

{

        BYTE        Msg[RPLMSGF_ADDVERSMAP_REQ_SIZE]; //Buffer that will contain
                                                      //the request to send

        DWORD       MsgLen;                        //Msg Length
        LPBYTE      pRspMsg;                       //ptr to Rsp message
        DWORD       RspMsgLen = 0;                 //Rsp msg length
#if SUPPORT612WINS > 0
    BOOL            fIsPnrBeta1Wins;
#endif

        DBGENTER("GetVersNo\n");
        /*
        * format the request to ask for version numbers
        */
        RplMsgfFrmAddVersMapReq( Msg + COMM_N_TCP_HDR_SZ,  &MsgLen );

        /*
         * Send "send me IP address - Version Number" messages to  the
         * Push Pnr
         *
         * NOTE: If there is a communication failure or if the other WINS
         * brings down the link, this function will raise a COMM_FAIL
         * exception (caught in the caller of GetVersNo)
        */
        ECommSndCmd(
                        &pPushPnrData->DlgHdl,
                        Msg + COMM_N_TCP_HDR_SZ,
                        MsgLen,
                        &pRspMsg,
                        &RspMsgLen
                   );

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pPushPnrData->DlgHdl, fIsPnrBeta1Wins);
#endif
        /*
        *  Unformat the Rsp Message
        */
        RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        pRspMsg + 4,                 //past the opcodes
                        &(pPushPnrData->NoOfMaps),
                        NULL,
                        &pPushPnrData->pAddVers
                               );

#ifdef WINSDBG
        {
          DWORD i;
          struct in_addr InAddr;
          PRPL_ADD_VERS_NO_T  pAddVers;     //maps

          DBGPRINT1(RPLPULL, " %d Add-Vers Mappings retrieved.\n",
                                      pPushPnrData->NoOfMaps);

          for (i=0, pAddVers = pPushPnrData->pAddVers; i < pPushPnrData->NoOfMaps; i++, pAddVers++)
          {
                InAddr.s_addr = htonl(
                        pAddVers->OwnerWinsAdd.Add.IPAdd
                                     );
                DBGPRINT3(RPLPULL,"Add (%s)  - MaxVersNo (%lu %lu)\n",
                                inet_ntoa(InAddr),
                                pAddVers->VersNo.HighPart,
                                pAddVers->VersNo.LowPart
                                );
          }
       }
#endif
        ECommFreeBuff(pRspMsg - COMM_HEADER_SIZE);  //decrement to begining
                                                     //of buff
        DBGLEAVE("GetVersNo\n");
        return;

}


VOID
RplPullPullEntries(
        PCOMM_HDL_T             pDlgHdl,
        DWORD                   dwOwnerId,
        VERS_NO_T               MaxVersNo,
        VERS_NO_T               MinVersNo,
        WINS_CLIENT_E           Client_e,
        LPBYTE                  *ppRspBuff,
        BOOL                    fUpdCntrs,
        DWORD                   RplType
        )

/*++

Routine Description:
        This function is called to pull replicas for a particular owner from
        a Push Pnr.


Arguments:
        pDlgHdl   - Dialogue with the Push Pnr
        dwOwnerId - Owner Id. of WINS whose records are to be pulled.
        MaxVersNo - Max. Vers. No. in the set of replicas to pull
        MinVersNo - Min. Vers. No. in the set of replicas to pull
        Client_e  - indicates who the client is
        ppRspBuff - address of pointer to response buffer if client is
                    WINS_E_NMSSCV -- Scavenger thread executing VerifyIfClutter

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:
        None
--*/
{

        BYTE                Buff[RPLMSGF_SNDENTRIES_REQ_SIZE];
        DWORD               MsgLen;
        LPBYTE              pRspBuff;
        DWORD               RspMsgLen = 0;
        DWORD               NoOfRecs;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               NameLen;
        BOOL                fGrp;
        DWORD               NoOfAdds;
        COMM_ADD_T          NodeAdd[NMSDB_MAX_MEMS_IN_GRP * 2]; //twice the # of
                                                             //members because
                                                             //for each member
                                                             //we have an owner
        DWORD               Flag;
        VERS_NO_T           VersNo, TmpVersNo;
        DWORD               i;
        LPBYTE              pTmp;
        PCOMM_ADD_T         pWinsAdd;
        PNMSDB_WINS_STATE_E pWinsState_e;
        PVERS_NO_T           pStartVersNo;
        STATUS              RetStat = WINS_SUCCESS;
#if SUPPORT612WINS > 0
        BOOL                fIsPnrBeta1Wins;
#endif

        DBGENTER("RplPullPullEntries\n");

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fIsPnrBeta1Wins);
#endif

        WinsMscChkTermEvt(
#ifdef WINSDBG
                    Client_e,
#endif
                    FALSE
                        );

        sfPulled = FALSE;                //we haven't pulled anything yet.
        RPL_FIND_ADD_BY_OWNER_ID_M(
                                dwOwnerId,
                                pWinsAdd,
                                pWinsState_e,
                                pStartVersNo
                                  );

        while(TRUE)
        {

#ifdef WINSDBG
         {
                PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
                PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
                struct in_addr InAdd;

                InAdd.s_addr = htonl(pWinsAdd->Add.IPAdd);
                DBGPRINT2(RPLPULL, "Going to Pull Entries owned by WINS with Owner Id = (%d) and address = (%s)\n", dwOwnerId, inet_ntoa(InAdd));

                InAdd.s_addr = htonl(pAssocCtx->RemoteAdd.sin_addr.s_addr);

                DBGPRINT5(RPLPULL, "RplPullPullEntries: Range of records is  = (%lu %lu) to (%lu %lu) and is being pulled from WINS with address - (%s)\n",
                        MinVersNo.HighPart,
                        MinVersNo.LowPart,
                        MaxVersNo.HighPart,
                        MaxVersNo.LowPart,
                        inet_ntoa(InAdd)
                 );
        }
#endif
        /*
        * Format the "send me data entries" message
        */
        RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
                               fIsPnrBeta1Wins,
#endif
                                Buff + COMM_N_TCP_HDR_SZ,
                                pWinsAdd,
                                MaxVersNo,
                                MinVersNo,
                                RplType,
                                &MsgLen
                           );

FUTURES("In case a huge range is being pulled, change the sTimeToWait")
FUTURES("in comm.c to a higher timeout value so that select does not")
FUTURES("time out")
        /*
        * send the cmd to the Push Pnr and read in the response
        */
        ECommSndCmd(
                        pDlgHdl,
                        Buff + COMM_N_TCP_HDR_SZ,
                        MsgLen,
                        &pRspBuff,
                        &RspMsgLen
                    );

        DBGPRINT0(RPLPULL, "RplPull: Received Response from Push pnr\n");

        if (Client_e == WINS_E_NMSSCV)
        {
                *ppRspBuff = pRspBuff;
                /*--ft: 01/07/200 moved to ChkConfNUpd--
                if (WinsCnf.LogDetailedEvts > 0)
                {
                    PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
                    PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
                    DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

                    WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Verification"), __LINE__, "ddd", IpPartner, pWinsAdd->Add.IPAdd, 0);
                }
                --tf--*/
                DBGLEAVE("RplPullPullEntries\n");

                return;
        }

        pTmp = pRspBuff + 4;         //past the opcode

PERF("Speed this up by moving it into RplPullRegRepl")
        /*
         * Get the no of records from the response
        */
        RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        &pTmp,
                        &NoOfRecs,
                        Name,
                        &NameLen,
                        &fGrp,
                        &NoOfAdds,
                        NodeAdd,
                        &Flag,
                        &TmpVersNo,
                        TRUE /*Is it first time*/
                               );

        DBGPRINT1(RPLPULL, "RplPullPullEntries: No of Records pulled are (%d)\n",
                                        NoOfRecs);

        if (WinsCnf.LogDetailedEvts > 0)
        {
            PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
            PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
            DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

            WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Pull replication"), __LINE__, "ddd", IpPartner, pWinsAdd->Add.IPAdd, NoOfRecs);
        }
        if (NoOfRecs > 0)
        {


           if (RplPullRegRepl(
                           Name,
                           NameLen,
                           Flag,
                           dwOwnerId,
                           TmpVersNo,
                           NoOfAdds,
                           NodeAdd,
                           pWinsAdd,
                           RplType
                          ) == WINS_SUCCESS)
           {

              VersNo = TmpVersNo;

              /*
               * Repeat until all replicas have been retrieved from the
               * response buffer
              */
              for (i=1; i<NoOfRecs; i++)
              {
                  RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                 fIsPnrBeta1Wins,
#endif
                                  &pTmp,
                                  &NoOfRecs,
                                  Name,
                                  &NameLen,
                                  &fGrp,
                                  &NoOfAdds,  //will be > 1 only if fGrp is
                                              // is TRUE and it is a special
                                              //group
                                  NodeAdd,
                                  &Flag,
                                  &TmpVersNo,
                                  FALSE /*Is it first time*/
                                 );


                   if (RplPullRegRepl(
                           Name,
                           NameLen,
                           Flag,
                           dwOwnerId,
                           TmpVersNo,
                           NoOfAdds,
                           NodeAdd,
                           pWinsAdd,
                           RplType
                          ) != WINS_SUCCESS)
                 {
                     DBGPRINT5(ERR, "RplPullPullEntries: Could not register record.\nName=(%s[%x])\nVersNo=(%d %d)\ndwOwnerId=(%d)\n", Name, Name[15], TmpVersNo.HighPart, TmpVersNo.LowPart, dwOwnerId);
                     break;
                 }
                 else
                 {
                         VersNo = TmpVersNo;
                 }
             } //end of for (looping over all records starting from
               //the second one
             sfPulled = TRUE;
          }
          else
          {
                     DBGPRINT5(ERR, "RplPullPullEntries: Could not register record.\nName=(%s[%x])\nVersNo=(%d %d)\ndwOwnerId=(%d)\n", Name, Name[15], TmpVersNo.HighPart, TmpVersNo.LowPart, dwOwnerId);
                     RetStat = WINS_FAILURE;


          }

           DBGPRINT2(RPLPULL,
                    "RplPullPullEntries. Max. Version No pulled = (%d %d)\n",
                     VersNo.HighPart, VersNo.LowPart
                         );


        }
        else // NoOfRecs == 0
        {
                DBGPRINT0(RPLPULL, "RplPullPullEntries: 0 records pulled\n");
        }

        //
        // Let us free the response buffer
        //
        ECommFreeBuff(pRspBuff - COMM_HEADER_SIZE);

        //
        // let us store the max. version number pulled from the Push Pnr
        // in the RplPullOwnerVersNo array.  This array is looked at by
        // the Push thread and RPC threads so we have to synchronize
        // with them

        //
        //  NOTE NOTE NOTE
        //       It is possible that one or more group (normal or
        //       special) records clashed with records in the db.
        //       During conflict resolution, the ownership of the
        //       record in the db may not get changed
        //       (See ClashAtReplGrpMems).  Thus, even though the
        //       version number counter for the WINS whose replicas
        //       were pulled gets updated it is possible that there
        //       may not be any (or there may be less than what got pulled)
        //       records for that owner in the db. In such a
        //       case,  a third WINS that tries to pull records owned by
        //       such a WINS may end up pulling 0 (or less number of) records.
        //       This is normal and correct behavior
        //
        //

        //
        // If the number of
        // records pulled is greater than 1, update the counters.
        //
        if (NoOfRecs > 0)
        {
          if (RetStat == WINS_SUCCESS)
          {
            //
            // fUpdCntrs will be FALSE if we have pulled as a result of a
            // PULL RANGE request from the administrator.  For all other
            // cases, it is TRUE. If FALSE, we will update the counter
            // only if the highest version number that we successfully
            // pulled is greater than what is there in our counter for
            // the WINS server.
            //
            if (        fUpdCntrs
                          ||
                        LiGtr(VersNo, (pRplPullOwnerVersNo+dwOwnerId)->VersNo)
               )
            {
                EnterCriticalSection(&RplVersNoStoreCrtSec);

                //
                // NOTE: Store the max. version number pulled and not the
                // MaxVersNo that we specified.  This is because, if we have
                // not pulled released records, then if they get changed to
                // ACTIVE prior to a future replication cycle (version number
                // remains unchanged when a released record changes to an
                // ACTIVE record due to a name registration), we will pull them.
                //
                (pRplPullOwnerVersNo+dwOwnerId)->VersNo                = VersNo;

                LeaveCriticalSection(&RplVersNoStoreCrtSec);

                //
                // We will pull our own records only due to a Pull Range
                // request.  PullSpecifiedRange calls this function
                // from inside the NmsNmhNamRegCrtSec Section.
                //
                if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
                {
                      if (LiGeq(VersNo, NmsNmhMyMaxVersNo))
                      {
                          NMSNMH_INC_VERS_COUNTER_M(VersNo, NmsNmhMyMaxVersNo);
                      }
                }
                //
                // If vers. number pulled is smaller than the Max. Vers no,
                // specified, check if it is because of the limit we have set
                // for the max. number or records that can be replicated
                // at a time.  If yes, pull again.
                //
                if (
                        LiLtr(VersNo, MaxVersNo)
                                &&
                        (NoOfRecs == RPL_MAX_LIMIT_FOR_RPL)
                   )
                {
                       MinVersNo = VersNo;
                       NMSNMH_INC_VERS_NO_M(MinVersNo, MinVersNo);

                       /*
                        *  We may have been signaled by the main thread
                        *  Check it.
                       */
                       WinsMscChkTermEvt(
#ifdef WINSDBG
                                  Client_e,
#endif
                                   FALSE
                                         );
                       continue;
                }
            }
          } //if RetStat == 0
        }  // if NoOfRecs > 0
        else  // no of records pulled in is zero
        {
                //
                // if the number of records pulled in is 0, then check if
                // we have any records for the owner in the database.
                // If there are none and fUpdCtrs is FALSE, meaning
                // that this is a PULL SPECIFIED RANGE request from the
                // administrator, delete the record for the owner from
                // the in-memory and database tables
                //
                if (
                        (LiEqlZero((pRplPullOwnerVersNo+dwOwnerId)->VersNo))
                                        &&
                        (!fUpdCntrs)
                                        &&
                        (dwOwnerId != NMSDB_LOCAL_OWNER_ID)
                   )
                {
                        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                        try {
                          (pNmsDbOwnAddTbl+dwOwnerId)->WinsState_e =
                                                NMSDB_E_WINS_DELETED;
                          NmsDbWriteOwnAddTbl(
                                NMSDB_E_DELETE_REC,
                                dwOwnerId,
                                NULL,               //address of WINS
                                NMSDB_E_WINS_DELETED,
                                NULL,
                                NULL
                                        );
                        } // end of try
                        finally {
                          LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
                        }

                }
                break;  //break out of the while loop
         } // end of else

         break;
       }  //end of while (TRUE)

       DBGLEAVE("RplPullPullEntries\n");
       return;
}


VOID
SubmitTimerReqs(
        PRPL_CONFIG_REC_T        pPullCnfRecs
        )

/*++

Routine Description:
        This function goes through the array of configuration records
        submitting a timer request for each config. record that specifies
        a time interval

        Note: a single timer request is submitted for all records that
                have the same time interval specified in them.

Arguments:
        pPullCnfRecs - Array of Pull Configuration records

Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        InitRplProcess

Side Effects:

Comments:
        The records in the pPullCnfRecs array are traversed in sequence

        This function is called only at Init/Reconfig time
--*/

{

        DBGENTER("SubmitTimerReqs\n");
try {
        SetTimeReqs.NoOfSetTimeReqs = 0;

        for(
                ;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                pPullCnfRecs = (PRPL_CONFIG_REC_T) (
                                   (LPBYTE)pPullCnfRecs + RPL_CONFIG_REC_SIZE
                                                    )
           )
        {

                //
                // Submit a timer request only if we have not submitted one
                // already for the same time interval value
                //
                if  (!pPullCnfRecs->fLinked)
                {
                        //
                        // If it has an invalid time interval, check that
                        // it is not a one time only replication record
                        //
                        if  (pPullCnfRecs->TimeInterval == RPL_INVALID_METRIC)
                        {
                                if (!pPullCnfRecs->fSpTime)
                                {
                                        continue;
                                }
                                else  // a specific time is given
                                {
                                  //
                                  // If Init time replication is specified,
                                  // we must have done replication
                                  // (in InitTimeRpl).
                                  // We should check if SpTimeIntvl <= 0. If
                                  // it is, we skip this record. The time for
                                  // Specific time replication is past. In any
                                  // case, we just pulled (in InitTimeRpl)
                                  //
                                  if (
                                        (WinsCnf.PullInfo.InitTimeRpl)
                                                &&
                                        (pPullCnfRecs->SpTimeIntvl <= 0)
                                     )
                                  {
                                        continue;
                                  }
                                }
                        }

                        SubmitTimer(
                                    NULL,  //NULL means, SubmitTimer should
                                       //allocate its own work item
                                    pPullCnfRecs,
                                FALSE                //it is not a resubmission
                                    );
                }

        } // end of for loop
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("SubmitTimerReqs\n");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
        }
        DBGLEAVE("SubmitTimerReqs\n");
        return;
}



VOID
SubmitTimer(
        LPVOID                        pWrkItm,
        PRPL_CONFIG_REC_T         pPullCnfRec,
        BOOL                        fResubmit
        )

/*++

Routine Description:
        This function is called to submit a single timer request
        It is passed the address of a pull configuration record that
        may have other pull config. records linked to it.  Records
        are linked if they require replication to happen at the same time.


Arguments:

        pWrkItm     - Work item to submit after initialization
        pPullCnfRec - Address of a configuration record pertaining to a
                      Push Pnr
        fResubmit   - indicates whether this work item was submitted earlier (
                      and is now being resubmitted)

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        SubmitTimerReqs(), RplPullInit()

Side Effects:

Comments:
        None
--*/

{
        time_t            AbsTime;
        DWORD             TimeInt;
        BOOL              fTimerSet = FALSE;
        DWORD             LastMaxVal = 0;
        LPVOID            pStartOfPullGrp = pPullCnfRec;
        PRPL_CONFIG_REC_T pSvPtr = pPullCnfRec;
        BOOL              fSubmit = TRUE;

        ASSERT(pPullCnfRec);

        //
        // Let us check all linked records.
        // We stop at the first one with a Retry Count <=
        // MaxNoOfRetries specified in WinsCnf. If found, we submit a timer,
        // else we return
        //
        for (
                        ;
                pPullCnfRec != NULL;
                pPullCnfRec = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRec,
                                                RPL_E_VIA_LINK //get the
                                                               //linked rec
                                                      )
            )
        {
                //
                // If the number of retries have exceeded the max. no. allowed,
                // check if we should submit a timer request for it now.
                //
                if (pPullCnfRec->RetryCount > WinsCnf.PullInfo.MaxNoOfRetries)
                {

                        if (pPullCnfRec->RetryAfterThisManyRpl
                                        < (DWORD)((pPullCnfRec->TimeInterval >
                                                   WINSCNF_MAX_WAIT_BEFORE_RETRY_RPL) ? 0 : WINSCNF_RETRY_AFTER_THIS_MANY_RPL
                                ))
                        {
                                pPullCnfRec->RetryAfterThisManyRpl++;

                                //
                                // Is this record closer to a retry than
                                // the any other we have seen so far. If
                                // yes, then save the value of the
                                // RetryAfterThisManyRpl field and the
                                // address of the record.  Note: A record
                                // with an invalid time interval but with
                                // a specific time will never be encountered
                                // by this section of the code (because
                                // fSpTime will be set to FALSE -- see below;
                                // Also, see SubmitTimerReqs)
                                //
                                if (pPullCnfRec->RetryAfterThisManyRpl >
                                                 LastMaxVal)
                                {
                                        pSvPtr = pPullCnfRec;
                                        LastMaxVal =
                                           pPullCnfRec->RetryAfterThisManyRpl;

                                }

                                continue;        //check the next record
                        }
                        else
                        {
                                pPullCnfRec->RetryAfterThisManyRpl = 0;
                                //pPullCnfRec->RetryAfterThisManyRpl = 1;
                                pPullCnfRec->RetryCount = 0;
                        }
                }

FUTURES("Get rid of the if below")
                //
                // If this is a retry and TimeInterval is valid, use the retry time
        // interval.  If time interval is invalid, it means that we tried
        // to establish comm. at a specific time.
                //
                if ((pPullCnfRec->RetryCount != 0) && (pPullCnfRec->TimeInterval != RPL_INVALID_METRIC))
                {
//                        TimeInt = WINSCNF_RETRY_TIME_INT;
                        TimeInt = pPullCnfRec->TimeInterval;
                }
                else  // this is not a retry
                {
                        //
                        // Specific time replication is done only once at
                        // the particular time specified. After that
                        // replication is driven by the TimeInterval value
                        //
                        if (pPullCnfRec->fSpTime)
                        {
                                TimeInt      = (DWORD)pPullCnfRec->SpTimeIntvl;
                                pPullCnfRec->fSpTime = FALSE;
                        }
                        else
                        {
                                if (pPullCnfRec->TimeInterval
                                                != RPL_INVALID_METRIC)
                                {
                                        TimeInt = pPullCnfRec->TimeInterval;
                                }
                                else
                                {
                                        //
                                        // Since we have submitted a request
                                        // for all records in this chain
                                        // atleast once, break out of the
                                        // loop (All records in this chain
                                        // have an invalid time interval).
                                        //
                                        fSubmit = FALSE;
                                        break; // we have already submitted
                                               // this one time only request
                                }
                        }
                }

                //
                // Set fTimerSet to TRUE to indicate that there is atleast
                // one partner for which we will be submitting a timer request.
                //
                fTimerSet = TRUE;

                //
                // We need to submit the request. Break out of the loop
                //
                break;
        }

        //
        // Do we need to submit a timer request
        //
        if (fSubmit)
        {

           //
           // If fTimerSet is FALSE,
           // it means that communication could not be established
           // with any member of the group (despite WinsCnf.MaxNoOfRetries
           // retries with each). We should compute the time interval to the
           // earliest retry that we should do.
           //
           if (!fTimerSet)
           {
              // fixes #391314
              if (WINSCNF_RETRY_AFTER_THIS_MANY_RPL == pSvPtr->RetryAfterThisManyRpl)
              {
                  TimeInt = pSvPtr->TimeInterval;
              }
              else
              {
                  TimeInt = pSvPtr->TimeInterval *
                                (WINSCNF_RETRY_AFTER_THIS_MANY_RPL -
                                                pSvPtr->RetryAfterThisManyRpl);
              }
              pSvPtr->RetryAfterThisManyRpl = 0;
              pSvPtr->RetryCount             = 0;
           }

           (void)time(&AbsTime);
           if( pSvPtr->LastRplTime == 0 ) {

               //
               //  This is our first replication.  Just add the interval to
               //  the current time.
               //

               AbsTime += TimeInt;
               pSvPtr->LastRplTime = AbsTime;

           } else {

               //
               //  We have replicated before.  We need to make sure that
               //  our replication time is at an interval based on the time
               //  the last replication started.
               //

               do {

                   pSvPtr->LastRplTime += TimeInt;

               } while( pSvPtr->LastRplTime <= AbsTime );

               AbsTime = pSvPtr->LastRplTime;
           }


           DBGPRINT3(RPLPULL, "SubmitTimer: %s a Timer Request for (%d) secs to expire at abs. time = (%d)\n",
fResubmit ? "Resubmitting" : "Submitting", TimeInt, AbsTime);

           WinsTmmInsertEntry(
                                pWrkItm,
                                WINS_E_RPLPULL,
                                QUE_E_CMD_SET_TIMER,
                                fResubmit,
                                AbsTime,
                                TimeInt,
                                &QueRplPullQueHd,
                                pStartOfPullGrp,
                                pSvPtr->MagicNo,
                                &SetTimeReqs
                                 );
        }

        return;
}



VOID
SndPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to push a notification to a remote WINS (Pull
        Partner) that a certain number of updates have been done.

    It can be called either as a result of a version number update or from
    HdlPushNtf() to propagate a net trigger.

Arguments:
        pConfigRec  -  Configuration record of the Push Pnr to whome the
                       notification needs to be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit()

Side Effects:

Comments:
        None
--*/

{

   LPBYTE                      pBuff;
   DWORD                       MsgLen;
   COMM_HDL_T                  DlgHdl;
   DWORD                       i;
   PRPL_ADD_VERS_NO_T          pPullAddVersNoTbl;
   PRPL_ADD_VERS_NO_T          pPullAddVersNoTblTmp;
   PCOMM_ADD_T                 pWinsAdd;
   PNMSDB_WINS_STATE_E         pWinsState_e;
   PVERS_NO_T                  pStartVersNo;
   time_t                      CurrentTime;
   BOOL                        fStartDlg = FALSE;
   volatile PRPL_CONFIG_REC_T  pConfigRec = pWrkItm->pClientCtx;
   DWORD                       NoOfOwnersActive = 0;
#if SUPPORT612WINS > 0
   BOOL                        fIsPnrBeta1Wins;
#endif
   DWORD                       StartOwnerId;
   DWORD                       EndOwnerId;
   BOOL                        fPullAddVersNoTblAlloc = FALSE;
   DWORD                       SizeOfBuff;
   BOOL                        fBuffAlloc = FALSE;
#if PRSCONN
   BOOL                        fDlgActive = TRUE;
#endif
   RPLMSGF_MSG_OPCODE_E        Opcd_e;

   DBGENTER("SndPushNtf\n");

   //
   // No need for entering a critical section while using pConfigRec,
   // since only the Pull thread deallocates it on reconfiguration
   // (check Reconfig)
   //


   //
   // Check whether we want to try sending or not.   We will not try if
   // we have had 2 comm. failure in the past 5 mts. This is to guard
   // against the case where a lot of push request get queued up for
   // the pull thread for communicating with a wins with which comm
   // has been lost.
   //
   (void)time(&CurrentTime);

#define PUSH_TRY_LIMIT    2

   if (
        ((CurrentTime - pConfigRec->LastCommFailTime) < FIVE_MINUTES)
                        &&
        (pConfigRec->PushNtfTries >= PUSH_TRY_LIMIT)        //try two times

     )
   {
        DBGPRINT2(ERR, "SndPushNtf: Since we have tried %d times unsuccessfully in the past 5 mts to communicate with the WINS server (%X) , we are returning\n",
                pConfigRec->PushNtfTries,
                pConfigRec->WinsAdd.Add.IPAdd);

        WINSEVT_LOG_D_M(pConfigRec->WinsAdd.Add.IPAdd, WINS_EVT_NO_NTF_PERS_COMM_FAIL);
        return;
   }

   //
   // If it is a push notification without propagate, we should send all
   // our maps. If it is a push with propagate, we should send only one
   // map -- If we are initiating the trigger, we should send map of
   // records owned by us.  If not, we should send the map of records
   // owned by the WINS that initiated the trigger
   //
   if ( pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF)
   {
          StartOwnerId   = 0;
          EndOwnerId = StartOwnerId + NmsDbNoOfOwners;
   }
   else
   {
          BOOL fAllocNew = FALSE;
          COMM_ADD_T  WinsAdd;
          STATUS RetStat;

          //
          // If we are propagating a net trigger and the address in pMsg is
          // not our own, it means that the trigger came from a new WINS. If
          // it is our own, it means that the trigger came from an old WINS(3.5)
          // or 3.51 beta/RC1. In this case we should send all of our maps.
          //
          if (
               (pWrkItm->pMsg)
                   &&
               (PtrToUlong(pWrkItm->pMsg) != NmsLocalAdd.Add.IPAdd)
             )
          {
            //
            // we are propagating a net trigger.  pMsg above will not be NULL
            // only if we are propagating a net trigger
            //
            COMM_INIT_ADD_M(&WinsAdd, PtrToUlong(pWrkItm->pMsg));
            RetStat = RplFindOwnerId(
                        &WinsAdd,
                        &fAllocNew,  //don't assign
                        &StartOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                         );
            if (RetStat == WINS_FAILURE)
            {
                ASSERTMSG("DROPPING PROPAGATE\n", FALSE);
                //
                // log an event and return
                //
                DBGPRINT1(RPLPULL, "SndPushNtf: WEIRD -- Dropping the push with propagate since we did not find the owner (%x) in our table. HOW CAN THAT HAPPEN\n", WinsAdd.Add.IPAdd);
                return;
            }
            EndOwnerId = StartOwnerId + 1;
          }
          else
          {
             //
             // Either we are initiating the trigger or we are propagating
             // one sent by a 3.5 or a 3.51 BETA/RC1 WINS
             //
             if (!pWrkItm->pMsg)
             {
                //
                // We are initiating a trigger. Just send one map (records
                // owned by us)
                //
                StartOwnerId = 0;
                EndOwnerId   = 1;
             }
             else
             {
               //
               // Send all the maps except our own since we don't know who
               // initiated the trigger. Not sending ours lowers the
               // probability of this trigger process continuing indefinitely
               //

               //
               // Actually no need to test this since we will never
               // have this case (HdlPushNtf() must have pulled records
               // of atleast one other WINS).
               //
               if (NmsDbNoOfOwners == 1)
               {
                 //
                 // nothing to propagate. Just return
                 //
                 return;
               }
               else
               {
                 StartOwnerId = 1;
               }
               EndOwnerId   = NmsDbNoOfOwners;
             }
          }

   }

   //
   // If we are trying after a comm. failure
   //
   if (pConfigRec->PushNtfTries == PUSH_TRY_LIMIT)
   {
        pConfigRec->PushNtfTries = 0;
   }




FUTURES("If/When we start having persistent dialogues, we should check if we")
FUTURES("already have a dialogue with the WINS. If there is one, we should")
FUTURES("use that.  To find this out, loop over all Pull Config Recs to see")
FUTURES("if there is match (use the address as the search key")

try {

#if PRSCONN
   //
   // If the pnr is not a persistent pnr or if it is one but the dlg with it
   // is not active
   //
   if (
     (!pConfigRec->fPrsConn)
         ||
     !ECommIsBlockValid(&pConfigRec->PrsDlgHdl)
         ||
     (((CurrentTime - pConfigRec->LastCommTime) > FIVE_MINUTES) &&
     !(fDlgActive = ECommIsDlgActive(&pConfigRec->PrsDlgHdl)))
    )
   {
     if (!fDlgActive)
     {
        ECommEndDlg(&pConfigRec->PrsDlgHdl);
     }

     //
     // Init the pEnt field to NULL so that ECommEndDlg (in the
     // exception handler) called as a result of an exception from
     // behaves fine.
     //
     DlgHdl.pEnt = NULL;

     //
     // Start a dialogue.  Don't retry if there is comm. failure
     //
     ECommStartDlg(
                        &pConfigRec->WinsAdd,
                        COMM_E_RPL,
                        &DlgHdl
                );

     //
     // If the pnr is not NT 5, we can not send a PRS opcode to it (it will just
     // chuck it. The macro below will set the fPrsConn field of the partner
     // record to FALSE if the partner is not an NT 5+ partner
     //
     if (pConfigRec->fPrsConn)
     {
        ECOMM_IS_PNR_POSTNT4_WINS_M(&DlgHdl, pConfigRec->fPrsConn);
     }

     if (pConfigRec->fPrsConn)
     {
        pConfigRec->PrsDlgHdl = DlgHdl;
     }
   }
   else
   {
     DlgHdl    = pConfigRec->PrsDlgHdl;
   }
#else
   //
   // Init the pEnt field to NULL so that ECommEndDlg (in the
   // exception handler) called as a result of an exception from
   // behaves fine.
   //
   DlgHdl.pEnt = NULL;

   //
   // Start a dialogue.  Don't retry if there is comm. failure
   //
   ECommStartDlg(
                        &pConfigRec->WinsAdd,
                        COMM_E_RPL,
                        &DlgHdl
                );

#endif
   fStartDlg = TRUE;

   pConfigRec->LastCommFailTime = 0;
   if (pConfigRec->PushNtfTries > 0)
   {
     pConfigRec->PushNtfTries     = 0;
   }

    /*
     *  Get the max. version no for entries owned by self
     *  No need to enter a critical section before retrieving
     *  the version number.
     *
     *  The reason we subtract 1 from NmsNmhMyMaxVersNo is because
     *  it contains the version number to be given to the next record
     *  to be registered/updated.
    */
   EnterCriticalSection(&NmsNmhNamRegCrtSec);
   EnterCriticalSection(&RplVersNoStoreCrtSec);
   NMSNMH_DEC_VERS_NO_M(
                        NmsNmhMyMaxVersNo,
                        pRplPullOwnerVersNo->VersNo
                        );
   LeaveCriticalSection(&RplVersNoStoreCrtSec);
   LeaveCriticalSection(&NmsNmhNamRegCrtSec);



   WinsMscAlloc(
                 sizeof(RPL_ADD_VERS_NO_T) * (EndOwnerId - StartOwnerId),
                 (LPVOID *)&pPullAddVersNoTbl
               );
   fPullAddVersNoTblAlloc = TRUE;

   //
   // Initialize PullAddVersNoTbl array
   //
   for (i=StartOwnerId; i < EndOwnerId; i++)
   {
    RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e, pStartVersNo);
    if (*pWinsState_e == NMSDB_E_WINS_ACTIVE)
    {
          (pPullAddVersNoTbl + NoOfOwnersActive)->VersNo = (pRplPullOwnerVersNo+i)->VersNo;
          (pPullAddVersNoTbl + NoOfOwnersActive)->OwnerWinsAdd  = *pWinsAdd;
          NoOfOwnersActive++;
    }
   }

#if SUPPORT612WINS > 0
   COMM_IS_PNR_BETA1_WINS_M(&DlgHdl, fIsPnrBeta1Wins);
#endif

   //
   // format the Push notification message. This message is exactly same
   // as the Address to Version Number Mapping message except the opcode
   //

   SizeOfBuff = RPLMSGF_ADDVERSMAP_RSP_SIZE_M(NoOfOwnersActive);
   WinsMscAlloc(SizeOfBuff, (LPVOID *)&pBuff);
   fBuffAlloc = TRUE;

#if PRSCONN

   //
   //  Send a PRS opcode if we are supposed to be forming a persistent conn
   //
   if (pConfigRec->fPrsConn)
   {
        Opcd_e = (pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF) ? RPLMSGF_E_UPDATE_NTF_PRS                                : RPLMSGF_E_UPDATE_NTF_PROP_PRS;
   }
   else
#endif
   {

        Opcd_e = (pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF) ? RPLMSGF_E_UPDATE_NTF                                : RPLMSGF_E_UPDATE_NTF_PROP;

   }
   RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
        fIsPnrBeta1Wins,
#endif
        Opcd_e,
        pBuff + COMM_N_TCP_HDR_SZ,
        SizeOfBuff - COMM_N_TCP_HDR_SZ,
        pPullAddVersNoTbl,
        NoOfOwnersActive,
        (pWrkItm->pMsg != NULL) ? PtrToUlong(pWrkItm->pMsg) : NmsLocalAdd.Add.IPAdd,
                           //
                           // pMsg above will be Non-NULL only for the case
                           // when we are propagating the net upd. ntf.
                           //
        &MsgLen
                 );
   //
   // send the message to the remote WINS.  Use an existent dialogue
   // if there with the remote WINS
   //

   ECommSendMsg(
                &DlgHdl,
                NULL,                //no need for address since this is a TCP conn
                pBuff + COMM_N_TCP_HDR_SZ,
                MsgLen
                );


#if PRSCONN
   pConfigRec->LastCommTime = CurrentTime;
   if (!pConfigRec->fPrsConn)
#endif
   {
      //
      // Ask ComSys (TCP listener thread) to monitor the dialogue
      //
      ECommProcessDlg(
                &DlgHdl,
                COMM_E_NTF_START_MON
              );
   }

 } // end of try {..}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT2(EXC, "SndPushNtf -PULL thread. Got Exception (%x). WinsAdd = (%x)\n", ExcCode, pConfigRec->WinsAdd.Add.IPAdd);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPLPULL_PUSH_NTF_EXC);
        if (ExcCode == WINS_EXC_COMM_FAIL)
        {
                pConfigRec->LastCommFailTime = CurrentTime;
NOTE("Causes an access violation when compiled with no debugs.  Haven't")
NOTE("figured out why. This code is not needed")
                pConfigRec->PushNtfTries++;  //increment count of tries.
        }
        if (fStartDlg)
        {
                //
                // End the dialogue.
                //
                ECommEndDlg(&DlgHdl);
#if PRSCONN
                if (pConfigRec->fPrsConn)
                {
                    ECOMM_INIT_DLG_HDL_M(&(pConfigRec->PrsDlgHdl));
                }
#endif
        }
 } //end of exception handler

   if (fPullAddVersNoTblAlloc)
   {
       WinsMscDealloc(pPullAddVersNoTbl);

   }
   //
   // If this is a temporary configuration record, we need to deallocate it
   // It can be a temporary config. record only if
   //   1)We are executing here due to an rpc request
   //
   if (pConfigRec->fTemp)
   {
        WinsMscDealloc(pConfigRec);
   }

   //
   // dealloc the buffer we allocated
   //
   if (fBuffAlloc)
   {
        WinsMscDealloc(pBuff);

   }

   //
   // In the normal case, the connection will be terminated by the other side.
   //
  DBGLEAVE("SndPushNtf\n");
  return;
}


VOID
EstablishComm(
        IN  PRPL_CONFIG_REC_T    pPullCnfRecs,
        IN  BOOL                 fAllocPushPnrData,
        IN  PPUSHPNR_DATA_T      *ppPushPnrData,
        IN  RPL_REC_TRAVERSAL_E  RecTrv_e,
        OUT LPDWORD              pNoOfPushPnrs
        )

/*++

Routine Description:
        This function is called to establish communications with
        all the WINS servers i(Push Pnrs) specified by the the config records

Arguments:
        pPullCnfRecs  - Pull Config records
        pPushPnrData  - Array of data records each pertaining to a PUSH pnr
        RecTrv_e      - indicates whether the list of configuration records
                        is to be traversed in sequence
        pNoOfPushPnrs - No of Push Pnrs

Externals Used:
        None

Return Value:
        VOID

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:
        On return from this function, pPushPnrData will have zero or more
        partners starting from index 0 with which dlg could be started.
        PushPnrId will start from 1 (if dlg. could be established with
        atleast one partner) and can be any number in the range 1
        to MAX_RPL_OWNERS (the number indicates the iteration of the for
        loop at which this WINS was encountered)
--*/

{
#define INITIAL_NO_OF_PNRS    30

        volatile DWORD  i;
        volatile DWORD  NoOfRetries = 0;
        DWORD           TotNoOfPushPnrSlots = INITIAL_NO_OF_PNRS;
        PPUSHPNR_DATA_T pPushPnrData;
#if PRSCONN
        time_t          CurrentTime;
        BOOL            fDlgActive;
#endif

        DBGENTER("EstablishComm\n");

        *pNoOfPushPnrs = 0;

        //
        // if the client wants this function to allocate pPushPnrData
        //
        if (fAllocPushPnrData)
        {
          WinsMscAlloc(sizeof(PUSHPNR_DATA_T) * TotNoOfPushPnrSlots, (LPVOID *)ppPushPnrData);
        }

        pPushPnrData = *ppPushPnrData;

        /*
          Start a dialogue with all Push Partners specified in the
          Pull Cnf Recs  passed as input argument and get
          the version numbers of the different owners kept
          in the database of these Push Pnrs

          i = 0 for self's data
        */
#if PRSCONN
        (void)time(&CurrentTime);
#endif
        for (
                i = 1;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                        // no third expression
            )
        {


try
 {

#if PRSCONN

                fDlgActive = TRUE;

                //
                // If this partner is not a persistent conn. pnr or if he is one
                // but the dlg that we have with it is not valid, start a dlg
                // with him.  A dlg may not be valid either because we never
                // formed one with pnr or because it got disconnected as
                // a result of the pnr terminating.
                //
                // there is a corner case: two servers, A<->B replication partners
                // A pulls records from B and then on B WINS is restarted. Then, any
                // communication that A attempts with B in less than five minutes will
                // fail. This is because A will still think the connection is up.
                // A can't do otherwise, because there would be too much overhead in 
                // testing each time the TCP connection (see CommIsDlgActive).
                // This check has to be done at least at certain intervals (5min).
                if (
                    (!pPullCnfRecs->fPrsConn)
                             ||
                    !ECommIsBlockValid(&pPullCnfRecs->PrsDlgHdl)
                               ||
                   (((CurrentTime - pPullCnfRecs->LastCommTime) > FIVE_MINUTES) &&
                   !(fDlgActive = ECommIsDlgActive(&pPullCnfRecs->PrsDlgHdl)))
                      )
                {

                  //
                  // if the dlg is gone, end it so that the dlg block gets
                  // deallocated.
                  //
                  if (!fDlgActive)
                  {
                     ECommEndDlg(&pPullCnfRecs->PrsDlgHdl);
                  }
#endif
                  //
                  // Let us make sure that we don't try to establish
                  // communications with a WINS whose retry count is
                  // over.  If this is such a WINS's record, get the
                  // next WINS's record and continue.  If there is
                  // no WINS left to establish comm with, break out of
                  // the for loop
                  //
                  //
                  if (pPullCnfRecs->RetryCount > WinsCnf.PullInfo.MaxNoOfRetries)
                  {
                        pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                        pPullCnfRecs,
                                                        RecTrv_e
                                                              );
                        if (pPullCnfRecs == NULL)
                        {
                                      break;  // break out of the for loop
                        }
                        continue;
                  }
                  ECommStartDlg(
                                &pPullCnfRecs->WinsAdd,
                                COMM_E_RPL,
                                &pPushPnrData->DlgHdl
                             );

                  pPushPnrData->fDlgStarted = TRUE;
#if PRSCONN
                  //
                  // If the dlg is supposed to be persistent, store it as such
                  //
                  if (pPullCnfRecs->fPrsConn)
                  {
                       pPullCnfRecs->PrsDlgHdl = pPushPnrData->DlgHdl;
                       pPushPnrData->fPrsConn = TRUE;
                  }
                }
                else //There is a pers dlg and it is very much active
                {

                       pPushPnrData->DlgHdl = pPullCnfRecs->PrsDlgHdl;
                       pPushPnrData->fPrsConn = TRUE;
                       pPushPnrData->fDlgStarted = TRUE;
                       //
                       // No need to set fPrsConn field of PushPnrData to FALSE
                       // Memory is initialized to 0 by default
                       //
                }

                //
                // It is ok to set it here as against after the data is sent
                //
                pPullCnfRecs->LastCommTime = CurrentTime;
#endif

                pPushPnrData->RplType     = pPullCnfRecs->RplType;

                 //
                 // Note: Don't use RplFindOwnerId to get the owner id.
                 // corresponding to the Wins with which communication
                 // is being established because doing so will create an
                 // entry for the WINS in the table. If this partner
                 // turns out to be bogus, we will have to remove
                 // the entry later.
                 //
                 // We will do this later.
                 //
                 pPushPnrData->PushPnrId    = i;
                 pPushPnrData->WinsAdd      = pPullCnfRecs->WinsAdd;
                 pPushPnrData->pPullCnfRec  = pPullCnfRecs;

                 //
                 // we were able to establish comm., so let us init the
                 // LastCommFailTime to 0. NOTE: Currently, this field
                 // is not used for pull partners.
                 //
                 pPullCnfRecs->LastCommFailTime = 0;

                 //
                 // Reset the retry counter back to 0
                 //
                 NoOfRetries = 0;

                 (VOID)InterlockedIncrement(&pPullCnfRecs->NoOfRpls);
                 //
                 // reinit Retry Count to 0
                 //
                 pPullCnfRecs->RetryCount = 0;


                //
                // Note: These should get incremented only if there is
                // no exception.  That is why they are here versus in the
                // as expr3 of the for clause
                //
                pPushPnrData++;
                (*pNoOfPushPnrs)++;

                if (fAllocPushPnrData && (*pNoOfPushPnrs == TotNoOfPushPnrSlots))
                {
                     WINSMSC_REALLOC_M(sizeof(PUSHPNR_DATA_T) * (TotNoOfPushPnrSlots * 2), ppPushPnrData);
                     pPushPnrData = (*ppPushPnrData) + TotNoOfPushPnrSlots;
                     TotNoOfPushPnrSlots *= 2;

                }
                i++;

                WinsMscChkTermEvt(
#ifdef WINSDBG
                         WINS_E_RPLPULL,
#endif
                         FALSE
                            );

                //
                //  Note: the following
                //  is required even when an exception is raised. Therefore
                //  it is repeated inside the exception handler code.
                //
                pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RecTrv_e
                                                      );
                if (pPullCnfRecs == NULL)
                {
                      break;  // break out of the for loop
                }
 }        // end of try blk
except(EXCEPTION_EXECUTE_HANDLER)  {
                DBGPRINTEXC("EstablishComm");
                if (GetExceptionCode() == WINS_EXC_COMM_FAIL)
                {

#ifdef WINSDBG
                    struct in_addr        InAddr;
                    InAddr.s_addr = htonl( pPullCnfRecs->WinsAdd.Add.IPAdd );
                    DBGPRINT1(EXC, "EstablishComm: Got a comm. fail with WINS at address = (%s)\n", inet_ntoa(InAddr));
#endif
                    WinsMscChkTermEvt(
#ifdef WINSDBG
                       WINS_E_RPLPULL,
#endif
                       FALSE
                                     );
                   //
                   // Store the time (for use in SndPushNtf)
                   //
#if PRSCONN
                   pPullCnfRecs->LastCommFailTime = CurrentTime;
#else
                   (VOID)time(&(pPullCnfRecs->LastCommFailTime));
#endif

                   //
                   // Check if we have exhausted the max. no. of retries
                   // we are allowed in one replication cycle. If not,
                   // sleep for some time (20sec) and try again..
                   //
                   // --ft: 07/10: comment out this piece of code since
                   // MAX_RETRIES_TO_BE_DONE is set to 0 (#def)
                   //
                   //if (NoOfRetries < MAX_RETRIES_TO_BE_DONE)
                   //{
                   //     // Maybe the remote WINS is coming up.  We should
                   //     // give it a chance to come up.  Let us sleep for
                   //     // some time.
                   //     //
                   //     Sleep(RETRY_TIME_INTVL);
                   //     NoOfRetries++;
                   //     continue;
                   //}

                   (VOID)InterlockedIncrement(&pPullCnfRecs->NoOfCommFails);


                   //
                   //  Only Communication failure exception is to
                   //  be  consumed.
                   //
                   //  We will retry at the next replication time.
                   //
                   // Note: the comparison operator needs to be <= and not
                   // < (this is required for the 0 retry case). If we
                   // use <, a timer request would be submitted for
                   // the WINS (by SubmitTimerReqs following GetReplicasNew
                   // in RplPullInit which will result in a retry.
                   //
                   if (pPullCnfRecs->RetryCount <= WinsCnf.PullInfo.MaxNoOfRetries)
                   {
                        pPullCnfRecs->RetryCount++;

                        //
                        // We will now retry at the next
                        // replication time.
                        //

CHECK("A retry time interval different than the replication time interval")
CHECK("could be used here.  Though this will complicate the code, it may")
CHECK("be a good idea to do it if the replication time interval is large")
CHECK("Alternatively, considering that we have already retried a certain")
CHECK("no. of times, we can put the onus on the administrator to trigger")
CHECK("replication.  I need to think this some more")

                   }
                   else  //max. no of retries done
                   {
                        WINSEVT_LOG_M(
                            WINS_FAILURE,
                            WINS_EVT_CONN_RETRIES_FAILED
                        );
                        DBGPRINT0(ERR, "Could not connect to WINS. All retries failed\n");
                   }

                    //
                    //  Go to the next configuration record based on the
                    //  value of the RecTrv_e flag
                    //
                    pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RecTrv_e
                                                      );
                    if (pPullCnfRecs == NULL)
                    {
                        break;  //break out of the for loop
                    }
                  }
                  else
                  {
                        //
                        // A non comm failure error is serious. It needs
                        // to be propagated up
                        //
                        WINS_RERAISE_EXC_M();
                  }
            }  //end of exception handler
         }  // end of for loop for looping over config records
         DBGLEAVE("EstablishComm\n");
         return;
}



VOID
HdlPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function is called to handle a push notification received from
        a remote WINS.

Arguments:
        pWrkItm - the work item that the Pull thread pulled from its queue

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{
      BOOL                   fFound = FALSE;
      PUSHPNR_DATA_T         PushPnrData[1];
      DWORD                  OwnerId;
      DWORD                  i;
      VERS_NO_T              MinVersNo;
      VERS_NO_T              MaxVersNo;
      RPLMSGF_MSG_OPCODE_E   Opcode_e;
      BOOL                   fPulled = FALSE;
      BOOL                   fAllocNew;
#if SUPPORT612WINS > 0
      BOOL                   fIsPnrBeta1Wins;
#endif
      DWORD                  InitiatorWinsIpAdd;

#if PRSCONN
      BOOL                   fImplicitConnPrs;
      time_t                 CurrentTime;
      BOOL                   fDlgActive = TRUE;
      COMM_HDL_T             DlgHdl;
      PCOMM_HDL_T            pDlgHdl = &DlgHdl;
      PRPL_CONFIG_REC_T  pPnr;
#endif
      DWORD                  ExcCode = WINS_EXC_INIT;

      DBGENTER("HdlPushNtf - PULL thread\n");


#if SUPPORT612WINS > 0
      COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif
#if 0
      COMM_INIT_ADD_FROM_DLG_HDL_M(&PnrAdd, pWrkItm->DlgHdl);
#endif


      //
      // We want to pull all records starting from the min vers. no.
      //
      WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

      //
      // Get the opcode from the message
      //
      RPLMSGF_GET_OPC_FROM_MSG_M(pWrkItm->pMsg, Opcode_e);

      //
      // Unformat the message to get the owner to version number maps
      //
      RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
                         fIsPnrBeta1Wins,
#endif

                        pWrkItm->pMsg + 4,               //past the opcodes
                        &(PushPnrData[0].NoOfMaps),
                        &InitiatorWinsIpAdd,          //Wins that initiated
                                                      //the prop
                        &PushPnrData[0].pAddVers
                             );

      //
      // Free the buffer that carried the message. We don't need it anymore
      //
      ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE); //decrement to
                                                         // begining
                                                              //of buff


#if PRSCONN

      (VOID)time(&CurrentTime);
      //
      // We determine whether or not the partner has formed a persistent
      // connection with us from the opcode
      //
      fImplicitConnPrs = ((Opcode_e == RPLMSGF_E_UPDATE_NTF_PRS) || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS));

FUTURES("When we start having persistent dialogues, we should check if we")
FUTURES("already have a dialogue with the WINS. If there is one, we should")
FUTURES("use that.  To find this out, loop over all Pull Config Recs to see")
FUTURES("if there is match (use the address as the search key")
      //
      // If the connection formed with us is persistent, get the
      // config record or the pnr.  Nobody can change the config
      // rec array except the current thread (pull thread)
      //
      if (fImplicitConnPrs)
      {


          if ((pPnr = RplGetConfigRec(RPL_E_PULL, &pWrkItm->DlgHdl,NULL)) != NULL)
          {
                   //
                   // if the pnr is not persistent for pulling  or if it
                   // is persistent but the dlg is invalid, start it. Store
                   // the dlg hdl in a temp var.
                   //
                   if ((!pPnr->fPrsConn)
                             ||
                        !ECommIsBlockValid(&pPnr->PrsDlgHdl)
                               ||
                          (((CurrentTime - pPnr->LastCommTime) > FIVE_MINUTES) &&
                          !(fDlgActive = ECommIsDlgActive(&pPnr->PrsDlgHdl))))
                   {

                     //
                     // If the dlg is inactive, end it so that we start from
                     // a clean slate.
                     //
                     if (!fDlgActive)
                     {
                        ECommEndDlg(&pPnr->PrsDlgHdl);
                     }
                     ECommStartDlg(
                                &pPnr->WinsAdd,
                                COMM_E_RPL,
                                pDlgHdl
                             );

                     if (pPnr->fPrsConn)
                     {
                        pPnr->PrsDlgHdl = *pDlgHdl;
                     }

                   }
                   else
                   {

                     pDlgHdl = &pPnr->PrsDlgHdl;
                   }
         }
         else
         {
                   //
                   // Apparently a window where a reconfig of this
                   // WINS caused the remote guy to be removed as a pull
                   // pnr.  This is a window because the push thread
                   // checks whether the remote guy is a pnr prior to
                   // handing the request to the pull thread. We will in
                   // this case just bail out
                   //
                   ASSERTMSG("window condition.  Pnr no longer there.  Did you reconfigure in the very recent past If yes, hit go, else log it", FALSE);
                   ECommEndDlg(&pWrkItm->DlgHdl);
                   DBGPRINT0(FLOW, "LEAVE: HdlPushNtf - PULL thread\n");
                   return;

         }
      }
      else
      {
               pDlgHdl = &pWrkItm->DlgHdl;
      }
#endif

      //
      // loop over all WINS address - Version number maps sent to us
      // by the remote client
      //
try {
      PRPL_ADD_VERS_NO_T pAddVers;

      // filter personas grata / non grata from the list of OwnerAddress<->VersionNo
      // given to us by the remote pusher
      FilterPersona(&(PushPnrData[0]));

      pAddVers = PushPnrData[0].pAddVers;

      // at this point all WINS in PushPnrData are allowed by the lists of personas grata/non-grata
      for (i=0; i < PushPnrData[0].NoOfMaps; i++, pAddVers++)
      {

            fAllocNew = TRUE;
                  RplFindOwnerId(
                    &pAddVers->OwnerWinsAdd,
                    &fAllocNew,        //allocate entry if not existent
                    &OwnerId,
                    WINSCNF_E_INITP_IF_NON_EXISTENT,
                    WINSCNF_LOW_PREC
                              );

            //
            // If the local WINS has older information than the remote
            // WINS, pull the new information.  Here we are comparing
            // the highest version number in the local db for a particular
            // WINS with the highest version number that the remote Pusher
            // has.  NOTE: if the map sent by the PULL PNR pertains to
            // self, it means that we went down and came up with a truncated
            // database (partners have replicas).  DON"T PULL these records
            //
            if (
                   (OwnerId != NMSDB_LOCAL_OWNER_ID)

               )
            {
                //
                // If the max. vers. number is less than or equal to
                // what we have, don't pull
                //
                if (LiLeq(
                        pAddVers->VersNo,
                        (pRplPullOwnerVersNo+OwnerId)->VersNo
                                   )
                )
                {
                        continue;       //check the next owner
                }


                NMSNMH_INC_VERS_NO_M(
                                (pRplPullOwnerVersNo+OwnerId)->VersNo,
                                MinVersNo
                                  );

                //
                // Pull Entries
                //
                RplPullPullEntries(
                        pDlgHdl,
                        OwnerId,
                        MaxVersNo,        //inited to 0
                        MinVersNo,
                        WINS_E_RPLPULL,
                        NULL,
                        TRUE,        //update counters
                        PtrToUlong (pWrkItm->pClientCtx)
                           );

                //
                // If atleast one valid record was pulled by WINS, sfPulled
                // will be set to TRUE.  Since this can get reset by the
                // next call to RplPullPullEntries, let us save it.
                //
                if (sfPulled)
                {
                        fPulled = TRUE;
                }

            }
     }  //end of for{} over all wins address - version # maps
} // end of try {}
except (EXCEPTION_EXECUTE_HANDLER) {
        ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "HdlPushNtf: Encountered exception %x\n", ExcCode);
        if (ExcCode == WINS_EXC_COMM_FAIL)
        {
                COMM_IP_ADD_T        RemoteIPAdd;
                COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &RemoteIPAdd);
                DBGPRINT1(EXC, "HdlPushNtf: Communication Failure with Remote Wins having address = (%x)\n", RemoteIPAdd);
        }
        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_PUSH_TRIG_PROC);
 }

    if (PushPnrData[0].NoOfMaps > 0)
    {
      WinsMscDealloc(PushPnrData[0].pAddVers);
    }

    //
    // If opcode indicates push propagation and we did pull atleast one
    // record from the WINS that sent us the Push notification, do the
    // propagation now.  We do not propagate to the guy who sent us
    // the trigger.
    //
    // Note: We never propagate if this update notification has made its way
    // back to us because of some loop.  We also don't propagate it if
    // we have been told not to by the admin.
    //
    if (((Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP)
#if PRSCONN
             || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS)
#endif
       ) && fPulled && !COMM_MY_IP_ADD_M(InitiatorWinsIpAdd) && (WinsCnf.PushInfo.PropNetUpdNtf == DO_PROP_NET_UPD_NTF))
    {
      COMM_ADD_T        WinsAdd;

      COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

      //
      // We need to synchronize with the NBT threads
      //
      EnterCriticalSection(&NmsNmhNamRegCrtSec);

      //
      // Check whether we have any PULL pnrs.  (We need to access WinsCnf
      // from within the NmsNmhNamRegCrtSec)
      //

      // We do this test here instead of in the RPL_PUSH_NTF_M macro to
      // localize the overhead to this function only.  Note: If the
      // Initiator WINS address is 0, it means that it is a Daytona WINS (not
      // a PPC release WINS).  In such a case, we put our own address.  This
      // has the advantage of stopping propagations in a loop of new WINSs if
      // they have gone around the loop once..
      //
      if (WinsCnf.PushInfo.NoOfPullPnrs != 0)
      {
        try
        {
           RPL_PUSH_NTF_M(
                        RPL_PUSH_PROP,
            (InitiatorWinsIpAdd == 0) ? ULongToPtr(NmsLocalAdd.Add.IPAdd) : ULongToPtr(InitiatorWinsIpAdd),
                        &WinsAdd,         //don't want to send to this guy.
                        NULL
                       );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
          DBGPRINTEXC("HdlPushNtf: Exception while propagating a trigger");
          WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_PUSH_PROP_FAILED);
        }
      }
      LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    }

     //
     // End the dlg. The right dlg will get terminated.
     // Note: The dlg is explicit (if we establishd it) or implicit (established
     // by the remote client).
     //
     // So, if the remote connection is not persistent or if it is but we
     // the pnr is not persistent for pulling (meaning we established an
     // explicit connection with it, end the dlg.  pDlgHdl points to the right
     // dlg
     //
#if PRSCONN
     if (!fImplicitConnPrs || !pPnr->fPrsConn)
     {
        ECommEndDlg(pDlgHdl);
     }
     else
     {
         //
         // if we are here, it means that we pPnr is set to a Partner.  If
         // we had a comm. failure with it, we should end the Prs Dlg with
         // it.
         //
         if (ExcCode == WINS_EXC_COMM_FAIL)
         {
            ECommEndDlg(&pPnr->PrsDlgHdl);
         }

     }
#else
        ECommEndDlg(pDlgHdl);
#endif


     DBGPRINT0(FLOW, "LEAVE: HdlPushNtf - PULL thread\n");
     return;

}



STATUS
RegGrpRepl(
        LPBYTE                pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T        VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd
        )

/*++

Routine Description:
        This function is called to register a replica of a group entry

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        RplPullPullEntries

Side Effects:

Comments:
        None
--*/

{

        NMSDB_NODE_ADDS_T GrpMems;
        DWORD                  i;                //for loop counter
        DWORD                  n = 0;                //index into the NodeAdd array
        BYTE                  EntTyp;
        BOOL                  fAllocNew;
        STATUS            RetStat;
        GrpMems.NoOfMems = 0;

        DBGENTER("RegGrpRepl\n");
        EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(Flag);

        //
        // Check if it is a special group or a multihomed entry
        //
        if (EntTyp != NMSDB_NORM_GRP_ENTRY)
        {
CHECK("I think I have now stopped sending timed out records");
                //
                // If we did not get any member.  This can only mean that
                // all members of this group/multihomed entry have timed out
                // at the remote WINS.
                //
                if (NoOfAdds != 0)
                {
                        GrpMems.NoOfMems =  NoOfAdds;
                        for (i = 0; i < NoOfAdds; i++)
                        {
                                //
                                // The first address is the address of
                                // the WINS that is the owner of the
                                // member.
                                //
                                fAllocNew = TRUE;
                                RplFindOwnerId(
                                        &pNodeAdd[n++],
                                        &fAllocNew,  //assign if not there
                                        &GrpMems.Mem[i].OwnerId,
                                        WINSCNF_E_INITP_IF_NON_EXISTENT,
                                        WINSCNF_LOW_PREC
                                                    );

                                //
                                // The next address is the address of the
                                // member
                                //
                                GrpMems.Mem[i].Add = pNodeAdd[n++];
                        }
                }
#ifdef WINSDBG
                else  //no members
                {
                        if (NMSDB_ENTRY_STATE_M(Flag) != NMSDB_E_TOMBSTONE)
                        {
                                DBGPRINT0(EXC, "RegGrpRepl: The replica of a special group without any members is not a TOMBSTONE\n");
                                WINSEVT_LOG_M(
                                        WINS_FAILURE,
                                        WINS_EVT_RPL_STATE_ERR
                                             );
                                WINS_RAISE_EXC_M(WINS_EXC_RPL_STATE_ERR);
                        }
                }
#endif
        }
        else  // it is a normal group
        {
NOTE("On a clash with a special group, this owner id. will be stored which")
NOTE("can be misleading")
                GrpMems.NoOfMems       =  1;
                GrpMems.Mem[0].OwnerId = OwnerId;  //misleading (see ClashAtRegGrpRpl()
                                           //in nmsnmh.c - clash between normal
                                           //grp and special grp.
                GrpMems.Mem[0].Add     =  *pNodeAdd;
        }

        RetStat = NmsNmhReplGrpMems(
                        pName,
                        NameLen,
                        EntTyp,
                        &GrpMems,
                        Flag,
                        OwnerId,
                        VersNo,
                        pOwnerWinsAdd
                        );
        DBGLEAVE("RegGrpRepl\n");
        return(RetStat);
}

BOOL
IsTimeoutToBeIgnored(
        PQUE_TMM_REQ_WRK_ITM_T  pWrkItm
        )

/*++

Routine Description:
        This function is called to determine if the timeout that the
        PULL thread received needs to be ignored

Arguments:
        pWrkItm - Timeout work itm

Externals Used:
        None


Return Value:

        TRUE if the timeout needs to be ignored
        FALSE otherwise

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{
        BOOL                        fRetVal = FALSE;

try {
        //
        // If this is the timeout based on old config
        // ignore it.  If the old configuration memory blocks
        // have not been deallocated as yet, deallocate them
        //
        if (pWrkItm->MagicNo != RplPullCnfMagicNo)
        {
                //
                // Deallocate the work item and deallocate
                // the configuration block
                //
                WinsTmmDeallocReq(pWrkItm);
                fRetVal = TRUE;
        }
 }
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("IsTimeoutToBeIgnored");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
 }
        return(fRetVal);
}
VOID
InitRplProcess(
        PWINSCNF_CNF_T        pWinsCnf
 )

/*++

Routine Description:
        This function is called to start the replication process.  This
        comprises of getting the replicas if the InitTimeRpl field
        is set to 1.  Timer requests are also submitted.

Arguments:
        pWinsCnf - pointer to the Wins Configuration structure

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit()

Side Effects:

Comments:
        None
--*/

{
        PRPL_CONFIG_REC_T        pPullCnfRecs = pWinsCnf->PullInfo.pPullCnfRecs;
        BOOL                        fAllocNew;
        DWORD                        OwnerWinsId;
        STATUS                        RetStat;

        //
        // Initialize Owner-Id table with new entries if any
        //
        for (
                        ;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                        //no third expression
            )
        {
                fAllocNew = TRUE;
                RetStat = RplFindOwnerId(
                                &pPullCnfRecs->WinsAdd,
                                &fAllocNew,
                                &OwnerWinsId,
                                WINSCNF_E_INITP,
                                pPullCnfRecs->MemberPrec
                                );

                if (RetStat == WINS_FAILURE)
                {
FUTURES("Improve error recovery")
                        //
                        // We have hit the limit. Break out of the loop
                        // but carry on in the hope that the situation
                        // will correct itself by the time we replicate.
                        // If InitTimeReplication is TRUE, there is no
                        // chance of the table entries getting freed up.
                        // Even if some entries get freed, when we make
                        // an entry for the WINS which we couldn't insert now,
                        // it will take LOW_PREC.
                        //
                        break;
                }
                pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RPL_E_IN_SEQ
                                                      );
        }

        //
        // Do init time replication if not prohibited by the config
        // info.
        //
        if (pWinsCnf->PullInfo.InitTimeRpl)
        {
                /*
                 * Pull replicas and handle them
                */
                GetReplicasNew(
                        pWinsCnf->PullInfo.pPullCnfRecs,
                        RPL_E_IN_SEQ        //records are in sequence
                                 );

        }
        //
        // For all Push partners with which replication has to be done
        // periodically, submit timer requests
        //
        SubmitTimerReqs(pWinsCnf->PullInfo.pPullCnfRecs);
        return;

} // InitRplProcess()


VOID
Reconfig(
        PWINSCNF_CNF_T        pWinsCnf
  )

/*++

Routine Description:
        This function is called to reconfigure the PULL handler

Arguments:
        pNewWinsCnf - New Configuration

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        RplPullInit when it gets the CONFIGURE message
Side Effects:

Comments:
        None
--*/

{
        BOOL    fNewInfo  = FALSE;
        BOOL    fValidReq = FALSE;
#if PRSCONN
        PRPL_CONFIG_REC_T pOldPnr, pNewPnr;
        DWORD i, n;
#endif

        DBGENTER("Reconfig (PULL)\n");

        //
        // synchronize with rpc threads and with the push thread
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

try {

        //
        // Get the latest magic no (set by the main thread)
        //
            RplPullCnfMagicNo        = WinsCnfCnfMagicNo;

        //
        // If the latest magic no is not the same as the one
        // in this configuration block, we can ignore this
        // configuration request
        //
        if (WinsCnfCnfMagicNo == pWinsCnf->MagicNo)
        {
           fValidReq = TRUE;
           DBGPRINT1(RPLPULL, "Reconfig: Magic No (%d) match\n", WinsCnfCnfMagicNo);

           //
           // Initialize the Push records if required
           //
           // Note: NBT threads look at Push config
           // records after doing registrations.  Therefore
           // we should enter the critical section before
           // changing WinsCnf
           //
           EnterCriticalSection(&NmsNmhNamRegCrtSec);
           try {
                if (WinsCnf.PushInfo.pPushCnfRecs != NULL)
                {
#if PRSCONN
                   //
                   // Copy the statistics info
                   //
                   pOldPnr = WinsCnf.PushInfo.pPushCnfRecs;
                   for (i = 0; i < WinsCnf.PushInfo.NoOfPullPnrs; i++)
                   {
                      pNewPnr = pWinsCnf->PushInfo.pPushCnfRecs;
                      for (n=0; n < pWinsCnf->PushInfo.NoOfPullPnrs; n++)
                      {
                          if (pNewPnr->WinsAdd.Add.IPAdd == pOldPnr->WinsAdd.Add.IPAdd)
                          {
                               pNewPnr->LastCommFailTime = pOldPnr->LastCommFailTime;
                               pNewPnr->LastCommTime = pOldPnr->LastCommFailTime;
                               //
                               // If the partner stays persistent, init the dlg
                               // hdl.
                               //
                               if (pNewPnr->fPrsConn && (pNewPnr->fPrsConn == pOldPnr->fPrsConn))
                               {
                                   pNewPnr->PrsDlgHdl = pOldPnr->PrsDlgHdl;
                               }
                               else
                               {
                                   //
                                   // The partner was persistent but is no
                                   // longer so. Terminate the dlg
                                   //
                                   if (pOldPnr->fPrsConn)
                                   {
                                        ECommEndDlg(&pOldPnr->PrsDlgHdl);
                                   }

                               }
                               break;
                          }
                          pNewPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pNewPnr + RPL_CONFIG_REC_SIZE);
                      }
                      pOldPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pOldPnr + RPL_CONFIG_REC_SIZE);
                   }
#endif

                   WinsMscDealloc(WinsCnf.PushInfo.pPushCnfRecs);
                }

                WinsCnf.PushInfo = pWinsCnf->PushInfo;

               //
               // Initialize the push records
               //
               if (pWinsCnf->PushInfo.pPushCnfRecs != NULL)
               {
PERF("Do the following along with the stuff under PRSCONN")
                   RPLPUSH_INIT_PUSH_RECS_M(&WinsCnf);
               }
           }
           except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("Reconfig (PULL thread)");

                //
                // Log a message
                //
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
             }
             LeaveCriticalSection(&NmsNmhNamRegCrtSec);

          //
          // We need to first get rid of all timer requests that
          // we made based on the previous configuration
          //
          if (WinsCnf.PullInfo.pPullCnfRecs != NULL)
          {
#if !PRSCONN
                PRPL_CONFIG_REC_T pOldPnr, pNewPnr;
                DWORD i, n;
#endif

                fNewInfo = TRUE;

                //
                // Cancel (and deallocate) all requests that we might have
                // submitted
                //
                WinsTmmDeleteReqs(WINS_E_RPLPULL);

                //
                // Copy the statistics info
                //
                pOldPnr = WinsCnf.PullInfo.pPullCnfRecs;
                for (i = 0; i < WinsCnf.PullInfo.NoOfPushPnrs; i++)
                {
                      pNewPnr = pWinsCnf->PullInfo.pPullCnfRecs;
                      for (n=0; n < pWinsCnf->PullInfo.NoOfPushPnrs; n++)
                      {
                          if (pNewPnr->WinsAdd.Add.IPAdd == pOldPnr->WinsAdd.Add.IPAdd)
                          {
                               pNewPnr->NoOfRpls      = pOldPnr->NoOfRpls;
                               pNewPnr->NoOfCommFails = pOldPnr->NoOfCommFails;
#if PRSCONN
                               pNewPnr->LastCommFailTime = pOldPnr->LastCommFailTime;
                               pNewPnr->LastCommTime = pOldPnr->LastCommFailTime;
                               //
                               // If the partner stays persistent, init the dlg
                               // hdl.
                               //
                               if (pNewPnr->fPrsConn && (pNewPnr->fPrsConn == pOldPnr->fPrsConn))
                               {
                                   pNewPnr->PrsDlgHdl = pOldPnr->PrsDlgHdl;
                               }
                               else
                               {
                                   //
                                   // The partner was persistent but is no
                                   // longer so. Terminate the dlg
                                   //
                                   if (pOldPnr->fPrsConn)
                                   {
                                        ECommEndDlg(&pOldPnr->PrsDlgHdl);
                                   }

                               }
#endif
                               break;
                          }
                          pNewPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pNewPnr + RPL_CONFIG_REC_SIZE);
                      }
                      pOldPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pOldPnr + RPL_CONFIG_REC_SIZE);
                }

                //
                // Deallocate the memory holding the pull configuration blocks
                //
                //
                WinsMscDealloc(WinsCnf.PullInfo.pPullCnfRecs);
          }

          //
          // Initialize with the new information
          //
          WinsCnf.PullInfo    = pWinsCnf->PullInfo;

     }
#ifdef WINSDBG
     else
     {
           DBGPRINT2(RPLPULL, "Reconfig: Magic Nos different. WinsCnfCnfMagicNo=(%d), pWinsCnf->MagicNo = (%d)\n", WinsCnfCnfMagicNo, pWinsCnf->MagicNo);
     }
#endif

   }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("Reconfig: Pull Thread");
        }

        //
        // synchronize with rpc threads doing WinsStatus/WinsTrigger
        //
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        if (fValidReq)
        {
          if (WinsCnf.pPersonaList != NULL)
          {
                 WinsMscDealloc(WinsCnf.pPersonaList);
          }
          WinsCnf.fPersonaGrata = pWinsCnf->fPersonaGrata;
          WinsCnf.NoOfPersona  = pWinsCnf->NoOfPersona;
          WinsCnf.pPersonaList = pWinsCnf->pPersonaList;

          //
          // Start the replication process if there are PULL records
          // in the new configuration
          //
          if (WinsCnf.PullInfo.pPullCnfRecs != NULL)
          {
                InitRplProcess(&WinsCnf);
          }
        }

        //
        // Deallocate the new config structure
        //
        WinsCnfDeallocCnfMem(pWinsCnf);

        DBGLEAVE("Reconfig (PULL)\n");
        return;
} // Reconfig()

VOID
AddressChangeNotification(
        PWINSCNF_CNF_T        pWinsCnf
  )

/*++

Routine Description:
        This function is called to handle address change of the local
        machine.

Arguments:
        pNewWinsCnf - New Configuration

Externals Used:
        None


Return Value:

        None
Error Handling:

Side Effects:

Comments:
        None
--*/

{
    DBGENTER("AddressChangeNotification\n");
    //
    // if our address has changed, the following routine
    // will reinitialize the owner address table with own address
    //

    InitOwnAddTbl();
    DBGLEAVE("AddressChangeNotification\n");
        return;
} // AddressChangeNotification()

VOID
PullSpecifiedRange(
        PCOMM_HDL_T                 pDlgHdl,
        PWINSINTF_PULL_RANGE_INFO_T pPullRangeInfo,
        BOOL                        fAdjustMin,
        DWORD                       RplType
        )

/*++

Routine Description:
        This function is called to pull a specified range of records from
        a remote WINS server

Arguments:


Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        PUSHPNR_DATA_T       PushPnrData[1];
        DWORD                NoOfPushPnrs = 1;
        DWORD                OwnerId;
        BOOL                 fEnterCrtSec = FALSE;
        PRPL_CONFIG_REC_T    pPnr = pPullRangeInfo->pPnr;
        COMM_ADD_T           OwnAdd;
        BOOL                 fAllocNew = TRUE;
        PPUSHPNR_DATA_T      pPushPnrData = PushPnrData;

        //
        // Establish communications with the Push Pnr
        //
        // When this function returns, the 'NoOfPushPnrs' entries of
        // PushPnrData array will be initialized.
        //
        if (pDlgHdl == NULL)
        {
           EstablishComm(
                        pPnr,
                        FALSE,
                        &pPushPnrData,
                        RPL_E_NO_TRAVERSAL,
                        &NoOfPushPnrs
                     );
        }
        else
        {
               PushPnrData[0].DlgHdl = *pDlgHdl;
        }


try {

        //
        // if communication could be established above, NoOfPushPnrs will
        // be 1
        //
        if (NoOfPushPnrs == 1)
        {
          //
          // Get owner id. of WINS whose entries are to be pulled
          //
          OwnAdd.AddTyp_e                = pPullRangeInfo->OwnAdd.Type;
          OwnAdd.AddLen                = pPullRangeInfo->OwnAdd.Len;
          OwnAdd.Add.IPAdd        = pPullRangeInfo->OwnAdd.IPAdd;

PERF("for the case where pDlgHdl != NULL, the Owner Id is 0. See GetReplicasNew->ConductChkNew")
PERF("We could make use of that to go around the RplFindOwnerId call")

          (VOID)RplFindOwnerId(
                        &OwnAdd,
                        &fAllocNew,//allocate a new entry if WINS is not found
                        &OwnerId,
                        WINSCNF_E_INITP_IF_NON_EXISTENT,
                        WINSCNF_LOW_PREC
                      );
          //
          // if a new entry was not allocated, it means that there are
          // records for this owner in the database.  We might have to
          // delete some or all.
          //
          // If the local WINS owns the records, enter the critical section
          // so that NmsNmhMyMaxVersNo is not changed by Nbt or Rpl threads
          // while we are doing our work here
          //
          if (!fAllocNew)
          {
            if (OwnerId == NMSDB_LOCAL_OWNER_ID)
            {
                //
                // See NOTE NOTE NOTE below.
                //
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                fEnterCrtSec = TRUE;

                //
                // If we have not been told to adjust the min. vers. no,
                // delete all records that have a version number greater
                // than the minimum to be pulled
                //
                if (LiLtr(pPullRangeInfo->MinVersNo, NmsNmhMyMaxVersNo))
                {
                      if (!fAdjustMin)
                      {
                        NmsDbDelDataRecs(
                                OwnerId,
                                pPullRangeInfo->MinVersNo,
                                pPullRangeInfo->MaxVersNo,
                                FALSE,                //do not enter critical section
                                FALSE          //one shot deletion
                                        );
                      }
                      else
                      {
                           pPullRangeInfo->MinVersNo = NmsNmhMyMaxVersNo;
                      }
                }

            }
            else//records to be pulled are owned by some other WINS server
            {
                if (LiLeq(pPullRangeInfo->MinVersNo,
                                (pRplPullOwnerVersNo+OwnerId)->VersNo))
                {
                        NmsDbDelDataRecs(
                                OwnerId,
                                pPullRangeInfo->MinVersNo,
                                pPullRangeInfo->MaxVersNo,
                                TRUE,                  //enter critical section
                                FALSE           //one shot deletion
                                        );
                }
            }
         }


          //
          // Pull Entries.
          //
          // NOTE NOTE NOTE
          //
          // RplPullPullEntries will update NmsNmhMyMaxVersNo counter if
          // we pull our own records with the highest version number being
          // pulled being > NmsNmhMyMaxVersNo.  For the above case,
          // RplPullPullEntries assumes that we are inside the
          // NmsNmhNamRegCrtSec critical section.
          //
          if (LiGeq(pPullRangeInfo->MaxVersNo, pPullRangeInfo->MinVersNo))
          {
            RplPullPullEntries(
                   &PushPnrData[0].DlgHdl,
                   OwnerId,                        //owner id
                   pPullRangeInfo->MaxVersNo,  //Max vers. no to be pulled
                   pPullRangeInfo->MinVersNo,  //Min vers. no to be pulled
                   WINS_E_RPLPULL,
                   NULL,
                   FALSE,        //don't update RplOwnAddTblVersNo counters
                                //unless pulled version number is > what
                                //we currently have.
                   RplType
                              );
         }
        } // end of if (NoOfPushPnrs == 1)
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "PullSpecifiedRange: Got exception %x",  ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_PULL_RANGE_EXC);
 }

        if (fEnterCrtSec)
        {
                //
                // The following assumes that we enter the critical section
                // in this function only when pulling our own records.  This
                // is true currently.
                // If the min. vers. no. specified for pulling is <
                // the Min. for scavenging, adjust the min. for scavenging.
                // Note: We may not have pulled this minimum but we adjust
                // the min. for scavenging regardless.  This is to save
                // the overhead that would exist if we were to adopt the
                // approach of having RplPullPullEntries do the same (we
                // would need to pass an arg. to it; Note: This function
                // will be used in rare situations by an admin.
                //
                // We need to synchronize with the Scavenger thread.
                //
                if (LiGtr(NmsScvMinScvVersNo, pPullRangeInfo->MinVersNo))
                {
                        NmsScvMinScvVersNo = pPullRangeInfo->MinVersNo;
                }
                        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }

        if (pPnr->fTemp)
        {
                WinsMscDealloc(pPullRangeInfo->pPnr);
        }


        if (pDlgHdl == NULL)
        {
#if PRSCONN
           if (!PushPnrData[0].fPrsConn)
           {
             //
             // End the dialogue
             //
             ECommEndDlg(&PushPnrData[0].DlgHdl);
           }
#else

           ECommEndDlg(&PushPnrData[0].DlgHdl);
#endif
        }

        return;

} //PullSpecifiedRange()


STATUS
RplPullRegRepl(
        LPBYTE                pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T        VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd,
        DWORD           RplType
        )

/*++

Routine Description:
        This function is called to register a replica.

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        It is called by RplPullPullEntries and by ChkConfNUpd in nmsscv.c
--*/

{
       STATUS RetStat;

try {
           //
           // If this is a unique replica, call NmsNmhReplRegInd
           //
           if (NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY)
           {
                //
                // If only spec. grps and pdc name are to be replicated and
                // this name is not a pdc name, skip it
                //
#if 0
                if ((RplType & WINSCNF_RPL_SPEC_GRPS_N_PDC)
                   && (!NMSDB_IS_IT_PDC_NM_M(pName)))
                {
                       DBGPRINT1(RPLPULL, "RplPullRegRepl: Ignoring unique record - name = (%s)\n", pName);
                       return(WINS_SUCCESS);
                }
#endif

                RetStat = NmsNmhReplRegInd(
                                pName,
                                NameLen,
                                pNodeAdd,
                                Flag,
                                OwnerId,
                                VersNo,
                                pOwnerWinsAdd  //add. of WINS owning the record
                                   );
           }
           else  // it is either a normal or a special group or a multihomed
                 // entry
           {
#if 0
                if ((RplType & WINSCNF_RPL_SPEC_GRPS_N_PDC)
                                     &&
                   (!NMSDB_ENTRY_SPEC_GRP_M(NMSDB_ENTRY_TYPE_M(Flag))))
                {
                       DBGPRINT1(RPLPULL, "RplPullRegRepl: Ignoring non-SG record - name = (%s)\n", pName);
                       return(WINS_SUCCESS);
                }
#endif
                RetStat = RegGrpRepl(
                           pName,
                           NameLen,
                           Flag,
                           OwnerId,
                           VersNo,
                           NoOfAdds,
                           pNodeAdd,
                           pOwnerWinsAdd  //add. of WINS owning the record
                          );
           }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "RplPullRegRepl: Got Exception %x", ExcCode);
    WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_EXC);
    RetStat = WINS_FAILURE;
        }

        if (RetStat == WINS_FAILURE)
        {
            WinsEvtLogDetEvt(FALSE, NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY ? WINS_EVT_RPL_REG_UNIQUE_ERR : WINS_EVT_RPL_REG_GRP_MEM_ERR,
               NULL, __LINE__, "sddd", pName,
               pOwnerWinsAdd->Add.IPAdd,
               VersNo.LowPart, VersNo.HighPart);

                WINSEVT_LOG_M(pNodeAdd->Add.IPAdd, WINS_EVT_RPL_REG_ERR);

             //
             // If WINS has been directed to continue replication on error,
             // change RetStat to fool the caller into thinking that
             // the replica registration was successful.
             //
             if (!WinsCnf.fNoRplOnErr)
             {
                   RetStat = WINS_SUCCESS;
             }
        }
        return(RetStat);
} // RplPullRegRepl()


VOID
DeleteWins(
        PCOMM_ADD_T        pWinsAdd
  )

/*++

Routine Description:
        This function deletes all records belonging to a WINS.  It
        also removes the entry of the WINS from the Owner-Add database
        table.  It marks the entry as deleted in the in-memory table so
        that it can be reused if need be.

Arguments:
        pWinsAdd - Address of WINS whose entry is to be removed

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
   BOOL           fAllocNew = FALSE;
   DWORD   OwnerId;
   STATUS  RetStat;
   DWORD   fEnterCrtSec = FALSE;
   DWORD ExcCode = WINS_SUCCESS;

   //
   // Find the owner id of the WINS. If the WINS is not in the table
   // return
   //
   RetStat = RplFindOwnerId(
                                pWinsAdd,
                                &fAllocNew,
                                &OwnerId,
                                WINSCNF_E_IGNORE_PREC,
                                WINSCNF_LOW_PREC
                            );

   if (RetStat == WINS_SUCCESS)
   {
        if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                //
                // We always keep the entry for the local WINS.
                //
                DBGPRINT0(ERR, "DeleteWins: Sorry, you can not delete the local WINS\n");
                //WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_DELETE_LOCAL_WINS_DISALLOWED);
        }
        else
        {
                VERS_NO_T        MinVersNo;
                VERS_NO_T        MaxVersNo;
                WINSEVT_STRS_T  EvtStrs;
                WCHAR           String[WINS_MAX_NAME_SZ];
                struct in_addr  InAddr;

                InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                (VOID)WinsMscConvertAsciiStringToUnicode(
                            inet_ntoa( InAddr),
                            (LPBYTE)String,
                            WINS_MAX_NAME_SZ);

                EvtStrs.NoOfStrs = 1;
                EvtStrs.pStr[0]  = String;
                WINSEVT_LOG_INFO_STR_D_M(WINS_EVT_DEL_OWNER_STARTED, &EvtStrs);

                WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);
                WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);


                //
                // Need to synchronize with NBT threads or rpc threads that
                // might be modifying these records. NmsDelDataRecs will
                // enter the critical section
                //
#if 0
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
#endif

        try {
                //
                // Delete all records
                //
                RetStat = NmsDbDelDataRecs(
                                OwnerId,
                                MinVersNo,
                                MaxVersNo,
                                TRUE,               //enter critical section
                                TRUE         //fragmented deletion
                                        );

                //
                // If all records were deleted, mark entry as deleted.
                //
                if (RetStat == WINS_SUCCESS)
                {
                        EnterCriticalSection(&RplVersNoStoreCrtSec);
                        WINS_ASSIGN_INT_TO_LI_M((pRplPullOwnerVersNo+OwnerId)->VersNo, 0);
                        LeaveCriticalSection(&RplVersNoStoreCrtSec);

                        //
                        // Delete the entry for the WINS from the db table
                        // and mark WINS as deleted in the in-memory table.
                        //
                        // This way, we will free up entries in the table.
                        //
                        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                        fEnterCrtSec = TRUE;
                        (pNmsDbOwnAddTbl+OwnerId)->WinsState_e =  NMSDB_E_WINS_DELETED;
                        //
                        // Delete entry from the owner-Add table
                        //
                        NmsDbWriteOwnAddTbl(
                                NMSDB_E_DELETE_REC,
                                OwnerId,
                                NULL,
                                NMSDB_E_WINS_DELETED,
                                NULL,
                                NULL
                                        );

                }
                else
                {
                      DBGPRINT2(ERR, "DeleteWins: Could not delete one or more records of WINS with owner Id = (%d) and address = (%x)\n", OwnerId,
pWinsAdd->Add.IPAdd);
                }
           } //end of try
           except(EXCEPTION_EXECUTE_HANDLER) {
               ExcCode = GetExceptionCode();
               DBGPRINT1(EXC, "DeleteWins: Got Exception (%x)\n", ExcCode);
               RetStat = WINS_FAILURE;
           } // end of exception handler

          if (fEnterCrtSec)
          {
                  LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
          }

          if (RetStat == WINS_FAILURE)
          {
               //
               // There is no danger of pWinsAdd being NULL. See WinsDeleteWins
               //
               WinsEvtLogDetEvt(FALSE, WINS_EVT_COULD_NOT_DELETE_WINS_RECS,
                 NULL, __LINE__, "dd", pWinsAdd->Add.IPAdd,
                 ExcCode );

               //
               // Since we are leaving the database in an inconsistent state,
               // mark the WINS as inconsistent
               //
               (pNmsDbOwnAddTbl+OwnerId)->WinsState_e =  NMSDB_E_WINS_INCONSISTENT;

          } else {
              WINSEVT_LOG_INFO_STR_D_M(WINS_EVT_DEL_OWNER_COMPLETED, &EvtStrs);
          }

      }  // end of else
   } // end of if (WINS is in own-add table)

   //
   // deallocate the buffer
   //
   WinsMscDealloc(pWinsAdd);
   return;
}

BOOL
AcceptPersona(
  PCOMM_ADD_T  pWinsAdd
 )
/*++
Routine Description:
   Accept a persona in either of the two situations:
   - PersonaType setting points to 'Persona Grata list', the list exists and
     the address is in the list.
   - PersonaType setting points to 'Persona Non-Grata list' and either the list
     doesn't exist or the address is not there.
   Side effects:
   - If none of the two settings is defined (PersonaType & PersonaList)
     this is like a non-existant 'Persona Non-Grata list' which means all WINS 
     will be accepted.
   - If only PersonaType exists and it says 'Persona Grata list' this is like
     a non-existant Persona Grata list hence no WINS will be accepted!
Arguments:
   pWinsAdd - address of the WINS to check
Return Value:
   TRUE if the WINS pWinsAdd is a persona grata/non-grata (depending on fGrata),
   FALSE otherwise
Called by:
   FilterPersona()
--*/
{
    PRPL_ADD_VERS_NO_T pPersona = NULL;

    DBGPRINT1(RPLPULL, "AcceptPersona check for address=(%x)\n", pWinsAdd->Add.IPAdd);

    // if the list exists, look for the address in it
    if (WinsCnf.pPersonaList != NULL)
        pPersona = bsearch(
                      pWinsAdd,
                      WinsCnf.pPersonaList,
                      (size_t)WinsCnf.NoOfPersona,
                      sizeof(COMM_ADD_T),
                      ECommCompareAdd);;

    if (WinsCnf.fPersonaGrata)
        // if the list is 'persona grata', the address has to be there in order to 
        // be accepted.
        return (pPersona != NULL);
    else
        // otherwise, WINS is accepted if either the list doesn't exist or the address
        // is not there
        return (pPersona == NULL);
}

VOID
FilterPersona(
  PPUSHPNR_DATA_T   pPushData
  )
/*++
Routine Description:
    Filters out from the PUSHPNR_DATA_T structure those OwnerAddress<->VersionNo mappings
    that are denied by persona grata/non-grata list. This routine adjustes from that structure
    only the NoOfMaps field and moves around elements in the array pointed by pAddVers
    (bubbling up the ones that are accepted).
Arguments:
    pPushData - pointer to the PUSHPNR_DATA_T providing the mapping table
Called by:
    HdlPushNtf
--*/
{
    DWORD i, newNoOfMaps;
    PRPL_ADD_VERS_NO_T pAddVers = pPushData->pAddVers;

    // in most common case, none of 'PersonaType' or 'PersonaList' is defined. This means
    // we deny no WINS so we don't need to filter anything - then get out right away.
    if (!WinsCnf.fPersonaGrata && WinsCnf.pPersonaList == NULL)
        return;

    for (i = 0, newNoOfMaps = 0; i < pPushData->NoOfMaps; i++)
    {
        if (AcceptPersona(&(pAddVers[i].OwnerWinsAdd)))
        {
            // if the decision is to accept this WINS, move it to the top of the list
            // over the ones that were rejected. If none was rejected yet, no memory
            // operation is performed.
            if (newNoOfMaps < i)
            {
                memcpy(&pAddVers[newNoOfMaps], &pAddVers[i], sizeof(RPL_ADD_VERS_NO_T));
            }

            // since this wins was accepted, increment the counter of accepted wins.
            newNoOfMaps++;
        }
    }

    // only the first newNoOfMaps have to be considered from now on
    pPushData->NoOfMaps = newNoOfMaps;

    // just in case no WINS was accepted, cleanup the pAddVers array
    if (pPushData->NoOfMaps == 0 && pPushData->pAddVers != NULL)
    {
        WinsMscDealloc(pPushData->pAddVers);
        pPushData->pAddVers = NULL;
    }
}

VOID
RplPullAllocVersNoArray(
      PRPL_VERS_NOS_T *ppRplOwnerVersNo,
      DWORD          CurrentNo
     )
{

        if (*ppRplOwnerVersNo != NULL)
        {
          DWORD MemSize = sizeof(RPL_VERS_NOS_T) * (CurrentNo + 100);
          WINSMSC_REALLOC_M( MemSize,  (LPVOID *)ppRplOwnerVersNo );
        }
        else
        {
          DWORD MemSize = sizeof(RPL_VERS_NOS_T) * (CurrentNo + 100);
          WinsMscAlloc(
                    MemSize,
                    (LPVOID *)ppRplOwnerVersNo
                    );

        }
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wins\server\rpl\rplpush.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        rplpush.c

Abstract:
        This module contains functions of the PUSH handler component
        of the Replicator.

        These functions handle the pull requests from a Pull Partner


Functions:
        RplPushInit
        ExecuteWrkItm
        HandleAddVersMapReq
        HandleSndEntriesReq
        HandleUpdNtf
        HandleUpdVersNoReq

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "nmsnmh.h"
#include "nms.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "rplpush.h"
#include "rplpull.h"
#include "winsevt.h"
#include "winsque.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "comm.h"


/*
 *        Local Macro Declarations
*/

//
// The amount of time the push thread will wait after its last activity
// before exiting.  This is kept to be 5 mts for now.
//
//  It is a good idea to keep it less than the Min. Replication time
//  interval
//
#define   WAIT_TIME_BEFORE_EXITING        (300000)

/*
 *        Local Typedef Declarations
*/


/*
 *        Global Variable Definitions
*/

HANDLE                RplPushCnfEvtHdl;

BOOL                fRplPushThdExists = FALSE;

/*
 *        Local Variable Definitions
*/



/*
 *        Local Function Prototype Declarations
*/
STATIC
STATUS
HandleAddVersMapReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );
STATIC
STATUS
HandleSndEntriesReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );


STATIC
VOID
HandleUpdNtf(
#if PRSCONN
        BOOL                          fPrsConn,
#endif
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
HandleUpdVersNoReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );
STATIC
VOID
ExecuteWrkItm(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );


/* prototypes for functions local to this module go here */

STATUS
RplPushInit(
        LPVOID pParam
        )

/*++

Routine Description:

        This function is the start function of the Push Thread.
        The function blocks on an auto-reset event variable until signalled

          When signalled it
                dequeues a work item from from its work queue and executes it

Arguments:
        pParam

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ERplInit

Side Effects:

Comments:
        None
--*/
{
        HANDLE                         ThdEvtArr[2];
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;
        DWORD                        RetVal;
        BOOL                        fSignaled;


        UNREFERENCED_PARAMETER(pParam);
try {
        //
        // Initialize the thd
        //
        NmsDbThdInit(WINS_E_RPLPUSH);
        DBGMYNAME("Replicator Push Thread\n");

        //
        // We do this at each thread creation to save on STATIC storage.  This
        // way when the thread is not there we don't consume resources.
        //
        ThdEvtArr[0]    = NmsTermEvt;
        ThdEvtArr[1]        = QueRplPushQueHd.EvtHdl;

        while(TRUE)
        {
try {
           /*
            *  Block until signaled or until timer expiry
           */
           WinsMscWaitTimedUntilSignaled(
                                ThdEvtArr,
                                2,
                                &ArrInd,
                                WAIT_TIME_BEFORE_EXITING,
                                &fSignaled
                                );

           //
           // If the wait was interrupted due to a termination signal or
           // if the wait timed out, exit the thread.
           //
           if (!fSignaled || (ArrInd == 0))
           {
                //
                // if the thread has timed out, we need to exit it. Before
                // we do that, we check whether some thread sneaked in
                // a message after the timeout
                //
                if (!fSignaled)
                {
                        PQUE_HD_T        pQueHd = pWinsQueQueHd[QUE_E_RPLPUSH];

                        //
                        // QueGetWrkItm also enters the Push thread's critical
                        // section.  I don't want to write a separate function
                        // or overload the QueGetWrkItem function to avoid
                        // the double entry into the critical section.
                        //
                        EnterCriticalSection(&pQueHd->CrtSec);
                        RetVal                  = QueGetWrkItm(
                                                        QUE_E_RPLPUSH,
                                                        (LPVOID)&pWrkItm
                                                          );
                        //
                        // if we got a request execute it.
                        //
                        if (RetVal != WINS_NO_REQ)
                        {
                                LeaveCriticalSection(&pQueHd->CrtSec);
                                NmsDbOpenTables(WINS_E_RPLPUSH);
                                ExecuteWrkItm(pWrkItm);
                                NmsDbCloseTables();
                        }
                        else
                        {
                                //
                                // set the flag to FALSE so that if a message
                                // comes for this Push thread, it is created.
                                //
                                fRplPushThdExists = FALSE;
                                WinsThdPool.ThdCount--;

                                WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].
                                        fTaken = FALSE;

                                //
                                // Be sure to close the handle, otherwise
                                // the thread object will stay.
                                //
                                CloseHandle(
                                  WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].
                                                                ThdHdl
                                           );
                                LeaveCriticalSection(&pQueHd->CrtSec);
                                WinsMscTermThd(WINS_SUCCESS,
                                        WINS_DB_SESSION_EXISTS);
                        }
              }
              else  //signaled for termination by the main thread
              {
                        WinsMscTermThd(WINS_SUCCESS,
                                        WINS_DB_SESSION_EXISTS);
              }

           }


           /*
            *loop forever until all work items have been handled
           */
            while(TRUE)
           {
                /*
                 *  dequeue the request from the queue
                */
                RetVal = QueGetWrkItm(
                                        QUE_E_RPLPUSH,
                                        (LPVOID)&pWrkItm
                                     );
                if (RetVal == WINS_NO_REQ)
                {
                        break;
                }


                NmsDbOpenTables(WINS_E_RPLPUSH);
                ExecuteWrkItm(pWrkItm);
                NmsDbCloseTables();

                //
                //  Check for termination here since WINS could be under
                //  stress with a large number of messages in the queue.
                //  We don't want to delay the stop.
                //
                WinsMscChkTermEvt(
#ifdef WINSDBG
                            WINS_E_RPLPUSH,
#endif
                            FALSE
                            );
           }
      } // end of try
      except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("Replicator Push thread");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }

    } // end of while
  } // end of try

except (EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("Replicator Push thread");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit comes back with an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
 }
     //
     // We should never get here.
     //
     return(WINS_FAILURE);
}


VOID
ExecuteWrkItm(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        The function executes a work item. The work item can either be
        a push notification request from within this WINS (from an NBT thread)
        or a replication request (from a remote WINS)

Arguments:
        pWrkItm - ptr to a work item

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        RplPushInit

Side Effects:

Comments:
        None
--*/

{

        RPLMSGF_MSG_OPCODE_E        PullReqType_e;
#if PRSCONN
        BOOL                        fPrsConn = FALSE;
#endif
        BOOL                        fPushNtf = FALSE;

        //
        // get the opcode
        //
        RplMsgfUfmPullPnrReq(
                                pWrkItm->pMsg,
                                pWrkItm->MsgLen,
                                &PullReqType_e
                            );

        switch(PullReqType_e)
        {

          case(RPLMSGF_E_ADDVERSNO_MAP_REQ):
                HandleAddVersMapReq(pWrkItm);
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoAddVersReq++;
#endif
                break;

          case(RPLMSGF_E_SNDENTRIES_REQ):
                HandleSndEntriesReq(pWrkItm);
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoSndEntReq++;
#endif
                break;
#if PRSCONN
          case(RPLMSGF_E_UPDATE_NTF_PRS):
          case(RPLMSGF_E_UPDATE_NTF_PROP_PRS):
               fPrsConn = TRUE;
#endif
          case(RPLMSGF_E_UPDATE_NTF):
          case(RPLMSGF_E_UPDATE_NTF_PROP):

                fPushNtf = TRUE;
#if PRSCONN
                HandleUpdNtf(fPrsConn, pWrkItm);
#else
                HandleUpdNtf(pWrkItm);
#endif

#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoUpdNtfReq++;
#endif
                break;

          case(RPLMSGF_E_UPDVERSNO_REQ):
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoUpdVersReq++;
#endif
                HandleUpdVersNoReq(pWrkItm);
                break;

          default:
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoInvReq++;
#endif
                DBGPRINT1(ERR, "RplPush: ExecuteWrkItm: Invalid Opcode (%d)\n",
                                                PullReqType_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                break;
        }

        //
        // If the message is not an update notification,
        // Free the message buffer.  For an update
        // notification, the message is handed to
        // the PULL thread to handle.  Therefore, we should not free it
        // The work items needs to be freed always since we always allocate
        // a new work item when queuing a request.
        //
        if ( !fPushNtf)
        {
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);

        }

        //
        // Deallocate the work item
        //
        QueDeallocWrkItm( RplWrkItmHeapHdl,  pWrkItm );

        return;
}


STATUS
HandleAddVersMapReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function handles a "send address - version # " request

Arguments:
        pWrkItm - Work item that carries the request and associated info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        LPBYTE                   pRspBuff;
        DWORD                    RspMsgLen;
        PRPL_ADD_VERS_NO_T       pPullAddNVersNo;
        DWORD                    i = 0;
        DWORD                    MaxNoOfOwners;
        PRPL_CONFIG_REC_T        pPnr;
        COMM_ADD_T               WinsAdd;
        BOOL                     fRplPnr = FALSE;
        BOOL                     fExc    = FALSE;
        struct in_addr           InAddr;
        PCOMM_ADD_T              pWinsAdd;
        PNMSDB_WINS_STATE_E      pWinsState_e;
        DWORD                    SizeOfBuff;
        BOOL                     fRspBuffAlloc = FALSE;
#if SUPPORT612WINS > 0
        BOOL                     fIsPnrBeta1Wins;
#endif

        DBGENTER("HandleAddVersMapReq\n");

        //
        // We need to handle this request only if
        // either the WINS that sent this message is one of our
        // pull pnrs or if the fRplOnlyWCnfPnrs in the registry is FALSE
        //

        EnterCriticalSection(&WinsCnfCnfCrtSec);
   try {
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
              if ((pPnr = WinsCnf.PushInfo.pPushCnfRecs) != NULL)
              {
                 COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == WinsAdd.Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
              }
        }
        else
        {
                fRplPnr     = TRUE;
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("HandleAddVersMapReq");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
                fExc = TRUE;
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
try {

        if (fRplPnr)
        {

           VERS_NO_T        MinOwnVersNo;
           BOOL             fOwnInited = FALSE;
           DWORD            TotNoOfOwners;

           MaxNoOfOwners = 0;
           WINS_ASSIGN_INT_TO_LI_M(MinOwnVersNo, 1);


           DBGPRINT1(TMP, "HandleAddVersMap: WINS (%x) made an AddVersMap request\n", WinsAdd.Add.IPAdd);
           EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
           TotNoOfOwners = NmsDbNoOfOwners;
           LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
           WinsMscAlloc(sizeof(RPL_ADD_VERS_NO_T) * TotNoOfOwners, &pPullAddNVersNo);

           //
           // If version counter value > 1, we will send it
           //
           EnterCriticalSection(&NmsNmhNamRegCrtSec);
           if (LiGtr(NmsNmhMyMaxVersNo, MinOwnVersNo))
           {
              /*
              *  Get the max. version no for entries owned by self
              *
              *  The reason we subtract 1 from NmsNmhMyMaxVersNo is because
              *  it contains the version number to be given to the next record
              *  to be registered/updated.
              */
              NMSNMH_DEC_VERS_NO_M(
                             NmsNmhMyMaxVersNo,
                             pPullAddNVersNo->VersNo
                            );
               pPullAddNVersNo->OwnerWinsAdd = NmsLocalAdd;
               pPullAddNVersNo->StartVersNo  =  NmsDbStartVersNo;

               MaxNoOfOwners++;
               fOwnInited = TRUE;
           }
           LeaveCriticalSection(&NmsNmhNamRegCrtSec);


           //
           //  BUG 26196
           // Note: These critical sections are taken in the order given below
           // by the RPC thread executing GetConfig
           //
           EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
           EnterCriticalSection(&RplVersNoStoreCrtSec);

    try {
           for (i = 1; i < TotNoOfOwners; i++)
           {
                //
                // If the highest version number for an owner as identified
                // by the RplPullOwnerVersNo table is zero, there is no
                // need to send the mapping of this owner.  The reason
                // we may have a such an entry in our in-memory table is
                // because 1)All records of the owner got deleted. Local
                // WINS got terminated and reinvoked. On reinvocation, it
                // did not find any records in the db.
                //           2)Local WINS received a Pull range
                //             request for an owner that it did not know about.
                //             Since Pull Range request comes in as a
                //             "SndEntries" request, the Push thread has
                //             no way of distinguishing it from a normal
                //             2 message pull request.  For a 2 message
                //             request, "SndEntries" request will always
                //             have a subset of the WINS servers that
                //             have records in our db.
                //
                if (LiGtrZero((pRplPullOwnerVersNo+i)->VersNo) &&
                     (pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                {
                   PVERS_NO_T    pStartVersNo;
                   (pPullAddNVersNo+MaxNoOfOwners)->VersNo = (pRplPullOwnerVersNo+i)->VersNo;
                   //
                   // Note:  Since RplPullOwnerVersNo[i] is > 0, the
                   // State of the entry can not be deleted (see
                   // RplPullPullEntrie)
                   //
                   RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e,
                                        pStartVersNo);
                   (pPullAddNVersNo+MaxNoOfOwners)->OwnerWinsAdd  = *pWinsAdd;
                   (pPullAddNVersNo+MaxNoOfOwners++)->StartVersNo = *pStartVersNo;
                   DBGPRINT3(RPLPUSH, "HandleAddVersMap:Owner Add (%x) - Vers. No (%d %d)\n", pWinsAdd->Add.IPAdd, (pRplPullOwnerVersNo+i)->VersNo.HighPart, (pRplPullOwnerVersNo+i)->VersNo.LowPart);
                }
PERF("Speed it up by using pointer arithmetic")
           }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("HandleAddVersMapReq");
       DBGPRINT1(EXC, "HandleAddVersMapReq: Exc. while checking vers. nos of owners\n", GetExceptionCode());
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
     }

           //
           // Let us initialize RplPullOwnerVersNo entry for the local WINS
           //
           //  This is done so that if we later on pull from the remote WINS,
           //  we don't end up pulling our own records
           //

           if (fOwnInited)
           {
              pRplPullOwnerVersNo->VersNo      =   pPullAddNVersNo->VersNo;
              pRplPullOwnerVersNo->StartVersNo =  pPullAddNVersNo->StartVersNo;
              DBGPRINT3(RPLPUSH, "HandleAddVersMap: Owner Add (%x) - Vers. No (%d %d)\n", NmsLocalAdd.Add.IPAdd, (pRplPullOwnerVersNo+i)->VersNo.HighPart, (pRplPullOwnerVersNo+i)->VersNo.LowPart);
           }

           LeaveCriticalSection(&RplVersNoStoreCrtSec);
           LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif

           SizeOfBuff = RPLMSGF_ADDVERSMAP_RSP_SIZE_M(MaxNoOfOwners);
           WinsMscAlloc(SizeOfBuff, &pRspBuff);
           fRspBuffAlloc = TRUE;
           /*
            * format the response
           */
           RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        RPLMSGF_E_ADDVERSNO_MAP_RSP,
                        pRspBuff + COMM_N_TCP_HDR_SZ,
                        SizeOfBuff - COMM_N_TCP_HDR_SZ,
                        pPullAddNVersNo,
                        MaxNoOfOwners,
                        0,
                        &RspMsgLen
                           );

           //
           // Free the memory we allocated earlier
           //
           WinsMscDealloc(pPullAddNVersNo);

           /*
            * Send the response.  We don't check the return code.  ECommSndRsp
            * may have failed due to communication failure.  There is nothing
            * more to be done for either the success of failure case.
           */
           (VOID)ECommSndRsp(
                        &pWrkItm->DlgHdl,
                        pRspBuff + COMM_N_TCP_HDR_SZ,
                        RspMsgLen
                   );

           //
           // We don't end the dialogue.  It will get terminated when
           // the initiator terminates it.
           //
        }
        else
        {
                if (!fExc)
                {
                  COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                  DBGPRINT1(RPLPUSH, "HandleAddVersMapReq: Got a pull request message from a WINS to which we are not allowed to push replicas. Address of WINS is (%x)\n",
                   WinsAdd.Add.IPAdd
                        );
                   COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                   WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_ADD_VERS_MAP_REQ_NOT_ACCEPTED,
                                     TRUE);

                }

                //
                // We need to end the dialogue.  The work item and the message
                // will get deallocated by the caller
                //

                //
                // End the implicit dialogue
                //
                (VOID)ECommEndDlg(&pWrkItm->DlgHdl);
        }

   }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleAddVersMapReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
        if (fRspBuffAlloc)
        {
           WinsMscDealloc(pRspBuff);
        }
        DBGLEAVE("HandleAddVersMapReq\n")
        return(WINS_SUCCESS);
}


STATUS
HandleSndEntriesReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function handles the "send data entries req"

Arguments:
        pWrkItm - Work item carrying info about the "Send Entries" request from
                  a remote WINS

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

        RplPushInit()

Side Effects:

Comments:
        None
--*/
{

        COMM_ADD_T             WinsAdd;          /*address of WINS server whose records
                                         *are being requested*/
        VERS_NO_T             MaxVers, MinVers; /*max. amd min. versions of
                                                *records*/
FUTURES("use NMSDB_ROW_INFO_T structure - Maybe")
        PRPL_REC_ENTRY_T     pBuff;
        LPBYTE               pStartBuff = NULL;
        DWORD                RspBufLen;
        DWORD                NoOfRecs = 0;
        DWORD                i;
        LPBYTE               pNewPos;
        LPBYTE               pTxBuff;
        LPBYTE               pStartTxBuff;
        STATUS               RetStat;
        PWINSTHD_TLS_T       pTls;
        BOOL                 fGetDataRecs = FALSE;
        PRPL_CONFIG_REC_T    pPnr;
        BOOL                 fOnlyDynRecs = FALSE;
        DWORD                RplType = WINSCNF_RPL_DEFAULT_TYPE;
        DWORD                RplTypeFMsg;
        BYTE                 Name[1];   //dummy to prevent RtlCopyMemory from
                                        //barfing
       COMM_ADD_T ReqWinsAdd;
#if SUPPORT612WINS > 0
    BOOL        fIsPnrBeta1Wins;
#endif

        DBGENTER("HandleSndEntriesReq\n");
        GET_TLS_M(pTls);
        pTls->HeapHdl = NULL;
//#ifdef WINSDBG
try {
//#endif
        //
        // Check if this is one of our configured partners. If yes,
        // pass the value of fOnlyDynRecs to NmsDbGetDataRecs.
        //
        // We allow access to even those WINSs that are not partners since
        // we need to let them do revalidation of replicas (except for
        // this replication activity, all other from non-configured partners
        // is stopped at the first step - HandleAddVersMapReq).
        //
        if ((pPnr = RplGetConfigRec(RPL_E_PUSH, &pWrkItm->DlgHdl, NULL)) != NULL)
        {
                 fOnlyDynRecs = pPnr->fOnlyDynRecs;
                 RplType      = pPnr->RplType;
        }

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif
         /*
        *  Unformat the request message
        */
        RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pWrkItm->pMsg + 4, /*past the
                                                    *opcode  */
                                 &WinsAdd,
                                &MaxVers,
                                &MinVers,
                                &RplTypeFMsg
                            );
//        ASSERTMSG("Min. Vers. No is >= Max. Vers. No", LiGeq(MaxVers, MinVers));

FUTURES("Check if the request is a PULL RANGE request.  If it is, honor it")
FUTURES("only if the Requesting WINS is under the PUSH key or RplOnlyWCnfPnrs")
FUTURES("is set to 0")

       COMM_INIT_ADD_FR_DLG_HDL_M(&ReqWinsAdd, &pWrkItm->DlgHdl);

#ifdef WINSDBG
       DBGPRINT2(TMP, "HandleSndEntriesReq: WINS (%x) made a SndEntries request for Owner = (%x) \n", ReqWinsAdd.Add.IPAdd, WinsAdd.Add.IPAdd);
       DBGPRINT4(TMP, "HandleSndEntriesReq: Min Vers No (%d %d); Max Vers No = (%d %d)\n", MinVers.HighPart, MinVers.LowPart, MaxVers.HighPart, MaxVers.LowPart);
#endif
        if (RplType == WINSCNF_RPL_DEFAULT_TYPE)
        {
               DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: Pnr (%x) is requesting replication of type (%x)\n", ReqWinsAdd.Add.IPAdd, RplTypeFMsg);
//               WINSEVT_LOG_INFO_M(ReqWinsAdd.Add.IPAdd, WINS_EVT_PNR_PARTIAL_RPL_TYPE);
               RplType = RplTypeFMsg;
        }

        /*
        *
        * Call database manager function to get the records. No need
        * to check the return status here
        */
        (VOID)NmsDbGetDataRecs(
                          WINS_E_RPLPUSH,
                          THREAD_PRIORITY_NORMAL, //not looked at
                          MinVers,
                          MaxVers,
                          0,                //not of use here
                          LiEqlZero(MaxVers) ? TRUE : FALSE, //if max. vers.
                                                               //no. is zero,
                                                               //we want all
                                                               //recs.
                          FALSE,        //not looked at in this call
                          NULL,                //must be NULL since we are not
                                        //doing scavenging of clutter
                          &WinsAdd,
                          fOnlyDynRecs,
                          RplType,
                          (LPVOID *)&pStartBuff,
                          &RspBufLen,
                          &NoOfRecs
                        );
        fGetDataRecs = TRUE;
        //
        // Allocate a buffer for transmitting the records.  Even if the
        // above function failed, we still should have received a buffer
        // from it (pStartBuff). Note: RspBufLen contains the size of memory
        // required for a flattened stream of records.
        //
        pStartTxBuff = WinsMscHeapAlloc(pTls->HeapHdl, RspBufLen);
        pTxBuff      = pStartTxBuff + COMM_N_TCP_HDR_SZ;

        pBuff        = (PRPL_REC_ENTRY_T)pStartBuff;

        DBGPRINT4(RPLPUSH, "Formatting 1st record for sending --name (%s)\nfGrp (%d)\nVersNo (%d %d)\n", pBuff->pName/*pBuff->Name*/,
                    pBuff->fGrp,
                    pBuff->VersNo.HighPart,
                    pBuff->VersNo.LowPart
                );

        /*
        * format the response
        *
        *  Note:  It is quite possible that NmsDbGetDataRecs retrieved 0
        *          records.  Even if it did, we are still assured of getting
        *          a buffer of the RPL_CONFIG_REC_SIZE size.  Since at the
        *          time of allocation, memory is 'zero'ed by default, we
        *          won't run into any problems in the following function
        *          call.  Check out this function to reassure yourself.
        *
        *         Like mentioned in NmsDbGetDataRecs, the following call
        *          will serve to format a valid response to the remote WINS
        */
        RplMsgfFrmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pTxBuff,
                                NoOfRecs,
NOTE("expedient HACK - for now. Later on modify FrmSndEntriesRsp ")
                                NoOfRecs ? pBuff->pName : Name,
                                pBuff->NameLen,
                                pBuff->fGrp,
                                pBuff->NoOfAdds,
                                pBuff->NodeAdd,
                                pBuff->Flag,
                                pBuff->VersNo,
                                TRUE,                         /*First time*/
                                &pNewPos
                           );


PERF("Change RplFrmSndEntriesRsp so that it does the looping itself")
          for (i = 1; i < NoOfRecs; i++)
          {

             pBuff = (PRPL_REC_ENTRY_T)((LPBYTE)pBuff + RPL_REC_ENTRY_SIZE);

//             DBGPRINT4(RPLPUSH, "Formatting record for sending --name (%s)\nfGrp (%d)\nVersNo (%d %d)\n", pBuff->pName/*pBuff->Name*/, pBuff->fGrp, pBuff->VersNo.HighPart, pBuff->VersNo.LowPart);

             /*
             *  Format the response
             */
             RplMsgfFrmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pNewPos,
                                NoOfRecs,                //not used by func
                                pBuff->pName,
                                pBuff->NameLen,
                                pBuff->fGrp,
                                pBuff->NoOfAdds,
                                pBuff->NodeAdd,
                                pBuff->Flag,
                                pBuff->VersNo,
                                FALSE, /*Not First time*/
                                &pNewPos
                                );


        }

       RspBufLen = (ULONG) (pNewPos - pTxBuff);

       /*
        * Call ECommSndRsp to send the response.
       */
       RetStat = ECommSndRsp(
                    &pWrkItm->DlgHdl,
                    pTxBuff,
                    RspBufLen
                    );

#ifdef WINSDBG
{
//        COMM_IP_ADD_T IPAdd;

        struct in_addr InAdd;
 //       COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &IPAdd);
        InAdd.s_addr = htonl(ReqWinsAdd.Add.IPAdd);

        if (RetStat != WINS_SUCCESS)
        {
                 DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: ERROR: Could not send (%d) records to WINS with address = (%s)\n",
                                NoOfRecs,
                                inet_ntoa(InAdd)
                 );
        }
        else
        {
                 DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: Sent (%d) records to WINS with address = (%s)\n",
                                NoOfRecs,
                                inet_ntoa(InAdd)
                         );
        }
}
#endif

//#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleSndEntriesReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
      } //end of exception handler
//#endif
        if (fGetDataRecs)
        {
           //
           //  Free the buffer, allocated by NmsDbGetDataRecs and the Tx Buff
           //
           //   The work item and the message it holds are freed by the caller
           //
           pBuff        = (PRPL_REC_ENTRY_T)pStartBuff;
           for (i=0; i<NoOfRecs; i++)
           {
             DWORD EntType;
             if (pBuff->pName != NULL)
             {
                    WinsMscHeapFree(pTls->HeapHdl, pBuff->pName);
             }
             EntType = NMSDB_ENTRY_TYPE_M(pBuff->Flag);

             if (((EntType == NMSDB_SPEC_GRP_ENTRY) || (EntType == NMSDB_MULTIHOMED_ENTRY)) && (pBuff->pNodeAdd != NULL))
             {
                    WinsMscHeapFree(pTls->HeapHdl, pBuff->pNodeAdd);
             }
             pBuff = (PRPL_REC_ENTRY_T)((LPBYTE)pBuff + RPL_REC_ENTRY_SIZE);
           }
           WinsMscHeapFree(pTls->HeapHdl, pStartBuff);
           WinsMscHeapFree(pTls->HeapHdl, pStartTxBuff);
           WinsMscHeapDestroy(pTls->HeapHdl);
        }
        DBGLEAVE("HandleSndEntriesReq\n");
        return(WINS_SUCCESS);
}


VOID
HandleUpdNtf(
#if PRSCONN
        BOOL                          fPrsConn,
#endif
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to handle an update notification message
        received from a remote WINS

Arguments:
        fPrsConn - Indicates whether the connection is persistent or not
        pWrkItm - Work Item containing the message and other relevant info

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPushInit()

Side Effects:

Comments:
        None
--*/

{
        PRPL_CONFIG_REC_T        pPnr;
        COMM_ADD_T                WinsAdd;
        BOOL                        fRplPnr = FALSE;
        BOOL                        fExc    = FALSE;
        struct        in_addr                InAddr;
        DWORD         RplType;


        DBGENTER("HandleUpdNtf - PUSH thread\n");

        //
        // We need to forward this request to the PULL thread only if
        // either the WINS that sent this notification is one of our
        // push pnrs or if the fRplOnlyWCnfPnrs in the registry is FALSE
        //
FUTURES("user RplGetConfigRec instead of the following code")

        EnterCriticalSection(&WinsCnfCnfCrtSec);
   try {
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
              if ((pPnr = WinsCnf.PullInfo.pPullCnfRecs) != NULL)
              {
                 COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == WinsAdd.Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        RplType = pPnr->RplType;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
              }
        }
        else
        {
                fRplPnr     = TRUE;
                RplType     = WinsCnf.PullInfo.RplType;
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("HandleUpdNtf");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PUSH_TRIG_PROC);
                fExc = TRUE;
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
#ifdef WINSDBG
try {
#endif
        if (fRplPnr)
        {
            //
            // Inform the TCP listener thread that it should stop
            // monitoring the dialogue since we are handing it over to
            // the PULL thread
            //
#if PRSCONN
            if (!fPrsConn)
#endif
            {
              if (!ECommProcessDlg(&pWrkItm->DlgHdl, COMM_E_NTF_STOP_MON))
              {

                //
                // Free the buffer
                //
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);
                DBGPRINT0(ERR, "HandleUpdNtf - PUSH thread. No Upd Ntf could be sent.  It could be because the link went down\n");
                return;
              }
              else
              {
                     COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                     COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                     WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_UPD_NTF_ACCEPTED, TRUE);
              }
            }

            //
            // Forward the request to the Pull thread
            //
            ERplInsertQue(
                WINS_E_RPLPUSH,
                QUE_E_CMD_HDL_PUSH_NTF,
                &pWrkItm->DlgHdl,
                pWrkItm->pMsg,                //msg containing the push ntf
                pWrkItm->MsgLen,        //msg length
                ULongToPtr(RplType),    //context to pass
                0                       //no magic no
                     );

           //
           // The Pull thread will now terminate the dlg
           //
        }
        else  //we need to reject this trigger
        {
                if (!fExc)
                {
                   COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                   DBGPRINT1(RPLPUSH, "HandleUpdNtf: Got a push trigger from a WINS with which we are not allowed to pull replicas. Address of WINS is (%d)\n",
                   WinsAdd.Add.IPAdd
                        );

                   COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                   WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_UPD_NTF_NOT_ACCEPTED, TRUE);
                }

                //
                // We need to first deallocate the message and then end the
                // dialogue.  The work item will get deallocated by the caller
                //

                //
                // Free the buffer
                //
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);

                //
                // End the implicit dialogue
                //
                (VOID)ECommEndDlg(&pWrkItm->DlgHdl);
        }

#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleUpdNtf");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
#endif

        DBGLEAVE("HandleUpdNtf - PUSH thread\n");
        return;
}

VOID
HandleUpdVersNoReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to handle an update version number
        request received from a remote WINS

        This message is sent by a remote WINS as a result of a clash
        during replication.

Arguments:
        pWrkItm - work item

Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        RplPushInit()

Side Effects:

Comments:
        None
--*/

{
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD                NameLen;
        BYTE                Rcode;
        DWORD                RspBuffLen;
        BYTE                RspBuff[RPLMSGF_UPDVERSNO_RSP_SIZE];
        COMM_ADD_T      WinsAdd;
        struct in_addr  InAddr;

        DBGENTER("HandleUpdVerdNoReq\n");

#ifdef WINSDBG
try {
#endif
        //
        // log an event
        //
        COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &WinsAdd.Add.IPAdd);
        COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);
        WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr), WINS_EVT_REM_WINS_INF, TRUE);

        /*
        *  Unformat the request message
        */
        RplMsgfUfmUpdVersNoReq(
                                pWrkItm->pMsg + 4, /*past the
                                                    *opcode  */
                                Name,
                                &NameLen
                                );

        //
        // handle the request
        //
        NmsNmhUpdVersNo( Name, NameLen, &Rcode, &WinsAdd );


        //
        //Format the response
        //
        RplMsgfFrmUpdVersNoRsp(
                        RspBuff + COMM_N_TCP_HDR_SZ,
                        Rcode,
                        &RspBuffLen
                              );

        //
        // Send the response. No need to check the return code.
        //
        (VOID)ECommSndRsp(
                        &pWrkItm->DlgHdl,
                        RspBuff + COMM_N_TCP_HDR_SZ,
                        RspBuffLen
                   );

        //
        // No need to end the dialogue.  The initiator of the dlg will end it.
        //
#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleUpdVersNoReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
#endif

        DBGLEAVE("HandleUpdVerdNoReq\n");
        return;

} // HandleUpdVersNoReq()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\cluster.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 cluster.cpp
//
// Module:	 WLBS API
//
// Description: Implement class CWlbsCluster
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:	 Created    3/9/00
//
//+----------------------------------------------------------------------------
#include "precomp.h"

#include <debug.h>
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "cluster.tmh" // For event tracing


CWlbsCluster::CWlbsCluster(DWORD dwConfigIndex)
{
    m_reload_required = FALSE;
    m_mac_addr_change = FALSE;
    m_this_cl_addr    = 0;
    m_this_host_id  = 0;
    m_this_ded_addr   = 0;
    m_dwConfigIndex = dwConfigIndex;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::ReadConfig
//
// Description:  Read cluster settings from registry
//
// Arguments: PWLBS_REG_PARAMS reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::ReadConfig(PWLBS_REG_PARAMS reg_data)
{
    if (ParamReadReg(m_AdapterGuid, reg_data) == false)
    {
        return WLBS_REG_ERROR;
    }

    /* create a copy in the old_params structure. this will be required to
     * determine whether a reload is needed or a reboot is needed for commit */

    memcpy ( &m_reg_params, reg_data, sizeof (WLBS_REG_PARAMS));

//    m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);
    
    return WLBS_OK;
} 





//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::GetClusterIpOrIndex
//
// Description:  Get the index or IP of the cluster.  If the cluster IP is non-zero
//              The IP is return.
//              If the cluster IP is 0, the index is returned
//
// Arguments: CWlbsControl* pControl - 
//
// Returns:   DWORD - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::GetClusterIpOrIndex(CWlbsControl* pControl)
{
    DWORD dwIp = CWlbsCluster::GetClusterIp();

    if (dwIp!=0)
    {
        //
        // Return the cluster IP if non 0
        //
        return dwIp;
    }

    if (pControl->GetClusterNum() == 1)
    {
        //
        // For backward compatibility, return 0 if only one cluster exists
        //

        return 0;
    }

    //
    // Ip address is in the reverse order
    //
    return (CWlbsCluster::m_dwConfigIndex) <<24;
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::WriteConfig
//
// Description:  Write cluster settings to registry
//
// Arguments: WLBS_REG_PARAMS* reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::WriteConfig(WLBS_REG_PARAMS* reg_data)
{
    if (memcmp (&m_reg_params, reg_data, sizeof (WLBS_REG_PARAMS)) == 0)
    {
        //
        // No changes
        //

        return WLBS_OK;
    }

    if (ParamWriteReg(m_AdapterGuid, reg_data) == false)
    {
        return WLBS_REG_ERROR;
    }

    /* No errors so far, so set the global flags reload_required and reboot_required
     * depending on which fields have been changed between reg_data and old_params.
     */

    m_reload_required = TRUE;

    /* Reboot is required if multicast_support option is changed or
     * if the user specifies a different mac address
     */

    /* Reboot required is set to TRUE whenever cl_mac_address changes. Will be modified later ##### */
    
    if (m_reg_params.mcast_support != reg_data->mcast_support || _tcsicmp(m_reg_params.cl_mac_addr, reg_data->cl_mac_addr) != 0) {
        m_mac_addr_change = true;
    
        //
        //  if m_reg_params -> mcast_support then remove mac addr, otherwise write mac addr
        //
        if (RegChangeNetworkAddress (m_AdapterGuid, reg_data->cl_mac_addr, reg_data->mcast_support) == false) {
            LOG_ERROR("CWlbsCluster::WriteConfig failed at RegChangeNetworkAddress");
        }
    }

    /* Write the changes to the structure old_values
     * This copying is done only after all the data has been written into the registry
     * Otherwise, the structure old_values would retain the previous values.
     */

    memcpy(&m_reg_params, reg_data, sizeof (WLBS_REG_PARAMS));

    return WLBS_OK;
} 







//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::CommitChanges
//
// Description:  Notify wlbs driver or nic driver to pick up the changes
//
// Arguments: CWlbsControl* pWlbsControl - 
//
// Returns:   DWORD - 
//
// History: fengsun  Created Header    7/6/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::CommitChanges(CWlbsControl* pWlbsControl)
{

    ASSERT(pWlbsControl);
    HANDLE hDeviceWlbs = pWlbsControl->GetDriverHandle();
    
    // Read the cluster IP address and the dedicated IP address from the
    // registry and update the global variables.
    // Always update the cluster IP address and the dedicated IP address
    RegReadAdapterIp(m_AdapterGuid, m_this_cl_addr, m_this_ded_addr);

    /* Check if the driver requires a reload or not. If not, then simply return */
    if (m_reload_required == FALSE)
    {
        return WLBS_OK;
    }

    NotifyDriverConfigChanges(hDeviceWlbs, m_AdapterGuid);

    LONG                status;

    IOCTL_CVY_BUF       in_buf;
    IOCTL_CVY_BUF       out_buf;
    status = WlbsLocalControl (hDeviceWlbs, m_AdapterGuid, IOCTL_CVY_RELOAD, & in_buf, & out_buf, 0);

    if (status == WLBS_IO_ERROR)
    {
        return status;
    }

    if (out_buf . ret_code == IOCTL_CVY_BAD_PARAMS)
    {
        return WLBS_BAD_PARAMS;
    }

    m_reload_required = FALSE; /* reset the flag */

    if (m_mac_addr_change)
    {
        m_mac_addr_change = false;
        
        /* The NIC card name for the cluster. */
        WCHAR driver_name[CVY_STR_SIZE];
        ZeroMemory(driver_name, sizeof(driver_name));

        /* Get the driver name from the GUID. */
        GetDriverNameFromGUID(m_AdapterGuid, driver_name, CVY_STR_SIZE);

        /* When the MAC address changes, disable and re-enable the adapter as well as notify 
           the adapter that the MAC address has changed.  There is no need to make sure that 
           the adapter is initially enabled because disabled adapters are invisible here. */
        NotifyAdapterPropertyChange(driver_name, DICS_DISABLE);
        NotifyAdapterPropertyChange(driver_name, DICS_PROPCHANGE);
        NotifyAdapterPropertyChange(driver_name, DICS_ENABLE);
    }

    return WLBS_OK;
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::Initialize
//
// Description:  Initialization
//
// Arguments: const GUID& AdapterGuid - 
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool CWlbsCluster::Initialize(const GUID& AdapterGuid)
{
    m_AdapterGuid = AdapterGuid;
    m_mac_addr_change = false;
    m_reload_required = false;

    ZeroMemory (& m_reg_params, sizeof (m_reg_params));

    ParamReadReg(m_AdapterGuid, &m_reg_params);  

    m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);\
    m_this_host_id = m_reg_params.host_priority;
    
    return true;
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::ReInitialize
//
// Description:  Reload settings from registry
//
// Arguments: 
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool CWlbsCluster::ReInitialize()
{
    if (ParamReadReg(m_AdapterGuid, &m_reg_params) == false)
    {
        return false;
    }

    //
    // Do not change the ClusterIP if the changes has not been commited
    //
    if (!IsCommitPending())
    {
        m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
        m_this_host_id = m_reg_params.host_priority;
    }
    
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);
    
    return true;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::GetPassword
//
// Description:  Get remote control password for this cluster
//
// Arguments: 
//
// Returns:   DWORD - password
//
// History:   fengsun Created Header    2/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::GetPassword()
{
    HKEY  key = NULL;
    LONG  status;
    DWORD dwRctPassword = 0;


    key = RegOpenWlbsSetting(m_AdapterGuid, true);
    
    DWORD size = sizeof(dwRctPassword);
    status = RegQueryValueEx (key, CVY_NAME_RCT_PASSWORD, 0L, NULL,
                              (LPBYTE) & dwRctPassword, & size);

    if (status != ERROR_SUCCESS)
        dwRctPassword = CVY_DEF_RCT_PASSWORD;

    RegCloseKey(key);

    return dwRctPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\license.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    license.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Code to encrypt/decrypt passwords and port rules.

Author:

    kyrilf

History:

    JosephJ 11/22/00 Gutted this file and folded in three constants from
                the now defunct license.h. Basically the functions in this
                file used to do lots of things but now only encrypt/decrypt
                port rules and passwords. The port rules stuff is only used
                for upgrading from olde versions of wlbs so that may go away
                as well.

        This file is located in two places:
            WLBS netconfig code -- net\config\netcfg\wlbscfg
            WLBS API code -- net\wlbs\api

        Because this involves password encryption, we don't want to make
        the functions callable via a DLL entrypoint, and setting up
        a static library to be shared between netconfig and api stuff is
        not trivial and overkill because the two trees are far apart.
        
--*/
#include <precomp.h>


/* CONSTANTS */


static UCHAR    data_key [] =
                            { 0x3f, 0xba, 0x6e, 0xf0, 0xe1, 0x44, 0x1b, 0x45,
                              0x41, 0xc4, 0x9f, 0xfb, 0x46, 0x54, 0xbc, 0x43 };

static UCHAR    str_key [] =

                           { 0xdb, 0x1b, 0xac, 0x1a, 0xb9, 0xb1, 0x18, 0x03,
                             0x55, 0x57, 0x4a, 0x62, 0x36, 0x21, 0x7c, 0xa6 };


/* Encryption and decryption routines are based on a public-domain Tiny
   Encryption Algorithm (TEA) by David Wheeler and Roger Needham at the
   Computer Laboratory of Cambridge University. For reference, please
   consult http://vader.brad.ac.uk/tea/tea.shtml */


static VOID License_decipher (
    PULONG              v,
    PULONG              k)
{
   ULONG                y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0xC6EF3720,
                        delta = 0x9E3779B9;

    /* sum = delta<<5, in general sum = delta * n */

    while (n-- > 0)
    {
        z -= (y << 4) + c ^ y + sum ^ (y >> 5) + d;
        y -= (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        sum -= delta;
    }

    v [0] = y; v [1] = z;

} /* end License_decipher */


static VOID License_encipher (
    PULONG              v,
    PULONG              k)
{
    ULONG               y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0,
                        delta = 0x9E3779B9;

    while (n-- > 0)
    {
        sum += delta;
        y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;
    }

    v [0] = y; v [1] = z;

} /* end License_encipher */



BOOL License_data_decode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_decipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_decode */


ULONG License_string_encode (
    PCHAR               str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_string_encode */

ULONG License_wstring_encode (
    PWCHAR              str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = (UCHAR)str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_wstring_encode */


BOOL License_data_encode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_encipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_encode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\cluster.h ===
#ifndef WLBSCLUSTER_H
#define WLBSCLUSTER_H

#include "wlbsconfig.h"


class CWlbsControl;

//+----------------------------------------------------------------------------
//
// class CWlbsCluster
//
// Description:  This class is exported to perform cluster configuration,
//
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------

class __declspec(dllexport) CWlbsCluster
{
public:
    CWlbsCluster(DWORD dwConfigIndex);

    DWORD GetClusterIp() {return m_this_cl_addr;} 
    DWORD GetHostID() {return m_this_host_id;}
    DWORD GetDedicatedIp() {return m_this_ded_addr;}

    bool Initialize(const GUID& AdapterGuid);
    bool ReInitialize();

    DWORD ReadConfig(PWLBS_REG_PARAMS reg_data);   // read the config from registry
    DWORD WriteConfig(const PWLBS_REG_PARAMS reg_data);

    DWORD CommitChanges(CWlbsControl* pWlbsControl);
    bool  IsCommitPending() const {return m_reload_required;}  // whether changes are commited

    const GUID& GetAdapterGuid() { return m_AdapterGuid;}

    DWORD GetPassword();

    DWORD GetClusterIpOrIndex(CWlbsControl* pControl);

public:
    DWORD m_dwConfigIndex; // unique index for the cluster

protected:
	// Cluser IP of this adapter. Reflect the value in driver instead of registry.  
	// The value does not change, if WriteConfig is called but Commint is not called.
	// See bug 162812 162854
    DWORD        m_this_cl_addr;   
    
    DWORD        m_this_host_id; // Host ID of the cluster.  Reflect the value in driver instead of registry
    DWORD        m_this_ded_addr;  // Dedicated IP of this adapter
    
    WLBS_REG_PARAMS  m_reg_params; // original settings

    GUID		 m_AdapterGuid;

    bool         m_mac_addr_change;  // whether we need to reload the nic driver
    bool         m_reload_required;  // set if change in registry need to be picked by wlbs driver
};

#endif // WLBSCLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\control.h ===
#ifndef WLBSCONTROL_H
#define WLBSCONTROL_H

#include "cluster.h"

class CWlbsCluster;

//+----------------------------------------------------------------------------
//
// class CWlbsControl
//
// Description:  This class is exported to perform cluster control operation,
//               as well as get Cluster objects
//
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
class __declspec(dllexport) CWlbsControl
{
friend DWORD WINAPI WlbsCommitChanges(DWORD cluster);

public:
    CWlbsControl();
    ~CWlbsControl();
    DWORD Initialize();
    bool  ReInitialize();


    DWORD WlbsQuery(CWlbsCluster* pCluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        PDWORD           host_map,
        PVOID            reserved);

    DWORD WlbsQuery(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        PDWORD           host_map,
        PVOID            reserved);

    DWORD WlbsSuspend(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsResume(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsStart(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsStop(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsDrainStop(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsEnable(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    DWORD WlbsDisable(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    DWORD WlbsDrain(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    DWORD WlbsAdjust(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            port,
        DWORD            value);

    //
    // Set remote control parameters
    //
    void WlbsPortSet(DWORD cluster, WORD port);
    void WlbsPasswordSet(DWORD cluster, const WCHAR* password);
    void WlbsCodeSet(DWORD cluster, DWORD passw);
    void WlbsDestinationSet(DWORD cluster, DWORD dest);
    void WlbsTimeoutSet(DWORD cluster, DWORD milliseconds);

    DWORD EnumClusters(OUT DWORD* pdwAddresses, IN OUT DWORD* pdwNum); // for API wrapper
	DWORD GetClusterNum() { return m_dwNumCluster;}
    DWORD EnumClusterObjects(OUT CWlbsCluster** &ppClusters, OUT DWORD* pdwNum);

    CWlbsCluster* GetClusterFromIp(DWORD dwClusterIp);
    CWlbsCluster* GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex);


    HANDLE GetDriverHandle() {return m_hdl;}


	//
	// GetClusterFromAdapter looks up an adapter based on its GUID.
	//
    CWlbsCluster*
    GetClusterFromAdapter(
    	IN const GUID &AdapterGuid
    	);

	//
	// ValidateParam validates and fixes up the specified parameters structure. It has no side effects other than changing some
	// fields within paramp, such as IP addresses which may be reformatted into canonical form.
	//
	BOOL
	ValidateParam(
		IN OUT PWLBS_REG_PARAMS paramp
		);

	//
	// Performs local cluster-wide control operations on the specified GUID. 
	//
   DWORD LocalClusterControl(
   		IN const GUID& AdapterGuid,
		IN LONG    ioctl
        );
   

    BOOLEAN IsClusterMember (DWORD dwClusterIp);

protected:
    struct WLBS_CLUSTER_PARAMS
    {
        DWORD           cluster;
        DWORD           passw;
        DWORD           timeout;
        DWORD           dest;
        WORD            port;
        WORD            valid;
    };

    enum { WLBS_MAX_CLUSTERS = 128};
    WLBS_CLUSTER_PARAMS m_cluster_params [WLBS_MAX_CLUSTERS]; // Cluster settings for remote control

    BOOL         m_init_once;    // whether WlbsInit is called
    BOOL         m_remote_ctrl;  // Whether remote operation can be performed on this machine
    BOOL         m_local_ctrl;   // Whether local operation can be performed on this machine
    HANDLE       m_hdl;          // handle to the device object
//    HANDLE       lock;         // An mutex
    DWORD        m_def_dst_addr;   // Default destination address for all clusters, set by WlbsDestinationSet
    DWORD        m_def_timeout;// Time out value for remote control
    WORD         m_def_port;           // UDP port for remote control
    DWORD        m_def_passw;  // Default password for remote control
    HANDLE       m_registry_lock; // used for mutually exclusive access to the registry, should use named lock 
    DWORD        m_dwSrcAddress;  // address of this machine, used by remote control packet
    DWORD m_dwNumCluster;       // number of clusters on this host

    CWlbsCluster* m_pClusterArray[WLBS_MAX_CLUSTERS];  // an array of all clusters
    
    DWORD GetInitResult()
    {
        if (m_local_ctrl && m_remote_ctrl)
            return WLBS_PRESENT;
        if (m_local_ctrl)
            return WLBS_LOCAL_ONLY;
        else if (m_remote_ctrl)
            return WLBS_REMOTE_ONLY;
        else
            return WLBS_INIT_ERROR;
    };

	bool IsInitialized() const {return m_hdl != INVALID_HANDLE_VALUE;}
	
    DWORD RemoteQuery(DWORD cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        PDWORD           host_map);
        
    DWORD WlbsRemoteControl(LONG             ioctl,
                    PIOCTL_CVY_BUF   pin_bufp,
                    PIOCTL_CVY_BUF   pout_bufp,
                    PWLBS_RESPONSE   pcvy_resp,
                    PDWORD           nump,
                    DWORD            trg_addr,
                    DWORD            hst_addr,
                    DWORD            vip);
    

};


DWORD WlbsLocalControl(HANDLE hDevice, const GUID& AdapterGuid,
						LONG ioctl, PIOCTL_CVY_BUF in_bufp, 
                                 PIOCTL_CVY_BUF out_bufp, DWORD vip);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\control.cpp ===
//+----------------------------------------------------------------------------
//
// File:         control.cpp
//
// Module:       
//
// Description: Implement class CWlbsControl
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       Created    3/2/00
//
//+----------------------------------------------------------------------------

#include "precomp.h"

#include <debug.h>
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "control.tmh" // for event tracing


//
// Global variable for the dll instance
//
HINSTANCE g_hInstCtrl;

//
// Helper functions
//
DWORD MapStateFromDriverToApi(DWORD dwDriverState);

//+----------------------------------------------------------------------------
//
// Function:  IsLocalHost
//
// Description:  
//
// Arguments: CWlbsCluster* pCluster - 
//            DWORD dwHostID - 
//
// Returns:   inline bool - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
inline bool IsLocalHost(CWlbsCluster* pCluster, DWORD dwHostID)
{
    if (pCluster == NULL)
    {
        return false;
    }

    return dwHostID == WLBS_LOCAL_HOST; // || pCluster->GetHostID() == dwHostID;
}


//+----------------------------------------------------------------------------
//
// Function:  QueryPortFromSocket
//
// Synopsis:  
//    This routine retrieves the port number to which a socket is bound.
//
// Arguments:
//    Socket - the socket to be queried
//
// Return Value:
//    USHORT - the port number retrieved
//
// History:   Created Header    2/10/99
//
//+----------------------------------------------------------------------------
static USHORT QueryPortFromSocket(SOCKET Socket)
{
    SOCKADDR_IN Address;
    int AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, &AddressLength);
    return Address.sin_port;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::CWlbsControl
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
CWlbsControl::CWlbsControl()
{
    m_local_ctrl      = FALSE;
    m_remote_ctrl     = FALSE;
    m_hdl             = INVALID_HANDLE_VALUE;
    m_registry_lock   = INVALID_HANDLE_VALUE;
    m_def_dst_addr    = 0;
    m_def_timeout     = IOCTL_REMOTE_RECV_DELAY;
    m_def_port        = CVY_DEF_RCT_PORT;
    m_def_passw       = CVY_DEF_RCT_PASSWORD;

    m_dwNumCluster = 0;

    for (int i = 0; i < WLBS_MAX_CLUSTERS; i ++)
    {
        m_cluster_params [i] . cluster = 0;
        m_cluster_params [i] . passw   = CVY_DEF_RCT_PASSWORD;
        m_cluster_params [i] . timeout = IOCTL_REMOTE_RECV_DELAY;
        m_cluster_params [i] . port    = CVY_DEF_RCT_PORT;
        m_cluster_params [i] . dest    = 0;
    }

    ZeroMemory(m_pClusterArray, sizeof(m_pClusterArray));
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::~CWlbsControl
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
CWlbsControl::~CWlbsControl()
{
        for (DWORD i=0; i< m_dwNumCluster; i++)
        {
                delete m_pClusterArray[i];
        }
        
    if (m_hdl)
    {
        CloseHandle(m_hdl);
    }

    if (m_remote_ctrl) 
    {
        WSACleanup();  // WSAStartup is called in Initialize()
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::Initialize
//
// Description:  Initialization
//
// Arguments: None
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::Initialize()
{
    WORD            ver;
    int             ret;

    if (IsInitialized())
    {
        ReInitialize();
        return GetInitResult();
    }
    
    _tsetlocale (LC_ALL, _TEXT(".OCP"));


    /* open Winsock */

    WSADATA         data;

	if (WSAStartup (WINSOCK_VERSION, & data) == 0)
	{
	    /* figure out client IP address */
        CHAR buf [CVY_STR_SIZE];

        ret = gethostname (buf, CVY_STR_SIZE);

        if (ret != SOCKET_ERROR)
        {
            struct hostent *  host;
            host = gethostbyname (buf);

            m_dwSrcAddress = 0;

            if ( host && ((struct in_addr *) (host -> h_addr)) -> s_addr != 0)
            {
                m_remote_ctrl = TRUE;
                m_dwSrcAddress = ((struct in_addr *) (host -> h_addr)) -> s_addr;
            }
        }

        if (!m_remote_ctrl)
        {
            LOG_ERROR1("CWlbsControl::Initialize failed. gethostname return %d", ret);
            WSACleanup();
        }
    }


    /* if succeeded querying local parameters - connect to device */

    if (m_hdl != INVALID_HANDLE_VALUE)
        CloseHandle (m_hdl);

    m_hdl = CreateFile (_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);

    if (m_hdl == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR1("CWlbsControl::Initialize failed to open wlbs device %d", GetLastError());
        return GetInitResult();
    }
    else
    {
        m_local_ctrl = TRUE;
    }

    //
    // enumerate clusters
    //

    HKEY hKeyWlbs;
    DWORD dwError;
    
    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                            L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface",
                            0L, KEY_READ, & hKeyWlbs);

    if (dwError != ERROR_SUCCESS)
    {
        return GetInitResult();
    }

    m_dwNumCluster = 0;

    for (int index=0;;index++)
    {
        WCHAR szAdapterGuid[128];
        DWORD dwSize = sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]);
        
        dwError = RegEnumKeyEx(hKeyWlbs, index, 
                        szAdapterGuid, &dwSize,
                        NULL, NULL, NULL, NULL);

        if (dwError != ERROR_SUCCESS)
        {
            if (dwError != ERROR_NO_MORE_ITEMS)
            {
                LOG_ERROR1("CWlbsControl::Initialize failed at RegEnumKeyEx %d", dwError);
            }
            break;
        }

        GUID AdapterGuid;
        HRESULT hr = CLSIDFromString(szAdapterGuid, &AdapterGuid);

        if (FAILED(hr))
        {
            LOG_ERROR1("CWlbsControl::Initialize failed at CLSIDFromString %s", szAdapterGuid);
            continue;
        }

        IOCTL_CVY_BUF    in_buf;
        IOCTL_CVY_BUF    out_buf;

        DWORD status = WlbsLocalControl (m_hdl, AdapterGuid,
            IOCTL_CVY_QUERY, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
        {
            continue;
        }
        
        //
        // Use index instead of m_dwNumCluster as the cluster index
        // m_dwNumCluster will change is a adapter get unbound.
        // index will change only if an adapter get removed
        //
        m_pClusterArray[m_dwNumCluster] = new CWlbsCluster(index);
        
        if (m_pClusterArray[m_dwNumCluster] == NULL)
        {
            LOG_ERROR("CWlbsControl::Initialize failed to allocate memory");
            ASSERT(m_pClusterArray[m_dwNumCluster]);
        }
        else
        {
            m_pClusterArray[m_dwNumCluster]->Initialize(AdapterGuid);
            m_dwNumCluster++;
        }
    }

    RegCloseKey(hKeyWlbs);
    
    return GetInitResult();

} 



//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::ReInitialize
//
// Description:  Re-Initialization to get the current cluster list
//
// Arguments: None
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
bool CWlbsControl::ReInitialize()
{
    ASSERT(m_hdl != INVALID_HANDLE_VALUE);

    if ( m_hdl == INVALID_HANDLE_VALUE )
    {
        return false;
    }
    

    HKEY hKeyWlbs;
    DWORD dwError;
    
    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                            L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface",
                            0L, KEY_READ, & hKeyWlbs);

    if (dwError != ERROR_SUCCESS)
    {
        LOG_ERROR("CWlbsControl::Initialize failed at RegOpenKeyEx");
        return false;
    }


    //
    // Re enumerate the clusters
    //
    
    DWORD dwNewNumCluster = 0;   // the number of new clusters
    bool fClusterExists[WLBS_MAX_CLUSTERS];
    CWlbsCluster* NewClusterArray[WLBS_MAX_CLUSTERS];

    for (DWORD i=0;i<m_dwNumCluster;i++)
    {
        fClusterExists[i] = false;
    }

    for (int index=0;;index++)
    {
        WCHAR szAdapterGuid[128];
        DWORD dwSize = sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]);
        
        dwError = RegEnumKeyEx(hKeyWlbs, index, 
                        szAdapterGuid, &dwSize,
                        NULL, NULL, NULL, NULL);

        if (dwError != ERROR_SUCCESS)
        {
            if (dwError != ERROR_NO_MORE_ITEMS)
            {
                LOG_ERROR1("CWlbsControl::Initialize failed at RegEnumKeyEx %d", dwError);
                return false;
            }

            break;
        }

        GUID AdapterGuid;
        HRESULT hr = CLSIDFromString(szAdapterGuid, &AdapterGuid);

        if (FAILED(hr))
        {
            LOG_ERROR1("CWlbsControl::Initialize failed at CLSIDFromString %s", szAdapterGuid);
            continue;
        }

        IOCTL_CVY_BUF    in_buf;
        IOCTL_CVY_BUF    out_buf;

        DWORD status = WlbsLocalControl (m_hdl, AdapterGuid,
            IOCTL_CVY_QUERY, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
        {
            continue;
        }

        //
        // Check if this is a new adapter
        //
        for (DWORD j=0; j<m_dwNumCluster; j++)
        {
            ASSERT(m_pClusterArray[j]);
            
            if (IsEqualGUID(AdapterGuid, m_pClusterArray[j]->GetAdapterGuid()))
            {
                ASSERT(fClusterExists[j] == false);
                
                fClusterExists[j] = true;
                
                //
                // Since adapter could be added or removed, since last time,
                // The index could be changed
                //
                m_pClusterArray[j]->m_dwConfigIndex = index;

                break;
            }
        }

        //
        // It is a new adapter
        //
        if (j == m_dwNumCluster)
        {
            CWlbsCluster* pCluster = new CWlbsCluster(index);

            if (pCluster == NULL)
            {
                LOG_ERROR("CWlbsControl::ReInitialize failed to allocate memory");
                ASSERT(pCluster);
            }
            else
            {
                pCluster->Initialize(AdapterGuid);

                //
                // Add
                //
                NewClusterArray[dwNewNumCluster] = pCluster;
                dwNewNumCluster++;
            }
        }
    }

    RegCloseKey(hKeyWlbs);

    //
    //  Create the new cluster array
    //
    for (i=0; i< m_dwNumCluster; i++)
    {
        if (!fClusterExists[i])
        {
            delete m_pClusterArray[i];
        }
        else
        {
            //
            // Reload settings
            //
            m_pClusterArray[i]->ReInitialize();

            NewClusterArray[dwNewNumCluster] = m_pClusterArray[i];
            dwNewNumCluster++;
        }

        m_pClusterArray[i] = NULL;
    }


    //
    // Copy the array back
    //
    m_dwNumCluster = dwNewNumCluster;
    CopyMemory(m_pClusterArray, NewClusterArray, m_dwNumCluster * sizeof(m_pClusterArray[0]));

    ASSERT(m_pClusterArray[m_dwNumCluster] == NULL);
    
    return true;
} 

//+----------------------------------------------------------------------------
//
// Function:  MapStateFromDriverToApi
//
// Description:  Map the state return from wlbs driver to the API state
//
// Arguments: DWORD dwDriverState - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD MapStateFromDriverToApi(DWORD dwDriverState)
{
    struct STATE_MAP
    {
        DWORD dwDriverState;
        DWORD dwApiState;
    } StateMap[] =
    {  
        {IOCTL_CVY_ALREADY, WLBS_ALREADY},
        {IOCTL_CVY_BAD_PARAMS, WLBS_BAD_PARAMS},
        {IOCTL_CVY_NOT_FOUND, WLBS_NOT_FOUND},
        {IOCTL_CVY_STOPPED, WLBS_STOPPED},
        {IOCTL_CVY_SUSPENDED, WLBS_SUSPENDED},
        {IOCTL_CVY_CONVERGING, WLBS_CONVERGING},
        {IOCTL_CVY_SLAVE, WLBS_CONVERGED},
        {IOCTL_CVY_MASTER, WLBS_DEFAULT},
        {IOCTL_CVY_BAD_PASSWORD, WLBS_BAD_PASSW},
        {IOCTL_CVY_DRAINING, WLBS_DRAINING},
        {IOCTL_CVY_DRAINING_STOPPED, WLBS_DRAIN_STOP},
        {IOCTL_CVY_DISCONNECTED, WLBS_DISCONNECTED},
    };

    for (int i=0; i<sizeof(StateMap) /sizeof(StateMap[0]); i++)
    {
        if (StateMap[i].dwDriverState == dwDriverState)
        {
            return StateMap[i].dwApiState;
        }
    }

    //
    // Default
    //
    return WLBS_OK;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::GetClusterFromIp
//
// Description:  Get the cluster object from IP
//
// Arguments: DWORD dwClusterIp - 
//
// Returns:   CWlbsCluster* - Caller can NOT free the return object 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
inline 
CWlbsCluster* CWlbsControl::GetClusterFromIp(DWORD dwClusterIp)
{
        for (DWORD i=0; i< m_dwNumCluster; i++)
        {
                if(m_pClusterArray[i]->GetClusterIp() == dwClusterIp)
                {
                        return m_pClusterArray[i];
                }
        }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::GetClusterFromAdapter
//
// Description:  Get the cluster object from adapter guid
//
// Arguments: GUID *pAdapterGuid -- GUID of the adapter. 
//
// Returns:   CWlbsCluster* - Caller can NOT free the return object 
//
// History:   JosephJ Created 4/20/01
//
//+----------------------------------------------------------------------------
inline 
CWlbsCluster* CWlbsControl::GetClusterFromAdapter(IN const GUID &AdapterGuid)
{
        for (DWORD i=0; i< m_dwNumCluster; i++)
        {
                const GUID& Guid = m_pClusterArray[i]->GetAdapterGuid();
                if (IsEqualGUID(Guid, AdapterGuid))
                {
                        return m_pClusterArray[i];
                }
        }

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::ValidateParam
//
// Description:  Validate the specified WLBS cluster parameter. It has no side effects other to munge paramp, for example reformatting
//				IP addresses into canonical form.
//
// Arguments: paramp    -- params to validate
//
// Returns:   TRUE if params look valid, false otherwise.
//
// History:   JosephJ Created 4/25/01
//
//+----------------------------------------------------------------------------
BOOL
CWlbsControl::ValidateParam(
	IN OUT PWLBS_REG_PARAMS paramp
	)
{
	return ::ParamValidate(paramp)!=0;
}

//
//
//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::LocalClusterControl
//
// Description: Performs local cluster-wide control operations on the
//              specified GUID. 
//
// Arguments: AdapterGuid -- GUID of the adapter. 
//            ioctl -- cluster control ioctl.
//
// Returns:   WLBS return code
//
// History:   JosephJ Created 4/25/01
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::LocalClusterControl(
		IN const GUID& AdapterGuid,
		IN LONG    ioctl
)
{
    DWORD            status;
    IOCTL_CVY_BUF     in_buf;
    IOCTL_CVY_BUF     out_buf;

    status = GetInitResult();
    if (status == WLBS_INIT_ERROR)
    {
        goto end;
    }

    //
    // We only support cluster-wide operations...
    //
    switch(ioctl)
    {
    case IOCTL_CVY_CLUSTER_ON:
        break;
    case IOCTL_CVY_CLUSTER_OFF:
        break;
    case IOCTL_CVY_CLUSTER_SUSPEND:
        break;
    case IOCTL_CVY_CLUSTER_RESUME:
        break;
    case IOCTL_CVY_CLUSTER_DRAIN:
        break;
    default:
        status = WLBS_BAD_PARAMS;
        goto end;
    }
 
    ZeroMemory(&in_buf, sizeof(in_buf));
 
    status = WlbsLocalControl (m_hdl, AdapterGuid,
                ioctl, & in_buf, & out_buf, 0);

    if (status != WLBS_IO_ERROR)
    {
        status = MapStateFromDriverToApi (out_buf.ret_code);
    }

end:
    return status;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControlWrapper::GetClusterFromIpOrIndex
//
// Description:  
//
// Arguments: DWORD dwClusterIpOrIndex - 
//
// Returns:   CWlbsCluster* - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
CWlbsCluster* CWlbsControl::GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex)
{
    for (DWORD i=0; i<m_dwNumCluster; i++)
    {
        if (m_pClusterArray[i]->GetClusterIpOrIndex(this) == dwClusterIpOrIndex)
        {
            return m_pClusterArray[i];
        }
    }

    return NULL;
}

/* 
 * Function: CWlbsControlWrapper::IsClusterMember
 * Description: This function searches the list of known NLB clusters on this 
 *              host to determine whether or not this host is a member of a
 *              given cluster.
 * Author: shouse, Created 4.16.01
 */
BOOLEAN CWlbsControl::IsClusterMember (DWORD dwClusterIp)
{
    for (DWORD i = 0; i < m_dwNumCluster; i++) {
        if (m_pClusterArray[i]->GetClusterIp() == dwClusterIp)
            return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::EnumClusterObjects
//
// Description:  Get a list of cluster objects
//
// Arguments: OUT CWlbsCluster** &pdwClusters - The memory is internal to CWlbsControl
///                 Caller can NOT free the pdwClusters memory 
//            OUT DWORD* pdwNum - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::EnumClusterObjects(OUT CWlbsCluster** &ppClusters, OUT DWORD* pdwNum)
{
    ASSERT(pdwNum);
	
    ppClusters = m_pClusterArray;

    *pdwNum = m_dwNumCluster;

    return ERROR_SUCCESS;
}





//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::EnumClusters
//
// Description:  Get a list of cluster IP or index
//
// Arguments: OUT DWORD* pdwAddresses - 
//            IN OUT DWORD* pdwNum - IN size of the buffer, OUT element returned
//
// Returns:   DWORD - WLBS error code.
//
// History:   fengsun Created Header    3/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::EnumClusters(OUT DWORD* pdwAddresses, IN OUT DWORD* pdwNum)
{
    if (pdwNum == NULL)
    {
        return WLBS_BAD_PARAMS;
    }

        if (pdwAddresses == NULL || *pdwNum < m_dwNumCluster)
        {
            *pdwNum = m_dwNumCluster;
                return ERROR_MORE_DATA;
        }

    *pdwNum = m_dwNumCluster;

	for (DWORD i=0; i< m_dwNumCluster; i++)
	{
		pdwAddresses[i] = m_pClusterArray[i]->GetClusterIpOrIndex(this);
	}

    return WLBS_OK;
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsLocalControl
//
// Description:  Send DeviceIoControl to local driver
//
// Arguments: HANDLE hDevice - 
//            const GUID& AdapterGuid - the guid of the adapter
//            LONG ioctl - 
//            PIOCTL_CVY_BUF in_bufp - 
//            PIOCTL_CVY_BUF out_bufp - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WlbsLocalControl(HANDLE hDevice, 
                       const GUID& AdapterGuid, 
                       LONG ioctl, 
                       PIOCTL_CVY_BUF in_bufp, 
                       PIOCTL_CVY_BUF out_bufp,
                       DWORD vip)
{
    BOOLEAN         res;
    DWORD           act;

    //
    // Add adapter GUID
    //
    IOCTL_LOCAL_HDR inBuf;  
    IOCTL_LOCAL_HDR outBuf;
    
    WCHAR szGuid[128];
    StringFromGUID2(AdapterGuid, szGuid, sizeof(szGuid)/ sizeof(szGuid[0]));

    lstrcpy(inBuf.device_name, L"\\device\\");
    lstrcat(inBuf.device_name, szGuid);
    inBuf.ctrl = *in_bufp;

    switch (ioctl) {
    case IOCTL_CVY_CLUSTER_ON:
    case IOCTL_CVY_CLUSTER_OFF:
        break;
    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_PORT_SET:
    case IOCTL_CVY_PORT_DRAIN:
    {
        /* Set the port options. */
        inBuf.options.port.flags = 0;

        inBuf.options.port.virtual_ip_addr = vip;
     
        break;
    }
    case IOCTL_CVY_QUERY:
        break;
    case IOCTL_CVY_CLUSTER_DRAIN:
    case IOCTL_CVY_CLUSTER_SUSPEND:
    case IOCTL_CVY_CLUSTER_RESUME:
        break;
    case IOCTL_CVY_QUERY_STATE:
        break;
    default:
        break;
    }

    res = (BOOLEAN) DeviceIoControl (hDevice, ioctl, &inBuf, sizeof (inBuf),
                                     &outBuf, sizeof (outBuf), & act, NULL);

    *out_bufp = outBuf.ctrl;
    
    if (! res || act != sizeof (outBuf))
        return WLBS_IO_ERROR;

    return WLBS_OK;
}


//+----------------------------------------------------------------------------
//
// Function:  NotifyDriverConfigChanges
//
// Description:  Notify wlbs driver to pick up configuration changes from 
//                               registry
//
// Arguments: HANDLE hDeviceWlbs - The WLBS driver device handle
//                         const GUID& - AdapterGuid Adapter guid       
//
//
// Returns:   DWORD - Win32 Error code
//
// History:   fengsun Created Header    2/3/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid)
{
    LONG                status;

    IOCTL_CVY_BUF       in_buf;
    IOCTL_CVY_BUF       out_buf;
    status = WlbsLocalControl (hDeviceWlbs, AdapterGuid, IOCTL_CVY_RELOAD, 
                & in_buf, & out_buf, 0);

    return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsRemoteControl
//
// Description:  Send a remote control packet
//
// Arguments: ONG             ioctl - 
//            PIOCTL_CVY_BUF   pin_bufp - 
//            PIOCTL_CVY_BUF   pout_bufp - 
//            PWLBS_RESPONSE   pcvy_resp - 
//            PDWORD           nump - 
//            DWORD            trg_addr - 
//            DWORD            hst_addr
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsRemoteControl
(
    LONG             ioctl,
    PIOCTL_CVY_BUF   pin_bufp,
    PIOCTL_CVY_BUF   pout_bufp,
    PWLBS_RESPONSE   pcvy_resp,
    PDWORD           nump,
    DWORD            trg_addr,
    DWORD            hst_addr,
    DWORD            vip
)
{
    INT              ret;
    BOOLEAN          responded [WLBS_MAX_HOSTS], heard;
    BOOL             broadcast;
    DWORD            mode, num_sends, num_recvs;
    SOCKET           sock = INVALID_SOCKET;
    SOCKADDR_IN      caddr, saddr;
    DWORD            i, hosts;
    IOCTL_REMOTE_HDR rct_req;
    IOCTL_REMOTE_HDR rct_rep;
    PIOCTL_CVY_BUF   in_bufp  = & rct_req . ctrl;
    DWORD            timeout;
    WORD             port;
    DWORD            dst_addr;
    DWORD            passw;

    * in_bufp = * pin_bufp;
    timeout   = m_def_timeout;
    port      = m_def_port;
    dst_addr  = m_def_dst_addr;
    passw     = m_def_passw;

//    LOCK(m_lock);

    //
    // Find parameters for the cluster 
    //

    for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
    {
        if (m_cluster_params [i] . cluster == trg_addr)
            break;
    }

    if (i < WLBS_MAX_CLUSTERS)
    {
        timeout  = m_cluster_params [i] . timeout;
        port     = m_cluster_params [i] . port;
        dst_addr = m_cluster_params [i] . dest;
        passw    = m_cluster_params [i] . passw;
    }

    CWlbsCluster* pCluster = GetClusterFromIp(trg_addr);
/*    
    if (pCluster)
    {
        //
        // Always uses password in registry for local cluster
        //
        passw = pCluster->GetPassword();
    }
*/
//    UNLOCK(m_lock);

    if (dst_addr == 0)
        dst_addr = trg_addr;

    rct_req . code     = IOCTL_REMOTE_CODE;
    rct_req . version  = CVY_VERSION_FULL;
    rct_req . id       = GetTickCount ();

    rct_req . cluster  = trg_addr;
    rct_req . host     = hst_addr;
    rct_req . addr     = m_dwSrcAddress;
    rct_req . password = passw;
    rct_req . ioctrl   = ioctl;

    switch (ioctl) {
    case IOCTL_CVY_CLUSTER_ON:
    case IOCTL_CVY_CLUSTER_OFF:
        break;
    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_PORT_SET:
    case IOCTL_CVY_PORT_DRAIN:
    {
        /* Set the port options. */
        rct_req.options.port.flags = 0;

        rct_req.options.port.virtual_ip_addr = vip;
     
        break;
    }
    case IOCTL_CVY_QUERY:
    {
        BOOLEAN bIsMember = IsClusterMember(trg_addr);
        
        /* Reset the flags. */
        rct_req.options.query.flags = 0;

        /* Reset the hostname. */
        rct_req.options.query.hostname[0] = 0;

        /* If I am myself a member of the target cluster, then set the query cluster flags appropriately. */
        if (bIsMember)
            rct_req.options.query.flags |= IOCTL_OPTIONS_QUERY_CLUSTER_MEMBER;
        
        /* Request the hostname from each host. */
        rct_req.options.query.flags |= IOCTL_OPTIONS_QUERY_HOSTNAME;;

        break;
    }
    case IOCTL_CVY_CLUSTER_DRAIN:
    case IOCTL_CVY_CLUSTER_SUSPEND:
    case IOCTL_CVY_CLUSTER_RESUME:
        break;
    case IOCTL_CVY_QUERY_STATE:
        break;
    default:
        break;
    }

    /* now create socket */

    sock = socket (AF_INET, SOCK_DGRAM, 0);

    if (sock == INVALID_SOCKET)
        return WSAGetLastError();

    /* set socket to nonblocking mode */

    mode = 1;
    ret = ioctlsocket (sock, FIONBIO, & mode);

    if (ret == SOCKET_ERROR)
    {
        closesocket (sock);
        return WSAGetLastError();
    }

    /* bind client's address to socket */

    caddr . sin_family        = AF_INET;
    caddr . sin_port          = htons (0);

    BOOLEAN  fBound = FALSE;

    if (pCluster)
    {
        //
        // For local cluster, always bind to the cluster IP.
        // Can not bind to the dedicated IP, which could be for a different NIC.
        //
        caddr . sin_addr . s_addr = trg_addr;
        if (bind (sock, (LPSOCKADDR) & caddr, sizeof (caddr)) != SOCKET_ERROR)
        {
            fBound = TRUE;
        }
    }

    if (!fBound)
    {
        //
        // For remote cluster, or fail to bind VIP/DIP, bind to the any IP 
        //
        caddr . sin_addr . s_addr = htonl (INADDR_ANY);
        if (bind (sock, (LPSOCKADDR) & caddr, sizeof (caddr)) != SOCKET_ERROR)
        {
            fBound = TRUE;
        }
    }
        
    if (!fBound)
    {
        LOG_ERROR1("CWlbsControl::WlbsRemoteControl failed at bind %d", WSAGetLastError());
        closesocket (sock);
        return WSAGetLastError();
    }

        WORD wMyPort;
    wMyPort = QueryPortFromSocket(sock);

    //
    // The client is bound to the remote control server port
    // Let's get another port
    //
    if (wMyPort == htons (port))
    {
        closesocket (sock);

        sock = socket (AF_INET, SOCK_DGRAM, 0);

        if (sock == INVALID_SOCKET)
            return WSAGetLastError();

        /* set socket to nonblocking mode */

        mode = 1;
        ret = ioctlsocket (sock, FIONBIO, & mode);

        if (ret == SOCKET_ERROR)
        {
            closesocket (sock);
            return WSAGetLastError();
        }

        ret = bind (sock, (LPSOCKADDR) & caddr, sizeof (caddr));

        if (ret == SOCKET_ERROR)
        {
            closesocket (sock);
            return WSAGetLastError();
        }
    }


    /* setup server's address */

    saddr . sin_family = AF_INET;
    saddr . sin_port   = htons (port);

    if ( pCluster )  // local cluster
    {
        /* enable sending broadcast on the socket */
        broadcast = TRUE;

        ret = setsockopt (sock, SOL_SOCKET, SO_BROADCAST, (char *) & broadcast,
                          sizeof (broadcast));

        if (ret == SOCKET_ERROR)
        {
            closesocket (sock);
            return WSAGetLastError();
        }

        saddr . sin_addr . s_addr = INADDR_BROADCAST;
    }
    else
        saddr . sin_addr . s_addr = dst_addr;

    for (i = 0; i < WLBS_MAX_HOSTS; i ++)
        responded [i] = FALSE;

    heard = FALSE;
    hosts = 0;

    for (num_sends = 0; num_sends < IOCTL_REMOTE_SEND_RETRIES; num_sends ++)
    {
        /* send remote control request message */

        ret = sendto (sock, (PCHAR) & rct_req, sizeof (rct_req), 0,
                      (LPSOCKADDR) & saddr, sizeof (saddr));

        if (ret == SOCKET_ERROR)
        {
            LOG_ERROR1("CWlbsControl::WlbsRemoteControl failed at sendto %d", WSAGetLastError());

            //
            // Sendto could fail if the adapter is too busy. Allow retry
            //
            Sleep (timeout);
            continue;

//            closesocket (sock);
//            return WSAGetLastError();
        }

        if (ret != sizeof (rct_req))
            continue;

        for (num_recvs = 0; num_recvs < IOCTL_REMOTE_RECV_RETRIES; num_recvs ++)
        {
            /* recv remote control reply message */

            ret = recv (sock, (PCHAR) & rct_rep, sizeof (rct_rep), 0);

            if (ret == SOCKET_ERROR)
            {
                if (WSAGetLastError() == WSAEWOULDBLOCK)
                {
                    Sleep (timeout);
                    continue;
                }
                else if (WSAGetLastError() == WSAECONNRESET)
                {
                    //
                    // Remote control is disabled
                    //
                    continue;
                }
                else
                {
                    closesocket (sock);
                    return WSAGetLastError();
                }
            }

            if (ret != sizeof (rct_rep))
            {
                Sleep (timeout);
                continue;
            }

            if (rct_rep . cluster != trg_addr)
            {
                Sleep (timeout);
                continue;
            }

            if (rct_rep . code != IOCTL_REMOTE_CODE)
            {
                Sleep (timeout);
                continue;
            }

            if (rct_rep . id != rct_req . id)
            {
                Sleep (timeout); 
                continue;
            }

            if (rct_rep . host > WLBS_MAX_HOSTS || rct_rep . host == 0 )
            {
                Sleep (timeout); 
                continue;
            }

            if (! responded [rct_rep . host - 1])
            {
                if (hosts < WLBS_MAX_HOSTS)
                {
                    pout_bufp [hosts] = rct_rep . ctrl;

                    if (hosts < * nump && pcvy_resp != NULL)
                    {
                        pcvy_resp [hosts] . id      = rct_rep . host;
                        pcvy_resp [hosts] . address = rct_rep . addr;

                        if (rct_req . ioctrl == IOCTL_CVY_QUERY) {
                            pcvy_resp [hosts] . status =
                            MapStateFromDriverToApi (rct_rep . ctrl . data . query . state);
                            lstrcpy(pcvy_resp[hosts].hostname, rct_rep.options.query.hostname);                            
                        } else {
                            pcvy_resp [hosts] . status =
                            MapStateFromDriverToApi (rct_rep . ctrl . ret_code);
                        }
                    }
                    hosts ++;
                }
            }

            responded [rct_rep . host - 1] = TRUE;
            heard = TRUE;

            if (hst_addr != WLBS_ALL_HOSTS)
            {
                * nump = hosts;
                closesocket (sock);
                return WLBS_OK;
            }
        }
    }

    * nump = hosts;
    closesocket (sock);

    if (! heard)
        return WLBS_TIMEOUT;

    return WLBS_OK;

}





//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsQuery
//
// Description:  
//
// Arguments: CWlbsCluster*   pCluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            PDWORD           host_map - 
//            PVOID            // reserved
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsQuery
(
    CWlbsCluster*    pCluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    PDWORD           host_map,
    PVOID            // reserved
)
{
    LONG             ioctl = IOCTL_CVY_QUERY;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    /* The following condition is to take care of the case when num_hosts is null
     * and host_map contains some junk value. This could crash this function. */

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
            ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (host_map != NULL)
            * host_map = out_buf . data . query . host_map;

        if (response != NULL)
        {
            response [0] . id      = out_buf . data . query . host_id;
            response [0] . address = 0;
            response [0] . status  = MapStateFromDriverToApi (out_buf . data . query . state);
        }

        if (num_hosts != NULL)
            * num_hosts = 1;

        status = MapStateFromDriverToApi (out_buf . data . query . state);
    }
    else
    {
        status = RemoteQuery(pCluster->GetClusterIp(),
            host, response, num_hosts, host_map);
    }

    return status;

} 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsQuery
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            PDWORD           host_map - 
//            PVOID            // reserved
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsQuery
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    PDWORD           host_map,
    PVOID            // reserved
)
{
    DWORD ret;
    TRACE_INFO("> WlbsQuery: cluster=0x%lx, host=0x%lx", cluster, host);

    if (GetInitResult() == WLBS_INIT_ERROR)
    {
        ret = GetInitResult();
        goto end;
    }

    if (cluster == WLBS_LOCAL_CLUSTER && (GetInitResult() == WLBS_REMOTE_ONLY))
    {
        ret = GetInitResult();
        goto end;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);  

    if (pCluster == NULL)
    {
        ret = RemoteQuery(cluster, host, response, num_hosts, host_map);
        goto end;
    }
    else
    {
        ret = WlbsQuery(pCluster, host, response, num_hosts, host_map, NULL);
        goto end;
    }

end:

    TRACE_INFO("< WlbsQuery: return %d", ret);

    return ret; 
}
 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::RemoteQuery
//
// Description:  
//
// Arguments: DWORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            PDWORD           host_map - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::RemoteQuery
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    PDWORD           host_map
)
{
    LONG             ioctl = IOCTL_CVY_QUERY;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
    DWORD               hosts;
    DWORD               hmap = 0;
    DWORD               active;
    DWORD               i;


    if (GetInitResult() == WLBS_LOCAL_ONLY)
        return GetInitResult();

    if (num_hosts != NULL)
        hosts = * num_hosts;
    else
        hosts = 0;

    status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                         cluster, host, 0);

    if (status >= WSABASEERR || status == WLBS_TIMEOUT)
    {
        if (num_hosts != NULL)
            * num_hosts = 0;
        
        return status;
    }

    if (host == WLBS_ALL_HOSTS)
    {
        for (status = WLBS_STOPPED, active = 0, i = 0; i < hosts; i ++)
        {
            switch (MapStateFromDriverToApi (out_buf [i] . data . query . state))
            {
            case WLBS_SUSPENDED:

                if (status == WLBS_STOPPED)
                    status = WLBS_SUSPENDED;

                break;

            case WLBS_CONVERGING:

                if (status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGING;

                break;

            case WLBS_DRAINING:

                if (status == WLBS_STOPPED)
                    status = WLBS_DRAINING;

                break;

            case WLBS_CONVERGED:

                if (status != WLBS_CONVERGING && status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGED;

                hmap = out_buf [i] . data . query . host_map;
                active ++;
                break;

            case WLBS_BAD_PASSW:

                status = WLBS_BAD_PASSW;
                break;

            case WLBS_DEFAULT:

                if (status != WLBS_CONVERGING && status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGED;

                hmap = out_buf [i] . data . query . host_map;
                active ++;
                break;

            case WLBS_STOPPED:
            default:
                break;

            }
        }

        if (status == WLBS_CONVERGED)
            status = active;
    }
    else
    {
        status = MapStateFromDriverToApi (out_buf [0] . data . query . state);
        hmap = out_buf [0] . data . query . host_map;
    }

    if (host_map != NULL)
        * host_map = hmap;

    if (num_hosts != NULL)
        * num_hosts = hosts;

    return status;

} 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsSuspend
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsSuspend
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    LONG             ioctl = IOCTL_CVY_CLUSTER_SUSPEND;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    CWlbsCluster* pCluster= GetClusterFromIpOrIndex(cluster);

    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                    ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAIN_STOP:
                default:
                    break;
                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;
} 




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsResume
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsResume
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    LONG             ioctl = IOCTL_CVY_CLUSTER_RESUME;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                default:
                    break;
                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

} 




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsStart
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsStart
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    LONG             ioctl = IOCTL_CVY_CLUSTER_ON;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PARAMS:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_BAD_PARAMS;

                    break;

                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_BAD_PARAMS)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_DRAIN_STOP:
                    break;
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsStop
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    LONG             ioctl = IOCTL_CVY_CLUSTER_OFF;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_DRAIN_STOP:
                default:
                    break;
                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDrainStop
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDrainStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    LONG             ioctl = IOCTL_CVY_CLUSTER_DRAIN;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl,pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_STOPPED, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:

                    if (status != WLBS_BAD_PASSW && status != WLBS_SUSPENDED)
                        status = WLBS_OK;

                case WLBS_STOPPED:
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsEnable
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsEnable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    LONG             ioctl = IOCTL_CVY_PORT_ON;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster&& (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, vip);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, vip);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDisable
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDisable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    LONG             ioctl = IOCTL_CVY_PORT_OFF;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, vip);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, vip);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDrain
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDrain
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    LONG             ioctl = IOCTL_CVY_PORT_DRAIN;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    if (num_hosts == NULL)
        response = NULL;
    else if (*num_hosts == 0)
        response = NULL;

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, vip);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, vip);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsAdjust
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port - 
//            DWORD            value
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsAdjust
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            port,
    DWORD            value
)
{
    LONG             ioctl = IOCTL_CVY_PORT_SET;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    if (GetInitResult() == WLBS_INIT_ERROR)
        return GetInitResult();

    in_buf . data . port . num  = port;
    in_buf . data . port . load = value;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && (GetInitResult() == WLBS_REMOTE_ONLY))
        return GetInitResult();

    if (pCluster && IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;


        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, 0);

        if (status == WLBS_IO_ERROR)
            return status;

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;


        if (GetInitResult() == WLBS_LOCAL_ONLY)
            return GetInitResult();

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, 0);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
            return status;

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    return status;

}



//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsPortSet
//
// Description:  
//
// Arguments: DWORD cluster - 
//            WORD port - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsPortSet(DWORD cluster, WORD port)
{
    DWORD           i;
    DWORD           j;
    WORD            rct_port;


//    LOCK(global_info.lock);

    if (port == 0)
        rct_port = CVY_DEF_RCT_PORT;
    else
        rct_port = port;

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_port = rct_port;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . port = rct_port;
    }
    else
    {
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . port = rct_port;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . port    = rct_port;
        }
    }

//    UNLOCK(global_info.lock);

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsPasswordSet
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PTCHAR          password
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsPasswordSet
(
    DWORD           cluster,
    const WCHAR* password
)
{
    DWORD           i;
    DWORD           j;
    DWORD           passw;


//    LOCK(global_info.lock);

    if (password != NULL)
    {
#ifndef UNICODE
        passw = License_string_encode (password);
#else
        passw = License_wstring_encode((WCHAR*)password);
#endif
    }
    else
        passw = CVY_DEF_RCT_PASSWORD;

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_passw = passw;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . passw = passw;
    }
    else
    {
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . passw = passw;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . passw   = passw;
        }
    }

//    UNLOCK(global_info.lock);

} /* end WlbsPasswordSet */


VOID CWlbsControl::WlbsCodeSet
(
    DWORD           cluster,
    DWORD           passw
)
{
    DWORD           i;
    DWORD           j;


//    LOCK(global_info.lock);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_passw = passw;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . passw = passw;
    }
    else
    {
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . passw = passw;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . passw   = passw;
        }
    }

//    UNLOCK(global_info.lock);

} /* end WlbsCodeSet */


VOID CWlbsControl::WlbsDestinationSet
(
    DWORD           cluster,
    DWORD           dest
)
{
    DWORD           i;
    DWORD           j;


//    LOCK(global_info.lock);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_dst_addr = dest;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . dest = dest;
    }
    else
    {
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . dest = dest;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . dest    = dest;
        }
    }

//    UNLOCK(global_info.lock);

}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsTimeoutSet
//
// Description:  
//
// Arguments: DWORD cluster - 
//            DWORD milliseconds - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsTimeoutSet(DWORD cluster, DWORD milliseconds)
{
    DWORD           i;
    DWORD           j;
    DWORD           timeout;


//    LOCK(global_info.lock);

    if (milliseconds == 0)
        timeout = IOCTL_REMOTE_RECV_DELAY;
    else
        timeout = milliseconds / (IOCTL_REMOTE_SEND_RETRIES *
                                  IOCTL_REMOTE_RECV_RETRIES);

    if (timeout < 10)
        timeout = 10;

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_timeout = timeout;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . timeout = timeout;
    }
    else
    {
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . timeout = timeout;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j < WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . timeout = timeout;
        }
    }

//    UNLOCK(global_info.lock);

} /* end WlbsTimeoutSet */

#if defined (SBH)
DWORD CWlbsControl::WlbsQueryStateInfo (DWORD cluster, DWORD host, PIOCTL_QUERY_STATE bufp) {
    IOCTL_LOCAL_HDR Header;
    CWlbsCluster *  pCluster = NULL;
    LONG            Ioctl = IOCTL_CVY_QUERY_STATE;
    ULONG           BufferSize = 0;
    WCHAR           Guid[128];
    ULONG           Length;
    BOOLEAN         Ret;

    if (GetInitResult() == WLBS_INIT_ERROR) return GetInitResult();

    pCluster = GetClusterFromIpOrIndex(cluster);  

    if (!pCluster) return WLBS_IO_ERROR;
    
    StringFromGUID2(pCluster->GetAdapterGuid(), Guid, sizeof(Guid)/ sizeof(Guid[0]));
        
    ZeroMemory((VOID *)&Header, sizeof(IOCTL_LOCAL_HDR));

    lstrcpy(Header.device_name, L"\\device\\");
    lstrcat(Header.device_name, Guid);

    Header.options.state.flags = 0;
    Header.options.state.query = *bufp;

    switch (bufp->Operation) {
    case NLB_QUERY_REG_PARAMS:
    case NLB_QUERY_PORT_RULE_STATE:
    case NLB_QUERY_BDA_TEAM_STATE:
    case NLB_QUERY_PACKET_STATISTICS:
        return WLBS_IO_ERROR;
    case NLB_QUERY_PACKET_FILTER:
        Ret = (BOOLEAN)DeviceIoControl(m_hdl, Ioctl, &Header, sizeof(IOCTL_LOCAL_HDR), &Header, sizeof(IOCTL_LOCAL_HDR), &Length, NULL);
        
        if (!Ret || (Length != sizeof(IOCTL_LOCAL_HDR))) return WLBS_IO_ERROR;
        
        break;
    default:
        return WLBS_IO_ERROR;
    }

    *bufp = Header.options.state.query;
    
    return WLBS_OK; 
}
#endif

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Description:  Dll entry point
//
// Arguments: HINSTANCE handle - 
//            DWORD reason - 
//            LPVOID situation - 
//
// Returns:   BOOL WINAPI - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE handle, DWORD reason, LPVOID situation)
{
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        _tsetlocale (LC_ALL, _TEXT(".OCP"));
        DisableThreadLibraryCalls(handle);
        g_hInstCtrl = handle; 

        //
        // Enable tracing
        //
        WPP_INIT_TRACING(L"Microsoft\\NLB");
	break;
    
    case DLL_THREAD_ATTACH:        
        break;

    case DLL_PROCESS_DETACH:
        //
        // Disable tracing
        //
        WPP_CLEANUP();
    	break;

    case DLL_THREAD_DETACH:
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\license.h ===
#ifdef  __cplusplus
extern "C"
{
#endif

ULONG License_string_encode (
    PCHAR               str);               /* NULL-terminated character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/

ULONG License_wstring_encode (
    PWCHAR              str);               /* NULL-terminated wide character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/


BOOL License_data_encode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Encodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY  bytes

  function:
*/


BOOL License_data_decode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Decodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY bytes

  function:
*/

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\makefile.inc ===
$(O)\wlbsapi.res: wlbsapi.rc
$(O)\wlbsapitest.res: wlbsapitest.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\notification.cpp ===
/* 
 * File: notification.cpp
 * Description: Support for connection notification.
 * Author: shouse 4.30.01
 */

#include <windows.h>

#include <stdio.h>
#include <devguid.h>
#include <iphlpapi.h>

#include "wlbsiocl.h"
#include "debug.h"
#include "wlbsctrl.h"

#if defined (NLB_SESSION_SUPPORT)

/* The length of the IP to GUID hash table. */
#define IP_TO_GUID_HASH 19

/* Loopback IP address. (127.0.0.1) */
#define IP_LOOPBACK_ADDRESS 0x0100007f

/* An Ip to GUID table entry. */
typedef struct IPToGUIDEntry {
    DWORD dwIPAddress;
    WCHAR szAdapterGUID[CVY_MAX_DEVNAME_LEN];
    IPToGUIDEntry * pNext;
} IPToGUIDEntry;

/* The WLBS device - necessary for IOCTLs. */
WCHAR szDevice[CVY_STR_SIZE];

/* The IP to GUID map is an array of linked lists hashed on IP address. */
IPToGUIDEntry * IPToGUIDMap[IP_TO_GUID_HASH];

/* An overlapped structure for IP address change notifications. */
OVERLAPPED AddrChangeOverlapped;

/* A handle for IP address change notifications. */
HANDLE hAddrChangeHandle;

/* A handle for an IP address change event. */
HANDLE hAddrChangeEvent;

/* A boolean to indicate whether or not connection notification has been initialized.
   Initialization is performed upon the first call to either WlbsConnectionUp or WlbsConnectionDown. */
static BOOL fInitialized = FALSE;

/*
 * Function: GetGUIDFromIP
 * Description: Gets the GUID from the IPToGUID table corresponding to the
 *              the given IP address.
 * Returns: If the call succeeds, returns a pointer to the unicode string
 *          containing the CLSID (GUID).  Upon failure, returns NULL.
 * Author: shouse 6.15.00 
 */
WCHAR * GetGUIDFromIP (DWORD IPAddress) {
    IPToGUIDEntry * entry = NULL;

    /* Loop through the linked list at the hashed index and return the GUID from the entry
       corresponding to the given IP address. */
    for (entry = IPToGUIDMap[IPAddress % IP_TO_GUID_HASH]; entry; entry = entry->pNext)
	if (entry->dwIPAddress == IPAddress) 
	    return entry->szAdapterGUID;

    /* At this point, we can't find the IP address in the table, so bail. */
    return NULL;
}

/*
 * Function: GetGUIDFromIndex
 * Description: Gets the GUID from the AdaptersInfo table corresponding
 *              to the given IP address.
 * Returns: If the call succeeds, returns a pointer to the string containing
 *          the adapter name (GUID).  Upon failure, returns NULL.
 * Author: shouse 6.15.00 
 */
CHAR * GetGUIDFromIndex (PIP_ADAPTER_INFO pAdapterTable, DWORD dwIndex) {
    PIP_ADAPTER_INFO pAdapterInfo = NULL;   

    /* Loop through the adapter table looking for the given index.  Return the adapter
       name for the corresponding index. */
    for (pAdapterInfo = pAdapterTable; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next)
        if (pAdapterInfo->Index == dwIndex)
            return pAdapterInfo->AdapterName;

    /* If we get this far, we can't find it, so bail. */
    return NULL;
}

/*
 * Function: PrintIPAddress
 * Description: Prints an IP address in dot notation.
 * Returns: 
 * Author: shouse 6.15.00 
 */
void PrintIPAddress (DWORD IPAddress) {
    CHAR szIPAddress[16];

    sprintf(szIPAddress, "%d.%d.%d.%d", IPAddress & 0x000000ff, (IPAddress & 0x0000ff00) >> 8,
            (IPAddress & 0x00ff0000) >> 16, (IPAddress & 0xff000000) >> 24);

    TRACE1("%-15s", szIPAddress);
}

/*
 * Function: PrintIPToGUIDMap
 * Description: Traverses and prints the IPToGUID map.
 * Returns: 
 * Author: shouse 6.15.00 
 */
void PrintIPToGUIDMap (void) {
    IPToGUIDEntry * entry = NULL;
    DWORD dwHash;

    /* Loop through the linked list at each hashed index and print the IP to GUID mapping. */
    for (dwHash = 0; dwHash < IP_TO_GUID_HASH; dwHash++) {
        for (entry = IPToGUIDMap[dwHash]; entry; entry = entry->pNext) {
            PrintIPAddress(entry->dwIPAddress);
            TRACE1(" -> GUID %ws\n", entry->szAdapterGUID);
        }
    }
}

/*
 * Function: DestroyIPToGUIDMap
 * Description: Destroys the IPToGUID map.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.15.00 
 */
DWORD DestroyIPToGUIDMap (void) {
    DWORD dwError = ERROR_SUCCESS;
    IPToGUIDEntry * next = NULL;
    DWORD dwHash;

    /* Loop through all hash indexes. */
    for (dwHash = 0; dwHash < IP_TO_GUID_HASH; dwHash++) {
        next = IPToGUIDMap[dwHash];
        
        /* Loop through the linked list and free each entry. */
        while (next) {
            IPToGUIDEntry * entry = NULL;

            entry = next;
            next = next->pNext;

            if (!HeapFree(GetProcessHeap(), 0, entry)) {
                dwError = GetLastError();
                TRACE_ERROR1("HeapFree failed: %d\n", dwError);
                return dwError;
            }
        }

        /* Reset the pointer to the head of the list in the array. */
        IPToGUIDMap[dwHash] = NULL;
    }

    return dwError;
}

/*
 * Function: BuildIPToGUIDMap
 * Desc