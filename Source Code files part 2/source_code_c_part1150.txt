   CheckReturnEqual( rc,
                      FALSE,
                      "SET - Use CP ACP, system default locale",
                      &NumErrors );
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_USE_CP_ACP | LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"..",
                       "GET - Use CP ACP, system default locale",
                       &NumErrors );


    //
    //  Reset the slist value.
    //
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         pSList );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SLIST",
                      &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmf2mof\main.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bmf2mof.c

Abstract:

    TODO: Enable localization

    Tool to convert a binary mof resource back to a text mof file

    Usage:

        bmf2mof <image name> <resource name>


Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>

#include <bmfmisc.h>
#include <wbemcli.h>

void Usage()
{
	printf("bmf2mof <image name> <resource name> <mof file>\n");
	printf("    Convert binary mof resource to a text mof\n\n");
	printf("****** WARNING: if <image name> is a system dll (like advapi32.dll)  ******\n");
	printf("****** then the system dll will be used and not the file on disk *****\n\n");
}

ULONG LoadMofResource(
    PTCHAR Filename,
    PTCHAR ResourceName,
    PUCHAR *Data
    )
{
	HMODULE Module;
	HRSRC Resource;
	HGLOBAL Global;
	ULONG Status;
	
	Module = LoadLibraryEx(Filename,
						   NULL,
						   LOAD_LIBRARY_AS_DATAFILE);

	if (Module != NULL)
	{
		Resource = FindResource(Module,
								ResourceName,
								TEXT("MOFDATA"));
		if (Resource != NULL)
		{
			Global = LoadResource(Module,
								  Resource);
			if (Global != NULL)
			{
				*Data = LockResource(Global);
				if (*Data != NULL)
				{
					Status = ERROR_SUCCESS;
				} else {
					Status = GetLastError();
				}
			} else {
				Status = GetLastError();
			}
		} else {
			Status = GetLastError();
		}
	} else {
		Status = GetLastError();
	}
	return(Status);
}

int _cdecl main(int argc, char *argv[])
{
	ULONG Status;
	PUCHAR Data;
	BOOLEAN b;
	
    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);   // BUGBUG: Remove when MOF format maintains alignment correctly
	
	if (argc != 4)
	{
		Usage();
		return(0);
	}

    printf("BMF2MOF - convert a binary mof resource back into a text mof\n\n");
	printf("    Converting resource %s in file %s into text mof %s\n\n",
		   argv[2], argv[1], argv[3]);
	printf("****** WARNING: if %s is a system dll (like advapi32.dll)  ******\n",
		   argv[1]);
	printf("****** then the system dll will be used and not the file on disk *****\n\n");
	
	Status = LoadMofResource(argv[1], argv[2], &Data);

	if (Status == ERROR_SUCCESS)
	{
		b = ConvertBmfToMof(Data,
							argv[3],
							TEXT(""));
		if (! b)
		{
			printf("Could not convert resource %s in file %s to text mof\n",
				   argv[2], argv[1]);
		} else {
			printf("%s created successfully\n", argv[3]);
		}
	} else {
		printf("Could not load resource %s from file %s\n",
			   argv[2], argv[1]);
	}
	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmf2mof\stubs.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    stubs.c

Abstract:


Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>

#include <bmfmisc.h>
#include <wbemcli.h>

HRESULT CreateBMOFViaDLL(
	WCHAR *MofFileW,
	WCHAR *BmfFileW,
    WCHAR *NameSpace,
    LONG OptionFlags,
    LONG ClassFlags,
    LONG InstanceFlags,
    WBEM_COMPILE_STATUS_INFO *info
    )
{
	//
	// Stub implementation - not needed in this app
	//
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\wctest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    wctest.c

Abstract:

    Test module for NLS API WideCharToMultiByte.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE           50
#define  WC_INVALID_FLAGS  ((DWORD)(~(WC_DISCARDNS | WC_SEPCHARS |          \
                                      WC_DEFAULTCHAR | WC_COMPOSITECHECK)))




//
//  Global Variables.
//

#define mbWCStr    "This Is A String."
#define wcWCStr    L"This Is A String."

WCHAR wcWCStr2[] = L"This Is A String.";    // this could get overwritten


#define mbDefStr   "t?t"
#define mbDefStr2  "tXt"
#define wcDefStr   L"\x0074\xffef\x0074"
#define wcBestFit  L"\x0300"


BYTE  mbWCDest[BUFSIZE];




//
//  Forward Declarations.
//

int
WC_BadParamCheck();

int
WC_NormalCase();

int
WC_TestFlags();





////////////////////////////////////////////////////////////////////////////
//
//  TestWCToMB
//
//  Test routine for WideCharToMultiByte API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestWCToMB()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING WideCharToMultiByte...\n\n");

    //
    //  Test bad parameters.
    //
    ErrCount += WC_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += WC_NormalCase();

    //
    //  Test flags.
    //
    ErrCount += WC_TestFlags();

    //
    //  Print out result.
    //
    printf("\nWideCharToMultiByte:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  WC_BadParamCheck
//
//  This routine passes in bad parameters to the API routine and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WC_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Null Pointers and Equal Pointers.
    //

    //  Variation 1  -  lpWideCharStr = NULL
    rc = WideCharToMultiByte( 1252,
                              0,
                              NULL,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpWideCharStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpMultiByteStr = NULL
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpMultiByteStr NULL",
                         &NumErrors );

    //  Variation 3  -  equal pointers
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr2,
                              -1,
                              (LPSTR)wcWCStr2,
                              (sizeof(wcWCStr2) / sizeof(WCHAR)),
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "equal pointers",
                         &NumErrors );


    //
    //  Negative or Zero Lengths.
    //

    //  Variation 1  -  cchWideChar = 0
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              0,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchWideChar zero",
                         &NumErrors );

    //  Variation 2  -  cchMultiByte = negative
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              -1,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchMultiByte negative",
                         &NumErrors );


    //
    //  Invalid Code Page.
    //

    //  Variation 1  -  CodePage = invalid
    rc = WideCharToMultiByte( 5,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "CodePage Invalid",
                         &NumErrors );

    //  Variation 2  -  CodePage = invalid
    rc = WideCharToMultiByte( 65002,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "CodePage Invalid 2",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  wFlags = 0
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "dwFlags zero",
                       &NumErrors );

    //  Variation 2  -  wFlags = invalid
    rc = WideCharToMultiByte( 1252,
                              WC_INVALID_FLAGS,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwFlags invalid",
                         &NumErrors );

    //  Variation 3  -  wFlags = 0x100
    rc = WideCharToMultiByte( 1252,
                              0x00000100,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwFlags 0x100",
                         &NumErrors );



    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchMultiByte = too small
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              2,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchMultiByte too small",
                         &NumErrors );



    //
    //  No Unicode Translation.
    //

    //  Variation 1  - CodePage = CP_SYMBOL
    rc = WideCharToMultiByte( CP_SYMBOL,
                              0,
                              L"\xf020\xf033\xf0ca\xf200",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "CP_SYMBOL - invalid char 0xf200",
                         &NumErrors );

    //  Variation 2  - CodePage = CP_SYMBOL
    rc = WideCharToMultiByte( CP_SYMBOL,
                              0,
                              L"\xf020\xf033\xf0ca\x0033",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "CP_SYMBOL - invalid char 0x0033",
                         &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  WC_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WC_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE DefChar = 'X';           // default character
    BOOL UsedDef;                 // if default used
    LCID Locale;                  // save the old locale


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  cchMultiByte.
    //

    //  Variation 1  -  cchMultiByte = length of mbWCDest
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "cchMultiByte (length)",
                       &NumErrors );

    //  Variation 2  -  cchMultiByte = 0
    mbWCDest[0] = 0;
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "cchMultiByte zero",
                       &NumErrors );

    //  Variation 3  -  cchMultiByte = 0, mbWCDest = NULL
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "cchMultiByte zero (NULL ptr)",
                       &NumErrors );


    //
    //  cchWideChar.
    //

    //  Variation 1  -  cchWideChar = length of wcWCStr
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              WC_STRING_LEN(wcWCStr),
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       MB_STRING_LEN(mbWCStr),
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "cchWideChar (length)",
                       &NumErrors );

    //  Variation 2  -  cchWideChar = -1
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "cchWideChar (-1)",
                       &NumErrors );

    //  Variation 3  -  cchWideChar = length of wcWCStr, no WCDest
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              WC_STRING_LEN(wcWCStr),
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       MB_STRING_LEN(mbWCStr),
                       NULL,
                       mbWCStr,
                       NULL,
                       "cchWideChar (length), no WCDest",
                       &NumErrors );

    //  Variation 4  -  cchWideChar = -1, no WCDest
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "cchWideChar (-1), no WCDest",
                       &NumErrors );


    //
    //  CodePage.
    //

    //  Variation 1  - CodePage = CP_ACP
    rc = WideCharToMultiByte( CP_ACP,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage CP_ACP",
                       &NumErrors );

    //  Variation 2  - CodePage = CP_ACP, no WCDest
    rc = WideCharToMultiByte( CP_ACP,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage CP_ACP, no WCDest",
                       &NumErrors );

    //  Variation 3  - CodePage = CP_OEMCP
    rc = WideCharToMultiByte( CP_OEMCP,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage CP_OEMCP",
                       &NumErrors );

    //  Variation 4  - CodePage = CP_OEMCP, no WCDest
    rc = WideCharToMultiByte( CP_OEMCP,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage CP_OEMCP, no WCDest",
                       &NumErrors );

    //  Variation 5  - CodePage = 437
    rc = WideCharToMultiByte( 437,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage 437",
                       &NumErrors );

    //  Variation 6  - CodePage = 437, no WCDest
    rc = WideCharToMultiByte( 437,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage 437, no WCDest",
                       &NumErrors );

    //  Variation 7  - CodePage = 850
    rc = WideCharToMultiByte( 850,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage 850",
                       &NumErrors );

    //  Variation 8  - CodePage = 850, no WCDest
    rc = WideCharToMultiByte( 850,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage 850, no WCDest",
                       &NumErrors );

    //  Variation 9  - CodePage = 850  best fit
    rc = WideCharToMultiByte( 850,
                              0,
                              wcBestFit,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x27",
                       NULL,
                       "CodePage 850 best fit",
                       &NumErrors );

    //  Variation 10  - CodePage = 10000
    rc = WideCharToMultiByte( 10000,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage 10000",
                       &NumErrors );

    //  Variation 11  - CodePage = 10000, no WCDest
    rc = WideCharToMultiByte( 10000,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage 10000, no WCDest",
                       &NumErrors );

    //  Variation 12  - CodePage = CP_THREAD_ACP
    rc = WideCharToMultiByte( CP_THREAD_ACP,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "CodePage CP_THREAD_ACP",
                       &NumErrors );

    //  Variation 13  - CodePage = CP_THREAD_ACP, no WCDest
    rc = WideCharToMultiByte( CP_THREAD_ACP,
                              0,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "CodePage CP_THREAD_ACP, no WCDest",
                       &NumErrors );

    //  Variation 14  - CodePage = CP_THREAD_ACP
    Locale = GetThreadLocale();
    SetThreadLocale(0x00000405);                 // Czech - cp 1250
    rc = WideCharToMultiByte( CP_THREAD_ACP,
                              0,
                              L"\x0165\x017a",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x9d\x9f",
                       NULL,
                       "CodePage CP_THREAD_ACP - Czech cp 1250",
                       &NumErrors );
    SetThreadLocale(Locale);                     // US - cp 1252
    rc = WideCharToMultiByte( CP_THREAD_ACP,
                              0,
                              L"\x0165\x017a",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x74\x7a",
                       NULL,
                       "CodePage CP_THREAD_ACP - US cp 1252",
                       &NumErrors );

    //  Variation 15  - CodePage = CP_SYMBOL
    rc = WideCharToMultiByte( CP_SYMBOL,
                              0,
                              L"\xf020\xf033\xf0ca\x0000",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x20\x33\xca\x00",
                       NULL,
                       "CodePage CP_SYMBOL",
                       &NumErrors );

    //  Variation 16  - CodePage = CP_SYMBOL, no WCDest
    rc = WideCharToMultiByte( CP_SYMBOL,
                              0,
                              L"\xf020\xf033\xf0ca\x0000",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x20\x33\xca\x00",
                       NULL,
                       "CodePage CP_SYMBOL, no WCDest",
                       &NumErrors );

    //  Variation 17  - CodePage = CP_SYMBOL
    rc = WideCharToMultiByte( CP_SYMBOL,
                              0,
                              L"\xf020\xf033\xf0ca\x0000",
                              5,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       5,
                       mbWCDest,
                       "\x20\x33\xca\x00",
                       NULL,
                       "CodePage CP_SYMBOL, size",
                       &NumErrors );





    //
    //  UTF 7.
    //

    //  Variation 1  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x5317\x4eac",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x55\x78\x64\x4f\x72\x41\x2d",   // +UxdOrA-
                       NULL,
                       "CodePage CP_UTF7 - 1",
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x4e2d\x570b\x66f8\x5e97",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,                            // +Ti1XC2b4Xpc-
                       mbWCDest,
                       "\x2b\x54\x69\x31\x58\x43\x32\x62\x34\x58\x70\x63\x2d",
                       NULL,
                       "CodePage CP_UTF7 - 2",
                       &NumErrors );

    //  Variation 3  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x003b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x41\x44\x73\x2d",        // +ADs-
                       NULL,
                       "CodePage CP_UTF7 - 3",
                       &NumErrors );

    //  Variation 4  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x5eb7\x7199\x5b57\x5178",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,                            // +XrdxmVtXUXg-
                       mbWCDest,
                       "\x2b\x58\x72\x64\x78\x6d\x56\x74\x58\x55\x58\x67\x2d",
                       NULL,
                       "CodePage CP_UTF7 - 4",
                       &NumErrors );

    //  Variation 5  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x4e95\x4f5c\x6046",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,                            // +TpVPXGBG-
                       mbWCDest,
                       "\x2b\x54\x70\x56\x50\x58\x47\x42\x47\x2d",
                       NULL,
                       "CodePage CP_UTF7 - 5",
                       &NumErrors );

    //  Variation 6  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x005f",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x41\x46\x38\x2d",        // +AF8-
                       NULL,
                       "CodePage CP_UTF7 - 6",
                       &NumErrors );

    //  Variation 7  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x0040",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x41\x45\x41\x2d",        // +AEA-
                       NULL,
                       "CodePage CP_UTF7 - 7",
                       &NumErrors );

    //  Variation 8  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x002b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x2d",                    // +-
                       NULL,
                       "CodePage CP_UTF7 - 8",
                       &NumErrors );

    //  Variation 9  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x0041\x002b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x41\x2b\x2d",                // A+-
                       NULL,
                       "CodePage CP_UTF7 - 9",
                       &NumErrors );

    //  Variation 10  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"\x0040\x002b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b\x41\x45\x41\x2d\x2b\x2d",  // +AEA-+-
                       NULL,
                       "CodePage CP_UTF7 - 10",
                       &NumErrors );

    //  Variation 11  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"<HTML>",
                              6,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       14,
                       mbWCDest,
                       "+ADw-HTML+AD4-",
                       NULL,
                       "CodePage CP_UTF7 - 11",
                       &NumErrors );

    //  Variation 12  -  CodePage = CP_UTF7
    rc = WideCharToMultiByte( CP_UTF7,
                              0,
                              L"<HTML>",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "+ADw-HTML+AD4-",
                       NULL,
                       "CodePage CP_UTF7 - 12",
                       &NumErrors );


    //
    //  UTF 8.
    //

    //  Variation 1  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x5317\x4eac",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xe5\x8c\x97\xe4\xba\xac",
                       NULL,
                       "CodePage CP_UTF8 - 1",
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x4e2d\x570b\x66f8\x5e97",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xe4\xb8\xad\xe5\x9c\x8b\xe6\x9b\xb8\xe5\xba\x97",
                       NULL,
                       "CodePage CP_UTF8 - 2",
                       &NumErrors );

    //  Variation 3  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x003b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x3b",
                       NULL,
                       "CodePage CP_UTF8 - 3",
                       &NumErrors );

    //  Variation 4  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x5eb7\x7199\x5b57\x5178",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xe5\xba\xb7\xe7\x86\x99\xe5\xad\x97\xe5\x85\xb8",
                       NULL,
                       "CodePage CP_UTF8 - 4",
                       &NumErrors );

    //  Variation 5  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x4e95\x4f5c\x6046",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xe4\xba\x95\xe4\xbd\x9c\xe6\x81\x86",
                       NULL,
                       "CodePage CP_UTF8 - 5",
                       &NumErrors );

    //  Variation 6  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x005f",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x5f",
                       NULL,
                       "CodePage CP_UTF8 - 6",
                       &NumErrors );

    //  Variation 7  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x0040",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x40",
                       NULL,
                       "CodePage CP_UTF8 - 7",
                       &NumErrors );

    //  Variation 8  -  CodePage = CP_UTF8
    rc = WideCharToMultiByte( CP_UTF8,
                              0,
                              L"\x002b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x2b",
                       NULL,
                       "CodePage CP_UTF8 - 8",
                       &NumErrors );



    //
    //  lpDefaultChar and lpUsedDefaultChar.
    //

    //  Variation 1  - default (null, null)
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "default (null, null)",
                       &NumErrors );

    //  Variation 2  - default (null, non-null)
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcDefStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbDefStr,
                       &UsedDef,
                       "default (null, null)",
                       &NumErrors );

    //  Variation 3  - default (non-null, null)
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcDefStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbDefStr2,
                       NULL,
                       "default (non-null, null)",
                       &NumErrors );

    //  Variation 4  - default (non-null, non-null)
    rc = WideCharToMultiByte( 1252,
                              0,
                              wcDefStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbDefStr2,
                       &UsedDef,
                       "default (non-null, non-null)",
                       &NumErrors );


    //
    //  WC_NO_BEST_FIT_CHARS flag.
    //

    //  Variation 1  - Best Fit
    rc = WideCharToMultiByte( 1252,
                              0,
                              L"This \x2566 \xff32 \x2560",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "This \x2d \x52 \xa6",
                       NULL,
                       "Best Fit",
                       &NumErrors );

    //  Variation 2  - No Best Fit
    rc = WideCharToMultiByte( 1252,
                              WC_NO_BEST_FIT_CHARS,
                              L"This \x2566 \xff32 \x2560",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "This ? ? ?",
                       NULL,
                       "No Best Fit 1",
                       &NumErrors );

    //  Variation 3  - No Best Fit, no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_NO_BEST_FIT_CHARS,
                              L"This \x2566 \xff32 \x2560",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "This ? ? ?",
                       NULL,
                       "No Best Fit 1, no WCDest",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  WC_TestFlags
//
//  This routine tests the different flags of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////


int WC_TestFlags()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE DefChar = 'X';           // default character
    BOOL UsedDef;                 // if default used


    //
    //  Precomposed.
    //

    //  Variation 1  -  normal
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x00c0\x00c1",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xc0\xc1",
                       NULL,
                       "precomp (a grave, a acute)",
                       &NumErrors );

    //  Variation 2  -  no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x00c0\x00c1",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\xc0\xc1",
                       NULL,
                       "precomp (a grave, a acute), no WCDest",
                       &NumErrors );


    //
    //  WC_DISCARDNS flag.
    //

    //  Variation 1  -  normal
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "WC_DISCARDNS",
                       &NumErrors );

    //  Variation 2  -  no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "WC_DISCARDNS, no WCDest",
                       &NumErrors );

    //  Variation 3  -  acute
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x0301\x0045\x0301",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xc9\xc9",
                       NULL,
                       "WC_DISCARDNS acute",
                       &NumErrors );

    //  Variation 4  -  acute, default
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x0301\x0045\x0301",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xc9\xc9",
                       NULL,
                       "WC_DISCARDNS acute, default",
                       &NumErrors );

    //  Variation 5  -  no precomp form
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x3093\x309b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x82\xf1",
                       NULL,
                       "WC_DISCARDNS, no precomp",
                       &NumErrors );

    //  Variation 6  -  no precomp form, no WCDest
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x3093\x309b",
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x82\xf1",
                       NULL,
                       "WC_DISCARDNS, no precomp, no WCDest",
                       &NumErrors );


    //
    //  WC_SEPCHARS flag.
    //

    //  Variation 1  -  normal
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "WC_SEPCHARS",
                       &NumErrors );

    //  Variation 2  -  no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "WC_SEPCHARS, no WCDest",
                       &NumErrors );

    //  Variation 3  -  no precomp form
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x3093\x309b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x82\xf1\x81\x4a",
                       NULL,
                       "WC_SEPCHARS, no precomp",
                       &NumErrors );

    //  Variation 4  -  no precomp form, no WCDest
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x3093\x309b",
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x82\xf1\x81\x4a",
                       NULL,
                       "WC_SEPCHARS, no precomp, no WCDest",
                       &NumErrors );


    //
    //  WC_DEFAULTCHAR flag.
    //

    //  Variation 1  -  normal
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              wcWCStr,
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       mbWCStr,
                       NULL,
                       "WC_DEFAULTCHAR",
                       &NumErrors );

    //  Variation 2  -  no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              wcWCStr,
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       mbWCStr,
                       NULL,
                       "WC_DEFAULTCHAR, no WCDest",
                       &NumErrors );

    //  Variation 3  -  no precomp form
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp",
                       &NumErrors );

    //  Variation 4  -  no precomp form, no WCDest
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b",
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp, no WCDest",
                       &NumErrors );

    //  Variation 5  -  no precomp form, extra nonspace
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b\x309b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp extra nonspace",
                       &NumErrors );

    //  Variation 6  -  no precomp form, extra nonspace, no WCDest
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b\x309b",
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp extra nonspace, no WCDest",
                       &NumErrors );

    //  Variation 7  -  no precomp form, no default
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b\x309b",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x3f",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp no default",
                       &NumErrors );

    //  Variation 8  -  no precomp form, no WCDest, no default
    rc = WideCharToMultiByte( 932,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x3093\x309b\x309b",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x3f",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp no default, no WCDest",
                       &NumErrors );

    //  Variation 9  -  no precomp form, extra nonspace
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0065\x0303\x0303",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp 2, extra nonspace",
                       &NumErrors );

    //  Variation 10  -  no precomp form, extra nonspace, no WCDest
    rc = WideCharToMultiByte( 1252,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0065\x0303\x0303",
                              -1,
                              NULL,
                              0,
                              &DefChar,
                              &UsedDef );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "X",
                       NULL,
                       "WC_DEFAULTCHAR, no precomp 2, extra nonspace, no WCDest",
                       &NumErrors );




    //
    //  Circumflex check.
    //

    //  Variation 1  -  circumflex (no flag)
    rc = WideCharToMultiByte( 437,
                              0,
                              L"\x0045\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x45\x5e",
                       NULL,
                       "circumflex (no flag)",
                       &NumErrors );

    //  Variation 2  -  circumflex
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0045\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "E",
                       NULL,
                       "circumflex",
                       &NumErrors );

    //  Variation 3  -  circumflex, no WCDest
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0045\x0302",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x88",
                       NULL,
                       "circumflex, no WCDest",
                       &NumErrors );



    //
    //  Half Ring Below check.
    //

    //  Variation 1  -  half ring below
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x031c",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x45",
                       NULL,
                       "half ring below",
                       &NumErrors );

    //  Variation 2  -  half ring below, no WCDest
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x031c",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x45",
                       NULL,
                       "half ring below, no WCDest",
                       &NumErrors );



    //
    //  TILDE check.
    //

    //  Variation 1  -  tilde, discardns
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0042\x0303",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x42",
                       NULL,
                       "tilde, discardns",
                       &NumErrors );

    //  Variation 2  -  tilde, discardns, no WCDest
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0042\x0303",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x42",
                       NULL,
                       "tilde, discardns, no WCDest",
                       &NumErrors );

    //  Variation 3  -  tilde, sepchars
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0042\x0303",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x42\x7e",
                       NULL,
                       "tilde, sepchars",
                       &NumErrors );

    //  Variation 4  -  tilde, sepchars, no WCDest
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0042\x0303",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x42\x7e",
                       NULL,
                       "tilde, sepchars, no WCDest",
                       &NumErrors );

    //  Variation 5  -  tilde, defaultchar
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0042\x0303",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x3f",
                       NULL,
                       "tilde, defaultchar",
                       &NumErrors );

    //  Variation 6  -  tilde, defaultchar, no WCDest
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0042\x0303",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\x3f",
                       NULL,
                       "tilde, defaultchar, no WCDest",
                       &NumErrors );


    //
    //  CP 437 - Nonspace character first in string.
    //

    //  Variation 1  -  first char, discardns
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0301\x0045",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x45",
                       NULL,
                       "first char, discardns",
                       &NumErrors );

    //  Variation 2  -  first char, sepchars
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0301\x0045",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x27\x45",
                       NULL,
                       "first char, sepchars",
                       &NumErrors );

    //  Variation 3  -  first char, defaultchar
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0301\x0045",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x3f\x45",
                       NULL,
                       "first char, defaultchar",
                       &NumErrors );



    //
    //  CP 437 - Composite Check Flags.
    //

    //  Variation 1  -  composite check - no flags
    rc = WideCharToMultiByte( 437,
                              0,
                              L"\x0045\x0302\x0045\x0308\x0045\x0305",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x45\x5e\x45\x22\x45\x3f",
                       NULL,
                       "437 composite check",
                       &NumErrors );

    //  Variation 2  -  composite check - discardns
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x0302\x0045\x0308\x0045\x0305",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "EEE",
                       NULL,
                       "437 composite check - discardns",
                       &NumErrors );

    //  Variation 3  -  composite check - sepchars
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0045\x0302\x0045\x0308\x0045\x0305",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "EEE?",
                       NULL,
                       "437 composite check - sepchars",
                       &NumErrors );

    //  Variation 4  -  composite check - defaultchar
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0045\x0302\x0045\x0308\x0045\x0305",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "EE?",
                       NULL,
                       "437 composite check - defaultchar",
                       &NumErrors );



    //
    //  CP 437 - Double Nonspacing Chars Check.
    //

    //  Variation 1  -  double nonspace check - no flags
    rc = WideCharToMultiByte( 437,
                              0,
                              L"\x0045\x0302\x0045\x0302\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\x45\x5e\x45\x5e\x5e",
                       NULL,
                       "437 double nonspace check",
                       &NumErrors );

    //  Variation 2  -  double nonspace check - discardns
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DISCARDNS,
                              L"\x0045\x0302\x0045\x0302\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "EE",
                       NULL,
                       "437 double nonspace check - discardns",
                       &NumErrors );

    //  Variation 3  -  double nonspace check - sepchars
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x0045\x0302\x0045\x0302\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "EE^",
                       NULL,
                       "437 double nonspace check - sepchars",
                       &NumErrors );

    //  Variation 4  -  double nonspace check - defaultchar
    rc = WideCharToMultiByte( 437,
                              WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                              L"\x0045\x0302\x0045\x0302\x0302",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "E?",
                       NULL,
                       "437 double nonspace check - defaultchar",
                       &NumErrors );



    //
    //  CP 936.
    //

    //  Variation 1  -  ideographic comma
    rc = WideCharToMultiByte( 936,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x3001",
                              -1,
                              mbWCDest,
                              BUFSIZE,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       mbWCDest,
                       "\xa1\xa2",
                       NULL,
                       "cp 936",
                       &NumErrors );

    //  Variation 2  -  ideographic comma, no WCDest
    rc = WideCharToMultiByte( 936,
                              WC_COMPOSITECHECK | WC_SEPCHARS,
                              L"\x3001",
                              -1,
                              NULL,
                              0,
                              NULL,
                              NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "\xa1\xa2",
                       NULL,
                       "cp 936, no WCDest",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmof\bmof.c ===
//***************************************************************************
//
//  Copyright (c) 1997 by Microsoft Corporation
//
//  bmof.c
//
//  a-davj  14-April-97   Created.
//
//  Structures and helper functions for naviagating a BMOF file.
//
//***************************************************************************

#include "wmiump.h"
#include <string.h>
#include <ole2.h>
#include <oleauto.h>
#include "bmof.h"

#define VT_EMBEDDED_OBJECT VT_UNKNOWN

//***************************************************************************
//
//  BOOL LookupFlavor
//
//  DESCRIPTION:
//
//  Looks in the flavor table to see if a qualifier has a flavor.
//
//  PARAMETERS:
//
//  pQual      Pointer to the qualifier.
//  pdwFlavor  Pointer to where the return value is put
//  pBuff      Pointer to the main buffer.  I.e. "BMOF...."
//
//
//  RETURN VALUE:
//
//  TRUE if there is a flavor.  Note that failure is normal
//
//***************************************************************************

BOOL LookupFlavor(BYTE * pQual, DWORD * pdwFlavor, BYTE * pBuff)
{
    DWORD * pTemp;
    BYTE * pFlavorBlob;
    DWORD dwNumPairs;
    DWORD * pOffset;
    DWORD * pFlavor;
    DWORD dwMyOffset;
    DWORD dwCnt;

    *pdwFlavor = 0;

    // Calculate the pointer of the start of the flavor data

    pTemp = (DWORD * )pBuff;
    pTemp++;                            // point to the original blob size
    pFlavorBlob = pBuff + *pTemp;

    // Check if the flavor blob is valid, it should start off with the 
    // characters "BMOFQUALFLAVOR11"

    if(memcmp(pFlavorBlob, "BMOFQUALFLAVOR11", 16))
        return FALSE;                               // Not really a problem since it may be old file
    
    // The flavor part of the file has the format 
    // DWORD dwNumPair, followed by pairs of dwords;
    // offset, flavor

    // Determine the number of pairs

    pFlavorBlob+= 16;
    pTemp = (DWORD *)pFlavorBlob;
    dwNumPairs = *pTemp;              // Number of offset/value pairs
    if(dwNumPairs < 1)
        return FALSE;

    // point to the first offset/flavor pair

    pOffset = pTemp+1;
    pFlavor = pOffset+1;

    // Determine the offset we are looking for.  That is the pointer to the qualifier minus
    // the pointer to the start of the block;

    dwMyOffset = (DWORD)(pQual - pBuff);

    for(dwCnt = 0; dwCnt < dwNumPairs; dwCnt++)
    {
        if(dwMyOffset == *pOffset)
        {
            *pdwFlavor = *pFlavor;
        }
        if(dwMyOffset < *pOffset)
            return FALSE;
        pOffset += 2;
        pFlavor += 2;
    }
    return FALSE;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown 
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN DWORD vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    vtTest &= ~ VT_BYREF; // get rid of possible byref bit

    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;

        default:
            iRet = 0;
        }
    return iRet;
}


//***************************************************************************
//
//  CBMOFQualList * CreateQualList
//
//  DESCRIPTION:
//
//  Create a CBMOFQualList object which serves as a wrapper.
//
//  PARAMETERS:
//
//  pwql                 pointer to the WBEM_Qualifier structure in the binary
//                      MOF.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList structure that servers as a wrapper.  NULL 
//  if error.  This must be freed via BMOFFree() when no longer needed.
//
//
//***************************************************************************

CBMOFQualList * CreateQualList(WBEM_QualifierList *pwql)
{

    CBMOFQualList * pRet = NULL;
    if(pwql == NULL)
      return NULL;

    
    pRet = (CBMOFQualList *)BMOFAlloc(sizeof (CBMOFQualList));
    if(pRet != NULL)
    {
        pRet->m_pql = pwql;
        pRet->m_pInfo = (WBEM_Qualifier *)
            ((BYTE *)pRet->m_pql + sizeof(WBEM_QualifierList));;
        ResetQualList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetQualList
//
//  DESCRIPTION:
//
//  Resets CBMOFQualList stucture to point to the first entry.
//
//  PARAMETERS:
//
//  pql                 structure to be reset     
//
//***************************************************************************

void ResetQualList(CBMOFQualList * pql)
{
   if(pql)
   {
      pql->m_CurrQual = 0;
      pql->m_pCurr = pql->m_pInfo;
   }
}

//***************************************************************************
//
//  BOOL NextQual
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem)
{
    return NextQualEx(pql, ppName, pItem, NULL, NULL);
}


//***************************************************************************
//
//  BOOL NextQualEx
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem,
                                            DWORD * pdwFlavor, BYTE * pBuff)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;

    if(pql == NULL || pql->m_CurrQual++ >= pql->m_pql->dwNumQualifiers)
        return FALSE;

    if(pdwFlavor && pBuff)
        LookupFlavor((BYTE *)pql->m_pCurr, pdwFlavor, pBuff);
 
    pInfo = (BYTE *)pql->m_pCurr + sizeof(WBEM_Qualifier);
    
    if (ppName)
	{
		SetName(ppName, pInfo, pql->m_pCurr->dwOffsetName);
		if (*ppName == NULL)
		{
		  return(FALSE);
		}
	}

    if(pInfo)
      bRet = SetValue(pItem, pInfo, pql->m_pCurr->dwOffsetValue, 
                        pql->m_pCurr->dwType);

    // advance to next
    pql->m_pCurr = (WBEM_Qualifier *)((BYTE *)pql->m_pCurr + pql->m_pCurr->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindQual
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem)
{
    return FindQualEx(pql, pName, pItem, NULL, NULL);
}

//***************************************************************************
//
//  BOOL FindQualEx
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                          DWORD * pdwFlavor, BYTE * pBuff)
{
    DWORD dwCnt;
    WBEM_Qualifier * pQual = pql->m_pInfo;
    for(dwCnt = 0; dwCnt < pql->m_pql->dwNumQualifiers; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;
        BYTE * pInfo = (BYTE *)pQual + sizeof(WBEM_Qualifier);
        if(!SetName(&pTest, pInfo, pQual->dwOffsetName))
            return FALSE;

        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);
        if(bMatch)
        {
            if(pdwFlavor && pBuff)
                LookupFlavor((BYTE *)pQual, pdwFlavor, pBuff);
            return SetValue(pItem, pInfo, pQual->dwOffsetValue, pQual->dwType);
        }
        pQual = (WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return FALSE;
}



//***************************************************************************
//
//  BOOL SetValue
//
//  DESCRIPTION:
//
//  Sets up a CBMOFDataItem structure to point to a value in the BMOF.
//
//  PARAMETERS:
//
//  pItem               Input/Output, item to be set
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//  dwType              Input data type.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType)
{

    if(pItem == NULL || pInfo == NULL)
        return FALSE;

    pItem->m_dwType = dwType;

    // Check for NULL case.  This is how uninitialized data is stored.

    if(dwOffset == 0xffffffff)
        pItem->m_pData = NULL;
    else
        pItem->m_pData = pInfo + dwOffset;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetName
//
//  DESCRIPTION:
//
//  Gets a name out of an information block.  
//
//  PARAMETERS:
//
//  ppName              Input/Output.  On successful return, will point to a 
//                      WCHAR string containing the name.  This MUST be freed
//                      by the caller via BMOFFree()!
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset)
{
    WCHAR * pName;
    if(ppName == NULL || pInfo == NULL || dwOffset == 0xffffffff)
        return FALSE;

    pName = (WCHAR *)(pInfo + dwOffset);   // point to string in info block
    *ppName = (WCHAR *)BMOFAlloc(2*(wcslen(pName) + 1));
    if(*ppName == NULL)
        return FALSE;
    wcscpy(*ppName, pName);
    return TRUE;
}

//***************************************************************************
//
//  CBMOFObj * CreateObj
//
//  DESCRIPTION:
//
//  Create a CBMOFObj structure which wraps a WBEM_Object
//
//  PARAMETERS:
//
//  pwob                Input, structure to be wrapped
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObj * CreateObj(WBEM_Object * pwob)
{
    CBMOFObj * pRet = (CBMOFObj *)BMOFAlloc(sizeof(CBMOFObj));
    if(pRet)
     {
        pRet->m_pob = pwob;
        pRet->m_pInfo = ((BYTE *)pwob) + sizeof(WBEM_Object);
        pRet->m_ppl = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetPropertyList);
        pRet->m_pml = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetMethodList);
        ResetObj(pRet);
     }
    return pRet;
}


//***************************************************************************
//
//  void ResetObj
//
//  DESCRIPTION:
//
//  Resets a CBMOFObj structure so that it points to its first property.
//
//  PARAMETERS:
//
//  pob                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObj(CBMOFObj * pob)
{
   if(pob)
   {
      pob->m_CurrProp = 0; 
      pob->m_pCurrProp = (WBEM_Property *) ((BYTE *)pob->m_ppl +
                                    sizeof(WBEM_PropertyList));
      pob->m_CurrMeth = 0; 
      pob->m_pCurrMeth = (WBEM_Property *) ((BYTE *)pob->m_pml +
                                    sizeof(WBEM_PropertyList));
   }
}

//***************************************************************************
//
//  CBMOFQualList * GetQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps the objects qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetQualList(CBMOFObj * pob)
{

    WBEM_QualifierList *pql;
    if(pob->m_pob->dwOffsetQualifierList == 0xffffffff)
        return NULL;
    pql = (WBEM_QualifierList *)((BYTE *)pob->m_pInfo+
                            pob->m_pob->dwOffsetQualifierList);
    return CreateQualList(pql);
}


//***************************************************************************
//
//  CBMOFQualList * GetPropQualList
//  CBMOFQualList * GetMethQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps a property or 
//  methods qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Property name.  Note that this is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetPropOrMethQualList(WBEM_Property * pProp)
{
    if(pProp == NULL)
        return NULL;
    if(pProp->dwOffsetQualifierSet == 0xffffffff)
        return NULL;
    return CreateQualList((WBEM_QualifierList *)(
                                    (BYTE *)pProp + sizeof(WBEM_Property)+ 
                                    pProp->dwOffsetQualifierSet));
}

CBMOFQualList * GetPropQualList(CBMOFObj * pob, WCHAR * pName)
{
    WBEM_Property * pProp = FindPropPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

CBMOFQualList * GetMethQualList(CBMOFObj * pob, WCHAR * pName)
{
    WBEM_Property * pProp = FindMethPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

//***************************************************************************
//
//  BOOL NextProp
//  BOOL NextMet
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
///
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL Info(WBEM_Property * pPropOrMeth, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;
    if(pPropOrMeth == NULL)
        return FALSE;

    pInfo = (BYTE *)pPropOrMeth + sizeof(WBEM_Property);
    if(ppName)
       bRet = SetName(ppName, pInfo, pPropOrMeth->dwOffsetName);
    if (bRet && (pItem))
       bRet = SetValue(pItem, pInfo, 
                        pPropOrMeth->dwOffsetValue, 
                        pPropOrMeth->dwType);
    return bRet;
}

BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrProp++ >= pob->m_ppl->dwNumberOfProperties)
        return FALSE;

    bRet = Info(pob->m_pCurrProp, ppName, pItem);

    // advance pointer to next property.

    pob->m_pCurrProp = (WBEM_Property *)
                        ((BYTE *)pob->m_pCurrProp + pob->m_pCurrProp->dwLength);                     
    return bRet;
}

BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrMeth++ >= pob->m_pml->dwNumberOfProperties)
        return FALSE;

    bRet = Info(pob->m_pCurrMeth, ppName, pItem);

    // advance pointer to next method.

    pob->m_pCurrMeth = (WBEM_Property *)
                        ((BYTE *)pob->m_pCurrMeth + pob->m_pCurrMeth->dwLength);                     
    return bRet;
}

//***************************************************************************
//
//  BOOL FindProp
//  BOOL FindMeth
//
//  DESCRIPTION:
//
//  Sets a CBMOFDataItem structure to point to a properties data.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input. Name to be use for case insensitve search.
//  pItem               Input/Output.  Data item stucture to be updated.
//
//  RETURN VALUE:
//
//  True if found.
//
//***************************************************************************

BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    WBEM_Property * pProp = FindPropPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    WBEM_Property * pProp = FindMethPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

//***************************************************************************
//
//  BOOL GetName
//
//  DESCRIPTION:
//
//  Gets the name of an object.  This is works be returning the "__Class"
//  property.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Input/Output.  Points to a WCHAR string which
//                      has the name.  The caller MUST free this via
//                      BMOFFree()
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL GetName(CBMOFObj * pob, WCHAR ** ppName)
{
    CBMOFDataItem Item;
    BOOL bRet = FALSE, bFound;
    if(pob == NULL || ppName == NULL)
        return FALSE;

    bFound = FindProp(pob, L"__Class", &Item);
    if(!bFound)
        return FALSE;
    if(Item.m_dwType == VT_BSTR  && ppName)
    {
        bRet = GetData(&Item, (BYTE *)ppName, NULL);
    }
    return bRet;
}


//***************************************************************************
//
//  DWORD GetType
//
//  DESCRIPTION:
//
//  Returns an objects type.  A 0 indicates a class while a 1 indicates an 
//  instance.  A 0xffffffff if passed a null pointer.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  
//
//  RETURN VALUE:
//
//  See description.
//
//***************************************************************************

DWORD GetType(CBMOFObj * pob)
{
   if(pob)
      return pob->m_pob->dwType;
   else
      return 0xFFFFFFFF;
}

//***************************************************************************
//
//  WBEM_Property * FindPropPtr
//  WBEM_Property * FindMethPtr
//
//  DESCRIPTION:
//
//  Returns a WBEM_Property stucture pointer for a particular property or
//  method given its name.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Name of property.  Comparison is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  pointer to WBEM_Property, NULL if it cant be found.
//
//***************************************************************************

WBEM_Property *  Search(BYTE * pList, DWORD dwListSize, WCHAR * pName)
{
    DWORD dwCnt;
    WBEM_Property * pProp = NULL;

    // point to first property structure

    pProp = (WBEM_Property *)(pList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwListSize; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;

        // point to the property's name and retrieve it

        BYTE * pInfo = (BYTE *)pProp + sizeof(WBEM_Property);
        if(!SetName(&pTest, pInfo, pProp->dwOffsetName))
            return NULL;
        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);

        // If we have a match, return

        if(bMatch)
            return pProp;
        
        pProp = (WBEM_Property *)((BYTE *)pProp + pProp->dwLength);
    }
    return NULL;


}

WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_ppl, pob->m_ppl->dwNumberOfProperties, pName);
}

WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_pml, pob->m_pml->dwNumberOfProperties, pName);
}


//***************************************************************************
//
//  CBMOFObjList * CreateObjList
//
//  DESCRIPTION:
//
//  Create a CBMOFObjList structure which wraps a BMOF file.
//
//  PARAMETERS:
//
//  pBuff                Input, points to start of BMOF file.
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObjList * CreateObjList(BYTE * pBuff)
{
    CBMOFObjList * pRet = (CBMOFObjList * )BMOFAlloc(sizeof(CBMOFObjList));
    if(pRet)
    {
        pRet->m_pol = (WBEM_Binary_MOF *)pBuff;
        pRet->m_pInfo = (WBEM_Object *)
                   ((BYTE *)pBuff + sizeof(WBEM_Binary_MOF));
        ResetObjList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetObjList
//
//  DESCRIPTION:
//
//  Resets a CBMOFObjList structure so that it points to its first object.
//
//  PARAMETERS:
//
//  pol                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObjList(CBMOFObjList * pol)
{
   if(pol)
   {
      pol->m_pCurrObj = pol->m_pInfo;
      pol->m_CurrObj = 0;
   }
}

//***************************************************************************
//
//  CBMOFObj * NextObj
//
//  DESCRIPTION:
//
//  Gets the next object in the list.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * NextObj(CBMOFObjList *pol)
{
    CBMOFObj * pRet;

    if(pol == NULL || pol->m_CurrObj++ >= pol->m_pol->dwNumberOfObjects)
        return NULL;
    
    pRet = CreateObj(pol->m_pCurrObj);
    pol->m_pCurrObj = (WBEM_Object *)((BYTE *)pol->m_pCurrObj + pol->m_pCurrObj->dwLength);
    return pRet;
}


//***************************************************************************
//
//  CBMOFObj * FindObj
//
//  DESCRIPTION:
//
//  Searches the object list for the first object which has a "__className"
//  property.  The search is case insensitive. 
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//  pName               Input. Name of object being searched for
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName)
{
    DWORD dwCnt;
    WBEM_Object * pob;

    if(pol->m_pol == NULL || pName == NULL)
        return NULL;
    
    pob = pol->m_pInfo;
    for(dwCnt = 0; dwCnt < pol->m_pol->dwNumberOfObjects; dwCnt)
    {
        WCHAR * pwcName = NULL;
        BOOL bMatch = FALSE;

        CBMOFObj * pRet = CreateObj(pob);
         if(pRet == NULL)
            return NULL;
        if(GetName(pRet,&pwcName))
            bMatch = TRUE;
        if(pwcName)
            BMOFFree(pwcName);

        // If we found it, return it, otherwise free object and advance

        if(bMatch)
            return pRet;
        BMOFFree(pRet);
        pob = (WBEM_Object *)((BYTE *)pob + pob->dwLength);
    }
    return NULL; 
}


//***************************************************************************
//
//  int GetNumDimensions
//
//  DESCRIPTION:
//
//  Returns the number of dimensions for a data item.
//
//  PARAMETERS:
//
//  pItem               Input.  Item in question.
//
//  RETURN VALUE:
//  -1 if bogus argument, or if the data item doesnt hold data which would
//     be the case for uninitialized properties.
//  0  if non array argument
//  n  Number of dimensions.  Currently only single dimension arrays are
//     supported.
//
//***************************************************************************

int GetNumDimensions(CBMOFDataItem * pItem)
{
   unsigned long * pdwTemp;
   if(pItem == NULL)
      return -1;
   if(!(pItem->m_dwType & VT_ARRAY))
      return 0;
   if(pItem->m_pData == NULL)
      return -1;

   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;        // skip past total size
   return *pdwTemp;
}


//***************************************************************************
//
//  int GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements for an array dimension.  Note that 1 is the
//  first dimenstion.  Currently, only scalars and 1 dimensional arrays are
//  supported.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item in question.
//  lDim                Input.  Dimension in question.  The most significent
//                      (and for now only) dimension is 0.
//
//  RETURN VALUE:
//
//  Number of array elements.  Note that scalars will return -1.
//  
//***************************************************************************

int GetNumElements(CBMOFDataItem * pItem, long lDim)
{
   int iCnt; DWORD * pdwTemp;
   int lNumDim = GetNumDimensions(pItem);
   if(lNumDim == -1 || lDim > lNumDim)
      return -1;
   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;                          // skip total size
   pdwTemp++;                          // skip number of dimensions
   for(iCnt = 0; iCnt < lDim; iCnt++)
      pdwTemp++;
   return *pdwTemp;
}
 

//***************************************************************************
//
//  BYTE * GetDataElemPtr
//
//  DESCRIPTION:
//
//  Used to get the pointer to a particular data element.  Note that this is
//  usually used internally.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//  vtSimple            Input.  Variant type of the data with the VT_ARRAY 
//                      and VT_BYREF bits cleared.              
//
//  RETURN VALUE:
//

//  pointer to the data.
//***************************************************************************

BYTE * GetDataElemPtr(CBMOFDataItem * pItem, long * plDims, DWORD vtSimple)
{
   int iNumDim;
   DWORD dwTotalDataSize;
   BYTE * pEndOfData;
   DWORD * pdwCurr;
   DWORD * pdwCurrObj;
   BYTE * pRow;
   int iCnt;

   // first check the number of dimensions.

   iNumDim = GetNumDimensions(pItem);
   if(iNumDim == -1)
      return NULL;
   if(iNumDim == 0)           // simple case of scalar argument
      return pItem->m_pData;

   // for arrays, the data block starts off with this form, 
   // dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
   // Since currently only 1 dimensional arrays are supported, a 5 element
   // array would start with
   // dwSize, 1, 5

   pdwCurr = (DWORD *)pItem->m_pData;
   dwTotalDataSize = *pdwCurr;
   pEndOfData = pItem->m_pData + dwTotalDataSize;
   pdwCurr+= 2;      // skip to dimension list
   pdwCurr += iNumDim;  // skip of dimension sizes.

   while((BYTE *)pdwCurr < pEndOfData)
   {
      // Each row has the format 
      // dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
      // For a one dimensional array, it would just be
      // dwSizeOfRow, data


      DWORD dwRowSize = *pdwCurr;

      // test if this row is ok.  Each row of data will have 
      // a set of Indicies for each higher dimension.   

      for(iCnt = 0; iCnt < iNumDim-1; iCnt++)
      {
         DWORD * pRowInd = pdwCurr +1 + iCnt;
         if((long)*pRowInd != plDims[iCnt])
            break;

      }
      if(iCnt >= iNumDim -1)
      {
         break;                  // found the row.
      }

      // go to the next row

      pdwCurr = (DWORD *)((BYTE *)pdwCurr + dwRowSize);

   }

   if((BYTE *)pdwCurr >= pEndOfData)
      return NULL;

   pRow = (BYTE *)(pdwCurr + 1 + iNumDim -1);
   for(iCnt = 0; iCnt < plDims[iNumDim-1]; iCnt++)
   {
      if(vtSimple == VT_BSTR)
         pRow += 2*(wcslen((WCHAR *)pRow)+1);
      else if(vtSimple == VT_EMBEDDED_OBJECT)
      {
         // Each embedded object starts off with its own size

         pdwCurrObj = (DWORD *)pRow;
         pRow += *pdwCurrObj;

      }
      else 
         pRow += iTypeSize(vtSimple); 
   }

   return pRow;

}


//***************************************************************************
//
//  int GetData
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  pRet                Input/Output.  Pointer to where the data is to be
//                      copied.  For simple data, such as ints, this can just
//                      be a pointer to an int.  For BSTRs, or embedded 
//                      objects, this is treated as a pointer to a pointer 
//                      and it is the responsibility of the caller to free 
//                      the strings via BMOFFree().
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//                      The first element in any dimension is 0.
//  RETURN VALUE:
//
//  Number of bytes of data.
//***************************************************************************

int GetData(CBMOFDataItem * pItem, BYTE * pRet, long * plDims)
{
   DWORD dwSimple;
   BYTE * pData;
   LONG_PTR UNALIGNED *pLong = (LONG_PTR *)pRet;        // easier for returning strings and embedded objs.
   dwSimple = pItem->m_dwType &~ VT_ARRAY &~VT_BYREF;
   pData = GetDataElemPtr(pItem, plDims, dwSimple);
   if(pData == NULL)
      return 0;
   if(dwSimple == VT_BSTR)
   {

      // For strings, a new WCHAR buffer is returned.  Note that 
      // SysAllocString isnt used so as to avoid any Ole dependencies.

      BYTE * pStr;
      DWORD dwSize = 2*(wcslen((WCHAR *)pData)+1);
      
      pStr = BMOFAlloc(dwSize);

      if (pStr != NULL)
      {
          *pLong = (LONG_PTR)pStr;
          wcscpy((WCHAR *)pStr, (WCHAR *)pData);
      } else {
          dwSize = 0;
      }
      return dwSize;
   }
   else if(dwSimple == VT_EMBEDDED_OBJECT)
   {
      DWORD dwSize;
	  
      // This is the embedded object case.
      *pLong = (LONG_PTR) CreateObj((WBEM_Object *)pData);
	  if ((PVOID)*pLong != NULL)
	  {
		  dwSize = sizeof(long);
	  } else {
		  dwSize = 0;
	  }
      return(dwSize);
   }
   else
   {
      memcpy((void *)pRet, (void *)pData, iTypeSize(dwSimple)); 
      return iTypeSize(dwSimple);
   }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmof\bmofio.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    bmofio.cpp

Abstract:

    Binary mof Win32 subparser for Loc Studio

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#if DEBUG_HEAP
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wbemcli.h>
#include "dllcalls.h"
#include "bmfmisc.h"
#include "mrcicode.h"
#include "bmof.h"


ULONG GenerateMofForObj(
    PMOFFILETARGET MofFileTarget,
    CBMOFObj *Obj
    );

//
// Each class has one or more data items that are described by a MOFDATAITEM
// structure.
typedef struct
{
    PWCHAR Name;
    PWCHAR DataType;                // Method return type
    ULONG Flags;                    // Flags, See MOFDI_FLAG_*
    CBMOFQualList * QualifierList;
} METHODPARAMETER, *PMETHODPARAMETER;

// Data item is actually a fixed sized array
#define MOFDI_FLAG_ARRAY        0x00000001

// Data item is an input method parameter
#define MOFDI_FLAG_INPUT_METHOD       0x00000100

// Data item is an output method parameter
#define MOFDI_FLAG_OUTPUT_METHOD      0x00000200

//
// The MOFCLASSINFO structure describes the format of a data block
typedef struct
{
    PWCHAR ReturnDataType;
    ULONG ParamCount;            // Number of wmi data items (properties)
                                  // Array of Property info
    METHODPARAMETER Parameters[1];
} METHODPARAMLIST, *PMETHODPARAMLIST;


//
// Definitions for WmipAlloc/WmipFree. On debug builds we use our own
// heap. Be aware that heap creation is not serialized.
//
#if 0
#if DEBUG_HEAP
PVOID WmiPrivateHeap;

PVOID _stdcall WmipAlloc(ULONG size)
{
    PVOID p = NULL;
    
    if (WmiPrivateHeap == NULL)
    {
        WmiPrivateHeap = RtlCreateHeap(HEAP_GROWABLE | 
                                      HEAP_TAIL_CHECKING_ENABLED |
                                      HEAP_FREE_CHECKING_ENABLED | 
                                      HEAP_DISABLE_COALESCE_ON_FREE,
                                      NULL,
                                      0,
                                      0,
                                      NULL,
                                      NULL);
    }
    
    if (WmiPrivateHeap != NULL)
    {
        p = RtlAllocateHeap(WmiPrivateHeap, 0, size);
        if (p != NULL)
        {
            memset(p, 0, size);
        }
    }
    return(p);
}

void _stdcall WmipFree(PVOID p)
{
    RtlFreeHeap(WmiPrivateHeap, 0, p);
}
#else
PVOID _stdcall WmipAlloc(ULONG size)
{
    return(LocalAlloc(LPTR, size));
}

void _stdcall WmipFree(PVOID p)
{
    LocalFree(p);
}
#endif
#endif

#define WmipAlloc malloc
#define WmipFree free

//
// Definitions for WmipAssert
//
#if DBG
#define WmipAssert(x) if (! (x) ) { \
    WmipDebugPrint(("BMOFLocParser Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    DebugBreak(); }
#else
#define WmipAssert(x)
#endif


//
// WmipDebugPrint definitions
//
#if DBG
#define WmipDebugPrint(x) WmiDebugPrint x

VOID
WmiDebugPrint(
    PCHAR DebugMessage,
    ...
    )
/*++

Routine Description:

    Debug print for properties pages - stolen from classpnp\class.c

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    #define DEBUG_BUFFER_LENGTH 512
    static CHAR WmiBuffer[DEBUG_BUFFER_LENGTH];

    va_list ap;

    va_start(ap, DebugMessage);

    _vsnprintf(WmiBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

    OutputDebugStringA(WmiBuffer);

    va_end(ap);

} // end WmiDebugPrint()


#else
#define WmipDebugPrint(x)
#endif


ULONG AnsiToUnicode(
    LPCSTR pszA,
    LPWSTR *ppszW
    )
/*++

Routine Description:

    Convert Ansi string into its Unicode equivalent

Arguments:

    pszA is ansi string to convert

    *ppszW on entry has a pointer to a unicode string into which the answer
        is written. If NULL on entry then a buffer is allocated and  returned
    in it.

Return Value:

    Error code

--*/
{
    ULONG cCharacters;
    ULONG Status;
    ULONG cbUnicodeUsed;

    //
    // If input is null then just return the same.
    if (pszA == NULL)
    {
        *ppszW = NULL;
        return(ERROR_SUCCESS);
    }

    //
    // Determine the count of characters needed for Unicode string
    cCharacters = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    if (cCharacters == 0)
    {
        *ppszW = NULL;
        return(GetLastError());
    }

    // Convert to Unicode
    cbUnicodeUsed = MultiByteToWideChar(CP_ACP, 0, pszA, -1, *ppszW, cCharacters);
    
    if (0 == cbUnicodeUsed)
    {
        Status = GetLastError();
        return(Status);
    }

    return(ERROR_SUCCESS);
}

ULONG AppendFileToFile(
    TCHAR *DestFile,
    TCHAR *SrcFile
    )
{
    #define READ_BLOCK_SIZE 0x8000
    
    HANDLE DestHandle, SrcHandle;
    ULONG BytesRead, BytesWritten;
    PUCHAR Buffer;
    BOOL b;
    ULONG Status = ERROR_SUCCESS;

    Buffer = (PUCHAR)WmipAlloc(READ_BLOCK_SIZE);
    if (Buffer != NULL)
    {
        DestHandle = CreateFile(DestFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (DestHandle != INVALID_HANDLE_VALUE)
        {
            SrcHandle = CreateFile(SrcFile,
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
            if (SrcHandle != INVALID_HANDLE_VALUE)
            {
                b = SetFilePointer(DestHandle,
                                   0,
                                   NULL,
                                   FILE_END);
                if (b)
                {
                    do
                    {
                        b = ReadFile(SrcHandle,
                                     Buffer,
                                     READ_BLOCK_SIZE,
                                     &BytesRead,
                                     NULL);
                        if (b)
                        {
                            b = WriteFile(DestHandle,
                                          Buffer,
                                          BytesRead,
                                          &BytesWritten,
                                          NULL);
                            if (!b)
                            {                           
                                Status = GetLastError();
                                break;
                            } else if (BytesWritten != BytesRead) {
                                Status = ERROR_BAD_LENGTH;
                                break;
                            }
                        } else { 
                            Status = GetLastError();
                            break;
                        }
                    } while (BytesRead == READ_BLOCK_SIZE);
                } else {
                    Status = GetLastError();
                }
                CloseHandle(SrcHandle);
            } else {
                Status = GetLastError();
            }
            CloseHandle(DestHandle);
        } else {
            Status = GetLastError();
        }
        WmipFree(Buffer);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status); 
}

BOOLEAN ConvertMofToBmf(
    TCHAR *MofFile,
    TCHAR *EnglishMofFile,
    TCHAR *BmfFile
    )
{
    WBEM_COMPILE_STATUS_INFO info;
    SCODE sc;
    LONG OptionFlags, ClassFlags, InstanceFlags;
    PWCHAR NameSpace;
    WCHAR MofFileStatic[MAX_PATH];
    WCHAR BmfFileStatic[MAX_PATH];
    PWCHAR BmfFileW, MofFileW;
    BOOLEAN Success;
    ULONG Status;

    if (*EnglishMofFile != 0)
    {
        Status = AppendFileToFile(MofFile, EnglishMofFile);
        if (Status != ERROR_SUCCESS)
        {
            return(FALSE);
        }
    }
    
#if 0
    OutputDebugString(MofFile);
    OutputDebugString("\n");
    DebugBreak();
#endif  
    
    NameSpace = L"";
    OptionFlags = 0;
    ClassFlags = 0;
    InstanceFlags = 0;

    MofFileW = MofFileStatic;
    Status = AnsiToUnicode(MofFile, &MofFileW);

    if ((Status == ERROR_SUCCESS) &&
        (MofFileW != NULL))
    {
        BmfFileW = BmfFileStatic;
        Status = AnsiToUnicode(BmfFile, &BmfFileW);

        if ((Status == ERROR_SUCCESS) &&
            (BmfFileW != NULL))
        {
            sc = CreateBMOFViaDLL( MofFileW,
                                   BmfFileW,
                                   NameSpace,
                                   OptionFlags,
                                   ClassFlags,
                                   InstanceFlags,
                                   &info);
            Success = (sc == S_OK);
        } else {
            Success = FALSE;
        }
    } else {
        Success = FALSE;
    }
    
    return(Success);
}

ULONG FilePrintVaList(
    HANDLE FileHandle,
    WCHAR *Format,
    va_list pArg
    )
{
    WCHAR Buffer[8192];
    ULONG Size, Written;
    ULONG Status;

    Size = _vsnwprintf(Buffer, sizeof(Buffer)/sizeof(WCHAR), Format, pArg);
    if (WriteFile(FileHandle,
                       Buffer,
                       Size * sizeof(WCHAR),
                       &Written,
                       NULL))
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }

    return(Status);
}

ULONG FilePrint(
    PMOFFILETARGET MofFileTarget,
    WCHAR *Format,
    ...
    )
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(MofFileTarget->MofHandle, Format, pArg);

    if ((MofFileTarget->WriteToEnglish) &&
        (Status == ERROR_SUCCESS) &&
        (MofFileTarget->EnglishMofHandle != NULL))
    {
        Status = FilePrintVaList(MofFileTarget->EnglishMofHandle, Format, pArg);
    }
    
    return(Status);
}

ULONG FilePrintToHandle(
    HANDLE FileHandle,
    WCHAR *Format,
    ...
    )
{
    ULONG Status;
    va_list pArg;

    va_start(pArg, Format);
    Status = FilePrintVaList(FileHandle, Format, pArg);

    return(Status);
}


ULONG WmipDecompressBuffer(
    IN PUCHAR CompressedBuffer,
    OUT PUCHAR *UncompressedBuffer,
    OUT ULONG *UncompressedSize
    )
/*++

Routine Description:

    This routine will decompress a compressed MOF blob into a buffer
    that can be used to interpert the blob.

Arguments:

    CompressedBuffer points at the compressed MOF blob

    *UncompressedBuffer returns with a pointer to the uncompressed
        MOF blob

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PBMOFCOMPRESSEDHEADER CompressedHeader = (PBMOFCOMPRESSEDHEADER)CompressedBuffer;
    BYTE *Buffer;
    ULONG Status;

    if ((CompressedHeader->Signature != BMOF_SIG) ||
        (CompressedHeader->CompressionType != 1))
    {
        // TODO: LocStudio message
        WmipDebugPrint(("WMI: Invalid compressed mof header\n"));
        Status = ERROR_INVALID_PARAMETER;
    } else {
        Buffer = (BYTE *)WmipAlloc(CompressedHeader->UncompressedSize);
        if (Buffer == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            *UncompressedSize = Mrci1Decompress(&CompressedHeader->Buffer[0],
                                               CompressedHeader->CompressedSize,
                                               Buffer,
                                               CompressedHeader->UncompressedSize);

            if (*UncompressedSize != CompressedHeader->UncompressedSize)
            {
                // TODO: LocStudioMessage
                WmipDebugPrint(("WMI: Invalid compressed mof buffer\n"));
                WmipFree(Buffer);
                Status = ERROR_INVALID_PARAMETER;
            } else {
                *UncompressedBuffer = Buffer;
                Status = ERROR_SUCCESS;
            }
        }
    }
    return(Status);
}

ULONG WmipFindMofQualifier(
    CBMOFQualList *QualifierList,
    LPCWSTR QualifierName,
    DWORD *QualifierType,
    DWORD *NumberElements,
    PVOID QualifierValueBuffer
    )
/*++

Routine Description:

    This routine will find a MOF qualifier within the qualifier list passed,
    ensure that its type matches the type requested and return the qualifier's
    value

Arguments:

    QualifierList is the MOF qualifier list

    QualifierName is the name of the qualifier to search for

    *QualifierType on entry has the qualifier type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *QualifierType is 0xffffffff then any qualifier type is acceptable

    *NumberElements returns the number of elements in the array if the result
        of the qualifier is an array

    QualifierValueBuffer points to a buffer that returns the value of the
        qualifier. If the qualifier is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    CBMOFDataItem MofDataItem;
    ULONG Status;
    PUCHAR List, ListPtr;
    ULONG BaseTypeSize;
    LONG ElementCount;
    LONG i;

    if (QualifierList == NULL)
    {
        return(ERROR_FILE_NOT_FOUND);
    }
    
    if (FindQual(QualifierList, (PWCHAR)QualifierName, &MofDataItem))
    {
        if ((*QualifierType != 0xffffffff) &&
            (MofDataItem.m_dwType != *QualifierType))
        {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (MofDataItem.m_dwType & VT_ARRAY)
        {
            if (MofDataItem.m_dwType == (VT_BSTR | VT_ARRAY))
            {
                BaseTypeSize = sizeof(PWCHAR);
            } else {
                BaseTypeSize = iTypeSize(MofDataItem.m_dwType);
            }

            ElementCount = GetNumElements(&MofDataItem, 0);
            if (NumberElements != NULL)
            {
                *NumberElements = ElementCount;
            }

            if (ElementCount != -1)
            {
               List = (PUCHAR)WmipAlloc(ElementCount * BaseTypeSize);
               if (List != NULL)
               {
                   ListPtr = List;
                   for (i = 0; i < ElementCount; i++)
                   {
                       if ((GetData(&MofDataItem,
                                   (BYTE *)ListPtr,
                                   &i)) == 0)
                       {
                           WmipFree(List);
                           Status = ERROR_INVALID_PARAMETER;
                           return(Status);
                       }
                       ListPtr += BaseTypeSize;
                   }
                   Status = ERROR_SUCCESS;
                   *QualifierType = MofDataItem.m_dwType;
                   *((PVOID *)QualifierValueBuffer) = List;
               } else {
                   Status = ERROR_NOT_ENOUGH_MEMORY;
               }
			}
        } else {
            if (GetData(&MofDataItem, (BYTE *)QualifierValueBuffer, 0) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            } else {
                *QualifierType = MofDataItem.m_dwType;
                Status = ERROR_SUCCESS;
            }
        }
    } else {
        Status = ERROR_FILE_NOT_FOUND;
    }
    return(Status);
}

ULONG WmipFindProperty(
    CBMOFObj * ClassObject,
    WCHAR * PropertyName,
    CBMOFDataItem *MofPropertyData,
    DWORD *ValueType,
    PVOID ValueBuffer
    )
/*++

Routine Description:

    This routine will find a named property within a class object

Arguments:

    ClassObject is the class object in which to search

    PropertyName is the name of the property to search for

    MofPropertyData returns with the property data

    *ValueType on entry has the property data type being searched for. On exit
        it has the actual qualifier type for the qualifier value. If on entry
        *ValueType is 0xffffffff then any data type is acceptable

    ValueBuffer points to a buffer that returns the value of the
        property. If the property is a simple type (int or int64) then
        the value is returned in the buffer. If qualifier value is a string
        then a pointer to the string is returned in the buffer

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status;

    if (FindProp(ClassObject, PropertyName, MofPropertyData))
    {
        if ((*ValueType != 0xffffffff) &&
            (MofPropertyData->m_dwType != *ValueType))
        {
            Status = ERROR_INVALID_PARAMETER;
        }

        if (GetData(MofPropertyData, (BYTE *)ValueBuffer, 0) == 0)
        {
            Status = ERROR_INVALID_PARAMETER;
        } else {
            *ValueType = MofPropertyData->m_dwType;
            Status = ERROR_SUCCESS;
        }
    } else {
        Status = ERROR_FILE_NOT_FOUND;
    }
    return(Status);
}

PWCHAR AddSlashesToString(
    PWCHAR SlashedNamespace,
    PWCHAR Namespace
    )
{
    PWCHAR Return = SlashedNamespace;
    
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one
    //
    while (*Namespace != 0)
    {
        if (*Namespace == L'\\')
        {
            *SlashedNamespace++ = L'\\';
        }
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}


ULONG GenerateDataValueFromVariant(
    PMOFFILETARGET MofFileTarget,
    VARIANT *var
    )
{
    SCODE sc;
    VARIANT vTemp;
    ULONG Status;
    PWCHAR String;

    //
    // Uninitialized data will have a VT_NULL type.
    //
    if (var->vt == VT_NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // String types can just be dumped.
    //
    if (var->vt == VT_BSTR)
    {
        String = (PWCHAR)WmipAlloc(((wcslen(var->bstrVal)) *
                                    sizeof(WCHAR) * 2) + sizeof(WCHAR));
        if (String != NULL)
        {       
            Status = FilePrint(MofFileTarget,
                           L"\"%ws\"",
                           AddSlashesToString(String, var->bstrVal));
            WmipFree(String);
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        return(Status);
    }

    //
    // References need to be maintained
    //
    if (var->vt == (VT_BSTR | VT_BYREF))
    {
        String = (PWCHAR)WmipAlloc(((wcslen(var->bstrVal)) *
                                    sizeof(WCHAR) * 2) + sizeof(WCHAR));
        if (String != NULL)
        {       
            Status = FilePrint(MofFileTarget,
                           L"$%ws",
                           AddSlashesToString(String, var->bstrVal));
            WmipFree(String);
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        return(Status);
    }

	
    //
    // Embedded classes, so recurse in to display the contents of it
    //
    if (var->vt == VT_UNKNOWN)
    {
        CBMOFObj * pObj;
        
        WmipDebugPrint(("BMOFLocParser: Data is an embeeded object %p\n",
                        var));        
        pObj = (CBMOFObj *)var->bstrVal;
        Status = GenerateMofForObj(MofFileTarget,
                                   pObj);
        return(Status);
     }

    if (var->vt == VT_BOOL)
    {
        if (var->boolVal)
        {
            Status = FilePrint(MofFileTarget, L"%ws", L"TRUE");
        } else {
            Status = FilePrint(MofFileTarget, L"%ws", L"FALSE");
        }
        return(Status);
    }
    
    //
    // For non string data, convert the infomation to a bstr and display it.
    //
    VariantInit(&vTemp);
    sc = VariantChangeTypeEx(&vTemp, var,0,0, VT_BSTR);
    if (sc == S_OK)
    {
        Status = FilePrint(MofFileTarget,
                           L"%ws",
                           vTemp.bstrVal);
        VariantClear(&vTemp);
    } else {
        Status = sc;        
    }
    
    return(Status);
}

ULONG GenerateDataValue(
    PMOFFILETARGET MofFileTarget,
    CBMOFDataItem *Item
    )
{
    DWORD Type, SimpleType;
    long NumDim, i;
    long FirstDim;
    VARIANT var;
    BOOLEAN FirstIndex;
    ULONG Status = ERROR_SUCCESS;

    //
    // Determine the data type and clear out the variant
    //
    Type = Item->m_dwType;
    SimpleType = Type & ~VT_ARRAY; 
    memset((void *)&var.lVal, 0, 8);

    NumDim = GetNumDimensions(Item);
  
    if (NumDim == 0)    
    {
        //
        // handle the simple scalar case.  Note that uninitialized properties
        // will not have data.
        //
        if(GetData(Item, (BYTE *)&(var.lVal), NULL))
        {
            var.vt = (VARTYPE)SimpleType;
            Status = GenerateDataValueFromVariant(MofFileTarget,
                                                  &var);

            if (var.vt == VT_BSTR)
            {
               BMOFFree(var.bstrVal);
            }
        }
    } else if (NumDim == 1) {
        //
        // For the array case, just loop getting each element.
        // Start by getting the number of elements
        //
        FirstDim = GetNumElements(Item, 0);
        
		Status = ERROR_SUCCESS;

        FirstIndex = TRUE;
        
        for (i = 0; (i < FirstDim) && (Status == ERROR_SUCCESS); i++)
        {
            if (! FirstIndex)
            {
                FilePrint(MofFileTarget,
                          L", ");
            } else {
                FirstIndex = FALSE;
            }
            
            if (GetData(Item, (BYTE *)&(var.lVal), &i))
            {
                var.vt = (VARTYPE)SimpleType;
                Status = GenerateDataValueFromVariant(MofFileTarget,
                                                      &var);

               if(var.vt == VT_BSTR)
               {
                  BMOFFree(var.bstrVal);
               }
            }
        }
    } else {
        //
        // Currently undefined and multidimension arrays are not
        // supported.
        //
        WmipDebugPrint(("BMOFLocParser: Multi dimensional arrays not supported\n"));
        WmipAssert(FALSE);
        Status = ERROR_INVALID_PARAMETER;
    }

    return(Status);
}

#define MAX_FLAVOR_TEXT_SIZE MAX_PATH

WCHAR *FlavorToText(
    WCHAR *ClassFlagsText,
    ULONG ClassFlags
    )
{
    PWCHAR CommaText;

    //
    // TODO: FInd any undocumented flavors
    //

    
    CommaText = L"";    
    *ClassFlagsText = 0;

    if (ClassFlags & FlavorAmended)
    {
        //
        // since this is the first if, we can assume that a , would
        // never be needed
        //
        wcscat(ClassFlagsText, L"amended");
        CommaText = L",";
    }

    if (ClassFlags & FlavorDisableOverride)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"DisableOverride");
        CommaText = L",";
    }

    if (ClassFlags & FlavorToSubclass)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"ToSubclass");
        CommaText = L",";
    }

    if (ClassFlags & FlavorToInstance)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"ToInstance");
        CommaText = L",";
    }

    WmipAssert(*ClassFlagsText != 0);

    WmipDebugPrint(("BmofLocParser:        Flavor : %ws\n", ClassFlagsText));

    return(ClassFlagsText); 
}


ULONG GenerateQualifierList(
    PMOFFILETARGET MofFileTarget,
    CBMOFQualList * QualifierList,
    BOOLEAN SkipId
    )
{
    WCHAR *Name = NULL;
    CBMOFDataItem Item;
    BOOLEAN FirstQualifier;
    WCHAR OpenChar, CloseChar;
    ULONG Status = ERROR_SUCCESS;
    ULONG Flavor = 0;
    WCHAR s[MAX_FLAVOR_TEXT_SIZE];

    FirstQualifier = TRUE;
    ResetQualList(QualifierList);

    while ((Status == ERROR_SUCCESS) &&
           (NextQualEx(QualifierList,
                       &Name,
                       &Item,
                       &Flavor,
                       MofFileTarget->UncompressedBlob)))
    {
        //
        // TODO: if this is a mofcomp generated qualifier then we want
        // to ignore it
        //
        if (_wcsicmp(Name, L"CIMTYPE") == 0)
        {
            // must skip CIMTYPE qualifier
            continue;
        }

        if ((SkipId)  && _wcsicmp(Name, L"ID") == 0)
        {
            // If we want to skip the ID qualifier then do so
            continue;
        }
        
        if (FirstQualifier)
        {
            Status = FilePrint(MofFileTarget,
                               L"[");
            FirstQualifier = FALSE; 
        } else {
            Status = FilePrint(MofFileTarget,
                               L",\r\n ");
        }

        if (Status == ERROR_SUCCESS)
        {
            //
            // Arrays use {} to enclose the value of the qualifier
            // while scalers use ()
            //
            if (Item.m_dwType & VT_ARRAY)
            {
                OpenChar = L'{';
                CloseChar = L'}';
            } else {
                OpenChar = L'(';
                CloseChar = L')';
            }

            Status = FilePrint(MofFileTarget,
                               L"%ws%wc",
                               Name, OpenChar);

            if (Status == ERROR_SUCCESS)
            {
                Status = GenerateDataValue(MofFileTarget,
                                           &Item);

                if (Status == ERROR_SUCCESS)
                {
                    Status = FilePrint(MofFileTarget,
                                       L"%wc",
                                       CloseChar);
                    if ((Status == ERROR_SUCCESS) && (Flavor != 0))
                    {
                        Status = FilePrint(MofFileTarget,
                                           L": %ws",
                                           FlavorToText(s, Flavor));
                    }
                }
            }
        }
        
        BMOFFree(Name);
        Flavor = 0;
    }

    if ((Status == ERROR_SUCCESS) && ! FirstQualifier)
    {
        //
        // if we had generated qualifiers then we need a closing ]
        //
        Status = FilePrint(MofFileTarget,
                           L"]\r\n");
    }
    return(Status);
}

PWCHAR GeneratePropertyName(
    PWCHAR StringPtr
    )
{
    #define ObjectTextLen  ( ((sizeof(L"object:") / sizeof(WCHAR)) - 1) )
    PWCHAR PropertyType;
    
    //
    // If CIMTYPE begins with object: then it is an embedded object
    // and we need to skip the object: in the MOF generation
    //
    if (_wcsnicmp(StringPtr, L"object:", ObjectTextLen) == 0)
    {
        PropertyType = StringPtr + ObjectTextLen;
    } else {
        PropertyType = StringPtr;
    }
    return(PropertyType);
}

ULONG GenerateProperty(
    PMOFFILETARGET MofFileTarget,
    PWCHAR PropertyName,
    BOOLEAN IsInstance,
    CBMOFQualList * QualifierList,
    CBMOFDataItem *Property
    )
{
    DWORD QualifierType;
    WCHAR *StringPtr;
    ULONG Status;
    PWCHAR ArraySuffix;
    PWCHAR PropertyType;
    PWCHAR ArrayText;

    QualifierType = VT_BSTR;
    Status = WmipFindMofQualifier(QualifierList,
                                  L"CIMTYPE",
                                  &QualifierType,
                                  NULL,
                                  (PVOID)&StringPtr);

    if (IsInstance)
    {
        //
        // Property is within an instance definition
        //
        Status = FilePrint(MofFileTarget,
                           L"%ws = ",
                           PropertyName);

        if (Status == ERROR_SUCCESS)
        {
            if (Property->m_dwType & VT_ARRAY)
            {
                //
                // use {} around arrays
                //
                Status = FilePrint(MofFileTarget,
                                   L"{ ");
                ArrayText = L"};";
            } else if (Property->m_dwType == VT_UNKNOWN) {
                ArrayText = L"";
            } else {
                ArrayText = L";";               
            }
            
            if (Status == ERROR_SUCCESS)
            {
                Status = GenerateDataValue(MofFileTarget,
                                           Property);
                if (Status == ERROR_SUCCESS)
                {
                    Status = FilePrint(MofFileTarget,
                                           L"%ws\r\n",
                                           ArrayText);
                }
            }
        }        
    } else {
        //
        // Property is within a class definition, so just worry about
        // defining it.
        //
        if (Status == ERROR_SUCCESS)
        {
            PropertyType = GeneratePropertyName(StringPtr);
        
            if (Property->m_dwType & VT_ARRAY)
            {
                ArraySuffix = L"[]";
            } else {
                ArraySuffix = L"";
            }

            WmipDebugPrint(("BmofLocParser:      %ws %ws%ws\n",
                               PropertyType,
                               PropertyName,
                               ArraySuffix));
                            
            Status = FilePrint(MofFileTarget,
                               L"%ws %ws%ws;\r\n",
                               PropertyType,
                               PropertyName,
                               ArraySuffix);
            BMOFFree(StringPtr);
        }
    }

    return(Status);
}

ULONG GetDataItemCount(
    CBMOFObj * ClassObject,
    PWCHAR QualifierToFind
    )
/*++

Routine Description:

    This routine will count the number of WMI data items in the class and
    the total number of properties in the class.

Arguments:

    ClassObject is class for which we count the number of data items

    *TotalCount returns the total number of properties

Return Value:

    Count of methods

--*/
{
    CBMOFQualList *PropQualifierList;
    CBMOFDataItem MofPropertyData;
    DWORD QualifierType;
    ULONG Counter = 0;
    WCHAR *PropertyName;
    ULONG Status;
    ULONG Index;

    ResetObj(ClassObject);
    while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
    {
        PropQualifierList = GetPropQualList(ClassObject, PropertyName);
        if (PropQualifierList != NULL)
        {
            //
            // Get the id of the property so we know it order in class
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(PropQualifierList,
                                          QualifierToFind,
                                          &QualifierType,
                                          NULL,
                                          (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                Counter++;
            }
        }
        BMOFFree(PropertyName);
    }

    return(Counter);
}


ULONG ParseMethodInOutObject(
    CBMOFObj *ClassObject,
    PMETHODPARAMLIST ParamList,
    ULONG DataItemCount
)
/*++

Routine Description:

    This routine will parse a class object that is either the in or out
    parameters for a method.

Arguments:

    ClassObject is the in or out parameter class object to parse

    ClassInfo returns updated with information from ClassObject

    DataItemCount is the number of data items in the ClassInfo

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    ULONG Status;
    CBMOFDataItem MofPropertyData;
    PWCHAR PropertyName = NULL;
    ULONG Index;
    PMETHODPARAMETER MethodParam;
    CBMOFQualList *QualifierList = NULL;
    DWORD QualifierType;
    short BooleanValue;
    PWCHAR StringPtr;

    ResetObj(ClassObject);
    while (NextProp(ClassObject, &PropertyName, &MofPropertyData))
    {
        QualifierList = GetPropQualList(ClassObject, PropertyName);
        if (QualifierList != NULL)
        {

            //
            // Get the id of the property so we know its order in class
            //
            QualifierType = VT_I4;
            Status = WmipFindMofQualifier(QualifierList,
                                              L"Id",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&Index);
            if (Status == ERROR_SUCCESS)
            {
                //
                // Method ids are 0 based
                //
                if (Index < DataItemCount)
                {
                    //
                    // Valid data item id, make sure it already isn't
                    // in use. Note that we could have the same property
                    // be in both the in and the out class objects
                    //
                    MethodParam = &ParamList->Parameters[Index];

                    //
                    // If there is already an existing qualifier list
                    // attached then we free it and tag the new
                    // qualifier list to the parameter. Both lists
                    // should have all of the non [in] / [out]
                    // qualifiers
                    //
                    if (MethodParam->QualifierList != NULL)
                    {
                        BMOFFree(MethodParam->QualifierList);
                    }
                    MethodParam->QualifierList = QualifierList;

                    //
                    // See if this is an input, output or both
                    //
                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(QualifierList,
                                              L"in",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MethodParam->Flags |= MOFDI_FLAG_INPUT_METHOD;
                    }

                    QualifierType = VT_BOOL;
                    Status = WmipFindMofQualifier(QualifierList,
                                              L"out",
                                              &QualifierType,
                                              NULL,
                                              (PVOID)&BooleanValue);
                    if ((Status == ERROR_SUCCESS) && BooleanValue)
                    {
                        MethodParam->Flags |= MOFDI_FLAG_OUTPUT_METHOD;
                    }


                    //
                    // If there is already a name and its the same as
                    // ours then free the old name and use the new one.
                    // If the names are different then we have a binary
                    // mof error
                    //
                    if (MethodParam->Name != NULL)
                    {
                        if (wcscmp(MethodParam->Name, PropertyName) != 0)
                        {
                            //
                            // id already in use, but a different name
                            //
                            BMOFFree(PropertyName);
                            Status = ERROR_FILE_NOT_FOUND;
                            goto done;
                        } else {
                            //
                            // This is a duplicate so just free up the
                            // memory used and decrement the total
                            // count of parameters in the list. The
                            // data obtained the last time should still
                            // be valid
                            //
                            ParamList->ParamCount--;
                            BMOFFree(PropertyName);
                            continue;
                        }
                    }

                    MethodParam->Name = PropertyName;

                    //
                    // Now figure out the data type for the parameter
                    // and the array status
                    //
                    if (MofPropertyData.m_dwType & VT_ARRAY)
                    {
                        MethodParam->Flags |= MOFDI_FLAG_ARRAY;
                    }

                    QualifierType = VT_BSTR;
                    Status = WmipFindMofQualifier(QualifierList,
                                                  L"CIMTYPE",
                                                  &QualifierType,
                                                  NULL,
                                                  (PVOID)&StringPtr);

                    if (Status == ERROR_SUCCESS)
                    {
                        MethodParam->DataType = StringPtr;
                    }
                                                            
                } else {
                    //
                    // Method ID qualifier is out of range
                    //
                    BMOFFree(QualifierList);
                    Status = ERROR_FILE_NOT_FOUND;
                    goto done;
                }
            } else {
                //
                // Check if this is the special ReturnValue parameter
                // on the output parameter object. If so extract the
                // return type, otherwise flag an error in the binary
                // mof
                //
                if (_wcsicmp(L"ReturnValue", PropertyName) == 0)
                {
                    QualifierType = VT_BSTR;
                    Status = WmipFindMofQualifier(QualifierList,
                                                  L"CIMTYPE",
                                                  &QualifierType,
                                                  NULL,
                                                  (PVOID)&StringPtr);

                    if (Status == ERROR_SUCCESS)
                    {
                        BMOFFree(ParamList->ReturnDataType);
                        ParamList->ReturnDataType = StringPtr;
                    }
                    
                } else {
                    Status = ERROR_FILE_NOT_FOUND;
                    goto done;
                }
                BMOFFree(PropertyName);
                BMOFFree(QualifierList);
            }
        } else {
            BMOFFree(PropertyName);
        }
    }

done:

    return(Status);
}


ULONG ParseMethodParameterObjects(
    IN CBMOFObj *InObject,
    IN CBMOFObj *OutObject,
    OUT PMETHODPARAMLIST *MethodParamList
    )
/*++

Routine Description:

    This routine will parse the in and out method parameter obejcts to create
    a MOFCLASSINFO that describes the method call.

Arguments:

    InObject is the object with the input parameters

    OutObject is the object with the output parameters

    *ClassInfo returns with the class info for the method call

Return Value:

    ERROR_SUCCESS or a WMI Mof error code (see wmiump.h)

--*/
{
    PMETHODPARAMLIST ParamList;
    ULONG Status;
    ULONG DataItemCount;
    ULONG InItemCount, OutItemCount;
    ULONG Size;
    PMETHODPARAMETER MethodParameter;
    PWCHAR StringPtr;

    Status = ERROR_SUCCESS;
    
    if (InObject != NULL)
    {
        ResetObj(InObject);
        InItemCount = GetDataItemCount(InObject, L"Id");
    } else {
        InItemCount = 0;
    }

    if (OutObject != NULL)
    {
        ResetObj(OutObject);
        OutItemCount = GetDataItemCount(OutObject, L"Id");
    } else {
        OutItemCount = 0;
    }

    DataItemCount = InItemCount + OutItemCount;

    Size = sizeof(METHODPARAMLIST) + DataItemCount * sizeof(METHODPARAMETER);
    ParamList = (PMETHODPARAMLIST)WmipAlloc(Size);
    if (ParamList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get the essential information to fill in the parameter list
    memset(ParamList, 0, Size);
    ParamList->ParamCount = DataItemCount;

    StringPtr = (PWCHAR)BMOFAlloc( sizeof(L"void") + sizeof(WCHAR) );
    if (StringPtr != NULL)
    {
        wcscpy(StringPtr, L"void");
        ParamList->ReturnDataType = StringPtr;
    } else {
        BMOFFree(ParamList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    //
    // Parse the input parameter class object
    //
    if (InObject != NULL)
    {
        Status = ParseMethodInOutObject(InObject,
                                        ParamList,
                                        DataItemCount);
    } else {
        Status = ERROR_SUCCESS;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        if (OutObject != NULL)
        {
            //
            // Parse the output parameter class object
            //
            Status = ParseMethodInOutObject(OutObject,
                                            ParamList,
                                            DataItemCount);
        }
    }

    *MethodParamList = ParamList;

    return(Status);
}


ULONG ParseMethodParameters(
    CBMOFDataItem *MofMethodData,
    PMETHODPARAMLIST *MethodParamList
)
{
    ULONG Status = ERROR_SUCCESS;
    CBMOFObj *InObject;
    CBMOFObj *OutObject;
    LONG i;
    ULONG NumberDimensions;
    ULONG NumberElements;
    VARIANT InVar, OutVar;
    DWORD SimpleType;

    *MethodParamList = NULL;
    
    SimpleType = MofMethodData->m_dwType & ~VT_ARRAY & ~VT_BYREF;

    NumberDimensions = GetNumDimensions(MofMethodData);
    if (NumberDimensions > 0)
    {
        NumberElements = GetNumElements(MofMethodData, 0);
        WmipAssert(NumberDimensions == 1);
        WmipAssert((NumberElements == 1) || (NumberElements == 2));

        i = 0;
        memset((void *)&InVar.lVal, 0, 8);

        if (GetData(MofMethodData, (BYTE *)&(InVar.lVal), &i))
        {
            InObject = (CBMOFObj *)InVar.bstrVal;
            InVar.vt = (VARTYPE)SimpleType;
            WmipAssert(InVar.vt ==  VT_UNKNOWN);

            if (NumberElements == 2)
            {
                i = 1;
                memset((void *)&OutVar.lVal, 0, 8);
                if (GetData(MofMethodData, (BYTE *)&(OutVar.lVal), &i))
                {
                    OutVar.vt = (VARTYPE)SimpleType;
                    WmipAssert(OutVar.vt ==  VT_UNKNOWN);
                    OutObject = (CBMOFObj *)OutVar.bstrVal;
                } else {
                    Status = ERROR_FILE_NOT_FOUND;
                }
            } else {
                OutObject = NULL;
            }
        } else {
            Status = ERROR_FILE_NOT_FOUND;
        }
    } else {
        InObject = NULL;
        OutObject = NULL;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = ParseMethodParameterObjects(InObject,
                                                 OutObject,
                                                 MethodParamList);
    }

    return(Status);
}



ULONG GenerateMethod(
    PMOFFILETARGET MofFileTarget,
    PWCHAR MethodName,
    BOOLEAN IsInstance,
    CBMOFQualList * QualifierList,
    CBMOFDataItem *Method
    )                    
{
    ULONG Status;
    PMETHODPARAMLIST MethodList;
    ULONG i;
    PWCHAR ArraySuffix;
    PMETHODPARAMETER MethodParam;
    
    Status = ParseMethodParameters(Method,
                                   &MethodList);

    if (Status == ERROR_SUCCESS)
    {
        Status = FilePrint(MofFileTarget,
                           L"%ws %ws( ",
                           GeneratePropertyName(MethodList->ReturnDataType),
                           MethodName);

        if (Status == ERROR_SUCCESS)
        {
            for (i = 0;
                 ((Status == ERROR_SUCCESS) &&
                  (i < MethodList->ParamCount));
                 i++)
            {
                if (i != 0)
                {
                    Status = FilePrint(MofFileTarget,
                                       L"\r\n,");
                }

                if (Status == ERROR_SUCCESS)
                {
                    MethodParam = &MethodList->Parameters[i];
                    Status = GenerateQualifierList(MofFileTarget,
                                                   MethodParam->QualifierList,
                                                   TRUE);
                    if (Status == ERROR_SUCCESS)
                    {
                        if (MethodParam->Flags & MOFDI_FLAG_ARRAY)
                        {
                            ArraySuffix = L"[]";
                        } else {
                            ArraySuffix = L"";
                        }
                        
                        Status = FilePrint(MofFileTarget,
                                           L"%ws %ws%ws",
                                           GeneratePropertyName(MethodParam->DataType),
                                           MethodParam->Name,
                                           ArraySuffix);
                    }
                }
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            Status = FilePrint(MofFileTarget,
                      L");\r\n");
        }       
    }

    //
    // Free all memory used to build method parameter list
    //
    if (MethodList != NULL)
    {       
        for (i = 0; i < MethodList->ParamCount; i++)
        {
            MethodParam = &MethodList->Parameters[i];
        
            if (MethodParam->QualifierList != NULL)
            {
                BMOFFree(MethodParam->QualifierList);
            }

            if (MethodParam->Name != NULL)
            {
                BMOFFree(MethodParam->Name);
            }
        
            if (MethodParam->DataType != NULL)
            {
                BMOFFree(MethodParam->DataType);
            }
        }
    
        if (MethodList->ReturnDataType != NULL)
        {
            BMOFFree(MethodList->ReturnDataType);
        }
    
        WmipFree(MethodList);
    }
        
    return(Status);
}

ULONG GenerateMofForObj(
    PMOFFILETARGET MofFileTarget,
    CBMOFObj *Obj
    )
{
    CBMOFQualList * QualifierList;
    CBMOFDataItem Property, Method;
    WCHAR *Name = NULL;
    ULONG Status;
    BOOLEAN IsInstance;
    DWORD ObjType;
    PWCHAR Text;
    CBMOFDataItem MofPropertyData;
    PWCHAR SuperClass, Separator;
    PWCHAR EmptyString = L"";
    ULONG DataType;
    PWCHAR Alias, AliasSeparator;
            
    //
    // First display the class qualifier list
    //
    QualifierList = GetQualList(Obj);
    if(QualifierList != NULL)
    {
        Status = GenerateQualifierList(MofFileTarget,
                                       QualifierList,
                                       FALSE);
        BMOFFree(QualifierList);

        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }
    
    //
    // Now determine if this is a class or instance and display the class name
    //
    ObjType = GetType(Obj);
    switch (ObjType)
    {
        case MofObjectTypeClass:
        {
            IsInstance = FALSE;
            Text = L"class";
            break;
        }

        case MofObjectTypeInstance:
        {
            IsInstance = TRUE;
            Text = L"instance of";
            break;
        }

        default:
        {
            WmipDebugPrint(("BMOFLocParser: Unknown class object type 0x%x\n",
                            ObjType));
            WmipAssert(FALSE);
            return(ERROR_INVALID_PARAMETER);
        }
    }

    //
    // See if there is a superclass, that is if this class was derrived
    // from another
    //
    DataType = VT_BSTR;
    Status = WmipFindProperty(Obj,
                              L"__SUPERCLASS",
                              &MofPropertyData,
                              &DataType,
                              (PVOID)&SuperClass);
    switch (Status)
    {
        case ERROR_SUCCESS:
        {
            //
            // This class is derrived from another
            //
            Separator = L":";
            break;
        }

        case ERROR_FILE_NOT_FOUND:
        {
            //
            // This class is not derrived from another
            //
            SuperClass = EmptyString;
            Separator = EmptyString;
            break;
        }


        default:
        {
            //
            // Something is wrong, return an error
            //
            return(Status);
        }
    }


    //
    // See if there is an alias defined for this class
    //
    DataType = VT_BSTR;
    Status = WmipFindProperty(Obj,
                              L"__ALIAS",
                              &MofPropertyData,
                              &DataType,
                              (PVOID)&Alias);
    switch (Status)
    {
        case ERROR_SUCCESS:
        {
            //
            // This class is derrived from another
            //
            AliasSeparator = L" as $";
            break;
        }

        case ERROR_FILE_NOT_FOUND:
        {
            //
            // This class is not derrived from another
            //
            Alias = EmptyString;
            AliasSeparator = EmptyString;
            break;
        }


        default:
        {
            //
            // Something is wrong, return an error
            //
            return(Status);
        }
    }
    
    
    
    if (GetName(Obj, &Name))
    {
        WmipDebugPrint(("BmofLocParser: Parsing -> %ws %ws %ws %ws\n",
                  Text,
                  Name,
                  Separator,
                  SuperClass));
                        
        Status = FilePrint(MofFileTarget,
                  L"%ws %ws %ws %ws%ws%ws\r\n{\r\n",
                  Text,
                  Name,
                  Separator,
                  SuperClass,
                  AliasSeparator,
                  Alias);
        BMOFFree(Name);
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (SuperClass != EmptyString)
    {
        BMOFFree(SuperClass);
    }
    
    //
    // Now generate each property and its qualifiers
    //
    ResetObj(Obj);
    
    while ((Status == ERROR_SUCCESS) && (NextProp(Obj, &Name, &Property)))
    {
        //
        // Ignore any system property, that is, all those that begin
        // with __
        //
        if ( (Name[0] == L'_') && (Name[1] == L'_') )
        {
            WmipDebugPrint(("BmofLocParser:      Skipping system property %ws\n",
                            Name));
            BMOFFree(Name);
            continue;
        }
        
        QualifierList = GetPropQualList(Obj, Name);
        if (QualifierList != NULL)
        {
            Status = GenerateQualifierList(MofFileTarget,
                                           QualifierList,
                                           FALSE);
        }
            
        if (Status == ERROR_SUCCESS)
        {
            WmipDebugPrint(("BmofLocParser:      Parsing property %ws\n",
                            Name));
            Status = GenerateProperty(MofFileTarget,
                                      Name,
                                      IsInstance,
                                      QualifierList,
                                      &Property);
        }

        if (QualifierList != NULL)
        {
            BMOFFree(QualifierList);
        }

        BMOFFree(Name);
    }
    
    //
    // Next we generate all of the methods and their qualifiers
    //
    while ((Status == ERROR_SUCCESS) && (NextMeth(Obj, &Name, &Method)))
    {
        QualifierList = GetMethQualList(Obj, Name);
        if (QualifierList != NULL)
        {
            Status = GenerateQualifierList(MofFileTarget,
                                           QualifierList,
                                           FALSE);
        }

        if (Status == ERROR_SUCCESS)
        {               
            WmipDebugPrint(("BmofLocParser:      Parsing method %ws\n",
                            Name));
            Status = GenerateMethod(MofFileTarget,
                                    Name,
                                    IsInstance,
                                    QualifierList,
                                    &Method);
        }

        if (QualifierList != NULL)
        {
            BMOFFree(QualifierList);
        }

        BMOFFree(Name);
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // Closing brace for class definition
        //
        Status = FilePrint(MofFileTarget,
                           L"};\r\n\r\n");
    }

    return(Status);
}

PWCHAR MakeClassInstanceFlagsText(
    PWCHAR ClassFlagsText,
    ULONG ClassFlags
    )
{
    PWCHAR CommaText;

    //
    // TODO: FInd any undocumented flags
    //

    
    CommaText = L"";    
    *ClassFlagsText = 0;

    if (ClassFlags & 1)
    {
        //
        // since this is the first if, we can assume that a , would
        // never be needed
        //
        wcscat(ClassFlagsText, L"\"updateonly\"");
        CommaText = L",";
    }

    if (ClassFlags & 2)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"\"createonly\"");
        CommaText = L",";
    }

    if (ClassFlags & 32)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"\"safeupdate\"");
        CommaText = L",";
    }

    if (ClassFlags & 64)
    {
        wcscat(ClassFlagsText, CommaText);
        wcscat(ClassFlagsText, L"\"forceupdate\"");
        CommaText = L",";
    }

    WmipAssert(*ClassFlagsText != 0);
    
    return(ClassFlagsText);
}

ULONG WatchClassInstanceFlags(
    PMOFFILETARGET MofFileTarget,
    CBMOFObj *Obj,
    PWCHAR ClassName,
    PWCHAR PragmaName,
    LONG *Flags
)
{
    ULONG Status;
    LONG NewFlags;
    WCHAR FlagsText[MAX_PATH];
    ULONG DataType;
    CBMOFDataItem Property;
    
    DataType = VT_I4;
    Status = WmipFindProperty(Obj,
                              ClassName,
                              &Property,
                              &DataType,
                              &NewFlags);
        
    if (Status == ERROR_SUCCESS)
    {   
        if (*Flags != NewFlags)
        {
            //
            // Flags have just appeared or
            // changed so spit out a #pragma
            //
            WmipDebugPrint(("BmofLocParser: %ws changed to %ws\n",
                            PragmaName,
                               MakeClassInstanceFlagsText(FlagsText,
                                                          NewFlags)));
                            
            Status = FilePrint(MofFileTarget,
                               L"\r\n#pragma %ws(%ws)\r\n\r\n",
                               PragmaName,
                               MakeClassInstanceFlagsText(FlagsText,
                                                          NewFlags));
            *Flags = NewFlags;
        }
                        
    } else if (Status == ERROR_FILE_NOT_FOUND) {
        Status = ERROR_SUCCESS;
    }
    
    return(Status);
}

ULONG WatchForEnglishMof(
    PMOFFILETARGET MofFileTarget,
    PWCHAR Namespace,
    ULONG ClassFlags,
    CBMOFObj *Obj
    )
{
    WCHAR *Name = NULL;
    WCHAR *NamespaceName = NULL;
    ULONG DataType;
    CBMOFDataItem MofPropertyData;
    ULONG Status;
    WCHAR s[MAX_PATH];
    
    //
    // We are looking for an instance of __namespace
    //
    if (GetName(Obj, &Name))
    {
        if ( (GetType(Obj) == MofObjectTypeInstance) &&
             (_wcsicmp(Name, L"__namespace") == 0) )          
        {
            //
            // Now if we are dropping down to a namespace that ends in
            // ms_409 then that means we have an english amendment and
            // want to make a copy of it. Otherwise we want to stop
            // making copies. We determine the namespace we are
            // creating by looking at the value of the name property.
            //
            DataType = VT_BSTR;
            Status = WmipFindProperty(Obj,
                                      L"name",
                                      &MofPropertyData,
                                      &DataType,
                                      (PVOID)&NamespaceName);
            if (Status == ERROR_SUCCESS)
            {
                if (_wcsicmp(NamespaceName, L"ms_409") == 0)
                {
                    //
                    // moving to the english locale, so start writing
                    // english
                    //
                    MofFileTarget->WriteToEnglish = TRUE;
                    Status = FilePrintToHandle(MofFileTarget->EnglishMofHandle,
                                       L"\r\n\r\n"
                                       L"#pragma classflags(%d)\r\n"
                                       L"#pragma namespace(\"%ws\")\r\n",
                                       ClassFlags,
                                       AddSlashesToString(s, Namespace));
                                       
                } else {
                    //
                    // moving to a different locale, so stop writing
                    // english
                    //
                    MofFileTarget->WriteToEnglish = FALSE;
                }
                BMOFFree(NamespaceName);
            } else if (Status == ERROR_FILE_NOT_FOUND) {
                //
                // Did not find the property we wanted. Not a good
                // thing, but not fatal.
                //
                Status = ERROR_SUCCESS;
            }
        } else {
            Status = ERROR_SUCCESS;
        }
        
        BMOFFree(Name);
    } else {
        Status = ERROR_SUCCESS;
    }
    return(Status);
}

BOOLEAN ConvertBmfToMof(
    PUCHAR BinaryMofData,
    TCHAR *MofFile,
    TCHAR *EnglishMofFile
    )
{
    HANDLE FileHandle;
    ULONG Status;
    CBMOFObjList *ObjList;
    CBMOFObj *Obj;
    PUCHAR UncompressedBmof;
    ULONG UncompressedBmofSize;
    WCHAR Namespace[MAX_PATH];
    PWCHAR NewNamespace;
    ULONG DataType;
    CBMOFDataItem Property;
    LONG ClassFlags, InstanceFlags;
    WCHAR w;
    MOFFILETARGET MofFileTarget;
    
    //
    // First thing is to try to create the output files in which we will
    // generate the unicode MOF text
    //
    FileHandle = CreateFile(MofFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if (FileHandle != INVALID_HANDLE_VALUE)
    {
        //
        // Now open english mof file
        //
        if (*EnglishMofFile != 0)
        {
            MofFileTarget.EnglishMofHandle = CreateFile(EnglishMofFile,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        } else {
            MofFileTarget.EnglishMofHandle = NULL;
        }

        if (MofFileTarget.EnglishMofHandle != INVALID_HANDLE_VALUE)
        {
            //
            // Initialize the mof file target information
            //
            MofFileTarget.MofHandle = FileHandle;
            MofFileTarget.WriteToEnglish = FALSE;
            
            //
            // Write magic header that signifies that this is a unicode
            // file
            //
            w = 0xfeff;
            Status = FilePrintToHandle(FileHandle,
                               L"%wc",
                               w);
            
            if (Status == ERROR_SUCCESS)
            {       
                //
                // Uncompress the binary mof data so that we can work with it
                //
                Status = WmipDecompressBuffer(BinaryMofData,
                                              &UncompressedBmof,
                                              &UncompressedBmofSize);
                
                if (Status == ERROR_SUCCESS)
                {
                    WmipDebugPrint(("BmofLocParser: %s uncompressed to %d bytes\n",
                                    MofFile, UncompressedBmofSize));
                    WmipAssert(UncompressedBmof != NULL);
                    MofFileTarget.UncompressedBlob = UncompressedBmof;
                    
                    //
                    // We start in the root\default namespace by default
                    //
                    wcscpy(Namespace, L"root\\default");
                    
                    ClassFlags = 0;
                    InstanceFlags = 0;
                    
                    //
                    // Create the binary mof object list and related structures
                    // so that we can later enumerate over them and
                    // reconstitute them back into unicode text
                    //
                    ObjList = CreateObjList(UncompressedBmof);
                    if(ObjList != NULL)
                    {
                        ResetObjList(ObjList);
                        
                        while ((Obj = NextObj(ObjList)) &&
                               (Status == ERROR_SUCCESS))
                        {

                            //
                            // Watch for a new namespace instance and
                            // see if we are create an instance for
                            // "\\\\.\\root\\wmi\\ms_409". If so then
                            // turn on writing to the english mof,
                            // otherwise turn it off
                            //
                            if (MofFileTarget.EnglishMofHandle != NULL)
                            {
                                Status = WatchForEnglishMof(&MofFileTarget,
                                                        Namespace,
                                                        ClassFlags,
                                                        Obj);
                            }

                            if (Status == ERROR_SUCCESS)
                            {
                                //
                                // Watch for change in namespace and if so then
                                // spit out a #pragma namespace to track it
                                //
                                DataType = VT_BSTR;
                                Status = WmipFindProperty(Obj,
                                    L"__NAMESPACE",
                                    &Property,
                                    &DataType,
                                    (PVOID)&NewNamespace);
                            }
                            
                            if (Status == ERROR_SUCCESS)
                            {
                                if (_wcsicmp(Namespace, NewNamespace) != 0)
                                {
                                    //
                                    // Namespace has changed, spit out a
                                    // #pragma
                                    //
                                    WmipDebugPrint(("BmofLocParser: Switching from namespace %ws to %ws\n",
                                        Namespace, NewNamespace));
                                
                                    Status = FilePrint(&MofFileTarget,
                                        L"\r\n#pragma namespace(\"%ws\")\r\n\r\n",
                                        AddSlashesToString(Namespace, NewNamespace));
                                    wcscpy(Namespace, NewNamespace);
                                }
                                BMOFFree(NewNamespace);                        
                            } else if (Status == ERROR_FILE_NOT_FOUND) {
                                Status = ERROR_SUCCESS;
                            }
                            
                            //
                            // Watch for change in classflags
                            //
                            if (Status == ERROR_SUCCESS)
                            {
                                Status = WatchClassInstanceFlags(&MofFileTarget,
                                    Obj,
                                    L"__ClassFlags",
                                    L"Classflags",
                                    &ClassFlags);
                            }
                            
                            //
                            // Watch for change in instance flags
                            //
                            if (Status == ERROR_SUCCESS)
                            {
                                Status = WatchClassInstanceFlags(&MofFileTarget,
                                    Obj,
                                    L"__InstanceFlags",
                                    L"Instanceflags",
                                    &InstanceFlags);
                            }
                            
                            
                            //
                            // Generate mof for this object
                            //
                            if (Status == ERROR_SUCCESS)
                            {
                                Status = GenerateMofForObj(&MofFileTarget,
                                    Obj);
                            }
                            BMOFFree(Obj);
                        }
                        
                        BMOFFree(ObjList);
                    } else {
                        // TODO: LocStudio message
                        Status = ERROR_INVALID_PARAMETER;
                    }
                    
                    WmipFree(UncompressedBmof);
                }
            }
            
            CloseHandle(FileHandle);
            if (MofFileTarget.EnglishMofHandle != NULL)
            {
                CloseHandle(MofFileTarget.EnglishMofHandle);                
            }
            
            if (Status != ERROR_SUCCESS)
            {
                //
                // There was some error generating the MOF text and we are
                // going to return a failure. Make sure to clean up any
                // temporary file created
                //
                WmipDebugPrint(("BmofLocParser: BMF parsing returns error %d\n",
                                Status));
#if 0               
                DebugBreak();
#endif              
                
                DeleteFile(MofFile);
                DeleteFile(EnglishMofFile);
            }

        } else {
            CloseHandle(FileHandle);
            DeleteFile(MofFile);
			Status = GetLastError();
        }
    } else {
        Status = GetLastError();
    }
    
    return((Status == ERROR_SUCCESS) ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmof\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#include "mrcicode.h"                   /* prototype verification */

//#define NDEBUG                          /* turn off assertions */
#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return (unsigned)(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return (unsigned)(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return (unsigned)((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return (unsigned)((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\clasfact.cpp ===
//------------------------------------------------------------------------------
//
//  File: classfact.cpp
//  Copyright (C) 1995-1997 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  Implementation of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//  Owner:
//
//------------------------------------------------------------------------------
	    
#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"
#include "impresob.H"

#include "clasfact.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor - Member Data Init
//
//------------------------------------------------------------------------------
CLocImpClassFactory::CLocImpClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor - Object clean up
//
//------------------------------------------------------------------------------
CLocImpClassFactory::~CLocImpClassFactory()
{
	LTASSERT(m_uiRefCount == 0);
	DEBUGONLY(AssertValid());

	DecrementClassCount();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Increase Reference count on the object
//
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::AddRef(void)
{
	return ++m_uiRefCount;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrease Reference count on the object - destroy the object on the last
//  release
//
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::Release(void)
{
	LTASSERT(m_uiRefCount != 0);
	
	m_uiRefCount--;
	
	if (m_uiRefCount == 0)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query for other interfaces
//
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;
	
	if (iid == IID_IUnknown)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (iid == IID_IClassFactory)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}
	
	if (sc == S_OK)
	{
		AddRef();
	}
	return ResultFromScode(sc);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create a instance of the object with the given IID
//
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;
	
	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CLocImpResObj *pResObj = new CLocImpResObj;

			sc = pResObj->QueryInterface(iid, ppvObj);

			pResObj->Release();

		}
		catch (CMemoryException *pMem)
		{
			sc = E_OUTOFMEMORY;
			pMem->Delete();
		}
		catch (...)
		{
			sc = E_UNEXPECTED;
		}
	}

	return ResultFromScode(sc);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Not implemented
//
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::LockServer(
		BOOL)
{
	return E_NOTIMPL;
}


#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 
//
//------------------------------------------------------------------------------
void
CLocImpClassFactory::AssertValid(void)
		const
{
	CLObject::AssertValid();

	//More than 100 refs would probably mean an error somewhere.
	//Bump this up if needed.
	LTASSERT(m_uiRefCount >= 0 || m_uiRefCount < 100);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Dump the contents of this object
//
//------------------------------------------------------------------------------
void
CLocImpClassFactory::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);

	dc << _T("Reference Count ");
	dc << m_uiRefCount;
	dc << _T("\n");
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmof\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


TARGETNAME=wmibmof
TARGETTYPE=LIBRARY

INCLUDES=..;..\..\inc;$(PROJECT_ROOT)\published\wmi\inc;$(BASE_INC_PATH)

C_DEFINES=$(C_DEFINES) -D__MIDL_USER_DEFINED

SOURCES_LIST= \
        bmof.c \
        mrcicode.c \
        bmofio.cpp
	
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\dllvars.h ===
//-----------------------------------------------------------------------------
//  
//  File: dllvars.h
//  
//  Global variables and functions for the parser DLL
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef __DLLVARS_H
#define __DLLVARS_H


void IncrementClassCount(void);
void DecrementClassCount(void);
void ReportException(CException* pExcep, C32File* p32File, CLocItem* pItem, 		//May be null
	CReporter* pReporter);
void ThrowItemSetException();

class CItemSetException : public CException
{
	DECLARE_DYNAMIC(CItemSetException)

public:
// Constructors
	CItemSetException();
	CItemSetException(BOOL bAutoDelete);

// Operations
	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext = NULL);

protected:
	CLString m_strMsg;
};

#ifdef __DLLENTRY_CPP
#define __DLLENTRY_EXTERN 
#else
#define __DLLENTRY_EXTERN extern
#endif

__DLLENTRY_EXTERN HMODULE g_hDll;


#endif //__DLLVARS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\clasfact.h ===
//------------------------------------------------------------------------------
//
//  File: classfact.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Declaration of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef CLASSFACT_H
#define CLASSFACT_H

class CLocImpClassFactory : public IClassFactory, public CLObject
{
public:
	CLocImpClassFactory();
	~CLocImpClassFactory();

#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif
	
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

	
private:
	UINT m_uiRefCount;			//Object reference count
	
};


#endif // CLASSFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\impbin.cpp ===
//TODO: change CSampleBinary to the name of your binary object

//-----------------------------------------------------------------------------
//  
//  File: IMPBIN.CPP 
//  
//  Implementation of a CLocBinary Class
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"

#include "dllvars.h"

#include "impbin.h"

#include "misc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
// CSampleBinary

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Default constructor provided for the CreateBinaryObject call
//
//------------------------------------------------------------------------------
CSampleBinary::CSampleBinary()
{
	MemberDataInit();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Destructor and member clean up  
//
//------------------------------------------------------------------------------
CSampleBinary::~CSampleBinary()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Init member data items
//
//------------------------------------------------------------------------------
void 
CSampleBinary::MemberDataInit()
{
	//TODO: Init data
}


//
//  Serialization routines.
//

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Serialize the binary
//
//------------------------------------------------------------------------------
void CSampleBinary::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		//TODO:
	}
	else
	{
		//TODO:
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Compare the contents of this binary with the binary passed.
//
//------------------------------------------------------------------------------
CLocBinary::CompareCode 
CSampleBinary::Compare (const CLocBinary *pComp)
{
	//TODO: Some real compare 
	UNREFERENCED_PARAMETER(pComp);
	//TODO change btSample and pidBMOF

	LTASSERT((BinaryId)MAKELONG(btBMOF, pidBMOF) == pComp->GetBinaryId());
	
	//If anything has changed that is localizable return fullChange
	//If only non localizable data has changed return partialChange
	//If the two are identical return noChange

	return noChange;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Copy the non localizable data from pBinsource to this object
//
//------------------------------------------------------------------------------
void 
CSampleBinary::PartialUpdate(const CLocBinary * pBinSource)
{
	//TODO
	UNREFERENCED_PARAMETER(pBinSource);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the property from this object.  Return FALSE for 
//  properties not implemented
//
//------------------------------------------------------------------------------
BOOL 
CSampleBinary::GetProp(const Property prop, CLocVariant &vRet) const
{
	UNREFERENCED_PARAMETER(vRet);
	//TODO
	BOOL bRet = TRUE;
	switch(prop)
	{
	case p_dwXPosition:
		break;
	case p_dwYPosition:
		break;
	case p_dwXDimension:
		break;
	case p_dwYDimension:
		break;
	default:
		bRet = FALSE;
		break;
	}
	return bRet;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Set this binary property.  Return FALSE for 
//  properties not implemented
//
//------------------------------------------------------------------------------
BOOL 
CSampleBinary::SetProp(const Property prop, const CLocVariant &var)
{
	UNREFERENCED_PARAMETER(var);
	//TODO
	BOOL bRet = TRUE;
	switch(prop)
	{
	case p_dwXPosition:
		break;
	case p_dwYPosition:
		break;
	case p_dwXDimension:
		break;
	case p_dwYDimension:
		break;
	default:
		bRet = FALSE;
		break;
	}
	return bRet;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Attempt to convert the binary in the CLocItem passed to the new type
//
//------------------------------------------------------------------------------
BOOL 
CSampleBinary::Convert(CLocItem *)
{
	//TODO:
	return FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Sub parser IDs have the PARSERID in the HIWORD and the 
// Binary ID in the LOWWORD
//-----------------------------------------------------------------------------
BinaryId 
CSampleBinary::GetBinaryId(void) const
{
	return (BinaryId)MAKELONG(btBMOF, pidBMOF); //TODO: change to real
	                                              //binary AND parser ID 
}


#ifdef _DEBUG
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Perform asserts on member data
//
//------------------------------------------------------------------------------
void CSampleBinary::AssertValid(void) const
{
	CLocBinary::AssertValid();

	//TODO: Assert any member variable. 
	//Note: use LTASSERT instead of ASSERT
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump the contents of the binary object
//
//------------------------------------------------------------------------------
void CSampleBinary::Dump(CDumpContext &dc) const
{
	CLocBinary::Dump(dc);
	dc << _T("CSampleBinary Dump\n");
	//TODO: dump contents of any member variables
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\dllentry.cpp ===
//------------------------------------------------------------------------------
//
//  File: dllentry.cpp
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Defines the initialization routines for the DLL.
//
//  This file needs minor changes, as marked by TODO comments. However, the
//  functions herein are only called by the system, Espresso, or the framework,
//  and you should not need to look at them extensively.
//
//	Owner:
//
//------------------------------------------------------------------------------


#include "stdafx.h"

#include "clasfact.h"

#include "win32sub.h"

#include "impbin.h"

#include "misc.h"

#include "resource.h"
#define __DLLENTRY_CPP
#include "dllvars.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

LONG g_lActiveClasses = 0;	//Glbal count of active class in the DLL

static AFX_EXTENSION_MODULE g_parseDLL = { NULL, NULL };
CItemSetException g_SetException(FALSE);

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	DLL Main entry
//
//------------------------------------------------------------------------------
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);
	int nRet = 1; //OK
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		LTTRACE("BMOF.DLL Initializing!\n");  //TODO - change name
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(g_parseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(g_parseDLL);
		g_hDll = hInstance;


	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		LTTRACE("BMOF.DLL Terminating!\n");  //TODO - change name

		// Remove this DLL from MFC's list of extensions
		AfxTermExtensionModule(g_parseDLL);

		//
		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...
		//
		LTASSERT(DllCanUnloadNow() == S_OK);
		AfxTermExtensionModule(g_parseDLL);
	}
	return nRet;
}

// TODO: Use GUIDGEN.EXE to replace this class ID with a unique one.
// GUIDGEN is supplied with MSDEV (VC++ 4.0) as part of the OLE support stuff.
// Run it and you'll get a little dialog box. Pick radio button 3, "static
// const struct GUID = {...}". Click on the "New GUID" button, then the "Copy"
// button, which puts the result in the clipboard. From there, you can just
// paste it into here. Just remember to change the type to CLSID!

// {8B75CD76-DFC1-4356-AC04-AF088B448AB3}
static const CLSID ciImpParserCLSID = 
{ 0x8b75cd76, 0xdfc1, 0x4356, { 0xac, 0x4, 0xaf, 0x8, 0x8b, 0x44, 0x8a, 0xb3 } };

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Return the CLSID of the parser
//
//------------------------------------------------------------------------------
STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)
{
	ciParserCLSID = ciImpParserCLSID;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to register this parser. Calls base implementation in ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllRegisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	try
	{
		hr = RegisterParser(g_hDll);
	}
	catch (CException* pE)
	{
		pE->Delete();
	}
	catch (...)
	{
	}

	return ResultFromScode(hr);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to unregister this parser. Calls the base implementation in
//  ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllUnregisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	try
	{
		//TODO**: Change pidBMOF to real sub parser ID
		hr = UnregisterParser(pidBMOF, pidWin32);   
	}
	catch (CException* pE)
	{
		pE->Delete();
	}
	catch (...)
	{
	}

	return ResultFromScode(hr);
}

	
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the class factory for the requested class ID
//
//------------------------------------------------------------------------------
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,
		REFIID iid,
		LPVOID *ppClassFactory)
{
	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciImpParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CLocImpClassFactory *pClassFactory;

			pClassFactory = new CLocImpClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMem)
		{
			sc = E_OUTOFMEMORY;
			pMem->Delete();
		}
		catch (CException* pE)
		{
			sc = E_UNEXPECTED;
			pE->Delete();
		}
		catch (...)
		{
			sc = E_UNEXPECTED;
		}
	}
	
	return ResultFromScode(sc);
}

   

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return true if the parser can be unloaded
//
//------------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
	SCODE sc = (g_lActiveClasses == 0) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Increment the global count of active classes
//
//------------------------------------------------------------------------------
void
IncrementClassCount(void)
{
	InterlockedIncrement(&g_lActiveClasses);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrement the global count of active classes
//
//------------------------------------------------------------------------------
void
DecrementClassCount(void)
{
	LTASSERT(g_lActiveClasses != 0);
	
	InterlockedDecrement(&g_lActiveClasses);

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Throw a item set exception 
//
//------------------------------------------------------------------------------
void
ThrowItemSetException()
{
	throw &g_SetException;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Report a error through the reporter.  This function will never
//  fail or throw an exception out of the function.
//
//------------------------------------------------------------------------------
void
ReportException(
	CException* pExcep,		//May be null
	C32File* p32File, 		//May be null
	CLocItem* pItem, 		//May be null
	CReporter* pReporter)
{

	LTASSERT(NULL != pReporter);
	
	//Don't let this function throw an exception since it is normally called
	//within exception catch blocks

	try
	{
		CLString strContext;

		if (NULL != p32File)
		{
			strContext = p32File->GetFile()->GetFilePath();
		}
		else
		{
			LTVERIFY(strContext.LoadString(g_hDll, IDS_IMP_DESC));
		}

		CLString strExcep;
		BOOL bErrorFormatted = FALSE;

		if (NULL != pExcep)
		{
			bErrorFormatted = 
				pExcep->GetErrorMessage(strExcep.GetBuffer(512), 512);
			strExcep.ReleaseBuffer();
		}

		if (!bErrorFormatted || NULL == pExcep)
		{
			LTVERIFY(strExcep.LoadString(g_hDll, IDS_IMP_UNKNOWN_ERROR));
		}

		CLString strResId;
		if (NULL != pItem)
		{
			CPascalString pasResId;
			pItem->GetUniqueId().GetResId().GetDisplayableId(pasResId);
			pasResId.ConvertToCLString(strResId, CP_ACP);
		}

		CLString strMsg;
		strMsg.Format(g_hDll, IDS_ERR_EXCEPTION, (LPCTSTR)strResId,
			(LPCTSTR)strExcep);

		CContext ctx(strContext, pItem->GetMyDatabaseId(), otResource, vProjWindow);
		
		pReporter->IssueMessage(esError, ctx, strMsg);

	}
	catch(CException* pE)
	{
		LTASSERT(0 && _T("Could not issue a exception message"));
		pE->Delete();
	}
	catch(...)
	{
		LTASSERT(0 && _T("Could not issue a exception message"));
	}

}


////////////////////////////////////////////////////////////////////////////////
//  CItemSetException
//

IMPLEMENT_DYNAMIC(CItemSetException, CException)

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// 	Default contructor
//
//------------------------------------------------------------------------------
CItemSetException::CItemSetException()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Constructor
//
//------------------------------------------------------------------------------
CItemSetException::CItemSetException(BOOL bAutoDelete)
    :CException(bAutoDelete)
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Fill passed buffer with a error message for this exception.
// The message is cached and only retrieved 1 time. 
//
//------------------------------------------------------------------------------
BOOL
CItemSetException::GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext)
{
	LTASSERT(lpszError != NULL && AfxIsValidString(lpszError, nMaxError));

	if (NULL != pnHelpContext)
	{
		*pnHelpContext = 0;  //unused
	}

	if (m_strMsg.IsEmpty())
	{
		LTVERIFY(m_strMsg.LoadString(g_hDll, IDS_EXCEP_ITEMSET));
	}

	int nMax = min(nMaxError, (UINT)m_strMsg.GetLength() + 1);
	_tcsncpy(lpszError, m_strMsg, nMax - 1);

	lpszError[nMax] = _T('\0');

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\impresob.h ===
//-----------------------------------------------------------------------------
//  
//  File: impresob.h
//  
//  Declare the implementation of the ICreateResObj interface
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef IMPRESOB_H
#define IMPRESOB_H

class CLocImpResObj : public ICreateResObj2, public CLObject
{
public:
	CLocImpResObj();

	~CLocImpResObj();

	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ICreateResObj interfaces
	//
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ C32File * p32file, 
		CLocItem * pLocItem, DWORD dwSize, void * pvHeader);
	STDMETHOD_(void, OnCreateWin32File)(THIS_ C32File*);
	STDMETHOD_(void, OnDestroyWin32File)(THIS_ C32File*);

	STDMETHOD_(BOOL, OnBeginEnumerate)(THIS_ C32File*);
	STDMETHOD_(BOOL, OnEndEnumerate)(THIS_ C32File*, BOOL bOK);
	STDMETHOD_(BOOL, OnBeginGenerate)(THIS_ C32File*);
	STDMETHOD_(BOOL, OnEndGenerate)(THIS_ C32File*, BOOL bOK);

	//
	//  CLObject implementation
	//
#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif

private:
	//
	//  Implementation for IUnknown and ILocParser.
	ULONG m_ulRefCount;

	// Embedded class for ILocBinary interface
	class CLocImpBinary : public ILocBinary, public CLObject
	{
		friend CLocImpResObj;
	public:
		CLocImpBinary();
		~CLocImpBinary();

		//
		//  Standard IUnknown methods
		//
		STDMETHOD_(ULONG, AddRef)(); 
		STDMETHOD_(ULONG, Release)(); 
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

		//
		//  Standard Debugging interface.
		//
		STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

		//
		// ILocBinary interface
		//
		STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE);
		//
		//  CLObject implementation
		//
	#ifdef _DEBUG
		void AssertValid(void) const;
		void Dump(CDumpContext &) const;
	#endif

		
	private:
		CLocImpResObj *m_pParent;

	} m_IBinary;

	// Embedded class for ILocParser
	class CLocImpParser : public ILocParser, public CLObject
	{
		friend CLocImpResObj;
	public:
		CLocImpParser();
		~CLocImpParser();
		//
		//  Standard IUnknown methods
		//
		STDMETHOD_(ULONG, AddRef)(); 
		STDMETHOD_(ULONG, Release)(); 
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
		//
		//  Standard Debugging interfaces
		//
		STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;
		//
		//  ILocParser interfaces
		//
		STDMETHOD(Init)(IUnknown *);
		
		STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType);

		STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
			CONST_METHOD;
		STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &) CONST_METHOD;
		//
		//  CLObject implementation
		//
	#ifdef _DEBUG
		void AssertValid(void) const;
		void Dump(CDumpContext &) const;
	#endif
		
	private:
		CLocImpResObj *m_pParent;

	} m_IParser;

};


#endif //IMPRESOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\impresob.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: IMPRESOB.CPP
//  
//  Implementation of the ICreateRecObj class
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"

#include "impbin.h"
#include "win32sub.h"
#include "impresob.h"
#include "sampres.h"
#include "samplver.h"

#include "misc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor and member init
//
//------------------------------------------------------------------------------
CLocImpResObj::CLocImpResObj()
{
	
	m_ulRefCount = 0;
	m_IBinary.m_pParent = this;
	m_IParser.m_pParent = this;

	AddRef();
	IncrementClassCount();

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor and member clean up
//
//------------------------------------------------------------------------------
CLocImpResObj::~CLocImpResObj()
{

	DEBUGONLY(AssertValid());
	LTASSERT(m_ulRefCount == 0);

	DecrementClassCount();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Add to the reference count on the object. Return the new count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::AddRef(void)
{
	DEBUGONLY(AssertValid());

	return ++m_ulRefCount;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Subtract from the reference count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::Release(void)
{
	DEBUGONLY(AssertValid());

	LTASSERT(m_ulRefCount != 0);

	m_ulRefCount--;

	if (m_ulRefCount == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRefCount;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query for the passed IID. Interfaces not implemented on this object
//  are implemented as embedded objects.  If the interface is found
//  the reference count in increased.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLocImpResObj::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	DEBUGONLY(AssertValid());

	SCODE scResult = E_NOINTERFACE;

	*ppvObj = NULL;

	if (iid == IID_IUnknown)
	{
		*ppvObj = (IUnknown *)this;
		scResult = S_OK;
	}
	else if (iid == IID_ICreateResObj2)
	{
		*ppvObj = (ICreateResObj2 *)this;
		scResult = S_OK;		
	}
	else if (iid == IID_ILocBinary)
	{
		LTASSERT(NULL != m_IBinary.m_pParent);
		*ppvObj = &m_IBinary;
		scResult = S_OK;		
	}
	else if (iid == IID_ILocParser)
	{
		LTASSERT(NULL != m_IParser.m_pParent);
		*ppvObj = &m_IParser;
		scResult = S_OK;		
	}
	else if (iid == IID_ILocVersion)
	{
		*ppvObj = (ILocVersion *) new CLocSamplVersion(this);
		scResult = S_OK;		
	}

	if (scResult == S_OK)
	{
		AddRef();
	}
	
	return ResultFromScode(scResult);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert this interface
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::AssertValidInterface(void)
		const
{
	DEBUGONLY(AssertValid());
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create a CResObj from the CLocItem passed.  
//  
//  Inspect the CLocTypeId and CLocResId of the CLocItem to determine
//  if this is a CLocItem for this sub parser.  The file pointer for
//  p32File is positioned at the beginning of the resource if you need
//  to read some of the reasource to decide.  
//
//------------------------------------------------------------------------------
STDMETHODIMP_(CResObj*)
CLocImpResObj::CreateResObj(
		C32File  * p32File,
		CLocItem * pLocItem,
		DWORD dwSize, 
		void* pvHeader)
{
	UNREFERENCED_PARAMETER(p32File);
	UNREFERENCED_PARAMETER(dwSize);
	UNREFERENCED_PARAMETER(pvHeader);

	CResObj* pObj = NULL;
	try
	{
		//TODO: Add compare code to decide if this item
		// is for you.

		//The TypeID and ResID are set in the LocItem
		//Type ID is the resource type and ResId is the ID
		//from the image or resource file.

		// For this sample resource type "INIFILE" has
		// a ini file in it that we will parse.

		CPascalString pasType;
		if (pLocItem->GetUniqueId().GetTypeId().GetId(pasType))
		{
			// There is a string type.
			// If you wanted to look for a numeric type, you would
			// pass a DWORD to the GetId call above.

			if (L"MOFDATA" == pasType)
			{
				pObj = new CSampleResObj(pLocItem, dwSize, pvHeader);	
			}
		}

	}
	catch (CException* pE)
	{
		LTTRACE("%s building a CResObj",
			pE->GetRuntimeClass()->m_lpszClassName);
		pObj = NULL;
		pE->Delete();
	}

	return pObj;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Build any data objects used over the life of the file object.
//  Sub parsers don't create the files so this function and 
//  OnDestroyWin32File gives the sub parsers a chance to scope data 
//  on the life of the file.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::OnCreateWin32File(C32File* p32File)
{
	// Force our entry in the sub data storage to be null.
	// This is used in the SetParent function of the sample
	// resource object

	p32File->SetSubData(pidBMOF, NULL);   //TODO: change to the real
		                                    //parser ID
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  The C32File object is about to be destroyed.
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::OnDestroyWin32File(C32File* p32File)
{
	// Free the pointer if it is there 

	//TODO: change to use the real parser ID
	CLocItem* pItem = (CLocItem*)p32File->GetSubData(pidBMOF);
	if (NULL != pItem)
	{
		LTASSERTONLY(pItem->AssertValid());
		delete pItem;

		p32File->SetSubData(pidBMOF, NULL);  //TODO: change to the real
			                                   //parser ID
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Called before enumeration
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CLocImpResObj::OnBeginEnumerate(C32File*)
{
	return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Called after enumeration.  The BOOL is TRUE on successful enumerate
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CLocImpResObj::OnEndEnumerate(C32File*, BOOL)
{
	return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Called before Generate
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CLocImpResObj::OnBeginGenerate(C32File*)
{
	return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Called after generate. The BOOL is TRUE if the generate 
// was successful
//
//------------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CLocImpResObj::OnEndGenerate(C32File*, BOOL)
{
	return TRUE;
}



#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert this object is valid
//
//------------------------------------------------------------------------------
void
CLocImpResObj::AssertValid(void)
		const
{
	CLObject::AssertValid();

	//Bump up this check if needed.
	LTASSERT(m_ulRefCount >= 0 || m_ulRefCount < 100);

	LTASSERT(NULL != m_IBinary.m_pParent);
	LTASSERT(NULL != m_IParser.m_pParent);

	//TODO: ASSERT any other member data objects
	//Note: use LTASSERT instead of ASSERT
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump the contents of this object
//
//------------------------------------------------------------------------------
void
CLocImpResObj::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
	dc << _T("CLocImpResObj\n");

}

#endif // _DEBUG



// ILocBinary interface

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor and member init
//
//------------------------------------------------------------------------------
CLocImpResObj::CLocImpBinary::CLocImpBinary()
{
	m_pParent = NULL;
}	

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor and clean up
//
//------------------------------------------------------------------------------
CLocImpResObj::CLocImpBinary::~CLocImpBinary()
{
	DEBUGONLY(AssertValid());
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Add to the reference count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::CLocImpBinary::AddRef(void)
{
	DEBUGONLY(AssertValid());
	
	return m_pParent->AddRef();
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  subtract from the reference count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::CLocImpBinary::Release(void)
{
	DEBUGONLY(AssertValid());
	
	return m_pParent->Release();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query for the requested interface
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLocImpResObj::CLocImpBinary::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	DEBUGONLY(AssertValid());
	
	return m_pParent->QueryInterface(iid, ppvObj);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert this interface is valie
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::CLocImpBinary::AssertValidInterface() 
CONST_METHOD
{
	DEBUGONLY(AssertValid());
	DEBUGONLY(m_pParent->AssertValid());
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Create a Binary object.
// Sub parser IDs are only in the LOWORD
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(BOOL)
CLocImpResObj::CLocImpBinary::CreateBinaryObject(BinaryId ID, 
		CLocBinary *REFERENCE pBinary)
{

	DEBUGONLY(AssertValid());

	BOOL bRet = FALSE;
	pBinary = NULL;

	try 
	{
		switch (LOWORD(ID))
		{
		case btBMOF: //TODO: change to the real ID
			pBinary = new CSampleBinary;  	
			bRet = TRUE;
			
			break;
		default:
			LTASSERT(0 && "Unknown binary ID"); 
			break;
		}
	}
	catch (CException* pE)
	{
		LTTRACE("%s in CreateBinaryObject",
			pE->GetRuntimeClass()->m_lpszClassName);

		if (NULL != pBinary)
		{
			delete pBinary;
		}
				
		bRet = FALSE;
		pE->Delete();
	}
	catch (...)
	{
		LTTRACE("Unknown Exception in CreateBinaryObject");

		if (NULL != pBinary)
		{
			delete pBinary;
		}
				
		bRet = FALSE;
	}

	return bRet;
}


#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert that the object is valid
//
//------------------------------------------------------------------------------
void
CLocImpResObj::CLocImpBinary::AssertValid(void)
		const
{
	CLObject::AssertValid();

	LTASSERT(NULL != m_pParent);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump the contents of the object
//
//------------------------------------------------------------------------------
void
CLocImpResObj::CLocImpBinary::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
	dc << _T("CLocImpResObj::CLocImpBinary\n");
	dc << _T("m_pParent=");
	dc << (void*)m_pParent;
	dc << _T("\n");

}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\impbin.h ===
//TODO: change CSampleBinary to the name of your binary object

//-----------------------------------------------------------------------------
//  
//  File: IMPBIN.H
//  
//  Declaration of Binary Classes
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------


#ifndef IMPBIN_H 
#define IMPBIN_H 

//Bynary IDs in the file.  
//
//         New types MUST be added at the end
//
enum 
{
	btSample = 1,	//TODO: Define types for the Binary objects
	btBMOF   = 2
};


class CSampleBinary : public CLocBinary
{

public:
	CSampleBinary();
	virtual ~CSampleBinary();

#ifdef _DEBUG
	virtual void AssertValid(void) const;
	virtual void Dump(CDumpContext &) const;
#endif

	virtual CompareCode Compare (const CLocBinary *);

	virtual void PartialUpdate(const CLocBinary * binSource);

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);

	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const;

	//
	//  Serialization routine.
	//
	virtual void Serialize(CArchive &archive);


	//TODO: Add data
	
protected:	

	void MemberDataInit();
};


#endif  //IMPBIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\misc.h ===
//
// Define the parser id for WMI mof parser
//
#define pidWMI 97

//
// Define the Win32 SubParser id for the binary mof resource sub parser
//
#define pidBMOF 200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parser.rc
//
#define IDS_IMP_DESC                    12700
#define IDS_IMP_NO_ERROR                12701
#define IDS_IMP_OOM                     12702
#define IDS_IMP_CANT_LOAD_SOURCE        12703
#define IDS_IMP_CANT_OPEN_TARGET        12704
#define IDS_IMP_NO_OPEN_FILE            12705
#define IDS_IMP_CANT_WRITE_FILE         12707
#define IDS_ERR_EXCEPTION               12708
#define IDS_IMP_HANDLER_ERROR           12709
#define IDS_IMP_UNKNOWN_ERROR           12710
#define IDS_IMP_PARSER_DESC             12711
#define IDS_SDM_DLGSTRING               12712
#define IDS_EXCEP_ITEMSET               12713
#define IDS_NO_INI_PARSE                12714
 
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\samplver.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: samplver.cpp
//
//  Copyright (C) 1994-1997 Microsoft Corporation All rights reserved.
//  
//  Implementation of the ILocVersion interface.
//
//-----------------------------------------------------------------------------
 
#include "stdafx.h"

#include "dllvars.h"
#include "samplver.h"

#include "misc.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for Version interface.  Set up my reference count, and note
//  who my parent is.  Assume that my parent has already been AddRef()'d.
//  Also note that the total class count has gone up.
//  
//-----------------------------------------------------------------------------
CLocSamplVersion::CLocSamplVersion(
		IUnknown *pParent)
{
	m_ulRefCount = 0;
	m_pParent = pParent;
	
	AddRef();
	IncrementClassCount();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Bump my reference count.
//  
//-----------------------------------------------------------------------------
ULONG
CLocSamplVersion::AddRef(void)
{
	return ++m_ulRefCount;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Dec. my reference count.  If it goes to zero, delete myself AND Release()
//  my parent.
//  
//-----------------------------------------------------------------------------
ULONG
CLocSamplVersion::Release(void)
{
	LTASSERT(m_ulRefCount != 0);

	m_ulRefCount--;

	if (m_ulRefCount == 0)
	{
		m_pParent->Release();
		
		delete this;
		return 0;
	}

	return m_ulRefCount;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return an interface.  IID_ILocVersion is me, everything else is handed
//  off to my parent ie. this implements delegation.
//  
//-----------------------------------------------------------------------------
HRESULT
CLocSamplVersion::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE scResult = E_NOINTERFACE;

	*ppvObj = NULL;

	if (iid == IID_ILocVersion)
	{
		*ppvObj = (ILocVersion *)this;
		
		scResult = S_OK;
		AddRef();

		return ResultFromScode(scResult);
	}
	else
	{
		return m_pParent->QueryInterface(iid, ppvObj);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the parser version number.  This is really the version of Esputil
//  and PBase that we compiled against ie the version number of the Parser
//  SDK.
//  
//-----------------------------------------------------------------------------
void
CLocSamplVersion::GetParserVersion(
		DWORD &dwMajor,
		DWORD &dwMinor,
		BOOL &fDebug)
		const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Debuging interface.
//  
//-----------------------------------------------------------------------------
void
CLocSamplVersion::AssertValidInterface(void)
		const
{
	DEBUGONLY(AssertValid());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Simply note that the total class count is lower.
//  
//-----------------------------------------------------------------------------
CLocSamplVersion::~CLocSamplVersion()
{
	DEBUGONLY(AssertValid());
	LTASSERT(m_ulRefCount == 0);

	DecrementClassCount();
}


#ifdef _DEBUG

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Debugging methods.
//  
//-----------------------------------------------------------------------------
void
CLocSamplVersion::AssertValid(void)
		const
{
	CLObject::AssertValid();
}



void
CLocSamplVersion::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\impparse.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: IMPPARSE.CPP
//  
//  Implementation of the ILocParser class
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"

#include "impresob.h"

#include "misc.h"
			   
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor and member data init
//
//------------------------------------------------------------------------------
CLocImpResObj::CLocImpParser::CLocImpParser()
{
	m_pParent = NULL;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor and member clean up
//
//------------------------------------------------------------------------------
CLocImpResObj::CLocImpParser::~CLocImpParser()
{
	DEBUGONLY(AssertValid());
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Add to the object reference count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::CLocImpParser::AddRef(void)
{
	DEBUGONLY(AssertValid());
	
	return m_pParent->AddRef();
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Subtract from the object reference count
//
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CLocImpResObj::CLocImpParser::Release(void)
{
	DEBUGONLY(AssertValid());

	return m_pParent->Release();
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query for other IIDs on this object.  
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLocImpResObj::CLocImpParser::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	DEBUGONLY(AssertValid());
	
	return m_pParent->QueryInterface(iid, ppvObj);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert that this interface is valid
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::CLocImpParser::AssertValidInterface(void)
		const
{
	DEBUGONLY(AssertValid());
}



STDMETHODIMP
CLocImpResObj::CLocImpParser::Init(
		IUnknown *)
{
	return ERROR_SUCCESS;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create a file instance.  Sub parsers do not implement this function.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLocImpResObj::CLocImpParser::CreateFileInstance(
		ILocFile *&pLocFile,
		FileType ft)
{
	DEBUGONLY(AssertValid());

	UNREFERENCED_PARAMETER(pLocFile);
	UNREFERENCED_PARAMETER(ft);

	return ResultFromScode(E_NOTIMPL);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Fill the ParserInfo object with data for this sub parser
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::CLocImpParser::GetParserInfo(
		ParserInfo &pi)
		const
{
	DEBUGONLY(AssertValid());

	try
	{
		pi.aParserIds.SetSize(1);
		pi.aParserIds[0].m_pid = pidBMOF; //TODO: Change to real ID
		pi.aParserIds[0].m_pidParent = pidWin32;
		
		//TODO add any new extensions

		LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
		LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
	}
	catch (CException* pRE)
	{
		pi.aParserIds.SetSize(0);
		pi.strDescription.Empty();
		pRE->Delete();
	}
	catch (...)
	{
		pi.aParserIds.SetSize(0);
		pi.strDescription.Empty();
		//Unexpected.  Can't return error condition.
	}

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the descriptions of the files.  Sub parsers don't implement this
//  Function
//
//------------------------------------------------------------------------------
STDMETHODIMP_(void)
CLocImpResObj::CLocImpParser::GetFileDescriptions(CEnumCallback &cb)
CONST_METHOD
{
	DEBUGONLY(AssertValid());

	UNREFERENCED_PARAMETER(cb);
}


#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert that the object is valid
//
//------------------------------------------------------------------------------
void
CLocImpResObj::CLocImpParser::AssertValid(void)
		const
{
	CLObject::AssertValid();

	LTASSERT(NULL != m_pParent);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump the contents of the object
//
//------------------------------------------------------------------------------
void
CLocImpResObj::CLocImpParser::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
	dc << _T("CLocImpResObj::CLocImpParser\n");
	dc << _T("m_pParent=");
	dc << (void*)m_pParent;
	dc << _T("\n");

}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\samplver.h ===
//-----------------------------------------------------------------------------
//  
//  File: samplver.h
//
//  Copyright (C) 1994-1997 Microsoft Corporation All rights reserved.
//  
//  Declaration of the implementation of ILocVersion.
//
//  Owner:  MikeCo@Microsoft.com
//  
//-----------------------------------------------------------------------------
 
#ifndef SAMPLVER_H
#define SAMPLVER_H

class CLocSamplVersion : public ILocVersion, public CLObject
{
public:
	CLocSamplVersion(IUnknown *pParent);

	~CLocSamplVersion();
	

	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  Implementation for ILocVersion
	//
	STDMETHOD_(void, GetParserVersion)(DWORD &dwMajor,
			DWORD &dwMinor, BOOL &fDebug) const;
	
	//
	//  CLObject implementation
	//
#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif
	
private:
	//
	//  Implementation for IUnknown and ILocVersion.
	ULONG m_ulRefCount;
	IUnknown *m_pParent;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\stdafx.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: STDAFX.CPP 
//  
//  precompiled header file
//
//  Copyright (c) 1995 - 1996, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\sampres.h ===
//-----------------------------------------------------------------------------
//  
//  File: Sampres.H
//  
//  Declaration of classes for the CRecObj derived class
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef __SAMPRES_H
#define __SAMPRES_H


//
// CSampleResObj wraps a SDM DLTHEADER structure
//
class CSampleResObj : public CResObj
{
public:
	CSampleResObj(CLocItem *pLocItem, DWORD dwSize, void *pvHeader);
	virtual ~CSampleResObj();
	//
	//CResObj overrides
	//
	virtual BOOL Read(C32File *p32File);
	virtual BOOL Write(C32File *p32File);
	virtual BOOL CanReadWrite();
	virtual BOOL ReadWrite(C32File* pSrcFile, C32File* pTgtFile);
	virtual BOOL ReadRes32(C32File *p32File);
	virtual BOOL WriteRes32(C32File *p32File);
	virtual BOOL ReadRgLocItem(CLocItemPtrArray * pRgLocItem, int nSelItem);
	virtual BOOL WriteRgLocItem(CLocItemPtrArray * pRgLocItem, CReporter*);

	virtual const void* GetBufferPointer(void);
	virtual DWORD GetBufferSize(void);
	virtual void SetBufferSize(DWORD dwSize);
	virtual void MakeRes32Header(LangId nLangId);

	virtual CLocItem* GetLocItem();
	virtual BOOL IsKeepLocItems();
	virtual void SetKeepLocItems(BOOL fKeep);
	virtual BOOL GetMnemonics(CMnemonicsMap & mapMnemonics, 
		CReporter* pReporter);

	virtual void AssertValid(void) const;

protected:			
	DWORD m_dwSize;
	void *m_pvHeader;
	CLocItem * m_pLocItem;
	BOOL m_fKeepLocItems;

	static void SetParent(CLocItem* pLocItem, C32File* pFile);
	BOOL ReadWriteHelper(C32File* pSrcFile, C32File* pTgtFile, 
		BOOL fGenerate);

private:
};


#endif //__SAMPRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32sub.h ===
//-----------------------------------------------------------------------------
//  
//  File: Win32Sub.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Header file for Win32 Sub parsers.
//  Includes all the needed Win32 specific header files.
//  
//-----------------------------------------------------------------------------

#ifndef __WIN32SUB_H
#define __WIN32SUB_H

#pragma comment(lib, "win32rt.lib")

#include "..\win32rt\f32base.h"
#include "..\win32rt\resbase.h"
#include "..\win32rt\reshead.h"
#include "..\win32rt\w32types.h"
#include "..\win32rt\win32rt.h"
#include "..\win32rt\win32iid.h"
#include "..\win32rt\win32pid.h"

#endif //__WIN32SUB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: STDAFX.H
//  
//  precompiled header file
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.
#include <afxmt.h>          // MFC multithreading support

#include <parser.h>
#include <win32sub.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil.h ===
//-----------------------------------------------------------------------------
//  
//  File: esputil.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Common classes for Espresso
//  
//  
//-----------------------------------------------------------------------------

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\locationex.h"		// 4.2.2 - location plus RRI dialog state
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1999 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1999 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1999 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\sampres.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: Sampres.CPP
//  
//  Implementation of the sample CRecObj
//
//  Copyright (c) 1995 - 1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "impbin.h"
#include "impresob.h"

#include "sampres.h"
#include "dllvars.h"
#include <parseman.h>

#include "misc.h"
#include <bmfmisc.h>

//
//Local helper functions
//

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor and member data init
//
//------------------------------------------------------------------------------
CSampleResObj::CSampleResObj(
		CLocItem *pLocItem, 
		DWORD dwSize, 
		void *pvHeader)
{
	m_dwSize = dwSize;
	m_pvHeader = pvHeader;
	m_pLocItem = pLocItem;
	m_fKeepLocItems = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Cleanup for CSampleResObj
//
//
//-----------------------------------------------------------------------------
CSampleResObj::~CSampleResObj()
{
	if (m_pvHeader)
	{
		delete m_pvHeader;
	}

	if (!m_fKeepLocItems)
	{
		delete m_pLocItem;
	}

	//TODO: any special processing

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  If it is more efficient to read and write this resounce together
//  during a generate then return TRUE here
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::CanReadWrite()
{
	return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  TODO: Implement if you return TRUE from CanReadWrite
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::ReadWrite(
		C32File* p32FileSrc, 
		C32File* p32FileTgt)
{
	return ReadWriteHelper(p32FileSrc, p32FileTgt, TRUE);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read the resource from native format and build CLocItems 
//
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::Read(C32File *p32File)
{
	return ReadWriteHelper(p32File, NULL, FALSE);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Write the resource items
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::Write(C32File *)
{
	LTASSERT(0 && "CSampleResObj::Write is not implemented");
	return FALSE;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Create a short form res header for use with the Res Editor
//  The only information that is important is the Type and Res Id
//------------------------------------------------------------------------------
void 
CSampleResObj::MakeRes32Header(LangId nLangId)
{
	if (m_pvHeader)
	{
		delete m_pvHeader;
		m_pvHeader = NULL;
	}

	//TODO: If the type ID of this object is not the same 
	//as the type of Win32 type you want, set it do some other
	//Win32 type and set ESP_CHAR_USEARRAYVALUE
	//
	//
	
	//Example...
	//CLocTypeId lIDDialog;
	//lIDDialog.SetLocTypeId((DWORD)RT_DIALOG);
	//m_pvHeader = W32MakeRes32Header(lIDDialog,
	m_pvHeader = W32MakeRes32Header(m_pLocItem->GetUniqueId().GetTypeId(),
									m_pLocItem->GetUniqueId().GetResId(),
									nLangId,
									ESP_CHAR_USEARRAYVALUE); 
	//The ESP_CHAR_USEARRAYVALUE constant tells Win32 to use
	//the values from the real Locitem when cracking the resource
	//instead of using the ID from the res file.

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Set the buffer size
//------------------------------------------------------------------------------
void 
CSampleResObj::SetBufferSize(DWORD dwSize)
{
	m_dwSize = dwSize;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Return the loc item
//------------------------------------------------------------------------------
CLocItem* 
CSampleResObj::GetLocItem()
{
	return m_pLocItem;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Return the keep item state
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::IsKeepLocItems()
{
	return m_fKeepLocItems;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Set the keep item state
//------------------------------------------------------------------------------
void 
CSampleResObj::SetKeepLocItems(BOOL fKeep)
{
	m_fKeepLocItems = fKeep;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Read the resource from Res32 format 
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::ReadRes32(C32File *p32File)
{
	//TODO: if your file formats are different than 
	// RES32 then do unique processing here.

	return Read(p32File);
}


//-----------------------------------------------------------------------------
//
//  Worker function to read or write the ini file 
//
//-----------------------------------------------------------------------------
BOOL 
CSampleResObj::ReadWriteHelper(
	C32File* SourceFile, 
	C32File* TargetFile,
	BOOL GenerateTarget
	)
/*++

Routine Description:

    Helper routine for resource object read and write routines

Arguments:

	SourceFile is the source file object. This has the original
		resource data.

	TargetFile is the target file object. The localized information
		will be written into this file. If fGenerate is FALSE then
		p32FileTgt is NULL

	GenerateTarget is TRUE then a localized resource will be generated

Return Value:

	TRUE if successful else FALSE

--*/
{
	BOOL ReturnStatus = TRUE;
	TCHAR TempPath[MAX_PATH];
	TCHAR SourceMofFile[MAX_PATH];
	TCHAR EnglishMofFile[MAX_PATH];
	CFileSpec fs;
	CPascalString pasTempFileSrc;
	TCHAR TargetMofFile[MAX_PATH];
	TCHAR TargetBmfFile[MAX_PATH];
	CLocLangId langIdTgt;

	try
	{
		//
		// Read in the resource from the source so that we can generate
		// the corresponding unicode text mof from it and then hand off
		// the text mof to the WBEM MFL parser.
		//
		CByteArray baResource;
		baResource.SetSize(m_dwSize);

		if (m_dwSize != SourceFile->Read(baResource.GetData(), m_dwSize))
		{
			AfxThrowFileException(CFileException::endOfFile);
		}

		//
		// Create a temp file to generate the unicode mof text
		//
		if (0 == GetTempPath(MAX_PATH, TempPath))
		{
			AfxThrowUserException();
		}

		if (0 == GetTempFileName(TempPath, _T("mof"), 0, SourceMofFile))
		{
			AfxThrowUserException();
		}

		if (GenerateTarget)
		{
			if (0 == GetTempFileName(TempPath, _T("mof"), 0, EnglishMofFile))
			{
				AfxThrowUserException();
			}
		} else {
			*EnglishMofFile = 0;
		}


		//
		// Generate MOF from baResource into a temp file
		//
		
		if (ConvertBmfToMof(baResource.GetData(),
							SourceMofFile,
						    EnglishMofFile))
		{
#if 0
			OutputDebugString(SourceMofFile);
			OutputDebugString("\n");
			OutputDebugString(EnglishMofFile);
			OutputDebugString("\n");
			DebugBreak();
#endif	
			
			//
			// Leverage the WMI MOF loc parser to do the hard work
			//
			pasTempFileSrc.SetString(SourceMofFile,
									 strlen(SourceMofFile), 
									 CP_ACP);
		
			fs.SetFileName(pasTempFileSrc);
			fs.SetFileId(SourceFile->GetFileDBID());

			SmartRef<ILocFile> scIniFile;
			BOOL bFile = CLocParserManager::GetLocFile(fs,
												   pidWMI,
												   ftUnknown,
												   scIniFile,
												   *SourceFile->GetHandler());

			if (bFile)
			{
				// Set the parent node in the unique ID of the item
				SetParent(m_pLocItem, SourceFile);
		
				m_pLocItem->SetIconType(CIT::Expandable);
				m_pLocItem->SetFDisplayable(TRUE);
				m_pLocItem->SetFExpandable(TRUE);


				CLocItemSet setItems(FALSE);
				setItems.Add(m_pLocItem);

				if (!SourceFile->GetHandler()->HandleItemSet(setItems))
				{
					//Espresso failed the update - this could be due to
					//duplicate IDs, user clicking cancel, or other reasons.

					//Just throw an exception, destructors will do all
					//the clean up
					ThrowItemSetException();
				}

				LTASSERT(!scIniFile.IsNull());
				CLocLangId langIdSrc;
				langIdSrc.SetLanguageId(SourceFile->GetLangId());

				if (GenerateTarget)
				{
					//
					// We need to generate a localized binary mof. First we
					// generate the unicode MOF text from the WMI loc
					// parser and then convert it back into binary into
					// another file. Finally we read the binary mof and
					// write it into the resource.
					// 
					langIdTgt.SetLanguageId(TargetFile->GetLangId());
				
					if (0 == GetTempFileName(TempPath,
										 _T("mof"),
										 0, 
										 TargetMofFile))
					{
						AfxThrowUserException();
					}

					CPascalString pasTempFileTgt;
					pasTempFileTgt.SetString(TargetMofFile,
										 strlen(TargetMofFile), 
										 CP_ACP);

					BOOL bGen = scIniFile->GenerateFile(pasTempFileTgt,
													*SourceFile->GetHandler(),
													langIdSrc,
													langIdTgt,  
													m_pLocItem->GetMyDatabaseId());

					if (bGen)
					{
						
						//
						// Generate the BMF from the localized unicode text MOF
						//
					
						if (0 == GetTempFileName(TempPath, _T("bmf"), 0, 
											 TargetBmfFile))
						{
							AfxThrowUserException();
						}


						//
						// Do MOF to binary mof conversion
						//
						if (ConvertMofToBmf(TargetMofFile,
											EnglishMofFile,
											TargetBmfFile))
						{					
							CPascalString pasTempFileBmfTgt;
							pasTempFileBmfTgt.SetString(TargetBmfFile,
								strlen(TargetBmfFile),
								CP_ACP);
							
							//
							// Copy the BMF information from the binary mof
							// file and into the resource
							//
							CFile fTemp;
							fTemp.Open(TargetBmfFile, CFile::modeRead);
							
							CByteArray baData;
							int nDataLen = fTemp.GetLength();
							baData.SetSize(nDataLen);
							fTemp.Read(baData.GetData(), nDataLen);
							fTemp.Close();
							
							TargetFile->PreWriteResource(this);
							TargetFile->Write(baData.GetData(), nDataLen);
							TargetFile->PostWriteResource(this);
							
						} else {
							TargetFile->SetDelayedFailure(TRUE);
						}
						
						CFile::Remove(TargetBmfFile);
						CFile::Remove(TargetMofFile);
						
					} else {
						TargetFile->SetDelayedFailure(TRUE);
					}
					
				}
				else
				{
					if (!scIniFile->EnumerateFile(*SourceFile->GetHandler(),
						langIdSrc, m_pLocItem->GetMyDatabaseId()))
					{
						SourceFile->SetDelayedFailure(TRUE);
					}
				}
				
				scIniFile->Release();
				scIniFile.Extract();
				
			}
			else
			{
				// Issue some message about the parser not being there
				CContext ctx(g_hDll, IDS_IMP_PARSER_DESC, 
							 SourceFile->GetFileDBID(), otFile, vProjWindow);
				
				SourceFile->GetHandler()->IssueMessage(esError, ctx,
					g_hDll, IDS_NO_INI_PARSE);
				
				// TODO if you want to fail the update because of this reason
				// set bRet to FALSE and change the IssueMessage to be 
				// esError instead of esWarning.
				ReturnStatus = FALSE;
			}
		} else {
			ReturnStatus = FALSE;
		}
		
		CFile::Remove(SourceMofFile);
	}
	catch (CException* pE)
	{
		ReturnStatus = FALSE;

		ReportException(pE, TargetFile, m_pLocItem, SourceFile->GetHandler());

		pE->Delete();
	}

	return(ReturnStatus);

}


//
//TODO: Remove if not needed
//
//Example function to set the parent ID from
//a display node.

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Set the parent item.
//  The C32File is holding on to a Map of Ids to CLocItems for us.
//
//-----------------------------------------------------------------------------
void
CSampleResObj::SetParent(
			 CLocItem* pLocItem, 
			 C32File* pFile)
{
	
	//TODO: Change to the real parser ID
	CLocItem* pParentItem = (CLocItem*)pFile->GetSubData(pidBMOF);
	
	if (pParentItem != NULL)
	{
		LTASSERTONLY(pParentItem->AssertValid());
		pLocItem->GetUniqueId().SetParentId(pParentItem->GetMyDatabaseId());
	}
	else
	{
		//need to create and send one
		CPascalString pasStrName;
		pasStrName = L"Binary MOF";

		SmartPtr<CLocItem> spParentItem = new CLocItem;
		CLocUniqueId uid;

		uid.GetResId().SetId(pasStrName);
		uid.GetTypeId().SetId((ULONG)0);
		uid.SetParentId(pFile->GetMasterDBID());

		spParentItem->SetUniqueId(uid);
		
		spParentItem->SetFDisplayable(TRUE);
		spParentItem->SetFNoResTable(TRUE);
		spParentItem->SetIconType(CIT::Expandable);
		spParentItem->SetFExpandable(TRUE);

		CLocItemSet itemSet(FALSE);
		itemSet.Add(spParentItem.GetPointer());
		BOOL bHandle = pFile->GetHandler()->HandleItemSet(itemSet);

		if (!bHandle)
		{
			LTTRACE("Dummy Node value not handled"); 
			ThrowItemSetException();
		}

		pLocItem->GetUniqueId().SetParentId(spParentItem->GetMyDatabaseId());

		pFile->SetSubData(pidBMOF, spParentItem.Extract());
	}

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Write the object in Res32 Format
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::WriteRes32(C32File *p32File)
{
	//TODO: if your file formats are different than 
	// RES32 then do unique processing here.

	return Write(p32File);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Read the items passed and hold onto them.  
//
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::ReadRgLocItem(CLocItemPtrArray * pRgLocItem, int nSelItem)
{
	UNREFERENCED_PARAMETER(pRgLocItem);
	UNREFERENCED_PARAMETER(nSelItem);
	m_fKeepLocItems = TRUE;  //The loc items don't belong to us

	//TODO save the items if needed.
	
	return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// update the loc items in the array with the data from the loc items 
// in this object.
// Only the coordinants and the tab order are copied.
//
// The dialog is always the first item in the array.
//
// The Win32 parser calls this function in responce to CrackRes32Image
//------------------------------------------------------------------------------
BOOL 
CSampleResObj::WriteRgLocItem(
	CLocItemPtrArray * pRgLocItem,
	CReporter*)
{
	UNREFERENCED_PARAMETER(pRgLocItem);

	BOOL bRet = TRUE;
	try
	{
		LTASSERT(0 != pRgLocItem->GetSize());
		//TODO: implement

		//Transfer the binary from my item to the database item.
		pRgLocItem->GetAt(0)->TransferBinary(m_pLocItem);
	}
	catch (...)
	{
		bRet = FALSE;
	}

	return bRet;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Return Buffer pointer
//------------------------------------------------------------------------------
const void* 
CSampleResObj::GetBufferPointer(void)
{
	return m_pvHeader;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Return buffer size
//------------------------------------------------------------------------------
DWORD 
CSampleResObj::GetBufferSize(void)
{
	return m_dwSize;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Get mnemonics in resource
//------------------------------------------------------------------------------
BOOL	
CSampleResObj::GetMnemonics(
	CMnemonicsMap &, /*mapMnemonics*/ 
	CReporter* ) //pReporter
{
	return TRUE;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert the object is valid
//
//------------------------------------------------------------------------------
void 
CSampleResObj::AssertValid(void) const
{
#ifdef LTASSERT_ACTIVE
	CObject::AssertValid();         
	LTASSERT(m_dwSize > 0);
	LTASSERT(m_pvHeader != NULL);
	LTASSERT(m_pLocItem != NULL);

	//TODO any other asserts?
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is just a redirector to the 'real' MITUTIL.H.
//  
//-----------------------------------------------------------------------------

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\loctypes.h ===
//-----------------------------------------------------------------------------
//  
//  File: loctypes.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
//-----------------------------------------------------------------------------
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\helpids.h ===
//-----------------------------------------------------------------------------
//  
//  File: helpids.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//  DON'T USE MATH -  the Help compiler is very intelegent...
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478
#define IDH_ESPOPT_RRI				12484

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: locutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\precenum.h ===
#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseman.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase.h ===
//-----------------------------------------------------------------------------
//  
//  File: pbase.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Parser base classes.  Parsers should really be using parsers.h
//  
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parser.h ===
//-----------------------------------------------------------------------------
//  
//  File: parser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  
//-----------------------------------------------------------------------------

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: parsutil.h|inc
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\puser.h ===
//-----------------------------------------------------------------------------
//  
//  File: puser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
//-----------------------------------------------------------------------------
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: binary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parserid.h ===
//-----------------------------------------------------------------------------
//
// File: parserid.h
// Copyright (c) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// See 'parserid.txt' in the Parsers directory for a description of these
// constants.
//
//-----------------------------------------------------------------------------
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;

const ParserId pidGIFJPGParse = 97;

//const ParserId pid??? = 98;

const ParserId pidCustBIN = 99;

const ParserId pidLDF		= 103;

const ParserId pidToolTip = 105;

const ParserId pidPOM = 106;

const ParserId pidBLT	=	107;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\clfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
//-----------------------------------------------------------------------------
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\binary.inl ===
//-----------------------------------------------------------------------------
//  
//  File: binary.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Required inline functions for generating binary info template classes.
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\clfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return (LPCSTR) m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\dbid.h ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\context.inl ===
//-----------------------------------------------------------------------------
//  
//  File: context.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\context.h ===
//-----------------------------------------------------------------------------
//  
//  File: context.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\dbid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\dlgresfile.h ===
// DlgResFile.h: Dialog resource memory file.
//
//////////////////////////////////////////////////////////////////////

#if !defined(DLGRESFILE_H)
#define DLGRESFILE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Structure of a res file header. The header consists
// of two fixed sized parts with a variable sized middle
// The middle structure appears twice the first is the
// type ID and the second one is the Res ID

#include <pshpack1.h>

	typedef struct
	{
		DWORD dwDataSize;
		DWORD dwHeaderSize;
	} DRF_RESHEAD1;

	typedef struct
	{
		DWORD dwDataVersion;
		WORD wFlags;
		WORD wLang;
		DWORD dwResVersion;
		DWORD dwCharacteristics;
	} DRF_RESHEAD3;

#include <poppack.h>


//-----------------------------------------------------------------------------
//  
//	Format of a Name or Ordinal Field
//  
//-----------------------------------------------------------------------------

typedef union
{
	WCHAR wzId[1];
	struct
	{
	WORD wFlag;
	WORD wId;
	};
} DRF_NAMEORD;


class LTAPIENTRY CDlgResFile : public CLFile
{
public:
	CDlgResFile(CFile* pFile);
	~CDlgResFile();

	virtual BOOL OpenSource(const CFileSpec &fsSourceFile,
		CFileException *pExcept);
	virtual BOOL GetNextResource();

	//Helper functions
	virtual DWORD WriteNameOrd(const CLocId &locId); 
	virtual UINT WriteString(const CPascalString &pstrString);

	void AssertValid(void) const;

protected:
	BOOL ReadHeader(DWORD &dwNextPos, DWORD &dwDataSize, CLocId &lidType,
		CLocId &lidRes, LangId &langId, DWORD &dwChar, void * &pv);

private:
	DWORD m_dwHeaderPos;
	DWORD m_dwFileSize;
	DWORD m_dwNextPos;
};


void GetNameOrd(BYTE * &pbBuffer, CLocId *plocId);
void GetString(BYTE * &pbbuffer, CPascalString & pasStr);

#endif // !defined(DLGRESFILE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference,		// icon for reference glossary
		RRIProject,		// RRI project root icon
		RRIFile,		// RRI file
		RRIFileParsed,	// RRI file after being parsed
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\filespec.h ===
//-----------------------------------------------------------------------------
//  
//  File: filespec.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\globalroutines.h ===
// GlobalRoutines.h: interface for the CGlobalRoutines class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GLOBALROUTINES_H__CA00ED33_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_)
#define AFX_GLOBALROUTINES_H__CA00ED33_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "ProcessFileName.h"

#ifdef   __cplusplus
extern "C" {
#endif
//////////////////////////////////////////////////////////////////
enum enumAPPDRIVERMODE
{
    APPDRIVER_NAVIGATION_MODE_NORMAL  = 1,
    APPDRIVER_NAVIGATION_MODE_RANDOM  = 2,
    APPDRIVER_NAVIGATION_MODE_EXPLORE = 3,
    APPDRIVER_NAVIGATION_MODE_LISTEN  = 4
};
//////////////////////////////////////////////////////////////////

void LTAPIENTRY DumpComError(_com_error & ce);
BOOL ProcessFileName(const CString& strOriginalFileName, CCHECKFILENAME& procFileName);

void LTAPIENTRY GetPathComponents (const CLString& strFullPath, CLString* pDrive, 
                       	   CLString* pDirectory, 
                       	   CLString* pName, 
                           CLString* pExtension, CLString* pLastExtension = NULL, BOOL bCleanUp  = TRUE );

void LTAPIENTRY StripTrailingCharacter(CLString& rText, TCHAR chTrailing);
void LTAPIENTRY AddTrailingSlash(CLString& rText);
void LTAPIENTRY GetExtensionList(CStringList& strList, const CLString& strFileExtensions, const TCHAR chDelimiter = _T('.'));
BOOL LTAPIENTRY FindExtension(const CLString& strFileExt, const CLString& strUserExt);
void LTAPIENTRY StripLeadingCharacter(CLString& rText, TCHAR chLeading);
void LTAPIENTRY SetStrLength(CLString& Text, int nLength);
bool LTAPIENTRY GetAppDriverNavigationMode(const int nIndex, int& nrefAppNavigationMode);
bool LTAPIENTRY GetLTANavigationMode(const int nAppNavigationMode, int& nrefIndex);
bool LTAPIENTRY GetAppDriverDurationType(const int nIndex, int& nrefAppDurationType);
bool LTAPIENTRY GetLTADurationType(const int nrefAppDurationType, int& nrefIndex);

void LTAPIENTRY FillLBTextList(CStringList &refStrList, CListBox* pLB);
void LTAPIENTRY GetLBTextList(CStringList &refStrList, CListBox* pLB);

int   LTAPIENTRY GetGridComboList(CLString& strList, LPTSTR* rgszItems);
void  LTAPIENTRY ReplaceEntityRefChars(CLString& strXML);
bool  LTAPIENTRY GetAppDirectory(CLString& strAppDir);
bool  LTAPIENTRY GetWorkSpaceFileName(CLString& strWorkSpaceFileName);

bool LTAPIENTRY GetNavDelayIndex(int nDelayMSec, int& refnDelayIndex);
void LTAPIENTRY GetDelayMSec(const int nDelayIndex, int& nDelayMSec);

bool LTAPIENTRY FindInStrList(CLString strSearch, CStringList& refStrList);

CBitmap* LTAPIENTRY GetPreviewBitmap(CWnd* pParent, LPCDLGTEMPLATE pTemplate);

void LTAPIENTRY SetComboBoxCurSel(CComboBox& refComboBox, CLString& strCurSelString);
void LTAPIENTRY FormatEditControlString(CLString& strOriginalOutput);
//////////////////////////////////////////////////////////////////
#ifdef   __cplusplus
}
#endif

//////////////////////////////////////////////////////////////////
#endif // !defined(AFX_GLOBALROUTINES_H__CA00ED33_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);

LTAPIENTRY CGoto *CreateEspGoto(const CLocationEx &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\itemhand.h ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
//-----------------------------------------------------------------------------
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\globalid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\itemhand.inl ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\location.h ===
//-----------------------------------------------------------------------------
//  
//  File: location.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

protected:
	NOTHROW void AssignFrom(const CLocation &);

private:
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\locationex.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locationex.inl
//  Copyright (C) 1999-1999 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------



inline
void
CLocationEx::AssignFrom(
		const CLocationEx &rhs)
{
	CLocation::AssignFrom(rhs);
	m_dbidDialog = rhs.m_dbidDialog;
	m_lRRIVersion = rhs.m_lRRIVersion;
	m_strRuntimeStateString = rhs.m_strRuntimeStateString;
}

inline
CLocationEx::CLocationEx()
		: m_lRRIVersion(0)
{
}

inline
CLocationEx::CLocationEx(const CLocationEx &rlocex)
{
	AssignFrom(rlocex);
}

inline
CLocationEx::CLocationEx(
		const CGlobalId &rid,
		View v,
		TabId t,
		Component c,
		const DBID &rdbidDialog,
		long lRRIVersion)
		: CLocation(rid, v, t, c)
		, m_dbidDialog(rdbidDialog)
		, m_lRRIVersion(lRRIVersion)
{
}

inline
CLocationEx::CLocationEx(
		const DBID &rdbid,
		ObjectType ot,
		View v,
		TabId t,
		Component c,
		const DBID &rdbidDialog,
		long lRRIVersion)
		: CLocation(rdbid, ot, v, t, c)
		, m_dbidDialog(rdbidDialog)
		, m_lRRIVersion(lRRIVersion)
{
}

inline
CLocationEx::CLocationEx(
		const DBID &rdbid,
		ObjectType ot,
		View v,
		TabId t,
		Component c,
		const DBID &rdbidDialog,
		const CLString& rstrRuntimeStateString)
		: CLocation(rdbid, ot, v, t, c)
		, m_dbidDialog(rdbidDialog)
		, m_lRRIVersion(0)
		, m_strRuntimeStateString(rstrRuntimeStateString)
{
}

inline
const CLocationEx &
CLocationEx::operator=(const CLocationEx &rhs)
{
	AssignFrom(rhs);

	return *this;
}

inline
const DBID&
CLocationEx::GetDialogDbid() const
{
	return m_dbidDialog;
}

inline
long
CLocationEx::GetRRIVersion() const
{
	return m_lRRIVersion;
}

inline
const CLString&
CLocationEx::GetRuntimeStateString() const
{
	return m_strRuntimeStateString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\locationex.h ===
//-----------------------------------------------------------------------------
//  
//  File: locationex.h
//  Copyright (C) 1999-1999 Microsoft Corporation
//  All rights reserved.
//  
//  Owner: arilds
//
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCATIONEX_H
#define ESPUTIL_LOCATIONEX_H


#include "location.h"


class LTAPIENTRY CLocationEx : public CLocation
{
public:
	NOTHROW CLocationEx();
	NOTHROW CLocationEx(const CLocationEx &rlocex);
	NOTHROW CLocationEx(
			const CGlobalId &rid,
			View v,
			TabId t,
			Component c,
			const DBID &rdbidDialog,
			long lRRIVersion);
	NOTHROW CLocationEx(
			const DBID &rdbid,
			ObjectType ot,
			View v,
			TabId t,
			Component c,
			const DBID &rdbidDialog,
			long lRRIVersion);
	NOTHROW CLocationEx(
			const DBID &rdbid,
			ObjectType ot,
			View v,
			TabId t,
			Component c,
			const DBID &rdbidDialog,
			const CLString& rstrRuntimeStateString);

	NOTHROW const CLocationEx & operator=(const CLocationEx &rhs);

	NOTHROW const DBID& GetDialogDbid() const;
	NOTHROW long GetRRIVersion() const;
	NOTHROW const CLString& GetRuntimeStateString() const;

private:
	NOTHROW void AssignFrom(const CLocationEx &rhs);

	DBID m_dbidDialog;
	long m_lRRIVersion;
	CLString m_strRuntimeStateString;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locationex.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\locitem.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\locitem.h ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\lta.h ===
// Lta.h : main header file for the LTA application
//

#if !defined(AFX_LTA_H__F0AFC370_4604_11D2_8DA8_204C4F4F5020__INCLUDED_)
#define AFX_LTA_H__F0AFC370_4604_11D2_8DA8_204C4F4F5020__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "Lta_i.h"


/////////////////////////////////////////////////////////////////////////////
// CLtaApp:
// See Lta.cpp for the implementation of this class
//

class CLtaApp : public CWinApp
{
public:
	void OnExit();
	CLtaApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLtaApp)
	public:
	virtual BOOL InitInstance();
		virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	COleTemplateServer m_server;
		// Server object for document creation
	//{{AFX_MSG(CLtaApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
//JDG	SECMultiDocTemplate* GetRriNodeDocTemplate();
	virtual void         AddToRecentProjectList(const CString& strProjName);
	void                 OnUpdateRecentProject(CCmdUI* pCmdUI);
	BOOL                 OnOpenRecentProject(UINT nID);
	virtual void         LoadProjProfileSettings();
	CRecentFileList*	   m_pRecentProjects;

private:
	BOOL m_bATLInited;
//JDG   SECMultiDocTemplate* m_pRriNodeDocTemplate;
private:
	BOOL InitATL();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LTA_H__F0AFC370_4604_11D2_8DA8_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\ltastd.h ===
//////////////////////////////////////////////////////////////////////
// LtaStd.h: interface for the LtaStd class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LTASTD_H__3FC374A5_4447_11D2_8DA4_204C4F4F5020__INCLUDED_)
#define AFX_LTASTD_H__3FC374A5_4447_11D2_8DA4_204C4F4F5020__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ProjectDataStructs.h"

////////////////////////////////////////////////////////////////////
const LPTSTR _FILEEXT_RRI     = _T("rri");
const LPTSTR _FILEDOTEXT_RRI     = _T(".rri");
const LPTSTR _FILEFILETER_RRI     = _T("RRI Files (*.rri)|*.rri||");

const LPTSTR _FILEEXT_MAP     = _T("map");
const LPTSTR _FILEDOTEXT_MAP     = _T(".map");
const LPTSTR _FILEFILETER_MAP     = _T("MAP Files (*.map)|*.map||");

const LPTSTR _FILEEXT_LOG     = _T("log");
const LPTSTR _FILEDOTEXT_LOG     = _T(".log");
const LPTSTR _FILEFILETER_LOG     = _T("Log Files (*.log)|*.Log||");

const LPTSTR _FILEEXT_BUGRPORT= _T("dat");
const LPTSTR _FILEDOTEXT_BUGRPORT= _T(".dat");
const LPTSTR _FILEFILETER_BUGRPORT= _T("Bug Report Files (*.dat)|*.dat||");

const LPTSTR _FILEEXT_PROJECT = _T("xml");
const LPTSTR _FILEDOTEXT_PROJECT = _T(".xml");
const LPTSTR _FILEFILETER_PROJECT = _T("Project Files (*.xml)|*.xml||");

const LPTSTR _FILEEXT_APPLICATION =_T("Exe");
const LPTSTR _FILEDOTEXT_APPLICATION =_T(".Exe");
const LPTSTR _FILEFILETER_APPLICATION = _T("Application Files (*.exe)|*.exe||");

////////////////////////////////////////////////////////////////////
enum enumPopUpMenuIndex
{
   POPMENUINDEX_PROJECTVIEW   = 0,
   POPMENUINDEX_APPMENUS      = 3,
   POPMENUINDEX_APPOPTIONS    = 4,
   POPMENUINDEX_RICHEDIT      = 6,
   POPMENUINDEX_TESTBUGREPORT = 7,
   POPMENUINDEX_CTRLOPTIONS   = 8,
   POPMENUINDEX_RRIVIEW       = 9,
   POPMENUINDEX_RRICHECKTREE  = 10,
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

   /////////////////////////////////////////////////////////////////
typedef struct FormatInfo
{
   LPTSTR  m_szFormatName;
   bool    m_bSuper;
} FORMATINFO, FAR* LPFORMATINFO;

   /////////////////////////////////////////////////////////////////
typedef struct ElementAction
{
   LPTSTR  m_szElementAction;
   bool    m_bSuper;
} ELEMENTACTION, FAR* LPELEMENTACTION;

   /////////////////////////////////////////////////////////////////
typedef struct ElementInfo
{
   ElementAction* m_rgElementActions;
   FormatInfo*    m_rgResType;
   LPTSTR*        m_rgszElementLocations;

   bool     m_bSupportClassName;
   bool     m_bSupportCaption;
   bool     m_bSupportID;
   bool     m_bSupportScripting;
   bool    m_bSuper;

} ELEMENTINFO, FAR* LPELEMENTINFO;

   /////////////////////////////////////////////////////////////////
typedef struct Element
{
   LPCTSTR        m_szElementName;
   LPELEMENTINFO  m_pElementInfo;
} ELEMENT, FAR* LPELEMENT;

//////////////////////////////////////////////////////////////////
typedef class CCheckListItem
{
public:
   // Inline
   CCheckListItem(BOOL bChecked, BOOL bBold, LPTSTR strItemText)
      : m_bChecked(bChecked), m_bBold(bBold), m_strItemText(strItemText)
   {
   }

   // Inline
   virtual ~CCheckListItem()
   {
   }
public:
   BOOL     m_bChecked;
   BOOL     m_bBold;
   CString  m_strItemText;
} CCHECKLISTITEM, FAR* LPCCHECKLISTITEM;

////////////////////////////////////////////////////////////////////
// Global Externs.
////////////////////////////////////////////////////////////////////
extern Element g_rgElements[];

////////////////////////////////////////////////////////////////////
#endif // !defined(AFX_LTASTD_H__3FC374A5_4447_11D2_8DA4_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\location.inl ===
//-----------------------------------------------------------------------------
//  
//  File: location.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\lunknown.h ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\lta_i.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Thu Dec 03 04:41:50 1998
 */
/* Compiler settings for D:\Projects\LTA\Development\LtaApp\Lta.odl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __Lta_i_h__
#define __Lta_i_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ILta_FWD_DEFINED__
#define __ILta_FWD_DEFINED__
typedef interface ILta ILta;
#endif 	/* __ILta_FWD_DEFINED__ */


#ifndef __Document_FWD_DEFINED__
#define __Document_FWD_DEFINED__

#ifdef __cplusplus
typedef class Document Document;
#else
typedef struct Document Document;
#endif /* __cplusplus */

#endif 	/* __Document_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __Lta_LIBRARY_DEFINED__
#define __Lta_LIBRARY_DEFINED__

/* library Lta */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_Lta;

#ifndef __ILta_DISPINTERFACE_DEFINED__
#define __ILta_DISPINTERFACE_DEFINED__

/* dispinterface ILta */
/* [uuid] */ 


EXTERN_C const IID DIID_ILta;

#if defined(__cplusplus) && !defined(CINTERFACE)

//JDG    MIDL_INTERFACE("F0AFC366-4604-11D2-8DA8-204C4F4F5020")
//JDG    ILta : public IDispatch
//JDG    {
//JDG    };
    
#else 	/* C style interface */

    typedef struct ILtaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILta __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILta __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILta __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILta __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILta __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILta __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILta __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } ILtaVtbl;

    interface ILta
    {
        CONST_VTBL struct ILtaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILta_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILta_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILta_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILta_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILta_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILta_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILta_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __ILta_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_Document;

#ifdef __cplusplus

class DECLSPEC_UUID("AB91B5A3-16E0-11D2-8D79-C83846000000")
Document;
#endif
#endif /* __Lta_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\puid.h ===
//-----------------------------------------------------------------------------
//  
//  File: puid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\projectdatastructs.h ===
// ProjectDataStructs.h: interface for the ProjectDataStructs class.
//
// By: Saud A. Alshibani. (c) MS 1998. All rights reserved.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROJECTDATASTRUCTS_H__A1B64483_53BD_11D2_8780_00C04F8DA632__INCLUDED_)
#define AFX_PROJECTDATASTRUCTS_H__A1B64483_53BD_11D2_8780_00C04F8DA632__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "RaidDataStructs.h"


//#pragma  TODO(_T("Finish replacing XMLTAG_xxx with Getxxxxx()"))
//////////////////////////////////////////////////////////////////////
const LPTSTR XMLTAG_PROJECT                   = _T("PROJECT");
const LPTSTR XMLTAG_PROJECT_DATA              = _T("PROJDATA");
const LPTSTR XMLTAG_PROJECT_OPTIONS           = _T("PROJOPTIONS");
const LPTSTR XMLTAG_PROJECT_NAME              = _T("PROJNAME");
const LPTSTR XMLTAG_PROJECT_PATH              = _T("PROJPATH");
const LPTSTR XMLTAG_PROJECT_RRIFILE           = _T("RRIFILE");
const LPTSTR XMLTAG_PROJECT_LOGFILE           = _T("LOGFILE");
const LPTSTR XMLTAG_PROJECT_USERRIFILE        = _T("USERRIFILE");
const LPTSTR XMLTAG_PROJECT_USELOGFILE        = _T("USELOGFILE");

const LPTSTR XMLTAG_NAVIGATIONOPTIONS         = _T("NAVIGATIONOPTIONS");
const LPTSTR XMLTAG_NAVIGATION_MODESTR        = _T("MODESTR");
const LPTSTR XMLTAG_NAVIGATION_MODE           = _T("MODE");
const LPTSTR XMLTAG_NAVIGATION_DURATION       = _T("DURATION");
const LPTSTR XMLTAG_NAVIGATION_MINUTES        = _T("MINUTES");
const LPTSTR XMLTAG_NAVIGATION_ACTIONS        = _T("ACTIONS");
const LPTSTR XMLTAG_NAVIGATION_DELAY          = _T("DELAY");

const LPTSTR XMLTAG_ELEMENTNAVIGATION         = _T("ELEMENTNAVIGATION");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_LIST    = _T("ELEMENTNAVIGATIONLIST");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_ACTIVE  = _T("ACTIVE");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_NAME    = _T("NAME");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_ACTION  = _T("ACTION");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_CAPTION = _T("CAPTION");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_ID      = _T("ID");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_LOCATION= _T("LOCATION");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_FORMAT  = _T("FORMAT");
const LPTSTR XMLTAG_ELEMENTNAVIGATION_USEAPPSETTING = _T("USEAPPSETTING");

const LPTSTR XMLTAG_APPLICATION_NAME          = _T("APPNAME");
const LPTSTR XMLTAG_APPLICATION_PATH          = _T("APPPATH");
const LPTSTR XMLTAG_APPLICATION_OPTIONS       = _T("APPOPTIONS");
const LPTSTR XMLTAG_APPLICATION_MAPFILE       = _T("MAPFILE");
const LPTSTR XMLTAG_APPLICATION_CMDLINE       = _T("CMDLINE");
const LPTSTR XMLTAG_APPLICATION_USECMDLINE    = _T("USECMDLINE");
const LPTSTR XMLTAG_APPLICATION_USENAVIGATION = _T("USENAVIGATION");
const LPTSTR XMLTAG_APPLICATION_CMDLINEITEM   = _T("CMDLINEITEM");
const LPTSTR XMLTAG_APPLICATION_MENU          = _T("APPMENU");
const LPTSTR XMLTAG_APPLICATION_DATA          = _T("APPDATA");
const LPTSTR XMLTAG_APPLICATION_LIST          = _T("APPLIST");
const LPTSTR XMLTAG_APPLICATION_ACTIVE        = _T("ACTIVE");

const LPTSTR XMLTAG_GENERALOPTIONS               = _T("GENERALOPTIONS");
const LPTSTR XMLTAG_GENERALOPTIONS_DRIVEAPP      = _T("DRIVEAPP");
const LPTSTR XMLTAG_GENERALOPTIONS_CAPTURERRINFO = _T("CAPTURERRINFO");
const LPTSTR XMLTAG_GENERALOPTIONS_CAPTURERESID  = _T("CAPTURERESID");

const LPTSTR XMLTAG_ELEMENT_DISABLEACTIONS       = _T("disable-actions");
const LPTSTR XMLTAG_ELEMENT_ELEMENT              = _T("element");
const LPTSTR XMLTAG_ELEMENT_ACTION               = _T("action");
const LPTSTR XMLTAG_ELEMENT_CAPTION              = _T("caption");
const LPTSTR XMLTAG_ELEMENT_RESOURCEID           = _T("resource-id");

//////////////////////////////////////////////////////////////////////
typedef class ProjectXMLTags
{
public:
   static LPCTSTR GetProjectXMLTag()            { return XMLTAG_PROJECT                  ;   }
   static LPCTSTR GetProjDataXMLTag()           { return XMLTAG_PROJECT_DATA             ;  }
   static LPCTSTR GetProjOptionsXMLTag()        { return XMLTAG_PROJECT_OPTIONS          ;  }
   static LPCTSTR GetProjNameXMLTag()           { return XMLTAG_PROJECT_NAME             ;  }
   static LPCTSTR GetProjPathXMLTag()           { return XMLTAG_PROJECT_PATH             ;  }
   static LPCTSTR GetProjRrifileXMLTag()        { return XMLTAG_PROJECT_RRIFILE          ;  }
   static LPCTSTR GetProjLogfileXMLTag()        { return XMLTAG_PROJECT_LOGFILE          ;  }
   static LPCTSTR GetProjUserrifileXMLTag()     { return XMLTAG_PROJECT_USERRIFILE       ;  }
   static LPCTSTR GetProjUselogfileXMLTag()     { return XMLTAG_PROJECT_USELOGFILE       ;  }

   static LPCTSTR GetNavigationOptionsXMLTag()  { return XMLTAG_NAVIGATIONOPTIONS        ;  }
   static LPCTSTR GetNavigationModeXMLTag()     { return XMLTAG_NAVIGATION_MODE          ;  }
   static LPCTSTR GetNavigationModeStrXMLTag()  { return XMLTAG_NAVIGATION_MODESTR       ;  }
   static LPCTSTR GetNavigationDurationXMLTag() { return XMLTAG_NAVIGATION_DURATION      ;  }
   static LPCTSTR GetNavigationMinutesXMLTag()  { return XMLTAG_NAVIGATION_MINUTES       ;  }
   static LPCTSTR GetNavigationActionsXMLTag()  { return XMLTAG_NAVIGATION_ACTIONS       ;  }
   static LPCTSTR GetNavigationDelayXMLTag()    { return XMLTAG_NAVIGATION_DELAY         ;  }

   static LPCTSTR GetElementNavigationXMLTag()         { return XMLTAG_ELEMENTNAVIGATION         ;  }
   static LPCTSTR GetElementNavigationListXMLTag()     { return XMLTAG_ELEMENTNAVIGATION_LIST    ;  }
   static LPCTSTR GetElementNavigationActiveXMLTag()   { return XMLTAG_ELEMENTNAVIGATION_ACTIVE  ;  }
   static LPCTSTR GetElementNavigationNameXMLTag()     { return XMLTAG_ELEMENTNAVIGATION_NAME    ;  }
   static LPCTSTR GetElementNavigationActionXMLTag()   { return XMLTAG_ELEMENTNAVIGATION_ACTION  ;  }
   static LPCTSTR GetElementNavigationCaptionXMLTag()  { return XMLTAG_ELEMENTNAVIGATION_CAPTION ;  }
   static LPCTSTR GetElementNavigationIdXMLTag()       { return XMLTAG_ELEMENTNAVIGATION_ID      ;  }
   static LPCTSTR GetElementNavigationLocationXMLTag() { return XMLTAG_ELEMENTNAVIGATION_LOCATION;  }
   static LPCTSTR GetElementNavigationFormatXMLTag()   { return XMLTAG_ELEMENTNAVIGATION_FORMAT  ;  }
   static LPCTSTR GetElementNavigationUseAppSettingXMLTag()   { return XMLTAG_ELEMENTNAVIGATION_USEAPPSETTING;  }

   static LPCTSTR GetAppNameXMLTag()            { return XMLTAG_APPLICATION_NAME         ;  }
   static LPCTSTR GetAppPathXMLTag()            { return XMLTAG_APPLICATION_PATH         ;  }
   static LPCTSTR GetAppOptionsXMLTag()         { return XMLTAG_APPLICATION_OPTIONS      ;  }
   static LPCTSTR GetAppMapfileXMLTag()         { return XMLTAG_APPLICATION_MAPFILE      ;  }
   static LPCTSTR GetAppCmdlineXMLTag()         { return XMLTAG_APPLICATION_CMDLINE     ;  }
   static LPCTSTR GetAppUsecmdlineXMLTag()      { return XMLTAG_APPLICATION_USECMDLINE   ;  }
   static LPCTSTR GetAppUsenavigationXMLTag()   { return XMLTAG_APPLICATION_USENAVIGATION;  }
   static LPCTSTR GetAppCmdlineitemXMLTag()     { return XMLTAG_APPLICATION_CMDLINEITEM  ;  }
   static LPCTSTR GetAppMenuXMLTag()            { return XMLTAG_APPLICATION_MENU         ;  }
   static LPCTSTR GetAppDataXMLTag()            { return XMLTAG_APPLICATION_DATA         ;  }
   static LPCTSTR GetAppListXMLTag()            { return XMLTAG_APPLICATION_LIST         ;  }
   static LPCTSTR GetAppActiveXMLTag()          { return XMLTAG_APPLICATION_ACTIVE       ;  }

   static LPCTSTR GetGeneralOptionsXMLTag()               { return XMLTAG_GENERALOPTIONS               ;  }
   static LPCTSTR GetGeneralOptionsDriveAppXMLTag()       { return XMLTAG_GENERALOPTIONS_DRIVEAPP      ;  }
   static LPCTSTR GetGeneralOptionsCaptureRRInfoXMLTag()  { return XMLTAG_GENERALOPTIONS_CAPTURERRINFO ;  }
   static LPCTSTR GetGeneralOptionsCaptureResIDXMLTag()   { return XMLTAG_GENERALOPTIONS_CAPTURERESID  ;  }

   static LPCTSTR GetElementDisabeActionsXMLTag()        { return  XMLTAG_ELEMENT_DISABLEACTIONS;  }
   static LPCTSTR GetElementXMLTag()                     { return  XMLTAG_ELEMENT_ELEMENT       ;  }
   static LPCTSTR GetElementActionXMLTag()               { return  XMLTAG_ELEMENT_ACTION        ;  }
   static LPCTSTR GetElementCaptionXMLTag()              { return  XMLTAG_ELEMENT_CAPTION       ;  }
   static LPCTSTR GetElementResourceIDXMLTag()           { return  XMLTAG_ELEMENT_RESOURCEID    ;  }

} PROJECTXMLTAGS, FAR* LPPROJECTXMLTAGS;

typedef  PROJECTXMLTAGS PXT;
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
enum enumNavigationDelay
{
   NAVIGATIONDELAY_NONE   = -1,
   NAVIGATIONDELAY_SLOW   = 3000,
   NAVIGATIONDELAY_NORMAL = 1000,
   NAVIGATIONDELAY_FAST   = 0,
};

enum enumNavDelayIndex
{
   NAVDELAYINDEX_NONE   = -1,
   NAVDELAYINDEX_SLOW   = 0,
   NAVDELAYINDEX_NORMAL,
   NAVDELAYINDEX_FAST  ,
};

/////////////////////////////////////////////////////////////////////////////
typedef struct NavigationDelay
{
   int   m_nType;
   int   m_nDelayMSec;

} NAVIGATIONDELAY, FAR* LPNAVIGATIONDELAY;

//////////////////////////////////////////////////////////////////////
typedef class CLParamBase
{
public:
   CLParamBase() : m_bChecked(true)
   {
   }

   virtual ~CLParamBase()
   {
   }

public:
   bool        m_bChecked;

} CLPARAMBASE, FAR* LPCLPARAMBASE;

//////////////////////////////////////////////////////////////////////
typedef class CGeneralOptions
{
   CGeneralOptions(CGeneralOptions&);
   CGeneralOptions& operator=(CGeneralOptions&);
public:
   //////////////////////////////////////////////
   // Inline
   CGeneralOptions() : m_bCaptureResID(true), m_bCaptureRRInfo(true),
                       m_bDriveApp(true)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CGeneralOptions()
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual void Clone(CGeneralOptions& refGeneralOptions)
   {
      refGeneralOptions.m_bCaptureResID  = m_bCaptureResID ;
      refGeneralOptions.m_bCaptureRRInfo = m_bCaptureRRInfo;
      refGeneralOptions.m_bDriveApp      = m_bDriveApp     ;
      refGeneralOptions.m_strData        = m_strData       ;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

public:
   bool     m_bCaptureResID;
   bool     m_bCaptureRRInfo;
   bool     m_bDriveApp;
   CLString  m_strData;
} CGENERALOPTIONS, FAR* LPCGENERALOPTIONS;

//////////////////////////////////////////////////////////////////////
typedef class CXMLGeneralOptions : public CGeneralOptions
{
   CXMLGeneralOptions(CXMLGeneralOptions&);
   CXMLGeneralOptions& operator=(CXMLGeneralOptions&);
public:
   //////////////////////////////////////////////
   // Inline
   CXMLGeneralOptions() : m_XMLTagInformation(PXT::GetGeneralOptionsXMLTag(), _T("\t\t\t"))
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CXMLGeneralOptions()
   {
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetGeneralOptionsDriveAppXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_bDriveApp);

      XMLTagInfo.Init(PXT::GetGeneralOptionsCaptureRRInfoXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bCaptureRRInfo);

      XMLTagInfo.Init(PXT::GetGeneralOptionsCaptureResIDXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bCaptureResID);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLGENERALOPTIONS, FAR* LPCXMLGENERALOPTIONS;

//////////////////////////////////////////////////////////////////////
typedef class CNavigationMode
{
public:
   int      m_nNavigationMode;
   CLString  m_strNavigationMode;
} CNAVIGATIONMODE, FAR* LPCNAVIGATIONMODE;

//////////////////////////////////////////////////////////////////////
typedef class CDurationType
{
public:
   int      m_nDurationType;
   CLString  m_strDurationType;
} CDURATIONTYPE, FAR* LPCDURATIONTYPE;

//////////////////////////////////////////////////////////////////////
enum enumNavigationMode
{
   NAVIGATIONMODE_RANDOM = 0X0001,
};

enum enumDurationType
{
   DURATIONTYPE_NOTDEFINED = 0X0000,
   DURATIONTYPE_INFINITE   = 0X0000,
   DURATIONTYPE_MINUTES    = 0X0002,
   DURATIONTYPE_ACTIONS    = 0X0004,
};

//////////////////////////////////////////////////////////////////////
typedef class CNavigationOptions
{
   CNavigationOptions(CNavigationOptions&);
   CNavigationOptions& operator=(CNavigationOptions&);
public:
   //////////////////////////////////////////////
   // Inline
   CNavigationOptions()
      : m_nNavigationMode(NAVIGATIONMODE_RANDOM), m_nDurationType(DURATIONTYPE_INFINITE),
        m_nMinutes(60), m_nActions(100), m_nDelayMSec(NAVIGATIONDELAY_FAST)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CNavigationOptions()
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual void Clone(CNavigationOptions& refNavigationOptions)
   {
      refNavigationOptions.m_strNavigationMode = m_strNavigationMode;
      refNavigationOptions.m_nNavigationMode   = m_nNavigationMode  ;
      refNavigationOptions.m_nDurationType     = m_nDurationType    ;
      refNavigationOptions.m_nMinutes          = m_nMinutes         ;
      refNavigationOptions.m_nActions          = m_nActions         ;
      refNavigationOptions.m_nDelayMSec        = m_nDelayMSec       ;
      refNavigationOptions.m_strData           = m_strData          ;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

   //////////////////////////////////////////////
public:
   CLString  m_strNavigationMode;
   int      m_nNavigationMode;
   int      m_nDurationType;
   int      m_nMinutes;
   int      m_nActions;
   int      m_nDelayMSec;
   CLString  m_strData;

} CNAVIGATIONOPTIONS, FAR* LPCNAVIGATIONOPTIONS;

//////////////////////////////////////////////////////////////////////
typedef class CXMLNavigationOptions : public CNavigationOptions
{
   CXMLNavigationOptions(CXMLNavigationOptions&);
   CXMLNavigationOptions& operator=(CXMLNavigationOptions&);
public:
   //////////////////////////////////////////////
   // Inline
   CXMLNavigationOptions() : m_XMLTagInformation(PXT::GetNavigationOptionsXMLTag(), _T("\t\t\t\t"))
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CXMLNavigationOptions()
   {
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetNavigationModeStrXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strNavigationMode);

      XMLTagInfo.Init(PXT::GetNavigationModeXMLTag(), strTabs);
      strTmp = XMLTagInfo.GetXMLString(m_nNavigationMode);

      XMLTagInfo.Init(PXT::GetNavigationDurationXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_nDurationType);

      XMLTagInfo.Init(PXT::GetNavigationMinutesXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_nMinutes);

      XMLTagInfo.Init(PXT::GetNavigationActionsXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_nActions);

      XMLTagInfo.Init(PXT::GetNavigationDelayXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_nDelayMSec);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLNAVIGATIONOPTIONS, FAR* LPCXMLNAVIGATIONOPTIONS;

   /////////////////////////////////////////////////////////////////
typedef class CElementNavigation
{
private:
   CElementNavigation(CElementNavigation&);
   CElementNavigation& operator=(CElementNavigation&);

public:
   //////////////////////////////////////////////
   // Inline
   CElementNavigation() : m_bChecked(true)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CElementNavigation()
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual void Clone(CElementNavigation& refElementNavigation)
   {
      refElementNavigation.m_bChecked       = m_bChecked      ;
      refElementNavigation.m_strAction      = m_strAction     ;
      refElementNavigation.m_strCaption     = m_strCaption    ;
      refElementNavigation.m_strElementName = m_strElementName;
      refElementNavigation.m_strFormat      = m_strFormat     ;
      refElementNavigation.m_strID          = m_strID         ;
      refElementNavigation.m_strLocation    = m_strLocation   ;
      refElementNavigation.m_strData        = m_strData       ;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

   //////////////////////////////////////////////
public:
   CLString  m_strElementName;
   CLString  m_strAction;
   CLString  m_strCaption;
   CLString  m_strID;
   CLString  m_strLocation;
   CLString  m_strFormat;
   bool     m_bChecked;
   CLString  m_strData;
} CELEMENTNAVIGATION, FAR* LPCELEMENTNAVIGATION;

   /////////////////////////////////////////////////////////////////
typedef class CXMLElementNavigation : public CElementNavigation
{
private:
   CXMLElementNavigation(CXMLElementNavigation&);
   CXMLElementNavigation& operator=(CXMLElementNavigation&);

public:
   //////////////////////////////////////////////
   // Inline
   CXMLElementNavigation() : m_XMLTagInformation(PXT::GetElementNavigationXMLTag(), _T("\t\t\t\t"))
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CXMLElementNavigation()
   {
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetElementNavigationNameXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strElementName);

      XMLTagInfo.Init(PXT::GetElementNavigationActionXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strAction);

      XMLTagInfo.Init(PXT::GetElementNavigationCaptionXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strCaption);

      XMLTagInfo.Init(PXT::GetElementNavigationIdXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strID);

      XMLTagInfo.Init(PXT::GetElementNavigationLocationXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strLocation);

      XMLTagInfo.Init(PXT::GetElementNavigationFormatXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strFormat);

      XMLTagInfo.Init(PXT::GetElementNavigationActiveXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bChecked);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLELEMENTNAVIGATION, FAR* LPCXMLELEMENTNAVIGATION;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef class CApplicationOptions
{
private:
   CApplicationOptions(CApplicationOptions&);
   CApplicationOptions& operator=(CApplicationOptions&);

public:
   //////////////////////////////////////////////
   // Inline
   CApplicationOptions()
      : m_bUseCmdLineArg(TRUE), m_bUseNavigationOptions(FALSE),
        m_pGeneralOptions(NULL),
        m_pNavigationOptions(NULL)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CApplicationOptions()
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual void Clone(CApplicationOptions& refAppOptions)
   {
      refAppOptions.m_strMapFileName        = m_strMapFileName        ;
      refAppOptions.m_strCmdLineArg         = m_strCmdLineArg         ;
      refAppOptions.m_bUseCmdLineArg        = m_bUseCmdLineArg        ;
      refAppOptions.m_bUseNavigationOptions = m_bUseNavigationOptions ;
      refAppOptions.m_strCmdLineArgList.RemoveAll();
      POSITION pos = m_strCmdLineArgList.GetHeadPosition();
      while(pos)
      {
         CLString strTmp = m_strCmdLineArgList.GetNext(pos);
         refAppOptions.m_strCmdLineArgList.AddTail(strTmp);
      }

      // Clone the general and navigation option.
      ASSERT(m_pNavigationOptions);
      ASSERT(m_pGeneralOptions);
      m_pNavigationOptions->Clone(refAppOptions.GetNavigationOptions());
      m_pGeneralOptions->Clone(refAppOptions.GetGeneralOptions());
   }

   //////////////////////////////////////////////
   CNavigationOptions& GetNavigationOptions()
   {
      ASSERT(m_pNavigationOptions);
      return *m_pNavigationOptions;
   }

   //////////////////////////////////////////////
   CGeneralOptions& GetGeneralOptions()
   {
      ASSERT(m_pGeneralOptions);
      return *m_pGeneralOptions;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

public:
   CLString     m_strMapFileName;
   CLString     m_strCmdLineArg;
   CStringList m_strCmdLineArgList;
   BOOL        m_bUseCmdLineArg;
   BOOL        m_bUseNavigationOptions;
   CNavigationOptions*   m_pNavigationOptions;  // IMPORTANT: This must be allocated in the derived class
   CGeneralOptions*      m_pGeneralOptions;     // IMPORTANT: This must be allocated in the derived class

   CLString m_strData;
} CAPPLICATIONOPTIONS, FAR* LPCAPPLICATIONOPTIONS;

   //////////////////////////////////////////////////////////////////////
typedef class CXMLApplicationOptions : public CApplicationOptions
{
private:
   CXMLApplicationOptions(CXMLApplicationOptions&);
   CXMLApplicationOptions& operator=(CXMLApplicationOptions&);

public:
   //////////////////////////////////////////////
   CXMLApplicationOptions() : m_XMLTagInformation(XMLTAG_APPLICATION_OPTIONS, _T("\t\t\t"))
   {
      m_pNavigationOptions = new CXMLNAVIGATIONOPTIONS();
      m_pGeneralOptions    = new CXMLGENERALOPTIONS;
   }

   //////////////////////////////////////////////
   virtual ~CXMLApplicationOptions()
   {
      delete m_pNavigationOptions;
      delete m_pGeneralOptions;
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t\t");
      CXMLTagInformation XMLTagInfo(XMLTAG_APPLICATION_MAPFILE, strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strMapFileName);

      XMLTagInfo.Init(XMLTAG_APPLICATION_CMDLINE, strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strCmdLineArg);

      XMLTagInfo.Init(XMLTAG_APPLICATION_USECMDLINE, strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bUseCmdLineArg);

      XMLTagInfo.Init(XMLTAG_APPLICATION_USENAVIGATION, strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bUseNavigationOptions);


      // Now file the command line items.
      XMLTagInfo.Init(XMLTAG_APPLICATION_CMDLINEITEM, strTabs);
      POSITION pos = m_strCmdLineArgList.GetHeadPosition();
      while(pos)
      {
         strTmp += XMLTagInfo.GetXMLString(CLString(m_strCmdLineArgList.GetNext(pos)));
      }

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_pNavigationOptions->GetDataString();
      m_strData += m_pGeneralOptions->GetDataString();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   XMLTAGINFORMATION m_XMLTagInformation;
} CXMLAPPLICATIONOPTIONS, FAR* LPCXMLAPPLICATIONOPTIONS;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef class CApplicationMenus
{
private:
   CApplicationMenus(CApplicationMenus&);
   CApplicationMenus& operator=(CApplicationMenus&);

public:
   //////////////////////////////////////////////
   // Inline
   CApplicationMenus()
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CApplicationMenus()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CApplicationMenus& refAppMenus)
   {
      UNREFERENCED_PARAMETER(refAppMenus);
   }

   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

public:
   CLString m_strData;
} CAPPLICATIONMENUS, FAR* LPCAPPLICATIONMENUS;

   //////////////////////////////////////////////////////////////////////
typedef class CXMLApplicationMenus : public CApplicationMenus
{
private:
   CXMLApplicationMenus(CXMLApplicationMenus&);
   CXMLApplicationMenus& operator=(CXMLApplicationMenus&);

public:
   //////////////////////////////////////////////
   // Inline
   CXMLApplicationMenus() : m_XMLTagInformation(XMLTAG_APPLICATION_MENU, _T("\t\t\t"))
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CXMLApplicationMenus()
   {
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   XMLTAGINFORMATION m_XMLTagInformation;
} CXMLAPPLICATIONMENUS, FAR* LPCXMLAPPLICATIONMENUS;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef  std::map<CLString, LPCELEMENTNAVIGATION, std::less<CLString> > CElementMap;
typedef  CElementMap::iterator iterElementMap;
typedef  CElementMap::value_type valueElement;

   //////////////////////////////////////////////////////////////////////
typedef  class CElementNavMap : public CElementMap
{
public:
   CElementNavMap() : m_bUseAppSetting(false)
   {
   }

   virtual ~CElementNavMap()
   {
      CleanUp();
   }

   //////////////////////////////////////////////
   //Inline
   virtual void CleanUp()
   {
      if(size())
      {
         iterElementMap iter    = begin();
         iterElementMap iterEnd = end();
         while(iter != iterEnd)
         {
            LPCELEMENTNAVIGATION pElement = (*iter).second;
            ASSERT(pElement);
            delete pElement;
            iter++;
         }
      }
      clear();
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CElementNavMap& refMapElement)
   {
      refMapElement.m_strData        = m_strData;
      refMapElement.m_bUseAppSetting = m_bUseAppSetting;

      refMapElement.CleanUp();
      if(size())
      {
         iterElementMap iter    = begin();
         iterElementMap iterEnd = end();
         while(iter != iterEnd)
         {
            LPCELEMENTNAVIGATION pElement = (*iter).second;
            ASSERT(pElement);
            iter++;

            // Now clone and insert the new item (if necessary)
            LPCELEMENTNAVIGATION pNewElement = GetNewElement();
            ASSERT(pNewElement);
            pElement->Clone(*pNewElement);
            refMapElement.InsertElement(pNewElement);
         }
      }
   }

   //////////////////////////////////////////////
   //Inline
   bool InsertElement(LPCELEMENTNAVIGATION pElement)
   {
      bool bInserted = false;
      CLString strKey;
      GetKey(pElement, strKey);
      if(Find(strKey) == end())
      {
         insert(valueElement(strKey, pElement));
         bInserted = true;
      }
      return bInserted;
   }

   //////////////////////////////////////////////
   iterElementMap Find(CLString strKey)
   {
      ASSERT(!strKey.IsEmpty());
      strKey.MakeLower();
      return find(strKey);
   }

   //////////////////////////////////////////////
   iterElementMap Find(LPCELEMENTNAVIGATION pElement)
   {
      CLString strKey;
      GetKey(pElement, strKey);
      ASSERT(!strKey.IsEmpty());
      return find(strKey);
   }

   //////////////////////////////////////////////
   void GetKey(LPCELEMENTNAVIGATION pElement, CLString& strKey)
   {
      strKey = pElement->m_strElementName 
               + pElement->m_strAction
               + pElement->m_strCaption 
               + pElement->m_strID
               + pElement->m_strFormat
               + pElement->m_strLocation;
      strKey.MakeLower();
      ASSERT(!strKey.IsEmpty());
   }
public:
   //////////////////////////////////////////////
   // Inline - Pure Virtual
   virtual CLString& GetDataString() = 0;

   //////////////////////////////////////////////
   // Inline - Pure Virtual
   virtual LPCELEMENTNAVIGATION GetNewElement() = 0;

   //////////////////////////////////////////////
   virtual CLString& GetDisableActionsDataString() = 0;
public:
   CLString  m_strData;
   bool     m_bUseAppSetting;
}CELEMENTNAVMAP, FAR* LPCELEMENTNAVMAP;

   //////////////////////////////////////////////////////////////////////
typedef  class CXMLElementNavMap : public CElementNavMap
{
public:
   CXMLElementNavMap() : m_XMLTagInformation(PXT::GetElementNavigationListXMLTag(), _T("\t\t\t"))
   {
   }

   virtual ~CXMLElementNavMap()
   {
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t\t");
      if(size())
      {
         m_strData = m_XMLTagInformation.GetTabbedStartTag();
         CXMLTagInformation XMLTagInfo(PXT::GetElementNavigationUseAppSettingXMLTag(), strTabs);
         m_strData += XMLTagInfo.GetXMLString(m_bUseAppSetting);

         iterElementMap iter    = begin();
         iterElementMap iterEnd = end();
         while(iter != iterEnd)
         {
            LPCELEMENTNAVIGATION pElement = (*iter).second;
            ASSERT(pElement);
            m_strData += pElement->GetDataString();
            iter++;
         }
         m_strData += m_XMLTagInformation.GetTabbedEndTag();
      }
      return m_strData;
   }

   //////////////////////////////////////////////
   virtual CLString& GetDisableActionsDataString()
   {
      m_strData.Empty();
      if(size())
      {
         CLString strTabs = _T("\t");
         CXMLTagInformation ActionXMLTag(PXT::GetElementActionXMLTag(), strTabs);
         CXMLTagInformation ElementXMLTag(PXT::GetElementXMLTag(), strTabs);
         CXMLTagInformation ParentElementXMLTag(PXT::GetElementXMLTag(), strTabs);
         CXMLTagInformation CaptionXMLTag(PXT::GetElementCaptionXMLTag(), _T("\t\t"));
         CXMLTagInformation ResIDXMLTag(PXT::GetElementResourceIDXMLTag(), _T("\t\t"));

         iterElementMap iter    = begin();
         iterElementMap iterEnd = end();
         CLString strElementsXML;
         while(iter != iterEnd)
         {
            LPCELEMENTNAVIGATION pElement = (*iter).second;
            ASSERT(pElement);
            iter++;

            // We only create a disable action iff: (1) checked, (2) element name is
            // not empty, and (3) action type not empty.
            if(pElement->m_bChecked && !pElement->m_strElementName.IsEmpty() && !pElement->m_strAction.IsEmpty())
            {
               CLString strXML;
               CLString strTmp2;
               // Did the user specify a location?
               if(!pElement->m_strLocation.IsEmpty())
               {
                  strTmp2.Format(_T("type=\"%s\""), pElement->m_strLocation);
                  strXML += ParentElementXMLTag.GetTabbedStartTag(strTmp2);
                  ElementXMLTag.SetTabs(_T("\t\t"));
               }
               else
               {
                  ElementXMLTag.SetTabs(strTabs);
               }

               // Now compose the Element.
               if(!pElement->m_strFormat.IsEmpty())
                  strTmp2.Format(_T("type=\"%s\" format=\"%s\""), pElement->m_strElementName, pElement->m_strFormat);
               else
                  strTmp2.Format(_T("type=\"%s\""), pElement->m_strElementName);
               strXML += ElementXMLTag.GetTabbedStartTag(strTmp2);

               if(!pElement->m_strCaption.IsEmpty())
                  strXML += CaptionXMLTag.GetXMLString(pElement->m_strCaption);

               if(!pElement->m_strID.IsEmpty())
                  strXML += ResIDXMLTag.GetXMLString(pElement->m_strID);

               strXML += ElementXMLTag.GetTabbedEndTag();

               // Add the closing element if a location has been specified.
               if(!pElement->m_strLocation.IsEmpty())
               {
                  strXML += ParentElementXMLTag.GetTabbedEndTag();
               }

               strTmp2.Format(_T("type=\"%s\""), pElement->m_strAction);
               strXML += ActionXMLTag.GetTabbedStartTag(strTmp2);
               strXML += ActionXMLTag.GetTabbedEndTag();

               // Now add it to the overall string.
               strElementsXML += strXML;
            }
         }

         if(!strElementsXML.IsEmpty())
         {
            CXMLTagInformation DisableXMLTag(PXT::GetElementDisabeActionsXMLTag(), _T(""));
            m_strData = DisableXMLTag.GetTabbedStartTag();
            m_strData += strElementsXML;
            m_strData += DisableXMLTag.GetTabbedEndTag();
         }
      }

      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual LPCELEMENTNAVIGATION GetNewElement()
   {
      return new CXMLELEMENTNAVIGATION;
   }

public:
   XMLTAGINFORMATION m_XMLTagInformation;

}CXMLELEMENTNAVMAP, FAR* LPCXMLELEMENTNAVMAP;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef class CApplicationData : public CLParamBase
{
private:
   CApplicationData(CApplicationData&);
   CApplicationData& operator=(CApplicationData&);

public:
   //////////////////////////////////////////////
   // Inline
   CApplicationData() : m_pApplicationOptions(NULL), m_pApplicationMenus(NULL),
                        m_pElementNavMap(NULL)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CApplicationData()
   {
      CleanUp();
   }

   //////////////////////////////////////////////
   //Inline
   void CleanUp()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CApplicationData& refApplicationData)
   {
      refApplicationData.m_strAppName = m_strAppName;
      refApplicationData.m_strPath    = m_strPath   ;
      refApplicationData.m_bChecked   = m_bChecked  ;

      ASSERT(m_pApplicationOptions);
      ASSERT(m_pApplicationMenus);
      ASSERT(m_pElementNavMap);
      m_pApplicationOptions->Clone(refApplicationData.GetApplicationOptions());
      m_pApplicationMenus->Clone(refApplicationData.GetApplicationMenus());
      m_pElementNavMap->Clone(refApplicationData.GetElementNavMap());
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

   //////////////////////////////////////////////
   // Inline
   CApplicationOptions& GetApplicationOptions()
   {
      ASSERT(m_pApplicationOptions);
      return *m_pApplicationOptions;
   }

   //////////////////////////////////////////////
   // Inline
   CElementNavMap& GetElementNavMap()
   {
      ASSERT(m_pElementNavMap);
      return *m_pElementNavMap;
   }

   //////////////////////////////////////////////
   // Inline
   CElementNavMap* GetElementNavMapPtr()
   {
      ASSERT(m_pElementNavMap);
      return m_pElementNavMap;
   }

   //////////////////////////////////////////////
   // Inline
   CApplicationMenus& GetApplicationMenus()
   {
      ASSERT(m_pApplicationMenus);
      return *m_pApplicationMenus;
   }

   //////////////////////////////////////////////
public:
   CLString     m_strAppName;
   CLString     m_strPath;

   CApplicationOptions*  m_pApplicationOptions;
   CApplicationMenus*    m_pApplicationMenus;
   CElementNavMap*       m_pElementNavMap;

   CLString     m_strData;
} CAPPLICATIONDATA, FAR* LPCAPPLICATIONDATA;

   //////////////////////////////////////////////////////////////////////
typedef class CXMLApplicationData : public CApplicationData
{
private:
   CXMLApplicationData(CXMLApplicationData&);
   CXMLApplicationData& operator=(CXMLApplicationData&);

public:
   //////////////////////////////////////////////
   CXMLApplicationData() : m_XMLTagInformation(XMLTAG_APPLICATION_DATA, _T("\t\t"))
   {
      m_pApplicationOptions = new CXMLAPPLICATIONOPTIONS();
      m_pApplicationMenus   = new CXMLAPPLICATIONMENUS();
      m_pElementNavMap      = new CXMLElementNavMap();
   }

   //////////////////////////////////////////////
   virtual ~CXMLApplicationData()
   {
      delete m_pApplicationOptions;
      delete m_pApplicationMenus;
      delete m_pElementNavMap;
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetAppNameXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strAppName);

      XMLTagInfo.Init(PXT::GetAppPathXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strPath);

      XMLTagInfo.Init(PXT::GetAppActiveXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bChecked);

      // Now create the entire application XML string
      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_pApplicationOptions->GetDataString();
      m_strData += m_pElementNavMap->GetDataString();
      m_strData += m_pApplicationMenus->GetDataString();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   XMLTAGINFORMATION m_XMLTagInformation;
} CXMLAPPLICATIONDATA, FAR* LPCXMLAPPLICATIONDATA;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//typedef  CTypedPtrMap<CMapStringToPtr, CLString, LPCAPPLICATIONDATA> CAppList;
typedef  std::map<CLString, LPCAPPLICATIONDATA, std::less<CLString> > CAppMap;
typedef  CAppMap::iterator iterAppMap;
typedef  CAppMap::value_type valueApp;

typedef class CAppMapEx : public CAppMap
{
public:
   CAppMapEx()
   {
   }

   virtual ~CAppMapEx()
   {
      CleanUp();
   }

   //////////////////////////////////////////////
   //Inline
   virtual void CleanUp()
   {
      if(size())
      {
         iterAppMap iter    = begin();
         iterAppMap iterEnd = end();
         while(iter != iterEnd)
         {
            LPCAPPLICATIONDATA pItem = (*iter).second;
            ASSERT(pItem);
            delete pItem;
            iter++;
         }
      }
      clear();
   }

   //////////////////////////////////////////////
   //Inline
   bool InsertItem(LPCAPPLICATIONDATA pAppData)
   {
      CLString strTmp = pAppData->m_strPath;
      strTmp.MakeLower();
      insert(valueApp(strTmp, pAppData));
      return true;
   }

   //////////////////////////////////////////////
   //Inline
   iterAppMap Find(CLString strAppPath)
   {
      ASSERT(!strAppPath.IsEmpty());
      strAppPath.MakeLower();
      return find(strAppPath);
   }

   //////////////////////////////////////////////
   //Inline
   bool Erase(CLString strAppPath)
   {
      ASSERT(!strAppPath.IsEmpty());
      strAppPath.MakeLower();
      erase(strAppPath);
      return true;
   }

} CAPPMAPEX, FAR* LPCAPPMAPEX;

//////////////////////////////////////////////////////////////////////
typedef class CProjectOptions
{
private:
   CProjectOptions(CProjectOptions&);
   CProjectOptions& operator=(CProjectOptions&);

public:
   //////////////////////////////////////////////
   // Inline
   CProjectOptions() : m_bUseRRIFile(1), m_bUseLogFile(1),
                       m_pNavigationOptions(NULL),
                       m_pGeneralOptions(NULL)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CProjectOptions()
   {
   }

   //////////////////////////////////////////////
   //Inline
   void CleanUp()
   {
   }

   //////////////////////////////////////////////
   CNavigationOptions& GetNavigationOptions()
   {
      ASSERT(m_pNavigationOptions);
      return *m_pNavigationOptions;
   }

   //////////////////////////////////////////////
   CGeneralOptions& GetGeneralOptions()
   {
      ASSERT(m_pGeneralOptions);
      return *m_pGeneralOptions;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

public:
   CLString             m_strRRIFileName;
   CLString             m_strLogFileName;
   BOOL                m_bUseRRIFile;
   BOOL                m_bUseLogFile;
   CNavigationOptions* m_pNavigationOptions;  // IMPORTANT: This must be allocated in the derived class
   CGeneralOptions*    m_pGeneralOptions;     // IMPORTANT: This must be allocated in the derived class

   // Data String
   CLString              m_strData;
} CPROJECTOPTIONS, FAR* LPCPROJECTOPTIONS;

   //////////////////////////////////////////////////////////////////////
typedef class CXMLProjectOptions : public CProjectOptions
{
private:
   CXMLProjectOptions(CXMLProjectOptions&);
   CXMLProjectOptions& operator=(CXMLProjectOptions&);

public:
   //////////////////////////////////////////////
   // Constructor - Inline
   CXMLProjectOptions() : m_XMLTagInformation(PXT::GetProjOptionsXMLTag(), _T("\t\t"))
   {
      m_pNavigationOptions = new CXMLNAVIGATIONOPTIONS;
      m_pGeneralOptions    = new CXMLGENERALOPTIONS;
   }

   //////////////////////////////////////////////
   // Destructor - Inline
   virtual ~CXMLProjectOptions()
   {
      delete m_pNavigationOptions;
      delete m_pGeneralOptions;
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      ASSERT(m_pNavigationOptions);
      ASSERT(m_pGeneralOptions);

      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetProjRrifileXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strRRIFileName);

      XMLTagInfo.Init(PXT::GetProjLogfileXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strLogFileName);

      XMLTagInfo.Init(PXT::GetProjUserrifileXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bUseRRIFile);

      XMLTagInfo.Init(PXT::GetProjUselogfileXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_bUseLogFile);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_pNavigationOptions->GetDataString();
      m_strData += m_pGeneralOptions->GetDataString();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

public:
   XMLTAGINFORMATION m_XMLTagInformation;

} CXMLPROJECTOPTIONS, FAR* LPCXMLPROJECTOPTIONS;
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef class CProjectData : CLParamBase
{
private:
   CProjectData(CProjectData&);
   CProjectData& operator=(CProjectData&);

public:
   //////////////////////////////////////////////
   // Inline
   CProjectData() : m_pProjectOptions(NULL), m_pElementNavMap(NULL)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CProjectData()
   {
   }

   //////////////////////////////////////////////
   // Inline
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

   // Inline
   CPROJECTOPTIONS& GetProjectOptions()
   {
      ASSERT(m_pProjectOptions);
      return *m_pProjectOptions;
   }

   // Inline
   CPROJECTOPTIONS* GetProjectOptionsPtr()
   {
      ASSERT(m_pProjectOptions);
      return m_pProjectOptions;
   }

   //////////////////////////////////////////////
   // Inline
   CElementNavMap& GetElementNavMap()
   {
      ASSERT(m_pElementNavMap);
      return *m_pElementNavMap;
   }

   //////////////////////////////////////////////
   // Inline
   CElementNavMap* GetElementNavMapPtr()
   {
      ASSERT(m_pElementNavMap);
      return m_pElementNavMap;
   }

   //////////////////////////////////////////////
   // Data
public:
   CLString              m_strProjectName;
   CLString              m_strProjectFileName;
   CProjectOptions*     m_pProjectOptions;
   CElementNavMap*      m_pElementNavMap;

   CLString m_strData;
} CPROJECTDATA, FAR* LPCPROJECTDATA;

//////////////////////////////////////////////////////////////////////
typedef class CXMLProjectData : public CProjectData
{
private:
   CXMLProjectData(CXMLProjectData&);
   CXMLProjectData& operator=(CXMLProjectData&);

public:
   //////////////////////////////////////////////
   // Constructor
   CXMLProjectData() : m_XMLTagInformation(PXT::GetProjDataXMLTag(), _T("\t"))
   {
      m_pElementNavMap  = new CXMLElementNavMap();
      m_pProjectOptions = new CXMLPROJECTOPTIONS();

      CLString strTmp;
      strTmp.Format(_T("%s/%s"), PXT::GetProjectXMLTag(),m_XMLTagInformation.GetTagName());
      m_bstrXMLQuery  = strTmp;
   }

   // Destructor
   virtual ~CXMLProjectData()
   {
      delete m_pProjectOptions;
      delete m_pElementNavMap;
   }

public:
   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t");
      CXMLTagInformation XMLTagInfo(PXT::GetProjNameXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strProjectName);

      XMLTagInfo.Init(PXT::GetProjPathXMLTag(), strTabs);
      strTmp += XMLTagInfo.GetXMLString(m_strProjectFileName);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_pProjectOptions->GetDataString();
      m_strData += m_pElementNavMap->GetDataString();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   _bstr_t& GetProjectQueryXMLTag()
   {
      return m_bstrXMLQuery;
   }
public:
   _bstr_t           m_bstrXMLQuery;
   XMLTAGINFORMATION m_XMLTagInformation;
} CXMLPROJECTDATA, FAR* LPCXMLPROJECTDATA;

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
typedef class CProjectInformation
{
private:
   CProjectInformation(CProjectInformation&);
   CProjectInformation& operator=(CProjectInformation&);

public:
   //////////////////////////////////////////////
   // Inline
   CProjectInformation(bool bAutoCleanUp = false) : m_pProjectData(NULL), m_XMLTagInformation(PXT::GetProjectXMLTag()),
                           m_bAutoCleanUp(bAutoCleanUp)
   {
   }

   //////////////////////////////////////////////
   // Inline
   CProjectInformation(LPCPROJECTDATA pProjectData, bool bAutoCleanUp = false)
      : m_pProjectData(pProjectData), m_XMLTagInformation(PXT::GetProjectXMLTag()),
        m_bAutoCleanUp(bAutoCleanUp)
   {
   }

   //////////////////////////////////////////////
   // Inline
   virtual ~CProjectInformation()
   {
      if(m_bAutoCleanUp)
      {
         CleanUp();
      }
   }

   //////////////////////////////////////////////
   // IMPORTANT: Don't call this routine unless you're specifically
   // want this object to have absolute control of the memory allocated.
   void CleanUp()
   {
      if(m_pProjectData)
      {
         delete m_pProjectData;
         m_pProjectData = NULL;
      }
   }
   //////////////////////////////////////////////
   // Inline
   void SetProjectInformation(LPCPROJECTDATA pProjectData)
   {
      ASSERT(pProjectData);
      m_pProjectData = pProjectData;
   }

   //////////////////////////////////////////////
   // Inline
   CAppMapEx& GetAppMap()
   {
      return m_AppMap;
   }

   //////////////////////////////////////////////
   // Inline
   CProjectData& GetProjectData()
   {
      return *m_pProjectData;
   }

   //////////////////////////////////////////////
   // Inline
   CProjectData* GetProjectDataPtr()
   {
      return m_pProjectData;
   }

   //////////////////////////////////////////////
   virtual CLString& GetDataString()
   {
      m_strData.Empty();
      m_strData = _T("<?xml version=\"1.0\" standalone=\"no\"?>\n\n");
      m_strData += m_XMLTagInformation.GetTabbedStartTag();
      m_strData += m_pProjectData->GetDataString();

      // Application List
      CLString strTabs = _T("\t");
      CXMLTagInformation XMLTagInfo(XMLTAG_APPLICATION_LIST, strTabs);
      m_strData += XMLTagInfo.GetTabbedStartTag();
      if(GetAppMap().size())
      {
         iterAppMap iter    = GetAppMap().begin();
         iterAppMap iterEnd = GetAppMap().end();
         while(iter != iterEnd)
         {
            LPCAPPLICATIONDATA pAppData = (*iter).second;
            ASSERT(pAppData);
            m_strData += pAppData->GetDataString();
            iter++;
         }
      }

      m_strData += XMLTagInfo.GetTabbedEndTag();
      m_strData += GetRaidReportDataPtr()->GetDataString();   // Add RAID information
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   // Inline
   bool IsModified()
   {
      return m_bModified;
   }

   // Inline
   CRAIDREPORTDATA& GetRaidReportData()
   {
      return m_RaidReportData;
   }

   // Inline
   LPCRAIDREPORTDATA GetRaidReportDataPtr()
   {
      return &m_RaidReportData;
   }

   // Inline
   void SetModified(bool bModified = true)
   {
      m_bModified = bModified;
   }
   //////////////////////////////////////////////
   // Data
public:
   LPCPROJECTDATA     m_pProjectData;
   CXMLRAIDREPORTDATA m_RaidReportData;
   CAppMapEx          m_AppMap;      
   bool               m_bAutoCleanUp;
   bool               m_bModified;   
   CLString            m_strData;     
   XMLTAGINFORMATION  m_XMLTagInformation;

} CPROJECTINFORMATION, FAR* LPCPROJECTINFORMATION;

#endif // !defined(AFX_PROJECTDATASTRUCTS_H__A1B64483_53BD_11D2_8780_00C04F8DA632__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\processfilename.h ===
// ProcessFileName.h: interface for the CProcessFileName class.
//
////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROCESSFILENAME_H__CA00ED34_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_)
#define AFX_PROCESSFILENAME_H__CA00ED34_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
enum enumProcessFileName
{
   PROCESSFILE_UNDEFINED      = 0x00000000L,
   PROCESSFILE_NOREADLY       = 0x00000001L,
   PROCESSFILE_PROPERFILENAME = 0x00000002L,
   PROCESSFILE_VERIFYDIRECTORY= 0x00000004L,
   PROCESSFILE_VERIFYFILENAME = 0x00000008L,
   PROCESSFILE_VERIFYFILEEXT  = 0x00000010L,
   PROCESSFILE_ALLOWNEWFILES  = 0x00000020L,
   PROCESSFILE_APPEND         = 0x00000040L,
   PROCESSFILE_OVERWRITE      = 0x00000080L,
};

typedef class CProcessFileName
{
public:
   CProcessFileName();
   CProcessFileName(CLString* pStrDefaultExt, CLString* pStrRequiredExt, ULONG ulFlags);
   CProcessFileName(LPCTSTR pszDefaultExt, LPCTSTR pszRequiredExt, ULONG ulFlags);
   virtual ~CProcessFileName();

public:
   void SetValues(CLString* pStrDefaultExt, CLString* pStrRequiredExt, ULONG ulFlags);
   void SetValues(LPCTSTR pszDefaultExt, LPCTSTR pszRequiredExt, ULONG ulFlags);
   void ClearOutValues();
	void SetAllowReadOnly(bool bAllowReadOnly);

public:
   CLString  m_strDefaultExt;
   CLString  m_strRequiredExt;
   CLString  m_strOutputFileName; // Out parameter
   CLString  m_strOutputDirName;  // Out parameter
   CLString  m_strOutFileTitle;   // Out parameter
   CLString  m_strOutErrorMsg;    // Out parameter
   bool     m_bNewFile;
   ULONG    m_ulFlags;
	bool     m_bAllowReadOnly;
} CPROCESSFILENAME, FAR* LPCPROCESSFILENAME;

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
typedef class CCheckFileName : public CProcessFileName
{
public:
   // Inline
   CCheckFileName()
   {
   }

   // Inline
   CCheckFileName(CLString* pStrDefaultExt, CLString* pStrRequiredExt, ULONG ulFlags) 
                  : CProcessFileName(pStrDefaultExt, pStrRequiredExt, ulFlags)
   {
   }

   // Inline
   CCheckFileName(LPCTSTR pszDefaultExt, LPCTSTR pszRequiredExt, ULONG ulFlags)
                  : CProcessFileName(pszDefaultExt, pszRequiredExt, ulFlags)
   {
   }

   // inline
   BOOL CheckFileName(const CLString& strOriginalFileName, BOOL bAppend, UINT uAppendMsgID = 0, BOOL bDisplayMsg = true);
	BOOL CheckFileName(const CLString& strOriginalFileName, BOOL bAppend, CLString strErrorMessage = _T(""), BOOL bDisplayMsg =true);
	BOOL DoesFileExist(const CLString& strFileName, const CLString& strExt, bool bDisplayMsg = false);
	BOOL VerifyNewFile(const CLString& strFileName, const CLString& strExt, bool bDisplayMsg = false);

private:
} CCHECKFILENAME, FAR* LPCCHECKFILENAME;

#endif // !defined(AFX_PROCESSFILENAME_H__CA00ED34_46D7_11D2_8DAA_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\lunknown.inl ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\resid.h ===
//-----------------------------------------------------------------------------
//  
//  File: resid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\puid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: puid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\raiddatastructs.h ===
//////////////////////////////////////////////////////////////////
// RaidDataStructs.h: interface for the CRaidDataStructs class.
//
//////////////////////////////////////////////////////////////////

#if !defined(AFX_RAIDDATASTRUCTS_H__5FD93F0B_81D9_11D2_8162_00C04F68FDA4__INCLUDED_)
#define AFX_RAIDDATASTRUCTS_H__5FD93F0B_81D9_11D2_8162_00C04F68FDA4__INCLUDED_

#include "XMLBase.h"
#include "XmlTagInformation.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
//////////////////////////////////////////////////////////////////
const LPCTSTR  STR_RAID_BUGREPORT            = _T("BUGREPORT");

const LPCTSTR  STR_RAIDFILE_BUG_STATUS       = _T("BUG_STATUS");
const LPCTSTR  STR_RAIDFILE_ACCESSIBILITY    = _T("Accessibility");
const LPCTSTR  STR_RAIDFILE_ASSIGNEDTO       = _T("AssignedTo");
const LPCTSTR  STR_RAIDFILE_BY               = _T("BY");
const LPCTSTR  STR_RAIDFILE_ISSUETYPE        = _T("IssueType");
const LPCTSTR  STR_RAIDFILE_SEVERITY         = _T("Severity");
                                             
const LPCTSTR  STR_RAIDFILE_BUG_OPENED       = _T("BUG_OPENED");
const LPCTSTR  STR_RAIDFILE_OPENEDBY         = _T("OpenedBy");
const LPCTSTR  STR_RAIDFILE_SOURCE           = _T("Source");
const LPCTSTR  STR_RAIDFILE_BETAID           = _T("BetaID");
const LPCTSTR  STR_RAIDFILE_REVISION         = _T("FixedRev");
const LPCTSTR  STR_RAIDFILE_SOURCEID         = _T("SourceID");
const LPCTSTR  STR_RAIDFILE_HOWFOUND         = _T("HowFound");
const LPCTSTR  STR_RAIDFILE_LANGUAGE         = _T("Lang");

const LPCTSTR  STR_RAIDFILE_BUG_DESCRIPTION  = _T("BUG_DESCRIPTION");
const LPCTSTR  STR_RAIDFILE_DESCRIPTION      = _T("Description");

const LPCTSTR  STR_RAIDFILE_BUG_GENERAL      = _T("BUG_GENERAL");
const LPCTSTR  STR_RAIDFILE_TITLE            = _T("Title      ");
const LPCTSTR  STR_RAIDFILE_ENVIRONMENT      = _T("Environment");

const LPCTSTR  STR_RAIDFILE_ACTION           = _T("Action");
const LPCTSTR  STR_RAIDFILE_ACTION_ADD       = _T("Add");
const LPCTSTR  STR_RAIDFILE_ACTION_CHANGE    = _T("Change");
const LPCTSTR  STR_RAIDFILE_ACTION_ATTACH    = _T("Attach");

//////////////////////////////////////////////////////////////////
typedef class CRaidFileFields
{
public:
   static LPCTSTR GetBugReportFileField()       { return STR_RAID_BUGREPORT          ; }
                                                                                        
   static LPCTSTR GetBugStatusFileField()       { return STR_RAIDFILE_BUG_STATUS     ; }
   static LPCTSTR GetAccessibilityFileField()   { return STR_RAIDFILE_ACCESSIBILITY  ; }
   static LPCTSTR GetAssignedtoFileField()      { return STR_RAIDFILE_ASSIGNEDTO     ; }
   static LPCTSTR GetByFileField()              { return STR_RAIDFILE_BY             ; }
   static LPCTSTR GetIssuetypeFileField()       { return STR_RAIDFILE_ISSUETYPE      ; }
   static LPCTSTR GetSeverityFileField()        { return STR_RAIDFILE_SEVERITY       ; }
                                                                                        
   static LPCTSTR GetBugOpenedFileField()       { return STR_RAIDFILE_BUG_OPENED     ; }
   static LPCTSTR GetOpenedbyFileField()        { return STR_RAIDFILE_OPENEDBY       ; }
   static LPCTSTR GetSourceFileField()          { return STR_RAIDFILE_SOURCE         ; }
   static LPCTSTR GetBetaidFileField()          { return STR_RAIDFILE_BETAID         ; }
   static LPCTSTR GetRevisionFileField()        { return STR_RAIDFILE_REVISION       ; }
   static LPCTSTR GetSourceIDFileField()        { return STR_RAIDFILE_SOURCEID       ; }
   static LPCTSTR GetHowfoundFileField()        { return STR_RAIDFILE_HOWFOUND       ; }
   static LPCTSTR GetLanguageFileField()        { return STR_RAIDFILE_LANGUAGE       ; }
                                                                                     
   static LPCTSTR GetBugDescriptionFileField()  { return STR_RAIDFILE_BUG_DESCRIPTION; }
   static LPCTSTR GetDescriptionFileField()     { return STR_RAIDFILE_DESCRIPTION    ; }
                                                                                     
   static LPCTSTR GetBugGeneralFileField()      { return STR_RAIDFILE_BUG_GENERAL    ; }
   static LPCTSTR GetTitleFileField()           { return STR_RAIDFILE_TITLE          ; }
   static LPCTSTR GetEnvironmentFileField()     { return STR_RAIDFILE_ENVIRONMENT    ; }
                                                                                       
   static LPCTSTR GetActionFileField()          { return STR_RAIDFILE_ACTION       ; }
   static LPCTSTR GetAddFileField()             { return STR_RAIDFILE_ACTION_ADD   ; }
   static LPCTSTR GetChangeFileField()          { return STR_RAIDFILE_ACTION_CHANGE; }
   static LPCTSTR GetAttachFileField()          { return STR_RAIDFILE_ACTION_ATTACH; }

 } CRAIDFILEFIELDS, FAR* LPCRAIDFILEFIELDS;

typedef CRAIDFILEFIELDS RFF;

//////////////////////////////////////////////////////////////////
const LPCTSTR  STR_RAIDTAG_BUGREPORT     = _T("BUGREPORT");

const LPCTSTR  STR_RAIDTAG_BUG_STATUS    = _T("BUG_STATUS");
const LPCTSTR  STR_RAIDTAG_ACCESSIBILITY = _T("ACCESSIBILITY");
const LPCTSTR  STR_RAIDTAG_ASSIGNEDTO    = _T("ASSIGNEDTO");
const LPCTSTR  STR_RAIDTAG_BY            = _T("BY");
const LPCTSTR  STR_RAIDTAG_ISSUETYPE     = _T("ISSUETYPE");
const LPCTSTR  STR_RAIDTAG_SEVERITY      = _T("SEVERITY");
   
const LPCTSTR  STR_RAIDTAG_BUG_OPENED    = _T("BUG_OPENED");
const LPCTSTR  STR_RAIDTAG_OPENEDBY      = _T("OPENEDBY");
const LPCTSTR  STR_RAIDTAG_SOURCE        = _T("SOURCE");
const LPCTSTR  STR_RAIDTAG_BETAID        = _T("BETAID");
const LPCTSTR  STR_RAIDTAG_REVISION      = _T("REVISION");
const LPCTSTR  STR_RAIDTAG_SOURCEID      = _T("SOURCEID");
const LPCTSTR  STR_RAIDTAG_HOWFOUND      = _T("HOWFOUND");
const LPCTSTR  STR_RAIDTAG_LANGUAGE      = _T("LANGUAGE");

const LPCTSTR  STR_RAIDTAG_BUG_DESCRIPTION = _T("BUG_DESCRIPTION");
const LPCTSTR  STR_RAIDTAG_DESCRIPTION     = _T("DESCRIPTION");

const LPCTSTR  STR_RAIDTAG_BUG_GENERAL = _T("BUG_GENERAL");
const LPCTSTR  STR_RAIDTAG_TITLE       = _T("TITLE      ");
const LPCTSTR  STR_RAIDTAG_ENVIRONMENT = _T("ENVIRONMENT");

const LPCTSTR  STR_RAIDTAG_FILENAME    = _T("FILENAME");

//////////////////////////////////////////////////////////////////
typedef class CRaidXMLTags
{
public:
   static LPCTSTR GetBugReportXMLTag()       { return STR_RAIDTAG_BUGREPORT   ; }

   static LPCTSTR GetBugStatusXMLTag()       { return STR_RAIDTAG_BUG_STATUS   ; }
   static LPCTSTR GetAccessibilityXMLTag()   { return STR_RAIDTAG_ACCESSIBILITY; }
   static LPCTSTR GetAssignedtoXMLTag()      { return STR_RAIDTAG_ASSIGNEDTO   ; }
   static LPCTSTR GetByXMLTag()              { return STR_RAIDTAG_BY           ; }
   static LPCTSTR GetIssuetypeXMLTag()       { return STR_RAIDTAG_ISSUETYPE    ; }
   static LPCTSTR GetSeverityXMLTag()        { return STR_RAIDTAG_SEVERITY     ; }
                                                                      
   static LPCTSTR GetBugOpenedXMLTag()       { return STR_RAIDTAG_BUG_OPENED   ; }
   static LPCTSTR GetOpenedbyXMLTag()        { return STR_RAIDTAG_OPENEDBY     ; }
   static LPCTSTR GetSourceXMLTag()          { return STR_RAIDTAG_SOURCE       ; }
   static LPCTSTR GetBetaidXMLTag()          { return STR_RAIDTAG_BETAID       ; }
   static LPCTSTR GetRevisionXMLTag()        { return STR_RAIDTAG_REVISION     ; }
   static LPCTSTR GetSourceIDXMLTag()        { return STR_RAIDTAG_SOURCEID    ; }
   static LPCTSTR GetHowfoundXMLTag()        { return STR_RAIDTAG_HOWFOUND     ; }
   static LPCTSTR GetLanguageXMLTag()        { return STR_RAIDTAG_LANGUAGE     ; }

   static LPCTSTR GetBugDescriptionXMLTag()  { return STR_RAIDTAG_BUG_DESCRIPTION; }
   static LPCTSTR GetDescriptionXMLTag()     { return STR_RAIDTAG_DESCRIPTION    ; }

   static LPCTSTR GetBugGeneralXMLTag()      { return STR_RAIDTAG_BUG_GENERAL; }
   static LPCTSTR GetTitleXMLTag()           { return STR_RAIDTAG_TITLE      ; }
   static LPCTSTR GetEnvironmentXMLTag()     { return STR_RAIDTAG_ENVIRONMENT; }
                                                                         
   static LPCTSTR GetFilenameXMLTag()        { return STR_RAIDTAG_FILENAME   ; }

} CRAIDXMLTAGS, FAR* LPCRAIDXMLTAGS;

typedef CRAIDXMLTAGS BXT;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidFileBase
{
public:
   // INLINE
   CRaidFileBase()
   {
   }

   // INLINE
   virtual ~CRaidFileBase()
   {
   }

   CLString GetLine(CLString strFieldName, CLString strValue)
   {
      CLString strLine;
      ASSERT(!strFieldName.IsEmpty());
      if(!strFieldName.IsEmpty() && !strValue.IsEmpty())
      {
         strLine.Format(_T("%s=%s\n"), strFieldName, strValue);
      }
      return strLine;
   }

   CLString GetQuotedLine(CLString strFieldName, CLString strValue)
   {
      CLString strLine;
      ASSERT(!strFieldName.IsEmpty());
      if(!strFieldName.IsEmpty() && !strValue.IsEmpty())
      {
         strLine.Format(_T("%s='%s'\n"), strFieldName, strValue);
      }
      return strLine;
   }

public:

} CRAIDFILEBASE, FAR* LPCRAIDFILEBASE;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportBase() : m_bInitialized(false), m_bEnabled(true)
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportBase()
   {
   }

   //////////////////////////////////////////////
   //Inline
   bool IsInitialized()
   {
      return m_bInitialized;
   }

   //////////////////////////////////////////////
   //Inline
   void SetInitialized(bool bInitialized)
   {
      m_bInitialized = bInitialized;
   }

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetDataString() = 0;

   //////////////////////////////////////////////
   // Pure virtual function.
   virtual CLString& GetFileString() = 0;

   //////////////////////////////////////////////
   // data members
public:
   CLString  m_strData;
   bool     m_bInitialized;
   bool     m_bEnabled;
} CRAIDREPORTBASE, FAR* LPCRAIDREPORTBASE;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportStatus : public CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportStatus()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportStatus()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CRaidReportStatus& refLeftValue)
   {
      refLeftValue.m_strAccessibility = m_strAccessibility;
      refLeftValue.m_strAssignedTo    = m_strAssignedTo   ;
      refLeftValue.m_strBy            = m_strBy           ;
      refLeftValue.m_strIssueType     = m_strIssueType    ;
      refLeftValue.m_strSeverity      = m_strSeverity     ;
      refLeftValue.m_strData          = m_strData;
   }

   //////////////////////////////////////////////
   // data members
public:
   CLString  m_strAccessibility;
   CLString  m_strAssignedTo;
   CLString  m_strBy;
   CLString  m_strIssueType;
   CLString  m_strSeverity;
} CRAIDREPORTSTATUS, FAR* LPCRAIDREPORTSTATUS;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportOpened : public CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportOpened()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportOpened()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CRaidReportOpened& refLeftValue)
   {
      refLeftValue.m_strOpenedBy = m_strOpenedBy;
      refLeftValue.m_strSource   = m_strSource  ;
      refLeftValue.m_strBetaID   = m_strBetaID  ;
      refLeftValue.m_strRevision = m_strRevision;
      refLeftValue.m_strSourceID = m_strSourceID;
      refLeftValue.m_strHowFound = m_strHowFound;
      refLeftValue.m_strLanguage = m_strLanguage;
      refLeftValue.m_strData     = m_strData;
   }

   //////////////////////////////////////////////
   // data members
public:
   CLString  m_strOpenedBy;
   CLString  m_strSource;
   CLString  m_strBetaID;
   CLString  m_strRevision;
   CLString  m_strSourceID;
   CLString  m_strHowFound;
   CLString  m_strLanguage;
} CRAIDREPORTOPENED, FAR* LPCRAIDREPORTOPENED;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportDescription : public CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportDescription()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportDescription()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CRaidReportDescription& refLeftValue)
   {
      refLeftValue.m_strDescription = m_strDescription;
      refLeftValue.m_strData        = m_strData;
   }

   //////////////////////////////////////////////
   // data members
public:
   CLString  m_strDescription;
} CRAIDREPORTDESCRIPTION, FAR* LPCRAIDREPORTDESCRIPTION;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportGeneral : public CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportGeneral()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportGeneral()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CRaidReportGeneral& refLeftValue)
   {
      refLeftValue.m_strTitle             = m_strTitle      ;
      refLeftValue.m_strEnvironment       = m_strEnvironment;
      refLeftValue.m_strBugReportFileName = m_strEnvironment;
      refLeftValue.m_strData              = m_strData;
   }

   //////////////////////////////////////////////
   // data members
public:
   CLString  m_strTitle;
   CLString  m_strEnvironment;
   CLString  m_strBugReportFileName;
} CRAIDREPORTGENERAL, FAR* LPCRAIDREPORTGENERAL;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CRaidReportData : public CRaidReportBase
{
public:
   //////////////////////////////////////////////
   //Inline
   CRaidReportData()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CRaidReportData()
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual void Clone(CRaidReportData& refLeftValue)
   {
      GetRaidReportGeneralPtr()->Clone(refLeftValue.GetRaidReportGeneral()    );
      GetRaidReportDescriptionPtr()->Clone(refLeftValue.GetRaidReportDescription());
      GetRaidReportOpenedPtr()->Clone(refLeftValue.GetRaidReportOpened()     );
      GetRaidReportStatusPtr()->Clone(refLeftValue.GetRaidReportStatus()     );
   }

   // Get Get routines.
   CRaidReportGeneral    & GetRaidReportGeneral()     { return *m_pRaidReportGeneral;      }
   CRaidReportDescription& GetRaidReportDescription() { return *m_pRaidReportDescription;  }
   CRaidReportOpened     & GetRaidReportOpened()      { return *m_pRaidReportOpened;       }
   CRaidReportStatus     & GetRaidReportStatus()      { return *m_pRaidReportStatus;       }


   CRaidReportGeneral    * GetRaidReportGeneralPtr()     { return m_pRaidReportGeneral;      }
   CRaidReportDescription* GetRaidReportDescriptionPtr() { return m_pRaidReportDescription;  }
   CRaidReportOpened     * GetRaidReportOpenedPtr()      { return m_pRaidReportOpened;       }
   CRaidReportStatus     * GetRaidReportStatusPtr()      { return m_pRaidReportStatus;       }

   //////////////////////////////////////////////
   // data members
public:
   CRaidReportGeneral*      m_pRaidReportGeneral;
   CRaidReportDescription*  m_pRaidReportDescription;
   CRaidReportOpened*       m_pRaidReportOpened;
   CRaidReportStatus*       m_pRaidReportStatus;
} CRAIDREPORTDATA, FAR* LPCRAIDREPORTDATA;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CXMLRaidReportStatus : public CRaidReportStatus, public CXMLBase 
{
public:
   //////////////////////////////////////////////
   //Inline
   CXMLRaidReportStatus() : m_XMLTagInformation(BXT::GetBugStatusXMLTag(), _T("\t\t"))
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CXMLRaidReportStatus()
   {
   }

   // Override the base class definition
   IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent)
   {
      UNREFERENCED_PARAMETER(bstrNewTag);
	  UNREFERENCED_PARAMETER(var);
	  UNREFERENCED_PARAMETER(spXDNParent);
	  ASSERT(FALSE);
      return NULL;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(BXT::GetAccessibilityXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strAccessibility);

      strTmp += XMLTagInfo.GetXMLString(BXT::GetAssignedtoXMLTag() , m_strAssignedTo   , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetByXMLTag()         , m_strBy           , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetIssuetypeXMLTag()  , m_strIssueType    , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetSeverityXMLTag()   , m_strSeverity     , true);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetFileString()
   {
      CRaidFileBase raidFileBase;

      m_strData  = raidFileBase.GetLine(RFF::GetAccessibilityFileField(), m_strAccessibility);
      m_strData += raidFileBase.GetLine(RFF::GetAssignedtoFileField()   , m_strAssignedTo   );
      m_strData += raidFileBase.GetLine(RFF::GetByFileField()           , m_strBy           );
      m_strData += raidFileBase.GetLine(RFF::GetIssuetypeFileField()    , m_strIssueType    );
      m_strData += raidFileBase.GetLine(RFF::GetSeverityFileField()     , m_strSeverity     );
      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual bool ExtractXMLContents(IXMLDOMNodePtr spParentXDN)
   {
      _bstr_t bstrTag = BXT::GetBugStatusXMLTag();
      IXMLDOMNodePtr spXDNChild = spParentXDN->selectSingleNode(bstrTag);
      if(spXDNChild)
      {
         GetTagText(m_strAccessibility,BXT::GetAccessibilityXMLTag(), spXDNChild);
         GetTagText(m_strAssignedTo   ,BXT::GetAssignedtoXMLTag()   , spXDNChild);
         GetTagText(m_strBy           ,BXT::GetByXMLTag()           , spXDNChild);
         GetTagText(m_strIssueType    ,BXT::GetIssuetypeXMLTag()    , spXDNChild);
         GetTagText(m_strSeverity     ,BXT::GetSeverityXMLTag()     , spXDNChild);
      }
      return true;
   }

   //////////////////////////////////////////////
   // data members
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLRAIDREPORTSTATUS, FAR* LPCXMLRAIDREPORTSTATUS;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CXMLRaidReportOpened : public CRaidReportOpened, public CXMLBase 
{
public:
   //////////////////////////////////////////////
   //Inline
   CXMLRaidReportOpened() : m_XMLTagInformation(BXT::GetBugOpenedXMLTag(), _T("\t\t"))
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CXMLRaidReportOpened()
   {
   }

   // Override the base class definition
   IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent)
   {
      UNREFERENCED_PARAMETER(bstrNewTag);
	  UNREFERENCED_PARAMETER(var);
	  UNREFERENCED_PARAMETER(spXDNParent);
      ASSERT(FALSE);
      return NULL;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(BXT::GetOpenedbyXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strOpenedBy);

      strTmp += XMLTagInfo.GetXMLString(BXT::GetSourceXMLTag()  , m_strSource   , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetBetaidXMLTag()  , m_strBetaID   , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetRevisionXMLTag(), m_strRevision , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetSourceIDXMLTag(), m_strSourceID , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetHowfoundXMLTag(), m_strHowFound , true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetLanguageXMLTag(), m_strLanguage , true);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetFileString()
   {
      CRaidFileBase raidFileBase;

      m_strData  = raidFileBase.GetLine(RFF::GetOpenedbyFileField() , m_strOpenedBy);
      m_strData += raidFileBase.GetLine(RFF::GetSourceFileField()   , m_strSource  );
      m_strData += raidFileBase.GetLine(RFF::GetBetaidFileField()   , m_strBetaID  );
      m_strData += raidFileBase.GetLine(RFF::GetRevisionFileField() , m_strRevision);
      m_strData += raidFileBase.GetLine(RFF::GetSourceIDFileField() , m_strSourceID);
      m_strData += raidFileBase.GetLine(RFF::GetHowfoundFileField() , m_strHowFound);
      m_strData += raidFileBase.GetLine(RFF::GetLanguageFileField() , m_strLanguage);
      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual bool ExtractXMLContents(IXMLDOMNodePtr spParentXDN)
   {
      _bstr_t bstrTag = BXT::GetBugOpenedXMLTag();
      IXMLDOMNodePtr spXDNChild = spParentXDN->selectSingleNode(bstrTag);
      if(spXDNChild)
      {
         GetTagText(m_strOpenedBy,BXT::GetOpenedbyXMLTag() , spXDNChild);
         GetTagText(m_strSource  ,BXT::GetSourceXMLTag()   , spXDNChild);
         GetTagText(m_strBetaID  ,BXT::GetBetaidXMLTag()   , spXDNChild);
         GetTagText(m_strRevision,BXT::GetRevisionXMLTag() , spXDNChild);
         GetTagText(m_strSourceID,BXT::GetSourceIDXMLTag() , spXDNChild);
         GetTagText(m_strHowFound,BXT::GetHowfoundXMLTag() , spXDNChild);
         GetTagText(m_strLanguage,BXT::GetLanguageXMLTag() , spXDNChild);
      }
      return true;
   }

   //////////////////////////////////////////////
   // data members
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLRAIDREPORTOPENED, FAR* LPCXMLRAIDREPORTOPENED;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CXMLRaidReportDescription : public CRaidReportDescription, public CXMLBase 
{
public:
   //////////////////////////////////////////////
   //Inline
   CXMLRaidReportDescription() : m_XMLTagInformation(BXT::GetBugDescriptionXMLTag(), _T("\t\t"))
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CXMLRaidReportDescription()
   {
   }

   // Override the base class definition
   IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent)
   {
      UNREFERENCED_PARAMETER(bstrNewTag);
	  UNREFERENCED_PARAMETER(var);
	  UNREFERENCED_PARAMETER(spXDNParent);
      ASSERT(FALSE);
      return NULL;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(BXT::GetDescriptionXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strDescription);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetFileString()
   {
      CRaidFileBase raidFileBase;
      m_strData  = raidFileBase.GetQuotedLine(RFF::GetDescriptionFileField() , m_strDescription);
      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual bool ExtractXMLContents(IXMLDOMNodePtr spParentXDN)
   {
      _bstr_t bstrTag = BXT::GetBugDescriptionXMLTag();
      IXMLDOMNodePtr spXDNChild = spParentXDN->selectSingleNode(bstrTag);
      if(spXDNChild)
      {
         GetTagText(m_strDescription, BXT::GetDescriptionXMLTag(), spXDNChild);
      }
      return true;
   }

   //////////////////////////////////////////////
   // data members
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLRAIDREPORTDESCRIPTION, FAR* LPCXMLRAIDREPORTDESCRIPTION;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CXMLRaidReportGeneral : public CRaidReportGeneral, public CXMLBase 
{
public:
   //////////////////////////////////////////////
   //Inline
   CXMLRaidReportGeneral() : m_XMLTagInformation(BXT::GetBugGeneralXMLTag(), _T("\t\t"))
   {
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CXMLRaidReportGeneral()
   {
   }

   // Override the base class definition
   IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent)
   {
      UNREFERENCED_PARAMETER(bstrNewTag);
	  UNREFERENCED_PARAMETER(var);
	  UNREFERENCED_PARAMETER(spXDNParent);
      ASSERT(FALSE);
      return NULL;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      CLString strTabs = _T("\t\t\t");
      CXMLTagInformation XMLTagInfo(BXT::GetTitleXMLTag(), strTabs);
      CLString strTmp = XMLTagInfo.GetXMLString(m_strTitle);

      strTmp += XMLTagInfo.GetXMLString(BXT::GetEnvironmentXMLTag(), m_strEnvironment, true);
      strTmp += XMLTagInfo.GetXMLString(BXT::GetFilenameXMLTag(), m_strBugReportFileName, true);

      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += strTmp;
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetFileString()
   {
      CRaidFileBase raidFileBase;

      m_strData  = raidFileBase.GetLine(RFF::GetTitleFileField()       , m_strTitle      );
      m_strData += raidFileBase.GetLine(RFF::GetEnvironmentFileField() , m_strEnvironment);
      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual bool ExtractXMLContents(IXMLDOMNodePtr spParentXDN)
   {
      _bstr_t bstrTag = BXT::GetBugGeneralXMLTag();
      IXMLDOMNodePtr spXDNChild = spParentXDN->selectSingleNode(bstrTag);
      if(spXDNChild)
      {
         GetTagText(m_strTitle            , BXT::GetTitleXMLTag()       , spXDNChild);
         GetTagText(m_strEnvironment      , BXT::GetEnvironmentXMLTag() , spXDNChild);
         GetTagText(m_strBugReportFileName, BXT::GetFilenameXMLTag()    , spXDNChild);
      }
      return true;
   }

   //////////////////////////////////////////////
   // data members
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLRAIDREPORTGENERAL, FAR* LPCXMLRAIDREPORTGENERAL;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class CXMLRaidReportData : public CRaidReportData, public CXMLBase 
{
public:
   //////////////////////////////////////////////
   //Inline
   CXMLRaidReportData() : m_XMLTagInformation(BXT::GetBugReportXMLTag(), _T("\t"))
   {
      m_pRaidReportGeneral      = new CXMLRaidReportGeneral    ();
      m_pRaidReportDescription  = new CXMLRaidReportDescription();
      m_pRaidReportOpened       = new CXMLRaidReportOpened     ();
      m_pRaidReportStatus       = new CXMLRaidReportStatus     ();
   }

   //////////////////////////////////////////////
   //Inline
   virtual ~CXMLRaidReportData()
   {
      delete m_pRaidReportGeneral    ;
      delete m_pRaidReportDescription;
      delete m_pRaidReportOpened     ;
      delete m_pRaidReportStatus     ;
   }

   // Override the base class definition
   IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent)
   {
      UNREFERENCED_PARAMETER(bstrNewTag);
	  UNREFERENCED_PARAMETER(var);
	  UNREFERENCED_PARAMETER(spXDNParent);
      ASSERT(FALSE);
      return NULL;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetDataString()
   {
      m_strData = m_XMLTagInformation.GetTabbedStartTag();
      m_strData += GetRaidReportGeneralPtr()->GetDataString();
      m_strData += GetRaidReportDescriptionPtr()->GetDataString();
      m_strData += GetRaidReportOpenedPtr()->GetDataString();
      m_strData += GetRaidReportStatusPtr()->GetDataString();
      m_strData += m_XMLTagInformation.GetTabbedEndTag();
      return m_strData;
   }

   //////////////////////////////////////////////
   // virtual function.
   virtual CLString& GetFileString()
   {
      m_strData.Empty();
      CLString strTmp;
      CRaidFileBase raidFileBase;
      strTmp  = GetRaidReportGeneralPtr()->GetFileString();
      strTmp += GetRaidReportOpenedPtr()->GetFileString();
      strTmp += GetRaidReportStatusPtr()->GetFileString();
      CLString strDescription = GetRaidReportDescriptionPtr()->GetFileString();
      if(!strTmp.IsEmpty() || !strDescription.IsEmpty())
      {
         strTmp    += strDescription;
         m_strData  = raidFileBase.GetLine(RFF::GetActionFileField(),RFF::GetAddFileField());
         m_strData += strTmp;
      }
      return m_strData;
   }

   //////////////////////////////////////////////
   // Inline
   virtual bool ExtractXMLContents(IXMLDOMNodePtr spXDNRaid)
   {
      if(spXDNRaid)
      {
         ((CXMLRaidReportGeneral*    )GetRaidReportGeneralPtr())->ExtractXMLContents(spXDNRaid);    
         ((CXMLRaidReportDescription*)GetRaidReportDescriptionPtr())->ExtractXMLContents(spXDNRaid);
         ((CXMLRaidReportOpened*     )GetRaidReportOpenedPtr())->ExtractXMLContents(spXDNRaid);     
         ((CXMLRaidReportStatus*     )GetRaidReportStatusPtr())->ExtractXMLContents(spXDNRaid);     
      }

      return true;
   }

   //////////////////////////////////////////////
   // data members
public:
   CXMLTagInformation m_XMLTagInformation;
} CXMLRAIDREPORTDATA, FAR* LPCXMLRAIDREPORTDATA;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
#endif // !defined(AFX_RAIDDATASTRUCTS_H__5FD93F0B_81D9_11D2_8162_00C04F68FDA4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#define IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\typeid.h ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4244 4310 4100 4786)

#pragma warning(disable : 4663 4244)

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxrich.h>		// MFC rich edit classes
#pragma warning(disable : 4310)
#include <comdef.h>			// COM
#include <afxpriv.h>		// for USE_CONVERSIONS stuff
#include <..\src\AfxImpl.h>

#include <afxtempl.h>

#include <map>
#include <list>

#define _ATL_APARTMENT_THREADED
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CLtaModule : public CComModule
{
public:
	LONG Unlock();
	LONG Lock();
	DWORD dwThreadID;
};
extern CLtaModule _Module;
#include <atlcom.h>

#include <mitutil.h>
#include <locutil.h>

#pragma warning(disable : 4786)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\rribase.h ===
//-----------------------------------------------------------------------------
//  
//  File: rribase.h
//  Copyright (C) 1999 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
// rribase.h : include file for basic RRI types and defines

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////
// RRI Specific
////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
	#import  "..\..\Import\Misc\LS\Debug\XML-NT.DLL"
#else
	#import  "..\..\Import\Misc\LS\Retail\XML-NT.DLL"
#endif

// Helper macros to put notes that are 'in your face' during compile time
#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)

#ifndef NO_TODO
#define TODO(m) message(__FILE__ "(" STRINGIZE(__LINE__) "): TODO: " m)
#define FUTURE(m) message(__FILE__ "(" STRINGIZE(__LINE__) "): FUTURE: " m)
#define NYI(m) message(__FILE__ "(" STRINGIZE(__LINE__) "): NYI: " m)
#else
#define TODO(m) 
#define FUTURE(m) 
#define NYI(m) 
#endif

const int   INT_MAX_NAVIGATION_MINUTES  = 1220;
const int   INT_MIN_NAVIGATION_MINUTES  = 1   ;
const int   INT_MAX_NAVIGATION_ACTIONS  = 10000;
const int   INT_MIN_NAVIGATION_ACTIONS  = 10   ;
const int   INT_MIN_NAVIGATION_DELAY    = 0;
const int   INT_MAX_NAVIGATION_DELAY    = 32000;

////////////////////////////////////////////////////////////////////
const LPTSTR STR_YES     = _T("yes");
const LPTSTR STR_NO      = _T("no");
const LPTSTR STR_NORESID = _T("<N/A>");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\rrixmlfile.h ===
// RriXMLFile.h: interface for the CRriXMLFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RRIXMLFILE_H__6AEA6863_68FC_11D2_879C_00C04F8DA632__INCLUDED_)
   #define AFX_RRIXMLFILE_H__6AEA6863_68FC_11D2_879C_00C04F8DA632__INCLUDED_

#include "LtaStd.h"  // Added by ClassView
#include "ProcessFileName.h"
#include "XMLBase.h"
#include "RaidDataStructs.h"

using namespace MSXML;


const LPTSTR STR_ALLITEMS         = _T("All");
const LPTSTR STR_NESTEDDIALOG     = _T("<nested dialog>");

const _bstr_t  BSTR_ROOTTAGTEXT          = _T("RRI");
const _bstr_t  BSTR_ROOTTAGSTART         = _T("<RRI>");
const _bstr_t  BSTR_ROOTTAGEND           = _T("</RRI>");
const _bstr_t  BSTR_TAG_DIALOGINFOSEC    = _T("DIALOGINFOSEC");
const _bstr_t  BSTR_TAG_MENUINFOSEC      = _T("MENUINFOSEC");

// RRI tags
const _bstr_t  BSTR_RRITAG_CRCKEY        = _T("STR_CRC");
const _bstr_t  BSTR_RRITAG_DIALOGINFO    = _T("DIALOGINFO");
const _bstr_t  BSTR_RRITAG_MENUINFO      = _T("MENUINFO");
const _bstr_t  BSTR_RRITAG_APP_NAME      = _T("APP_NAME");
const _bstr_t  BSTR_RRITAG_RES_MODULE    = _T("RES_MODULE");
const _bstr_t  BSTR_RRITAG_CAPTION       = _T("CAPTION");
const _bstr_t  BSTR_RRITAG_RES_ID        = _T("RES_ID");
const _bstr_t  BSTR_RRITAG_CONTROL       = _T("CONTROL");
const _bstr_t  BSTR_RRITAG_CTRLCLASSNAME = _T("CTRL_CLASS");
const _bstr_t  BSTR_RRITAG_CTRLID        = _T("CTRL_ID");

const _bstr_t  BSTR_QUERY_DIALOGINFO    = _T("./DIALOGINFO");
const _bstr_t  BSTR_QUERY_DIALOGINFOSEC = _T("./DIALOGINFOSEC");
const _bstr_t  BSTR_QUERY_MENUINFO      = _T("./MENUINFO");
const _bstr_t  BSTR_QUERY_MENUINFOSEC   = _T("./MENUINFOSEC");
const _bstr_t  BSTR_QUERY_WINDOWINFO    = _T("./WINDOWINFO");
const _bstr_t  BSTR_QUERY_DIALOG_CRCKEY = _T("DIALOGINFO/STR_CRC");
const _bstr_t  BSTR_QUERY_MENU_CRCKEY   = _T("MENUINFO/STR_CRC");
const _bstr_t  BSTR_QUERY_GET_DIALOGINFO= _T("./DIALOGINFOSEC/DIALOGINFO");
const _bstr_t  BSTR_QUERY_GET_MENUINFO  = _T("./MENUINFOSEC/MENUINFO");


typedef class CRriXMLTags
{
public:
   static _bstr_t  GetRootTextXMLTag()                {  return BSTR_ROOTTAGTEXT      ;}
   static _bstr_t  GetRootStartXMLTag()               {  return BSTR_ROOTTAGSTART     ;}
   static _bstr_t  GetRootEndXMLTag()                 {  return BSTR_ROOTTAGEND       ;}
   static _bstr_t  GetDialoginfosecXMLTag()           {  return BSTR_TAG_DIALOGINFOSEC;}
   static _bstr_t  GetMenuinfosecXMLTag()             {  return BSTR_TAG_MENUINFOSEC  ;}

   // RRI Tags
   static _bstr_t  GetRriCrckeyXMLTag()               {  return BSTR_RRITAG_CRCKEY     ;}
   static _bstr_t  GetRriDialoginfoXMLTag()           {  return BSTR_RRITAG_DIALOGINFO ;}
   static _bstr_t  GetRriMenuinfoXMLTag()             {  return BSTR_RRITAG_MENUINFO   ;}
   static _bstr_t  GetRriAppNameXMLTag()              {  return BSTR_RRITAG_APP_NAME   ;}
   static _bstr_t  GetRriResModuleXMLTag()            {  return BSTR_RRITAG_RES_MODULE ;}
   static _bstr_t  GetRriCaptionXMLTag()              {  return BSTR_RRITAG_CAPTION    ;}
   static _bstr_t  GetRriResIdXMLTag()                {  return BSTR_RRITAG_RES_ID     ;}
   static _bstr_t  GetRriControlXMLTag()              {  return BSTR_RRITAG_CONTROL    ;}
   static _bstr_t  GetRriCtrlClassNameXMLTag()        {  return BSTR_RRITAG_CTRLCLASSNAME    ;}
   static _bstr_t  GetRriCtrlIDXMLTag()               {  return BSTR_RRITAG_CTRLID           ;}

   // RRI queries
   static _bstr_t  GetQueryDialoginfoXMLTag()         {  return BSTR_QUERY_DIALOGINFO    ;}
   static _bstr_t  GetQueryDialoginfosecXMLTag()      {  return BSTR_QUERY_DIALOGINFOSEC ;}
   static _bstr_t  GetQueryMenuinfoXMLTag()           {  return BSTR_QUERY_MENUINFO      ;}
   static _bstr_t  GetQueryMenuinfosecXMLTag()        {  return BSTR_QUERY_MENUINFOSEC   ;}
   static _bstr_t  GetQueryWindowinfoXMLTag()         {  return BSTR_QUERY_WINDOWINFO    ;}
   static _bstr_t  GetQueryDialogCrckeyXMLTag()       {  return BSTR_QUERY_DIALOG_CRCKEY ;}
   static _bstr_t  GetQueryMenuCrckeyXMLTag()         {  return BSTR_QUERY_MENU_CRCKEY   ;}
   static _bstr_t  GetQueryGetDialoginfoXMLTag()      {  return BSTR_QUERY_GET_DIALOGINFO;}
   static _bstr_t  GetQueryGetMenuinfoXMLTag()        {  return BSTR_QUERY_GET_MENUINFO  ;}

   //   _bstr_t  GetXMLTag() {  return ; }

} CRRIXMLTAGS, FAR* LPCRRIXMLTAGS;

typedef CRRIXMLTAGS RXT;   //********


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef class LTAPIENTRY CRriNodeInfo
{
public:
   CRriNodeInfo();
   virtual ~CRriNodeInfo();

   IXMLDOMNodePtr GetRriXMLNodePtr();

   CLString GetCurRriModuleInfo(CLString& strOutPut);
   CLString GetCurRriModuleInfo();

public:
   CLString            m_strCRC;        
   CLString            m_strAppPath;    
   CLString            m_strID;         
   CLString            m_strCaption;    
   CLString            m_strModule;     
   _bstr_t            m_bstrNodeTag;   
   LPARAM             m_lParam;        
   IXMLDOMNodePtr     m_spRriNode;     

} CRRINODEINFO, FAR* LPCRRINODEINFO;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef  std::map<CLString, LPCRRINODEINFO, std::less<CLString> > CRriNodeMap;
typedef  CRriNodeMap::iterator iterNodeMap;
typedef  CRriNodeMap::value_type valueNode;

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
typedef  std::list<LPCRRINODEINFO> CRriNodeList;
typedef  CRriNodeList::iterator iterNodeList;
typedef  CRriNodeList::value_type valueListNode;

#pragma warning(disable : 4275)

//////////////////////////////////////////////////////////////////
typedef class LTAPIENTRY CRriNodeListEx : public CRriNodeList
{
public:
   CRriNodeListEx();
   virtual ~CRriNodeListEx();

public:
} CRRINODELISTEX, FAR* LPCRRINODELISTEX;

//////////////////////////////////////////////////////////////////
typedef class LTAPIENTRY CRriNodeMapEx : public CRriNodeMap
{
public:
   CRriNodeMapEx();
   virtual ~CRriNodeMapEx();

   virtual void CleanUp();

   bool InsertRriNode(LPCRRINODEINFO pItem);
   bool RemoveRriNode(LPCRRINODEINFO pItem);
   bool RemoveRriNode(CLString strCRC);

   iterNodeMap Find(CLString strCRC);
   bool Erase(CLString strCRC);

   bool RemoveAppRriNodes(const CLString& strAppPath);
   bool GetAppRriNodes(const CLString& strAppPath, CRriNodeListEx& refRriNodeList, _bstr_t bstrNodeTag = RXT::GetRriDialoginfoXMLTag());

   bool GetRriNodeList(const CLString& strID, const CLString& strCaption, const CLString& strAppPath, const CLString& strModule, CRriNodeListEx& refRriNodeList, _bstr_t bstrNodeTag = RXT::GetRriDialoginfoXMLTag());
   bool GetRriNodeList(CRriNodeListEx& refRriNodeList, _bstr_t bstrNodeTag = RXT::GetRriDialoginfoXMLTag());

   bool IsNodeTag(_bstr_t& bstrNodeTag, LPCRRINODEINFO pItem);

} CRRINODEMAPEX, FAR* LPCRRINODEMAPEX;

#pragma warning(default : 4275)

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
class LTAPIENTRY CRriXMLFile : public CXMLBase
{
public:
   CRriXMLFile();
   virtual ~CRriXMLFile();

public:
	void Close();
	bool RemoveRriDialogNode(LPCRRINODEINFO pNodeInfo);
	bool RemoveRriMenuNode(LPCRRINODEINFO pNodeInfo);
   bool Init();
   bool IsInitialized();
   bool IsLogging();

   bool IsFileAlreadyOpen(const CLString& strFileName);
	bool RemoveAppNodes(const CLString &strAppPath, _bstr_t bstrTagQuery);
   bool RemoveRriNode(LPCRRINODEINFO pNodeInfo, CLString strQuery);
   bool GetNodeData(LPCRRINODEINFO pNodeInfo, IXMLDOMNodePtr spXDN);
   bool GetDisplayID(CLString& strID, IXMLDOMNodePtr spXDN);
   bool RemoveAppNodes(const CLString& strAppPath);
   bool FillRriNodeMap(_bstr_t bstrQuery);
   bool Clear(bool bSaveDocFirst = true);
   bool SetXMLFileName(const CLString& strFileName, bool bCreate, bool& bAlreadyOpen);

   bool RemoveMenuInfo(IXMLDOMNodePtr spXDN);
   bool RemoveWindowInfo(IXMLDOMNodePtr spXDN);
   bool RemoveRriNodes();
   bool AddRriNode(IXMLDOMNodePtr spXDN, LPCRRINODEINFO* ppItem);
	void SetRaidReportData(CRaidReportData* pRaidReportData);

   bool SaveCurFile();
   bool SaveFile(const CLString& strFileName, bool bSetFileName = true);
   bool SaveFile(CStdioFile& stdioFile);
   bool GetRootNode(const _bstr_t &bstrRootNodeTag);
   bool CreateRootNode(const _bstr_t& bstrRootNodeTag);
   bool ReadFile(const CLString& strFileName, bool bSetFileName = true);
   bool CreateXMLFile(const CLString& strFileName);

   bool AddResource(const _bstr_t& bstrResource, LPCRRINODEINFO* ppItem );

   CRriNodeMapEx& GetRriNodeMap();
private:
   bool               m_bInitialized;
   CLString            m_strXMLFileName;
   CRriNodeMapEx      m_RriNodeMap;
   CRaidReportData*   m_pGlobalRaidReportData;
};

#endif // !defined(AFX_RRIXMLFILE_H__6AEA6863_68FC_11D2_879C_00C04F8DA632__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\resid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\xmlbase.h ===
// XMLBase.h: interface for the CXMLBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLBASE_H__E5C2DB63_6B7D_11D2_8DCF_204C4F4F5020__INCLUDED_)
#define AFX_XMLBASE_H__E5C2DB63_6B7D_11D2_8DCF_204C4F4F5020__INCLUDED_

#include "rribase.h"

using namespace MSXML;

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4251)

class LTAPIENTRY CXMLBase  
{
public:
	CXMLBase();
   virtual ~CXMLBase();

public:
	bool           GetTagItemsList(IXMLDOMNodePtr &spXDN,  _bstr_t bstrTag, CStringList& strList);
	bool           RemoveTagNodes(_bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	bool           IsTag(const _bstr_t strTag, IXMLDOMNodePtr &spXDN);

	virtual bool   GetTagText(int &nrefValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   GetTagText(CLString& strValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   GetTagText(_bstr_t& bstrValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   GetTagText(bool &nrefValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);

	virtual bool   GetTagTextYesNo(int &nrefValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   GetTagTextYesNo(bool &nrefValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);

	virtual bool   SetTagText(const CLString& strValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   SetTagText(DWORD dwValue, BOOL fHex, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);
	virtual bool   SetTagText(const _bstr_t& bstrValue, _bstr_t bstrQuery, IXMLDOMNodePtr &spXDN);

	virtual IXMLDOMNodePtr CreateNodeFromXMLString(const _bstr_t& bstrXML);
	virtual IXMLDOMNodePtr CreateXMLNode(const _bstr_t bstrNewTag, _variant_t& var, IXMLDOMNodePtr spXDNParent);

	IXMLDOMNodePtr SelectSingleNode(IXMLDOMNodePtr &spXDN, const _bstr_t queryString);

protected:
   IXMLDOMDocumentPtr m_spIXMLDOMDoc;
   IXMLDOMNodePtr     m_spRootNode;
};

#endif // !defined(AFX_XMLBASE_H__E5C2DB63_6B7D_11D2_8DCF_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\softinfo.h ===
//******************************************************************************
//
// SoftInfo.h: Software Utility classes
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and
	// mess people up.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\typeid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\uniqid.h ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  What we use to uniquely identify a localizable item.
//  
//-----------------------------------------------------------------------------
 

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\uniqid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
//-----------------------------------------------------------------------------
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\xmldlgitem.h ===
#ifndef __XMLDlgItem_H__
#define __XMLDlgItem_H__

/////////////////////////////////////////////////////////////////////////////
// Includes

#include "XMLBase.h"

// This is to disable the UnReferenced Local Vars in STL
#pragma warning( disable : 4100 4245 4786)
#define __PLACEMENT_NEW_INLINE
#include <list>
using namespace std;
#pragma warning( default : 4100 4245 )

/////////////////////////////////////////////////////////////////////////////
// Structure Declaration
// Although the structure is documented, It is not declared in Windows headers??
#if 0
#pragma pack(push, 1)
	struct DLGITEMTEMPLATEEX
	{
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		short x;
		short y;
		short cx;
		short cy;
		DWORD id;	// PAT According to the help, this should be a WORD but when I took
					// it from ATLWin declaration, it was a DWORD.  This could present
					// serious problems!  As MFC also declares this as a DWORD, I have
					// made a majarity rules decision.

		// Everything else in this structure is variable length,
		// and therefore must be determined dynamically

		// sz_Or_Ord windowClass;	// name or ordinal of a window class
		// sz_Or_Ord title;			// title string or ordinal of a resource
		// WORD extraCount;			// bytes following creation data
	};
#pragma pack(pop)
#endif

typedef DLGITEMTEMPLATEEX *LPDLGITEMTEMPLATEEX;

class LTAPIENTRY CXMLDlgItem : public CXMLBase
{
public:
	friend class CXMLDialog;

	enum EDlgItemType
	{
		DIT_CONTROL,                        // generic control (unknown)
		DIT_STATIC,                         // static control
		DIT_ICON,                           // icon
		DIT_RECT,                           // rectangle
		DIT_FRAME,                          // frame
		DIT_BITMAP,                         // bitmap
		DIT_METAFILE,                       // metafile
		DIT_OWNERDRAWBUTTON,                // owner draw button
		DIT_PUSHBUTTON,                     // pushbutton
		DIT_CHECKBOX,                       // checkbox
		DIT_RADIOBUTTON,                    // radio button
		DIT_GROUPBOX,                       // group box
		DIT_EDIT,                           // edit box
		DIT_COMBOBOX,                       // combo box
		DIT_LISTBOX,                        // listbox
		DIT_SCROLLBAR,                      // scroll bar
		DIT_LISTVIEW,                       // list view control
		DIT_TREEVIEW,                       // tree view control
		DIT_TABCONTROL,                     // tab control
		DIT_TABCONTROL16,                   // tab control (16 bit)
		DIT_ANIMATE,                        // animate control
		DIT_HOTKEY,                         // hotkey control
		DIT_TRACKBAR,                       // trackbar
		DIT_PROGRESS,                       // progress bar
		DIT_UPDOWN,                         // up-down control
		DIT_RICHEDIT,                       // rich edit control
		DIT_IPADDRESS,						// ip address control
		DIT_HEADER,							// header control
		DIT_PAGER,							// pager control
		DIT_TOOLBAR,						// toolbar control
		DIT_DIALOG,                         // dialog (nested)

		DIT_MENUITEM,                       // menu item

		DIT_RICHEDIT20,                     // rich edit 2.0    (Windows NT 4.0)
		DIT_COOLBAR,                        // cool bar         (IE 3.0)
		DIT_COMBOBOXEX,                     // combo box Ex     (IE 3.0)
		DIT_DATETIMEPICKER,                 // date time picker (IE 3.0)
		DIT_MONTHCAL,                       // month calendar   (IE 3.0)

		DIT_OWNERDRAW,                      // static control: owner-draw (fix)
		DIT_USERITEM,                       // static control: user item  (fix)

		DIT_SDM_CONTROL,                    // SDM generic control (unknown)
		DIT_SDM_STATICTEXT,                 // SDM static text
		DIT_SDM_PUSHBUTTON,                 // SDM push button
		DIT_SDM_CHECKBOX,                   // SDM check box
		DIT_SDM_RADIOBUTTON,                // SDM radio button
		DIT_SDM_GROUPBOX,                   // SDM group box
		DIT_SDM_EDIT,                       // SDM edit
		DIT_SDM_FORMATTEDTEXT,              // SDM formatted text
		DIT_SDM_LISTBOX,                    // SDM list box
		DIT_SDM_DROPLIST,                   // SDM drop list
		DIT_SDM_BITMAP,                     // SDM bitmap
		DIT_SDM_GENERALPICTURE,             // SDM general picture
		DIT_SDM_SCROLL,                     // SDM scroll bar
		DIT_SDM_COMBO_EDIT,                 // SDM combo edit
		DIT_SDM_SPIN_EDIT,                  // SDM spin  edit
		DIT_SDM_CONTROL_TITLE,              // SDM control title
		DIT_SDM_TAB_CONTROL,                // SDM tab control
		DIT_UNKNOWN							// unknown control
	};
	enum
	{
		WORD_SIZE = 2,
		WORD_ALIGN = WORD_SIZE - 1
	};

	// Construction
	CXMLDlgItem();
	// Destruction
	~CXMLDlgItem();


public:
	BOOL Init(IXMLDOMNodePtr &pControlNode);
	BOOL Update(IXMLDOMNodePtr &pControlNode);

	// Get/Set
	DWORD			GetSize()			{ return m_nSizeOfStruct; }
	DWORD			GetHelpID()			{ return m_HelpID; }
	DWORD			GetExStyle()		{ return m_ExStyle; }
	void			SetExStyle(DWORD dwExStyle)
										{ m_ExStyle = dwExStyle; }
	DWORD			GetStyle()			{ return m_Style; }
	void			SetStyle(DWORD dwStyle)
										{ m_Style = dwStyle; }
	short			GetXPos()			{ return m_xPos; }
	void			SetXPos(short xPos)	{ m_xPos = xPos; }
	short			GetYPos()			{ return m_yPos; }
	void			SetYPos(short yPos)	{ m_yPos = yPos; }
	short			GetXSize()			{ return m_xSize; }
	void			SetXSize(short xSize)
										{ m_xSize = xSize; }
	short			GetYSize()			{ return m_ySize; }
	void			SetYSize(short ySize)
										{ m_ySize = ySize; }
	DWORD			GetItemID()			{ return m_ItemID; }
	VOID			SetItemID(DWORD dwNewID);
	DWORD			GetOrigItemID()		{ return m_OrigItemID; }
	CLString		GetItemName()		{ return m_ItemName; }
	EDlgItemType	GetItemType()		{ return m_DlgItemType; }
	DWORD			GetTabOrder()		{ return m_TabOrder; }
	const CLocId &	GetWindowClass()	{ return m_WindowClass; }
	void			SetWindowClass(const CLocId &lidClass);
	CLString		GetTitle()			{ return m_Title; }
	void			SetTitle(const CLString strNewTitle)	{ m_Title = strNewTitle; }
	CLString		GetText()			{ return m_ControlText; }
	WORD			GetCountExtraBytes(){ return m_CountExtraBytes; }
	BYTE*			GetExtraBytes()		{ return m_pExtraBytes; }
	CLString		GetCurrInfo()		{ return m_szCurrInfo; }

	LPDLGITEMTEMPLATEEX GetDlgItemTemplate() { return m_pDlgItemTemplate; }

	BOOL			SetText(HWND hWndControl);

protected:
	BOOL	GetRect(IXMLDOMNodePtr &pControlNode);
	BOOL	SetRect(IXMLDOMNodePtr &pControlNode);
	DWORD	GetAttribute(IXMLDOMNodePtr &pDomNode);
	void	SetAttribute(DWORD dwAttr, IXMLDOMNodePtr &pDomNode);
	BOOL	GetControlText(IXMLDOMNodePtr &pControlNode);
	void	SetControlText(IXMLDOMNodePtr &pControlNode);
	BOOL	CreateDlgItemTemplate(BOOL fUseOrigItemIDs);
	DWORD	CalculateSize();
	BOOL	GetControlClass(IXMLDOMNodePtr &pControlNode);
	void	GetControlType(IXMLDOMNodePtr &pControlNode);
	void	ChangeControlStyle();

	BOOL	SetListBoxOrComboBoxText(HWND hWndControl, UINT uMsg, int nErr);
	BOOL	SetTabControlText(HWND hWndControl);
	void	SetButtonState(HWND hWndControl);


	DWORD			m_nSizeOfStruct;
	DWORD			m_HelpID;
	DWORD			m_ExStyle;
	DWORD			m_Style;
	short			m_xPos;
	short			m_yPos;
	short			m_xSize;
	short			m_ySize;
	DWORD			m_ItemID;
	DWORD			m_OrigItemID;		// Original ItemID
	CLString		m_ItemName;			// Unique name ID
	DWORD			m_TabOrder;			// tab order of this control
	CLocId			m_WindowClass;		// name or ordinal of a window class
	CLString		m_Title;			// title string of the dialog box
	CLString		m_ControlText;		// Additional text
	CLString		m_szCurrInfo;		// Current info
	WORD			m_CountExtraBytes;	// bytes of following creation data
	BYTE*			m_pExtraBytes;		// Pointer to extra bytes
	EDlgItemType	m_DlgItemType;		// Dialog item type


	LPDLGITEMTEMPLATEEX m_pDlgItemTemplate;

};


// Global routines for serialing data
DWORD DWordFromHexString (const char *psz);
DWORD Write(LPBYTE  pByte, DWORD Count, LPBYTE& lpOut);
DWORD WriteNameOrd(const CLocId &lid, LPBYTE& lpOut);

typedef list<CXMLDlgItem*> CXMLDlgItemList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\xmldialog.h ===
// XMLDialog.h: interface for the CXMLDialog class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLDIALOG_H__ADBD45EB_57FA_11D2_A37A_00C04FA31BFB__INCLUDED_)
#define AFX_XMLDIALOG_H__ADBD45EB_57FA_11D2_A37A_00C04FA31BFB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "XMLBase.h"
#include <winuser.h>
#include "XMLDlgItem.h"

/////////////////////////////////////////////////////////////////////////////
// Defines

const DWORD TYPEID_BUTTON = 0x80;
const DWORD TYPEID_EDIT = 0x81;
const DWORD TYPEID_STATIC = 0x82;
const DWORD TYPEID_LISTBOX = 0x83;
const DWORD TYPEID_SCROLLBAR = 0x84;
const DWORD TYPEID_COMBOBOX = 0x85;

/////////////////////////////////////////////////////////////////////////////
// Forward Declarations
/////////////////////////////////////////////////////////////////////////////
// Typedefs
typedef DLGTEMPLATEEX* LPDLGTEMPLATEEX;


class LTAPIENTRY CXMLDialog  : public CXMLBase
{
public:
	CXMLDialog();
	~CXMLDialog();

	enum
	{
		DWORD_SIZE = 4,
		DWORD_ALIGN = DWORD_SIZE - 1
	};

	BOOL	Init(IXMLDOMNodePtr pDialogNode);
	BOOL	Init(BYTE *pbyDlg, CLocItemPtrArray * prgLocItem);
	BOOL	Init(CMemFile *pmfDlg, CLocItemPtrArray * prgLocItem);
	void	Reset();
	void	SetFocus();

	BOOL	Update(IXMLDOMNodePtr pDialogNode);

	BOOL HighlightItems(IXMLDOMNodePtr &pDialogItem);
	BOOL AddHighlightRect(IXMLDOMNodePtr &pDialogItem);
	void AddHighlightRect(RECT& rectToHighlight);
	void DisplayDialog(HWND hWndParent = NULL, BOOL fHandleCancel = TRUE);
	void CloseDialog();
	BOOL IsDialogDisplayed()            { return ::IsWindow(m_hWndDlg); }
	LPDLGTEMPLATEEX GetDialogTemplate() { return m_pDlgTemplate; }

	DWORD			GetSizeOfStruct()	{ return m_nSizeOfStruct; }
	WORD			GetDialogVersion()	{ return m_DlgVer; }
	WORD			GetSignature()		{ return m_Signature; }
	DWORD			GetSubDialogMask()	{ return m_SubDlgMask; }
	DWORD			GetHelpID()			{ return m_HelpID; }
	DWORD			GetExStyle()		{ return m_ExStyle; }
	void			SetExStyle(DWORD dwExStyle)
										{ m_ExStyle = dwExStyle; }
	DWORD			GetStyle()			{ return m_Style; }
	void			SetStyle(DWORD dwStyle)
										{ m_Style = dwStyle; }
	WORD			GetItemCount()		{ return m_CountDlgItems; }
	short			GetXPos()			{ return m_xPos; }
	void			SetXPos(short xPos)	{ m_xPos = xPos; }
	short			GetYPos()			{ return m_yPos; }
	void			SetYPos(short yPos)	{ m_yPos = yPos; }
	short			GetXSize()			{ return m_xSize; }
	void			SetXSize(short xSize)
										{ m_xSize = xSize; }
	short			GetYSize()			{ return m_ySize; }
	void			SetYSize(short ySize)
										{ m_ySize = ySize; }
	const CLocId &	GetMenu()			{ return m_Menu; }
	const CLocId &	GetWindowClass()	{ return m_WindowClass; }
	CLString		GetTitle()			{ return m_Title; }
	void			SetTitle(const CLString strNewTitle)
										{ m_Title = strNewTitle; }
	short			GetFontPointSize()	{ return m_FontPointSize; }
	void			SetFontPointSize(short nSize)
										{ m_FontPointSize = nSize; }
	short			GetFontWeight()		{ return m_FontWeight; }
	void			SetFontWeight(short nWeight)
										{ m_FontWeight = nWeight; }
	short			GetIsFontItalic()	{ return m_bItalic; }
	void			SetIsFontItalic(short bItalic)
										{ m_bItalic = bItalic; }
	CLString		GetFontName()		{ return m_FontName; }
	void			SetFontName(const CLString &strName)
										{ m_FontName = strName; }
	CXMLDlgItemList& GetItemList()		{ return m_ItemList; }

	// JDG - Made this function public
	BOOL	CreateDlgTemplate(BOOL fUseOrigItemIDs);

protected:
	BOOL	ReadRes32(CDlgResFile *pDlgResFile, CLocItemPtrArray * prgLocItem);
	BOOL	ReadRes32(BYTE *pbBuffer, CLocItemPtrArray * prgLocItem);
	VOID	GetResIDName(CLocItemPtrArray *prgLocItem, int nLocIndex,
					CXMLDlgItem* pItem);

	DWORD	GetSize();
	BOOL	GetRect(IXMLDOMNodePtr &pDialogNode);
	BOOL	SetRect(IXMLDOMNodePtr &pDialogNode);
	DWORD	GetAttribute(IXMLDOMNodePtr &pDomNode);
	void	SetAttribute(DWORD dwAttr, IXMLDOMNodePtr &pDomNode);
	BOOL	GetControls(IXMLDOMNodePtr &pDialogNode);
	BOOL	SetControls(IXMLDOMNodePtr &pDialogNode);
	void	AddControl(IXMLDOMNodePtr &pControlNode);
	BOOL	OnInitDialog(HWND hWndDlg);
	void	CleanRectArray();

	static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

	LPDLGTEMPLATEEX	m_pDlgTemplate;
	HWND			m_hWndDlg;

	BOOL			m_fHandleCancel;
	// Members
	DWORD			m_nSizeOfStruct;

	DWORD			m_SubDlgMask;
	WORD			m_DlgVer;
	WORD			m_Signature;
	DWORD			m_HelpID;
	DWORD			m_ExStyle;
	DWORD			m_Style;
	WORD			m_CountDlgItems;
	short			m_xPos;
	short			m_yPos;
	short			m_xSize;
	short			m_ySize;
	CLocId			m_Menu;			// name or ordinal of a menu resource
	CLocId			m_WindowClass;	// name or ordinal of a window class
	CLString		m_Title;		// title string of the dialog box
	short			m_FontPointSize;// only if DS_SETFONT flag is set
	short			m_FontWeight;	// only if DS_SETFONT flag is set
	short			m_bItalic;		// only if DS_SETFONT flag is set
	CLString		m_FontName;		// typeface name, if DS_SETFONT is set
	CXMLDlgItemList	m_ItemList;		// List of Dialog Items.
	DWORD			m_dwBaseUnitX;
	DWORD			m_dwBaseUnitY;
	BOOL			m_fHighlightItem;

	CPtrArray		m_hltRectArray;

	static CMap<HWND, HWND&, CXMLDialog*, CXMLDialog*&> sm_XMLDialogMap;

private:
};


#endif // !defined(AFX_XMLDIALOG_H__ADBD45EB_57FA_11D2_A37A_00C04FA31BFB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\xmltaginformation.h ===
// XMLTagInformation.h: interface for the CXMLTagInformation class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XMLTAGINFORMATION_H__C76C2581_7678_11D2_8DD8_204C4F4F5020__INCLUDED_)
#define AFX_XMLTAGINFORMATION_H__C76C2581_7678_11D2_8DD8_204C4F4F5020__INCLUDED_

#include "rribase.h"
#include "GlobalRoutines.h"
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////
typedef class CXMLTagInformation
{
public:
   // Inline
   CXMLTagInformation(CLString strTagName, CLString strTabs = _T(""))
   {
      ASSERT(!strTagName.IsEmpty());
      Init(strTagName, strTabs);
   }

   // Inline
   virtual ~CXMLTagInformation()
   {
   }

public:
   // Inline
   const CLString& GetTagName()
   {
      ASSERT(!m_strTagName.IsEmpty());
      return m_strTagName;
   }

   // Inline
   const CLString& GetStartTag()
   {
      ASSERT(!m_strStartTag.IsEmpty());
      return m_strStartTag;
   }

   // Inline
   const CLString GetTabbedStartTag(bool bAddNewLine = true)
   {
      CLString strText;
      strText.Format(_T("%s%s%s"), m_strTabs, m_strStartTag, bAddNewLine ? _T("\n") : _T(""));
      return strText;
   }

   const CLString GetTabbedStartTag(CLString& strAttribute, bool bAddNewLine = true)
   {
      CLString strText;
      ::ReplaceEntityRefChars(strAttribute);
      strText.Format(_T("%s<%s %s>%s"), m_strTabs, m_strTagName, strAttribute, bAddNewLine ? _T("\n") : _T(""));
      return strText;
   }

   // Inline
   const CLString& GetEndTag()
   {
      ASSERT(!m_strEndTag.IsEmpty());
      return m_strEndTag;
   }

   // Inline
   const CLString GetTabbedEndTag(bool bAddNewLine = true)
   {
      CLString strText;
      strText.Format(_T("%s%s%s"), m_strTabs, m_strEndTag, bAddNewLine ? _T("\n") : _T(""));
      return strText;
   }

   // Inline
   void Init(const CLString& strTagName, const CLString& strTabs)
   {
      m_strTabs    = strTabs;
      m_strTagName = strTagName;
      m_strStartTag.Format(_T("<%s>"), strTagName);
      m_strEndTag.Format(_T("</%s>"), strTagName);
   }

   // Inline
   CLString& GetXMLString(CLString strXMLText, bool bAddNewLine = true)
   {
      ::ReplaceEntityRefChars(strXMLText);
      m_strXMLString.Format(_T("%s%s%s%s"), GetTabbedStartTag(false), strXMLText, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString& GetXMLString(TCHAR chXMLChar, bool bAddNewLine = true)
   {
      CLString strXMLText = chXMLChar;
      ::ReplaceEntityRefChars(strXMLText);
      m_strXMLString.Format(_T("%s%s%s%s"), GetTabbedStartTag(false), strXMLText, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString GetXMLCharList(CLString strXMLText, bool bAddNewLine = true)
   {
      UNREFERENCED_PARAMETER(bAddNewLine);
      CLString strTemp;
      int nLen = strXMLText.GetLength();
      if(nLen == 1)
      {
         strTemp += GetXMLString(strXMLText);
      }
      else
      {
         for(int i = 0; i < nLen; i++)
         {
            strTemp += GetXMLString(strXMLText.GetAt(i));
         }
      }
      return strTemp;
   }

   // Inline
   CLString& GetXMLString(const int& nValue, bool bAddNewLine = true)
   {
      m_strXMLString.Format(_T("%s%d%s%s"), GetTabbedStartTag(false), nValue, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString& GetXMLString(const CLString& strTagName, CLString strXMLText, bool bAddNewLine = true)
   {
      Init(strTagName, m_strTabs);
      ::ReplaceEntityRefChars(strXMLText);
      m_strXMLString.Format(_T("%s%s%s%s"), GetTabbedStartTag(false), strXMLText, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString& GetXMLString(const CLString& strTagName, const int& nValue, bool bAddNewLine = true)
   {
      Init(strTagName, m_strTabs);
      m_strXMLString.Format(_T("%s%d%s%s"), GetTabbedStartTag(false), nValue, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString& GetXMLStringYesNo(const CLString& strTagName, const int& nValue, bool bAddNewLine = true)
   {
      Init(strTagName, m_strTabs);
      m_strXMLString.Format(_T("%s%s%s%s"), GetTabbedStartTag(false), nValue ? STR_YES : STR_NO, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   // Inline
   CLString& GetXMLStringYesNo(const int& nValue, bool bAddNewLine = true)
   {
      m_strXMLString.Format(_T("%s%s%s%s"), GetTabbedStartTag(false), nValue ? STR_YES : STR_NO, GetEndTag(), bAddNewLine ? _T("\n") : _T(""));
      return m_strXMLString;
   }

   void SetTabs(CLString strTabs)
   {
      m_strTabs = strTabs;
   }
public:
   CLString  m_strTagName;
   CLString  m_strStartTag;
   CLString  m_strEndTag;
   CLString  m_strTabs;
   CLString  m_strXMLString;
} XMLTAGINFORMATION, FAR* LPXMLTAGINFORMATION;

#endif // !defined(AFX_XMLTAGINFORMATION_H__C76C2581_7678_11D2_8DD8_204C4F4F5020__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: _goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;
	virtual CGoto * CreateGoto(const CLocationEx &) = 0;	// 4.2.2

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: _globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_importo.h ===
//-----------------------------------------------------------------------------
//  
//  File: importo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class for Import Data Options
//
//  Owner: KenWal
//
//  Code Review Status: Not Reviewed
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_wtrmark.h ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_wtrmark.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\cancel.h ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\esputil\_var.h ===
//-----------------------------------------------------------------------------
//  
//  File: var.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\dbhelp.h ===
//******************************************************************************
//
//  DbHelp.h:  LocStudio LocUtil
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\dcsgrid.h ===
//------------------------------------------------------------------------------
//
// File: DcsGrid.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//------------------------------------------------------------------------------
 
#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\enumplatform.h ===
//******************************************************************************
//
// EnumPlatform.h: Common enum Platform definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\espstate.h ===
//-----------------------------------------------------------------------------
//  
//  File: espstate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\extlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: extlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of an extension list.  Used by the parsers to tell the caller
//  what the parser is will to handle.
//  
//-----------------------------------------------------------------------------
 
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\fielddef.h ===
//******************************************************************************
//  
//  FieldDef.h:	Common Column Definitions
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************
 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\fieldval.h ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\enumstringtype.h ===
//******************************************************************************
//
// EnumStringType.h: Common enum String Type definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\filedlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
 
#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\fieldval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\flddeflist.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddeflist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\fileexcldlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileExclDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\flddefhelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddefhelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\gotohelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: gotohelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locobj.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\logfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locpct.h ===
//-----------------------------------------------------------------------------
//  
//  File: LOCPCT.H
//  
//  Declarations for CLocPercentFrame and CLocPercentHelper
//
//  Author:  kenwal
//
//  Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\logfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\operator.h ===
//-----------------------------------------------------------------------------
//  
//  File: operator.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\passtrmerge.h ===
//-----------------------------------------------------------------------------
//
// File: PasStrMerge.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// Declaration of a class which handles the merge of two Pascal strings.
//
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\product.h ===
//-----------------------------------------------------------------------------
//  
//  File: product.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
//  
//-----------------------------------------------------------------------------
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\lstime.h ===
//-----------------------------------------------------------------------------
//  
//  File: lstime.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\report.h ===
//-----------------------------------------------------------------------------
//  
//  File: report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 


enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h|locutil
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\showwarnings.h ===
//-----------------------------------------------------------------------------
//  
//  File: ShowWarnings.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\progress.inl ===
//-----------------------------------------------------------------------------
//  
//  File: progress.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\schema.h ===
//-----------------------------------------------------------------------------
//  
//  File: schema.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------
//
// File: _cancel.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\warndlg.h ===
//******************************************************************************
//  
//  File: WarnDlg.H
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\stringhelp.h ===
//******************************************************************************
//
// StringHelp.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\schema.inl ===
//-----------------------------------------------------------------------------
//  
//  File: schema.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: _progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: _extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Classes to support the new Espresso Extensions interfaces.
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1999 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1999 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1999 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_optvalstore.h ===
//-----------------------------------------------------------------------------
//  
//  File: _optvalstore.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_pumpidle.h ===
//-----------------------------------------------------------------------------
//  
//  File: pumpidle.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitctrl.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitctrl.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_username.h ===
//-----------------------------------------------------------------------------
//  
//  File: username.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_report.h ===
//-----------------------------------------------------------------------------
//  
//  File: _report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mittl.h ===
//******************************************************************************
//
// MitTL.h: MIT Template Library
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitui.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitui.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\locutil\_report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _report.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\profile.h ===
//-----------------------------------------------------------------------------
//  
//  File: profile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  LocStudio  profile marks
//
//-----------------------------------------------------------------------------

#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitdiff.h ===
//------------------------------------------------------------------------------
//  
//  mitdiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\premidlenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\precenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\blobfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\blobfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\counter.h ===
//-----------------------------------------------------------------------------
//  
//  File: counter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\clstring.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
//AMW: Causes compiler error	
//	LTVERIFY(strFormat.LoadString(hResourceModule, nFormatID) != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\cowblob.h ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Copy-On-Write (COW) blob class.  Hold binary information, but only copies
//  the data when it's written to.
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 
#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\diff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: diff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\clstring.h ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\dllvars.h ===
//-----------------------------------------------------------------------------
//  
//  File: dllvars.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\cowblob.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for CLocCOWBlob.  This file should only be used by
//  cowblob.h
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\diff.h ===
//-----------------------------------------------------------------------------
//  
//  File: diff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the following classes needed for string differencing:
//	CDifference, CDelta, CDeltaVisitor, CDiffAlgorithm, CDiffAlgortihmFactory,
//	CDiffEngine  
//-----------------------------------------------------------------------------
 
#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\edithelp.h ===
//******************************************************************************
//  
//  EditHelp.h
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\flushmem.h ===
//-----------------------------------------------------------------------------
//  
//  File: flushmem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\listdelta.h ===
//-----------------------------------------------------------------------------
//  
//  File: listdelta.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CListDelta
//-----------------------------------------------------------------------------
 
#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\gnudiffalg.h ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CGNUDiffAlgorithm, CGNUDiffAlgFact
//-----------------------------------------------------------------------------
 
#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\gnudiffalg.inl ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline implementation of CDumbDiffAlgorithm, CDumbDiffAlgFact
//-----------------------------------------------------------------------------
 
inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\espnls.inl ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the language id object.  This file should ONLY be
//  included by espnls.h
//  
//-----------------------------------------------------------------------------
 

inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\loadlib.h ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class to manage LoadLibray/FreeLibary style DLL usage.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\espnls.h ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Language support functions for Espresso.
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\imagehelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: imagehelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This file is a re-director for IMAGEHLP.DLL.  Rather than linking directly
//  with the DLL (which may not exist on Win 95 systems), this class will
//  dynamically load IMAGEHLP.DLL and then provide certain functions from it.
//  The functions currently available are those that I found immediately
//  useful, so this is not a complete list of IMAGEHLP functionality.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\ltdebug.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltdebug.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
//-----------------------------------------------------------------------------
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\ltimalloc.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltimalloc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\macros.h ===
//-----------------------------------------------------------------------------
//  
//  File: macros.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\locid.h ===
//-----------------------------------------------------------------------------
//  
//  File: locid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\loadlib.inl ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\locvar.h ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CLocVariant, our variant class.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\locid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
//-----------------------------------------------------------------------------
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\locvar.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\optvalset.h ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\optionval.h ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\optvalset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\mitenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\optionval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\redvisit.h ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CRichEditDeltaVisitor
//-----------------------------------------------------------------------------
 
#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\passtr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\refcount.h ===
//-----------------------------------------------------------------------------
//  
//  File: refcount.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\redvisit.inl ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\reghelp.h ===
//******************************************************************************
//
// RegHelp.h : Collection of Registry helping functions
//
// Copyright (C) 1994-1997 by Microsoft Corporation
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\passtr.h ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
//-----------------------------------------------------------------------------
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\smartptr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\smartptr.h ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\smartref.h ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\stacktrace.h ===
//-----------------------------------------------------------------------------
//  
//  File: stacktrace.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;

//
//  'human readable' form of a stack-frame.  Provides module and function name.
struct SYMBOL_INFO
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, SYMBOL_INFO *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\stringblast.h ===
//******************************************************************************
//
// StringBlast.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\smartref.inl ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 



template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\strlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\strlist.inl ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\uiopthelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: uiopthelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class used to represent a single 'option'.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\uioptions.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------




inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\stringtokenizer.h ===
//-----------------------------------------------------------------------------
//  
//  File: StringTokenizer.h
//  Copyright (C) 1997 Microsoft Corporation
//  All rights reserved.
//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}
//-----------------------------------------------------------------------------
#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\uioptions.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\uioptset.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\pdesc.h ===
//-----------------------------------------------------------------------------
//  
//  File: pdesc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\worddiff.h ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CWordDiff
//-----------------------------------------------------------------------------
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\worddiff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of CWordDiff
//-----------------------------------------------------------------------------
 
#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\mit\mitutil\uioptset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\pmanager.h ===
//-----------------------------------------------------------------------------
//  
//  File: pmanager.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\pinfo.h ===
//-----------------------------------------------------------------------------
//  
//  File: pinfo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class that holds information about a parser.
//  
//-----------------------------------------------------------------------------
 
#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parseman\unloader.h ===
//-----------------------------------------------------------------------------
//  
//  File: uloader.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\locbinary.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocBinary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\locchild.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocChild.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\locstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocStrVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\locparser.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocParser.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PARSUTIL.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\locversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocVersion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: ParsUtil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------

#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\parsers\parsutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\idupdate.h ===
//-----------------------------------------------------------------------------
//  
//  File: idupdate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: Binary.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Class to hold 'binary' (non-string) information about a localizable item.
//  
//-----------------------------------------------------------------------------

#ifndef BINARY_H
#define BINARY_H


//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\iresobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: IResObj.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\imgres32.h ===
//-----------------------------------------------------------------------------
//  
//  File: ImgRes32.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\pversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: pversion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\pstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: pstrval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  String Validation interface.
//
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\updatelog.h ===
//-----------------------------------------------------------------------------
//  
//  File: updatelog.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\locfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocFile.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Operations we can perforn on a localizable file.
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\subparse.h ===
//-----------------------------------------------------------------------------
//  
//  File: SubParse.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\mnemonic.h ===
//-----------------------------------------------------------------------------
//  
//  File: Mnemonic.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocMnemonics. 
//	This interface allows to retrieve the mnemonics (aka hotkeys) of a 
//	resource
//
//	Owner: EduardoF
//  
//-----------------------------------------------------------------------------

#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\pbase\parseapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseapi.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Main interface to a file parser DLL.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\inc\prodver\prodver.h ===
#define rmj 4
#define rmm 2
#define rup 422
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\resbase.h ===
//-----------------------------------------------------------------------------
//  
//  File: ResBase.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
// Purpose: Declares the abstract base class CResObj
//
//-----------------------------------------------------------------------------

#ifndef __RESBASE_H
#define __RESBASE_H

class CResObj : public CObject
{
public:
	virtual BOOL Read(C32File *p32File) = 0;
	virtual BOOL Write(C32File *p32File) = 0;
	virtual BOOL CanReadWrite() = 0;
	virtual BOOL ReadWrite(C32File* pSrcFile, C32File* pTgtFile) = 0;
	virtual BOOL ReadRes32(C32File *p32File) = 0;
	virtual BOOL WriteRes32(C32File *p32File) = 0;
	virtual BOOL ReadRgLocItem(CLocItemPtrArray * pRgLocItem, int iSelIndex) = 0;
	virtual BOOL WriteRgLocItem(CLocItemPtrArray * pRgLocItem, 
		CReporter* pReporter) = 0;
	virtual const void* GetBufferPointer(void) = 0;
	virtual DWORD GetBufferSize(void) = 0;
	virtual void SetBufferSize(DWORD dwSize) = 0;
	virtual void MakeRes32Header(LangId nLangId) = 0;

	virtual CLocItem* GetLocItem() = 0;
	virtual BOOL IsKeepLocItems() = 0;
	virtual void SetKeepLocItems(BOOL fKeep) = 0;
	virtual BOOL GetMnemonics(CMnemonicsMap & mapMnemonics, 
		CReporter* pReporter) = 0;
};


#endif //__RESBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxdisp.h>        // MFC OLE automation classes

#include <afxole.h>

#include <parser.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\testdrv\bmoftest.c ===
#include <stdio.h>


int __cdecl main(int argc, char *argv[])
{
	printf("test binary for bmof loc parser\n");
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\f32base.h ===
//-----------------------------------------------------------------------------
//  
//  File: F32Base.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Declares the abstract base class C32File.
//
//  All functions MUST be virtual since this class is passed between
//  Win32 parser and the sub parsers.
//  
//-----------------------------------------------------------------------------

#ifndef __F32BASE_H
#define __F32BASE_H

class CResObj;

class C32File : public CLFile
{
public:
	C32File();
	C32File(CFile* pFile);
	virtual ~C32File();
	virtual FileType GetFileType() = 0;
	virtual void GetFileTypeDescription(CLString &) = 0;
	virtual BOOL OpenSource(const CFileSpec &fsSourceFile,
		CFileException *pExcept, CReporter *pReport = NULL) = 0;
	virtual BOOL OpenTarget(const CPascalString &pasFileName,
		CFileException *pExcept) = 0;
	virtual BOOL GetNextResource(CResObj * &, const CLocUniqueId* pLuid) = 0;
	virtual BOOL GetResource(CLocTypeId &typeId, CLocResId &resId,
		CLocItem * &pLocItem, DWORD &dwDataSize, void * &pv) = 0;
	virtual void PreWriteResource(CResObj * pResObj) = 0;
	virtual void PostWriteResource(CResObj * pResObj) = 0;
	virtual C32File* NewThis(void) = 0;
	virtual BOOL CloseTarget(void) = 0;
	virtual C32File * GetSourceFile(void) = 0;

	virtual LangId GetLangId(void) = 0; 
	virtual void SetLangId(LangId langId) = 0;
	virtual CodePage GetCodePage(CodePageType cpType)= 0; 
	virtual CLocItemHandler *GetHandler(void) = 0; 
	virtual void SetHandler(CLocItemHandler * handler) = 0; 
	virtual DBID GetMasterDBID(void) = 0; 
	virtual void SetMasterDBID(DBID id) = 0; 

	virtual DBID GetFileDBID(void) = 0;		// to help with IssueMessage(...)
	virtual void SetFileDBID(DBID id) = 0;

	virtual BOOL GetFontInfo(Res32FontInfo* pFontInfo) = 0;

	//Helper functions
	virtual void GetNameOrd(BYTE * &pbBuffer, CLocId *plocId, 
		BOOL bBigEnded = FALSE) = 0; 
	virtual void GetString(BYTE * &pbbuffer, CPascalString & pasStr,
		BOOL bBigEnded = FALSE) = 0; 
	virtual DWORD WriteNameOrd(const CLocId &locId,
		BOOL bBigEnded = FALSE) = 0; 
	virtual UINT WriteString(const CPascalString &pstrString, 
		BOOL bBigEnded = FALSE) = 0;

	virtual void SetSubData(ParserId pid, void* pData) = 0;
	virtual void* GetSubData(ParserId pid) = 0;

	virtual CFile * GetFile(void) = 0;

	virtual void ReportProgressIntoResource(int nProgressInBytes) = 0;

	enum WordOrder
	{
		bigEnded,
		littleEnded
	};

	virtual WordOrder GetWordOrder() = 0;

	virtual void NoteResourceLanguage(LangId) = 0;
	virtual BOOL IsLangMismatch(void) = 0;

	// Time release errors in enumerate or generate
	virtual void SetDelayedFailure(BOOL) = 0;
	virtual BOOL GetDelayedFailure(void) = 0;

	void AssertValid(void) const;
};


#endif //__F32BASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\reshead.h ===
//-----------------------------------------------------------------------------
//  
//  File: ResHead.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Definitions of the header structures in a RES32 file
//  
//-----------------------------------------------------------------------------

#ifndef __RESHEAD_H
#define __RESHEAD_H

const DWORD ESP_CHAR_USEARRAYVALUE = 1;   //Cause the Win32 parser
                                          //to use the type value
                                          //from the LocItem array
                                          //instead of the res file
                                          //in the CrackRes32Image
                                          //function.

// Structure of a res file header. The header consists
// of two fixed sized parts with a variable sized middle
// The middle structure appears twice the first is the
// type ID and the second one is the Res ID

#include <pshpack1.h>

	typedef struct
	{
		DWORD dwDataSize;
		DWORD dwHeaderSize;
	} RESHEAD1;

	typedef struct
	{
		DWORD dwDataVersion;
		WORD wFlags;
		WORD wLang;
		DWORD dwResVersion;
		DWORD dwCharacteristics;
	} RESHEAD3;

// Format of our private header data it has an offset to HEADER3
	typedef struct
	{
		DWORD dwOffsetHead3;
		RESHEAD1 reshead1;
	} PVHEAD;
#include <poppack.h>


#endif  //__RESHEAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\w32types.h ===
//-----------------------------------------------------------------------------
//  
//  File: W32Types.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------

#pragma once

const DWORD TYPEID_BUTTON = 0x80;
const DWORD TYPEID_EDIT = 0x81;
const DWORD TYPEID_STATIC = 0x82;
const DWORD TYPEID_LISTBOX = 0x83;
const DWORD TYPEID_SCROLLBAR = 0x84;
const DWORD TYPEID_COMBOBOX = 0x85;

extern const WCHAR *szStringTableEntryType;
extern const WCHAR *szMessageTableEntryType;
extern const WCHAR *szVersionStampEntryType;
extern const WCHAR *szVersionStampType;
extern const WCHAR *szMenuEntryType;
extern const WCHAR *szDummyNodeType;
extern const WCHAR *szAccelTableEntryType;
extern const WCHAR *szDialogControlType;

extern const WCHAR *szTypeIdCustomControl;
extern const WCHAR *szTypeIdSysTabControl32;
extern const WCHAR *szTypeIdSysAnimate32;
extern const WCHAR *szTypeIdSysListView32;
extern const WCHAR *szTypeIdSysTreeView32;
extern const WCHAR *szTypeIdMSCtlsTrackBar32;
extern const WCHAR *szTypeIdMSCtlsProgress32;
extern const WCHAR *szTypeIdMSCtlsUpDown32;
extern const WCHAR *szTypeIdMSCtlsHotKey32;
extern const WCHAR *szTypeIdRichEdit;
extern const WCHAR *szTypeIdHex;
extern const WCHAR *szTypeIdToolBarWindow32;

BOOL GetOldType(const WCHAR *szNewType, UINT &uiOldType);
void MungeDialogControlTypeId(CLocTypeId &);
BOOL IsMungedDialogControlTypeId(const CLocTypeId &);
void UnMungeDialogControlTypeId(CLocTypeId &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\win32pid.h ===
//-----------------------------------------------------------------------------
//  
//  File: Win32Pid.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  This file contains the parser ids for Win32 sub parsers
//  
//-----------------------------------------------------------------------------

#ifndef __WIN32PID_H
#define __WIN32PID_H

const ParserId pidSDM   = 1;
const ParserId pidO96   = 2;
const ParserId pidSample   = 3;
const ParserId pidReserved4   = 4;

const ParserId pidHeat  = 7;
const ParserId pidWin32Inf   = 8;
const ParserId pidWin32Reserved9  = 9;
const ParserId pidWin32VB1  = 10;

const ParserId pidWin32WAV  = 11;

const ParserId pidMSDev = 79;

#endif //__WIN32PID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\cimmap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cimmap.h
//
//
//  This file contains routines that will establish a mapping between
//  Wdm class instances and Cdm class instances. See
//  MapWdmClassToCimClass for more information.
//
//--------------------------------------------------------------------------

HRESULT MapWdmClassToCimClass(
    IWbemServices *pWdmServices,
    IWbemServices *pCimServices,
    BSTR WdmClassName,
    BSTR CimClassName,
    OUT BSTR /* FREE */ **PnPDeviceIds,							  
    BSTR **WdmInstanceNames,
    BSTR **WdmRelPaths,
    BSTR **CimRelPaths,
    int *RelPathCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\win32iid.h ===
//-----------------------------------------------------------------------------
//  
//  File: Win32IID.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef __WIN32IID_H
#define __WIN32IID_H

#include <ltapi.h>

class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;
class C32File;

extern const IID IID_ICreateResObj2;

DECLARE_INTERFACE_(ICreateResObj2, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resource processing
	//Inputs:
	//  - A pointer to the file, prepositioned at the start of the
	//    data area. A resource parser may read up to dwSize bytes,
	//    as necessary to decide whether the resource can be handled.
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ C32File * p32File,
		CLocItem * pLocItem, DWORD dwSize, void * pvHeader) PURE;

	// Inform a sub parser that the main parser is creating a Win32
	// File. 
	//Inputs: Pointer to the Win32 File created.  
	//        This is the same file that will be passed
	//        to later Read. Write, etc... calls on CResObj  
	//Return: void
	STDMETHOD_(void, OnCreateWin32File)(THIS_ C32File*) PURE;

	// Inform a sub parser that the main parser is destroying a Win32
	// File. 
	//Inputs: Pointer to the Win32 File being destroyed
	//Return: void
	STDMETHOD_(void, OnDestroyWin32File)(THIS_ C32File*) PURE;

	// Inform a sub parser that a enumeration is just beginning
	STDMETHOD_(BOOL, OnBeginEnumerate)(THIS_ C32File*) PURE;

	// Inform a sub parser that a enumeration has just ended
	// bOK is TRUE for a successful end
	STDMETHOD_(BOOL, OnEndEnumerate)(THIS_ C32File*, BOOL bOK) PURE;
	
	// Inform a sub parser that a generate is just beginning
	STDMETHOD_(BOOL, OnBeginGenerate)(THIS_ C32File*) PURE;

	// Inform a sub parser that a generate has just ended
	// bOK is TRUE for a successful end
	STDMETHOD_(BOOL, OnEndGenerate)(THIS_ C32File*, BOOL bOK) PURE;

};


#endif  // __WIN32IID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\bmoflocparser\win32rt\win32rt.h ===
//-----------------------------------------------------------------------------
//  
//  File: Win32RT.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Declare helper runtime functions for Win32 parsers and sub parsers
//-----------------------------------------------------------------------------

#ifndef __WIN32RT_H
#define __WIN32RT_H

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Put a name or ord in a buffer.  Caller is responsible for
//  the having enough memory in the buffer.
//  The pointer is updated on return.
//-----------------------------------------------------------------------------
void
W32PutNameOrd(
	const CLocId &locId,		// Name or id to write
	BYTE * &pbCur);	     		// Buffer pointer updated on return


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Create a Res32 header.
//  The caller is responsible for calling delete on the returned
//  memory.
//-----------------------------------------------------------------------------
BYTE* 
W32MakeRes32Header(
		const CLocTypeId& typeId,  //typeid for header
		const CLocResId& resId,	   //resID for header
		LangId nLangId,  		   //Lang for header
		DWORD dwCharacteristics);  //Characteristics member.
                                   //Has special values for 
                                   //Espresso. 



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Pad a buffer to a DWORD boundary
//-----------------------------------------------------------------------------
void 
W32PadDW(
		const BYTE *pbBase,  //Base Address
		BYTE * &pbCur);		 //Current pointer - will be updated


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Flips the bytes in a unicode_null terminated unicode stirng 
//  The string is modified in place.
//-----------------------------------------------------------------------------
void 
W32UnicodeFlip(
	WCHAR* pbBuffer);		//Address of unicode string.


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Flips the bytes in a unicode stirng 
//  The string is modified in place.
//-----------------------------------------------------------------------------
void 
W32UnicodeFlip(
	WCHAR* pbBuffer,		//Address of unicode string.
	UINT nCntChar);			//Count of unicode characters


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Examines a CPascalString for embedded NULLS; issues a message. Debug
//  version can be made to issue messages for ALL strings.
//-----------------------------------------------------------------------------
BOOL
W32FoundNullInPasString(
	MessageSeverity severity,		// Severity of the message
	C32File *p32File,				// file
	HINSTANCE hInstance,			// DLL handle
	UINT uiMaskMsgId,				// msg mask with 3 %s sequences, viz:
									//   "Unexpected NULL found in %s %s, ResId %s."
	UINT uiTypeMsgId,				// msg naming res type, e.g., "Menu"
	UINT uiHelpId,
	const CLocResId &locResId,			// res name
	const CLocUniqueId &locItemUniqueId,	// item id
	const CPascalString &pas);		// item string


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Calls FoundNullInPasString() for every string in a CLocItemPtrArray.
//-----------------------------------------------------------------------------
BOOL
W32FoundNullInLocItemPtrArrayPasString(
	MessageSeverity severity,		// Severity of the message
	C32File *p32File,				// file
	HINSTANCE hInstance,		    // DLL handle
	UINT uiMaskMsgId,				// msg mask with 3 %s sequences, viz:
									//   "Unexpected NULL found in %s %s, ResId %s."
	UINT uiTypeMsgId,				// msg naming res type, e.g., "Menu"
	UINT uiHelpId,
	CLocItem *pLocItem,				// res name
	CLocItemPtrArray &rgLocItem);	// item strings


#endif  //__WIN32RT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\cimmap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       cimmap.cpp
//
//
//  This file contains routines that will establish a mapping between
//  Wdm class instances and Cdm class instances. See
//  MapWdmClassToCimClass for more information.
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <wbemidl.h>

#include "wbemmisc.h"
#include "debug.h"
#include "cimmap.h"

HRESULT WdmInstanceNameToPnPId(
    IWbemServices *pWdmServices,
    BSTR WdmInstanceName,
    VARIANT /* FREE */ *PnPId
    )
/*+++

Routine Description:

	This routine will convert a Wdm instance name into its
	corresponding pnp id
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace 

	WdmInstanceName

	*PnPId returns with the pnp id
		
Return Value:

    HRESULT

---*/
{
	WCHAR Query[2 * MAX_PATH];
	WCHAR s[MAX_PATH];
	BSTR sQuery;
	HRESULT hr;
	IEnumWbemClassObject *pWdmEnumInstances;
	IWbemClassObject *pWdmInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(PnPId != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		//
		// First get PnP id from Instance name from the MSWmi_PnPDeviceId
		// class (select * from MSWMI_PnPDeviceId where InstanceName =
		// "<WdmInstanceName>"
		//
		wsprintfW(Query,
				L"select * from MSWmi_PnPDeviceId where InstanceName = \"%ws\"",
				AddSlashesToStringW(s, WdmInstanceName));
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = pWdmServices->ExecQuery(sWQL,
									sQuery,
									WBEM_FLAG_FORWARD_ONLY |
									WBEM_FLAG_ENSURE_LOCATABLE,
									NULL,
									&pWdmEnumInstances);

			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pWdmEnumInstances->Next(WBEM_INFINITE,
											  1,
											  &pWdmInstance,
											  &Count);
				if ((hr == WBEM_S_NO_ERROR) &&
					(Count == 1))
				{
					hr = WmiGetProperty(pWdmInstance,
										L"PnPDeviceId",
										CIM_STRING,
										PnPId);

					pWdmInstance->Release();
				}

				pWdmEnumInstances->Release();
			} else {
				WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								sQuery, hr));
			}
			
			SysFreeString(sQuery);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}

		SysFreeString(sWQL);
	} else {
		hr  = WBEM_E_OUT_OF_MEMORY;
	}

	return(hr);
}

HRESULT FindCimClassByWdmInstanceName(
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR CimClassName,
    IN BSTR WdmInstanceName,
    OUT BSTR *PnPId,
    OUT BSTR /* FREE */ *CimRelPath
    )
/*+++

Routine Description:

	This routine will find the Cim class instance that corresponds to a
	particular Wdm class instance
        
Arguments:

	pWdmServices is the pointer to the root\wmi namespace
	
	pCdmServices is the pointer to the root\cimv2 namespace 

	CimClassName is the name of the cim class that the wdm instance
		would map to
		
	WdmInstanceName

    *PnPId returns with the PnP id for the device stack
    
	*CimRelPath returns with the relpath for the Cim instance
		
Return Value:

    HRESULT

---*/
{
	HRESULT hr;
	VARIANT v;
	IEnumWbemClassObject *pCimEnumInstances;
	IWbemClassObject *pCimInstance;
	ULONG Count;
	BSTR sWQL;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(WdmInstanceName != NULL);
	WmipAssert(CimRelPath != NULL);
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{

		// ****************************************************************
		// Note: Net cards need to do something similar. We get the
		// netcard address in class MSNDIS_???? and then get the CIM class
		// by matching the netcard addresses.
		// ****************************************************************
		
		//
		// First thing is to convert from an instance name to a pnpid
		//
		hr = WdmInstanceNameToPnPId(pWdmServices,
									WdmInstanceName,
									&v);

		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Next select * from CimClassName where PnPDeviceId = "<PnPDevice
			// Id from above>".
			//
			WCHAR Query[2 * MAX_PATH];
			WCHAR s[MAX_PATH];
			BSTR sQuery;

			wsprintfW(Query,
					  L"select * from %ws where PnPDeviceId = \"%ws\"",
					  CimClassName,
					  AddSlashesToStringW(s, v.bstrVal));
			*PnPId = v.bstrVal;

			sQuery = SysAllocString(Query);

			if (sQuery != NULL)
			{
				hr = pCimServices->ExecQuery(sWQL,
										sQuery,
										WBEM_FLAG_FORWARD_ONLY |
										WBEM_FLAG_ENSURE_LOCATABLE,
										NULL,
										&pCimEnumInstances);

				SysFreeString(sQuery);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = pCimEnumInstances->Next(WBEM_INFINITE,
												  1,
												  &pCimInstance,
												  &Count);
					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1))
					{

						//
						// Finally grab the relpath from cim class and we're done
						//

						hr = WmiGetProperty(pCimInstance,
											L"__RELPATH",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							*CimRelPath = SysAllocString(v.bstrVal);
							if (*CimRelPath == NULL)
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
							
							VariantClear(&v);
						}

						pCimInstance->Release();
					}

					pCimEnumInstances->Release();
				} else {
					WmipDebugPrint(("CDMPROV: Query %ws failed %x\n",
								Query, hr));
				}

			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}		
		}
		
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}


	return(hr);
}

HRESULT GetEnumCount(
    IN IEnumWbemClassObject *pEnumInstances,
	OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will return the count of instances in the enumeration
        
Arguments:

	pEnumInstance is the instance enumerator

	*RelPathCount returns the number of instances in the enumeration
		
Return Value:

    HRESULT

---*/
{
	ULONG Count;
	HRESULT hr;
	IWbemClassObject *pInstance;

	WmipAssert(pEnumInstances != NULL);
	WmipAssert(RelPathCount != NULL);
	
	*RelPathCount = 0;
	do
	{
		hr = pEnumInstances->Next(WBEM_INFINITE,
									 1,
									 &pInstance,
									 &Count);

		if ((hr == WBEM_S_NO_ERROR) &&
			(Count == 1))
		{
			(*RelPathCount)++;
			pInstance->Release();
		} else {
			if (hr == WBEM_S_FALSE)
			{
				hr = WBEM_S_NO_ERROR;
			}
			break;
		}
	} while (TRUE);
	
	return(hr);
}

HRESULT MapWdmClassToCimClass(
    IN IWbemServices *pWdmServices,
    IN IWbemServices *pCimServices,
    IN BSTR WdmClassName,
    IN BSTR CimClassName,
    OUT BSTR /* FREE */ **PnPDeviceIds,							  
    OUT BSTR /* FREE */ **WdmInstanceNames,							  
    OUT BSTR /* FREE */ **WdmRelPaths,
    OUT BSTR /* FREE */ **CimRelPaths,
    OUT int *RelPathCount
    )
/*+++

Routine Description:

	This routine will perform a mapping between the instances of WDM
	classes and Cim Classes
        
Arguments:

	pWdmServices

	pCdmServices

	WdmClassName

	CimClassName

	*PnPDeviceIds return with the an array of PnP device ids

	*WdmInstanceNames returns with an array of Wdm instnace names

	*WdmRelPaths returns with an array of relpaths to Wdm instances

	*CimRelpaths returns with an array of relapaths to Cim instance

	*RelPathCount returns with the count of instances that are mapped
	
Return Value:

    HRESULT

---*/
{
	IWbemClassObject *pWdmInstance;
	IEnumWbemClassObject *pWdmEnumInstances;
	HRESULT hr;
	int i, NumberWdmInstances;
	VARIANT v;
	ULONG Count;
	ULONG AllocSize;

	WmipAssert(pWdmServices != NULL);
	WmipAssert(pCimServices != NULL);
	WmipAssert(WdmClassName != NULL);
	WmipAssert(CimClassName != NULL);
	WmipAssert(PnPDeviceIds != NULL);
	WmipAssert(WdmInstanceNames != NULL);
	WmipAssert(CimRelPaths != NULL);
	WmipAssert(RelPathCount != NULL);

	WmipDebugPrint(("CDMPROV: Mapping Wdm %ws to CIM %ws\n",
					WdmClassName,
					CimClassName));

	*PnPDeviceIds = NULL;
	*WdmInstanceNames = NULL;
	*WdmRelPaths = NULL;
	*CimRelPaths = NULL;
	
	//
	// Get all instances of the Wdm Class
	//
	hr = pWdmServices->CreateInstanceEnum(WdmClassName,
										  WBEM_FLAG_USE_AMENDED_QUALIFIERS |
										  WBEM_FLAG_SHALLOW,
										  NULL,
										  &pWdmEnumInstances);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = GetEnumCount(pWdmEnumInstances,
						  RelPathCount);

		NumberWdmInstances = *RelPathCount;
		if (hr == WBEM_S_NO_ERROR)
		{
			AllocSize = NumberWdmInstances * sizeof(BSTR *);
			*WdmRelPaths = (BSTR *)WmipAlloc(AllocSize);
			*CimRelPaths = (BSTR *)WmipAlloc(AllocSize);
			*WdmInstanceNames = (BSTR *)WmipAlloc(AllocSize);
			*PnPDeviceIds = (BSTR *)WmipAlloc(AllocSize);
			if ((*WdmRelPaths != NULL) &&
                (*CimRelPaths != NULL) &&
				(*WdmInstanceNames != NULL) &&
                (*PnPDeviceIds != NULL))
			{
				memset(*WdmRelPaths, 0, AllocSize);
				memset(*CimRelPaths, 0, AllocSize);
				memset(*WdmInstanceNames, 0, AllocSize);
				memset(*PnPDeviceIds, 0, AllocSize);

				pWdmEnumInstances->Reset();
				i = 0;
				do
				{
					hr = pWdmEnumInstances->Next(WBEM_INFINITE,
												 1,
												 &pWdmInstance,
												 &Count);

					if ((hr == WBEM_S_NO_ERROR) &&
						(Count == 1) &&
						(i < NumberWdmInstances))
					{
						//
						// Lets get the instance name and then lookup the pnp
						// id for it
						//
						hr = WmiGetProperty(pWdmInstance,
											L"InstanceName",
											CIM_STRING,
											&v);

						if (hr == WBEM_S_NO_ERROR)
						{
							//
							// Remember wdm instnace name
							//
							WmipDebugPrint(("CDMPROV: Wdm InstanceName is %ws\n",
											v.bstrVal));
							(*WdmInstanceNames)[i] = v.bstrVal;
							hr = FindCimClassByWdmInstanceName(pWdmServices,
								                               pCimServices,
								                               CimClassName,
								                               v.bstrVal,
								                               &((*PnPDeviceIds)[i]),
															   &((*CimRelPaths)[i]));
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// Remember Wdm class relative path
								//
								WmipDebugPrint(("CDMPROV: Found CimRelPath %ws for Wdm class %ws\n",
												((*CimRelPaths)[i]), WdmClassName));
								hr = WmiGetProperty(pWdmInstance,
									                L"__RELPATH",
													CIM_STRING,
													&v);
								if (hr == WBEM_S_NO_ERROR)
								{
									(*WdmRelPaths)[i] = SysAllocString(v.bstrVal);
									if ((*WdmRelPaths)[i] == NULL)
									{
										hr = WBEM_E_OUT_OF_MEMORY;
									}
									VariantClear(&v);
									i++;
								}
							} else {
								//
								// We did not find a CIM class
								// to match our Wdm instance
								// names, so we decrement our
								// relpath count and continue
								// searching
								(*RelPathCount)--;
								if (*RelPathCount == 0)
								{
									hr = WBEM_E_NOT_FOUND;
								} else {
									hr = WBEM_S_NO_ERROR;
								}
							}
						}
						pWdmInstance->Release();
					} else {
						if (hr == WBEM_S_FALSE)
						{
							hr = WBEM_S_NO_ERROR;
						}
						break;
					}
				} while (hr == WBEM_S_NO_ERROR);				
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;							
			}
		}
		pWdmEnumInstances->Release();
	}

	//
	// If mapping was unsuccessful then be sure to clean up any
	// allocated instance names and relpaths
	//
	if (hr != WBEM_S_NO_ERROR)
	{
		if (*PnPDeviceIds != NULL)
		{
			FreeTheBSTRArray(*WdmRelPaths,
							NumberWdmInstances);
			*WdmRelPaths = NULL;
		}

		if (*WdmRelPaths != NULL)
		{
			FreeTheBSTRArray(*WdmRelPaths,
							NumberWdmInstances);
			*WdmRelPaths = NULL;
		}

		if (*CimRelPaths != NULL)
		{
			FreeTheBSTRArray(*CimRelPaths,
							NumberWdmInstances);
			*CimRelPaths = NULL;
		}
		
		if (*WdmInstanceNames != NULL)
		{
			FreeTheBSTRArray(*WdmInstanceNames,
							NumberWdmInstances);
			*WdmInstanceNames = NULL;
		}
	}
	
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: CDM Provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
	LONG cRef;

	cRef = m_cRef+1;
	
	InterlockedIncrement((LPLONG)&m_cRef);
	
    return (cRef);
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CClassPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CClassPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WINMGMT class provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "sample.h"

#include "wbemmisc.h"

HMODULE ghModule;
HANDLE CdmMutex;

// {AC42F9A6-9945-426f-9199-86F7257365D4}
DEFINE_GUID(CLSID_classprovider,
0xac42f9a6, 0x9945, 0x426f, 0x91, 0x99, 0x86, 0xf7, 0x25, 0x73, 0x65, 0xd4);

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


extern "C" BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
	{
        ghModule = hInstance;
		CdmMutex = CreateMutex(NULL,
							   FALSE,
							   NULL);
		if (CdmMutex == NULL)
		{
			return(FALSE);
		}
	}
    return(TRUE);
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_classprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
#if 0    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
#else
	//
	// We always remain loaded since we carry around result objects for
	// the results of previously run tests and do not want to unload
	// when there are result objects still held. In the future we will
	// want to check if all results are cleared and if so then unload,
	// but for now we'll stay loaded forever.
	//
	return(S_FALSE);
#endif
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "CDMPROV Test Class Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\debug.h ===
//***************************************************************************
//
//  debug.CPP
//
//  Module: CDM Provider
//
//  Purpose: Debugging routines
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************


#ifdef DBG
void __cdecl DebugOut(char *Format, ...);
#define WmipDebugPrint(_x_) { DebugOut _x_; }

#define WmipAssert(x) if (! (x) ) { \
    WmipDebugPrint(("CDMPROV Assertion: "#x" at %s %d\n", __FILE__, __LINE__)); \
    DebugBreak(); }
#else
#define WmipDebugPrint(x)
#define WmipAssert(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\debug.cpp ===
//***************************************************************************
//
//  debug.CPP
//
//  Module: CDM Provider
//
//  Purpose: Debugging routines
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

// @@BEGIN_DDKSPLIT
#ifdef HEAP_DEBUG
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
// @@END_DDKSPLIT
#include <windows.h>
#include <stdio.h>

#include "debug.h"


void __cdecl DebugOut(char *Format, ...)
{
    char Buffer[1024];
    va_list pArg;
    ULONG i;

    va_start(pArg, Format);
    i = _vsnprintf(Buffer, sizeof(Buffer), Format, pArg);
    OutputDebugString(Buffer);
}

// @@BEGIN_DDKSPLIT
#ifdef HEAP_DEBUG
PVOID MyHeap;

PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	PVOID p;
	
	if (MyHeap == NULL)
	{
        MyHeap = RtlCreateHeap(HEAP_GROWABLE |
							   HEAP_GENERATE_EXCEPTIONS |
							   HEAP_TAIL_CHECKING_ENABLED |
							   HEAP_FREE_CHECKING_ENABLED,
                                        NULL,
                                        0,
                                        0,
                                        NULL,
                                        NULL);
		if (MyHeap == NULL)
		{
			WmipDebugPrint(("CDMPROV: Could not create debug heap\n"));
			return(NULL);
		}
	}
	
	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	
	p = RtlAllocateHeap(MyHeap,
						   0,
						   Size);

	return(p);
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	WmipAssert(MyHeap != NULL);

	WmipAssert(RtlValidateHeap(MyHeap,
							   0,
							   NULL));
	RtlFreeHeap(MyHeap,
				0,
				Ptr);
}

void * __cdecl ::operator new(size_t Size)
{
	return(WmipAlloc(Size));
}

void __cdecl ::operator delete(void *Ptr)
{
	WmipFree(Ptr);
}

#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\classprov.cpp ===
//***************************************************************************
//
//  CLASSPRO.CPP
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "sample.h"
#include <process.h>

#include <unknwn.h>
#include "wbemmisc.h"
#include "debug.h"


// @@BEGIN_DDKSPLIT
// TODO: pass down all pCtx so that all calls into wbem use it
// @@END_DDKSPLIT

//
// This is the global list of all of the CDM classes and their
// corresponsing WDM classes that are managed by the provider.
//
// It is maintained as a global since WinMgmt is aggressive in
// releasing the CClassProv, but we really want to maintain the result
// objects and do not want to be unloaded unless all result objects are
// cleared.
//
CTestServices *WdmTestHead;

void CleanupAllTests(
    )
{
    CTestServices *WdmTest;
    CTestServices *WdmTestNext;

    //
    // Loop over all classes that were supported by the provider and
    // clean them up
    //
    WdmTest = WdmTestHead;  
    while (WdmTest != NULL)
    {
        WdmTestNext = WdmTest->GetNext();
        delete WdmTest;
    }
}

//***************************************************************************
//
// CClassPro::CClassPro
// CClassPro::~CClassPro
//
//***************************************************************************

CClassPro::CClassPro(
    BSTR ObjectPath,
    BSTR User,
    BSTR Password,
    IWbemContext * pCtx
    )
{
    m_pCdmServices = NULL;
    m_cRef=0;
	InterlockedIncrement(&g_cObj);
    return;
}

CClassPro::~CClassPro(void)
{   
    if(m_pCdmServices)
    {
        m_pCdmServices->Release();
    }
    InterlockedDecrement(&g_cObj);
    
    return;
}

//***************************************************************************
//
// CClassPro::QueryInterface
// CClassPro::AddRef
// CClassPro::Release
//
// Purpose: IUnknown members for CClassPro object.
//***************************************************************************


STDMETHODIMP CClassPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
    {
       *ppv=(IWbemServices*)this;
    }

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
    {
       *ppv=(IWbemProviderInit*)this;
    }
    

    if (NULL!=*ppv)
    {
        AddRef();
        hr = NOERROR;
    }
    else {
        hr = E_NOINTERFACE;
    }
    
    return(hr);
}


STDMETHODIMP_(ULONG) CClassPro::AddRef(void)
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CClassPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
    {
        delete this;
    }
    
    return(nNewCount);
}

/***********************************************************************
*                                                                      *
*   CClassPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CClassPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if (pNamespace)
    {
        pNamespace->AddRef();
    }
        
    m_pCdmServices = pNamespace;

    //
    // Let CIMOM know you are initialized
    //
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    
    return(WBEM_S_NO_ERROR);
}

//***************************************************************************
//
// CClassPro::CreateClassEnumAsync
//
// Purpose: Asynchronously enumerates the classes this provider supports.  
// Note that this sample only supports one.  
//
//***************************************************************************

SCODE CClassPro::CreateClassEnumAsync(
    const BSTR Superclass, long lFlags, 
    IWbemContext  *pCtx,
    IWbemObjectSink *pHandler
    )
{
    return(WBEM_E_NOT_SUPPORTED);
}

//***************************************************************************
//
// CClassPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CClassPro::CreateInstanceEnumAsync(
    const BSTR ClassName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemObjectSink FAR* pHandler
)
{
    HRESULT hr, hr2;
    ULONG i, Count;
    IWbemClassObject *pCdmTest;
    CTestServices *WdmTest;	
	
    WmipDebugPrint(("CDMPROV: Enumerate instances of class %ws\n",
                    ClassName));
    
    //
    // Do a check of arguments and make sure we have pointer to Namespace
    //
    if (pHandler == NULL || m_pCdmServices == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Plan for success
    //
    hr = WBEM_S_NO_ERROR;

    //
    // Obtain a test services object that represents this class
    //
    hr = LookupTestServices(ClassName,
                            &WdmTest);


    if (hr == WBEM_S_NO_ERROR)
    {
        if (_wcsicmp(ClassName, WdmTest->GetCdmTestClassName()) == 0)
        {
            hr = CreateTestInst(WdmTest, &pCdmTest, pCtx);
            if (hr == WBEM_S_NO_ERROR)
            {
                //
                // Send the object to the caller
                //
                hr = pHandler->Indicate(1,&pCdmTest);
                pCdmTest->Release();
            }

        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultClassName()) == 0) {
            //
            // Loop over all instances of the test and report all results
            // that we have previously recorded
            //
            IWbemClassObject **pCdmResultsList;
			ULONG ResultCount, j;

            Count = WdmTest->GetInstanceCount();
            for (i = 0; (i < Count) && SUCCEEDED(hr); i++)
            {
                hr2 = WdmTest->GetResultsList(i,
											&ResultCount,
											&pCdmResultsList);

                if ((hr2 == WBEM_S_NO_ERROR) && (pCdmResultsList != NULL))
                {
					//
					// Send the object to the caller
					//  
					hr = pHandler->Indicate(ResultCount, pCdmResultsList);

					for (j = 0; j < ResultCount; j++)
					{
						//
						// Release ref taken when results list was
						// built
						//
						pCdmResultsList[j]->Release();
					}
					WmipFree(pCdmResultsList);
                }
            }       
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmSettingClassName()) == 0) {
            //
            // Return a setting instances for all tests
            //
            ULONG j, ListCount;
            IWbemClassObject *pCdmSetting;
            
            Count = WdmTest->GetInstanceCount();
            for (i = 0; (i < Count) && SUCCEEDED(hr); i++)
            {
                ListCount = WdmTest->GetCdmSettingCount(i);
                for (j = 0; (j < ListCount) && SUCCEEDED(hr); j++)
                {
                    pCdmSetting = WdmTest->GetCdmSettingObject(i, j);
                    if (pCdmSetting != NULL)
                    {
                        hr = pHandler->Indicate(1, &pCdmSetting);
                        // NO release required since object is cached
                    }
                }
            }
            
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultForMSEClassName()) == 0) {
            IWbemClassObject **pCdmResultsList;
			ULONG ResultCount, j;
            IWbemClassObject *pCdmResultForMSE;
            
            Count = WdmTest->GetInstanceCount();
            for (i = 0; (i < Count) && SUCCEEDED(hr); i++)
            {
                hr2 = WdmTest->GetResultsList(i,
											&ResultCount,
											&pCdmResultsList);

                if ((hr2 == WBEM_S_NO_ERROR) && (pCdmResultsList != NULL))
                {
					for (j = 0; (j < ResultCount); j++)
					{
						if (SUCCEEDED(hr))
						{
							//
							// for each instance of this test we create a ResultForMSE
							// association instance and then set the properties within
							// it to the appropriate values and relpaths
							hr2 = CreateResultForMSEInst(WdmTest,
														&pCdmResultForMSE,
														i,
														pCdmResultsList[j],
														pCtx);


							if (hr2 == WBEM_S_NO_ERROR)
							{
								//
								// Send the object to the caller
								//  
								hr = pHandler->Indicate(1, &pCdmResultForMSE);
								pCdmResultForMSE->Release();
							}
						}
						
						pCdmResultsList[j]->Release();
					}
					WmipFree(pCdmResultsList);
				}
            }
			
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultForTestClassName()) == 0) {
            IWbemClassObject **pCdmResultsList;
			ULONG ResultCount,j;
            IWbemClassObject *pCdmResultForTest;

            Count = WdmTest->GetInstanceCount();
            for (i = 0; (i < Count) && SUCCEEDED(hr); i++)
            {           
                hr2 = WdmTest->GetResultsList(i,
											&ResultCount,
											&pCdmResultsList);

                if ((hr2 == WBEM_S_NO_ERROR) && (pCdmResultsList != NULL))
                {
					for (j = 0; (j < ResultCount); j++)
					{
						if (SUCCEEDED(hr))
						{
							//
							// DiagnosticResult is a reference to the CIM_Diagnostic result class
							//
							hr2 = CreateResultForTestInst(WdmTest,
														 &pCdmResultForTest,
														 pCdmResultsList[j],
														 pCtx);

							if (hr2 == WBEM_S_NO_ERROR)
							{
								//
								// Send the object to the caller
								//  
								hr = pHandler->Indicate(1,&pCdmResultForTest);

								pCdmResultForTest->Release();
							}
						}
						pCdmResultsList[j]->Release();
					}
					WmipFree(pCdmResultsList);
				}
            }

        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestForMSEClassName()) == 0) {
            //
            // Here we create the associations between tests and MSE
            //
            IWbemClassObject *pCdmTestForMSE;

            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                //
                // for each instance of this test we create a TestForMSE
                // association instance and then set the properties within
                // it to the appropriate values and relpaths
                hr2 = CreateTestForMSEInst(WdmTest,
                                          &pCdmTestForMSE,
                                          i,
                                          pCtx);
                
                if (hr2 == WBEM_S_NO_ERROR)
                {
                    //
                    // Send the object to the caller
                    //  
                    hr = pHandler->Indicate(1, &pCdmTestForMSE);
                    pCdmTestForMSE->Release();
                }
            }       
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmSettingForTestClassName()) == 0) {
            //
            // Return all settings instances for this test
            //
            ULONG j, ListCount;
            IWbemClassObject *pCdmSettingForTest;
            
            Count = WdmTest->GetInstanceCount();
            for (i = 0; (i < Count) && SUCCEEDED(hr); i++)
            {
                ListCount = WdmTest->GetCdmSettingCount(i);
                for (j = 0; (j < ListCount) && SUCCEEDED(hr); j++)
                {
                    hr2 = CreateSettingForTestInst(WdmTest,
                                                  &pCdmSettingForTest,
                                                  i,
                                                  j,
                                                  pCtx);
                    
                    if (hr2 == WBEM_S_NO_ERROR)
                    {
                        pHandler->Indicate(1, &pCdmSettingForTest);
                        pCdmSettingForTest->Release();
                    }
                }
            }

#if 0   // Not supported			
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestForSoftwareClassName()) == 0) {
            //
            // We do not support this
            //
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestInPackageClassName()) == 0) {
            //
            // We do not support packages
            //
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultInPackageClassName()) == 0) {
            //
            // We do not support packages
            //
#endif			
        } else {
            //
            // Is this the right thing to do if we do not know what the
            // class name is
            //
            hr = WBEM_S_NO_ERROR;
        }
    }

	//
	// TODO: Create extended error object with more info about the
	// error that occured. The object is created by
	// CreateInst("__ExtendedStatus")
	//

    pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    return(hr);
}


//***************************************************************************
//
// CClassPro::GetObjectByPathAsync
//
// Purpose: Returns either an instance or a class.
//
//***************************************************************************



SCODE CClassPro::GetObjectAsync(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext  *pCtx,
    IWbemObjectSink FAR* pHandler
    )
{

    HRESULT hr;
    IWbemClassObject FAR* pObj;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pCdmServices == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	
	hr = GetByPath(ObjectPath,&pObj, pCtx);
    if (hr == WBEM_S_NO_ERROR)
    {
        WmipDebugPrint(("CDMProv: Found instance %p for relpath %ws\n",
                        pObj, ObjectPath));
        hr = pHandler->Indicate(1,&pObj);
        pObj->Release();
    } else {
        WmipDebugPrint(("CDMProv: Did not find instance for relpath %ws\n",
                        ObjectPath));
        hr = WBEM_E_NOT_FOUND;
    }

    // Set Status

    pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    return(hr);
}
 
//***************************************************************************
//
// CClassPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//          All objects returned are assumed to be AddRefed
//
//***************************************************************************

HRESULT CClassPro::GetByPath(
    BSTR ObjectPath,
    IWbemClassObject **ppObj,
    IWbemContext  *pCtx
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;   
    WCHAR ClassName[MAX_PATH+1];
    WCHAR *p;
    int iNumQuotes = 0;
    int i, Count;
    CTestServices *WdmTest;
    BSTR s;

    //
    // This is where we are queried for a class based upon its relpath.
    // We need to parse the relpath to get the class name and then look
    // at the relpath to determine which instance of the class we are
    // interested in and then build up the instance and return it
    //
    //
    // Relpaths created at init
    //
    // Sample_Filter_DiagTest.Name="Sample_Filter_DiagTest"
    // Sample_Filter_DiagTestForMSE.Antecedent="Win32_USBController.DeviceID=\"PCI\\\\VEN_8086&DEV_7112&SUBSYS_00000000&REV_01\\\\2&EBB567F&0&3A\"",Dependent="Sample_Filter_DiagTest.Name=\"Sample_Filter_DiagTest\""
    //
    //
    // Relpaths created at method execute
    //
    // Sample_Filter_DiagResult.DiagnosticCreationClassName="MSSample_DiagnosticTest.InstanceName=\"PCI\\\\VEN_8086&DEV_7112&SUBSYS_00000000&REV_01\\\\2&ebb567f&0&3A_0\"",DiagnosticName="Sample_Filter_DiagTest",ExecutionID="0"
    // Sample_Filter_DiagResultForMSE.Result="Sample_Filter_DiagResult.DiagnosticCreationClassName=\"MSSample_DiagnosticTest.InstanceName=\\\"PCI\\\\\\\\VEN_8086&DEV_7112&SUBSYS_00000000&REV_01\\\\\\\\2&ebb567f&0&3A_0\\\"\",DiagnosticName=\"Sample_Filter_DiagTest\",ExecutionID=\"0\"",SystemElement="Win32_USBController.DeviceID=\"PCI\\\\VEN_8086&DEV_7112&SUBSYS_00000000&REV_01\\\\2&EBB567F&0&3A\""
    // Sample_Filter_DiagResultForTest.DiagnosticResult="Sample_Filter_DiagResult.DiagnosticCreationClassName=\"MSSample_DiagnosticTest.InstanceName=\\\"PCI\\\\\\\\VEN_8086&DEV_7112&SUBSYS_00000000&REV_01\\\\\\\\2&ebb567f&0&3A_0\\\"\",DiagnosticName=\"Sample_Filter_DiagTest\",ExecutionID=\"0\"",DiagnosticTest="Sample_Filter_DiagTest.Name=\"Sample_Filter_DiagTest\""

    //
    // Obtain the class name by copying up to the .
    //
    for (p = ObjectPath, i = 0;
         (*p != 0) && (*p != L'.') && (i < MAX_PATH);
         p++, i++)
    {
        ClassName[i] = *p;
    }

    if (*p != L'.') 
    {
        //
        // If we did end our loop with a . then we failed to parse
        // properly
        //
        WmipDebugPrint(("CDMPROV: Unable to parse relpath %ws at %ws, i = %d\n",
                        ObjectPath, p, i));
    }
    
    ClassName[i] = 0;

    WmipDebugPrint(("CDMPROV: Class %ws looking for relpath %ws\n",
                    ClassName, ObjectPath));
    
    //
    // Obtain a test services object that represents this class
    //
    hr = LookupTestServices(ClassName,
                            &WdmTest);

    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Assume that we will not find the object instance
        //
        hr = WBEM_E_NOT_FOUND;
        
        if (_wcsicmp(ClassName, WdmTest->GetCdmTestClassName()) == 0)
        {
            //
            // This is a CdmTest class object instance
            //
#ifdef VERBOSE_DEBUG            
            WmipDebugPrint(("CDMPROV: Compareing \n%ws\n\nwith\n%ws\n\n",
                            ObjectPath, WdmTest->GetCdmTestRelPath()));
#endif          
            if (_wcsicmp(ObjectPath, WdmTest->GetCdmTestRelPath()) == 0)
            {
                hr = CreateTestInst(WdmTest, ppObj, pCtx);
            }
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultClassName()) == 0) {
            //
            // This is a CdmResult class object instance
            //
            IWbemClassObject *pCdmResult;

            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                hr = WdmTest->GetCdmResultByResultRelPath(i,
					                              ObjectPath,
					                              &pCdmResult);
                if (hr == WBEM_S_NO_ERROR)
                {
					*ppObj = pCdmResult;
					break;
                }
            }       
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmSettingClassName()) == 0) {
            //
            // This is a CDM settings class instnace
            //
            ULONG j, ListCount;
            IWbemClassObject *pCdmSetting;
            
            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                ListCount = WdmTest->GetCdmSettingCount(i);
                for (j = 0; j < ListCount; j++)
                {
                    s = WdmTest->GetCdmSettingRelPath(i, j);
#ifdef VERBOSE_DEBUG                    
                    WmipDebugPrint(("CDMPROV: Compareing \n%ws\n\nwith\n%ws\n\n",
                                    ObjectPath, s));
#endif                  
                    if (_wcsicmp(ObjectPath,
                                 s) == 0)
                    {
                        pCdmSetting = WdmTest->GetCdmSettingObject(i, j);
                        pCdmSetting->AddRef();
                        *ppObj = pCdmSetting;
                        hr = WBEM_S_NO_ERROR;
                        break;
                    }
                }
            }
            
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultForMSEClassName()) == 0) {
            //
            // This is a CDM result for MSE class instance
            //
			IWbemClassObject *pCdmResult;
			
            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                hr = WdmTest->GetCdmResultByResultForMSERelPath(i,
					                              ObjectPath,
					                              &pCdmResult);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = CreateResultForMSEInst(WdmTest,
												ppObj,
												i,
												pCdmResult,
												pCtx);
					pCdmResult->Release();
					break;
                }
            }
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultForTestClassName()) == 0) {
			IWbemClassObject *pCdmResult;
			
            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                hr = WdmTest->GetCdmResultByResultForTestRelPath(i,
					                              ObjectPath,
					                              &pCdmResult);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = CreateResultForTestInst(WdmTest,
						                         ppObj,
						                         pCdmResult,
                                                 pCtx);
					pCdmResult->Release();
					break;
                }
            }

        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestForMSEClassName()) == 0) {
            //
            // TestForMSE class object
            //
            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
#ifdef VERBOSE_DEBUG                    
                WmipDebugPrint(("CDMPROV: Compareing \n%ws\n\nwith\n%ws\n\n",
                                ObjectPath, WdmTest->GetCdmTestForMSERelPath(i)));
#endif              
                if (_wcsicmp(ObjectPath,
                             WdmTest->GetCdmTestForMSERelPath(i)) == 0)
                {
                    hr = CreateTestForMSEInst(WdmTest,
                                              ppObj,
                                              i,
                                              pCtx);
                    break;
                }
            }       
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmSettingForTestClassName()) == 0) {
            //
            // This is a CDM settings for test class instnace
            //
            ULONG j, ListCount;
            
            Count = WdmTest->GetInstanceCount();
            for (i = 0; i < Count; i++)
            {
                ListCount = WdmTest->GetCdmSettingCount(i);
                for (j = 0; j < ListCount; j++)
                {
                    s = WdmTest->GetCdmSettingForTestRelPath(i, j);
#ifdef VERBOSE_DEBUG                    
                    WmipDebugPrint(("CDMPROV: Compareing \n%ws\n\nwith\n%ws\n\n",
                                    ObjectPath, s));
#endif                  
                    if (_wcsicmp(ObjectPath,
                                 s) == 0)
                    {
                        hr = CreateSettingForTestInst(WdmTest,
                                                      ppObj,
                                                      i,
                                                      j,
                                                      pCtx);
                        break;
                    }
                }
            }
            
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestForSoftwareClassName()) == 0) {
            //
            // We do not support this
            //
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmTestInPackageClassName()) == 0) {
            //
            // We do not support packages
            //
        } else if (_wcsicmp(ClassName, WdmTest->GetCdmResultInPackageClassName()) == 0) {
            //
            // We do not support packages
            //
        }
    }

    return(hr);
}


/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.                                                       *
*                                                                       *
*                                                                       *
************************************************************************/

STDMETHODIMP CClassPro::ExecMethodAsync(
    const BSTR ObjectPath,
    const BSTR MethodName, 
    long lFlags,
    IWbemContext* pCtx,
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink
    )
{   
    HRESULT hr, hrDontCare;    
    IWbemClassObject * pMethodClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    WCHAR ClassName[MAX_PATH];
    WCHAR *p;
    VARIANT v, vRetVal;
    int RelPathIndex;
    CTestServices *WdmTest;
    BSTR ExecutionID;


    VariantInit(&v);
    VariantInit(&vRetVal);
    
    //
    // Extract this class name from the object path
    //
    wcscpy(ClassName, ObjectPath);
    p = ClassName;
    while ((*p != 0) && (*p != L'.'))
    {
        p++;
    }
    *p = 0;

    WmipDebugPrint(("CDMPROV: Exec method %ws for instanec %ws\n",
                    MethodName, ObjectPath));

    //
    // Obtain a test services object that represents this class
    //
    hr = LookupTestServices(ClassName,
                            &WdmTest);
    
    if (hr != WBEM_S_NO_ERROR)
    {
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }

    //
    // Get the input parameter SystemElement which is the Cim Relative
    // Path
    //
    hr = WmiGetProperty(pInParams,
                        L"SystemElement",
                        CIM_REFERENCE,
                        &v);

    if (hr != WBEM_S_NO_ERROR)
    {
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }

    //
    // Find the relpath index that matches the Cim Path
    //
    hr = WdmTest->GetRelPathIndex(v.bstrVal,
                                  &RelPathIndex);
        
    VariantClear(&v);
    
    if (hr != WBEM_S_NO_ERROR)
    {
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }

    //
    // Get our class object for the method so we can set the output
    // parameters
    //
    hr = m_pCdmServices->GetObject(ClassName, 0, pCtx, &pMethodClass, NULL);
    if (hr != S_OK)
    {
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }


    //
    // These methods returns values, and so create an instance of the
    // output argument class.

    hr = pMethodClass->GetMethod(MethodName, 0, NULL, &pOutClass);
    if (hr != S_OK)
    {
        pMethodClass->Release();
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }

    hr = pOutClass->SpawnInstance(0, &pOutParams);
    pOutClass->Release();
    pMethodClass->Release();

    if (hr != WBEM_S_NO_ERROR)
    {
        pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
        return(WBEM_S_NO_ERROR);
    }
            
    //
    // See what method we are being called on and deal with it
    //
    if (_wcsicmp(MethodName, L"RunTest") == 0)
    {
        //
        // Run test
        //
        // uint16 RunTest([IN] CIM_ManagedSystemElement ref SystemElement, 
        //                [IN] DiagnosticSetting ref Setting, 
        //                [OUT] CIM_DiagnosticResult ref Result);   
        //
        IWbemClassObject *pCdmSettings;
        IWbemClassObject *pCdmResult;
        ULONG Result;
        VARIANT vSettingRelPath;
        VARIANT vResult;

        //
        // Get the settings for the test by first getting the
        // relpath for them and then getting the actual object
        //
        hr = WmiGetProperty(pInParams,
                            L"Setting",
                            CIM_REFERENCE,
                            &vSettingRelPath);
                
        if (hr == WBEM_S_NO_ERROR)
        {
            if (vSettingRelPath.vt != VT_NULL)
            {
                hr = m_pCdmServices->GetObject(vSettingRelPath.bstrVal,
                                               WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                               NULL,
                                               &pCdmSettings,
                                               NULL);
            } else {
                pCdmSettings = NULL;
            }
            
            VariantClear(&vSettingRelPath);
                    
            if (hr == WBEM_S_NO_ERROR)
            {
                //
                // Create an empty instance of the results
                // class which will get filled in when the test
                // is run
                //
                hr = CreateInst(m_pCdmServices,
                                &pCdmResult,
                                WdmTest->GetCdmResultClassName(),
                                NULL);

                if (hr == WBEM_S_NO_ERROR)
                {
                    //
                    // Setup the test starting time
                    //
                    v.vt = VT_BSTR;
                    v.bstrVal = GetCurrentDateTime();
                    hr = WmiSetProperty(pCdmResult,
                                        L"TestStartTime",
                                        &v);
                    VariantClear(&v);

                    if (hr == WBEM_S_NO_ERROR)
                    {
                        //
                        // Go and get the Wdm test run and the
                        // results copied back into our cdm class
                        //
                        hr = WdmTest->ExecuteWdmTest(pCdmSettings,
                                                     pCdmResult,
                                                     RelPathIndex,
                                                     &Result,
                                                     &ExecutionID);

                        if (hr == WBEM_S_NO_ERROR)
                        {
                            //
                            // Fill in any additional properties
                            // for the result object
                            //
                            hr = WdmTest->FillInCdmResult(pCdmResult,
                                                              pCdmSettings,
                                                              RelPathIndex,
                                                              ExecutionID);

                            if (hr == WBEM_S_NO_ERROR)
                            {
                                //
                                // return result as an output pointer
                                //
                                hr = WmiGetProperty(pCdmResult,
                                                    L"__RelPath",
                                                    CIM_STRING,
                                                    &vResult);

                                if (hr == WBEM_S_NO_ERROR)
                                {
                                    hr = WmiSetProperty(pOutParams,
                                                        L"Result",
                                                        &vResult);
                                    if (hr == WBEM_S_NO_ERROR)
                                    {
										
// @@BEGIN_DDKSPLIT
// We'll do this when we support reboot diags and
// keeping results after reboot
#if 0                                        
                                        //
                                        // Persist the result
                                        // object into the schema
                                        // for later access
                                        //
                                        hr = WdmTest->PersistResultInSchema(pCdmResult,
                                                                            ExecutionID,
                                                                            RelPathIndex);
#endif										
// @@END_DDKSPLIT
										
                                        if (hr == WBEM_S_NO_ERROR)
                                        {
                                            //
                                            // Include the relpath
                                            // to the result
                                            // object to our
                                            // internal list
                                            hr = WdmTest->AddResultToList(pCdmResult,
                                                                          ExecutionID,
                                                                          RelPathIndex
                                                                          );
                                            if (hr == WBEM_S_NO_ERROR)
                                            {
                                                //
                                                // Setup a return value of success
                                                //
                                                vRetVal.vt = VT_I4;
                                                vRetVal.lVal = Result;
                                            }
                                        }
                                    }
                                    VariantClear(&vResult);
                                }
                            }
                            SysFreeString(ExecutionID);
                        }                               
                    }
                    
                    pCdmResult->Release();
                }
                
                if (pCdmSettings != NULL)
                {
                    pCdmSettings->Release();
                }
            }
        }
                
    } else if (_wcsicmp(MethodName, L"ClearResults") == 0) {
        //
        // Clear the results for the test
        //
        // uint32 ClearResults([IN] CIM_ManagedSystemElement ref SystemElement, 
        //                     [OUT] String ResultsNotCleared[]);   
        //
        VARIANT vResultsNotCleared;

        //
        // Clear all results for this test
        //
        WdmTest->ClearResultsList(RelPathIndex);
        
        //
        // Setup the output parameter
        //
        VariantInit(&vResultsNotCleared);
        vResultsNotCleared.vt = VT_BSTR;
        vResultsNotCleared.bstrVal = NULL;
                
        WmiSetProperty(pOutParams,
                       L"ResultsNotCleared",
                       &vResultsNotCleared);
        VariantClear(&vResultsNotCleared);
        
        //
        // Setup a return value of success
        //
        vRetVal.vt = VT_I4;
        vRetVal.ulVal = 0;
    } else if (_wcsicmp(MethodName, L"DiscontinueTest") == 0) {
        //
        // Discontinue a test in progress. 
        //
        // uint32 DiscontinueTest([IN] CIM_ManagedSystemElement ref SystemElement, 
        //                        [IN] CIM_DiagnosticResult ref Result, 
        //                        [OUT] Boolean TestingStopped);                
        //
        BOOLEAN TestingStopped;
        ULONG Result;
        VARIANT vTestingStopped;                

        hr = WdmTest->StopWdmTest(RelPathIndex,
                                           &Result,
                                           &TestingStopped);
                                           
        //
        // Setup the output parameter
        //
        if (hr == WBEM_S_NO_ERROR)
        {
            VariantInit(&vTestingStopped);
            vTestingStopped.vt = VT_BOOL;
            vTestingStopped.boolVal = TestingStopped ? VARIANT_TRUE :
                                                       VARIANT_FALSE;

            WmiSetProperty(pOutParams,
                           L"TestingStopped",
                           &vTestingStopped);
            VariantClear(&vTestingStopped);

            //
            // Setup a return value of result
            //
            vRetVal.vt = VT_I4;
            vRetVal.ulVal = Result;
        }               
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Establish the return value for the method call
        //
        WmiSetProperty(pOutParams,
                   L"ReturnValue",
                   &vRetVal);
        VariantClear(&vRetVal);

        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.

        hr = pResultSink->Indicate(1, &pOutParams);    
        
    }
    
    pOutParams->Release();
    
    pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL,NULL);
    
    return(hr);
}


SCODE CClassPro::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}
 
SCODE CClassPro::DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}
SCODE CClassPro::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}
SCODE CClassPro::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}

CTestServices *CClassPro::FindExistingTestServices(
	PWCHAR CdmClassName
	)
{
	
	CTestServices *WdmTest;

	//
	// This routine assumes any sync mechanism has been done outside of
	// this routine
	//
    WdmTest = WdmTestHead;
    while (WdmTest != NULL)
    {
        if (WdmTest->ClaimCdmClassName(CdmClassName))
        {
            //
            // We found an existing test services for this class
            //
            return(WdmTest);
        }
        WdmTest = WdmTest->GetNext();
    }
	return(NULL);
}

HRESULT CClassPro::LookupTestServices(
    const BSTR CdmClassName,
    CTestServices **TestServices
    )
{
    HRESULT hr;
    CTestServices *WdmTest, *OtherWdmTest;
            
    WmipAssert(CdmClassName != NULL);
    WmipAssert(TestServices != NULL);
    
    //
    // Look up the class name and find the Wdm Test Services
    // class that represents it. 
    //

	EnterCdmCritSection();
	WdmTest = FindExistingTestServices(CdmClassName);
	LeaveCdmCritSection();
	if (WdmTest != NULL)
	{
		*TestServices = WdmTest;
		return(WBEM_S_NO_ERROR);
	}
	        
    //
    // If the WDM test services has not yet been initialized for this
    // CDM diagnostic classes then go ahead and do so
    //
    WdmTest = new CTestServices();
    
    hr = WdmTest->InitializeCdmClasses(CdmClassName);
    
    if (hr == WBEM_S_NO_ERROR)
    {
		//
		// Now check to see if another thread created and inserted the
		// test services for the class while we were trying to
		// initialize it. Since we want only one test services we throw
		// ours away and use the other
		//
		EnterCdmCritSection();
		OtherWdmTest = FindExistingTestServices(CdmClassName);
		
		if (OtherWdmTest == NULL)
		{
			//
			// Horray, we win do insert our own test into list
			//
			WdmTest->InsertSelf(&WdmTestHead);
			LeaveCdmCritSection();
		} else {
			//
			// We lost, so use existing test services
			//
			WmipDebugPrint(("CDMPROV: WdmTest %p lost insertion race to %p\n",
							WdmTest, OtherWdmTest));
			LeaveCdmCritSection();
			delete WdmTest;
			WdmTest = OtherWdmTest;
		}
		
        *TestServices = WdmTest;
        WmipDebugPrint(("CDMPROV: Inited WdmTest %p for %ws\n",
                        WdmTest, CdmClassName));
    } else {
        WmipDebugPrint(("CDMPROV: Inited failed %x for %p for %ws\n",
                        hr, WdmTest, CdmClassName));
        delete WdmTest;
    }
    
    return(hr);
}

HRESULT CClassPro::CreateTestInst(
    CTestServices *WdmTest,
    IWbemClassObject **pCdmTest,
    IWbemContext *pCtx                                        
    )
{
    HRESULT hr;
    VARIANT v;
    
    //
    // We create 1 instance of the CIM_DiagnosticTest class
    // regardless of the number of devices that support this class.
    // Note that for the CDM proeprties of the test we arbitrarily
    // pick the first device and get its WDM properties.
    //
    hr = CreateInst(m_pCdmServices,
                    pCdmTest,
                    WdmTest->GetCdmTestClassName(),
                    pCtx);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Get WDM properties from WDM
        //
        hr = WdmTest->QueryWdmTest(*pCdmTest,
                                   0);
        if (hr == WBEM_S_NO_ERROR)
        {
            //
            // Set UM provider properties here. These are Name
            //
            VariantInit(&v);

            V_VT(&v) = VT_BSTR;
            V_BSTR(&v) = SysAllocString(WdmTest->GetCdmTestClassName());
            hr = (*pCdmTest)->Put(L"Name", 0, &v, 0);
            if (hr != WBEM_S_NO_ERROR)
            {
                (*pCdmTest)->Release();
            }
            VariantClear(&v);

        } else {
            (*pCdmTest)->Release();
        }
    }
    return(hr);
}

HRESULT CClassPro::CreateResultForMSEInst(
    CTestServices *WdmTest,
    IWbemClassObject **pCdmResultForMSE,
    int RelPathIndex,
    IWbemClassObject *pCdmResult,
    IWbemContext *pCtx                                        
)
{
    HRESULT hr;
    PWCHAR PropertyNames[2];
    VARIANT PropertyValues[2];
            
    hr = CreateInst(m_pCdmServices,
                    pCdmResultForMSE,
                    WdmTest->GetCdmResultForMSEClassName(),
                    pCtx);

    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Result is a reference to the CIM_Diagnostic result class
        //
		hr = WmiGetProperty(pCdmResult,
							L"__RelPath",
							CIM_REFERENCE,
							&PropertyValues[0]);
		PropertyNames[0] = L"Result";
            
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// SystemElement is a reference to the CIM class (MSE)
			//
			PropertyNames[1] = L"SystemElement";
			PropertyValues[1].vt = VT_BSTR;
			PropertyValues[1].bstrVal = WdmTest->GetCimRelPath(RelPathIndex);
			
			hr = WmiSetPropertyList(*pCdmResultForMSE,
									2,
									PropertyNames,
									PropertyValues);
			if (hr != WBEM_S_NO_ERROR)
			{
				(*pCdmResultForMSE)->Release();
			}
                
			VariantClear(&PropertyValues[0]);

		} else {
			(*pCdmResultForMSE)->Release();
		}
	} else {
		hr = WBEM_E_NOT_FOUND;
		(*pCdmResultForMSE)->Release();
    }
    
    return(hr);
}

HRESULT CClassPro::CreateResultForTestInst(
    CTestServices *WdmTest,
    IWbemClassObject **pCdmResultForTest,
    IWbemClassObject *pCdmResult,
    IWbemContext *pCtx
    )
{
    PWCHAR PropertyNames[2];
    VARIANT PropertyValues[2];
    HRESULT hr;

    //
    // Set the DiagnosticTest property which is the relpath to
    // this test
    //
    PropertyNames[0] = L"DiagnosticTest";
    PropertyValues[0].vt = VT_BSTR;
    PropertyValues[0].bstrVal = WdmTest->GetCdmTestRelPath();

	hr = WmiGetProperty(pCdmResult,
                            L"__RelPath",
                            CIM_REFERENCE,
                            &PropertyValues[1]);
	PropertyNames[1] = L"DiagnosticResult";

	if (hr == WBEM_S_NO_ERROR)
	{           
		//
		// for each instance of this test we create a ResultForTest
		// association instance and then set the properties within
		// it to the appropriate values and relpaths
            
		hr = CreateInst(m_pCdmServices,
                            pCdmResultForTest,
                            WdmTest->GetCdmResultForTestClassName(),
                            pCtx);
            
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = WmiSetPropertyList((*pCdmResultForTest),
									2,
									PropertyNames,
									PropertyValues);
			if (hr != WBEM_S_NO_ERROR)
			{
				(*pCdmResultForTest)->Release();
			}
		}
		VariantClear(&PropertyValues[1]);
	}
    
    return(hr);
}

HRESULT CClassPro::CreateTestForMSEInst(
    CTestServices *WdmTest,
    IWbemClassObject **pCdmTestForMSE,
    int RelPathIndex,
    IWbemContext *pCtx
    )
{
    HRESULT hr;
    PWCHAR PropertyNames[8];
    VARIANT PropertyValues[8];
    
    hr = CreateInst(m_pCdmServices,
                    pCdmTestForMSE,
                    WdmTest->GetCdmTestForMSEClassName(),
                    pCtx);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Set the antecedent property which is the relpath to
        // the DiagTest
        //
        PropertyNames[0] = L"Antecedent";
        PropertyValues[0].vt = VT_BSTR;
        PropertyValues[0].bstrVal = WdmTest->GetCdmTestRelPath();

        //
        // Set the dependent property which is the relpath to
        // this MSE
        //
        PropertyNames[1] = L"Dependent";
        PropertyValues[1].vt = VT_BSTR;
        PropertyValues[1].bstrVal = WdmTest->GetCimRelPath(RelPathIndex);

        //
        // Set the estimated time of performing which is
        // obtained from querying the test itself
        //
        PropertyNames[2] = L"EstimatedTimeOfPerforming";
        PropertyValues[2].vt = VT_I4;
        PropertyValues[2].lVal = WdmTest->GetTestEstimatedTime(RelPathIndex);
        
        //
        // Set IsExclusiveForMSE which is obtained from
        // querying the test itself
        //
        PropertyNames[3] = L"IsExclusiveForMSE";
        PropertyValues[3].vt = VT_BOOL;
        PropertyValues[3].boolVal = WdmTest->GetTestIsExclusiveForMSE(RelPathIndex) ?
                                                    VARIANT_TRUE :
                                                    VARIANT_FALSE;

        //
        // Not sure what this is for
        // 
        PropertyNames[4] = L"MessageLine";
        PropertyValues[4].vt = VT_BSTR;
        PropertyValues[4].bstrVal = NULL;
        
        //
        // Not sure what this is for
        //
        PropertyNames[5] = L"ReturnMessage";
        PropertyValues[5].vt = VT_BSTR;
        PropertyValues[5].bstrVal = NULL;

        //
        // Not sure what this is for
        //
        PropertyNames[6] = L"Prompt";
        PropertyValues[6].vt = VT_I4;
        PropertyValues[6].lVal = 0;
        
        //
        // Not sure what this is for
        //
        PropertyNames[7] = L"RequestedLanguage";
        PropertyValues[7].vt = VT_I4;
        PropertyValues[7].lVal = 0;
        
        hr = WmiSetPropertyList(*pCdmTestForMSE,
                                8,
                                PropertyNames,
                                PropertyValues);
        if (hr != WBEM_S_NO_ERROR)
        {
            (*pCdmTestForMSE)->Release();
        }       
    }
    
    return(hr);
}

HRESULT CClassPro::CreateSettingForTestInst(
    CTestServices *WdmTest,
    IWbemClassObject **pCdmSettingForTest,
    int RelPathIndex,
    ULONG SettingIndex,
    IWbemContext *pCtx
    )
{
    HRESULT hr;
    PWCHAR PropertyNames[2];
    VARIANT PropertyValues[2];
    
    hr = CreateInst(m_pCdmServices,
                    pCdmSettingForTest,
                    WdmTest->GetCdmSettingForTestClassName(),
                    pCtx);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        //
        // Set the e;lement property which is the relpath to
        // the Diagn
        //
        PropertyNames[0] = L"Element";
        PropertyValues[0].vt = VT_BSTR;
        PropertyValues[0].bstrVal = WdmTest->GetCdmTestRelPath();

        //
        // Set the setting property which is the relpath to
        // this setting
        //
        PropertyNames[1] = L"Setting";
        PropertyValues[1].vt = VT_BSTR;
        PropertyValues[1].bstrVal = WdmTest->GetCdmSettingRelPath(RelPathIndex,
                                                                  SettingIndex);
        hr = WmiSetPropertyList(*pCdmSettingForTest,
                                2,
                                PropertyNames,
                                PropertyValues);
        if (hr != WBEM_S_NO_ERROR)
        {
            (*pCdmSettingForTest)->Release();
        }       
    }
    
    return(hr);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\reload.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    reload.cpp

Abstract:

    Restart a device stack


Revision History:

--*/

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "debug.h"

extern "C" ULONG RestartDevice(
    PWCHAR PnpDeviceId
    )
{
	HDEVINFO DevInfo;
	SP_DEVINFO_DATA DevInfoData;
	SP_PROPCHANGE_PARAMS PropChangeParams;
	ULONG Status;
	BOOL ok;
	
	//
	// First thing is to create a dev info set
	//
	DevInfo = SetupDiCreateDeviceInfoList(NULL,	    // ClassGuid
										  NULL);	// hwndParent

	if (DevInfo == INVALID_HANDLE_VALUE)
	{
		WmipDebugPrint(("SetupDiCreateDeviceInfoList failed %d\n",
			   GetLastError()));
		
		return(GetLastError());
	}

	//
	// Next step is to add our target device to the dev info set
	//
	DevInfoData.cbSize = sizeof(DevInfoData);
	ok = SetupDiOpenDeviceInfoW(DevInfo,
							   PnpDeviceId,
							   NULL,				// hwndParent
							   0,                   // OpenFlags
							   &DevInfoData);

	if (ok)
	{
		memset(&PropChangeParams, 0, sizeof(PropChangeParams));
		PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
		PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
		PropChangeParams.StateChange = DICS_PROPCHANGE;
		PropChangeParams.Scope       = DICS_FLAG_CONFIGSPECIFIC;
		PropChangeParams.HwProfile   = 0; // current profile
		
		ok = SetupDiSetClassInstallParamsW(DevInfo,		
                                      &DevInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                      sizeof(SP_PROPCHANGE_PARAMS));
		if (ok)
		{		
			ok = SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
										   DevInfo,
										   &DevInfoData);
			if (ok)
			{
				Status = ERROR_SUCCESS;
			} else {
				WmipDebugPrint(("SetupDiCallClassInstaller failed %d\n", GetLastError()));
				Status = GetLastError();
			}
		} else {
			WmipDebugPrint(("SetupDiSetClassInstallParams failed %d\n", GetLastError()));
			Status = GetLastError();
		}
									   
	} else {
		printf("SetupDiOpenDeviceInfo failed %d\n", GetLastError());
		Status = GetLastError();
	}

	//
	// Finally we need to free the device info set
	//
	SetupDiDestroyDeviceInfoList(DevInfo);
	
	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\reload.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    reload.h

Abstract:

    Restart a device stack


Revision History:

--*/

extern "C" ULONG RestartDevice(
    PWCHAR PnpDeviceId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\wbemmisc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wbemmisc.cpp
//
//  Abstract:    Misc routines useful for interfacing with WBEM
//
//--------------------------------------------------------------------------

extern HANDLE CdmMutex;

#define EnterCdmCritSection() WaitForSingleObject(CdmMutex, INFINITE)

#define LeaveCdmCritSection() ReleaseMutex(CdmMutex);


HRESULT WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PWCHAR QualifierName,
    IN VARTYPE Type,
    OUT VARIANT *Value
    );

HRESULT WmiGetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT *Value
    );

HRESULT WmiSetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN VARIANT *Value
    );

PVOID WmipAlloc(
    ULONG Size
    );

void WmipFree(
    PVOID Ptr
    );
PWCHAR AddSlashesToStringW(
    PWCHAR SlashedNamespace,
    PWCHAR Namespace
    );

HRESULT WmiConnectToWbem(
    PWCHAR Namespace,
    IWbemServices **ppIWbemServices
    );


typedef struct
{
	PWCHAR Name;
	VARTYPE VarType;
	VARIANT Value;
} QUALIFIER_VALUE, *PQUALIFIER_VALUE;


HRESULT GetClassQualifierList(
    IWbemServices *pServices,
    PWCHAR ClassName,
    ULONG QualifierValuesCount,
	PQUALIFIER_VALUE QualifierValues
    );

HRESULT WmiSetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,
    IN PWCHAR *PropertyNames,
    IN VARIANT *Values
    );

HRESULT WmiGetPropertyByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT *Value
    );

HRESULT CreateInst(
    IWbemServices * pNamespace,
	IWbemClassObject ** pNewInst,
    WCHAR * pwcClassName,
	IWbemContext  *pCtx
);

BSTR GetCurrentDateTime(
    void
    );


HRESULT WmiDumpClassObject(
    IWbemClassObject *pClass,
    PWCHAR ClassName
    );

HRESULT WmiGetQualifierListByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    PWCHAR PropertyName,					   
    IN ULONG QualifierCount,
    IN PWCHAR *QualifierNames,
    IN VARTYPE *Types,
    OUT VARIANT *Values
    );

PWCHAR AddSlashesToStringExW(
    PWCHAR SlashedNamespace,
    PWCHAR Namespace
    );


HRESULT WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
);

HRESULT LookupValueMap(
    IWbemServices *pServices,
    PWCHAR ClassName,
    PWCHAR PropertyName,					   
	ULONG Value,
    BSTR *MappedValue
	);

void FreeTheBSTRArray(
    BSTR *Array,
	ULONG Size
    );

HRESULT GetMethodInParamInstance(
    IN IWbemServices *pServices,
	IN PWCHAR ClassName,
    IN BSTR MethodName,
    OUT IWbemClassObject **ppInParamInstance
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\wbemmisc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       wbemmisc.cpp
//
//  Abstract:    Misc routines useful for interfacing with WBEM
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <windows.h>
#include <wbemidl.h>
#include <wbemtime.h>

#include <stdio.h>
#include <string.h>
#include <wchar.h>

#include "debug.h"
#include "wbemmisc.h"


HRESULT GetMethodInParamInstance(
    IN IWbemServices *pServices,
	IN PWCHAR ClassName,
    IN BSTR MethodName,
    OUT IWbemClassObject **ppInParamInstance
	)
/*+++

Routine Description:

    This routine will return an instance object for a methods in
    parameter. WBEM requires that we go through this dance to get an
    instance object.
        
Arguments:

    pServices

    ClassName is the class containing the method

    MethodName is the name of the method

    *ppInParamInstance returns the instance object to fill with in
        parameters

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemClassObject *pInParamClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(MethodName != NULL);
	WmipAssert(ppInParamInstance != NULL);
	
	hr = pServices->GetObject(ClassName,
								 0,
								 NULL,
								 &pClass,
								 NULL);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = pClass->GetMethod(MethodName,
									  0,
									  &pInParamClass,
									  NULL);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = pInParamClass->SpawnInstance(0,
											  ppInParamInstance);
			pInParamClass->Release();
		}
		pClass->Release();
	}
	
    return(hr);			
}


HRESULT WmiGetQualifier(
    IN IWbemQualifierSet *pIWbemQualifierSet,
    IN PWCHAR QualifierName,
    IN VARTYPE Type,
    OUT /* FREE */ VARIANT *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific qualifier
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    QualifierName is the name of the qualifier
        
    Type is the type of qualifier expected
        
    *Value returns with the value of the qualifier. Caller must call
		VariantClear

Return Value:

	HRESULT

---*/
{
    BSTR s;
    HRESULT hr;

    WmipAssert(pIWbemQualifierSet != NULL);
    WmipAssert(QualifierName != NULL);
    WmipAssert(Value != NULL);
    
    s = SysAllocString(QualifierName);
    if (s != NULL)
    {
        hr = pIWbemQualifierSet->Get(s,
                                0,
                                Value,
                                NULL);
                
        if ((Value->vt & ~CIM_FLAG_ARRAY) != Type)
        {
            hr = WBEM_E_FAILED;
			VariantClear(Value);
        }
        
        SysFreeString(s);
    } else {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return(hr);
}

HRESULT WmiGetQualifierListByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN ULONG QualifierCount,
    IN PWCHAR *QualifierNames,
    IN VARTYPE *Types,
    OUT VARIANT /* FREE */ *Values
    )
/*+++

Routine Description:

    This routine will return the values for a list of qualifiers. If
    all qualifiers cannot be returned then none are.
        
Arguments:

	pServices is the IWbemServices pointer

	ClassName is the name of the class with qualifiers

	PropertyName is the name of the property with qualfiers. If NULL
		then class qualifiers are returned

	QualifierCount is the count of qualifers to get

	QualifierNames is an array contaiing names of qualifiers to get

	Types is an array of expected value types for the qualifiers

	Values is an array of variants that return with the qualifer values

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;
	IWbemQualifierSet *pQualifiers;
	ULONG i, j;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(QualifierNames != NULL);
	WmipAssert(Types != NULL);
	WmipAssert(Values != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName,
							  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							  NULL,
							  &pClass,
							  NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		if (PropertyName == NULL)
		{
			hr = pClass->GetQualifierSet(&pQualifiers);
		} else {
			hr = pClass->GetPropertyQualifierSet(PropertyName,
				                                 &pQualifiers);
		}
		
		if (hr == WBEM_S_NO_ERROR)
		{
			for (i = 0; (i < QualifierCount) && (hr == WBEM_S_NO_ERROR); i++)
			{
				hr = WmiGetQualifier(pQualifiers,
									 QualifierNames[i],
									 Types[i],
									 &Values[i]);
			}

			if (hr != WBEM_S_NO_ERROR)
			{
				for (j = 0; j < i; j++)
				{
					VariantClear(&Values[j]);
				}
			}
			
			pQualifiers->Release();
		}
		pClass->Release();
	}
	
	return(hr);
}



HRESULT WmiGetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
    HRESULT hr;
	CIMTYPE CimType;

    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);
    
	hr = pIWbemClassObject->Get(PropertyName,
                                0,
                                Value,
								&CimType,
                                NULL);

	//
	// Treat a NULL value for a property as an error
	//
	if (Value->vt == VT_NULL)
	{
		hr = WBEM_E_ILLEGAL_NULL;
		WmipDebugPrint(("CDMPROV: Property %ws is NULL\n",
						PropertyName));
	}
	
	//
	// Treat CIM_REFERENCE and CIM_STRING as interchangable
	//
	if ((ExpectedCimType == CIM_REFERENCE) &&
        (CimType == CIM_STRING))
	{
		ExpectedCimType = CIM_STRING;
	}
	
	if ((ExpectedCimType == CIM_STRING) &&
        (CimType == CIM_REFERENCE))
	{
		ExpectedCimType = CIM_REFERENCE;
	}
	
	if ((hr == WBEM_S_NO_ERROR) && (ExpectedCimType != CimType))
	{
		WmipDebugPrint(("CDMPROV: Property %ws was expected as %d but was got as %d\n",
						PropertyName,
						ExpectedCimType,
						CimType));
		WmipAssert(FALSE);
		hr = WBEM_E_FAILED;
		VariantClear(Value);
	}
        

    return(hr);
}


HRESULT WmiGetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,						   
    IN PWCHAR *PropertyNames,
    IN CIMTYPE *ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property
        
Arguments:

    pIWbemQualifierSet is the qualifier set object
        
    PropertyNames is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	ULONG i,j;
	HRESULT hr;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(ExpectedCimType != NULL);
	WmipAssert(Value != NULL);

	
	for (i = 0, hr = WBEM_S_NO_ERROR;
		 (i < PropertyCount) && (hr == WBEM_S_NO_ERROR);
		 i++)
	{
		hr = WmiGetProperty(pIWbemClassObject,
							PropertyNames[i],
							ExpectedCimType[i],
							&Value[i]);
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		for (j = 0; j < i; j++)
		{
			VariantClear(&Value[i]);
		}
	}
	return(hr);
}

HRESULT WmiGetPropertyByName(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,
    IN CIMTYPE ExpectedCimType,
    OUT VARIANT /* FREE */ *Value
    )
/*+++

Routine Description:

    This routine will return the value for a specific property within a
    class
        
Arguments:

	pServices is the IWbemServices for the namespace containing your
		class
	
    ClassName is the name of the class whose property you are
		interested in
        
    PropertyName is the name of the property
        
    Type is the type of property expected
        
    *Value returns with the value of the property

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	IWbemClassObject *pClass;

	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(Value != NULL);
	
	//
	// Create the class so we can look at the properties
	//
	hr = pServices->GetObject(ClassName, 0, NULL, &pClass, NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetProperty(pClass,
							PropertyName,
							ExpectedCimType,
							Value);

		pClass->Release();
	}
	
	return(hr);
}


HRESULT WmiSetProperty(
    IN IWbemClassObject *pIWbemClassObject,
    IN PWCHAR PropertyName,
    IN VARIANT *Value
    )
/*+++

Routine Description:

    This routine will set the value of a property to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyName is the name of the property being set

	Value is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	HRESULT hr;
	
    WmipAssert(pIWbemClassObject != NULL);
    WmipAssert(PropertyName != NULL);
    WmipAssert(Value != NULL);

	hr = pIWbemClassObject->Put(PropertyName,
						   0,
						   Value,
						   0);

	if (hr == WBEM_E_TYPE_MISMATCH)
	{
		WmipDebugPrint(("CDMPROV: Put %ws has wrong type %d\n",
						PropertyName, Value->vt));
		WmipAssert(FALSE);
	}
	
	return(hr);
}

HRESULT WmiSetPropertyList(
    IN IWbemClassObject *pIWbemClassObject,
    IN ULONG PropertyCount,
    IN PWCHAR *PropertyNames,
    IN VARIANT *Values
    )
/*+++

Routine Description:

    This routine will set the values of multiple properties to something
        
Arguments:

	pIWbemClassObject is the object whose property is being set

	PropertyCount is the number of properties to set

	PropertyNames is the names of the property being set

	Values is the value that the property is being set to

Return Value:

	HRESULT

---*/
{
	ULONG i;
	HRESULT hr = WBEM_S_NO_ERROR;

	WmipAssert(pIWbemClassObject != NULL);
	WmipAssert(PropertyNames != NULL);
	WmipAssert(Values != NULL);

	for (i = 0; (i < PropertyCount) && (hr == WBEM_S_NO_ERROR); i++)
	{		
		hr = WmiSetProperty(pIWbemClassObject,
							PropertyNames[i],
							&Values[i]);
	}
	
	return(hr);
}

// @@BEGIN_DDKSPLIT
#ifndef HEAP_DEBUG
// @@END_DDKSPLIT
PVOID WmipAlloc(
    IN ULONG Size
    )
/*+++

Routine Description:

    Internal memory allocator
        
Arguments:

	Size is the number of bytes to allocate

Return Value:

	pointer to alloced memory or NULL

---*/
{
	return(LocalAlloc(LPTR, Size));
}

void WmipFree(
    IN PVOID Ptr
    )
/*+++

Routine Description:

    Internal memory deallocator
        
Arguments:

	Pointer to freed memory

Return Value:

    void

---*/
{
	WmipAssert(Ptr != NULL);
	LocalFree(Ptr);
}
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT


PWCHAR AddSlashesToStringW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\. It needs to
    do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;

	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one
    //
    while (*Namespace != 0)
    {
        if (*Namespace == L'\\')
        {
            *SlashedNamespace++ = L'\\';
        }
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

PWCHAR AddSlashesToStringExW(
    OUT PWCHAR SlashedNamespace,
    IN PWCHAR Namespace
    )
/*+++

Routine Description:

    This routine will convert ever \ in the string into \\ and " into
    \".  It needs to do this since WBEM will collapse \\ into \ sometimes.
        
Arguments:

    SlashedNamespace returns with string double slashed

    Namespace is the input string

Return Value:

	pointer to SlashedNamespace

---*/
{
    PWCHAR Return = SlashedNamespace;
    
	WmipAssert(SlashedNamespace != NULL);
	WmipAssert(Namespace != NULL);
	
    //
    // MOF likes the namespace paths to be C-style, that is to have a
    // '\\' instad of a '\'. So whereever we see a '\', we insert a
    // second one. We also need to add a \ before any ".
    //
    while (*Namespace != 0)
    {
        if ((*Namespace == L'\\') || (*Namespace == L'"'))
        {
            *SlashedNamespace++ = L'\\';
        }
		
        *SlashedNamespace++ = *Namespace++;
    }
    *SlashedNamespace = 0;
    
    return(Return);
}

HRESULT WmiConnectToWbem(
    IN PWCHAR Namespace,
    OUT IWbemServices **ppIWbemServices
    )
/*+++

Routine Description:

    This routine will establishes a connection to a WBEM namespace on
    the local machine.

Arguments:

	Namespace is the namespace to which to connect

	*ppIWbemServices returns with a IWbemServices * for the namespace

Return Value:

	HRESULT

---*/
{
    IWbemLocator *pIWbemLocator;
    DWORD hr;
    BSTR s;

	WmipAssert(Namespace != NULL);
    WmipAssert(ppIWbemServices != NULL);
    
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pIWbemLocator);
    if (hr == S_OK)
    {
        s = SysAllocString(Namespace);
        if (s != NULL)
        {
			*ppIWbemServices = NULL;
			hr = pIWbemLocator->ConnectServer(s,
                            NULL,                           // Userid
                            NULL,                           // PW
                            NULL,                           // Locale
                            0,                              // flags
                            NULL,                           // Authority
                            NULL,                           // Context
                            ppIWbemServices
                           );
                       
			SysFreeString(s);
                             
		} else {
		    *ppIWbemServices = NULL;
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		
        pIWbemLocator->Release();
    }
    
    return(hr);
}

HRESULT CreateInst(
    IN IWbemServices * pNamespace,
	OUT /* FREE */ IWbemClassObject ** pNewInst,
    IN WCHAR * pwcClassName,
	IN IWbemContext  *pCtx
)
/*+++

Routine Description:

    This routine will create a new instance for the specified class

Arguments:

	pNamespace is the IWbemServices * to the namespace in which the
		class lives

	*pNewinst returns with the new instance of the class

	pwcClassName has the name of the class whose instance is created

	pCtx is the context to use in creating the instance

Return Value:

	HRESULT

---*/
{   
    HRESULT hr;
    IWbemClassObject * pClass;
	
    hr = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if (hr != S_OK)
	{
        return WBEM_E_FAILED;
	}
	
    hr = pClass->SpawnInstance(0, pNewInst);
    pClass->Release();

	WmipDebugPrint(("CDMProv:: Created %ws as %p\n",
					pwcClassName, *pNewInst));

    return(hr);	
}

/* FREE */ BSTR GetCurrentDateTime(
    void
    )
{
	SYSTEMTIME SystemTime;
	WBEMTime WbemTime;

	GetSystemTime(&SystemTime);
	WbemTime = SystemTime;
	return(WbemTime.GetBSTR());
}


HRESULT WmiGetArraySize(
    IN SAFEARRAY *Array,
    OUT LONG *LBound,
    OUT LONG *UBound,
    OUT LONG *NumberElements
)
/*+++

Routine Description:

    This routine will information about the size and bounds of a single
    dimensional safe array.
        
Arguments:

    Array is the safe array
        
    *LBound returns with the lower bound of the array

    *UBound returns with the upper bound of the array
        
    *NumberElements returns with the number of elements in the array

Return Value:

    TRUE if successful else FALSE

---*/
{
    HRESULT hr;

    WmipAssert(Array != NULL);
    WmipAssert(LBound != NULL);
    WmipAssert(UBound != NULL);
    WmipAssert(NumberElements != NULL);
    
    //
    // Only single dim arrays are supported
    //
    WmipAssert(SafeArrayGetDim(Array) == 1);
    
    hr = SafeArrayGetLBound(Array, 1, LBound);
    
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = SafeArrayGetUBound(Array, 1, UBound);
        *NumberElements = (*UBound - *LBound) + 1;
    }
    return(hr);
}

BOOLEAN IsUlongAndStringEqual(
    IN ULONG Number,
    IN PWCHAR String
    )
/*+++

Routine Description:

    This routine will convert the passed string to an integer and
    compare it to the passed integer value
        
Arguments:

	Number

	String

Return Value:

    TRUE if equal else FALSE

---*/
{
	ULONG SNumber;

	SNumber = _wtoi(String);
	return ( (Number == SNumber) ? TRUE : FALSE );
}

HRESULT LookupValueMap(
    IN IWbemServices *pServices,
    IN PWCHAR ClassName,
    IN PWCHAR PropertyName,					   
	IN ULONG Value,
    OUT /* FREE */ BSTR *MappedValue
	)
/*+++

Routine Description:

    This routine will lookup the string value corresponding to an
    integer valuemap
        
Arguments:

	pServices is the pointer to the namespace in which the class is
		locaed

	ClassName is the name of the class

	PropertyName is the name of the property

	Value is the value of the property and is used to look up the
		string that corresponsds to it

	*MappedValue returns a string that contains the string which the
		value maps to
		
Return Value:

    HRESULT

---*/
{
	PWCHAR Names[2];
	VARIANT QualifierValues[2];
	VARTYPE Types[2];
	HRESULT hr;
	BSTR s;
	LONG ValuesLBound, ValuesUBound, ValuesElements;
	LONG ValueMapLBound, ValueMapUBound, ValueMapElements;
	LONG i, Index;


	WmipAssert(pServices != NULL);
	WmipAssert(ClassName != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(MappedValue != NULL);
	
	//
	// Get the Values and ValueMap qualifiers so we can do the mapping
	//
	Names[0] = L"Values";
	Types[0] = VT_BSTR;
	
	Names[1] = L"ValueMap";
	Types[1] = VT_BSTR;
	
	hr = WmiGetQualifierListByName(pServices,
								   ClassName,
								   PropertyName,
								   2,
								   Names,
								   Types,
								   QualifierValues);
	if (hr == WBEM_S_NO_ERROR)
	{
		//
		// Now do a sanity check to make sure the values and valuemaps
		// have the same number of elements
		//

		if (QualifierValues[0].vt == QualifierValues[1].vt)
		{
			//
			// Values and ValueMap both agree that they are both
			// scalars or both arrays and are both strings
			//
			if (QualifierValues[0].vt & VT_ARRAY)
			{
				//
				// We have an array of thing to check for mapping.
				// First lets make sure that the arrays have identical
				// dimensions
				//
				hr = WmiGetArraySize(QualifierValues[0].parray,
									 &ValuesLBound,
									 &ValuesUBound,
									 &ValuesElements);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = WmiGetArraySize(QualifierValues[1].parray,
									 &ValueMapLBound,
									 &ValueMapUBound,
									 &ValueMapElements);

					if (hr == WBEM_S_NO_ERROR)
					{
						if ((ValuesLBound == ValueMapLBound) &&
						    (ValuesUBound == ValueMapUBound) &&
						    (ValuesElements == ValueMapElements))
						{
							for (i = 0; i < ValueMapElements; i++)
							{
								Index = i + ValueMapLBound;
								hr = SafeArrayGetElement(QualifierValues[1].parray,
														 &Index,
														 &s);
								if (hr == WBEM_S_NO_ERROR)
								{
									if (IsUlongAndStringEqual(Value,
															  s))
									{
										hr = SafeArrayGetElement(QualifierValues[0].parray,
																&Index,
																MappedValue);
										//
										// Make sure loop will
										// terminate
										i = ValueMapElements;
									}
									SysFreeString(s);
								}
							}
						} else {
							hr = WBEM_E_NOT_FOUND;
						}
					}
				}
				
			} else {
				//
				// We have scalars so this should make a fairly simple
				// mapping
				//
				if (IsUlongAndStringEqual(Value,
										  QualifierValues[1].bstrVal))
				{
					*MappedValue = SysAllocString(QualifierValues[0].bstrVal);
					if (*MappedValue == NULL)
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				} else {
					hr = WBEM_E_NOT_FOUND;
				}
			}
		} else {
			hr = WBEM_E_NOT_FOUND;
		}
		
		VariantClear(&QualifierValues[0]);
		VariantClear(&QualifierValues[1]);
	}
	
	return(hr);
}


void FreeTheBSTRArray(
    BSTR *Array,
	ULONG Size
    )
/*+++

Routine Description:

	This routine will free the contents of an array of BSTR and then
	the array itself
        
Arguments:

	Array is the array to be freed

	Size is the number of elements in the array
Return Value:

    HRESULT

---*/
{
	ULONG i;

	if (Array != NULL)
	{
		for (i = 0; i < Size; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\testinfo.cpp ===
//***************************************************************************
//
//  TestInfo.CPP
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

// @@BEGIN_DDKSPLIT
//
// What is left to do:
//
//    Finish reboot diagnostics - This involves persisting the pending
//    result in the schema and then trying to query for the actual
//    results later
//
//    Keep more than 1 historical result instance. This involves
//    persisting the historical results in the schema and picking them
//    up from there
// @@END_DDKSPLIT


#include <objbase.h>

#ifndef _MT
  #define _MT
#endif

#include <wbemidl.h>

#include "debug.h"
#include "testinfo.h"
#include "wbemmisc.h"
#include "cimmap.h"
#include "reload.h"

IWbemServices *pCimServices;
IWbemServices *pWdmServices;

HRESULT TestInfoInitialize(
    void
    )
/*+++

Routine Description:

    This routine will establishes a connection to the root\wmi and
    root\cimv2 namespaces in global memory

Arguments:

Return Value:

	HRESULT

---*/
{
    HRESULT hr;

    WmipAssert(pCimServices == NULL);
    WmipAssert(pWdmServices == NULL);

    hr = WmiConnectToWbem(L"root\\cimv2",
                          &pCimServices);
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = WmiConnectToWbem(L"root\\wmi",
                              &pWdmServices);
        
        if (hr != WBEM_S_NO_ERROR)
        {
            pCimServices->Release();
            pCimServices = NULL;
        }
    }

    return(hr);
}

void TestInfoDeinitialize(
    void
    )
/*+++

Routine Description:

    This routine will disestablish a connection to the root\wmi and
    root\cimv2 namespaces in global memory

Arguments:

Return Value:


---*/
{
    WmipAssert(pCimServices != NULL);
    WmipAssert(pWdmServices != NULL);
    
    pCimServices->Release();
    pCimServices = NULL;

    pWdmServices->Release();
    pWdmServices = NULL;
}

CTestServices::CTestServices()
/*+++

Routine Description:

	Constructor for CTestServices class

Arguments:

Return Value:

---*/
{
	WdmTestClassName = NULL;
	WdmSettingClassName = NULL;
	WdmSettingListClassName = NULL;
	WdmResultClassName = NULL;
	WdmOfflineResultClassName = NULL;
	CdmTestClassName = NULL;
	CdmTestRelPath = NULL;
	CdmResultClassName = NULL;
	CdmSettingClassName = NULL;
	CdmTestForMSEClassName = NULL;
	CdmTestForMSERelPath = NULL;
	CdmSettingForTestClassName = NULL;
	CdmSettingForTestRelPath = NULL;
	CdmResultForMSEClassName = NULL;
	CdmResultForTestClassName = NULL;
	CdmTestForSoftwareClassName = NULL;
	CdmTestForSoftwareRelPath = NULL;		
	CdmTestInPackageClassName = NULL;
	CdmTestInPackageRelPath = NULL;
	CdmResultInPackageClassName = NULL;
	CdmResultInPackageRelPath = NULL;
	CimClassMappingClassName = NULL;
	CimRelPaths = NULL;
	WdmRelPaths = NULL;
	PnPDeviceIdsX = NULL;
	WdmInstanceNames = NULL;
	CdmSettingsList = NULL;
	CdmResultsList = NULL;
	Next = NULL;
	Prev = NULL;
}

CTestServices::~CTestServices()
/*+++

Routine Description:

	Destructor for CTestServices class

Arguments:

Return Value:

---*/
{
	int i;
	
	if (WdmTestClassName != NULL)
	{
		SysFreeString(WdmTestClassName);
	}
	
	if (WdmSettingClassName != NULL)
	{
		SysFreeString(WdmSettingClassName);
	}
	
	if (WdmResultClassName != NULL)
	{
		SysFreeString(WdmResultClassName);
	}
	
	if (WdmOfflineResultClassName != NULL)
	{
		SysFreeString(WdmOfflineResultClassName);
	}
	
	if (WdmSettingListClassName != NULL)
	{
		SysFreeString(WdmSettingListClassName);
	}
	
		
	if (CdmTestClassName != NULL)
	{
		SysFreeString(CdmTestClassName);
	}
	
	if (CdmTestRelPath != NULL)
	{
		SysFreeString(CdmTestRelPath);
	}
	
		
	if (CdmResultClassName != NULL)
	{
		SysFreeString(CdmResultClassName);
	}
	
	if (CdmSettingClassName != NULL)
	{
		SysFreeString(CdmSettingClassName);
	}
		
		
	if (CdmTestForMSEClassName != NULL)
	{
		SysFreeString(CdmTestForMSEClassName);
	}
		
	FreeTheBSTRArray(CdmTestForMSERelPath, RelPathCount);
		
	if (CdmSettingForTestClassName != NULL)
	{
		SysFreeString(CdmSettingForTestClassName);
	}
	
	if (CdmSettingForTestRelPath != NULL)
	{
		for (i = 0; i < RelPathCount; i++)
		{
			delete CdmSettingForTestRelPath[i];
		}
		WmipFree(CdmSettingForTestRelPath);
	}
	
		
	if (CdmResultForMSEClassName != NULL)
	{
		SysFreeString(CdmResultForMSEClassName);
	}
	

	if (CdmResultForTestClassName != NULL)
	{
		SysFreeString(CdmResultForTestClassName);
	}
	
	if (CdmTestForSoftwareClassName != NULL)
	{
		SysFreeString(CdmTestForSoftwareClassName);
	}
	
	if (CdmTestForSoftwareRelPath != NULL)
	{
		SysFreeString(CdmTestForSoftwareRelPath);
	}
	
	
	if (CdmTestInPackageClassName != NULL)
	{
		SysFreeString(CdmTestInPackageClassName);
	}
	
	if (CdmTestInPackageRelPath != NULL)
	{
		SysFreeString(CdmTestInPackageRelPath);
	}
	
		
	if (CdmResultInPackageClassName != NULL)
	{
		SysFreeString(CdmResultInPackageClassName);
	}
	
	if (CdmResultInPackageRelPath != NULL)
	{
		SysFreeString(CdmResultInPackageRelPath);
	}
	

	if (CimClassMappingClassName != NULL)
	{
		SysFreeString(CimClassMappingClassName);
	}
	
	FreeTheBSTRArray(CimRelPaths, RelPathCount);
	FreeTheBSTRArray(WdmRelPaths, RelPathCount);
	FreeTheBSTRArray(WdmInstanceNames, RelPathCount);
	FreeTheBSTRArray(PnPDeviceIdsX, RelPathCount);
		
	if (CdmSettingsList != NULL)
	{
		for (i = 0; i < RelPathCount; i++)
		{
			delete CdmSettingsList[i];
		}
		WmipFree(CdmSettingsList);
	}

	if (CdmResultsList != NULL)
	{
		for (i = 0; i < RelPathCount; i++)
		{
			delete &CdmResultsList[i];
		}
	}
}

BOOLEAN ClassIsCdmBaseClass(
    BSTR ClassName,
	BOOLEAN *IsTestClass
	)
/*+++

Routine Description:

	This routine determines if the class name is a CDM base class name

Arguments:

	ClassName is the name of the class
	
	*IsTestClass returns TRUE if the class name is CIM_DiagnosticTest

Return Value:

	TRUE if class is a CDM base class else FALSE
	
---*/
{
	WmipAssert(ClassName != NULL);
	WmipAssert(IsTestClass != NULL);
	
	if (_wcsicmp(ClassName, L"CIM_DiagnosticTest") == 0)
	{
		*IsTestClass = TRUE;
		return(TRUE);
	}

	if ((_wcsicmp(ClassName, L"CIM_DiagnosticResult") == 0) ||
        (_wcsicmp(ClassName, L"CIM_DiagnosticSetting") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticResultForMSE") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticResultForTest") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticTestForMSE") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticTestSoftware") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticTestInPackage") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticResultInPackage") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticResultForMSE") == 0) ||
		(_wcsicmp(ClassName, L"CIM_DiagnosticSettingForTest") == 0))
	{
		*IsTestClass = FALSE;
		return(TRUE);
	}
	return(FALSE);			
}

HRESULT CTestServices::GetCdmClassNamesFromOne(
    PWCHAR CdmClass
    )
/*+++
Routine Description:

	This routine obtains the names of all of the CDM classes from the
	name of a single CDM class

Arguments:

	CdmClass is the name of the CDM class
	
Return Value:

	HRESULT
	
---*/
{
	IWbemServices * pCdmServices = GetCdmServices();
	VARIANT v, vClass, vSuper;
	HRESULT hr, hrDontCare;
	BOOLEAN IsTestClass;
	BSTR SuperClass;
	BSTR CdmTestClass;
	
	//
	// First thing is that we need to do is figure out what kind of
	// class we have been handed. If it is a CIM_DiagnosticTest derived
	// class then we can proceed to obtain all of the other class names
	// via qualifiers. If not then we have to link back from the class
	// we have to the CIM_DiagnosticTest derived class via the
	// CdmDiagTest qualifier.
	//

	//
	// Get a class object for Cdm class passed and then check the
	// __SUPERCLASS property to see which CDM class it is derived from.
	//
	SuperClass = SysAllocString(CdmClass);

	if (SuperClass == NULL)
	{
		return(WBEM_E_OUT_OF_MEMORY);
	}

	v.vt = VT_BSTR;
	v.bstrVal = SuperClass;
	
	do
	{
		hr = WmiGetPropertyByName(pCdmServices,
								  v.bstrVal,
								  L"__SuperClass",
								  CIM_STRING,
								  &vSuper);
		
		if (hr == WBEM_S_NO_ERROR)
		{
#ifdef VERBOSE_DEBUG			
			WmipDebugPrint(("CDMPROV: Class %ws has superclass of %ws\n",
							SuperClass, vSuper.bstrVal));
#endif			
				
			if (_wcsicmp(v.bstrVal, vSuper.bstrVal) == 0)
			{
				//
				// When the superclass is the same as the base
				// class then we are at the top of the class tree
				// and so this class must not be in the CDM
				// heirarchy. In this case the cdm provider cannot
				// support it.
				//
				hr = WBEM_E_NOT_FOUND;
				VariantClear(&vSuper);
			} else if (ClassIsCdmBaseClass(vSuper.bstrVal, &IsTestClass)) {
				//
				// We have found a CDM base class
				//
				if (! IsTestClass)
				{
					//
					// The CDM base class was not the test class so
					// lookup the CdmDiagTest qualifier to find it
					//
					PWCHAR Name = L"CdmDiagTest";
					VARTYPE VarType = VT_BSTR;
					
					hr = WmiGetQualifierListByName(pCdmServices,
											       CdmClass,
						                           NULL,
												   1,
    											   &Name,
											       &VarType,
											       &vClass);
					if (hr == WBEM_S_NO_ERROR)
					{
						CdmTestClass = vClass.bstrVal;
#ifdef VERBOSE_DEBUG			
						WmipDebugPrint(("CDMPROV: Class %ws has a CdmDiagTestClass %ws\n",
										CdmClass, CdmTestClass));
#endif						
					}
				} else {
					CdmTestClass = SysAllocString(CdmClass);
					if (CdmTestClass == NULL)
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
#ifdef VERBOSE_DEBUG			
					WmipDebugPrint(("CDMPROV: Class %ws is already CdmDiagTestClass\n",
									CdmClass));
#endif					
				}
				VariantClear(&vSuper);
			} else {
				//
				// This is a more basic class, but is not the CDM base
				// class, so we need to continue up the derivation
				// chain
				//
			}
		}
		
		VariantClear(&v);
		v = vSuper;
		
	} while ((CdmTestClass == NULL) && (hr == WBEM_S_NO_ERROR));

	if (hr == WBEM_S_NO_ERROR)
	{
		PWCHAR Names[11];
		VARTYPE VarType[11];
		VARIANT Values[11];
		
		//
		// Now that we know the CDM Diagnostic test class name we can
		// go and discover the rest of the CDM class names via
		// the appropriate qualifiers on the Cdm Test class.
		//
		Names[0] = L"CimClassMapping";
		VarType[0] = VT_BSTR;
		VariantInit(&Values[0]);
		
		Names[1] = L"CdmDiagResult";
		VarType[1] = VT_BSTR;
		VariantInit(&Values[1]);
		
		Names[2] = L"CdmDiagSetting";
		VarType[2] = VT_BSTR;
		VariantInit(&Values[2]);
		
		Names[3] = L"CdmDiagTestForMSE";
		VarType[3] = VT_BSTR;
		VariantInit(&Values[3]);
		
		Names[4] = L"CdmDiagResultForMSE";
		VarType[4] = VT_BSTR;
		VariantInit(&Values[4]);
		
		Names[5] = L"CdmDiagResultForTest";
		VarType[5] = VT_BSTR;
		VariantInit(&Values[5]);
		
		Names[6] = L"CdmDiagTestSoftware";
		VarType[6] = VT_BSTR;
		VariantInit(&Values[6]);
		
		Names[7] = L"CdmDiagTestInPackage";
		VarType[7] = VT_BSTR;
		VariantInit(&Values[7]);
		
		Names[8] = L"CdmDiagResultInPackage";
		VarType[8] = VT_BSTR;
		VariantInit(&Values[8]);
		
		Names[9] = L"CdmDiagSettingForTest";
		VarType[9] = VT_BSTR;
		VariantInit(&Values[9]);
		
		Names[10] = L"WdmDiagTest";
		VarType[10] = VT_BSTR;		
		VariantInit(&Values[10]);
	
		hr = WmiGetQualifierListByName(pCdmServices,
									   CdmTestClass,
									   NULL,
									   11,
									   Names,
									   VarType,
									   Values);
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Remember the class names
			//
			CimClassMappingClassName = Values[0].bstrVal;
			
			CdmResultClassName = Values[1].bstrVal;
			CdmSettingClassName = Values[2].bstrVal;
			CdmTestForMSEClassName = Values[3].bstrVal;
			CdmResultForMSEClassName = Values[4].bstrVal;
			CdmResultForTestClassName = Values[5].bstrVal;
			CdmTestForSoftwareClassName = Values[6].bstrVal;
			CdmTestInPackageClassName = Values[7].bstrVal;
			CdmResultInPackageClassName = Values[8].bstrVal;
			CdmSettingForTestClassName = Values[9].bstrVal;

			WdmTestClassName = Values[10].bstrVal;
			
			//
			// Now that we have got all of the Cdm class names we need
			// to get the WdmDiagResult, WdmDiagSetting and
			// WdmDiagSettingList classes
			//
			Names[0] = L"WdmDiagResult";
			VariantInit(&Values[0]);
			hr = WmiGetQualifierListByName(pCdmServices,
										   CdmResultClassName,
										   NULL,
											 1,
											 Names,
											 VarType,
											 Values);
			if (hr == WBEM_S_NO_ERROR)
			{
				WdmResultClassName = Values[0].bstrVal;


				//
				// See if this is an offline diagnostic class
				//
				Names[0] = L"WdmDiagOfflineResult";
				VariantInit(&Values[0]);
				hrDontCare = WmiGetQualifierListByName(pCdmServices,
										   CdmResultClassName,
										   NULL,
											 1,
											 Names,
											 VarType,
											 Values);
				if (hrDontCare == WBEM_S_NO_ERROR)
				{
					WdmOfflineResultClassName = Values[0].bstrVal;
				}

				
				Names[0] = L"WdmDiagSetting";
				VariantInit(&Values[0]);
				hr = WmiGetQualifierListByName(pCdmServices,
											 CdmSettingClassName,
											   NULL,
											 1,
											 Names,
											 VarType,
											 Values);
				if (hr == WBEM_S_NO_ERROR)
				{
					WdmSettingClassName = Values[0].bstrVal;

					Names[0] = L"WdmDiagSettingList";
					VariantInit(&Values[0]);
					hr = WmiGetQualifierListByName(pCdmServices,
												 CdmSettingClassName,
												 NULL,
												 1,
												 Names,
												 VarType,
												 Values);
					if (hr == WBEM_S_NO_ERROR)
					{
						//
						// Whew, we got all of our class names
						// successfully. Setup the CdmTestClassName which
						// denotes that we are all setup properly
						//
						WdmSettingListClassName = Values[0].bstrVal;

						CdmTestClassName = CdmTestClass;
					}
				}
			}
		}		
	}

	return(hr);
}

HRESULT CTestServices::BuildResultRelPaths(
    IN int RelPathIndex,
    IN BSTR ExecutionId,
    OUT BSTR *ResultRelPath,
    OUT BSTR *ResultForMSERelPath,
    OUT BSTR *ResultForTestRelPath
    )
/*+++
Routine Description:

	This routine will create the string names for the CDM Result
	relative paths for a specific index. These are for the classes

	CIM_DiagnosticResult
	CIM_DiagnosticResultForMSE
	CIM_DiagnosticResultForTest

Arguments:

	RelPathIndex is the index into the list of result objects

	ExecutionId is the unique id used for the execution

	ResultRelPath returns with the result relpath

	ResultForMSERelPath returns with the ResultForMSE association
	    relpath

	ResultForTestRelPath returns with the ResultForTest association
	    relpath

	    
Return Value:

	HRESULT
	
---*/
{
	PWCHAR RelPath;
	HRESULT hr;
	ULONG AllocSize;
	WCHAR s1[2*MAX_PATH];
	WCHAR s2[2*MAX_PATH];

	RelPath = (PWCHAR)WmipAlloc(4096);
	if (RelPath != NULL)
	{
		//
		// Create the relpaths for the result classes and associations
		//
		wsprintfW(RelPath, L"%ws.DiagnosticCreationClassName=\"%ws\",DiagnosticName=\"%ws\",ExecutionID=\"%ws\"",
				  CdmResultClassName,
				  AddSlashesToStringExW(s1, WdmRelPaths[RelPathIndex]),
				  CdmTestClassName,
				  ExecutionId);

		*ResultRelPath = SysAllocString(RelPath);

		if (*ResultRelPath != NULL)
		{
			wsprintfW(RelPath, L"%ws.Result=\"%ws\",SystemElement=\"%ws\"",
						  CdmResultForMSEClassName,
						  AddSlashesToStringExW(s1, *ResultRelPath),
						  AddSlashesToStringExW(s2, CimRelPaths[RelPathIndex]));
			*ResultForMSERelPath = SysAllocString(RelPath);

			wsprintfW(RelPath, L"%ws.DiagnosticResult=\"%ws\",DiagnosticTest=\"%ws\"",
						CdmResultForTestClassName,
						AddSlashesToStringExW(s1, *ResultRelPath),
						AddSlashesToStringExW(s2, CdmTestRelPath));
			*ResultForTestRelPath = SysAllocString(RelPath);


			if ((*ResultForMSERelPath == NULL) ||
				(*ResultForTestRelPath == NULL))
			{
				SysFreeString(*ResultRelPath);

				if (*ResultForMSERelPath != NULL)
				{
					SysFreeString(*ResultForMSERelPath);
				}

				if (*ResultForTestRelPath != NULL)
				{
					SysFreeString(*ResultForTestRelPath);
				}

				hr = WBEM_E_OUT_OF_MEMORY;
			} else {
				hr = WBEM_S_NO_ERROR;
			}
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		WmipFree(RelPath);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	
	return(hr);
}


HRESULT CTestServices::BuildTestRelPaths(
    void
    )
/*+++
Routine Description:

	This routine will create the string names for the CDM Test
	relative paths for all index

	These are for the following classes:

		CIM_DiagnosticTest,
		CIM_DiagnosticTestForMSE

Arguments:

	
Return Value:

	HRESULT
	
---*/
{
	PWCHAR RelPath;
	int i;
	HRESULT hr;
	WCHAR s1[MAX_PATH];
	WCHAR s2[MAX_PATH];
	ULONG AllocSize;

	RelPath = (PWCHAR)WmipAlloc(4096);
	
	if (RelPath != NULL)
	{
		wsprintfW(RelPath, L"%ws.Name=\"%ws\"",
				  CdmTestClassName, CdmTestClassName);
		CdmTestRelPath = SysAllocString(RelPath);
		if (CdmTestRelPath != NULL)
		{
			AllocSize = RelPathCount * sizeof(BSTR);
			CdmTestForMSERelPath = (PWCHAR *)WmipAlloc(AllocSize);
			if (CdmTestForMSERelPath != NULL)
			{
				memset(CdmTestForMSERelPath, 0, AllocSize);

				hr = WBEM_S_NO_ERROR;
				for (i = 0; (i < RelPathCount) && (hr == WBEM_S_NO_ERROR); i++)
				{
					wsprintfW(RelPath, L"%ws.Antecedent=\"%ws\",Dependent=\"%ws\"",
						  CdmTestForMSEClassName,
						  AddSlashesToStringExW(s1, CimRelPaths[i]),
						  AddSlashesToStringExW(s2, CdmTestRelPath));
					CdmTestForMSERelPath[i] = SysAllocString(RelPath);
					if (CdmTestForMSERelPath[i] == NULL)
					{
						SysFreeString(CdmTestRelPath);
						CdmTestRelPath = NULL;
						
						FreeTheBSTRArray(CdmTestForMSERelPath, RelPathCount);
						CdmTestForMSERelPath = NULL;
						
						hr = WBEM_E_OUT_OF_MEMORY;					
					}
				}
			} else {
				SysFreeString(CdmTestRelPath);
				CdmTestRelPath = NULL;
				
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;			
		}
		
		WmipFree(RelPath);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	
	return(hr);
}

HRESULT CTestServices::BuildSettingForTestRelPath(
    OUT BSTR *RelPath,
	IN IWbemClassObject *pCdmSettingInstance
)
{
	WCHAR *Buffer;
	VARIANT v;
	WCHAR s[MAX_PATH];
	HRESULT hr;

	WmipAssert(RelPath != NULL);
	WmipAssert(pCdmSettingInstance != NULL);
	
	WmipAssert(IsThisInitialized());
	
	Buffer = (WCHAR *)WmipAlloc(4096);
	if (Buffer != NULL)
	{
		hr = WmiGetProperty(pCdmSettingInstance,
							L"__RELPATH",
							CIM_REFERENCE,
							&v);
		
		if (hr == WBEM_S_NO_ERROR)
		{
			wsprintfW(Buffer, L"%ws.Element=\"%ws.Name=\\\"%ws\\\"\",Setting=\"%ws\"",
					  CdmSettingForTestClassName,
					  CdmTestClassName,
					  CdmTestClassName,
					  AddSlashesToStringExW(s, v.bstrVal));
			VariantClear(&v);
			
			*RelPath = SysAllocString(Buffer);
			if (*RelPath != NULL)
			{
				hr = WBEM_S_NO_ERROR;
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}					  
		}
		
		WmipFree(Buffer);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}
	


HRESULT CTestServices::ParseSettingList(
    VARIANT *SettingList,
    CWbemObjectList *CdmSettings,
    CBstrArray *CdmSettingForTestRelPath,
    int RelPathIndex
	)
/*+++
Routine Description:

	This routine will obtain all of the settings for a particular test
	and store them into a settings list object

Arguments:

	SettingList points at a variant continaing an array of embedded
		WDM setting objects		

	CdmSettings points at a WbemObjectList class

	CdmSettingForTestRelPath has the relpaths for the cdm settings for
		test classes

	RelPathIndex is the relpath index associated with the settings
	
Return Value:

	HRESULT
	
---*/
{
	HRESULT hr;
	IWbemClassObject *pWdmSettingInstance;
	IWbemClassObject *pCdmSettingInstance;
	LONG Index, UBound, LBound, NumberElements;
	LONG i;
	IUnknown *punk;
	BSTR s;
	WCHAR SettingId[MAX_PATH];
	VARIANT v;

	WmipAssert(SettingList != NULL);
	WmipAssert(CdmSettingForTestRelPath != NULL);
	WmipAssert(SettingList->vt == (CIM_OBJECT | CIM_FLAG_ARRAY));
	WmipAssert(CdmSettings != NULL);
	
	hr = WmiGetArraySize(SettingList->parray,
						 &LBound,
						 &UBound,
						 &NumberElements);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = CdmSettingForTestRelPath->Initialize(NumberElements);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = CdmSettings->Initialize(NumberElements);

			for (i = 0, Index = LBound;
				 (i < NumberElements) && (hr == WBEM_S_NO_ERROR);
				 i++, Index++)
			{
				hr = SafeArrayGetElement(SettingList->parray,
										 &Index,
										 &punk);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = punk->QueryInterface(IID_IWbemClassObject,
											  (PVOID *)&pWdmSettingInstance);
					if (hr == WBEM_S_NO_ERROR)
					{
						hr = CreateInst(GetCdmServices(),
										&pCdmSettingInstance,
										CdmSettingClassName,
										NULL);
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = CopyBetweenCdmAndWdmClasses(pCdmSettingInstance,
															 pWdmSettingInstance,
															 TRUE);
							if (hr == WBEM_S_NO_ERROR)
							{
								//
								// Set CdmSetting.SettingId to a unique
								// setting id
								//
								wsprintfW(SettingId, L"%ws_%d_%d",
										  CdmTestClassName,
										  RelPathIndex,
										  i);
								s = SysAllocString(SettingId);
								if (s != NULL)
								{
									VariantInit(&v);
									v.vt = VT_BSTR;
									v.bstrVal = s;
									hr = WmiSetProperty(pCdmSettingInstance,
														L"SettingId",
														&v);
									VariantClear(&v);

									if (hr == WBEM_S_NO_ERROR)
									{
										hr = BuildSettingForTestRelPath(&s,
																		pCdmSettingInstance);

										if (hr == WBEM_S_NO_ERROR)
										{
											CdmSettingForTestRelPath->Set(i,
																		  s);

											CdmSettings->Set(i,
													pCdmSettingInstance,
													TRUE);
										}
									}
								} else {
									hr = WBEM_E_OUT_OF_MEMORY;
								}
							}

							if (hr != WBEM_S_NO_ERROR)
							{
								pCdmSettingInstance->Release();
							}
						}

						pWdmSettingInstance->Release();
					}
					punk->Release();
				}
			}
		}
	}
	
	return(hr);
}

HRESULT CTestServices::GetCdmTestSettings(
    void
    )
/*+++
Routine Description:

	This routine will obtain all of the CDM settings available for all
	instnaces of the test

Arguments:
	
Return Value:

	HRESULT
	
---*/
{
	WCHAR Query[MAX_PATH * 2];
	WCHAR s[MAX_PATH];
	ULONG AllocSize;
	BSTR sWQL, sQuery;
	IEnumWbemClassObject *pWdmEnumInstances;
	IWbemClassObject *pWdmInstance;
	int i;
	ULONG Count;
	HRESULT hr;
	VARIANT SettingList;
	
	//
	// We need to get all of the settings exposed by the WDM class and
	// then convert them to Cdm classes.
	//

	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		AllocSize = RelPathCount * sizeof(CWbemObjectList *);

		CdmSettingsList = (CWbemObjectList **)WmipAlloc(AllocSize);
		if (CdmSettingsList != NULL)
		{
			memset(CdmSettingsList, 0, AllocSize);
			
			AllocSize = RelPathCount * sizeof(CBstrArray *);
			CdmSettingForTestRelPath = (CBstrArray **)WmipAlloc(AllocSize);
			if (CdmSettingForTestRelPath != NULL)
			{
				memset(CdmSettingForTestRelPath, 0, AllocSize);
				
				hr = WBEM_S_NO_ERROR;
				for (i = 0; (i < RelPathCount) && (hr == WBEM_S_NO_ERROR); i++)
				{
					CdmSettingsList[i] = new CWbemObjectList();
					CdmSettingForTestRelPath[i] = new CBstrArray;
					
					wsprintfW(Query, L"select * from %ws where InstanceName = \"%ws\"",
							  WdmSettingListClassName,
							  AddSlashesToStringW(s, WdmInstanceNames[i]));
					sQuery = SysAllocString(Query);
					if (sQuery != NULL)
					{
						hr = pWdmServices->ExecQuery(sWQL,
												sQuery,
												WBEM_FLAG_FORWARD_ONLY |
												WBEM_FLAG_ENSURE_LOCATABLE,
												NULL,
												&pWdmEnumInstances);

						if (hr == WBEM_S_NO_ERROR)
						{
							hr = pWdmEnumInstances->Next(WBEM_INFINITE,
														  1,
														  &pWdmInstance,
														  &Count);
							if ((hr == WBEM_S_NO_ERROR) &&
								(Count == 1))
							{
								hr = WmiGetProperty(pWdmInstance,
													L"SettingList",
													CIM_FLAG_ARRAY | CIM_OBJECT,
													&SettingList);

								if (hr == WBEM_S_NO_ERROR)
								{
									if (SettingList.vt & VT_ARRAY)
									{
										hr = ParseSettingList(&SettingList,
															 CdmSettingsList[i],
															 CdmSettingForTestRelPath[i],
															 i);
									} else {
										hr = WBEM_E_FAILED;
									}
									VariantClear(&SettingList);
								}
								pWdmInstance->Release();
							}

							pWdmEnumInstances->Release();
						} else {
							//
							// There must not be any predefined settings
							//
							hr = CdmSettingsList[i]->Initialize(0);						
						}

						SysFreeString(sQuery);
					} else {
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
			} else {
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		SysFreeString(sWQL);
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return(hr);
}

HRESULT CTestServices::InitializeCdmClasses(
    PWCHAR CdmClass
    )
/*+++
Routine Description:

	This routine will setup this class and initialize everything so
	that the provider can interact with the CDM and WDM classes

Arguments:

	CdmClass is the name of the CDM class
	
Return Value:

	HRESULT
	
---*/
{
    HRESULT hr, hrDontCare;
	ULONG AllocSize;
	int i;
	
    WmipAssert(CdmClass != NULL);

	WmipAssert(! IsThisInitialized());

	//
	// We assume that this method will always be the first one called
	// by the class provider
	//
    if ((pCimServices == NULL) &&
        (pWdmServices == NULL))
    {
        hr = TestInfoInitialize();
        if (hr != WBEM_S_NO_ERROR)
        {
            return(hr);
        }
    }

	//
	// We are given a random CDM class name - it could be a test,
	// setting, association, etc so we need to go from that class name
	// and obtain all of the class names related to this diagnostic
	//
	hr = GetCdmClassNamesFromOne(CdmClass);

	
	if (hr == WBEM_S_NO_ERROR)
	{
		//
		// Use worker function to determine which
		// Wdm relpaths map to which Cdm relpaths
		//
		hr = MapWdmClassToCimClass(pWdmServices,
								   pCimServices,
								   WdmTestClassName,
								   CimClassMappingClassName,
								   &PnPDeviceIdsX,
								   &WdmInstanceNames,
								   &WdmRelPaths,
								   &CimRelPaths,
								   &RelPathCount);
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Obtain all of the possible settings for this test
			//
			hr = GetCdmTestSettings();
			if (hr == WBEM_S_NO_ERROR)
			{
				//
				// Initialize the results object lists
				//
				CdmResultsList = new CResultList[RelPathCount];
				
				//
				// Build the test class instance relpaths
				//
				hr = BuildTestRelPaths();
				
// @@BEGIN_DDKSPLIT
#ifdef REBOOT_DIAGNOSTICS						
				if (hr == WBEM_S_NO_ERROR)
				{
					hrDontCare = GatherRebootResults();
				}
#else
				//
				// Reboot diagnostics are not yet supported
				//
#endif
// @@END_DDKSPLIT
				
			}
		}
	}
          
    return(hr);
}


IWbemServices *CTestServices::GetWdmServices(
    void
    )
/*+++
Routine Description:

	Accessor for the WDM namespace IWbemServices

Arguments:


Return Value:

	IWbemServices
	
---*/
{
	WmipAssert(pWdmServices != NULL);
    return(pWdmServices);
}

IWbemServices *CTestServices::GetCdmServices(
    void
    )
/*+++
Routine Description:

	Accessor for the CIM namespace IWbemServices

Arguments:


Return Value:

	IWbemServices
	
---*/
{
	WmipAssert(pCimServices != NULL);
	
    return(pCimServices);
}

HRESULT CTestServices::WdmPropertyToCdmProperty(
    IN IWbemClassObject *pCdmClassInstance,
    IN IWbemClassObject *pWdmClassInstance,
    IN BSTR PropertyName,
    IN OUT VARIANT *PropertyValue,
    IN CIMTYPE CdmCimType,
    IN CIMTYPE WdmCimType
    )
/*+++
Routine Description:

	This routine will convert a property in a Wdm class into the form
	required for the property in the Cdm class.

Arguments:

	pCdmClassInstance is the instnace of the Cdm class that will get
		the property value

	pWdmClassInstance is the instance of the Wdm class that has the
		property value

	PropertyName is the name of the property in the Wdm and Cdm classes

	PropertyValue on entry has the value of the property in the Wdm
		instance and on return has the value to set in the Cdm instance

	CdmCimType is the property type for the property in the Cdm
		instance
	
	WdmCimType is the property type for the property in the Wdm
		instance
	
Return Value:

    HRESULT
	
---*/
{
	HRESULT hr;
	BSTR Mapped;
	VARIANT vClassName;
	CIMTYPE BaseWdmCimType, BaseCdmCimType;
	CIMTYPE WdmCimArray, CdmCimArray;
	LONG i;

	WmipAssert(pCdmClassInstance != NULL);
	WmipAssert(pWdmClassInstance != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(PropertyValue != NULL);
	
	WmipAssert(IsThisInitialized());
	
    //
    // Rules for converting Wdm Classes into Cdm Classes
    //  Wdm Class Type      Cdm Class Type     Conversion Done
    //    enumeration          string           Build string from enum
    //
	BaseWdmCimType = WdmCimType & ~CIM_FLAG_ARRAY;
	BaseCdmCimType = CdmCimType & ~CIM_FLAG_ARRAY;
	WdmCimArray = WdmCimType & CIM_FLAG_ARRAY;
	CdmCimArray = CdmCimType & CIM_FLAG_ARRAY;
	
	if (((BaseWdmCimType == CIM_UINT32) ||
		 (BaseWdmCimType == CIM_UINT16) ||
		 (BaseWdmCimType == CIM_UINT8)) &&
		(BaseCdmCimType == CIM_STRING) &&
	    (WdmCimArray == CdmCimArray) &&
	    (PropertyValue->vt != VT_NULL))
	{		
		hr = WmiGetProperty(pWdmClassInstance,
							L"__Class",
							CIM_STRING,
							&vClassName);

		if (hr == WBEM_S_NO_ERROR)
		{
			if (WdmCimArray)
			{
				SAFEARRAYBOUND Bounds;
				SAFEARRAY *Array;
				ULONG Value;
				LONG UBound, LBound, Elements, Index;

				//
				// We have an array of enumeration types to convert into an
				// array of corresponding strings
				//
				hr = WmiGetArraySize(PropertyValue->parray,
										 &LBound,
										 &UBound,
										 &Elements);
				if (hr == WBEM_S_NO_ERROR)
				{
					Bounds.lLbound = LBound;
					Bounds.cElements = Elements;
					Array = SafeArrayCreate(VT_BSTR,
											1,
											&Bounds);
					if (Array != NULL)
					{
						for (i = 0;
							 (i < Elements) && (hr == WBEM_S_NO_ERROR);
							 i++)
						{

							Index = i + LBound;
							hr = SafeArrayGetElement(PropertyValue->parray,
													 &Index,
													 &Value);
							if (hr == WBEM_S_NO_ERROR)
							{
								hr = LookupValueMap(GetWdmServices(),
										vClassName.bstrVal,
										PropertyName,
										Value,
										&Mapped);
								if (hr == WBEM_S_NO_ERROR)
								{
									hr = SafeArrayPutElement(Array,
										                     &Index,
										                     Mapped);
										                     
								}
								
							}
						}
							 
						if (hr == WBEM_S_NO_ERROR)
						{
							VariantClear(PropertyValue);
							PropertyValue->vt = VT_BSTR | VT_ARRAY;
							PropertyValue->parray = Array;							
						} else {
							SafeArrayDestroy(Array);
						}
					} else {
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}

			} else {

				//
				// We need to convert a scalar enumeration type into the
				// corresponding string. First we need to get the Wdm class
				// object and from that get the Values and ValueMap qualifiers
				// to determine the string we need to place into the cim class
				//
				hr = LookupValueMap(GetWdmServices(),
										vClassName.bstrVal,
										PropertyName,
										PropertyValue->uiVal,
										&Mapped);


				if (hr == WBEM_S_NO_ERROR)
				{
					VariantClear(PropertyValue);
					PropertyValue->vt = VT_BSTR;
					PropertyValue->bstrVal = Mapped;
				}			
			}
			VariantClear(&vClassName);			
		}
		
	} else {
		//
		// No conversion needs to occur
		//
		hr = WBEM_S_NO_ERROR;
	}
    
    return(hr);
}

HRESULT CTestServices::CdmPropertyToWdmProperty(
    IN IWbemClassObject *pWdmClassInstance,
    IN IWbemClassObject *pCdmClassInstance,
    IN BSTR PropertyName,
    IN OUT VARIANT *PropertyValue,
    IN CIMTYPE WdmCimType,
    IN CIMTYPE CdmCimType
    )
/*+++
Routine Description:

	This routine will convert a property in a Cdm class into the form
	required for the property in the Wdm class.

Arguments:

	pWdmClassInstance is the instance of the Wdm class that has the
		property value

	pCdmClassInstance is the instnace of the Cdm class that will get
		the property value

	PropertyName is the name of the property in the Wdm and Cdm classes

	PropertyValue on entry has the value of the property in the Wdm
		instance and on return has the value to set in the Cdm instance

	WdmCimType is the property type for the property in the Wdm
		instance
		
	CdmCimType is the property type for the property in the Cdm
		instance	
	
Return Value:

    HRESULT
	
---*/
{

	WmipAssert(pCdmClassInstance != NULL);
	WmipAssert(pWdmClassInstance != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(PropertyValue != NULL);

	
	WmipAssert(IsThisInitialized());
	
    //
    // Rules for converting Wdm Classes into Cdm Classes
    //  Wdm Class Type      Cdm Class Type     Conversion Done
    //


	//
	// There are no conversion requirements when converting from Cdm to
	// Wdm instances
	//
    return(WBEM_S_NO_ERROR);
}

HRESULT CTestServices::CopyBetweenCdmAndWdmClasses(
    IN IWbemClassObject *pDestinationInstance,
    IN IWbemClassObject *pSourceInstance,
    IN BOOLEAN WdmToCdm
    )
/*+++
Routine Description:

	This routine will do the work to copy and convert all properties in
	an instance of a Wdm or Cdm class to an instance of a Cdm or Wdm
	class.

	Note that properties from one instance are only copied to
	properties of another instance when the property names are
	identical. No assumption is ever made on the name of the
	properties. The only info used to determine how to convert a
	property is based upon the source and destination cim type.

Arguments:

	pDestinationInstance is the class instance that the properties will
	be copied into

	pSourceInstance is the class instance that the properties will be
	copied from

	WdmToCdm is TRUE if copying from Wdm to Cdm, else FALSE
	
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;
    VARIANT PropertyValue;
    BSTR PropertyName;
    CIMTYPE SourceCimType, DestCimType;
    HRESULT hrDontCare;

	WmipAssert(pDestinationInstance != NULL);
	WmipAssert(pSourceInstance != NULL);	
	
	WmipAssert(IsThisInitialized());
	
    //
    // Now we need to move over all of the properties from the source
    // class into the destination class. Note that some properties need
    // some special effort such as OtherCharacteristics which needs
    // to be converted from an enumeration value (in wdm) to a
    // string (in CDM).
    //
    // Our strategy is to enumerate all of the proeprties in the
    // source class and then look for a property with the same name
    // and type in the destination class. If so we just copy over the
    // value. If the data type is different we need to do some
    // conversion.
    //

					
	
    hr = pSourceInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    if (hr == WBEM_S_NO_ERROR)
    {
        do
        {
			//
			// Get a property from the source class
			//
            hr = pSourceInstance->Next(0,
                                 &PropertyName,
                                 &PropertyValue,
                                 &SourceCimType,
                                 NULL);
			
            if (hr == WBEM_S_NO_ERROR)
            {
				//
				// Try to get a property with the same name from the
				// dest class. If the identically named property does
				// not exist in the destination class then it is ignored
				//
				hrDontCare = pDestinationInstance->Get(PropertyName,
											0,
											NULL,
											&DestCimType,
											NULL);
									
				if (hrDontCare == WBEM_S_NO_ERROR)
				{
					
					if (WdmToCdm)
					{
						hr = WdmPropertyToCdmProperty(pDestinationInstance,
													  pSourceInstance,
													  PropertyName,
													  &PropertyValue,
							                          DestCimType,
												      SourceCimType);
					} else {                    
						hr = CdmPropertyToWdmProperty(pDestinationInstance,
													  pSourceInstance,
													  PropertyName,
													  &PropertyValue,
							                          DestCimType,
												      SourceCimType);
					}

					if (hr == WBEM_S_NO_ERROR)
					{
						//
						// Try to place the transformed property into the
						// destination class.
						//
						hr = pDestinationInstance->Put(PropertyName,
												  0,
												  &PropertyValue,
												  0);                       
					}
				}
                    
                SysFreeString(PropertyName);
                VariantClear(&PropertyValue);
				
            } else if (hr == WBEM_S_NO_MORE_DATA) {
                //
                // This signifies the end of the enumerations
                //
                hr = WBEM_S_NO_ERROR;
                break;
            }
        } while (hr == WBEM_S_NO_ERROR);

        pSourceInstance->EndEnumeration();

    }
    return(hr);
}

HRESULT CTestServices::QueryWdmTest(
    OUT IWbemClassObject *pCdmTest,
    IN int RelPathIndex
    )
/*+++
Routine Description:

	This routine will query the Wdm test class instance and copy the results
	into the Cdm Test class instance

Arguments:

	pCdmTest points at the Cdm Test class instance

	RelPathIndex
	
Return Value:

    HRESULT
	
---*/
{
    IWbemClassObject *pWdmTest;
    HRESULT hr;

	WmipAssert(pCdmTest != NULL);
	
	WmipAssert(IsThisInitialized());
	
    hr = ConnectToWdmClass(RelPathIndex,
                           &pWdmTest);

    if (hr == WBEM_S_NO_ERROR)
    {
        hr = CopyBetweenCdmAndWdmClasses(pCdmTest,
                                         pWdmTest,
                                         TRUE);
        pWdmTest->Release();
    }

    return(hr);
}

#define OBJECTCOLONSIZE (((sizeof(L"object:")/sizeof(WCHAR)))-1)

HRESULT CTestServices::FillTestInParams(
    OUT IWbemClassObject *pInParamInstance,
    IN IWbemClassObject *pCdmSettings,
    IN BSTR ExecutionID
    )
{
	HRESULT hr;
	IWbemServices *pWdmServices;
	VARIANT v;
	VARIANT PropertyValues[2];
	PWCHAR PropertyNames[2];
	PWCHAR ClassName;	
	IWbemClassObject *pRunTestIn;
	IWbemClassObject *pWdmSettingsInstance;
	IWbemQualifierSet *pQualSet;

	WmipAssert(pInParamInstance != NULL);

	pWdmServices = GetWdmServices();

	pRunTestIn = NULL;
	
	//
	// Get the name of the embedded class for the RunTestIn input
	// parameter. This should be an embedded class that contains all of
	// the input parameters. We get this from the __CIMTYPE qualifier
	// on the RunTestIn property.
	//
	// We need to do this since the wmiprov can't
	// handle anything with an embedded object as an input parameter to
	// a method
	//
	hr = pInParamInstance->GetPropertyQualifierSet(L"RunTestIn",
												   &pQualSet);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = WmiGetQualifier(pQualSet,
							 L"CIMTYPE",
							 VT_BSTR,
							 &v);
		if (hr == WBEM_S_NO_ERROR)
		{
			if (_wcsnicmp(v.bstrVal, L"object:", OBJECTCOLONSIZE) == 0)
			{
				ClassName = v.bstrVal + OBJECTCOLONSIZE;
				hr = CreateInst(pWdmServices,
								&pRunTestIn,
								ClassName,
								NULL);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = CreateInst(pWdmServices,
									&pWdmSettingsInstance,
									WdmSettingClassName,
									NULL);

					if (hr == WBEM_S_NO_ERROR)
					{						
						if (pCdmSettings != NULL)
						{
							hr = CopyBetweenCdmAndWdmClasses(pWdmSettingsInstance,
															 pCdmSettings,
															 FALSE);
						}	

						if (hr == WBEM_S_NO_ERROR)
						{
							PWCHAR PropertyNames[2];
							VARIANT PropertyValues[2];

							PropertyNames[0] = L"DiagSettings";
							PropertyValues[0].vt = VT_UNKNOWN;
							PropertyValues[0].punkVal = pWdmSettingsInstance;
							PropertyNames[1] = L"ExecutionID";
							PropertyValues[1].vt = VT_BSTR;
							PropertyValues[1].bstrVal = ExecutionID;

							hr = WmiSetPropertyList(pRunTestIn,
													2,
													PropertyNames,
													PropertyValues);

							
							if (hr == WBEM_S_NO_ERROR)
							{
								PropertyValues[0].vt = VT_UNKNOWN;
								PropertyValues[0].punkVal = pRunTestIn;
								hr = WmiSetProperty(pInParamInstance,
                                                    L"RunTestIn",
									                &PropertyValues[0]);
									                
							}
						}
						//
						// We can release here since we know that wbem
						// took a ref count when we set the property
						//
						pWdmSettingsInstance->Release();
					}					
				}
			}
			VariantClear(&v);
		}
		pQualSet->Release();
	}

	if ((hr != WBEM_S_NO_ERROR) && (pRunTestIn != NULL))
	{
		pRunTestIn->Release();
	}
	
	return(hr);
}

HRESULT CTestServices::GetTestOutParams(
    IN IWbemClassObject *OutParams,
    OUT IWbemClassObject *pCdmResult,
    OUT ULONG *Result
    )
{

	HRESULT hr;
	VARIANT v;
	IWbemClassObject *pRunTestOut;
	IWbemClassObject *pWdmResult;

	WmipAssert(OutParams != NULL);
	WmipAssert(pCdmResult != NULL);
	WmipAssert(Result != NULL);

	hr = WmiGetProperty(OutParams,
						L"RunTestOut",
						CIM_OBJECT,
						&v);
	if (hr == WBEM_S_NO_ERROR)
	{
		hr = v.punkVal->QueryInterface(IID_IWbemClassObject,
									   (PVOID *)&pRunTestOut);
		VariantClear(&v);

		if (hr == WBEM_S_NO_ERROR)
		{
			hr = WmiGetProperty(pRunTestOut,
								L"Result",
								CIM_UINT32,
								&v);
			if (hr == WBEM_S_NO_ERROR)
			{
				*Result = v.ulVal;
				VariantClear(&v);

				hr = WmiGetProperty(pRunTestOut,
									L"DiagResult",
									CIM_OBJECT,
									&v);
								
				if (hr == WBEM_S_NO_ERROR)
				{
					if (v.vt != VT_NULL)
					{
						hr = v.punkVal->QueryInterface(IID_IWbemClassObject,
							                      (PVOID *)&pWdmResult);
						if (hr == WBEM_S_NO_ERROR)
						{                                   
							hr = CopyBetweenCdmAndWdmClasses(pCdmResult,
															 pWdmResult,
															 TRUE);
							pWdmResult->Release();
						}
					} else {
						hr = WBEM_E_FAILED;
					}
					VariantClear(&v);
				}
			}
			pRunTestOut->Release();
		}		
	}
	return(hr);
}

LONG GlobalExecutionID;

BSTR CTestServices::GetExecutionID(
    void
)
{
	BSTR s;
	WCHAR x[MAX_PATH];

	//
	// We make up a unique execution ID for this test by using the
	// current date and time plus a unique counter. The execution id
	// must be unique.
	//
	s = GetCurrentDateTime();
	if (s != NULL)
	{
		wsprintfW(x, L"%ws*%08x", s, InterlockedIncrement(&GlobalExecutionID));
		SysFreeString(s);
		s = SysAllocString(x);
	}
	return(s);
}

		
HRESULT CTestServices::ExecuteWdmTest(
    IN IWbemClassObject *pCdmSettings,
    OUT IWbemClassObject *pCdmResult,
    IN int RelPathIndex,
    OUT ULONG *Result,
    OUT BSTR *ExecutionID
    )
/*+++
Routine Description:

	This routine will execute a test on the Wdm class instance and copy
	the results back to the Cdm results instance, along with creating
	all result instance relpaths

Arguments:

	pCdmSettings is a CDM settings instance that is used to create the
		wdm settings instance that is used to run the test. This may be
		NULL if default test settings are assumed

	pCdmResult is a CDM result instance that returns with the results
		form the test

	RelPathIndex

	*Result returns with the return value result from the test
	
	*ExecutionId returns with the unique execution id for the test
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;
    IWbemClassObject *pOutParams;
    IWbemClassObject *pInParamInstance;
    BSTR s;

	WmipAssert(pCdmResult != NULL);
	WmipAssert(Result != NULL);
	WmipAssert(ExecutionID != NULL);
	
	WmipAssert(IsThisInitialized());

	//
	// Run in the caller's context so that if he is not able to access
	// the WDM classes, he can't
	//
	hr = CoImpersonateClient();
	if (hr != WBEM_S_NO_ERROR)
	{
		return(hr);
	}

	
    *ExecutionID = GetExecutionID();

	if (*ExecutionID != NULL)
	{
		s = SysAllocString(L"RunTest");
		if (s != NULL)
		{
			hr = GetMethodInParamInstance(GetWdmServices(),
										  WdmTestClassName,
										  s,
										  &pInParamInstance);

			if (hr == WBEM_S_NO_ERROR)
			{
				hr = FillTestInParams(pInParamInstance,
									 pCdmSettings,
									 *ExecutionID);

				if (hr == WBEM_S_NO_ERROR)
				{
					hr = pWdmServices->ExecMethod(WdmRelPaths[RelPathIndex],
														  s,
														  0,
														  NULL,
														  pInParamInstance,
														  &pOutParams,
														  NULL);

					if (hr == WBEM_S_NO_ERROR)
					{

						hr = GetTestOutParams(pOutParams,
											  pCdmResult,
											  Result);
						if (hr == WBEM_S_NO_ERROR)
						{
							//
							// if the test requires the device being
							// taken offline then do that now
							//
							hr = OfflineDeviceForTest(pCdmResult,
								                      *ExecutionID,
													  RelPathIndex);
							
						}
						pOutParams->Release();
					}
				}
				pInParamInstance->Release();
			}
			SysFreeString(s);
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	CoRevertToSelf();
	
    return(hr);
}

HRESULT CTestServices::StopWdmTest(
    IN int RelPathIndex,
    OUT ULONG *Result,
    OUT BOOLEAN *TestingStopped
    )
/*+++
Routine Description:

	This routine will attempt to stop an executing WDM test

Arguments:

	RelPathIndex

	*Result returns with the result value
	
	*TestingStopped returns TRUE if testing was stopped successfully
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;
    IWbemClassObject *OutParams;
    BSTR s;
    IWbemServices *pWdmServices;
    VARIANT Value;

	WmipAssert(Result != NULL);
	WmipAssert(TestingStopped != NULL);
	
	WmipAssert(IsThisInitialized());

	
	//
	// Run in the caller's context so that if he is not able to access
	// the WDM classes, he can't
	//
	hr = CoImpersonateClient();
	if (hr != WBEM_S_NO_ERROR)
	{
		return(hr);
	}

    pWdmServices = GetWdmServices();
    
    s = SysAllocString(L"DiscontinueTest");
    if (s != NULL)
    {
        hr = pWdmServices->ExecMethod(WdmRelPaths[RelPathIndex],
                                         s,
                                         0,
                                         NULL,
                                         NULL,
                                         &OutParams,
                                         NULL);

        if (hr == WBEM_S_NO_ERROR)
        {
            hr = WmiGetProperty(OutParams,
                                L"Result",
                                CIM_UINT32,
                                &Value);
            if (hr == WBEM_S_NO_ERROR)
            {
                *Result = Value.ulVal;
                VariantClear(&Value);
                
                hr = WmiGetProperty(OutParams,
                                    L"TestingStopped",
                                    CIM_BOOLEAN,
                                    &Value);
                if (hr == WBEM_S_NO_ERROR)
                {
                    *TestingStopped = (Value.boolVal != 0) ?  TRUE : FALSE;
                    VariantClear(&Value);
                }
            }
            OutParams->Release();
        }
		SysFreeString(s);
    } else {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

	CoRevertToSelf();
	
    return(hr);
}

HRESULT CTestServices::GetRelPathIndex(
    BSTR CimRelPath,
    int *RelPathIndex
    )
/*+++
Routine Description:

	This routine will return the RelPathIndex for a specific Cim
	Relpath

Arguments:

	CimRelPath is the Cim relpath

	*RelPathIndex returns with the relpath index
	
Return Value:

    HRESULT
	
---*/
{
    int i;

	WmipAssert(CimRelPath != NULL);
	
    WmipAssert(CimRelPaths != NULL);
    WmipAssert(WdmRelPaths != NULL);

	WmipAssert(IsThisInitialized());
	
    for (i = 0; i < RelPathCount; i++)
    {
        if (_wcsicmp(CimRelPath, CimRelPaths[i]) == 0)
        {
            *RelPathIndex = i;
            return(WBEM_S_NO_ERROR);
        }
    }
    
    return(WBEM_E_NOT_FOUND);
}

HRESULT CTestServices::ConnectToWdmClass(
    IN int RelPathIndex,
    OUT IWbemClassObject **ppWdmClassObject
    )
/*+++
Routine Description:

	This routine will return a IWbemClassObject pointer associated
	with the RelPath index

Arguments:

	RelPathIndex

	*ppWdmClassObject returns with an instance for the relpaht
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;

	WmipAssert(ppWdmClassObject != NULL);
	
	WmipAssert(IsThisInitialized());
	
	//
	// Run in the caller's context so that if he is not able to access
	// the WDM classes, he can't
	//
	hr = CoImpersonateClient();
	if (hr == WBEM_S_NO_ERROR)
	{
		*ppWdmClassObject = NULL;        
		hr = GetWdmServices()->GetObject(WdmRelPaths[RelPathIndex],
									  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
									  NULL,
									  ppWdmClassObject,
									  NULL);
		CoRevertToSelf();
	}
	
    return(hr); 
}


HRESULT CTestServices::FillInCdmResult(
    OUT IWbemClassObject *pCdmResult,
    IN IWbemClassObject *pCdmSettings,
    IN int RelPathIndex,
    IN BSTR ExecutionID
    )
/*+++
Routine Description:

	This routine will fill in the various properties needed in a CDM
	result instance

Arguments:

	pCdmResult has its properties set

	pCdmSettings has the settings used to execute the test. This can be
	NULL

	RelPathIndex

	ExecutionID has a unique id used to execute the test
	
Return Value:

    HRESULT
	
---*/
{
	HRESULT hr, hrDontCare;
	WCHAR s[MAX_PATH];
	PWCHAR PropertyNames[12];
	VARIANT PropertyValues[12];
	ULONG PropertyCount;
	BSTR ss;

	WmipAssert(pCdmResult != NULL);
	
	WmipAssert(IsThisInitialized());
	
	PropertyNames[0] = L"DiagnosticCreationClassName";
	PropertyValues[0].vt = VT_BSTR;
	PropertyValues[0].bstrVal = WdmRelPaths[RelPathIndex];

	PropertyNames[1] = L"DiagnosticName";
	PropertyValues[1].vt = VT_BSTR;
	PropertyValues[1].bstrVal = CdmTestClassName;

	PropertyNames[2] = L"ExecutionID";
	PropertyValues[2].vt = VT_BSTR;
	PropertyValues[2].bstrVal = ExecutionID;

	PropertyNames[3] = L"TimeStamp";
	PropertyValues[3].vt = VT_BSTR;
	PropertyValues[3].bstrVal = GetCurrentDateTime();
	
	PropertyNames[4] = L"TestCompletionTime";
	PropertyValues[4].vt = VT_BSTR;
	PropertyValues[4].bstrVal = GetCurrentDateTime();

	PropertyNames[5] = L"IsPackage";
	PropertyValues[5].vt = VT_BOOL;
	PropertyValues[5].boolVal = VARIANT_FALSE;

	//
	// These properties are copied from pCdmSettings
	//
	if (pCdmSettings != NULL)
	{
		PropertyNames[6] = L"TestWarningLevel";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"TestWarningLevel",
									CIM_UINT16,
									&PropertyValues[6]);

		PropertyNames[7] = L"ReportSoftErrors";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"ReportSoftErrors",
									CIM_BOOLEAN,
									&PropertyValues[7]);

		PropertyNames[8] = L"ReportStatusMessages";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"ReportStatusMessages",
									CIM_BOOLEAN,
									&PropertyValues[8]);

		PropertyNames[9] = L"HaltOnError";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"HaltOnError",
									CIM_BOOLEAN,
									&PropertyValues[9]);

		PropertyNames[10] = L"QuickMode";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"QuickMode",
									CIM_BOOLEAN,
									&PropertyValues[10]);

		PropertyNames[11] = L"PercentOfTestCoverage";
		hrDontCare = WmiGetProperty(pCdmSettings,
									L"PercentOfTestCoverage",
									CIM_UINT8,
									&PropertyValues[11]);
		
		PropertyCount = 12;
	} else {
		PropertyCount = 6;
	}			

	hr = WmiSetPropertyList(pCdmResult,
							PropertyCount,
							PropertyNames,
							PropertyValues);

	VariantClear(&PropertyValues[3]);
	VariantClear(&PropertyValues[4]);
	
	return(hr);
}

HRESULT CTestServices::QueryOfflineResult(
    OUT IWbemClassObject *pCdmResult,
    IN BSTR ExecutionID,
    IN int RelPathIndex
    )
{
	WCHAR Query[MAX_PATH * 2];
	WCHAR s[MAX_PATH];
	BSTR sWQL, sQuery;
	IEnumWbemClassObject *pWdmEnumInstances;
	IWbemClassObject *pWdmResult, *pWdmInstance;
	ULONG Count;
	HRESULT hr;
	VARIANT vResult;
	
    WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	WmipAssert(WdmOfflineResultClassName != NULL);

	//
	// Run in the caller's context so that if he is not able to access
	// the WDM classes, he can't
	//
	hr = CoImpersonateClient();
	if (hr != WBEM_S_NO_ERROR)
	{
		return(hr);
	}
	
	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		wsprintfW(Query, L"select * from %ws where InstanceName = \"%ws\"",
				  WdmOfflineResultClassName,
				  AddSlashesToStringW(s, WdmInstanceNames[RelPathIndex]));
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hr = GetWdmServices()->ExecQuery(sWQL,
										 sQuery,
										 WBEM_FLAG_FORWARD_ONLY |
										 WBEM_FLAG_ENSURE_LOCATABLE,
										 NULL,
										 &pWdmEnumInstances);
			SysFreeString(sQuery);


			if (hr == WBEM_S_NO_ERROR)
			{
				hr = pWdmEnumInstances->Next(WBEM_INFINITE,
											 1,
											 &pWdmInstance,
											 &Count);
				if ((hr == WBEM_S_NO_ERROR) &&
					  (Count == 1))
				{
					//
					// Check that the result has the correct execution
					// ID
					//
					hr = WmiGetProperty(pWdmInstance,
										L"ExecutionID",
										CIM_STRING,
										&vResult);
					if (hr == WBEM_S_NO_ERROR)
					{
						if (_wcsicmp(ExecutionID, vResult.bstrVal) != 0)
						{
							hr = WBEM_E_FAILED;
							WmipDebugPrint(("CdmProv: Expected execution ID %ws, but got %ws\n",
											ExecutionID, vResult.bstrVal));
						}
						VariantClear(&vResult);

						if (hr == WBEM_S_NO_ERROR)
						{

							hr = WmiGetProperty(pWdmInstance,
												L"TestResult",
												CIM_OBJECT,
												&vResult);

							if (hr == WBEM_S_NO_ERROR)
							{
								hr = (vResult.punkVal)->QueryInterface(IID_IWbemClassObject,
																	(PVOID *)&pWdmResult);
								VariantClear(&vResult);
								if (hr == WBEM_S_NO_ERROR)
								{
									hr = CopyBetweenCdmAndWdmClasses(pCdmResult,
																	 pWdmResult,
																	 TRUE);
									pWdmResult->Release();
								}
							}
						}
					}
					pWdmInstance->Release();
				}
				pWdmEnumInstances->Release();
			}						
		}
		SysFreeString(sWQL);
		
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	CoRevertToSelf();
	
	return(hr);
}

//@@BEGIN_DDKSPLIT
HRESULT CTestServices::GatherRebootResults(
    void										   
    )
/*+++
Routine Description:

	This routine will check the schema to see if there were any tests
	that were pending reboot for this DiagnosticTest and if so gather
	the results of them.

	When a test is pending reboot, it gets stored as an instance of the
	static class CDMPROV_Result. The instance contains the Test class
	name, the result class name, the PnPId of the device stack and the
	result object. What we do is get all of the saved results for this
	DiagTest and then see if they apply to any of the PnP Device Ids
	for the WdmTest. If so then we call the device to retrieve the
	results and build the result objects.
	
Arguments:

	
Return Value:

    HRESULT
	
---*/
{

#ifdef REBOOT_DIAGNOSTICS
	HRESULT hr, hrDontCare;
	WCHAR Query[2*MAX_PATH];
	BSTR sQuery, sWQL;
	IEnumWbemClassObject *pEnumInstances;
	IWbemClassObject *pInstance;
	IWbemClassObject *pCdmResult;
	int i;
	ULONG Count;
	VARIANT vResult, vPnPId, vExecutionID;
	BSTR ExecutionId;
	

	hr = WBEM_S_NO_ERROR;

	sWQL = SysAllocString(L"WQL");

	if (sWQL != NULL)
	{
		wsprintfW(Query, L"select * from CdmProv_Result where CdmTestClass = \"%ws\"\n",
				  CdmTestClassName);
		sQuery = SysAllocString(Query);
		if (sQuery != NULL)
		{
			hrDontCare = GetCdmServices()->ExecQuery(sWQL,
										 sQuery,
										 WBEM_FLAG_FORWARD_ONLY |
										 WBEM_FLAG_ENSURE_LOCATABLE,
										 NULL,
										 &pEnumInstances);
			SysFreeString(sQuery);


			if (hrDontCare == WBEM_S_NO_ERROR)
			{
				hr = pEnumInstances->Next(WBEM_INFINITE,
											 1,
											 &pInstance,
											 &Count);
				if ((hr == WBEM_S_NO_ERROR) &&
					  (Count == 1))
				{
					hr = WmiGetProperty(pInstance,
										L"PnPId",
										CIM_STRING,
										&vPnPId);

					if (hr == WBEM_S_NO_ERROR)
					{
						for (i = 0; i < RelPathCount; i++)
						{
							if (_wcsicmp(vPnPId.bstrVal, PnPDeviceIdsX[i]) == 0)
							{
								//
								// We found an instance for this class
								// and PnPId. get out the stored
								// result, assign it a new execution
								// id, and then retrieve the active
								// result from the driver
								//
								PWCHAR PropertyNames[2];
								VARIANT Values[2];
								CIMTYPE CimTypes[2];

								PropertyNames[0] = L"CdmResult";
								CimTypes[0] = CIM_OBJECT;
								PropertyNames[1] = L"ResultTag";
								CimTypes[1] = CIM_STRING;
								
								hr = WmiGetPropertyList(pInstance,
									                PropertyNames,
									                CimTypes,
									                Values);

								if (hr == WBEM_S_NO_ERROR)
								{
									hr = (Values[0].punkVal)->QueryInterface(IID_IWbemClassObject,
										                                   (PVOID *)&pCdmResult);
									if (hr == WBEM_S_NO_ERROR)
									{
										hr = WmiGetProperty(pCdmResult,
											                L"ExecutionID",
											                CIM_STRING,
											                &vExecutionId);
										WmipAssert(vExecutionId.vt != VT_NULL);
										
										if (hr == WBEM_S_NO_ERROR)
										{
											hr = QueryOfflineResult(pCdmResult,
												                    Values[1].bstrVal,
																	i);
											
											if (hr == WBEM_S_NO_ERROR)
											{												
												hr = SetResultObject(pCdmResult,
											                         i,
											                         vExecutionId.bstrVal);
												if (hr == WBEM_S_NO_ERROR)
												{
													hr = FillInCdmResult(pCdmResult,
																 NULL,
												                 i,
												                 ExecutionId);
													if (hr != WBEM_S_NO_ERROR)
													{
														hrDontCare = SetResultObject(NULL,
													                         i,
													                         0);
													}											
												}
											}
										}
									}
									VariantClear(&Values[0]);
									VariantClear(&Values[1]);
								}
							}
						}
						VariantClear(&vPnPId);
					}
				}
				pEnumInstances->Release();
			}
		}						  
		SysFreeString(sWQL);
	}
	return(hr);
#else
	return(WBEM_S_NO_ERROR);
#endif
}


HRESULT CTestServices::PersistResultInSchema(
    IN IWbemClassObject *pCdmResult,
    IN BSTR ExecutionID,
    IN int RelPathIndex
    )
/*+++
Routine Description:

	This routine will persist a diagnostic result into the schema

Arguments:

	
Return Value:

    HRESULT
	
---*/
{
	HRESULT hr;
	IWbemClassObject *pPendingTest;
	IUnknown *punk;
	WCHAR *PropertyNames[5];
	VARIANT PropertyValues[5];

	WmipAssert(pCdmResult != NULL);
	
	WmipAssert(IsThisInitialized());
	
	hr = CreateInst(GetCdmServices(),
					&pPendingTest,
					L"CDMProv_Result",
					NULL);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = pCdmResult->QueryInterface(IID_IUnknown,
										(PVOID *)&punk);
		if (hr == WBEM_S_NO_ERROR)
		{
			PropertyNames[0] = L"PnPId";
			PropertyValues[0].vt = VT_BSTR;
			PropertyValues[0].bstrVal = PnPDeviceIdsX[RelPathIndex];
			
			PropertyNames[1] = L"CdmTestClass";
			PropertyValues[1].vt = VT_BSTR;
			PropertyValues[1].bstrVal = CdmTestClassName;

			PropertyNames[2] = L"CdmResultClass";
			PropertyValues[2].vt = VT_BSTR;
			PropertyValues[2].bstrVal = CdmResultClassName;

			PropertyNames[3] = L"CdmResult";
			PropertyValues[3].vt = VT_UNKNOWN;
			PropertyValues[3].punkVal = punk;

			PropertyNames[4] = L"ExecutionID";
			PropertyValues[4].vt = VT_BSTR;
			PropertyValues[4].bstrVal = ExecutionID;

			hr = WmiSetPropertyList(pPendingTest,
								 5,
								 PropertyNames,
								 PropertyValues);
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = GetCdmServices()->PutInstance(pPendingTest,
					                               WBEM_FLAG_CREATE_OR_UPDATE,
												   NULL,
												   NULL);
			}
			punk->Release();
		}
		pPendingTest->Release();
	}
	return(hr);
}
//@@END_DDKSPLIT

HRESULT CTestServices::OfflineDeviceForTest(
    IWbemClassObject *pCdmResult,
    BSTR ExecutionID,
    int RelPathIndex
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	ULONG Status;
	VARIANT v;
	
    WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());


	//
	// First determine if the test is one where it expects to be taken
	// offline and that the result from the RunTest method indicates
	// that an offline execution is pending
	//
	if (WdmOfflineResultClassName != NULL)
	{
		//
		// The device expects to be taken offline since it had a
		// WdmOfflineResultClass qualifier on the CIM_DiagnosticResult
		// class. Now see if the OtherStateDescription property in the
		// CIM_DiagnosticResult is set to "Offline Pending Execution"
		//
		hr = WmiGetProperty(pCdmResult,
							L"OtherStateDescription",
							CIM_STRING,
							&v);
		if (hr == WBEM_S_NO_ERROR)
		{
			if (_wcsicmp(v.bstrVal, L"Offline Pending Execution") == 0)
			{
				//
				// Ok, the test is waiting for the device to be taken
				// offline. Lets do this now and then when the device
				// comes back, pickup the results from the
				// OfflineResultClass
				//
				
// @@BEGIN_DDKSPLIT
//#define FORCE_REBOOT_REQUIRED
#ifdef FORCE_REBOOT_REQUIRED
                Status = ERROR_INVALID_PARAMETER;
#else
// @@END_DDKSPLIT
				
				//
				// Make sure to use the clients security context to try
				// to bring the device offline.
				//
				hr = CoImpersonateClient();
				if (hr == WBEM_S_NO_ERROR)
				{
					Status = RestartDevice(PnPDeviceIdsX[RelPathIndex]);
					CoRevertToSelf();
				}
				
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
	
				if (Status == ERROR_SUCCESS)
				{
					hr = QueryOfflineResult(pCdmResult,
											ExecutionID,
											RelPathIndex);
				} else {
					//
					// For some reason we were not able to bring the
					// device offline. Most likely this is because the
					// device is critical to the system and cannot be
					// taken offline right now - for example a disk
					// that is in the paging path.
					//
					
// @@BEGIN_DDKSPLIT
#if REBOOT_DIAGNOSTICS					
					// What we'll need to do is to remember that
					// this test is pending and so the next time the
					// system is rebooted we can check for the results
					// of this test and report them.
					//
					hr = PersistResultInSchema(pCdmResult,
											   RelPathIndex);
#else
					//
					// Reboot diagnostics are not currently supported.
					//
					
// @@END_DDKSPLIT
					
					hr = WBEM_E_FAILED;
					
// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT
					
				}
				
			}
			VariantClear(&v);
		} else {
			//
			// Since the OtherStateDescription was not set then we
			// assume that the tests isn't setup to go offline and has
			// already been completed
			//
			hr = WBEM_S_NO_ERROR;
		}
	}
	
	return(hr);
}



BOOLEAN CTestServices::IsThisInitialized(
    void
    )
/*+++
Routine Description:

	This routine determines if this class has been initialized to
	access CDM and WDM classes

Arguments:

	
	
Return Value:

    TRUE if initialiezed else FALSE
	
---*/
{
	return( (CdmTestClassName != NULL) );
}

HRESULT CTestServices::AddResultToList(
    IN IWbemClassObject *ResultInstance,
    IN BSTR ExecutionID,
    IN int RelPathIndex
    )
/*+++
Routine Description:

	This routine will add a result object and the related association
	relpaths to the list of result objects for the test

Arguments:

	ResultInstance is an instance of CIM_DiagnosticResults

	RelPathIndex

	ExecutionID
	
Return Value:

	Never fails
	
---*/
{
	HRESULT hr;
	BSTR ResultRelPath;
	BSTR ResultForMSERelPath;
	BSTR ResultForTestRelPath;
	
	WmipAssert(ResultInstance != NULL);
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	//
	// If there is a new result object then establish the various
	// result relpaths for it
	//
	hr = BuildResultRelPaths(RelPathIndex,
							 ExecutionID,
							 &ResultRelPath,
							 &ResultForMSERelPath,
							 &ResultForTestRelPath);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = CdmResultsList[RelPathIndex].Add(ResultInstance,
										 ResultRelPath,
										 ResultForMSERelPath,
										 ResultForTestRelPath);
	}
	
	return(hr);
}

HRESULT CTestServices::GetResultsList(
    IN int RelPathIndex,
    OUT ULONG *ResultsCount,
    OUT IWbemClassObject ***Results
)
{
	WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	
	return(CdmResultsList[RelPathIndex].GetResultsList(ResultsCount,
		                                          Results));
}

void CTestServices::ClearResultsList(
    int RelPathIndex
    )
{
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	CdmResultsList[RelPathIndex].Clear();
}

        
BSTR /* NOFREE */ CTestServices::GetCimRelPath(
    int RelPathIndex
	)
/*+++
Routine Description:

	This routine will return the Cim relpath for a RelPathIndex

Arguments:

	RelPathIndex
	
Return Value:

    Cim RelPath. This should not be freed
	
---*/
{
	WmipAssert(CimRelPaths != NULL);
	WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	
	return(CimRelPaths[RelPathIndex]);
}
		
BSTR /*  NOFREE */ CTestServices::GetCdmTestRelPath(
    void
    )
/*+++
Routine Description:

	This routine will return the Cdm Test class relpath

Arguments:


Return Value:

    Cdm Test Class RelPath. This should not be freed
	
---*/
{
	WmipAssert(IsThisInitialized());
	
	return(CdmTestRelPath);
}

BSTR /* NOFREE */ CTestServices::GetCdmTestClassName(
    void
    )
/*+++
Routine Description:

	This routine will return the Cdm Test class name

Arguments:


Return Value:

    Cdm Test Class Name. This should not be freed
	
---*/
{
	WmipAssert(IsThisInitialized());
	return(CdmTestClassName);
}


BSTR /* NOFREE */ CTestServices::GetCdmResultClassName(
    void
    )
/*+++
Routine Description:

	This routine will return the Cdm Result class name

Arguments:


Return Value:

    Cdm Result Class Name. This should not be freed
	
---*/
{
	WmipAssert(IsThisInitialized());
	return(CdmResultClassName);
}

HRESULT CTestServices::GetCdmResultByResultRelPath(
    IN int RelPathIndex,
    IN PWCHAR ObjectPath,
    OUT IWbemClassObject **ppCdmResult
    )
/*+++
Routine Description:

	This routine will return the Cdm Result object for a specific RelPath 

Arguments:

	RelPathIndex


Return Value:

    Cdm Result RelPath or NULL of there is no ressult object for the
		relpath. This should not be freed
	
---*/
{

	HRESULT hr;
	
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	hr = CdmResultsList[RelPathIndex].GetResultByResultRelPath(ObjectPath,
											   ppCdmResult);
		
	return(hr);
}

HRESULT CTestServices::GetCdmResultByResultForMSERelPath(
    IN int RelPathIndex,
    IN PWCHAR ObjectPath,
    OUT IWbemClassObject **ppCdmResult
    )
/*+++
Routine Description:

	This routine will return the Cdm Result object for a specific RelPath 

Arguments:

	RelPathIndex


Return Value:

    Cdm Result RelPath or NULL of there is no ressult object for the
		relpath. This should not be freed
	
---*/
{

	HRESULT hr;
	
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	hr = CdmResultsList[RelPathIndex].GetResultByResultForMSERelPath(ObjectPath,
											   ppCdmResult);
		
	return(hr);
}

HRESULT CTestServices::GetCdmResultByResultForTestRelPath(
    IN int RelPathIndex,
    IN PWCHAR ObjectPath,
    OUT IWbemClassObject **ppCdmResult
    )
/*+++
Routine Description:

	This routine will return the Cdm Result object for a specific RelPath 

Arguments:

	RelPathIndex


Return Value:

    Cdm Result RelPath or NULL of there is no ressult object for the
		relpath. This should not be freed
	
---*/
{

	HRESULT hr;
	
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	hr = CdmResultsList[RelPathIndex].GetResultByResultForTestRelPath(ObjectPath,
											                     ppCdmResult);
		
	return(hr);
}

BSTR /* NOFREE */ CTestServices::GetCdmSettingClassName(
    void
    )
/*+++
Routine Description:

	This routine will return the Cdm settings class name

Arguments:


Return Value:

    Cdm Settings class name. This should not be freed
	
---*/
{
	WmipAssert(IsThisInitialized());
	return(CdmSettingClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmSettingRelPath(
    int RelPathIndex,
	ULONG SettingIndex
    )
/*+++
Routine Description:

	This routine will return the Cdm settings relpath by relpath index
	and index with the settings for that relpath.

Arguments:

	RelPathIndex

	SettingIndex

Return Value:

    Cdm Settings relpath. This should not be freed
	
---*/
{
	CWbemObjectList *CdmSettings;
	
	WmipAssert(RelPathIndex < RelPathCount);
	WmipAssert(CdmSettingsList != NULL);
	WmipAssert(IsThisInitialized());	
	
	CdmSettings = CdmSettingsList[RelPathIndex];
	
	return(CdmSettings->GetRelPath(SettingIndex));
}

IWbemClassObject *CTestServices::GetCdmSettingObject(
	int RelPathIndex,
	ULONG SettingIndex
)
{
	CWbemObjectList *CdmSettings;
	
	WmipAssert(RelPathIndex < RelPathCount);
	WmipAssert(CdmSettingsList != NULL);
	WmipAssert(IsThisInitialized());

	CdmSettings = CdmSettingsList[RelPathIndex];
	
	return(CdmSettings->Get(SettingIndex));
}

ULONG CTestServices::GetCdmSettingCount(
	int RelPathIndex
)
{
	WmipAssert(RelPathIndex < RelPathCount);
	WmipAssert(CdmSettingsList != NULL);
	WmipAssert(IsThisInitialized());
	
	return(CdmSettingsList[RelPathIndex]->GetListSize());
}

BSTR /* NOFREE */ CTestServices::GetCdmTestForMSEClassName(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmTestForMSEClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmTestForMSERelPath(
    int RelPathIndex
    )
{
	WmipAssert(RelPathIndex < RelPathCount);
	WmipAssert(IsThisInitialized());
	return(CdmTestForMSERelPath[RelPathIndex]);
}

BSTR /* NOFREE */ CTestServices::GetCdmSettingForTestClassName(
    void
	)
{
	WmipAssert(IsThisInitialized());
	return(CdmSettingForTestClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmSettingForTestRelPath(
    int RelPathIndex,
	ULONG SettingIndex
	)
{
	CBstrArray *BstrArray;
	BSTR s;
	
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	if (CdmSettingForTestRelPath != NULL)
	{
		BstrArray = CdmSettingForTestRelPath[RelPathIndex];
		s = BstrArray->Get(SettingIndex);
	} else {
		s = NULL;
	}
	
	return(s);
}

BSTR /* NOFREE */ CTestServices::GetCdmResultForMSEClassName(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmResultForMSEClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmResultForTestClassName(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmResultForTestClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmTestForSoftwareClassName(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmTestForSoftwareClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmTestForSoftwareRelPath(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmTestForSoftwareRelPath);
}

BSTR /* NOFREE */ CTestServices::GetCdmTestInPackageClassName(
    void
	)
{
	WmipAssert(IsThisInitialized());
	return(CdmTestInPackageClassName);
}

BSTR  /* NOFREE */CTestServices::GetCdmTestInPackageRelPath(
    void
	)
{
	WmipAssert(IsThisInitialized());
	return(CdmTestInPackageRelPath);
}

BSTR /* NOFREE */ CTestServices::GetCdmResultInPackageClassName(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmResultInPackageClassName);
}

BSTR /* NOFREE */ CTestServices::GetCdmResultInPackageRelPath(
    void
    )
{
	WmipAssert(IsThisInitialized());
	return(CdmResultInPackageRelPath);
}


CWbemObjectList::CWbemObjectList()
{
	//
	// Constructor, init internal values
	//
	List = NULL;
	RelPaths = NULL;
	ListSize = 0xffffffff;
}

CWbemObjectList::~CWbemObjectList()
{
	//
	// Destructor, free memory held by this class
	//
	if (List != NULL)
	{
		WmipFree(List);
	}
	List = NULL;

	if (RelPaths != NULL)
	{
		FreeTheBSTRArray(RelPaths, ListSize);
		RelPaths = NULL;
	}
	
	ListSize = 0xffffffff;
}

HRESULT CWbemObjectList::Initialize(
    ULONG NumberPointers
    )
{
	HRESULT hr;
	ULONG AllocSize;

	//
	// Initialize class by allocating internal list array
	//

	WmipAssert(List == NULL);

	if (NumberPointers != 0)
	{
		AllocSize = NumberPointers * sizeof(IWbemClassObject *);
		List = (IWbemClassObject **)WmipAlloc(AllocSize);
		if (List != NULL)
		{
			memset(List, 0, AllocSize);
			AllocSize = NumberPointers * sizeof(BSTR);
			
			RelPaths = (BSTR *)WmipAlloc(AllocSize);
			if (RelPaths != NULL)
			{
				memset(RelPaths, 0, AllocSize);
				ListSize = NumberPointers;
				hr = WBEM_S_NO_ERROR;
			} else {
				WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList RelPaths\n"));
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		} else {
			WmipDebugPrint(("CDMProv: Could not alloc memory for CWbemObjectList\n"));
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = NumberPointers;
		hr = WBEM_S_NO_ERROR;
	}
	
	return(hr);
}

ULONG CWbemObjectList::GetListSize(
    void
	)
{
	//
	// Accessor for list size
	//

	WmipAssert(IsInitialized());
	
	return(ListSize);
}

IWbemClassObject *CWbemObjectList::Get(
    ULONG Index
    )
{	IWbemClassObject *Pointer;
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	Pointer = List[Index];
	
	return(Pointer);
}


HRESULT CWbemObjectList::Set(
    IN ULONG Index,
	IN IWbemClassObject *Pointer,
    IN BOOLEAN KeepRelPath
    )
{
	HRESULT hr;
	VARIANT v;
	
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());
	
	if (Pointer != NULL)
	{
		hr = WmiGetProperty(Pointer,
							L"__RelPath",
							CIM_REFERENCE,
							&v);
		if (hr == WBEM_S_NO_ERROR)
		{
			RelPaths[Index] = v.bstrVal;
			List[Index] = Pointer;		
		} else {
			if (! KeepRelPath)
			{
				RelPaths[Index] = NULL;
				List[Index] = Pointer;		
			}
		}
	} else {
		if (RelPaths[Index] != NULL)
		{
			SysFreeString(RelPaths[Index]);
			RelPaths[Index] = NULL;
			hr = WBEM_S_NO_ERROR;
		}
		
		List[Index] = NULL;
	}
	return(hr);
}

BSTR /* NOFREE */ CWbemObjectList::GetRelPath(
    IN ULONG Index
	)
{
	WmipAssert(Index < ListSize);
	WmipAssert(IsInitialized());

	return(RelPaths[Index]);
}

BOOLEAN CWbemObjectList::IsInitialized(
    )
{
	return((ListSize == 0) ||
		   ((List != NULL) && (RelPaths != NULL)));
}


//
// Linked list management routines
//
CTestServices *CTestServices::GetNext(
)
{
	return(Next);
}

CTestServices *CTestServices::GetPrev(
)
{
	return(Prev);
}


void CTestServices::InsertSelf(
    CTestServices **Head
	)
{
	WmipAssert(Next == NULL);
	WmipAssert(Prev == NULL);

	if (*Head != NULL)
	{
		Next = (*Head);
		(*Head)->Prev = this;
	}
	*Head = this;
}

BOOLEAN CTestServices::ClaimCdmClassName(
    PWCHAR CdmClassName
    )
{

	if (_wcsicmp(CdmClassName, CdmTestClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmResultClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmSettingClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmTestForMSEClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmSettingForTestClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmResultForMSEClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmResultForTestClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmTestForSoftwareClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmTestInPackageClassName) == 0)
	{
		return(TRUE);
	}

	if (_wcsicmp(CdmClassName, CdmResultInPackageClassName) == 0)
	{
		return(TRUE);
	}

	return(FALSE);
}

CBstrArray::CBstrArray()
{
	Array = NULL;
	ListSize = 0xffffffff;
}

CBstrArray::~CBstrArray()
{
	ULONG i;
	
	if (Array != NULL)
	{
		for (i = 0; i < ListSize; i++)
		{
			if (Array[i] != NULL)
			{
				SysFreeString(Array[i]);
			}
		}
		WmipFree(Array);
	}

	ListSize = 0xffffffff;
}

HRESULT CBstrArray::Initialize(
    ULONG ListCount
    )
{
	HRESULT hr = WBEM_S_NO_ERROR;
	ULONG AllocSize;
	
	if (ListCount != 0)
	{
		AllocSize = ListCount * sizeof(BSTR *);
		Array = (BSTR *)WmipAlloc(AllocSize);
		if (Array != NULL)
		{
			memset(Array, 0, AllocSize);
			ListSize = ListCount;
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		ListSize = ListCount;
	}
	return(hr);
}

BOOLEAN CBstrArray::IsInitialized(
    )
{
	return( (Array != NULL) || (ListSize == 0) );
}

BSTR CBstrArray::Get(
    ULONG Index
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	return(Array[Index]);
}

void CBstrArray::Set(
    ULONG Index,
    BSTR s				 
    )
{
	WmipAssert(Index < ListSize);
	
	WmipAssert(IsInitialized());

	Array[Index] = s;
}

ULONG CBstrArray::GetListSize(
    )
{
	WmipAssert(IsInitialized());

	return(ListSize);
}

CResultList::CResultList()
{
	ListSize = 0;
	ListEntries = 0;
	List = NULL;
}

CResultList::~CResultList()
{
	ULONG i;

	Clear();
	if (List != NULL)
	{
		WmipFree(List);
	}
}

void CResultList::Clear(
    void
    )
{
	ULONG i;
	PRESULTENTRY Entry;
	
	if (List != NULL)
	{
		for (i = 0; i < ListEntries; i++)
		{
			Entry = &List[i];
			if (Entry->ResultInstance != NULL)
			{
				Entry->ResultInstance->Release();
				Entry->ResultInstance = NULL;
			}

			if (Entry->ResultRelPath != NULL)
			{
				SysFreeString(Entry->ResultRelPath);
				Entry->ResultRelPath = NULL;
			}

			if (Entry->ResultForMSERelPath != NULL)
			{
				SysFreeString(Entry->ResultForMSERelPath);
				Entry->ResultForMSERelPath = NULL;
			}
			
			if (Entry->ResultForTestRelPath != NULL)
			{
				SysFreeString(Entry->ResultForTestRelPath);
				Entry->ResultForTestRelPath = NULL;
			}			
		}
	}
	ListEntries = 0;
}

//
// The result list will grow itself this many entries at a time
//
#define RESULTLISTGROWSIZE 4

HRESULT CResultList::Add(
    IWbemClassObject *CdmResultInstance,
	BSTR CdmResultRelPath,
	BSTR CdmResultForMSERelPath,
	BSTR CdmResultForTestRelPath
    )
{
	ULONG AllocSize;
	PRESULTENTRY NewList, Entry;
	ULONG CurrentSize;
	
	EnterCdmCritSection();
	
	if (List == NULL)
	{
		//
		// We are starting with an empty list
		//
		AllocSize = RESULTLISTGROWSIZE * sizeof(RESULTENTRY);
		List = (PRESULTENTRY)WmipAlloc(AllocSize);
		if (List == NULL)
		{
			LeaveCdmCritSection();
			return(WBEM_E_OUT_OF_MEMORY);
		}
		memset(List, 0, AllocSize);
		ListSize = RESULTLISTGROWSIZE;
		ListEntries = 0;
	} else if (ListEntries == ListSize)	{
		//
		// The list needs to grow, so we allocate more memory and copy
		// over the current list
		//
		CurrentSize = ListSize * sizeof(RESULTENTRY);
		AllocSize = CurrentSize + (RESULTLISTGROWSIZE * sizeof(RESULTENTRY));
		NewList = (PRESULTENTRY)WmipAlloc(AllocSize);
		if (NewList == NULL)
		{
			LeaveCdmCritSection();
			return(WBEM_E_OUT_OF_MEMORY);
		}

		memset(NewList, 0, AllocSize);
		memcpy(NewList, List, CurrentSize);
		WmipFree(List);
		List = NewList;
		ListSize += RESULTLISTGROWSIZE;
	}

	//
	// We have room to add a new entry to the list
	//
	Entry = &List[ListEntries++];
	Entry->ResultInstance = CdmResultInstance;
	Entry->ResultInstance->AddRef();
	Entry->ResultRelPath = CdmResultRelPath;
	Entry->ResultForMSERelPath = CdmResultForMSERelPath;
	Entry->ResultForTestRelPath = CdmResultForTestRelPath;
	
	LeaveCdmCritSection();
	return(WBEM_S_NO_ERROR);
}

HRESULT CResultList::GetResultsList(
	OUT ULONG *Count,
    OUT IWbemClassObject ***Objects
	)
{
	IWbemClassObject **Things;
	HRESULT hr;
	ULONG i;
	
	EnterCdmCritSection();

	*Count = ListEntries;
	if (ListEntries != 0)
	{
		Things = (IWbemClassObject **)WmipAlloc( ListEntries *
												 sizeof(IWbemClassObject *));
		if (Things != NULL)
		{
			*Objects = Things;

			for (i = 0; i < ListEntries; i++)
			{		
				Things[i] = List[i].ResultInstance;
				Things[i]->AddRef();
			}
			hr = WBEM_S_NO_ERROR;
		} else {
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	} else {
		*Objects = NULL;
		hr = WBEM_S_NO_ERROR;
	}
	
	LeaveCdmCritSection();

	return(hr);
}


HRESULT CResultList::GetResultByResultRelPath(
    PWCHAR ObjectPath,
	IWbemClassObject **ppResult
	)
{
	HRESULT hr;
	ULONG i;

	hr = WBEM_E_NOT_FOUND;
	
	EnterCdmCritSection();

	for (i = 0; i < ListEntries; i++)
	{
		if (_wcsicmp(ObjectPath, List[i].ResultRelPath) == 0)
		{
			*ppResult = List[i].ResultInstance;
			(*ppResult)->AddRef();
			hr = WBEM_S_NO_ERROR;
			break;
		}
	}
	
	LeaveCdmCritSection();
	return(hr);
}

HRESULT CResultList::GetResultByResultForMSERelPath(
    PWCHAR ObjectPath,
	IWbemClassObject **ppResult
	)
{
	HRESULT hr;
	ULONG i;

	hr = WBEM_E_NOT_FOUND;
	
	EnterCdmCritSection();

	for (i = 0; i < ListEntries; i++)
	{
		if (_wcsicmp(ObjectPath, List[i].ResultForMSERelPath) == 0)
		{
			*ppResult = List[i].ResultInstance;
			(*ppResult)->AddRef();
			hr = WBEM_S_NO_ERROR;
			break;
		}
	}
	
	LeaveCdmCritSection();
	return(hr);
}

HRESULT CResultList::GetResultByResultForTestRelPath(
    PWCHAR ObjectPath,
	IWbemClassObject **ppResult
	)
{
	HRESULT hr;
	ULONG i;

	hr = WBEM_E_NOT_FOUND;
	
	EnterCdmCritSection();

	for (i = 0; i < ListEntries; i++)
	{
		if (_wcsicmp(ObjectPath, List[i].ResultForTestRelPath) == 0)
		{
			*ppResult = List[i].ResultInstance;
			(*ppResult)->AddRef();
			hr = WBEM_S_NO_ERROR;
			break;
		}
	}
	
	LeaveCdmCritSection();
	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\testinfo.h ===
//***************************************************************************
//
//  TestInfo.h
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

class CResultList
{
	public:
		CResultList();
		~CResultList();
		
		HRESULT Add(IWbemClassObject *ResultInstance,
				    BSTR ResultRelPath,
				    BSTR ResultForMSERelPath,
				    BSTR ResultForTestRelPath);
		void Clear(void);
		
		HRESULT GetResultsList(ULONG *Count,
							 IWbemClassObject ***Objects);

		HRESULT GetResultByResultRelPath(PWCHAR ObjectPath,
								   IWbemClassObject **ppResult);

		HRESULT GetResultByResultForMSERelPath(PWCHAR ObjectPath,
								   IWbemClassObject **ppResult);
		
		HRESULT GetResultByResultForTestRelPath(PWCHAR ObjectPath,
								   IWbemClassObject **ppResult);
		
	private:
		typedef struct
		{
			IWbemClassObject *ResultInstance;
			BSTR ResultRelPath;
			BSTR ResultForMSERelPath;
			BSTR ResultForTestRelPath;			
		} RESULTENTRY, *PRESULTENTRY;

		ULONG ListSize;
		ULONG ListEntries;
		PRESULTENTRY List;
};


class CBstrArray
{
	public:
		CBstrArray();
		~CBstrArray();

		HRESULT Initialize(ULONG ListCount);
		void Set(ULONG Index, BSTR s);
		BSTR /* NOFREE */ Get(ULONG Index);
		ULONG GetListSize();

	private:
		BOOLEAN IsInitialized();
		BSTR *Array;
		ULONG ListSize;
};

class CWbemObjectList
{
	public:
		CWbemObjectList();
		~CWbemObjectList();

		HRESULT Initialize(ULONG ListCount);
		HRESULT Set(ULONG Index, IWbemClassObject *Pointer, BOOLEAN KeepRelPath);
		IWbemClassObject *Get(ULONG Index);
		BSTR /* NOFREE */ GetRelPath(ULONG Index);
		
		ULONG GetListSize(void);

	private:
		BOOLEAN IsInitialized(
							 );
		
		ULONG ListSize;
		IWbemClassObject **List;
		BSTR *RelPaths;
};


class CTestServices
{
	public:
		CTestServices();
		~CTestServices();


		//
		// Linked list management routines for the benefit of the
		// provider
		//
		CTestServices *GetNext();
		CTestServices *GetPrev();
		void InsertSelf(CTestServices **Head);
		
		HRESULT QueryWdmTest(IWbemClassObject *pCdmTest,
							 int RelPathIndex);

		HRESULT ExecuteWdmTest(    IWbemClassObject *pCdmSettings,
								   IWbemClassObject *pCdmResult,
								   int RelPathIndex,
								   ULONG *Result,
							       BSTR *ExecutionID);

		HRESULT StopWdmTest(    int RelPathIndex,
								ULONG *Result,
								BOOLEAN *TestingStopped);

		HRESULT GetRelPathIndex(BSTR CimRelPath,
								int *RelPathIndex);

		ULONG GetInstanceCount(void) { return(RelPathCount); };
		
		LONG GetTestEstimatedTime(int RelPathIndex) { return(0); };
		
		BOOLEAN GetTestIsExclusiveForMSE(int RelPathIndex) { return(FALSE); };

		HRESULT FillInCdmResult(
								IWbemClassObject *pCdmResult,
								IWbemClassObject *pCdmSettings,
								int RelPathIndex,
								BSTR ExecutionID
							   );

		BOOLEAN IsThisInitialized(void);
		
		HRESULT InitializeCdmClasses(PWCHAR CdmClassName);

		BOOLEAN ClaimCdmClassName(PWCHAR CdmClassName);

		HRESULT AddResultToList(IWbemClassObject *pCdmResult,
								BSTR ExecutionID,
								int RelPathIndex);

		void ClearResultsList(int RelPathIndex);
		HRESULT GetResultsList(int RelPathIndex,
							  ULONG *ResultsCount,
							  IWbemClassObject ***Results);

		HRESULT GetCdmResultByResultRelPath(int RelPathIndex,
								  PWCHAR ObjectPath,
								  IWbemClassObject **ppCdmResult);
		
		HRESULT GetCdmResultByResultForMSERelPath(int RelPathIndex,
								  PWCHAR ObjectPath,
								  IWbemClassObject **ppCdmResult);
		
		HRESULT GetCdmResultByResultForTestRelPath(int RelPathIndex,
								  PWCHAR ObjectPath,
								  IWbemClassObject **ppCdmResult);
		
		//
		// Accessors
		BSTR GetCimRelPath(int RelPathIndex);
		
		BSTR GetCdmTestClassName(void);
		BSTR GetCdmTestRelPath(void);
		
		BSTR GetCdmResultClassName(void);
		
		BSTR GetCdmSettingClassName(void);
		BSTR GetCdmSettingRelPath(int RelPathIndex, ULONG SettingIndex);
		ULONG GetCdmSettingCount(int RelPathIndex);
		IWbemClassObject *GetCdmSettingObject(int RelPathIndex, ULONG SettingIndex);
		
		BSTR GetCdmTestForMSEClassName(void);
		BSTR GetCdmTestForMSERelPath(int RelPathIndex);
		
		BSTR GetCdmSettingForTestClassName(void);
		BSTR GetCdmSettingForTestRelPath(int RelPathIndex, ULONG SettingIndex);
		
		BSTR GetCdmResultForMSEClassName(void);
		BSTR GetCdmResultForMSERelPath(int RelPathIndex);
		
		BSTR GetCdmResultForTestClassName(void);		
		BSTR GetCdmResultForTestRelPath(int RelPathIndex);
		
		BSTR GetCdmTestForSoftwareClassName(void);		
		BSTR GetCdmTestForSoftwareRelPath(void);
		
		BSTR GetCdmTestInPackageClassName(void);
		BSTR GetCdmTestInPackageRelPath(void);
		
		BSTR GetCdmResultInPackageClassName(void);
		BSTR GetCdmResultInPackageRelPath(void);

		
	private:								  
		
		HRESULT WdmPropertyToCdmProperty(
										 IWbemClassObject *pCdmClassInstance,
										 IWbemClassObject *pWdmClassInstance,
										 BSTR PropertyName,
										 VARIANT *PropertyValue,
										 CIMTYPE CdmCimType,
										 CIMTYPE WdmCimType
										);

		HRESULT CdmPropertyToWdmProperty(
										 IWbemClassObject *pWdmClassInstance,
										 IWbemClassObject *pCdmClassInstance,
										 BSTR PropertyName,
										 VARIANT *PropertyValue,
										 CIMTYPE WdmCimType,
										 CIMTYPE CdmCimType
										);
				
		HRESULT CopyBetweenCdmAndWdmClasses(
							IWbemClassObject *pDestinationClass,
							IWbemClassObject *pSourceClass,
							BOOLEAN WdmToCdm
							);
		
		HRESULT ConnectToWdmClass(int RelPathIndex,
								  IWbemClassObject **ppWdmClassObject);


		HRESULT GetCdmClassNamesFromOne(
										PWCHAR CdmClass
									   );
		
		HRESULT BuildResultRelPaths(
									    IN int RelPathIndex,
										IN BSTR ExecutionId,
										OUT BSTR *ResultRelPath,
										OUT BSTR *ResultForMSERelPath,
										OUT BSTR *ResultForTestRelPath
								   );
		
		HRESULT BuildTestRelPaths(
								  void
								 );

		HRESULT ParseSettingList(
								  VARIANT *SettingList,
								  CWbemObjectList *CdmSettings,
								  CBstrArray *CdmSettingForTestRelPath,
								  int RelPathIndex
								 );
		HRESULT BuildSettingForTestRelPath(
										   OUT BSTR *RelPath,
										   IN IWbemClassObject *pCdmSettingInstance
										  );

		
		HRESULT GetCdmTestSettings(void);

		HRESULT QueryOfflineResult(
								   OUT IWbemClassObject *pCdmResult,
								   IN BSTR ExecutionID,
								   IN int RelPathIndex
								  );
// @@BEGIN_DDKSPLIT
		HRESULT GatherRebootResults(
									void										   
								   );
		
		HRESULT PersistResultInSchema(
									  IWbemClassObject *pCdmResult,
									  BSTR ExecutionID,
									  int RelPathIndex
									 );
// @@END_DDKSPLIT
		
		HRESULT GetTestOutParams(
								 IN IWbemClassObject *OutParams,
								 OUT IWbemClassObject *pCdmResult,
								 OUT ULONG *Result
								);
		
		HRESULT OfflineDeviceForTest(IWbemClassObject *pCdmResult,
									BSTR ExecutionID,
									 int RelPathIndex);
		
		BSTR GetExecutionID(
							void
						   );
		
		HRESULT FillTestInParams(
									OUT IWbemClassObject *pInParamInstance,
									IN IWbemClassObject *pCdmSettings,
									IN BSTR ExecutionID
								);		
		
		IWbemServices *GetWdmServices(void);
		IWbemServices *GetCdmServices(void);


		CTestServices *Next;
		CTestServices *Prev;

		
		//
		// WDM Class Names
		//
		BSTR WdmTestClassName;
		BSTR WdmSettingClassName;
		BSTR WdmResultClassName;
		BSTR WdmOfflineResultClassName;
		BSTR WdmSettingListClassName;
		
		//
		// CDM Class and RelPath Names
		//
		BSTR CdmTestClassName;
		BSTR CdmTestRelPath;
		
		BSTR CdmResultClassName;
		
		BSTR CdmSettingClassName;
		
		BSTR CdmTestForMSEClassName;		
		BSTR *CdmTestForMSERelPath;
		
		BSTR CdmSettingForTestClassName;
		CBstrArray **CdmSettingForTestRelPath;
		
		BSTR CdmResultForMSEClassName;
		
		BSTR CdmResultForTestClassName;
		
		BSTR CdmTestForSoftwareClassName;
		BSTR CdmTestForSoftwareRelPath;
		
		BSTR CdmTestInPackageClassName;
		BSTR CdmTestInPackageRelPath;
		
		BSTR CdmResultInPackageClassName;
		BSTR CdmResultInPackageRelPath;

		//
		// Mapping class from Cim to WDM
		//
		BSTR CimClassMappingClassName;
		
		//
		// List of mappings between Cim and WDM
		//
		int RelPathCount;
		BSTR *CimRelPaths;
		BSTR *WdmRelPaths;

		BSTR *WdmInstanceNames;
		BSTR *PnPDeviceIdsX;
		
		//
		// Results for test executions. Each relpathindex maintains a
		// list of results.
		//
		CResultList *CdmResultsList;

		//
		// Settings for test execution, we can have many settings for
		// each test.
		//
		CWbemObjectList **CdmSettingsList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\sample.h ===
//***************************************************************************
//
//  sample.h
//
//  Module: WINMGMT class provider sample code
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_

#include <wbemprov.h>

#include "testinfo.h"

typedef LPVOID * PPVOID;


// Provider interfaces are provided by objects of this class
 
class CClassPro : public IWbemServices, public IWbemProviderInit
{

	private:
		
		HRESULT LookupTestServices(
								   const BSTR CdmClassName,
								   CTestServices **TestServices
								  );

		CTestServices *FindExistingTestServices(
													PWCHAR CdmClassName
											   );

		HRESULT CreateTestInst(
							   CTestServices *WdmTest,
							   IWbemClassObject **pCdmTest,
							   IWbemContext *pCtx										  
							  );
				
		HRESULT CreateResultForMSEInst(
									   CTestServices *WdmTest,
									   IWbemClassObject **pCdmResultForMSE,
									   int RelPathIndex,
									   IWbemClassObject *pCdmResult,
									   IWbemContext *pCtx										  
									  );

		HRESULT CreateResultForTestInst(
										CTestServices *WdmTest,
										IWbemClassObject **pCdmResultForTest,
										IWbemClassObject *pCdmResult,
										IWbemContext *pCtx
									   );

		HRESULT CreateTestForMSEInst(
									 CTestServices *WdmTest,
									 IWbemClassObject **pCdmTestForMSE,
									 int RelPathIndex,
									 IWbemContext *pCtx
									);

		
		HRESULT CreateSettingForTestInst(
										 CTestServices *WdmTest,
										 IWbemClassObject **pCdmSettingForTest,
										 int RelPathIndex,
										 ULONG SettingIndex,
										 IWbemContext *pCtx
										);
		
		
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pCdmServices;
		
     public:
        CClassPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CClassPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED; };

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

};

typedef CClassPro *PCClassPro;

// This class is the class factory for CClassPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern LONG       g_cObj;
extern LONG       g_cLock;

// General purpose utilities.  

             
SCODE CreateInst(
    IWbemServices * pNamespace,
	IWbemClassObject ** pNewInst,
    WCHAR * pwcClassName,
	IWbemContext  *pCtx
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif


NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    //
    // Remember registry path since it is needed for WMI registration
    FilterRegistryPath.Length = 0;
    FilterRegistryPath.MaximumLength = RegistryPath->Length;
    FilterRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool, 
                                                RegistryPath->Length+2,
                                                FILTER_TAG);
    RtlCopyUnicodeString(&FilterRegistryPath, RegistryPath);

    
    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object

    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);

        /*
         *  Clear the initializing bit from the new device object's flags.
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  The DO_POWER_PAGABLE bit of a device object
         *  indicates to the kernel that the power-handling
         *  code of the corresponding driver is pageable, and
         *  so must be called at IRQL 0.
         *  As a filter driver, we do not want to change the power
         *  behavior of the driver stack in any way; therefore,
         *  we copy this bit from the lower device object.
         */
        ASSERT(!(filterDevObj->Flags & DO_POWER_PAGABLE)); 
        filterDevObj->Flags |= (physicalDevObj->Flags & DO_POWER_PAGABLE);

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt->physicalDevObj);

        /*
         * WMI specific initialization
        */
        FilterInitializeWmiDataBlocks(devExt);  
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    DBGOUT(("VA_DriverUnload")); 
	
	//
    // Free memory used by registry path
    ExFreePool(FilterRegistryPath.Buffer);
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(("VA_Dispatch: majorFunc=%d, minorFunc=%d", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_SYSTEM_CONTROL:
                status = VA_SystemControl(devExt, Irp, &passIrpDown);
				break;
				
            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->physicalDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <wmilib.h>
#include "filtdata.h"

#define MAXEXECUTIONIDSIZE	40*sizeof(WCHAR)

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

//
// Data structures for storing WMI data



#define DEVICE_EXTENSION_SIGNATURE 'rtlF'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

    /*
     * WMILIB callbacks and guid list
     */
    WMILIB_CONTEXT WmiLib;

	/*
	 * Offline diagnostic test state. 0 implies no offline diag run
	 */
	ULONG OfflineTestResult;
	PUCHAR ExecutionID[MAXEXECUTIONIDSIZE];
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 */
#define FILTER_TAG (ULONG)'tliF'


#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'FILTER> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    VA_SystemControl(struct DEVICE_EXTENSION *devExt, PIRP irp, PBOOLEAN passIrpDown);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        RegistryAccessSample(PDEVICE_OBJECT devObj);
NTSTATUS    FilterInitializeWmiDataBlocks(struct DEVICE_EXTENSION *devExt);
NTSTATUS    FilterPerformOfflineDiags(struct DEVICE_EXTENSION *devExt);

extern UNICODE_STRING FilterRegistryPath;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# filtdata.h has definitions for the guids, data structures and definitions
#                of the method ids.
#
# filter.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you install your driver, run the script
#            at the command line by typing: filter.vbs.

clean:
    del filtdata.h filter.vbs

filter.vbs filtdata.h filter.x: $(O)\filter.bmf
    wmimofck -m -hfiltdata.h -tfilter.vbs -xfilter.x $(O)\filter.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\wmisamp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   wmisamp.c

Abstract:

    Sample device driver whose purpose is to show how to interface with
    the CDM provider and implement online and offline diagnostics
    

Environment:

    WDM, NT and Windows 98

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#include <wmistr.h>
#include <wmiguid.h>

#define OffsetToPtr(Base, Offset) ((PUCHAR)((PUCHAR)(Base) + (Offset)))

//
// These structures need to be defined by hand since they have varaible
// length elements and thus cannot be generated automatically by the
// mof checking tools
//
typedef struct
{
    BOOLEAN IsInUse;
	
    ULONG ResourcesUsedCount;

    ULONG CharacteristicsCount;
	
#define OtherCharacteristicNoReboot 0
#define OtherCharacteristicReboot 1

#define OfflineDiagnostic 0	
	
	ULONG OtherCharacteristic;

#define CharacteristicUnknown 0
#define	CharacteristicOther 1
#define CharacteristicIsExclusive 2
#define CharacteristicIsInteractive 3
#define CharacteristicIsDestructive 4
#define CharacteristicIsRisky 5
#define CharacteristicIsPackage 6
#define CharacteristicSupportsPercent 7
	
//    uint32 Characteristics[];

#define ResourceUsedCPU 0
#define ResourceUsedMemory 1 
#define ResourceUsedHardDisk 2
#define ResourceUsedCDROM 3
#define ResourceUsedFloppy 4
#define ResourceUsedPCIBus 5
#define ResourceUsedUSBBus 6
#define ResourceUsed1394Bus 7
#define ResourceUsedSCSIBus 8
#define ResourceUsedIDEBus 9
#define ResourceUsedNetwork 10
#define ResourceUsedISABus 11
#define ResourceUsedEISABus 12
#define ResourceUsedVESABus 13
#define ResourceUsedPCMCIABus 14
#define ResourceUsedCardBus 15
#define ResourceUsedAccessBus 16
#define ResourceUsedNuBus 17
#define ResourceUsedAGP 18
#define ResourceUsedVMEBus 19
#define ResourceUsedSbusIEEE1396_1993 20
#define ResourceUsedMCABus 21
#define ResourceUsedGIOBus 22
#define ResourceUsedXIOBus 23
#define ResourceUsedHIOBus 24
#define ResourceUsedPMCBus 25
#define ResourceUsedSIOBus 26
	
//    uint16 ResourcesUsed[];
	
    UCHAR VariableData[1];	
} DIAGNOSTIC_TEST, *PDIAGNOSTIC_TEST;

typedef struct
{
	ULONG Result;
	BOOLEAN TestingStopped;
} DISCONTINUE_TEST_OUT, *PDISCONTINUE_TEST_OUT;

enum RunDiscontinueTestResults
{
	// 0 = OK (function succeeded, but the test itself may have failed
	RunDiscontinueTestOk = 0,
	
	// 1 = Unspecified Error (function failed for unspecified reasons)
	RunDiscontinueTestUnspecifiedError = 1,
	
	// 2 = Not Implemented (function is not implemented for this instance 
	RunDiscontinueTestNotImplemented = 2,
							
	// 3 = Out Of Resources (component could not allocate required
	// resources, e.g. memory, disk space, etc.)
	RunDiscontinueTestOutOfResources = 3
};

NTSTATUS
FilterFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
FilterExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
FilterQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
FilterQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS FilterZwDeleteValueKey(
    HANDLE KeyHandle,
    PUNICODE_STRING ValueName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FilterQueryWmiRegInfo)
#pragma alloc_text(PAGE,FilterQueryWmiDataBlock)
#pragma alloc_text(PAGE,FilterExecuteWmiMethod)
#pragma alloc_text(PAGE,FilterFunctionControl)
#pragma alloc_text(PAGE,FilterPerformOfflineDiags)
#pragma alloc_text(PAGE,FilterZwDeleteValueKey)
#endif

//
// Create data structures for identifying the guids and reporting them to
// WMI. Since the WMILIB callbacks pass an index into the guid list we make
// definitions for the various guids indicies.
//
#define FilterDiagnosticClass 0
#define FilterOfflineDiagnosticClass 1
#define FilterDiagnosticSettingListClass 2
#define FilterOfflineResultsClass 3

GUID FilterDiagnosticClassGuid = MSSample_DiagnosticTestGuid;
GUID FilterOfflineDiagnosticClassGuid = MSSample_OfflineDiagnosticTestGuid;
GUID FilterDiagnosticSettingListGuid = MSSample_DiagnosticSettingListGuid;
GUID FilterOfflineResultsGuid = MSSample_OfflineResultGuid;

WMIGUIDREGINFO FilterGuidList[] =
{
    {
        &FilterDiagnosticClassGuid,			 // Guid
        1,							         // # of instances in each device
        WMIREG_FLAG_EXPENSIVE			     // Flag as expensive to collect
    },

    {
        &FilterOfflineDiagnosticClassGuid,	 // Guid
        1,							         // # of instances in each device
        0                    			     // Flag as expensive to collect
    },

    {
        &FilterDiagnosticSettingListGuid,			 // Guid
        1,							         // # of instances in each device
        0			                         // Flag as not expensive to collect
    },
	
    {
        &FilterOfflineResultsGuid,			 // Guid
        1,							         // # of instances in each device
        0			                         // Flag as not expensive to collect
    }
	
};

#define FilterGuidCount (sizeof(FilterGuidList) / sizeof(WMIGUIDREGINFO))

//
// We need to hang onto the registry path passed to our driver entry so that
// we can return it in the QueryWmiRegInfo callback.
//
UNICODE_STRING FilterRegistryPath;

NTSTATUS VA_SystemControl(
    struct DEVICE_EXTENSION *devExt,
    PIRP irp,
    PBOOLEAN passIrpDown
    )
/*++

Routine Description:

    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet
    *passIrpDown - returns with whether to pass irp down stack

Return Value:

    NT status code

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    wmilibContext = &devExt->WmiLib;

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for this device then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(wmilibContext,
                              devExt->filterDevObj,
                              irp,
                              &disposition);

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            *passIrpDown = FALSE;
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now.
            *passIrpDown = FALSE;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            *passIrpDown = TRUE;
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            *passIrpDown = TRUE;
            break;
        }
    }

    return(status);
}

NTSTATUS
FilterInitializeWmiDataBlocks(
    IN struct DEVICE_EXTENSION *devExt
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    devExt is device extension

Return Value:

--*/
{
    PWMILIB_CONTEXT wmilibInfo;

    //
    // Fill in the WMILIB_CONTEXT structure with a pointer to the
    // callback routines and a pointer to the list of guids
    // supported by the driver
    //
    wmilibInfo = &devExt->WmiLib;
    wmilibInfo->GuidCount = FilterGuidCount;
    wmilibInfo->GuidList = FilterGuidList;
    wmilibInfo->QueryWmiRegInfo = FilterQueryWmiRegInfo;
    wmilibInfo->QueryWmiDataBlock = FilterQueryWmiDataBlock;
    wmilibInfo->SetWmiDataBlock = NULL;
    wmilibInfo->SetWmiDataItem = NULL;
    wmilibInfo->ExecuteWmiMethod = FilterExecuteWmiMethod;
    wmilibInfo->WmiFunctionControl = FilterFunctionControl;

    return(STATUS_SUCCESS);
}

NTSTATUS
FilterQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose registration info is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. The caller
         does NOT free this buffer.

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL. The caller does NOT free this
        buffer.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;

    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    *RegistryPath = &FilterRegistryPath;

    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    RtlInitUnicodeString(MofResourceName, L"MofResourceName");

    //
    // Specify that the driver wants WMI to automatically generate instance
    // names for all of the data blocks based upon the device stack's
    // device instance id. Doing this is STRONGLY recommended since additional
    // information about the device would then be available to callers.
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *Pdo = devExt->physicalDevObj;

    return(STATUS_SUCCESS);
}

NTSTATUS
FilterQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. If the driver can satisfy the query within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the query is satisfied.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG sizeNeeded;

    switch(GuidIndex)
    {
		//
		// Online diagnostic test
		//
        case FilterDiagnosticClass:
        {
            sizeNeeded = FIELD_OFFSET(DIAGNOSTIC_TEST, VariableData) +
						 2 * sizeof(ULONG) + // 2 characteristics
						 2 * sizeof(USHORT); // 3 resources used
			
            if (BufferAvail >= sizeNeeded)
            {
				PDIAGNOSTIC_TEST diagTest = (PDIAGNOSTIC_TEST)Buffer;
				PULONG characteristics;
				PUSHORT resources;
				ULONG offset;

				diagTest->IsInUse = FALSE;
				diagTest->ResourcesUsedCount = 2;
				diagTest->CharacteristicsCount = 2;

				offset = FIELD_OFFSET(DIAGNOSTIC_TEST, VariableData);
				characteristics = (PULONG)OffsetToPtr(diagTest, offset);
				offset += 2 * sizeof(ULONG);
				resources = (PUSHORT)OffsetToPtr(diagTest, offset);

				characteristics[0] = CharacteristicIsInteractive;
				characteristics[1] = CharacteristicOther;
				diagTest->OtherCharacteristic = OtherCharacteristicNoReboot;

				resources[0] = ResourceUsedCPU;
				resources[1] = ResourceUsedMemory;
								
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
			}
            break;
        }

		//
		// Offline diagnostic test
		//
		case FilterOfflineDiagnosticClass:
		{
            sizeNeeded = FIELD_OFFSET(DIAGNOSTIC_TEST, VariableData) +
						 2 * sizeof(ULONG) + // 2 characteristics
						 2 * sizeof(USHORT); // 3 resources used
			
            if (BufferAvail >= sizeNeeded)
            {
				PDIAGNOSTIC_TEST diagTest = (PDIAGNOSTIC_TEST)Buffer;
				PULONG characteristics;
				PUSHORT resources;
				ULONG offset;

				diagTest->IsInUse = FALSE;
				diagTest->ResourcesUsedCount = 2;
				diagTest->CharacteristicsCount = 2;

				offset = FIELD_OFFSET(DIAGNOSTIC_TEST, VariableData);
				characteristics = (PULONG)OffsetToPtr(diagTest, offset);
				offset += 2 * sizeof(ULONG);
				resources = (PUSHORT)OffsetToPtr(diagTest, offset);

				characteristics[0] = CharacteristicIsInteractive;
				characteristics[1] = CharacteristicOther;
				diagTest->OtherCharacteristic = OfflineDiagnostic;

				resources[0] = ResourceUsedCPU;
				resources[1] = ResourceUsedMemory;
								
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
			}
            break;
		}

		//
		// This has the list of valid settings for running the online
		// or offline diagnostic tests. Note that you could have a
		// different setting list for the online and offline tests. To
		// do this you'd need to implement a different SettingList
		// datablock and class
		//
		case FilterDiagnosticSettingListClass:
		{
			PMSSample_DiagnosticSettingList DiagSettingList;
			ULONG i;
			
            sizeNeeded = FIELD_OFFSET(MSSample_DiagnosticSettingList,
									  SettingList) +
						 3 * sizeof(MSSample_DiagnosticSetting);
			
            if (BufferAvail >= sizeNeeded)
            {
				DiagSettingList = (PMSSample_DiagnosticSettingList)Buffer;
				DiagSettingList->SettingCount = 3;

				for (i = 0; i < 3; i++)
				{
					DiagSettingList->SettingList[i].TestWarningLevel = (USHORT)i+1;
					DiagSettingList->SettingList[i].ReportSoftErrors = (i % 1) == 1 ?
						                                                  TRUE :
						                                                  FALSE;
					DiagSettingList->SettingList[i].ReportStatusMessages = (i % 1) == 1 ?
						                                                  TRUE :
						                                                  FALSE;
					DiagSettingList->SettingList[i].HaltOnError = (i % 1) == 0 ?
						                                                  TRUE :
						                                                  FALSE;
					DiagSettingList->SettingList[i].QuickMode = (i % 1) == 0 ?
						                                                  TRUE :
						                                                  FALSE;
					DiagSettingList->SettingList[i].PercentOfTestCoverage = 100;
						
				}
                *InstanceLengthArray = sizeNeeded;
				status = STATUS_SUCCESS;
			} else {
				status = STATUS_BUFFER_TOO_SMALL;
			}
			
			break;
		}

		//
		// This class returns the results of the offline diagnostic
		// test that was run at device start time. There needs to be
		// one results data block for each offline diagnostic test that
		// could be run.
		//
		case FilterOfflineResultsClass:
		{
			PMSSample_DiagnosticResult diagResult;
			USHORT executionIDSize, executionIDSizePad4;

			//
			// Here we are queried for the results from the offline
			// test execution. If offline diags weren't run at start
			// then we return guid not found
			//
			if (devExt->OfflineTestResult != 0)
			{
				//
				// We return the execution ID string padded out to 4
				// bytes followed by a result data block
				//
				executionIDSize = *((PUSHORT)devExt->ExecutionID) + sizeof(USHORT);
				executionIDSizePad4 = (executionIDSize + 3) & ~3;
				sizeNeeded = executionIDSizePad4 +
							 sizeof(MSSample_DiagnosticResult);
				if (BufferAvail >= sizeNeeded)
				{
					RtlCopyMemory(Buffer,
								  &devExt->ExecutionID,
								  executionIDSize);
					diagResult = (PMSSample_DiagnosticResult)(Buffer + executionIDSizePad4);
					diagResult->EstimatedTimeOfPerforming = 0;
					diagResult->TestState = TestStateOther;
					diagResult->OtherStateDescription = OtherTestStatePassWithFlyingColors;
					diagResult->PercentComplete = 100;
					diagResult->TestResultsCount = 1;
					diagResult->TestResults[0] = devExt->OfflineTestResult;
					*InstanceLengthArray = sizeNeeded;
					status = STATUS_SUCCESS;
				} else {
					status = STATUS_BUFFER_TOO_SMALL;
				}
			} else {
				status = STATUS_WMI_GUID_NOT_FOUND;
			}

			break;
		}

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    //
    // Complete the irp. If there was not enough room in the output buffer
    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size
    // needed to return all of the data. If there was enough room then
    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes
    // being returned.
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

ULONG FilterRunDiagnostic(
    PMSSample_DiagnosticSetting DiagSetting,
    PMSSample_DiagnosticResult DiagResult
    )
{
	//
	// Here is where we can run the online diagnostic test. In this sample we
	// simply return that the diagnostic ran successfully, however more
	// sophisticated diagnostics will want to do more.
	//

	//
	// Now build the diagnostic results to return. Note that the diag
	// results are in the same memory as the diagnostic settings so
	// once we start writing the results the settings are overwritten.
	//
	DiagResult->EstimatedTimeOfPerforming = 1;
	DiagResult->TestState = TestStateOther;
	DiagResult->OtherStateDescription = OtherTestStatePassWithFlyingColors;
	DiagResult->PercentComplete = 100;
	DiagResult->TestResultsCount = 2;
	DiagResult->TestResults[0] = TestResultPassHappy;
	DiagResult->TestResults[1] = TestResultPassSad;
	
	return(RunDiscontinueTestOk);
}

ULONG FilterComputeDiagResultSize(
    PMSSample_DiagnosticSetting DiagSetting
    )
{

	//
	// Based upon the test settings that are passed to run the test we
	// compute how large an output buffer is needed so to return the
	// diagnostic results. It is important that we do this before
	// running the test since we do not want to run the test and then
	// realize that we cannot return the complete results. In the case
	// of the sample driver the size to be returned is fixed.
	//
	
	return(FIELD_OFFSET(MSSample_DiagnosticResult, TestResults) +
		    2 * sizeof(ULONG));
}

NTSTATUS
FilterOfflineRunTest(
	IN struct DEVICE_EXTENSION * devExt,
    IN PUCHAR Buffer,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    OUT ULONG *sizeNeeded
    )
{
	HANDLE keyHandle;
	UNICODE_STRING valueName;
	PMSSample_RunTestOut runTestOut;
	PULONG resultStatus;
	PMSSample_DiagnosticSetting diagSetting;
	PMSSample_DiagnosticResult diagResult;
	USHORT executionIDSize;
	ULONG inSizeNeeded;
	NTSTATUS status;

	if (InBufferSize >= sizeof(USHORT))
	{
		//
		// The input buffer is a string followed by a diagnostic
		// setting class. Make sure that the input buffer size is setup
		// correctly.
		//
		executionIDSize = *((PUSHORT)Buffer) + sizeof(USHORT);
		inSizeNeeded = executionIDSize + sizeof(MSSample_DiagnosticSetting);

		if (InBufferSize == inSizeNeeded)
		{
			diagSetting = (PMSSample_DiagnosticSetting)(Buffer + executionIDSize);
					
			runTestOut = (PMSSample_RunTestOut)Buffer;					
			resultStatus = &runTestOut->Result;
			diagResult = &runTestOut->DiagResult;
					
			*sizeNeeded = sizeof(MSSample_RunTestOut);
			if (OutBufferSize >= *sizeNeeded)
			{
				//
				// Ok we have been asked to perform a
				// diagnostic that requires the device being
				// taken offline so we save the settings for
				// the test off and then the next time the
				// device is started we run the test and report
				// the results
				//
				status = IoOpenDeviceRegistryKey(devExt->physicalDevObj,
					                             PLUGPLAY_REGKEY_DEVICE,
					                             KEY_READ |
					                             KEY_WRITE,
					                             &keyHandle);

				if (NT_SUCCESS(status))
				{
					//
					// We just write out to this value blindly,
					// but we need to be careful as this key is
					// shared by all drivers in the stack so
					// there is a possibility of collision in
					// case the FDO or PDO might also want to
					// store diagnostic info
					//
					RtlInitUnicodeString(&valueName, L"OfflineSetting");
					status = ZwSetValueKey(keyHandle,
										   &valueName,
										   0,
										   REG_BINARY,
										   Buffer,
										   InBufferSize);
					if (NT_SUCCESS(status))
					{
						//
						// Now fill out the diag results
						// structure to indicate that the test
						// is pending
						//
						diagResult->EstimatedTimeOfPerforming = 0;
						diagResult->TestState = TestStateOther;
						diagResult->OtherStateDescription = OfflinePendingExecution;
						diagResult->PercentComplete = 0;
						diagResult->TestResultsCount = 0;
						*resultStatus = RunDiscontinueTestOk;
					}
					ZwClose(keyHandle);
				}
				
			} else {
				status = STATUS_BUFFER_TOO_SMALL;
			}
		} else {
			status = STATUS_INVALID_PARAMETER;
		}
	} else {
		status = STATUS_INVALID_PARAMETER;
	}
	return(status);
}


NTSTATUS
FilterExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. If
    the driver can complete the method within the callback it should
    call WmiCompleteRequest to complete the irp before returning to the
    caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device whose method is being executed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the input buffer on entry and returns with
         the output data block

Return Value:

    status

--*/
{
    ULONG sizeNeeded = 0;
    NTSTATUS status;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;

	PAGED_CODE();
	
    if (GuidIndex == FilterDiagnosticClass)
    {
        switch(MethodId)
        {
            case RunTest:
            {				
				PMSSample_RunTestOut runTestOut;
				PULONG resultStatus;
				PMSSample_DiagnosticSetting diagSetting;
				PMSSample_DiagnosticResult diagResult;
				USHORT executionIDSize;
				ULONG inSizeNeeded;

				//
				// The input buffer is a string followed by a diagnostic
				// setting class. Make sure that the input buffer size is setup
				// correctly.
				//
				if (InBufferSize >= sizeof(USHORT))
				{
					executionIDSize = *((PUSHORT)Buffer) + sizeof(USHORT);
					inSizeNeeded = executionIDSize + sizeof(MSSample_DiagnosticSetting);

					if (InBufferSize == inSizeNeeded)
					{
						diagSetting = (PMSSample_DiagnosticSetting)(Buffer + executionIDSize);

						runTestOut = (PMSSample_RunTestOut)Buffer;					
						resultStatus = &runTestOut->Result;
						diagResult = &runTestOut->DiagResult;

						sizeNeeded = sizeof(ULONG) + FilterComputeDiagResultSize(diagSetting);
						if (OutBufferSize >= sizeNeeded)
						{
							*resultStatus = FilterRunDiagnostic(diagSetting,
																diagResult);
							status = STATUS_SUCCESS;
						} else {
							status = STATUS_BUFFER_TOO_SMALL;
						}
					} else {
						status = STATUS_INVALID_PARAMETER;
					}
				} else {
					status = STATUS_INVALID_PARAMETER;
				}
                break;
            }

            case DiscontinueTest:
            {
				PDISCONTINUE_TEST_OUT discTestOut;

				sizeNeeded = sizeof(DISCONTINUE_TEST_OUT);
				if (OutBufferSize >= sizeNeeded)
				{

					//
					// Right here we could make an attempt to stop a
					// test that is currently being executed, however
					// our test is very quick so it does not make
					// sense. If your driver has a test that takes a
					// long time to complete then it is possible to put
					// a checkpoint into your test and signal it from
					// here.
					//					
					discTestOut = (PDISCONTINUE_TEST_OUT)Buffer;
					discTestOut->Result = RunDiscontinueTestNotImplemented;
					discTestOut->TestingStopped = FALSE;
					status = STATUS_SUCCESS;
				} else {
					status = STATUS_BUFFER_TOO_SMALL;
				}
				
				break;
			}
			
            default:
            {
                status = STATUS_WMI_ITEMID_NOT_FOUND;
            }
        }
	} else if (GuidIndex == FilterOfflineDiagnosticClass) {
        switch(MethodId)
        {
            case RunTest:
            {
				status = FilterOfflineRunTest(devExt,
											  Buffer,
											  InBufferSize,
											  OutBufferSize,
											  &sizeNeeded);

				
                break;
            }

            case DiscontinueTest:
            {
				PDISCONTINUE_TEST_OUT discTestOut;
				HANDLE keyHandle;
				UNICODE_STRING valueName;

				sizeNeeded = sizeof(DISCONTINUE_TEST_OUT);
				if (OutBufferSize >= sizeNeeded)
				{

					//
					// Right here we are asked to discontinue execution
					// of the offline test. All we need to do is make
					// sure that the registry value is deleted
					//

					status = IoOpenDeviceRegistryKey(devExt->physicalDevObj,
													 PLUGPLAY_REGKEY_DEVICE,
													 KEY_READ,
													 &keyHandle);

					if (NT_SUCCESS(status))
					{
						//
						// We just read from this value blindly,
						// but we need to be careful as this key is
						// shared by all drivers in the stack so
						// there is a possibility of collision in
						// case the FDO or PDO might also want to
						// use something unique to this driver to store
						// diagnostic info
						//
						RtlInitUnicodeString(&valueName, L"OfflineSetting");
						FilterZwDeleteValueKey(keyHandle,
										 &valueName);
						ZwClose(keyHandle);
					}

					discTestOut = (PDISCONTINUE_TEST_OUT)Buffer;
					discTestOut->Result = RunDiscontinueTestOk;
					discTestOut->TestingStopped = TRUE;
					status = STATUS_SUCCESS;
				} else {
					status = STATUS_BUFFER_TOO_SMALL;
				}
				
				break;
			}
			
            default:
            {
                status = STATUS_WMI_ITEMID_NOT_FOUND;
            }
        }
    } else  {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
FilterFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it. If the driver can complete enabling/disabling within the callback it
    should call WmiCompleteRequest to complete the irp before returning to
    the caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device object

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status;

	PAGED_CODE();
	
    switch(GuidIndex)
    {
        case FilterDiagnosticClass:
        {
			if (Enable)
			{
				//
				// A consumer has just indicated interest in accessing
				// information about the FilterDiagnosticClass, most
				// likely it will want to query the class and execute
				// methods in it. If there is anything that needs to be
				// done such as setting up hardware, enabling counters,
				// etc before the class is queried or executed then
				// this is the place to do it. Note that only one
				// enable will be sent regardless of the number of
				// consumers who want to access the class.
				//
				status = STATUS_SUCCESS;
			} else {
				//
				// The last consumer has just indicated that it is no
				// longer interested in this class and so the class
				// will no longer be queried or its methods executed.
				// If there is anything that needs to be done such as
				// resetting hardware or stopping counters, etc then it
				// should be done here. Note that only one disable will
				// be sent regardless of the number of consumers who
				// previous used the class. 
			}
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}

NTSTATUS FilterPerformOfflineDiags(
    struct DEVICE_EXTENSION *devExt
    )
{
	UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
			     MAXEXECUTIONIDSIZE + sizeof(MSSample_DiagnosticSetting)];
	PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInfo;
	ULONG  infoSize;
	NTSTATUS status;
	HANDLE keyHandle;
	PMSSample_DiagnosticSetting diagSetting;
	UNICODE_STRING valueName;
	USHORT executionIDSize;

	PAGED_CODE();
	
	//
	// If registry has stuff then run test, else return
	//
	
	status = IoOpenDeviceRegistryKey(devExt->physicalDevObj,
									 PLUGPLAY_REGKEY_DEVICE,
									 KEY_READ,
									 &keyHandle);

	if (NT_SUCCESS(status))
	{
		//
		// We just read from this value blindly,
		// but we need to be careful as this key is
		// shared by all drivers in the stack so
		// there is a possibility of collision in
		// case the FDO or PDO might also want to
		// use something unique to this driver to store
		// diagnostic info
		//
		RtlInitUnicodeString(&valueName, L"OfflineSetting");

		keyValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
		infoSize = sizeof(buffer);
		status = ZwQueryValueKey(keyHandle,
								 &valueName,
								 KeyValuePartialInformation,
								 keyValuePartialInfo,
								 infoSize,
								 &infoSize);
						 
		if ((NT_SUCCESS(status)) &&
			 (keyValuePartialInfo->Type == REG_BINARY) &&
		     (keyValuePartialInfo->DataLength != 0))
		{
			//
			// We successfully read the diagnostics settings for the
			// offline test. First thing we do is delete the value so
			// that in case the the diagnostic test causes a problem
			// then it won't be run in the next time the device starts
			// up
			//
			FilterZwDeleteValueKey(keyHandle,
							 &valueName);

			//
			// Here is where we run our offline test. Remember the
			// Execution ID tag as we'll need to give that back to
			// the CDM provider
			//
			devExt->OfflineTestResult = TestResultPassSad;
			executionIDSize = *((PUSHORT)(keyValuePartialInfo->Data)) + sizeof(USHORT);
			RtlCopyMemory(&devExt->ExecutionID,
						  keyValuePartialInfo->Data,
						  executionIDSize);
		}
		ZwClose(keyHandle);
	}
	return(status);
}

NTSTATUS FilterZwDeleteValueKey(
    HANDLE KeyHandle,
    PUNICODE_STRING ValueName
    )
{
	NTSTATUS status;
	
	//
	// Since we do not have ZwDeleteValueKey as a proper WDM function
	// then we try to make one up. What we do is to set the value to an
	// empty REG_BINARY
	//
	status = ZwSetValueKey(KeyHandle,
						   ValueName,
						   0,
						   REG_BINARY,
						   NULL,
						   0);
	return(status);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: CDM Provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <wbemprov.h>

#include "debug.h"
#include "useful.h"
#include "testinfo.h"
#include "sample.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
	LONG cRef;

	cRef = m_cRef+1;
	
	InterlockedIncrement((LPLONG)&m_cRef);
	
    return (cRef);
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CClassPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CClassPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_PnP, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 

    switch (irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            DBGOUT(("START_DEVICE")); 

            devExt->state = STATE_STARTING;

            /*
             *  First, send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(devExt, irp);

            if (NT_SUCCESS(status)){
				//
				// Here is were we have an opportunity to run any
				// offline diagnostics that may have been queued up
				//
				FilterPerformOfflineDiags(devExt);
				
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(devExt);
                if (NT_SUCCESS(status)){
                    devExt->state = STATE_STARTED;
                    /*
                     * Now that device is started, register with WMI
                    */
                    IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_REGISTER);
                }
                else {
                    devExt->state = STATE_START_FAILED;
                }
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            break;

        case IRP_MN_STOP_DEVICE:
            if (devExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (devExt->state == STATE_STARTED){
                    devExt->state = STATE_STOPPED;
                }
            }
            break;
      
        case IRP_MN_QUERY_REMOVE_DEVICE:
            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            DBGOUT(("SURPRISE_REMOVAL")); 

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            devExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            DBGOUT(("REMOVE_DEVICE")); 
            if (devExt->state != STATE_REMOVED){

                devExt->state = STATE_REMOVED;

                /*
                 *  Send the REMOVE IRP down the stack asynchronously.
                 *  Do not synchronize sending down the REMOVE_DEVICE
                 *  IRP, because the REMOVE_DEVICE IRP must be sent
                 *  down and completed all the way back up to the sender
                 *  before we continue.
                 */
                IoCopyCurrentIrpStackLocationToNext(irp);
                status = IoCallDriver(devExt->physicalDevObj, irp);
                justReturnStatus = TRUE;

                DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                        devExt->pendingActionCount));  

                /*
                 *  We must for all outstanding IO to complete before
                 *  completing the REMOVE_DEVICE IRP.
                 *
                 *  First do an extra decrement on the pendingActionCount.
                 *  This will cause pendingActionCount to eventually
                 *  go to -1 once all asynchronous actions on this
                 *  device object are complete.
                 *  Then wait on the event that gets set when the
                 *  pendingActionCount actually reaches -1.
                 */
                DecrementPendingActionCount(devExt);
                KeWaitForSingleObject(  &devExt->removeEvent,
                                        Executive,      // wait reason
                                        KernelMode,
                                        FALSE,          // not alertable
                                        NULL );         // no timeout

                DBGOUT(("REMOVE_DEVICE - ... DONE waiting. ")); 

                /*
                 *  Now that the device is going away unregister with WMI
                 *  Note that we wait until all WMI irps are completed
                 *  before unregistering since unregistering will block
                 *  until all WMI irps are completed.
                 */
                IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_DEREGISTER);
	
                /*
                 *  Detach our device object from the lower 
                 *  device object stack.
                 */
                IoDetachDevice(devExt->topDevObj);

                /*
                 *  Delete our device object.
                 *  This will also delete the associated device extension.
                 */
                IoDeleteDevice(devExt->filterDevObj);
            }
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        default:
            break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack asynchronously.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->physicalDevObj, irp);
    }

    return status;
}





NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->physicalDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\classprov.cpp ===
//***************************************************************************
//
//  CLASSPRO.CPP
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <wbemprov.h>
#include <process.h>

#include <unknwn.h>
#include "debug.h"
#include "wbemmisc.h"
#include "useful.h"
#include "testinfo.h"
#include "sample.h"


// CONSIDER: Does this really need to stay a global ???
//
// This is the global list of all of the CIM classes and their
// corresponsing WDM classes that are managed by the provider.
//
// It is maintained as a global since WinMgmt is aggressive in
// releasing the CClassProv, but we really want to maintain the result
// objects and do not want to be unloaded unless all result objects are
// cleared.
//
CWdmClass *WdmClassHead;

void CleanupAllClasses(
    )
{
    CWdmClass *WdmClass;
    CWdmClass *WdmClassNext;

    //
    // Loop over all classes that were supported by the provider and
    // clean them up
    //
    WdmClass = WdmClassHead;  
    while (WdmClass != NULL)
    {
        WdmClassNext = WdmClass->GetNext();
        delete WdmClass;
    }
}

//***************************************************************************
//
// CClassPro::CClassPro
// CClassPro::~CClassPro
//
//***************************************************************************

CClassPro::CClassPro(
    BSTR ObjectPath,
    BSTR User,
    BSTR Password,
    IWbemContext * pCtx
    )
{
    m_pCimServices = NULL;
    m_cRef=0;
	InterlockedIncrement(&g_cObj);
    return;
}

CClassPro::~CClassPro(void)
{   
    if(m_pCimServices)
    {
        m_pCimServices->Release();
    }
    InterlockedDecrement(&g_cObj);
    
    return;
}

//***************************************************************************
//
// CClassPro::QueryInterface
// CClassPro::AddRef
// CClassPro::Release
//
// Purpose: IUnknown members for CClassPro object.
//***************************************************************************


STDMETHODIMP CClassPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
    {
       *ppv=(IWbemServices*)this;
    }

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
    {
       *ppv=(IWbemProviderInit*)this;
    }
    

    if (NULL!=*ppv)
    {
        AddRef();
        hr = NOERROR;
    }
    else {
        hr = E_NOINTERFACE;
    }
    
    return(hr);
}


STDMETHODIMP_(ULONG) CClassPro::AddRef(void)
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CClassPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
    {
        delete this;
    }
    
    return(nNewCount);
}

/***********************************************************************
*                                                                      *
*   CClassPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CClassPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if (pNamespace)
    {
        pNamespace->AddRef();
    }
        
    m_pCimServices = pNamespace;

    //
    // Let CIMOM know you are initialized
    //
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    
    return(WBEM_S_NO_ERROR);
}

//***************************************************************************
//
// CClassPro::CreateClassEnumAsync
//
// Purpose: Asynchronously enumerates the classes this provider supports.  
// Note that this sample only supports one.  
//
//***************************************************************************

SCODE CClassPro::CreateClassEnumAsync(
    const BSTR Superclass, long lFlags, 
    IWbemContext  *pCtx,
    IWbemObjectSink *pHandler
    )
{
    return(WBEM_E_NOT_SUPPORTED);
}

//***************************************************************************
//
// CClassPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CClassPro::CreateInstanceEnumAsync(
    const BSTR ClassName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemObjectSink FAR* pHandler
)
{
    HRESULT hr;
    ULONG i, Count;
    IWbemClassObject *pCimInstance;
    CWdmClass *WdmClass;
	
    WmipDebugPrint(("CDMPROV: Enumerate instances of class %ws\n",
                    ClassName));
    
    //
    // Do a check of arguments and make sure we have pointer to Namespace
    //
    if (pHandler == NULL || m_pCimServices == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Obtain a wdm class object that represents this class
    //
    hr = LookupWdmClass(pCtx,
						ClassName,
                        &WdmClass);


    if (hr == WBEM_S_NO_ERROR)
    {
		if (WdmClass->IsInstancesAvailable())
		{
			Count = WdmClass->GetInstanceCount();
			for (i = 0; i < Count; i++)
			{
				pCimInstance = WdmClass->GetCimInstance(i);
				//
				// Send the object to the caller
				//
				hr = pHandler->Indicate(1, &pCimInstance);
			}
		}
    }

	//
	// TODO: Create extended error object with more info about the
	// error that occured. The object is created by
	// CreateInst("__ExtendedStatus")
	//

    pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    return(hr);
}


//***************************************************************************
//
// CClassPro::GetObjectByPathAsync
//
// Purpose: Returns either an instance or a class.
//
//***************************************************************************



SCODE CClassPro::GetObjectAsync(
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext  *pCtx,
    IWbemObjectSink FAR* pHandler
    )
{

    HRESULT hr;
    IWbemClassObject FAR* Instance;

    // Do a check of arguments and make sure we have pointer to Namespace

    if (ObjectPath == NULL || pHandler == NULL || m_pCimServices == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
	
	hr = GetByPath(pCtx, ObjectPath, &Instance);
    if (hr == WBEM_S_NO_ERROR)
    {
        WmipDebugPrint(("CDMProv: Found instance %p for relpath %ws\n",
                        Instance, ObjectPath));
        hr = pHandler->Indicate(1, &Instance);
    } else {
        WmipDebugPrint(("CDMProv: Did not find instance for relpath %ws\n",
                        ObjectPath));
        hr = WBEM_E_NOT_FOUND;
    }

    // Set Status

    pHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    return(hr);
}
 
//***************************************************************************
//
// CClassPro::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//          All objects returned are assumed to be AddRefed
//
//***************************************************************************

HRESULT CClassPro::GetByPath(
    IWbemContext  *pCtx,
    BSTR ObjectPath,
    IWbemClassObject **Instance
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;   
    WCHAR ClassName[MAX_PATH+1];
    WCHAR *p;
    int iNumQuotes = 0;
    int i, Count;
    CWdmClass *WdmClass;
    BSTR s;

    //
    // This is where we are queried for a class based upon its relpath.
    // We need to parse the relpath to get the class name and then look
    // at the relpath to determine which instance of the class we are
    // interested in and then build up the instance and return it
    //
    //

    //
    // Obtain the class name by copying up to the .
    //
    for (p = ObjectPath, i = 0;
         (*p != 0) && (*p != L'.') && (i < MAX_PATH);
         p++, i++)
    {
        ClassName[i] = *p;
    }

    if (*p != L'.') 
    {
        //
        // If we did end our loop with a . then we failed to parse
        // properly
        //
        WmipDebugPrint(("CDMPROV: Unable to parse relpath %ws at %ws, i = %d\n",
                        ObjectPath, p, i));
    }
    
    ClassName[i] = 0;

    WmipDebugPrint(("CDMPROV: Class %ws looking for relpath %ws\n",
                    ClassName, ObjectPath));
    
    //
    // Obtain a Wdm class that represents this classname
    //
    hr = LookupWdmClass(pCtx,
						ClassName,
                        &WdmClass);

    if (hr == WBEM_S_NO_ERROR)
    {
		if (WdmClass->IsInstancesAvailable())
		{
			//
			// Assume that we will not find the object instance
			//
			hr = WBEM_E_NOT_FOUND;

			Count = WdmClass->GetInstanceCount();
			for (i = 0; i < Count; i++)
			{
				if (_wcsicmp(ObjectPath,
							 WdmClass->GetCimRelPath(i)) == 0)
				{
					*Instance = WdmClass->GetCimInstance(i);
					hr = WBEM_S_NO_ERROR;
					break;
				}
			}
		} else {
			hr = WBEM_E_FAILED;
		}
    }

    return(hr);
}


/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named Echo.  It   * 
*         takes an input string, copies it to the output and returns the* 
*         length.                                                       *
*                                                                       *
*                                                                       *
************************************************************************/

STDMETHODIMP CClassPro::ExecMethodAsync(
    const BSTR ObjectPath,
    const BSTR MethodName, 
    long lFlags,
    IWbemContext* pCtx,
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink
    )
{   
    HRESULT hr, hrDontCare;    
    IWbemClassObject * pMethodClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    WCHAR ClassName[MAX_PATH];
    WCHAR *p;
    VARIANT v, vRetVal;
    int RelPathIndex;
    CWdmClass *WdmClass;
	BSTR WdmObjectPath;

    VariantInit(&v);
    VariantInit(&vRetVal);
    
    //
    // Extract this class name from the object path
    //
    wcscpy(ClassName, ObjectPath);
    p = ClassName;
    while ((*p != 0) && (*p != L'.'))
    {
        p++;
    }
    *p = 0;

    WmipDebugPrint(("CDMPROV: Exec method %ws for instanec %ws\n",
                    MethodName, ObjectPath));

    //
    // Obtain a Wdm class that represents this ClassName
    //
    hr = LookupWdmClass(pCtx,
						ClassName,
						&WdmClass);
    
    if (hr == WBEM_S_NO_ERROR)
    {
		if (WdmClass->IsInstancesAvailable())
		{
			hr = WdmClass->GetIndexByCimRelPath(ObjectPath, &RelPathIndex);
			if (hr == WBEM_S_NO_ERROR)
			{
				WdmObjectPath = WdmClass->GetWdmRelPath(RelPathIndex);

				//
				// CONSIDER: Do we need to do any processing on the input
				// or output parameter objects ??
				//

				hr = WdmClass->GetWdmServices()->ExecMethod(WdmObjectPath,
																 MethodName,
																 lFlags,
																 pCtx,
																 pInParams,
					                                             &pOutParams,
																 NULL);

				if ((hr == WBEM_S_NO_ERROR) && (pOutParams != NULL))
				{					
					pResultSink->Indicate(1, &pOutParams);
					pOutParams->Release();
				}
				
			}
		}
    }

    pResultSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL,NULL);
    
    return(hr);
}

//
// TODO: Implement setting and deletion
//
SCODE CClassPro::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}
 
SCODE CClassPro::DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}
SCODE CClassPro::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResultsSink)
{
	HRESULT hr;
	CWdmClass *WdmClass;
	VARIANT Values[2];
	PWCHAR Names[2];
	CIMTYPE Types[2];
	int RelPathIndex;	
	
    if (pInst == NULL || pResultsSink == NULL )
    {
	    return WBEM_E_INVALID_PARAMETER;
    }

	//
	// Get the class name
	//
	Names[0] = L"__CLASS";
	Types[0] = CIM_STRING;
	
	Names[1] = L"__RELPATH";
	Types[1] = CIM_REFERENCE;
	
	hr = WmiGetPropertyList(pInst,
							2,
							Names,
							Types,
							Values);

	if (hr == WBEM_S_NO_ERROR)
	{
		hr = LookupWdmClass(pCtx,
							Values[0].bstrVal,
							&WdmClass);
		
		
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// We need to pull out the properties from the instance
			// passed to us, do any mapping to WDM properties and then
			// set them in the WDM instance
			//
            hr = WdmClass->GetIndexByCimRelPath(Values[1].bstrVal,
												&RelPathIndex);
			
			if (hr == WBEM_S_NO_ERROR)
			{
				hr = WdmClass->PutInstance(pCtx,
										   RelPathIndex,
										   pInst);
			}
			
		}
		
		VariantClear(&Values[0]);
		VariantClear(&Values[1]);
	}
	
    pResultsSink->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL,NULL);
	
	return(hr);
}
SCODE CClassPro::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    return(WBEM_E_NOT_SUPPORTED);
}

CWdmClass *CClassPro::FindExistingWdmClass(
	PWCHAR CimClassName
	)
{
	
	CWdmClass *WdmClass;

	//
	// This routine assumes any sync mechanism has been done outside of
	// this routine
	//
    WdmClass = WdmClassHead;
    while (WdmClass != NULL)
    {
        if (WdmClass->ClaimCimClassName(CimClassName))
        {
            //
            // We found an existing test services for this class.
            //
            return(WdmClass);
        }
        WdmClass = WdmClass->GetNext();
    }
	return(NULL);
}

HRESULT CClassPro::LookupWdmClass(
    IWbemContext *pCtx,
    const BSTR CimClassName,
    CWdmClass **WdmClassPtr
    )
{
    HRESULT hr;
    CWdmClass *WdmClass, *OtherWdmClass;
            
    WmipAssert(CimClassName != NULL);
    WmipAssert(WdmClassPtr != NULL);
    
    //
    // Look up the class name and find the Wdm Test Services
    // class that represents it. 
    //

	EnterCritSection();
	WdmClass = FindExistingWdmClass(CimClassName);
	LeaveCritSection();
	
	if (WdmClass != NULL)
	{
		//
		// CONSIDER: Refresh instances from WDM back into CIM
		//
		*WdmClassPtr = WdmClass;
		return(WBEM_S_NO_ERROR);
	}
	        
    //
    // If the WDM test services has not yet been initialized for this
    // CDM diagnostic classes then go ahead and do so
    //
    WdmClass = new CWdmClass();

	hr = WdmClass->InitializeSelf(pCtx, CimClassName);

	if (hr == WBEM_S_NO_ERROR)
	{

		//
		// Now check to see if another thread created and inserted the
		// test services for the class while we were trying to
		// initialize it. Since we want only one test services we throw
		// ours away and use the other
		//
		EnterCritSection();
		OtherWdmClass = FindExistingWdmClass(CimClassName);

		if (OtherWdmClass == NULL)
		{
			//
			// Horray, we win do insert our own test into list
			//
			WdmClass->InsertSelf(&WdmClassHead);
			LeaveCritSection();
			
			hr = WdmClass->RemapToCimClass(pCtx);

			//
			// Decrement the counter to indicate that instances are
			// available. This refcount was assigned in the constructor
			//
			WdmClass->DecrementMappingInProgress();
			
			if (hr != WBEM_S_NO_ERROR)
			{
				WmipDebugPrint(("CDMPROV: Inited failed %x for %p for %ws\n",
								hr, WdmClass, CimClassName));
			}
		} else {
			//
			// We lost, so use existing test services
			//
			WmipDebugPrint(("CDMPROV: WdmClass %p lost insertion race to %p\n",
							WdmClass, OtherWdmClass));
			LeaveCritSection();
			delete WdmClass;
			WdmClass = OtherWdmClass;
		}

		*WdmClassPtr = WdmClass;

	}
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->physicalDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}



VOID RegistryAccessSample(PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&keyName, L"SampleFilterParam"); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = ExAllocatePoolWithTag(   PagedPool,
                                                keyValueTotalSize,
                                                FILTER_TAG);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &keyName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){
                ULONG value;

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                value = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DBGOUT(("RegistryAccessSample: value is %xh.", value));
            }
            else {
                DBGOUT(("ZwQueryValueKey failed with %xh.", status));
            }
	    
	    ExFreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cdmprov\driver\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"



NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

    Note: We may or may not have set the DO_POWER_PAGABLE bit
          for the filter device object in AddDevice().
          Therefore, we don't know whether or not this function
          can be called at DISPATCH_LEVEL; so the power-handling
          code must be locked.

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IoCopyCurrentIrpStackLocationToNext(irp);
    IncrementPendingActionCount(devExt);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->physicalDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }

    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WINMGMT class provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include <wbemprov.h>
#include <initguid.h>

#include "debug.h"
#include "wbemmisc.h"
#include "useful.h"
#include "testinfo.h"
#include "sample.h"

HMODULE ghModule;
HANDLE CSMutex;

// {8DD99E84-2B01-4c97-8061-2A3D08E289BB}
DEFINE_GUID(CLSID_classprovider, 
0x8dd99e84, 0x2b01, 0x4c97, 0x80, 0x61, 0x2a, 0x3d, 0x8, 0xe2, 0x89, 0xbb);

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


extern "C" BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
	{
        ghModule = hInstance;
		CSMutex = CreateMutex(NULL,
							  FALSE,
							  NULL);
		if (CSMutex == NULL)
		{
			return(FALSE);
		}
	}
    return(TRUE);
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_classprovider!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
#if 0    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
#else
	//
	// We always remain loaded since we carry around result objects for
	// the results of previously run tests and do not want to unload
	// when there are result objects still held. In the future we will
	// want to check if all results are cleared and if so then unload,
	// but for now we'll stay loaded forever.
	//
	return(S_FALSE);
#endif
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WDM to CIM Mapping Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_classprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\testinfo.h ===
//***************************************************************************
//
//  TestInfo.h
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

class CWdmClass
{
    public:
        CWdmClass();
        ~CWdmClass();

        //
        // Linked list management routines for the benefit of the
        // provider
        //
        CWdmClass *GetNext();
        CWdmClass *GetPrev();
        void InsertSelf(CWdmClass **Head);

        
        BOOLEAN IsThisInitialized(void);

        HRESULT InitializeSelf(IWbemContext *pCtx,
                               PWCHAR CimClass);
        
        HRESULT RemapToCimClass(IWbemContext *pCtx);

        BOOLEAN ClaimCimClassName(PWCHAR CimClassName);
        
        HRESULT GetIndexByCimRelPath(BSTR CimObjectPath,
                                     int *RelPathIndex);

        BOOLEAN IsInstancesAvailable() {return(MappingInProgress == 0);};
        void IncrementMappingInProgress() { InterlockedIncrement(&MappingInProgress); };
        void DecrementMappingInProgress() { InterlockedDecrement(&MappingInProgress); };

		HRESULT PutInstance(IWbemContext *pCtx,
							int RelPathIndex,
							IWbemClassObject *pCimInstance);
        
        //
        // Accessors
        //
        ULONG GetInstanceCount(void) { return(RelPathCount); };
        BSTR /* NOFREE */ GetWdmRelPath(int RelPathIndex);
        BSTR /* NOFREE */ GetCimRelPath(int RelPathIndex);
        IWbemClassObject *GetCimInstance(int RelPathIndex);
    
        IWbemServices *GetWdmServices(void);
        IWbemServices *GetCimServices(void);
                
    private:                                  
        
        HRESULT WdmPropertyToCimProperty(
                                         IWbemClassObject *pCimClassInstance,
                                         IWbemClassObject *pWdmClassInstance,
                                         BSTR PropertyName,
                                         VARIANT *PropertyValue,
                                         CIMTYPE CimCimType,
                                         CIMTYPE WdmCimType
                                        );

        HRESULT CimPropertyToWdmProperty(
                                         IWbemClassObject *pWdmClassInstance,
                                         IWbemClassObject *pCimClassInstance,
                                         BSTR PropertyName,
                                         VARIANT *PropertyValue,
                                         CIMTYPE WdmCimType,
                                         CIMTYPE CimCimType
                                        );
                
        HRESULT CopyBetweenCimAndWdmClasses(
                            IWbemClassObject *pDestinationClass,
                            IWbemClassObject *pSourceClass,
                            BOOLEAN WdmToCdm
                            );
    

        HRESULT FillInCimInstance(
            IN IWbemContext *pCtx,
            IN int RelPathIndex,
            IN OUT IWbemClassObject *pCimInstance,
            IN IWbemClassObject *pWdmInstance
            );


        
        HRESULT GetWdmInstanceByIndex(IWbemContext *pCtx,
                                      int RelPathIndex,
                                      IWbemClassObject **Instance);
        

        HRESULT CreateCimInstance( IWbemContext  *pCtx,
                                int RelPathIndex,
                                IWbemClassObject **Instance);

        HRESULT DiscoverPropertyTypes(IWbemContext *pCtx,
                                      IWbemClassObject *pClassObject);

//
// Data Members
//

        LONG MappingInProgress;
        
        typedef enum
        {
            UnknownDerivation,
            NoDerivation,
            ConcreteDerivation,
            NonConcreteDerivation
        } DERIVATION_TYPE, *PDERIVATION_TYPE;
        
        DERIVATION_TYPE DerivationType;
        CBstrArray PropertyList;
                
        //
        // Link list management
        //
        CWdmClass *Next;
        CWdmClass *Prev;
        
        //
        // WDM/CIM Class Names
        //
        BSTR WdmShadowClassName;       // Shadow class name
        BSTR CimClassName;             // Current class name
        
        BSTR CimMappingClassName;
        BSTR CimMappingProperty;
        BSTR WdmMappingClassName;
        BSTR WdmMappingProperty;
        
        //
        // List of mappings between Cim and WDM.
        //
        int RelPathCount;
        CBstrArray *CimMapRelPaths;
        CBstrArray *WdmRelPaths;        
        CWbemObjectList *CimInstances;

		//
		// Useful device information
        CBstrArray *PnPDeviceIds;
		CBstrArray *FriendlyName;
		CBstrArray *DeviceDesc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\text.h ===
//***************************************************************************
//
//  Text.h
//
//  Module: CDM Provider
//
//  Purpose: Define fixed class, property  and qualifier names
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#define WDM_SHADOW_CLASS     L"WdmShadowClass"
#define CIM_MAPPING_CLASS    L"CimMappingClass"
#define WDM_MAPPING_CLASS    L"WdmMappingClass"
#define WDM_MAPPING_PROPERTY L"WdmMappingProperty"
#define CIM_MAPPING_PROPERTY L"CimMappingProperty"

#define DERIVED_CLASS_TYPE L"DerivedClassType"
#define CONCRETE           L"Concrete"
#define NONCONCRETE        L"NonConcrete"

#define VALUES             L"Values"
#define VALUE_MAP          L"ValueMap"

#define PNP_DEVICE_ID     L"PnPDeviceId"
#define CAPTION           L"Caption"
#define DESCRIPTION       L"Description"
#define NAME              L"Name"
#define STATUS            L"Status"
#define OK                L"OK"

#define SUPERCLASS        L"__Superclass"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\testinfo.cpp ===
//***************************************************************************
//
//  TestInfo.CPP
//
//  Module: CDM Provider
//
//  Purpose: Defines the CClassPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>

#ifndef _MT
  #define _MT
#endif

#include <wbemidl.h>

#include "debug.h"
#include "useful.h"
#include "wbemmisc.h"
#include "testinfo.h"
#include "cimmap.h"
#include "text.h"

IWbemServices *pCimServices;
IWbemServices *pWdmServices;

HRESULT TestInfoInitialize(
    void
    )
/*+++

Routine Description:

    This routine will establishes a connection to the root\wmi and
    root\cimv2 namespaces in global memory

Arguments:

Return Value:

	HRESULT

---*/
{
    HRESULT hr;

    WmipAssert(pCimServices == NULL);
    WmipAssert(pWdmServices == NULL);

    hr = WmiConnectToWbem(L"root\\cimv2",
                          &pCimServices);
    if (hr == WBEM_S_NO_ERROR)
    {
        hr = WmiConnectToWbem(L"root\\wmi",
                              &pWdmServices);
        
        if (hr != WBEM_S_NO_ERROR)
        {
            pCimServices->Release();
            pCimServices = NULL;
        }
    }

    return(hr);
}

void TestInfoDeinitialize(
    void
    )
/*+++

Routine Description:

    This routine will disestablish a connection to the root\wmi and
    root\cimv2 namespaces in global memory

Arguments:

Return Value:


---*/
{
    WmipAssert(pCimServices != NULL);
    WmipAssert(pWdmServices != NULL);
    
    pCimServices->Release();
    pCimServices = NULL;

    pWdmServices->Release();
    pWdmServices = NULL;
}

CWdmClass::CWdmClass()
/*+++

Routine Description:

	Constructor for CWdmClass class

Arguments:

Return Value:

---*/
{
	Next = NULL;
	Prev = NULL;
	
	WdmShadowClassName = NULL;
	WdmMappingClassName = NULL;
	WdmMappingProperty = NULL;
	CimClassName = NULL;
	CimMappingClassName = NULL;
	CimMappingProperty = NULL;
	
	PnPDeviceIds = NULL;
	FriendlyName = NULL;
	DeviceDesc = NULL;

	CimMapRelPaths = NULL;
	WdmRelPaths = NULL;
	CimInstances = NULL;
	
	RelPathCount = (int)-1;

	DerivationType = UnknownDerivation;

	//
	// Start out with the class marked as not having instances
	// availabel
	//
	MappingInProgress = 1;
}

CWdmClass::~CWdmClass()
/*+++

Routine Description:

	Destructor for CWdmClass class

Arguments:

Return Value:

---*/
{
	int i;
	
	if (WdmShadowClassName != NULL)
	{
		SysFreeString(WdmShadowClassName);
	}
	
	if (WdmMappingClassName != NULL)
	{
		SysFreeString(WdmMappingClassName);
	}
	
	if (WdmMappingProperty != NULL)
	{
		SysFreeString(WdmMappingProperty);
	}

	if (CimMappingClassName != NULL)
	{
		SysFreeString(CimMappingClassName);
	}

	if (CimClassName != NULL)
	{
		SysFreeString(CimClassName);
	}

	if (CimMappingProperty != NULL)
	{
		SysFreeString(CimMappingProperty);
	}

	if (WdmMappingProperty != NULL)
	{
		SysFreeString(WdmMappingProperty);
	}

	if (CimMapRelPaths != NULL)
	{
		delete CimMapRelPaths;
	}

	if (WdmRelPaths != NULL)
	{
		delete WdmRelPaths;
	}

	if (CimInstances != NULL)
	{
		delete CimInstances;
	}

	if (PnPDeviceIds != NULL)
	{
		delete PnPDeviceIds;
	}

	if (FriendlyName != NULL)
	{
		delete FriendlyName;
	}

	if (DeviceDesc != NULL)
	{
		delete DeviceDesc;
	}
}

IWbemServices *CWdmClass::GetWdmServices(
    void
    )
/*+++
Routine Description:

	Accessor for the WDM namespace IWbemServices

Arguments:


Return Value:

	IWbemServices
	
---*/
{
	WmipAssert(pWdmServices != NULL);
    return(pWdmServices);
}

IWbemServices *CWdmClass::GetCimServices(
    void
    )
/*+++
Routine Description:

	Accessor for the CIM namespace IWbemServices

Arguments:


Return Value:

	IWbemServices
	
---*/
{
	WmipAssert(pCimServices != NULL);
	
    return(pCimServices);
}

HRESULT CWdmClass::DiscoverPropertyTypes(
    IWbemContext *pCtx,
    IWbemClassObject *pCimClassObject
    )
{
    HRESULT hr, hrDontCare;
    VARIANT v;
    BSTR PropertyName;
	ULONG Count;
	IWbemQualifierSet *pQualifierList;

	WmipAssert(pCimClassObject != NULL);					

	if (DerivationType == ConcreteDerivation)
	{
		//
		// For a concrete derivation, get all of the key properties
		// from the superclass so we can populate them too
		//
		hr = pCimClassObject->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// TODO: Make CBstrArray allocation dynamic
			//
			PropertyList.Initialize(10);
			Count = 0;
			do
			{
				hr = pCimClassObject->Next(0,
									 &PropertyName,
									 NULL,
									 NULL,
									 NULL);

				if (hr == WBEM_S_NO_ERROR)
				{
					PropertyList.Set(Count++, PropertyName);
				} else if (hr == WBEM_S_NO_MORE_DATA) {
					//
					// This signifies the end of the enumerations
					//
					hr = WBEM_S_NO_ERROR;
					break;
				}
			} while (hr == WBEM_S_NO_ERROR);

			pCimClassObject->EndEnumeration();
		}
    } else if (DerivationType == NonConcreteDerivation) {
		//
		// TODO: Figure out how we want to create the list of
		//       superclass properties to fill
		//
		PropertyList.Initialize(1);
		hr = WBEM_S_NO_ERROR;
	}
	
    return(hr);
	
}

HRESULT CWdmClass::InitializeSelf(
    IWbemContext *pCtx,
    PWCHAR CimClass
    )
{
	HRESULT hr;
	VARIANT v, vSuper;
	IWbemClassObject *pClass;
	IWbemQualifierSet *pQualifiers;
	PWCHAR Names[6];
	VARTYPE Types[6];
	VARIANT Values[6];
	
	WmipAssert(CimClass != NULL);

	WmipAssert(CimMappingClassName == NULL);
	WmipAssert(WdmShadowClassName == NULL);
	WmipAssert(CimClassName == NULL);

	//
	// We assume that this method will always be the first one called
	// by the class provider
	//
	EnterCritSection();
    if ((pCimServices == NULL) &&
        (pWdmServices == NULL))
    {
        hr = TestInfoInitialize();
        if (hr != WBEM_S_NO_ERROR)
        {
			LeaveCritSection();
			WmipDebugPrint(("WMIMAP: TestInfoInitialize -> %x\n", hr));
            return(hr);
        }
    }
	LeaveCritSection();

	CimClassName = SysAllocString(CimClass);

	if (CimClassName != NULL)
	{
		//
		// Get the WdmShadowClass class qualifier to discover the name of
		// the Wdm class that is represented by this cim class
		//

		hr = GetCimServices()->GetObject(CimClassName,
							  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
							  pCtx,
							  &pClass,
							  NULL);
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// See if this is a derived class or not
			//
			VariantInit(&vSuper);
			hr = WmiGetProperty(pClass,
								 SUPERCLASS,
								 CIM_STRING,
								 &vSuper);

			if (hr == WBEM_S_NO_ERROR)
			{				
				hr = pClass->GetQualifierSet(&pQualifiers);
				
				if (hr == WBEM_S_NO_ERROR)
				{

					Names[0] = WDM_SHADOW_CLASS;
					Types[0] = VT_BSTR;

					Names[1] = WDM_MAPPING_CLASS;
					Types[1] = VT_BSTR;

					Names[2] = WDM_MAPPING_PROPERTY;
					Types[2] = VT_BSTR;

					Names[3] = CIM_MAPPING_CLASS;
					Types[3] = VT_BSTR;

					Names[4] = CIM_MAPPING_PROPERTY;
					Types[4] = VT_BSTR;

					Names[5] = DERIVED_CLASS_TYPE;
					Types[5] = VT_BSTR;
					hr = GetListOfQualifiers(pQualifiers,
											 6,
											 Names,
											 Types,
											 Values,
											 FALSE);
					
					if (hr == WBEM_S_NO_ERROR)
					{
						//
						// First determine if this is a concrete or non
						// concrete derivation
						//
						if (Values[5].vt == VT_BSTR)
						{
							if (_wcsicmp(Values[5].bstrVal, CONCRETE) == 0)
							{
								DerivationType = ConcreteDerivation;
							} else if (_wcsicmp(Values[5].bstrVal, NONCONCRETE) == 0)
							{
								DerivationType = NonConcreteDerivation;
							}									   							
						}

						if (DerivationType == UnknownDerivation)
						{
							//
							// Must specify derivation type
							//
							hr = WBEM_E_AMBIGUOUS_OPERATION;
							WmipDebugPrint(("WMIMAP: class %ws must specify derivation type\n",
											CimClass));
						} else {
							if (Values[3].vt == VT_BSTR)
							{
								//
								// Use CimMappingClass as specified
								//
								CimMappingClassName = Values[3].bstrVal;
								VariantInit(&Values[3]);
							} else {
								//
								// CimMappingClass not specified, use
								// superclass as mapping class
								//
								CimMappingClassName = vSuper.bstrVal;
								VariantInit(&vSuper);
							}

							if (Values[0].vt == VT_BSTR)
							{
								//
								// WdmShadowClass is required
								//
								WdmShadowClassName = Values[0].bstrVal;
								VariantInit(&Values[0]);
								
								if (Values[1].vt == VT_BSTR)
								{
									//
									// WdmMappingClass can specify that
									// the mapping class is different
									// from the shadow class
									//
									WdmMappingClassName = Values[1].bstrVal;
									VariantInit(&Values[1]);
								}

								if (Values[2].vt == VT_BSTR)
								{
									WdmMappingProperty = Values[2].bstrVal;
									VariantInit(&Values[2]);
								}

								if (Values[4].vt == VT_BSTR)
								{
									CimMappingProperty = Values[4].bstrVal;
									VariantInit(&Values[4]);
									if (WdmMappingProperty == NULL)
									{
										//
										// If CimMappingProperty
										// specified then
										// WdmMappingProperty is
										// required
										//
										hr = WBEM_E_INVALID_CLASS;
									}
								} else {
									if (WdmMappingProperty != NULL)
									{
										//
										// If CimMappingProperty is not
										// specified then
										// WdmMappingProperty should
										// not be specified
										//
										hr = WBEM_E_INVALID_CLASS;										
									}
								}

								if (hr == WBEM_S_NO_ERROR)
								{
									//
									// Look at all properties to discover which ones 
									// need to be handled 
									//
									hr = DiscoverPropertyTypes(pCtx,
															   pClass);
								}

							} else {
								//
								// WDMShadowClass qualifier is required
								//
								hr = WBEM_E_INVALID_CLASS;
							}
							
						}
						VariantClear(&Values[0]);
						VariantClear(&Values[1]);
						VariantClear(&Values[2]);
						VariantClear(&Values[3]);
						VariantClear(&Values[4]);
						VariantClear(&Values[5]);
					}
					pQualifiers->Release();					
				}
				
				VariantClear(&vSuper);

			} else {
				//
				// No superclass implies no derivation
				//
				DerivationType = NoDerivation;
				hr = WBEM_S_NO_ERROR;
			}

			pClass->Release();
		}
	} else {
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return(hr);
}

HRESULT CWdmClass::RemapToCimClass(
    IWbemContext *pCtx
    )
/*+++
Routine Description:

	This routine will setup this class and initialize everything so
	that the provider can interact with the CDM and WDM classes

Arguments:

	CdmClass is the name of the CDM class
	
Return Value:

	HRESULT
	
---*/
{
	CBstrArray WdmInstanceNames;
	CBstrArray *WdmPaths;
	CBstrArray *CimPaths;
	CBstrArray *CimMapPaths;
	IWbemClassObject *CimInstance;
    HRESULT hr;
	int i;
	
    WmipAssert(CimMappingClassName != NULL);
    WmipAssert(WdmShadowClassName != NULL);

	//
	// Increment this to indicate that mapping is in progress and thus
	// there are no instances available. Consider changing this to some
	// kind of synchronization mechanism
	//
	IncrementMappingInProgress();
	
	//
	// Free rel path bstr arrays
	//
	if (CimMapRelPaths != NULL)
	{
		delete CimMapRelPaths;
	}

	if (CimInstances != NULL)
	{
		delete CimInstances;
	}

	if (WdmRelPaths != NULL)
	{
		delete WdmRelPaths;
	}

	//
	// allocate new rel paths
	//
	CimMapRelPaths = new CBstrArray;
	WdmRelPaths = new CBstrArray;
	CimInstances = new CWbemObjectList;
	PnPDeviceIds = new CBstrArray;
	FriendlyName = new CBstrArray;
	DeviceDesc = new CBstrArray;

	if ((CimMapRelPaths != NULL) &&
        (CimInstances != NULL) && 
        (PnPDeviceIds != NULL) && 
        (FriendlyName != NULL) && 
        (DeviceDesc != NULL) && 
		(WdmRelPaths != NULL))
	{

		if ((WdmMappingProperty == NULL) &&
            (CimMappingProperty == NULL))
		{
			//
			// Use worker function to determine which
			// Wdm relpaths map to which CIM_LogicalDevice relpaths
			// via the PnP ids
			//
			hr = MapWdmClassToCimClassViaPnpId(pCtx,
									   pWdmServices,
									   pCimServices,
									   WdmShadowClassName,
									   CimMappingClassName,
									   PnPDeviceIds,
                                       FriendlyName,
                                       DeviceDesc,
									   &WdmInstanceNames,
									   WdmRelPaths,
									   CimMapRelPaths,
									   &RelPathCount);
		} else {
			//
			// Use worker function to map WDM relpaths to CIM relpaths
			// using a common property in both classes
			//
			hr = MapWdmClassToCimClassViaProperty(pCtx,
				                                  pWdmServices,
				                                  pCimServices,
				                                  WdmShadowClassName,
				                                  WdmMappingClassName ?
                                                        WdmMappingClassName :
				                                        WdmShadowClassName,
												  WdmMappingProperty,
												  CimMappingClassName,
												  CimMappingProperty,
 												  &WdmInstanceNames,
												  WdmRelPaths,
												  CimMapRelPaths,
												  &RelPathCount);

		}

		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Collect the relpaths for our cim instances that we are
			// providing. Best way to do this is to create our instances
			//
			CimInstances->Initialize(RelPathCount);
			for (i = 0; i < RelPathCount; i++)
			{
				WmipDebugPrint(("WMIMAP: %ws maps to %ws\n",
								WdmRelPaths->Get(i),
								CimMapRelPaths->Get(i)));
				hr = CreateCimInstance(pCtx,
									   i,
									   &CimInstance);
				if (hr == WBEM_S_NO_ERROR)
				{
					hr = CimInstances->Set(i,
										   CimInstance);
					
                    if (hr != WBEM_S_NO_ERROR)
					{
						break;
					}
				} else {
					break;
				}
			}

		}
	}

	if (hr != WBEM_S_NO_ERROR)
	{
		delete CimMapRelPaths;
		CimMapRelPaths = NULL;
		
		delete WdmRelPaths;
		WdmRelPaths = NULL;
		
		delete CimInstances;
		CimInstances = NULL;
	}
	
	DecrementMappingInProgress();
	
    return(hr);
}


HRESULT CWdmClass::WdmPropertyToCimProperty(
    IN IWbemClassObject *pCdmClassInstance,
    IN IWbemClassObject *pWdmClassInstance,
    IN BSTR PropertyName,
    IN OUT VARIANT *PropertyValue,
    IN CIMTYPE CdmCimType,
    IN CIMTYPE WdmCimType
    )
/*+++
Routine Description:

	This routine will convert a property in a Wdm class into the form
	required for the property in the Cdm class.

Arguments:

	pCdmClassInstance is the instnace of the Cdm class that will get
		the property value

	pWdmClassInstance is the instance of the Wdm class that has the
		property value

	PropertyName is the name of the property in the Wdm and Cdm classes

	PropertyValue on entry has the value of the property in the Wdm
		instance and on return has the value to set in the Cdm instance

	CdmCimType is the property type for the property in the Cdm
		instance
	
	WdmCimType is the property type for the property in the Wdm
		instance
	
Return Value:

    HRESULT
	
---*/
{
	HRESULT hr;
	CIMTYPE BaseWdmCimType, BaseCdmCimType;
	CIMTYPE WdmCimArray, CdmCimArray;

	WmipAssert(pCdmClassInstance != NULL);
	WmipAssert(pWdmClassInstance != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(PropertyValue != NULL);
	
	WmipAssert(IsThisInitialized());
	
    //
    // Rules for converting Wdm Classes into Cdm Classes
    //  Wdm Class Type      Cdm Class Type     Conversion Done
    //    enumeration          string           Build string from enum
    //
	BaseWdmCimType = WdmCimType & ~CIM_FLAG_ARRAY;
	BaseCdmCimType = CdmCimType & ~CIM_FLAG_ARRAY;
	WdmCimArray = WdmCimType & CIM_FLAG_ARRAY;
	CdmCimArray = CdmCimType & CIM_FLAG_ARRAY;
	
	if (((BaseWdmCimType == CIM_UINT32) ||
		 (BaseWdmCimType == CIM_UINT16) ||
		 (BaseWdmCimType == CIM_UINT8)) &&
		(BaseCdmCimType == CIM_STRING) &&
	    (WdmCimArray == CdmCimArray) &&
	    (PropertyValue->vt != VT_NULL))
	{		
		CValueMapping ValueMapping;

		hr = ValueMapping.EstablishByName(GetWdmServices(),
										  WdmShadowClassName,
										  PropertyName);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = ValueMapping.MapVariantToString(PropertyValue,
												 WdmCimType);
		}
	} else {
		//
		// No conversion needs to occur
		//
		hr = WBEM_S_NO_ERROR;
	}
    
    return(hr);
}

HRESULT CWdmClass::CimPropertyToWdmProperty(
    IN IWbemClassObject *pWdmClassInstance,
    IN IWbemClassObject *pCdmClassInstance,
    IN BSTR PropertyName,
    IN OUT VARIANT *PropertyValue,
    IN CIMTYPE WdmCimType,
    IN CIMTYPE CdmCimType
    )
/*+++
Routine Description:

	This routine will convert a property in a Cdm class into the form
	required for the property in the Wdm class.

Arguments:

	pWdmClassInstance is the instance of the Wdm class that has the
		property value

	pCdmClassInstance is the instnace of the Cdm class that will get
		the property value

	PropertyName is the name of the property in the Wdm and Cdm classes

	PropertyValue on entry has the value of the property in the Wdm
		instance and on return has the value to set in the Cdm instance

	WdmCimType is the property type for the property in the Wdm
		instance
		
	CdmCimType is the property type for the property in the Cdm
		instance	
	
Return Value:

    HRESULT
	
---*/
{
	HRESULT hr;
	CIMTYPE BaseWdmCimType, BaseCdmCimType;
	CIMTYPE WdmCimArray, CdmCimArray;

	WmipAssert(pCdmClassInstance != NULL);
	WmipAssert(pWdmClassInstance != NULL);
	WmipAssert(PropertyName != NULL);
	WmipAssert(PropertyValue != NULL);

	
	WmipAssert(IsThisInitialized());
	
    //
    // Rules for converting Wdm Classes into Cdm Classes
    //  Wdm Class Type      Cdm Class Type     Conversion Done
    //    enumeration          string           Map string to enum value
    //    
    //
	BaseWdmCimType = WdmCimType & ~CIM_FLAG_ARRAY;
	BaseCdmCimType = CdmCimType & ~CIM_FLAG_ARRAY;
	WdmCimArray = WdmCimType & CIM_FLAG_ARRAY;
	CdmCimArray = CdmCimType & CIM_FLAG_ARRAY;
	
	if (((BaseWdmCimType == CIM_UINT32) ||
		 (BaseWdmCimType == CIM_UINT16) ||
		 (BaseWdmCimType == CIM_UINT8)) &&
		(BaseCdmCimType == CIM_STRING) &&
	    (WdmCimArray == CdmCimArray) &&
	    (PropertyValue->vt != VT_NULL))
	{		
		CValueMapping ValueMapping;

		hr = ValueMapping.EstablishByName(GetWdmServices(),
										  WdmShadowClassName,
										  PropertyName);
		if (hr == WBEM_S_NO_ERROR)
		{
			hr = ValueMapping.MapVariantToNumber(PropertyValue,
				                                 (VARTYPE)BaseWdmCimType);

		}
	} else {
		//
		// No conversion needs to occur
		//
		hr = WBEM_S_NO_ERROR;
	}

    return(hr);
}

HRESULT CWdmClass::CopyBetweenCimAndWdmClasses(
    IN IWbemClassObject *pDestinationInstance,
    IN IWbemClassObject *pSourceInstance,
    IN BOOLEAN WdmToCdm
    )
/*+++
Routine Description:

	This routine will do the work to copy and convert all properties in
	an instance of a Wdm or Cdm class to an instance of a Cdm or Wdm
	class.

	Note that properties from one instance are only copied to
	properties of another instance when the property names are
	identical. No assumption is ever made on the name of the
	properties. The only info used to determine how to convert a
	property is based upon the source and destination cim type.

Arguments:

	pDestinationInstance is the class instance that the properties will
	be copied into

	pSourceInstance is the class instance that the properties will be
	copied from

	WdmToCdm is TRUE if copying from Wdm to Cdm, else FALSE
	
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;
    VARIANT PropertyValue;
    BSTR PropertyName;
    CIMTYPE SourceCimType, DestCimType;
    HRESULT hrDontCare;

	WmipAssert(pDestinationInstance != NULL);
	WmipAssert(pSourceInstance != NULL);	
	
	WmipAssert(IsThisInitialized());
	
    //
    // Now we need to move over all of the properties from the source
    // class into the destination class. Note that some properties need
    // some special effort such as OtherCharacteristics which needs
    // to be converted from an enumeration value (in wdm) to a
    // string (in CDM).
    //
    // Our strategy is to enumerate all of the proeprties in the
    // source class and then look for a property with the same name
    // and type in the destination class. If so we just copy over the
    // value. If the data type is different we need to do some
    // conversion.
    //
					
	
    hr = pSourceInstance->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    if (hr == WBEM_S_NO_ERROR)
    {
        do
        {
			//
			// Get a property from the source class
			//
            hr = pSourceInstance->Next(0,
                                 &PropertyName,
                                 &PropertyValue,
                                 &SourceCimType,
                                 NULL);
			
            if (hr == WBEM_S_NO_ERROR)
            {
				//
				// Try to get a property with the same name from the
				// dest class. If the identically named property does
				// not exist in the destination class then it is ignored
				//
				hrDontCare = pDestinationInstance->Get(PropertyName,
											0,
											NULL,
											&DestCimType,
											NULL);
									
				if (hrDontCare == WBEM_S_NO_ERROR)
				{
					
					if (WdmToCdm)
					{
						hr = WdmPropertyToCimProperty(pDestinationInstance,
													  pSourceInstance,
													  PropertyName,
													  &PropertyValue,
							                          DestCimType,
												      SourceCimType);
					} else {                    
						hr = CimPropertyToWdmProperty(pDestinationInstance,
													  pSourceInstance,
													  PropertyName,
													  &PropertyValue,
							                          DestCimType,
												      SourceCimType);
					}

					if (hr == WBEM_S_NO_ERROR)
					{
						//
						// Try to place the transformed property into the
						// destination class.
						//
						hr = pDestinationInstance->Put(PropertyName,
												  0,
												  &PropertyValue,
												  0);                       
					}
				}
                   
                SysFreeString(PropertyName);
                VariantClear(&PropertyValue);
				
            } else if (hr == WBEM_S_NO_MORE_DATA) {
                //
                // This signifies the end of the enumerations
                //
                hr = WBEM_S_NO_ERROR;
                break;
            }
        } while (hr == WBEM_S_NO_ERROR);

        pSourceInstance->EndEnumeration();

    }
    return(hr);
}

HRESULT CWdmClass::FillInCimInstance(
    IN IWbemContext *pCtx,
    IN int RelPathIndex,
    IN OUT IWbemClassObject *pCimInstance,
    IN IWbemClassObject *pWdmInstance
    )
{
	IWbemClassObject *pSuperInstance;
	ULONG Count;
	ULONG i;
	BSTR Property;
	VARIANT v;
	HRESULT hr, hrDontCare;
	CIMTYPE CimType;
	BSTR s;
	
	WmipAssert(RelPathIndex < RelPathCount);
	WmipAssert(pCimInstance != NULL);
	WmipAssert(pWdmInstance != NULL);

	switch (DerivationType)
	{
		case ConcreteDerivation:
		{
			//
			// We derived from a concrete class, so we need to duplicate
			// the key properties
			//
			hr = GetCimServices()->GetObject(CimMapRelPaths->Get(RelPathIndex),
											 0,
											 pCtx,
											 &pSuperInstance,
											 NULL);
			if (hr == WBEM_S_NO_ERROR)
			{
				Count = PropertyList.GetListSize();
				for (i = 0; (i < Count) && (hr == WBEM_S_NO_ERROR); i++)
				{
					Property = PropertyList.Get(i);
					WmipDebugPrint(("WMIMAP: Concrete Property %ws\n", Property));
					if (Property != NULL)
					{
						hr = pSuperInstance->Get(Property,
											0,
											&v,
											&CimType,
											NULL);
						
						if (hr == WBEM_S_NO_ERROR)
						{
							hr = pCimInstance->Put(Property,
								                   0,
								                   &v,
								                   CimType);
						    VariantClear(&v);
						}
							 
					}
				}
			
				pSuperInstance->Release();
			}
			break;
		}

		case NonConcreteDerivation:
		{
			//
			// We derived from a non concrete class, so we need to fill
			// in any properties from the super class that we feel we
			// should. The list includes
			// Description (from FriendlyName device property)
			// Caption (from DeviceDesc device property)
			// Name  (From DeviceDesc device property)
			// Status (always OK)
			// PNPDeviceID
			//

			if (PnPDeviceIds != NULL)
			{
				s = PnPDeviceIds->Get(RelPathIndex);
				v.vt = VT_BSTR;
				v.bstrVal = s;
				hrDontCare = pCimInstance->Put(PNP_DEVICE_ID,
									   0,
									   &v,
									   0);				
			}

			if (FriendlyName != NULL)
			{
				s = FriendlyName->Get(RelPathIndex);
				if (s != NULL)
				{
					v.vt = VT_BSTR;
					v.bstrVal = s;
					hrDontCare = pCimInstance->Put(DESCRIPTION,
										   0,
										   &v,
										   0);
				}
			}


			if (DeviceDesc != NULL)
			{
				s = DeviceDesc->Get(RelPathIndex);
				if (s != NULL)
				{
					v.vt = VT_BSTR;
					v.bstrVal = s;
					hrDontCare = pCimInstance->Put(NAME,
										   0,
										   &v,
										   0);

					hrDontCare = pCimInstance->Put(CAPTION,
										   0,
										   &v,
										   0);
				}
			}


			s = SysAllocString(OK);
			if (s != NULL)
			{
				v.vt = VT_BSTR;
				v.bstrVal = s;
				hrDontCare = pCimInstance->Put(STATUS,
									   0,
									   &v,
									   0);								
				SysFreeString(s);
			}
			
			break;
		}

		case NoDerivation:
		{
			//
			// Nothing to do
			//
			hr = WBEM_S_NO_ERROR;
			break;
		}
		
		default:
		{
			WmipAssert(FALSE);
			hr = WBEM_S_NO_ERROR;
			break;
		}
		
	}
	return(hr);
}

HRESULT CWdmClass::CreateCimInstance(
    IN IWbemContext *pCtx,
    IN int RelPathIndex,
    OUT IWbemClassObject **pCimInstance
    )
/*+++
Routine Description:

	This routine will create a CIM instance corresponding to the WDM
	instance for the relpath index. No data is cached as the WDM class
	is always queried to create the instance. 

Arguments:

	pCtx is the WBEM context

	RelPathIndex is the index into the class corresponding to the
		instance

	*pCimInstance returns with a CIM class instance
	
Return Value:

    HRESULT
	
---*/
{
    IWbemClassObject *pWdmInstance;
    HRESULT hr;

	WmipAssert(pCimInstance != NULL);
	WmipAssert(RelPathIndex < RelPathCount);
	
	WmipAssert(IsThisInitialized());

	//
	// Create a template Cim instance to be filled with WDM properties
	//
	hr = CreateInst(pCtx,
					GetCimServices(),
					CimClassName,
					pCimInstance);

	if (hr == WBEM_S_NO_ERROR)
	{	
		hr = GetWdmInstanceByIndex(pCtx,
								   RelPathIndex,
								   &pWdmInstance);

		if (hr == WBEM_S_NO_ERROR)
		{
			hr = CopyBetweenCimAndWdmClasses(*pCimInstance,
											 pWdmInstance,
											 TRUE);

			if (hr == WBEM_S_NO_ERROR)
			{
				//
				// Fill in additional CIM properties in the case of
				// classes derived from concrete and non concrete classes
				//
				hr = FillInCimInstance(pCtx,
									   RelPathIndex,
									   *pCimInstance,
									   pWdmInstance);
									   
			}
			
			pWdmInstance->Release();

		}

		if (hr != WBEM_S_NO_ERROR)
		{
			(*pCimInstance)->Release();
			*pCimInstance = NULL;
		}
	}

    return(hr);
}

HRESULT CWdmClass::GetIndexByCimRelPath(
    BSTR CimObjectPath,
    int *RelPathIndex
    )
/*+++
Routine Description:

	This routine will return the RelPathIndex for a specific Cim
	Relpath

Arguments:

	CimRelPath is the Cim relpath

	*RelPathIndex returns with the relpath index
	
Return Value:

    HRESULT
	
---*/
{
    int i;

	WmipAssert(CimObjectPath != NULL);
	
    WmipAssert(CimInstances->IsInitialized());
    WmipAssert(WdmRelPaths->IsInitialized());

	WmipAssert(IsThisInitialized());
	
    for (i = 0; i < RelPathCount; i++)
    {
        if (_wcsicmp(CimObjectPath, GetCimRelPath(i)) == 0)
        {
            *RelPathIndex = i;
            return(WBEM_S_NO_ERROR);
        }
    }
    
    return(WBEM_E_NOT_FOUND);
}

HRESULT CWdmClass::GetWdmInstanceByIndex(
    IN IWbemContext *pCtx,
    IN int RelPathIndex,
    OUT IWbemClassObject **ppWdmInstance
    )
/*+++
Routine Description:

	This routine will return a IWbemClassObject pointer associated
	with the RelPath index

Arguments:

	RelPathIndex

	*ppWdmClassObject returns with an instance for the relpaht
	
Return Value:

    HRESULT
	
---*/
{
    HRESULT hr;

	WmipAssert(ppWdmInstance != NULL);
	
	WmipAssert(IsThisInitialized());
	
	//
	// Run in the caller's context so that if he is not able to access
	// the WDM classes, he can't
	//
	hr = CoImpersonateClient();
	if (hr == WBEM_S_NO_ERROR)
	{
		*ppWdmInstance = NULL;        
		hr = GetWdmServices()->GetObject(WdmRelPaths->Get(RelPathIndex),
									  WBEM_FLAG_USE_AMENDED_QUALIFIERS,
									  pCtx,
									  ppWdmInstance,
									  NULL);
		CoRevertToSelf();
	}
	
    return(hr); 
}


BOOLEAN CWdmClass::IsThisInitialized(
    void
    )
/*+++
Routine Description:

	This routine determines if this class has been initialized to
	access CDM and WDM classes

Arguments:

	
	
Return Value:

    TRUE if initialiezed else FALSE
	
---*/
{
	return( (CimClassName != NULL) );
}

IWbemClassObject *CWdmClass::GetCimInstance(
    int RelPathIndex
    )
{
	WmipAssert(CimInstances->IsInitialized());
	WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	
	return(CimInstances->Get(RelPathIndex));
}
        
BSTR /* NOFREE */ CWdmClass::GetCimRelPath(
    int RelPathIndex
	)
/*+++
Routine Description:

	This routine will return the Cim relpath for a RelPathIndex

Arguments:

	RelPathIndex
	
Return Value:

    Cim RelPath. This should not be freed
	
---*/
{
	WmipAssert(CimInstances->IsInitialized());
	WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	
	return(CimInstances->GetRelPath(RelPathIndex));
}

BSTR /* NOFREE */ CWdmClass::GetWdmRelPath(
    int RelPathIndex
	)
/*+++
Routine Description:

	This routine will return the Wdm relpath for a RelPathIndex

Arguments:

	RelPathIndex
	
Return Value:

    Cim RelPath. This should not be freed
	
---*/
{
	WmipAssert(WdmRelPaths->IsInitialized());
	WmipAssert(RelPathIndex < RelPathCount);

	WmipAssert(IsThisInitialized());
	
	return(WdmRelPaths->Get(RelPathIndex));
}

//
// Linked list management routines
//
CWdmClass *CWdmClass::GetNext(
)
{
	return(Next);
}

CWdmClass *CWdmClass::GetPrev(
)
{
	return(Prev);
}


void CWdmClass::InsertSelf(
    CWdmClass **Head
	)
{
	WmipAssert(Next == NULL);
	WmipAssert(Prev == NULL);

	if (*Head != NULL)
	{
		Next = (*Head);
		(*Head)->Prev = this;
	}
	*Head = this;
}

BOOLEAN CWdmClass::ClaimCimClassName(
    PWCHAR ClassName
    )
{

	//
	// If this class has the same CIM class name as the one we are
	// looking for then we have a match
	//
	if (_wcsicmp(ClassName, CimClassName) == 0)
	{
		return(TRUE);
	}

	return(FALSE);
}

HRESULT CWdmClass::PutInstance(
    IWbemContext *pCtx,
	int RelPathIndex,
	IWbemClassObject *pCimInstance
    )
{
	HRESULT hr;
	IWbemClassObject *pWdmInstance;

	WmipAssert(pCimInstance != NULL);
	WmipAssert(RelPathIndex < RelPathCount);

	//
	// First thing is to obtain the WDM instance that corresponds to
	// the cim instance
	//
	hr = GetWdmServices()->GetObject(WdmRelPaths->Get(RelPathIndex),
									 0,
									 pCtx,
									 &pWdmInstance,
									 NULL);
	if (hr == WBEM_S_NO_ERROR)
	{
		//
		// Now copy properties from the CIM class into the WDM class
		//
		hr = CopyBetweenCimAndWdmClasses(pWdmInstance,
										 pCimInstance,
										 FALSE);
		if (hr == WBEM_S_NO_ERROR)
		{
			//
			// Finally put the WDM instance to reflect the changed
			// properties down into the driver
			//
			hr = GetWdmServices()->PutInstance(pWdmInstance,
											   WBEM_FLAG_UPDATE_ONLY,
											   pCtx,
											   NULL);
		}
	}

	return(hr);
									 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\alloc.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    alloc.c

Abstract:

    WMI data structure allocation routines

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

//
// This defines the number of DataSources allocated in each DataSource chunk
#if DBG
#define DSCHUNKSIZE 4
#else
#define DSCHUNKSIZE 64
#endif

C_ASSERT ( (FIELD_OFFSET (WMI_BUFFER_HEADER, GlobalEntry) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );
C_ASSERT ( (FIELD_OFFSET (WMI_BUFFER_HEADER, SlistEntry) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO DSChunkInfo =
{
    { NULL, NULL },
    sizeof(DATASOURCE),
    DSCHUNKSIZE,
    WmipDSCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    DS_SIGNATURE
};

LIST_ENTRY DSHead;              // Head of registerd data source list
PLIST_ENTRY DSHeadPtr;

//
// This defines the number of GuidEntrys allocated in each GuidEntry chunk
#if DBG
#define GECHUNKSIZE    4
#else
#define GECHUNKSIZE    512
#endif

CHUNKINFO GEChunkInfo =
{
    { NULL, NULL },
    sizeof(GUIDENTRY),
    GECHUNKSIZE,
    NULL,
    FLAG_ENTRY_REMOVE_LIST,
    GE_SIGNATURE
};

LIST_ENTRY GEHead;              // Head of registerd guid list
PLIST_ENTRY GEHeadPtr;


//
// This defines the number of InstanceSets allocated in each InstanceSet chunk
#if DBG
#define ISCHUNKSIZE    4
#else
#define ISCHUNKSIZE    2048
#endif

void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO ISChunkInfo =
{
    { NULL, NULL },
    sizeof(INSTANCESET),
    ISCHUNKSIZE,
    WmipISCleanup,
    0,
    IS_SIGNATURE
};

//
// This defines the number of DataConsumers allocated in each DCENTRY chunk
#if DBG
#define DCCHUNKSIZE    1
#else
#define DCCHUNKSIZE    16
#endif

void WmipDCCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO DCChunkInfo =
{
    { NULL, NULL },
    sizeof(DCENTRY),
    DCCHUNKSIZE,
    WmipDCCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    DC_SIGNATURE
};

LIST_ENTRY DCHead;                 // Head of registered data consumer
PLIST_ENTRY DCHeadPtr;

//
// This defines the number of Notifications allocated in each
// NOTIFICATIONENTRY chunk
#if DBG
#define NECHUNKSIZE    1
#else
#define NECHUNKSIZE    64
#endif

void WmipNECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO NEChunkInfo =
{
    { NULL, NULL },
    sizeof(NOTIFICATIONENTRY),
    NECHUNKSIZE,
    WmipNECleanup,
    FLAG_ENTRY_REMOVE_LIST,
    NE_SIGNATURE
};

LIST_ENTRY NEHead;                    // Head of enabled notifications list
PLIST_ENTRY NEHeadPtr;

#if DBG
#define MRCHUNKSIZE    2
#else
#define MRCHUNKSIZE    16
#endif

void WmipMRCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

CHUNKINFO MRChunkInfo =
{
    { NULL, NULL },
    sizeof(MOFRESOURCE),
    MRCHUNKSIZE,
    WmipMRCleanup,
    FLAG_ENTRY_REMOVE_LIST,
    MR_SIGNATURE
};

LIST_ENTRY MRHead;                     // Head of Mof Resource list
PLIST_ENTRY MRHeadPtr;


LIST_ENTRY  GMHead;     // Head of Guid Map List
PLIST_ENTRY GMHeadPtr;


ULONG GlobalUniqueValue;

#ifndef MEMPHIS
RTL_CRITICAL_SECTION SMCritSect;
#else
HANDLE SMMutex;
#endif

PBDATASOURCE WmipAllocDataSource(
    void
    )
/*++

Routine Description:

    Allocates a Data Source structure

Arguments:


Return Value:

    pointer to data source structure or NULL if one cannot be allocated

--*/
{
    PBDATASOURCE DataSource;

    DataSource = (PBDATASOURCE)WmipAllocEntry(&DSChunkInfo);
    if (DataSource != NULL)
    {
        InitializeListHead(&DataSource->ISHead);
        DataSource->MofResourceCount = AVGMOFRESOURCECOUNT;
        DataSource->MofResources = DataSource->StaticMofResources;
        memset(DataSource->MofResources,
               0,
               AVGMOFRESOURCECOUNT * sizeof(PMOFRESOURCE));
    }

    return(DataSource);
}

void WmipDSCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up data source structure and any other structures or handles
    associated with it.

Arguments:

    Data source structure to free

Return Value:

--*/
{
    PBDATASOURCE DataSource = (PBDATASOURCE)Entry;
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    PMOFRESOURCE MofResource;
    ULONG i;

    WmipAssert(DataSource != NULL);
    WmipAssert(DataSource->Flags & FLAG_ENTRY_INVALID);

    WmipEnterSMCritSection();

    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if (InstanceSet->GuidISList.Flink != NULL)
        {
            RemoveEntryList(&InstanceSet->GuidISList);
            InstanceSet->DataSource = NULL;
            InstanceSet->GuidEntry->ISCount--;
        }

        if ((InstanceSet->GuidEntry != NULL) &&
            (! (InstanceSet->Flags & IS_NEWLY_REGISTERED)))
        {

            if (IsEqualGUID(&InstanceSet->GuidEntry->Guid,
                            &WmipBinaryMofGuid))
            {
                WmipLeaveSMCritSection();
                WmipGenerateBinaryMofNotification(InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);

                WmipEnterSMCritSection();
            }

            WmipUnreferenceGE(InstanceSet->GuidEntry);
        }
        InstanceSet->GuidEntry = NULL;

        InstanceSetList = InstanceSetList->Flink;

        WmipUnreferenceIS(InstanceSet);
    }

    WmipLeaveSMCritSection();

    for (i = 0; i < DataSource->MofResourceCount; i++)
    {
        if (DataSource->MofResources[i] != NULL)
        {
            WmipUnreferenceMR(DataSource->MofResources[i]);
        }
    }

    if (DataSource->MofResources != DataSource->StaticMofResources)
    {
        WmipFree(DataSource->MofResources);
    }

    if (DataSource->RegistryPath != NULL)
    {
        WmipFree(DataSource->RegistryPath);
    }

    if (DataSource->BindingString != NULL)
    {
        WmipFree(DataSource->BindingString);
    }
    
    if (DataSource->RpcBindingHandle != 0)
    {
        RpcBindingFree((handle_t *)&DataSource->RpcBindingHandle);
    }    
}

void WmipDCCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
/*++

Routine Description:

    Cleans up data consumer structure and any other structures or handles
    associated with it.

Arguments:

    Data source structure to free

Return Value:

--*/
{
    PDCENTRY DataConsumer = (PDCENTRY)Entry;

    WmipAssert(DataConsumer != NULL);
    WmipAssert(DataConsumer->Flags & FLAG_ENTRY_INVALID);
    WmipAssert(DataConsumer->Flags & DC_FLAG_RUNDOWN);
    WmipAssert(DataConsumer->EventData == NULL);

    if (DataConsumer->RpcBindingHandle != 0)
    {
        RpcBindingFree((handle_t *)&DataConsumer->RpcBindingHandle);
    }

#if DBG
    if (DataConsumer->BindingString != NULL)
    {
        WmipFree(DataConsumer->BindingString);
    }
#endif

    WmipDebugPrint(("WMI: DC %x has just been freed\n", DataConsumer));
}

PBGUIDENTRY WmipAllocGuidEntry(
    void
    )
{
    PBGUIDENTRY GuidEntry;

    GuidEntry = (PBGUIDENTRY)WmipAllocEntry(&GEChunkInfo);
    if (GuidEntry != NULL)
    {
        InitializeListHead(&GuidEntry->ISHead);
    }

    return(GuidEntry);
}


void WmipISCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
{
    PBINSTANCESET InstanceSet = (PBINSTANCESET)Entry;

    WmipAssert(InstanceSet != NULL);
    WmipAssert(InstanceSet->Flags & FLAG_ENTRY_INVALID);

    if (InstanceSet->IsBaseName != NULL)
    {
        WmipFree(InstanceSet->IsBaseName);
    }
}

void WmipNECleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
{
    PNOTIFICATIONENTRY NotificationEntry = (PNOTIFICATIONENTRY)Entry;
#if DBG
    int i;
    PDCREF DcRef;
#endif

    WmipAssert(NotificationEntry != NULL);
    WmipAssert(NotificationEntry->EventRefCount == 0);
    WmipAssert(NotificationEntry->CollectRefCount == 0);
    WmipAssert(NotificationEntry->Flags & FLAG_ENTRY_INVALID);

    WmipAssert(NotificationEntry->CollectInProgress == NULL);
#if DBG
    //
    // Make sure nothing is left enabled in what we are freeing
    for (i = 0; i < DCREFPERNOTIFICATION; i++)
    {
        DcRef = &NotificationEntry->DcRef[i];
        WmipAssert(DcRef->EventRefCount == 0);
        WmipAssert(DcRef->CollectRefCount == 0);
        WmipAssert(DcRef->DcEntry == NULL);
        WmipAssert((DcRef->Flags & (DCREF_FLAG_NOTIFICATION_ENABLED | DCREF_FLAG_COLLECTION_ENABLED)) == 0);
    }
#endif

    //
    // If there are any continuation records then free them as well
    NotificationEntry = NotificationEntry->Continuation;
    if (NotificationEntry != NULL)
    {
        WmipUnreferenceNE(NotificationEntry);
    }
}

void WmipMRCleanup(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    )
{
    PMOFRESOURCE MofResource = (PMOFRESOURCE)Entry;

    if ((MofResource->MofImagePath != NULL) &&
        (MofResource->MofResourceName != NULL))
    {
        WmipGenerateMofResourceNotification(MofResource->MofImagePath,
                                    MofResource->MofResourceName,
                                    &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);
    }

    if (MofResource->MofImagePath != NULL)
    {
        WmipFree(MofResource->MofImagePath);
    }

    if (MofResource->MofResourceName != NULL)
    {
        WmipFree(MofResource->MofResourceName);
    }
}


PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    )
/*++

Routine Description:

    Searches guid list for first occurence of guid. Guid's refcount is
    incremented if found.

Arguments:

    Guid is pointer to guid that is to be found

    MakeTopOfList is TRUE then if NE is found it is placed at the top of the
        NE list

Return Value:

    pointer to guid entry pointer or NULL if not found

--*/
{
    PLIST_ENTRY GuidEntryList;
    PBGUIDENTRY GuidEntry;

    WmipEnterSMCritSection();

    GuidEntryList = GEHeadPtr->Flink;
    while (GuidEntryList != GEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                      GUIDENTRY,
                                      MainGEList);
        if (IsEqualGUID(Guid, &GuidEntry->Guid))
        {
            WmipReferenceGE(GuidEntry);

            if (MakeTopOfList)
            {
                RemoveEntryList(GuidEntryList);
                InsertHeadList(GEHeadPtr, GuidEntryList);
            }

            WmipLeaveSMCritSection();
            WmipAssert(GuidEntry->Signature == GE_SIGNATURE);
            return(GuidEntry);
        }
        GuidEntryList = GuidEntryList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    )
/*++

Routine Description:

    This routine finds a DataSource on the provider id passed. DataSource's
    ref  count is incremented if found

Arguments:

    ProviderId is the data source provider id

Return Value:

    DataSource pointer or NULL if no data source was found

--*/
{
    PLIST_ENTRY DataSourceList;
    PBDATASOURCE DataSource;

    WmipEnterSMCritSection();
    DataSourceList = DSHeadPtr->Flink;
    while (DataSourceList != DSHeadPtr)
    {
        DataSource = CONTAINING_RECORD(DataSourceList,
                                      DATASOURCE,
                                      MainDSList);
        if (DataSource->ProviderId == ProviderId)
        {
            WmipReferenceDS(DataSource);
            WmipLeaveSMCritSection();
            WmipAssert(DataSource->Signature == DS_SIGNATURE);
            return(DataSource);
        }

        DataSourceList = DataSourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    )
/*++

Routine Description:

    This routine will find an instance set within a data source list for a
    specific guid. Note that any instance sets that have been replaceed
    (have IS_REPLACED_BY_REFERENCE) are ignored and not returned. The
    InstanceSet that is found has its reference count increased.

Arguments:

    DataSource is the data source whose instance set list is searched
    Guid is a pointer to a guid which defines which instance set list to find

Return Value:

    InstanceSet pointer or NULL if not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;

    WmipEnterSMCritSection();
    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                      INSTANCESET,
                                      DSISList);
        if (IsEqualGUID(&InstanceSet->GuidEntry->Guid, Guid))
        {
            WmipReferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
            WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

PNOTIFICATIONENTRY WmipFindNEByGuid(
    GUID UNALIGNED *Guid,
    BOOLEAN MakeTopOfList
    )
/*++

Routine Description:

    Searches notifications list for first occurence of guid. The Notification
    entry found has its reference count incremented.

Arguments:

    Guid is pointer to guid that is to be found

    MakeTopOfList is TRUE then if NE is found it is placed at the top of the
        NE list

Return Value:

    pointer to  guid entry pointer or NULL if not found

--*/
{
    PLIST_ENTRY NotificationEntryList;
    PNOTIFICATIONENTRY NotificationEntry;

    WmipEnterSMCritSection();
    NotificationEntryList = NEHeadPtr->Flink;
    while (NotificationEntryList != NEHeadPtr)
    {
        NotificationEntry = CONTAINING_RECORD(NotificationEntryList,
                                      NOTIFICATIONENTRY,
                                      MainNotificationList);
        if (IsEqualGUID(Guid, &NotificationEntry->Guid))
        {
            WmipReferenceNE(NotificationEntry);

            if (MakeTopOfList)
            {
                RemoveEntryList(NotificationEntryList);
                InsertHeadList(NEHeadPtr, NotificationEntryList);
            }

            WmipLeaveSMCritSection();
            WmipAssert(NotificationEntry->Signature == NE_SIGNATURE);
            return(NotificationEntry);
        }
        NotificationEntryList = NotificationEntryList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}


PDCREF WmipFindExistingAndFreeDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer,
    PDCREF *FreeDcRef
    )
/*++

Routine Description:

    Searches a notifications entry for the DCRef for a specific Data
    consumer. Also returns a free DCRef. If there are no more free DCRef
    then a continuation Notification Entry is allocated. Note that *FreeDcRef
    may return NULL when the return value is not NULL

    This routine assumes that the NotificationEntry specific or the global
    critical section has been taken.

Arguments:

    NotificationEntry is the notification entry to search through

    DataConsumer is the data consumer being searched for

    *FreeDcRef returns a free DCRef if the specific DcRef is not found.


Return Value:

    pointer to DCRef related to DataConsumeer or NULL

--*/
{
    PDCREF DcRef;
    ULONG i;
    PNOTIFICATIONENTRY NotificationEntryNext, Continuation;

    WmipAssert(NotificationEntry != NULL);
    WmipAssert(FreeDcRef != NULL);

    *FreeDcRef = NULL;
    NotificationEntryNext = NotificationEntry;
    while (NotificationEntryNext != NULL)
    {
        NotificationEntry = NotificationEntryNext;
        for (i = 0; i < DCREFPERNOTIFICATION; i++)
        {
            DcRef = &NotificationEntry->DcRef[i];
            if ((*FreeDcRef == NULL) &&
                (DcRef->DcEntry == NULL))
            {
                *FreeDcRef = DcRef;
            } else if (DcRef->DcEntry == DataConsumer) {
                return(DcRef);
            }
        }
        NotificationEntryNext = NotificationEntry->Continuation;
    }


    if (*FreeDcRef == NULL)
    {
        //
        // DataConsumer is not specified in any DcRef and there are not
        // more free DcRefs. Allocate more of them
        Continuation = WmipAllocNotificationEntry();
        if (Continuation != NULL)
        {
            memcpy(&Continuation->Guid,
                   &NotificationEntry->Guid,
                   sizeof(GUID));
            *FreeDcRef = &Continuation->DcRef[0];
            NotificationEntry->Continuation = Continuation;
        }
    }
    return(NULL);
}


PDCREF WmipFindDCRefInNE(
    PNOTIFICATIONENTRY NotificationEntry,
    PDCENTRY DataConsumer
    )
/*++

Routine Description:

    Searches a notifications entry for the DCRef for a specific Data
    consumer.

    This routine assumes that the NotificationEntry specific or the global
    critical section has been taken.

Arguments:

    NotificationEntry is the notification entry to search through

    DataConsumer is the data consumer being searched for


Return Value:

    pointer to DCRef related to DataConsumeer or NULL

--*/
{
    PDCREF DcRef;
    ULONG i;

    WmipAssert(NotificationEntry != NULL);

    while (NotificationEntry != NULL)
    {
        for (i = 0; i < DCREFPERNOTIFICATION; i++)
        {
            DcRef = &NotificationEntry->DcRef[i];
            if (DcRef->DcEntry == DataConsumer)
            {
                return(DcRef);
            }
        }
        NotificationEntry = NotificationEntry->Continuation;
    }

    return(NULL);
}

PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    )
/*++

Routine Description:

    Searches mof resource list for a MR that has the same image path and
    resource name. If ine is found a reference count is added to it.

Arguments:

    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource

    MofResourceName points at a string that has the name of the MOF
        resource

Return Value:

    pointer to mof resource or NULL if not found

--*/
{
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;

    WmipEnterSMCritSection();

    MofResourceList = MRHeadPtr->Flink;
    while (MofResourceList != MRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                      MOFRESOURCE,
                                      MainMRList);
        if ((wcscmp(MofResource->MofImagePath, ImagePath) == 0) &&
            (wcscmp(MofResource->MofResourceName, MofResourceName) == 0))
        {
            WmipReferenceMR(MofResource);
            WmipLeaveSMCritSection();
            WmipAssert(MofResource->Signature == MR_SIGNATURE);
            return(MofResource);
        }
        MofResourceList = MofResourceList->Flink;
    }
    WmipLeaveSMCritSection();
    return(NULL);
}

BOOLEAN WmipIsNumber(
    LPCWSTR String
    )
{
    while (*String != UNICODE_NULL)
    {
        if ((*String < L'0') || (*String > L'9'))
        {
            return(FALSE);
        }
        String++;
    }
    return(TRUE);
}

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    )
/*++

Routine Description:

    This routine finds the instance set containing the instance name passed
    within the GuidEntry passed. If found it will also return the index of
    the instance name within the instance set. The instance set found has its
    ref count incremented.

Arguments:

    GuidEntry contains the instance sets to look through
    InstanceName is the instance name to look for
    *InstanceIndex return instance index within set

Return Value:

    Instance set containing instance name or NULL of instance name not found

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    ULONG BaseNameLen;
    PWCHAR InstanceNamePtr;
    ULONG InstanceNameIndex;
    ULONG InstanceSetFirstIndex, InstanceSetLastIndex;
    ULONG i;

    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
        if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
        {
            BaseNameLen = wcslen(InstanceSet->IsBaseName->BaseName);
            if (wcsncmp(InstanceName,
                        InstanceSet->IsBaseName->BaseName,
                        BaseNameLen) == 0)
            {
                InstanceNamePtr = InstanceName + BaseNameLen;
                InstanceNameIndex = _wtoi(InstanceNamePtr);
                InstanceSetFirstIndex = InstanceSet->IsBaseName->BaseIndex;
                InstanceSetLastIndex = InstanceSetFirstIndex + InstanceSet->Count;
                if (( (InstanceNameIndex >= InstanceSetFirstIndex) &&
                      (InstanceNameIndex < InstanceSetLastIndex)) &&
                    ((InstanceNameIndex != 0) || WmipIsNumber(InstanceNamePtr)))
                {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = InstanceNameIndex - InstanceSetFirstIndex;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   return(InstanceSet);
                }
            }
        } else if (InstanceSet->Flags & IS_INSTANCE_STATICNAMES) {
            for (i = 0; i < InstanceSet->Count; i++)
            {
                if (wcscmp(InstanceName,
                           InstanceSet->IsStaticNames->StaticNamePtr[i]) == 0)
               {
                   InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                   *InstanceIndex = i;
                   WmipReferenceIS(InstanceSet);
                   WmipAssert(InstanceSet->Signature == IS_SIGNATURE);
                   return(InstanceSet);
               }
            }
        }
        InstanceSetList = InstanceSetList->Flink;
    }
    return(NULL);
}

BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    )
/*++

Routine Description:

    Reallocate a buffer to a larger size while preserving data

Arguments:

    Buffer on entry has the buffer to be reallocated, on exit has the new
        buffer

    CurrentSize is the current size of the buffer

    NewSize has the new size desired

Return Value:

    TRUE if realloc was successful

--*/
{
    PVOID NewBuffer;

    WmipAssert(NewSize > CurrentSize);

    NewBuffer = WmipAlloc(NewSize);
    if (NewBuffer != NULL)
    {
        memset(NewBuffer, 0, NewSize);
        memcpy(NewBuffer, *Buffer, CurrentSize);
        if (FreeOriginalBuffer)
        {
            WmipFree(*Buffer);
        }
        *Buffer = NewBuffer;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\datastr.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    datastr.c

Abstract:

    WMI data structure management

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

GUID WmipBinaryMofGuid = BINARY_MOF_GUID;

ULONG WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    );

ULONG WmipMangleInstanceName(
    LPGUID Guid,
    PWCHAR Name,
    ULONG MaxMangledNameSize,
    PWCHAR MangledName
    );

BOOLEAN WmipIsNumber(
    LPCWSTR String
    );

VOID
WmipSaveTraceGuidMap(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    );

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR InstanceBaseName,
    ULONG InstanceCount
    );

ULONG WmipBuildInstanceSet(
    PWMIREGGUIDW RegGuid,
    PWMIREGINFOW RegisrationInfo,
    PBINSTANCESET InstanceSet,
    LPCTSTR MofImagePath
    );

BOOLEAN WmipValidateStringInRegInfo(
    PWMIREGINFOW RegistrationInfo,
    ULONG Offset,
    ULONG RegistrationInfoSize
    )
{
    PUSHORT StringCount;

    if (Offset == 0)
    {
        return(TRUE);
    } else if (Offset >= 0x80000000) {
        return(FALSE);
    }
    
    StringCount = (PUSHORT)OffsetToPtr(RegistrationInfo, Offset);
                                       
    Offset += sizeof(USHORT);
    if (Offset > RegistrationInfoSize)
    {
        return(FALSE);
    }
    
    if ((Offset + *StringCount) > RegistrationInfoSize)
    {
        return(FALSE);
    }
    
    return(TRUE);
}


BOOLEAN WmipValidateRegistrationInfo(
    PWMIREGINFOW RegistrationInfo,
    ULONG RegistrationInfoSize
    )    
{
    ULONG i,j;
    ULONG Offset, Size;
    PUSHORT StringCount;
    PWMIREGGUIDW RegGuid;
    
    //
    // Validate that RegistrationInfo is correct
    // 1. ->BufferSize is <= Actual buffer size
    // 2. ->RegistryPath is <= Actual buffer size
    // 3. ->MofResourceName is <= Actual buffer size
    // 4. All WmiRegGuid structures would fit into the buffer
    // 5. Any offsets within the WmiRegGuid structure are within
    //    the buffer
        
        
    if (RegistrationInfoSize < FIELD_OFFSET(WMIREGINFOW, WmiRegGuid))
    {
        WmipDebugPrint(("WMI: RegistrationInfoSize is bogus\n"));
        return(FALSE);
    }
    
    if (RegistrationInfo->BufferSize > RegistrationInfoSize)
    {
        WmipDebugPrint(("WMI: RegistrationInfo->BufferSize is bogus\n"));
        return(FALSE);
    }
    
    
    if (! WmipValidateStringInRegInfo(RegistrationInfo,
                                      RegistrationInfo->RegistryPath,
                                      RegistrationInfoSize))
    {
        WmipDebugPrint(("WMI: RegistrationInfo->RegistrationInfo is bogus\n"));
        return(FALSE);
    }
    
    if (! WmipValidateStringInRegInfo(RegistrationInfo,
                                      RegistrationInfo->MofResourceName,
                                      RegistrationInfoSize))
    {
        WmipDebugPrint(("WMI: RegistrationInfo->MofResourceName is bogus\n"));
        return(FALSE);
    }
    
    if (RegistrationInfo->GuidCount >= 0x80000000)
    {
        return(FALSE);
    }
    
    Size = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) + 
           (RegistrationInfo->GuidCount * sizeof(WMIREGGUIDW));
    if (Size > RegistrationInfoSize)
    {
        WmipDebugPrint(("WMI: RegistrationInfo->GuidCount is bogus\n"));
        return(FALSE);
    }
    
    for (i = 0; i < RegistrationInfo->GuidCount; i++)
    {
        RegGuid = &RegistrationInfo->WmiRegGuid[i];
        if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_LIST)
        {
            Offset = RegGuid->InstanceNameList;
            if (Offset >= 0x80000000)
            {
                return(FALSE);
            }
            for (j = 0; j < RegGuid->InstanceCount; j++)
            {
                if (! WmipValidateStringInRegInfo(RegistrationInfo,
                                                  Offset,
                                                  RegistrationInfoSize))
                {
                    WmipDebugPrint(("WMI: InstanceList bogus for RegGuid[%d]\n",
                                     i));
                    return(FALSE);
                }
                StringCount = (PUSHORT)OffsetToPtr(RegistrationInfo,
                                                   Offset);
                Offset += *StringCount + sizeof(USHORT);
            }
        } else if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_BASENAME) {
            if (! WmipValidateStringInRegInfo(RegistrationInfo,
                                              RegGuid->BaseNameOffset,
                                              RegistrationInfoSize))
            {
                WmipDebugPrint(("WMI: BaseName for RegGuid[%d] is bogus\n",
                                i));
                return(FALSE);
            }
        }
    }
    
    return(TRUE);
}


ULONG WmipAddDataSource(
    PTCHAR QueryBinding,
    ULONG RequestAddress,
    ULONG RequestContext,
    LPCTSTR MofImagePath,
    PWMIREGINFOW RegistrationInfo,
    ULONG RegistrationInfoSize,
    ULONG_PTR *ProviderId,
    BOOLEAN IsAnsi
    )
/*++

Routine Description:

    Adds a new data source to WMI data source list

Arguments:

    QueryBinding is the binding string of the data providers RPC server

    RequestAddress is the request callback address in data provider's process
        to call with WMI requests.

    RequestContext is the request context to pass to data provider's
        WMI request callback.

    MofImagePath is a pointer to an image that contains the MOF resource

    RegistrationInfo is a pointer to a data structure that has registration
        information

    RegistrationInfoSize is the number of bytes passed in the registration
        information parameter RegistrationInfo.
            
    ProviderId is a pointer to a ULONG_PTR that on entry contains the provider
        id for kernel mode providers. On return it contains the assigned
        provider id for user mode data providers.

    IsAnsi is TRUE then data provider is expecting all dynamic instance names
        to be Ansi and will put dynamic instance names in as ansi

Return Value:

    Error or success code

--*/
{
    PBDATASOURCE DataSource, DataSource2;
    ULONG Status;
    PWMIREGGUIDW RegGuid;
    PINSTANCESET BinaryMofInstanceSet = NULL;
    ULONG i,j;
    ULONG InstanceCount;
    PBINSTANCESET InstanceSet;
    PBGUIDENTRY GuidEntry;
    PWCHAR RegistryPath, RegistryPathTemp;
    BOOLEAN KmDataSource, AppendToDS;
    BYTE WnodeBuffer[sizeof(WNODE_HEADER) + AVGGUIDSPERDS * sizeof(GUID)];
    PWNODE_HEADER Wnode;
    LPWSTR MofResourceName, MofImagePathUnicode;
    LPWSTR MofResourceNamePtr;
    ULONG MofResourceNameLen;
    BOOLEAN NewMofResource;
#ifdef MEMPHIS
    LPSTR MofResourceNameAnsi;
#endif

#ifdef HEAPVALIDATION
    WmipDebugPrint(("WMI: Adding data source %x\n", *ProviderId));
    WmipAssert(RtlValidateProcessHeaps());
#endif

    if (! WmipValidateRegistrationInfo(RegistrationInfo,
                                       RegistrationInfoSize))
    {
        WmipDebugPrint(("WMI: Invalid Registration Info buffer for %ws\n",
                        MofImagePath ? MofImagePath : TEXT("Unknown")));
        WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                           EVENTLOG_WARNING_TYPE,
                           0,
                           sizeof(ULONG),
                           RegistrationInfo,
                           1,
                           MofImagePath ? MofImagePath : TEXT("Unknown"));
        return(ERROR_WMI_INVALID_REGINFO);
    }


    DataSource = WmipAllocDataSource();
    if (DataSource == NULL)
    {
        WmipDebugPrint(("WMI: WmipAddDataSource: WmipAllocDataSource failed\n"));
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (*ProviderId == 0)
    {
        //
        // User mode data provider specific initialization
        *ProviderId = (ULONG_PTR)DataSource;
        KmDataSource = FALSE;
        AppendToDS = FALSE;

        if ((QueryBinding != NULL) && (RequestAddress != 0))
        {
            DataSource->BindingString = WmipAlloc((_tcslen(QueryBinding) + 1) * sizeof(TCHAR));
            if (DataSource->BindingString != NULL)
            {
                _tcscpy(DataSource->BindingString, QueryBinding);
                DataSource->RequestAddress = RequestAddress;
                DataSource->RequestContext = RequestContext;
            } else {
                WmipUnreferenceDS(DataSource);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        } else {
            //
            // All data sources must supply a query binding
            WmipUnreferenceDS(DataSource);
            return(ERROR_INVALID_PARAMETER);
        }
    } else if (*ProviderId == INTERNAL_PROVIDER_ID) {
        DataSource->Flags |= DS_INTERNAL;
            KmDataSource = FALSE;
            AppendToDS = FALSE;
    } else {

        //
        // Kernel mode specific initialization

        //
        // We allow multiple registrations to use the same KM provider id. Any
        // new guids will be just added to the end of the current data source
        // and after that it will look as though they all came from a single
        // registration.

        WmipAssert(*ProviderId != 0);

        DataSource2 = WmipFindDSByProviderId(*ProviderId);
        if (DataSource2 != NULL)
        {
            WmipUnreferenceDS(DataSource2);
            WmipUnreferenceDS(DataSource);
            DataSource = DataSource2;
            AppendToDS = TRUE;
        } else {
            AppendToDS = FALSE;
        }
        KmDataSource = TRUE;
        DataSource->Flags |= DS_KERNEL_MODE;
    }

    if (! AppendToDS)
    {
        //
        // This is the first registration for the data source so do any
        // one time data source initialization now
        DataSource->ProviderId = *ProviderId;
    }

    //
    // Loop over each guid being registered and build instance sets and
    // guid entries.
    RegGuid = RegistrationInfo->WmiRegGuid;

    for (i = 0; i < RegistrationInfo->GuidCount; i++, RegGuid++)
    {
        if (! (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID))
        {
            //
            // Allocate an instance set for this new set of instances
            InstanceSet = WmipAllocInstanceSet();
            if (InstanceSet == NULL)
            {
                WmipUnreferenceDS(DataSource);
                WmipDebugPrint(("WMI: WmipAddDataSource: WmipAllocInstanceSet failed\n"));
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            //
            // We will allocate a proper guid entry for the instance set when
            // the data source gets linked into the main data source list so
            // we stash a pointer to the guid away now.
            InstanceSet->GuidEntry = (PBGUIDENTRY)&RegGuid->Guid;

            //
            // Minimally initialize the InstanceSet and add it to the DataSource's
            // list of InstanceSets. We do this first so that if there is any
            // failure below and the DataSource can'e be fully registered the
            // instance set and guid entry will be free when the DataSource is
            // freed.
            InstanceSet->DataSource = DataSource;
            InstanceSet->Flags |= IS_NEWLY_REGISTERED;

            if (IsAnsi)
            {
                InstanceSet->Flags |= IS_ANSI_INSTANCENAMES;
            }

            if (DataSource->Flags & DS_INTERNAL)
            {
                InstanceSet->Flags |= IS_INTERNAL_PROVIDER;
            }


            Status = WmipBuildInstanceSet(RegGuid,
                                          RegistrationInfo,
                                          InstanceSet,
                                          MofImagePath);

            //
            // If this is the guid that represents the binary mof data
            // then remember the InstanceSet for  later
            if (IsEqualGUID(&RegGuid->Guid, &WmipBinaryMofGuid))
            {
                BinaryMofInstanceSet = InstanceSet;
            }


            InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);

            if (Status != ERROR_SUCCESS)
            {
                WmipUnreferenceDS(DataSource);
                return(Status);
            }
        }
    }

    if (! AppendToDS)
    {
        //
        // If this is the first time the data provider has registered then
        // Build registry path in data source
        RegistryPath = (LPWSTR)OffsetToPtr(RegistrationInfo, RegistrationInfo->RegistryPath);
        if ( (RegistrationInfo->RegistryPath != 0) &&
             (WmipValidateCountedString(RegistryPath)) )
        {
            RegistryPathTemp = WmipAlloc((*RegistryPath+1) * sizeof(WCHAR));
            if (RegistryPathTemp == NULL)
            {
                WmipDebugPrint(("WMI: WmipAddDataSource: Couldn't allocate RegistryPath\n"));
                WmipUnreferenceDS(DataSource);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            memcpy(RegistryPathTemp, RegistryPath+1, *RegistryPath);
            RegistryPathTemp[*RegistryPath/sizeof(WCHAR)] = UNICODE_NULL;
#ifdef MEMPHIS
            //
            // We won't worry about a failure in converting the registry path
            // since currently the registry path is only used for ACL checking
            // and there are not ACLs on memphis so who cares. If we ever
            // start using the registry path for anything else then we will
            // need to start worrying about a failure here.
            DataSource->RegistryPath = NULL;
            UnicodeToAnsi(RegistryPathTemp, &DataSource->RegistryPath, NULL);
            WmipFree(RegistryPathTemp);
#else
            DataSource->RegistryPath = RegistryPathTemp;
#endif
        } else {
            WmipDebugPrint(("WMI: Invalid or missing registry path passed %x\n",
                        RegistryPath));
            DataSource->RegistryPath = NULL;
        }

        WmipEnterSMCritSection();
        Status = WmipLinkDataSourceToList(DataSource, TRUE);
        WmipLeaveSMCritSection();

        if (Status != ERROR_SUCCESS)
        {
            WmipUnreferenceDS(DataSource);
        }
    } else {
        WmipEnterSMCritSection();
        Status = WmipLinkDataSourceToList(DataSource, FALSE);
        WmipLeaveSMCritSection();

        if (Status != ERROR_SUCCESS)
        {
            WmipUnreferenceDS(DataSource);
        }
    }

    if (Status != ERROR_SUCCESS)
    {
        // For some reason we could not link the data source and guids to
        // their lists. Note that WmipLinkDataSourceToList had already
        // freed the could have been DataSource.
        return(Status);
    }

    if (BinaryMofInstanceSet != NULL)
    {
        WmipGenerateBinaryMofNotification(BinaryMofInstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);

    }

    MofResourceNamePtr = (LPWSTR)OffsetToPtr(RegistrationInfo, 
                                             (RegistrationInfo->MofResourceName));
    MofResourceNameLen = *MofResourceNamePtr++;
    if ((MofImagePath != NULL) && 
        (RegistrationInfo->MofResourceName != 0) &&
        (MofResourceNameLen != 0))
    {
        MofResourceName = WmipAlloc(MofResourceNameLen + sizeof(WCHAR));
        if (MofResourceName != NULL)
        {
            MofResourceNameLen /= sizeof(WCHAR);
            wcsncpy(MofResourceName, MofResourceNamePtr, MofResourceNameLen);
            MofResourceName[MofResourceNameLen] = UNICODE_NULL;
        
#ifdef MEMPHIS
            MofImagePathUnicode = NULL;
            if (AnsiToUnicode(MofImagePath, &MofImagePathUnicode) == ERROR_SUCCESS) {
#else
                MofImagePathUnicode = (LPWSTR)MofImagePath;
#endif
        
                Status = WmipBuildMofClassInfo(
                            DataSource,
                            MofImagePathUnicode,
                            MofResourceName,
                            &NewMofResource);
            
                if ((Status == ERROR_SUCCESS) && NewMofResource)
                {
                    WmipGenerateMofResourceNotification(MofImagePathUnicode,
                                                           MofResourceName,
                                        &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
                }
        
#ifdef MEMPHIS
                WmipFree(MofImagePathUnicode);
            }
#endif
            
        
            WmipFree(MofResourceName);
        } else {
            WmipDebugPrint(("WMI: WmipAddDataSource: Couldn't alloc for MofResourcedbName\n"));
        }
    }

    //
    // Send a notification about new/changed guids
    Wnode = WmipGenerateRegistrationNotification(DataSource,
                                                (PWNODE_HEADER)WnodeBuffer,
                                                 AVGGUIDSPERDS,
                                                 RegistrationAdd);

    //
    // First fire the internal registration change notification and then for
    // any data consumers who are interested
    WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);
    memcpy(&Wnode->Guid, &GUID_REGISTRATION_CHANGE_NOTIFICATION, sizeof(GUID));
    Wnode->Flags &= ~WNODE_FLAG_INTERNAL;
    WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);

    if (Wnode != (PWNODE_HEADER)WnodeBuffer)
    {
        WmipFree(Wnode);
    }

#ifdef HEAPVALIDATION
    WmipAssert(RtlValidateProcessHeaps());
#endif

    return(ERROR_SUCCESS);
}

ULONG WmipBuildInstanceSet(
    PWMIREGGUID RegGuid,
    PWMIREGINFOW RegistrationInfo,
    PBINSTANCESET InstanceSet,
    LPCTSTR MofImagePath
    )
{
    PWCHAR InstanceName, InstanceNamePtr;
    PBISBASENAME IsBaseName;
    PBISSTATICNAMES IsStaticName;
    ULONG SizeNeeded;
    ULONG SuffixSize;
    PWCHAR StaticNames;
    ULONG Len;
    ULONG InstanceCount;
    ULONG j;
    ULONG MaxStaticInstanceNameSize;
    PWCHAR StaticInstanceNameBuffer;

    InstanceCount = RegGuid->InstanceCount;

    InstanceSet->Count = InstanceCount;

    //
    // Reset any flags that might be changed by a new REGGUID
    InstanceSet->Flags &= ~(IS_EXPENSIVE |
                            IS_EVENT_ONLY |
                            IS_PDO_INSTANCENAME |
                            IS_INSTANCE_STATICNAMES |
                            IS_INSTANCE_BASENAME);

    //
    // Finish initializing the Instance Set
    if (RegGuid->Flags & WMIREG_FLAG_EXPENSIVE)
    {
        InstanceSet->Flags |= IS_EXPENSIVE;
    }

    if (RegGuid->Flags & WMIREG_FLAG_TRACED_GUID)
    {
        //
        // This guid is not queryable, but is used for sending trace
        // events. We mark the InstanceSet as special
        InstanceSet->Flags |= IS_TRACED;

        if (RegGuid->Flags & WMIREG_FLAG_TRACE_CONTROL_GUID)
        {
            InstanceSet->Flags |= IS_CONTROL_GUID;
        }
    }

    if (RegGuid->Flags & WMIREG_FLAG_EVENT_ONLY_GUID)
    {
        //
        // This guid is not queryable, but is only used for sending
        // events. We mark the InstanceSet as special
        InstanceSet->Flags |= IS_EVENT_ONLY;
    }

    InstanceName = (LPWSTR)OffsetToPtr(RegistrationInfo,
                                       RegGuid->BaseNameOffset);

    if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_LIST)
    {
        //
        // We have static list of instance names that might need mangling
        // We assume that any name mangling that must occur can be
        // done with a suffix of 5 or fewer characters. This allows
        // up to 100,000 identical static instance names within the
        // same guid.
        SizeNeeded = FIELD_OFFSET(ISSTATICENAMES, StaticNamePtr);
        SuffixSize = MAXBASENAMESUFFIXSIZE;
        InstanceNamePtr = InstanceName;
        MaxStaticInstanceNameSize = 0;
        for (j = 0; j < InstanceCount; j++)
        {
            if (! WmipValidateCountedString(InstanceNamePtr))
            {
                WmipDebugPrint(("WMI: WmipAddDataSource: bad static instance name %x\n", InstanceNamePtr));
                WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       RegistrationInfo->BufferSize,
                                       RegistrationInfo,
                                       1,
                                       MofImagePath ? MofImagePath : TEXT("Unknown"));
                return(ERROR_WMI_INVALID_REGINFO);
            }

            if (*InstanceNamePtr > MaxStaticInstanceNameSize)
            {
                MaxStaticInstanceNameSize = *InstanceNamePtr;
            }
            SizeNeeded += *InstanceNamePtr + 1 + SuffixSize +
                            (sizeof(PWCHAR) / sizeof(WCHAR));
            InstanceNamePtr += (*((USHORT *)InstanceNamePtr) + 2) / sizeof(WCHAR);
        }

        IsStaticName = (PBISSTATICNAMES)WmipAllocString(SizeNeeded);
        if (IsStaticName == NULL)
        {
            WmipDebugPrint(("WMI: WmipAddDataSource: alloc static instance names\n"));
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        InstanceSet->Flags |= IS_INSTANCE_STATICNAMES;
        InstanceSet->IsStaticNames = IsStaticName;
        StaticNames = (PWCHAR) ((PBYTE)IsStaticName +
                                 (InstanceCount * sizeof(PWCHAR)));
        InstanceNamePtr = InstanceName;
        StaticInstanceNameBuffer = WmipAlloc(MaxStaticInstanceNameSize + sizeof(WCHAR));
        if (StaticInstanceNameBuffer == NULL)
        {
            WmipDebugPrint(("WMI: WmipAddDataSource: couldn't alloc StaticInstanceNameBuffer\n"));
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        for (j = 0; j < InstanceCount; j++)
        {
            IsStaticName->StaticNamePtr[j] = StaticNames;
            memcpy(StaticInstanceNameBuffer, InstanceNamePtr+1, *InstanceNamePtr);
            StaticInstanceNameBuffer[*InstanceNamePtr/sizeof(WCHAR)] = UNICODE_NULL;
            Len = WmipMangleInstanceName(&RegGuid->Guid,
                                        StaticInstanceNameBuffer,
                                       *InstanceNamePtr +
                                          SuffixSize + 1,
                                        StaticNames);
            StaticNames += Len;
            InstanceNamePtr += (*((USHORT *)InstanceNamePtr) + 2)/sizeof(WCHAR);
        }



        WmipFree(StaticInstanceNameBuffer);
    } else if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_BASENAME) {
        //
        // We have static instance names built from a base name

        if (! WmipValidateCountedString(InstanceName))
        {
            WmipDebugPrint(("WMI: WmipAddDataSource: Invalid instance base name %x\n",
                                    InstanceName));
            WmipReportEventLog(EVENT_WMI_INVALID_REGINFO,
                                       EVENTLOG_WARNING_TYPE,
                                       0,
                                       RegistrationInfo->BufferSize,
                                       RegistrationInfo,
                                       1,
                                       MofImagePath ? MofImagePath : TEXT("Unknown"));
            return(ERROR_WMI_INVALID_REGINFO);
        }

        InstanceSet->Flags |= IS_INSTANCE_BASENAME;

        if (RegGuid->Flags & WMIREG_FLAG_INSTANCE_PDO)
        {
            InstanceSet->Flags |= IS_PDO_INSTANCENAME;
        }

        IsBaseName = (PBISBASENAME)WmipAlloc(*InstanceName +
                                              sizeof(WCHAR) +
                                              FIELD_OFFSET(ISBASENAME, 
                                                           BaseName));
        if (IsBaseName == NULL)
        {
            WmipDebugPrint(("WMI: WmipAddDataSource: alloc ISBASENAME failed\n"));
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        InstanceSet->IsBaseName = IsBaseName;

        memcpy(IsBaseName->BaseName, InstanceName+1, *InstanceName);
        IsBaseName->BaseName[*InstanceName/sizeof(WCHAR)] = UNICODE_NULL;
        IsBaseName->BaseIndex = WmipDetermineInstanceBaseIndex(
                                                    &RegGuid->Guid,
                                                    IsBaseName->BaseName,
                                                    RegGuid->InstanceCount);

    }
    return(ERROR_SUCCESS);
}


ULONG WmipLinkDataSourceToList(
    PBDATASOURCE DataSource,
    BOOLEAN AddDSToList
    )
/*++

Routine Description:

    This routine will take a DataSource that was just registered or updated
    and link any new InstanceSets to an appropriate GuidEntry. Then if the
    AddDSToList is TRUE the DataSource itself will be added to the main
    data source list.

    This routine will do all of the linkages within a critical section so the
    data source and its new instances are added atomically. The routine will
    also determine if the guid entry associated with a InstanceSet is a
    duplicate of another that is already on the main guid entry list and if
    so will use the preexisting guid entry.

    This routine assumes that the SM critical section has been taken

Arguments:

    DataSource is a based pointer to a DataSource structure

    AddDSToList    is TRUE then data source will be added to the main list
        of data sources

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PBINSTANCESET InstanceSet;
    PLIST_ENTRY InstanceSetList;
    PBGUIDENTRY GuidEntry;

    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);
        //
        // If this instance set has just been registered then we need to
        // get it on a GuidEntry list.
        if (InstanceSet->Flags & IS_NEWLY_REGISTERED)
        {
            //
            // See if there is already a GUID entry for the instance set.
            // If not go allocate a new guid entry and place it on the
            // main guid list. If there already is a GuidEntry for the
            // InstanceSet we will assign the ref count that was given by
            // the WmipFindGEByGuid to the DataSource which will unreference
            // the GuidEntry when the DataSource is unregistered.
            GuidEntry = WmipFindGEByGuid((LPGUID)InstanceSet->GuidEntry, 
                                          FALSE);
            if (GuidEntry == NULL)
            {
                GuidEntry = WmipAllocGuidEntry();
                if (GuidEntry == NULL)
                {
                    WmipDebugPrint(("WMI: WmipLinkDataSourceToList: WmipAllocGuidEntry failed\n"));
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                //
                // Initialize the new GuidEntry and place it on the master
                // GuidEntry list.
                memcpy(&GuidEntry->Guid,
                       (LPGUID)InstanceSet->GuidEntry,
                       sizeof(GUID));

                InsertHeadList(GEHeadPtr, &GuidEntry->MainGEList);
            }
            InstanceSet->GuidEntry = GuidEntry;
            InstanceSet->Flags &= ~IS_NEWLY_REGISTERED;
            InsertTailList(&GuidEntry->ISHead, &InstanceSet->GuidISList);
            GuidEntry->ISCount++;
        }

        InstanceSetList = InstanceSetList->Flink;
    }


    if (AddDSToList)
    {
        WmipAssert(! (DataSource->Flags & FLAG_ENTRY_ON_INUSE_LIST));

        DataSource->Flags |= FLAG_ENTRY_ON_INUSE_LIST;
        InsertTailList(DSHeadPtr, &DataSource->MainDSList);
    }

    return(ERROR_SUCCESS);
}

ULONG WmipDetermineInstanceBaseIndex(
    LPGUID Guid,
    PWCHAR BaseName,
    ULONG InstanceCount
    )
/*++

Routine Description:

    Figure out the base index for the instance names specified by a base
    instance name. We walk the list of instances sets for the guid and if
    there is a match in the base instance name we set the base instance index
    above that used by the previously registered instance set.

Arguments:

    Guid points at guid for the instance names
    BaseName points at the base name for the instances
    InstanceCount is the count of instance names

Return Value:

    Base index for instance name

--*/
{
    PBGUIDENTRY GuidEntry;
    ULONG BaseIndex = 0;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    ULONG LastBaseIndex;

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);
    if (GuidEntry != NULL)
    {
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
            {
                if (wcscmp(BaseName, InstanceSet->IsBaseName->BaseName) == 0)
                {
                    LastBaseIndex = InstanceSet->IsBaseName->BaseIndex + InstanceSet->Count;
                    if (BaseIndex <= LastBaseIndex)
                    {
                        BaseIndex = LastBaseIndex;
                    }
                }
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipUnreferenceGE(GuidEntry);
    }
    WmipDebugPrint(("WMI: Static instance name %ws has base index %x\n",
                    BaseName, BaseIndex));
    return(BaseIndex);
}

ULONG WmipMangleInstanceName(
    LPGUID Guid,
    PWCHAR Name,
    ULONG MaxMangledNameLen,
    PWCHAR MangledName
    )
/*++

Routine Description:

    Copies a static instance name from the input buffer to the output
    buffer, mangling it if the name collides with another name for the
    same guid.

Arguments:

    Guid points at guid for the instance name
    Name points at the proposed instance name
    MaxMangledNameLen has the maximum number of chars in mangled name buffer
    MangledName points at buffer to return mangled name

Return Value:

    Actual length of mangled name

--*/
{
    PBGUIDENTRY GuidEntry;
    WCHAR ManglingChar;
    ULONG ManglePos;
    ULONG InstanceIndex;
    PBINSTANCESET InstanceSet;

    WmipAssert(MaxMangledNameLen >= wcslen(Name));

    wcsncpy(MangledName, Name, MaxMangledNameLen);

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    if (GuidEntry != NULL)
    {
        ManglePos = wcslen(MangledName)-1;
        ManglingChar = L'Z';

        //
        // Loop until we get a unique name
        InstanceSet = WmipFindISinGEbyName(GuidEntry,
                                           MangledName,
                                           &InstanceIndex);
        while (InstanceSet != NULL)
        {
            WmipUnreferenceIS(InstanceSet);
            WmipDebugPrint(("WMI: Need to mangle name %ws\n",
                                MangledName));
            if (ManglingChar == L'Z')
            {
                ManglingChar = L'A';
                if (ManglePos++ == MaxMangledNameLen)
                {
                    WmipDebugPrint(("WMI: Instance Name could not be mangled\n"));
                    break;
                }
                MangledName[ManglePos+1] = UNICODE_NULL;
            } else {
                ManglingChar++;
            }
            MangledName[ManglePos] = ManglingChar;
            InstanceSet = WmipFindISinGEbyName(GuidEntry,
                                               MangledName,
                                               &InstanceIndex) ;
        }
        WmipUnreferenceGE(GuidEntry);
    }

    return(wcslen(MangledName)+1);
}

void WmipEnableCollectionForNewGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PNOTIFICATIONENTRY NotificationEntry;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    memset(&Wnode, 0, sizeof(WNODE_HEADER));
    memcpy(&Wnode.Guid, Guid, sizeof(GUID));
    Wnode.BufferSize = sizeof(WNODE_HEADER);

    WmipEnterSMCritSection();
    NotificationEntry = WmipFindNEByGuid(Guid, FALSE);
    if (NotificationEntry != NULL)
    {
        if ((NotificationEntry->EventRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_EVENT) == 0))

        {
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags |= IS_ENABLE_EVENT;

            //
            // If it is Tracelog, NewGuid notifications are piggybacked with
            // Registration call return. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED);
            if (IsTraceLog) 
            {
                if (!(InstanceSet->DataSource->Flags & DS_KERNEL_MODE) ) {
                    if (GuidEntry != NULL)
                    {
                        WmipUnreferenceGE(GuidEntry);
                    }
                    WmipUnreferenceNE(NotificationEntry);
                    WmipLeaveSMCritSection();
                    return;
                }
                //
                // For the Kernel Mode Trace Providers pass on the context
                //
                Wnode.HistoricalContext = NotificationEntry->LoggerContext;
            }

            NotificationEntry->Flags |= NE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(WMI_ENABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (NotificationEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(NotificationEntry,
                                          GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           NotificationEntry->LoggerContext,
                                          NE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                NotificationEntry->Flags &= ~NE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        if ((NotificationEntry->CollectRefCount > 0) &&
            ((InstanceSet->Flags & IS_ENABLE_COLLECTION) == 0)  &&
            (InstanceSet->Flags & IS_EXPENSIVE) )

        {
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            NotificationEntry->Flags |= NE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags |= IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(WMI_ENABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (NotificationEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(NotificationEntry,
                                          GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          NE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                NotificationEntry->Flags &= ~NE_FLAG_COLLECTION_IN_PROGRESS;
		
		//
        	// If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                if (NotificationEntry->CollectInProgress != NULL)
	 	{            
		    WmipReleaseCollectionEnabled(NotificationEntry);
		}
            }
        }

        //
        // Guid is already enabled so we need to enable this new one
        WmipUnreferenceNE(NotificationEntry);
    }

    WmipLeaveSMCritSection();
    if (GuidEntry != NULL)
    {
        WmipUnreferenceGE(GuidEntry);
    }
}

void WmipDisableCollectionForRemovedGuid(
    LPGUID Guid,
    PBINSTANCESET InstanceSet
    )
{
    WNODE_HEADER Wnode;
    PNOTIFICATIONENTRY NotificationEntry;
    PBGUIDENTRY GuidEntry;
    ULONG Status;
    BOOLEAN IsTraceLog;

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);

    memset(&Wnode, 0, sizeof(WNODE_HEADER));
    memcpy(&Wnode.Guid, Guid, sizeof(GUID));
    Wnode.BufferSize = sizeof(WNODE_HEADER);

    WmipEnterSMCritSection();
    NotificationEntry = WmipFindNEByGuid(Guid, FALSE);
    if (NotificationEntry != NULL)
    {
        if ((NotificationEntry->EventRefCount > 0) &&
               ((InstanceSet->Flags & IS_ENABLE_EVENT) != 0))

        {
            // Events were previously enabled for this guid, but not for this
            // instance set so call data source for instance set to enable
            // the events. First set the in progress flag and InstanceSet
            // set flag to denote that events have been enabled for the
            // instance set.
            InstanceSet->Flags &= ~IS_ENABLE_EVENT;

            //
            // If it is Tracelog, RemoveGuid notifications are handled
            // through UnregisterGuids call. 
            //
            IsTraceLog = ((InstanceSet->Flags & IS_TRACED) == IS_TRACED);
            if (IsTraceLog)
            {
                if ( !(InstanceSet->DataSource->Flags & DS_KERNEL_MODE)) {
                    if (GuidEntry != NULL)
                    {
                        WmipUnreferenceGE(GuidEntry);
                    }
                    WmipUnreferenceNE(NotificationEntry);
                    WmipLeaveSMCritSection();
                    return;
                }
                Wnode.HistoricalContext = NotificationEntry->LoggerContext;
            }


            NotificationEntry->Flags |= NE_FLAG_NOTIFICATION_IN_PROGRESS;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(WMI_DISABLE_EVENTS,
                                 InstanceSet->DataSource,
                                 &Wnode);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (NotificationEntry->EventRefCount == 0)
            {
                Status = WmipDoDisableRequest(NotificationEntry,
                                          GuidEntry,
                                          TRUE,
                                             IsTraceLog,
                                           NotificationEntry->LoggerContext,
                                          NE_FLAG_NOTIFICATION_IN_PROGRESS);

            } else {
                NotificationEntry->Flags &= ~NE_FLAG_NOTIFICATION_IN_PROGRESS;
            }
        }

        //
        // Now check to see if collection needs to be enabled for this guid
        if ((NotificationEntry->CollectRefCount > 0) &&
               ((InstanceSet->Flags & IS_ENABLE_COLLECTION) != 0))

        {
            // Collection was previously enabled for this guid, but not
            // for this instance set so call data source for instance set
            // to enable collection. First set the in progress flag and
            // InstanceSet set flag to denote that collection has been enabled
            //  for the instance set.
            NotificationEntry->Flags |= NE_FLAG_COLLECTION_IN_PROGRESS;
            InstanceSet->Flags &= ~IS_ENABLE_COLLECTION;

            WmipLeaveSMCritSection();
            WmipDeliverWnodeToDS(WMI_DISABLE_COLLECTION,
                                 InstanceSet->DataSource,
                                 &Wnode);
            WmipEnterSMCritSection();

            //
            // Now we need to check if events were disabled while the enable
            // request was in progress. If so go do the work to actually
            // disable them.
            if (NotificationEntry->CollectRefCount == 0)
            {
                Status = WmipDoDisableRequest(NotificationEntry,
                                          GuidEntry,
                                          FALSE,
                                             FALSE,
                                           0,
                                          NE_FLAG_COLLECTION_IN_PROGRESS);

            } else {
                NotificationEntry->Flags &= ~NE_FLAG_COLLECTION_IN_PROGRESS;
		
		//
        	// If there are any other threads that were waiting 
                // until all of the enable/disable work completed, we 
                // close the event handle to release them from their wait.
                //
                if (NotificationEntry->CollectInProgress != NULL)
	 	{            
		    WmipReleaseCollectionEnabled(NotificationEntry);
		}
            }
        }

        //
        // Guid is already enabled so we need to enable this new one
        WmipUnreferenceNE(NotificationEntry);
    }

    WmipLeaveSMCritSection();
    if (GuidEntry != NULL)
    {
        WmipUnreferenceGE(GuidEntry);
    }
}

PWNODE_HEADER WmipGenerateRegistrationNotification(
    PBDATASOURCE DataSource,
    PWNODE_HEADER WnodeBuffer,
    ULONG GuidMax,
    ULONG NotificationCode
    )
{
    PWNODE_HEADER Wnode2;
    LPGUID GuidPtr;
    ULONG GuidCount;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PWNODE_HEADER Wnode = WnodeBuffer;
    LPGUID Guid;

    //
    // Build notification containing all guids that are going to being
    // removed. We build it now and then send it after the data source
    // is removed.

    WmipReferenceDS(DataSource);

    GuidCount = 0;
    GuidPtr = (LPGUID)((PBYTE)Wnode + sizeof(WNODE_HEADER));
    InstanceSetList =  DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        if (GuidCount == GuidMax)
        {
            GuidMax = GuidMax + AVGGUIDSPERDS;
            Wnode2 = WmipAlloc(sizeof(WNODE_HEADER) + GuidMax * sizeof(GUID));
            if (Wnode2 == NULL)
            {
                WmipDebugPrint(("WMI: GenerateRegistrationNotification couldn't alloc extra guids\n"));
                break;
            }
            memcpy(Wnode2, Wnode, sizeof(WNODE_HEADER) + GuidCount * sizeof(GUID));
            if (Wnode != WnodeBuffer)
            {
                WmipFree(Wnode);
            }
            Wnode = Wnode2;
            GuidPtr = (LPGUID)((PBYTE)Wnode + sizeof(WNODE_HEADER));
            GuidPtr += GuidCount;
        }

        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        Guid = &InstanceSet->GuidEntry->Guid;
        *GuidPtr++ = *Guid;

        if (NotificationCode == RegistrationAdd)
        {
            WmipEnableCollectionForNewGuid(Guid, InstanceSet);
        } else if (NotificationCode == RegistrationDelete) {
            WmipDisableCollectionForRemovedGuid(Guid, InstanceSet);
        }

        //
        //  If this is a Trace Provider, then add the Unregistering Guids
        //  to the GuidMapList if a logger session is active.
        //  If there is a notification entry for this Guid, then we take
        //  it that there is a logger session active.
        //
        if ( (NotificationCode == RegistrationDelete) &&
             (InstanceSet->Flags & IS_TRACED) )
        {
            WmipSaveTraceGuidMap(Guid, InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
        GuidCount++;
    }
    WmipUnreferenceDS(DataSource);

    WmipBuildRegistrationNotification(Wnode, sizeof(WNODE_HEADER) + GuidCount * sizeof(GUID), NotificationCode, GuidCount);

    return(Wnode);
}

void WmipRemoveDataSource(
    ULONG_PTR ProviderId
    )
{
    PBDATASOURCE DataSource;
    
    DataSource = WmipFindDSByProviderId(ProviderId);
    if (DataSource != NULL)
    {
        WmipRemoveDataSourceByDS(DataSource);
        WmipUnreferenceDS(DataSource);
    } else {
        WmipDebugPrint(("WMI: Attempt to remove non existant data source %x\n",
                        ProviderId));
    }
}

void WmipRemoveDataSourceByDS(
    PBDATASOURCE DataSource
    )
{    
    BYTE WnodeBuffer[sizeof(WNODE_HEADER) + AVGGUIDSPERDS * sizeof(GUID)];
    PWNODE_HEADER Wnode;
    PLIST_ENTRY MofResourceList;
#ifdef WMI_USER_MODE
    PLIST_ENTRY MofClassList;
    PMOFCLASS MofClass;
#endif
    PMOFRESOURCE MofResource;

    Wnode = WmipGenerateRegistrationNotification(DataSource,
                                                (PWNODE_HEADER)WnodeBuffer,
                                                 AVGGUIDSPERDS,
                                                 RegistrationDelete);

    WmipUnreferenceDS(DataSource);

    WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);

    memcpy(&Wnode->Guid, &GUID_REGISTRATION_CHANGE_NOTIFICATION, sizeof(GUID));
    Wnode->Flags &= ~WNODE_FLAG_INTERNAL;
    WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);
    if (Wnode != (PWNODE_HEADER)WnodeBuffer)
    {
        WmipFree(Wnode);
    }
}

void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;
    ULONG i;

    if (BinaryMofInstanceSet->Count == 0)
    {
        return;
    }

    for (i = 0; i < BinaryMofInstanceSet->Count; i++)
    {
        ImagePathLen = sizeof(USHORT);
        InstanceNameLen = (sizeof(USHORT) + 7) & ~7;

        if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
        {
            ResourceNameLen = ((wcslen(BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i])+1) * sizeof(WCHAR)) + sizeof(USHORT);
        } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
            ResourceNameLen = (((wcslen(BinaryMofInstanceSet->IsBaseName->BaseName) +
                             MAXBASENAMESUFFIXSIZE) * sizeof(WCHAR)) + sizeof(USHORT));
        } else {
            return;
        }

        BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

        Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
        if (Wnode != NULL)
        {
            Wnode->WnodeHeader.BufferSize = BufferSize;
            Wnode->WnodeHeader.ProviderId = 0;
            Wnode->WnodeHeader.Version = 1;
            Wnode->WnodeHeader.Linkage = 0;
            Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                        WNODE_FLAG_SINGLE_INSTANCE);
            memcpy(&Wnode->WnodeHeader.Guid,
                   Guid,
                   sizeof(GUID));
            WmiInsertTimestamp(&Wnode->WnodeHeader);
            Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
            Wnode->DataBlockOffset = Wnode->OffsetInstanceName + 
                                      InstanceNameLen;
            Wnode->SizeDataBlock = ImagePathLen + ResourceNameLen;
            Ptr = (PWCHAR)&Wnode->VariableData;

            *Ptr++ = 0;              // Empty instance name
            
            Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
            *Ptr++ = 0;              // Empty image path

            // Instance name for binary mof resource
            if (BinaryMofInstanceSet->Flags & IS_INSTANCE_STATICNAMES)
            {
                *Ptr++ = (USHORT)(ResourceNameLen - sizeof(USHORT));
                wcscpy(Ptr, BinaryMofInstanceSet->IsStaticNames->StaticNamePtr[i]);
            } else if (BinaryMofInstanceSet->Flags & IS_INSTANCE_BASENAME) {
#ifdef MEMPHIS
                *Ptr = swprintf(Ptr+1,
                                L"%ws%d",
                                BinaryMofInstanceSet->IsBaseName->BaseName,
                                BinaryMofInstanceSet->IsBaseName->BaseIndex+i) * sizeof(WCHAR);
#else
                *Ptr = (USHORT)wsprintfW(Ptr+1,
                                     L"%ws%d",
                                     BinaryMofInstanceSet->IsBaseName->BaseName,
                                     BinaryMofInstanceSet->IsBaseName->BaseIndex+i) * sizeof(WCHAR);
#endif
            }

            WmipEventNotification((PWNODE_HEADER)Wnode, 
                              TRUE, 
                                ((PWNODE_HEADER)Wnode)->BufferSize);
            WmipFree(Wnode);
        }
    }
}

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid        
    )
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG ImagePathLen, ResourceNameLen, InstanceNameLen, BufferSize;
    PWCHAR Ptr;


    ImagePathLen = (wcslen(ImagePath) + 2) * sizeof(WCHAR);

    ResourceNameLen = (wcslen(ResourceName) + 2) * sizeof(WCHAR);
    InstanceNameLen = ( sizeof(USHORT)+7 ) & ~7;
    BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                      InstanceNameLen +
                      ImagePathLen +
                      ResourceNameLen;

    Wnode = (PWNODE_SINGLE_INSTANCE)WmipAlloc(BufferSize);
    if (Wnode != NULL)
    {
        Wnode->WnodeHeader.BufferSize = BufferSize;
        Wnode->WnodeHeader.ProviderId = 0;
        Wnode->WnodeHeader.Version = 1;
        Wnode->WnodeHeader.Linkage = 0;
        Wnode->WnodeHeader.Flags = (WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_SINGLE_INSTANCE);
        memcpy(&Wnode->WnodeHeader.Guid,
               Guid,
               sizeof(GUID));
        WmiInsertTimestamp(&Wnode->WnodeHeader);
        Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                 VariableData);
        Wnode->DataBlockOffset = Wnode->OffsetInstanceName + InstanceNameLen;
        Wnode->SizeDataBlock = ImagePathLen + ResourceNameLen;
        Ptr = (PWCHAR)&Wnode->VariableData;

        *Ptr = 0;              // Empty instance name

                                 // ImagePath name
        Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
        ImagePathLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ImagePathLen;
        memcpy(Ptr, ImagePath, ImagePathLen);
        Ptr += (ImagePathLen / sizeof(WCHAR));

                                 // MofResource Name
        ResourceNameLen -= sizeof(USHORT);
        *Ptr++ = (USHORT)ResourceNameLen;
        memcpy(Ptr, ResourceName, ResourceNameLen);

        WmipEventNotification((PWNODE_HEADER)Wnode,
                              TRUE,
                              ((PWNODE_HEADER)Wnode)->BufferSize);
        WmipFree(Wnode);
    }
}

void WmipSendGuidUpdateNotifications(
    NOTIFICATIONTYPES NotificationType,
    ULONG GuidCount,
    PTRCACHE *GuidList
    )
{
    PBYTE WnodeBuffer;
    PWNODE_HEADER Wnode;
    ULONG WnodeSize;
    LPGUID WnodeGuidPtr;
    ULONG i;

    WnodeSize = sizeof(WNODE_HEADER) + GuidCount*sizeof(GUID);
    WnodeBuffer = WmipAlloc(WnodeSize);
    if (WnodeBuffer != NULL)
    {
        Wnode = (PWNODE_HEADER)WnodeBuffer;
        WmipBuildRegistrationNotification(Wnode,
                                          WnodeSize,
                                          NotificationType,
                                          GuidCount);

        WnodeGuidPtr = (LPGUID)(WnodeBuffer + sizeof(WNODE_HEADER));
        for (i = 0; i < GuidCount; i++)
        {

            *WnodeGuidPtr++ =  *GuidList[i].Guid;
        }

        WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);

        memcpy(&Wnode->Guid,
               &GUID_REGISTRATION_CHANGE_NOTIFICATION, sizeof(GUID));
        Wnode->Flags &= ~WNODE_FLAG_INTERNAL;
        WmipEventNotification(Wnode, TRUE, Wnode->BufferSize);

        WmipFree(WnodeBuffer);
    }

}


PBINSTANCESET WmipFindISInDSByGuid(
    PBDATASOURCE DataSource,
    LPGUID Guid
    )
/*++

Routine Description:

    This routine will find the InstanceSet in the passed DataSource for the
    guid passed.

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    Guid has the Guid for the InstanceSet to find

Return Value:

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    InstanceSetList = DataSource->ISHead.Flink;
    while (InstanceSetList != &DataSource->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        DSISList);

        if ((InstanceSet->GuidEntry != NULL) &&
             (IsEqualGUID(Guid, &InstanceSet->GuidEntry->Guid)))
        {
            WmipReferenceIS(InstanceSet);
            return(InstanceSet);
        }

        InstanceSetList = InstanceSetList->Flink;
    }
    return(NULL);
}

ULONG WmipUpdateAddGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will add a new guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    RegistrationInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    ULONG Status;

    //
    // Allocate an instance set for this new set of instances
    InstanceSet = WmipAllocInstanceSet();
    if (InstanceSet == NULL)
    {
        WmipDebugPrint(("WMI: WmipUpdateAddGuid: WmipAllocInstanceSet failed\n"));
        return(0);
    }

    //
    // We will allocate a proper guid entry for the instance set when
    // the data source gets linked into the main data source list so
    // we stash a pointer to the guid away now.
    InstanceSet->GuidEntry = (PBGUIDENTRY)Guid;

    //
    // Minimally initialize the InstanceSet and add it to the DataSource's
    // list of InstanceSets. We do this first so that if there is any
    // failure below and the DataSource can'e be fully registered the
    // instance set and guid entry will be free when the DataSource is
    // freed.
    InstanceSet->DataSource = DataSource;
    InstanceSet->Flags |= IS_NEWLY_REGISTERED;

    InsertHeadList(&DataSource->ISHead, &InstanceSet->DSISList);

    Status = WmipBuildInstanceSet(RegGuid,
                                  RegistrationInfo,
                                  InstanceSet,
                                  DataSource->RegistryPath);

    if (Status != ERROR_SUCCESS)
    {
        WmipUnreferenceIS(InstanceSet);
        return(0);
    }

    Status = WmipLinkDataSourceToList(DataSource,
                                          FALSE);

    *AddModInstanceSet = InstanceSet;

    return( (Status == ERROR_SUCCESS) ? 1 : 0);
}

BOOLEAN WmipUpdateRemoveGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will remove the guid for the data source and send notification

    This routine assumes that the SM critical section is held before it is
    called.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

Return Value:

    TRUE if guid was removed else FALSE

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    BOOLEAN SendNotification;

    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        WmipUnreferenceIS(InstanceSet);
        *AddModInstanceSet = InstanceSet;
        SendNotification = TRUE;
    } else {
#if DBG
        TCHAR s[256];
        WmipDebugPrint(("WMI: UpdateRemoveGuid %ws not registered by %ws\n",
                        GuidToString(s, Guid), DataSource->RegistryPath));
#endif
        SendNotification = FALSE;
    }
    return(SendNotification);
}


BOOLEAN WmipIsEqualInstanceSets(
    PBINSTANCESET InstanceSet1,
    PBINSTANCESET InstanceSet2
    )
{
    ULONG i;
    ULONG Flags1, Flags2;

    Flags1 = InstanceSet1->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    Flags2 = InstanceSet2->Flags & ~(IS_ENABLE_EVENT | IS_ENABLE_COLLECTION);
    if (Flags1 == Flags2)
    {
        if (InstanceSet1->Flags & IS_INSTANCE_BASENAME)
        {
            if ((InstanceSet1->Count == InstanceSet2->Count) &&
                (wcscmp(InstanceSet1->IsBaseName->BaseName,
                        InstanceSet1->IsBaseName->BaseName) == 0))
            {
                return(TRUE);
            }
        } else if (InstanceSet1->Flags & IS_INSTANCE_BASENAME) {
            if (InstanceSet1->Count == InstanceSet2->Count)
            {
                for (i = 0; i < InstanceSet1->Count; i++)
                {
                    if (wcscmp(InstanceSet1->IsStaticNames->StaticNamePtr[i],
                               InstanceSet2->IsStaticNames->StaticNamePtr[i]) != 0)
                     {
                        return(FALSE);
                    }
                }
                return(TRUE);
            }
        } else {
            return(TRUE);
        }
    }

    return(FALSE);

}

ULONG WmipUpdateModifyGuid(
    PBDATASOURCE DataSource,
    PWMIREGGUID RegGuid,
    PWMIREGINFO RegistrationInfo,
    PBINSTANCESET *AddModInstanceSet
    )
/*++

Routine Description:

    This routine will modify an existing guid for the data source and
    send notification

    This routine assumes that the SM critical section is held before it is
    called.


    BUGBUG: If a guid was opened when it was registered as cheap, but closed
        when the guid was registered expensive a disable collection will
            NOT be sent. Conversely if a guid was opened when it was
        registered as expensive and is closed when registed as cheap a
            disable collection may be sent.

Arguments:

    DataSource is the data source from which the guid is to be removed

    RegGuid has the Guid update data structure

    RegistrationInfo points at the beginning of the registration update info

Return Value:

    1 if guid was added or 2 if guid was modified else 0

--*/
{
    PBINSTANCESET InstanceSet;
    LPGUID Guid = &RegGuid->Guid;
    ULONG SendNotification;
    PBINSTANCESET InstanceSetNew;
    PVOID ToFree;

    InstanceSet = WmipFindISInDSByGuid(DataSource,
                                       Guid);
    if (InstanceSet != NULL)
    {
        //
        // See if anything has changed with the instance names and if not
        // then don't bother to recreate the instance set

        InstanceSetNew = WmipAllocInstanceSet();
        if (InstanceSetNew == NULL)
        {
            WmipDebugPrint(("WMI: UpdateModifyGuid Not enough memory to alloc InstanceSet\n"));
            WmipUnreferenceIS(InstanceSet);
            return(0);
        }

        WmipBuildInstanceSet(RegGuid,
                             RegistrationInfo,
                             InstanceSetNew,
                             DataSource->RegistryPath);
        if (! WmipIsEqualInstanceSets(InstanceSet,
                                      InstanceSetNew))
        {
            ToFree = NULL;
            if (InstanceSet->IsBaseName != NULL) {
                ToFree = (PVOID)InstanceSet->IsBaseName;
            }

            RemoveEntryList(&InstanceSet->GuidISList);
            WmipBuildInstanceSet(RegGuid,
                             RegistrationInfo,
                             InstanceSet,
                             DataSource->RegistryPath);
            InsertHeadList(&InstanceSet->GuidEntry->ISHead,
                           &InstanceSet->GuidISList);

            WmipFree(ToFree);

            *AddModInstanceSet = InstanceSet;
            SendNotification = 2;
        } else {
            //
            // The InstanceSets are identical so just delete the new one
            SendNotification = 0;
        }
        WmipUnreferenceIS(InstanceSetNew);

        WmipUnreferenceIS(InstanceSet);
    } else {
        //
        // Guid not already registered so try to add it
        SendNotification = WmipUpdateAddGuid(DataSource,
                          RegGuid,
                          RegistrationInfo,
                          AddModInstanceSet);
    }
    return(SendNotification);
}

void WmipCachePtrs(
    LPGUID Ptr1,
    PBINSTANCESET Ptr2,
    ULONG *PtrCount,
    ULONG *PtrMax,
    PTRCACHE **PtrArray
    )
{
    PTRCACHE *NewPtrArray;
    PTRCACHE *OldPtrArray;
    PTRCACHE *ActualPtrArray;

    if (*PtrCount == *PtrMax)
    {
        NewPtrArray = WmipAlloc((*PtrMax + PTRCACHEGROWSIZE) * sizeof(PTRCACHE));
        if (NewPtrArray != NULL)
        {
            OldPtrArray = *PtrArray;
            memcpy(NewPtrArray, OldPtrArray, *PtrMax * sizeof(PTRCACHE));
            *PtrMax += PTRCACHEGROWSIZE;
            if (*PtrArray != NULL)
            {
                WmipFree(PtrArray);
            }
            *PtrArray = NewPtrArray;
        } else {
            WmipDebugPrint(("WMI: Couldn't alloc memory for pointer cache\n"));
            return;
        }
    }
    ActualPtrArray = *PtrArray;
    ActualPtrArray[*PtrCount].Guid = Ptr1;
    ActualPtrArray[*PtrCount].InstanceSet = Ptr2;
    (*PtrCount)++;
}

void WmipUpdateDataSource(
    ULONG_PTR ProviderId,
    PWMIREGINFOW RegistrationInfo,
    ULONG RetSize
    )
/*++

Routine Description:

    This routine will update a data source with changes to already registered
    guids.

Arguments:

    ProviderId is the provider id of the DataSource whose guids are being
        updated.

    RegistrationInfo has the registration update information

    RetSize has the size of the registration information returned from
        kernel mode.

Return Value:


--*/
{
    PBDATASOURCE DataSource;
    PBYTE RegInfo;
    ULONG RetSizeLeft;
    ULONG i;
    PWMIREGGUID RegGuid;
    ULONG NextWmiRegInfo;
    PTRCACHE *RemovedGuids;
    PTRCACHE *AddedGuids;
    PTRCACHE *ModifiedGuids;
    ULONG RemovedGuidCount;
    ULONG AddedGuidCount;
    ULONG ModifiedGuidCount;
    ULONG RemovedGuidMax;
    ULONG AddedGuidMax;
    ULONG ModifiedGuidMax;
    PBINSTANCESET InstanceSet;
    ULONG Action;

    DataSource = WmipFindDSByProviderId(ProviderId);
    if (DataSource == NULL)
    {
        WmipDebugPrint(("WMI: ProviderId %x requested update but is not registered\n",
                       ProviderId));
        return;
    }

    if ((RetSize < FIELD_OFFSET(WMIREGINFOW, WmiRegGuid)) ||
        (RetSize < (FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                    RegistrationInfo->GuidCount * sizeof(WMIREGGUIDW))))
    {
       WmipDebugPrint(("WMI: REGINFO Update block for %ws (%x) is too small\n",
                        DataSource->RegistryPath, ProviderId));
       WmipUnreferenceDS(DataSource);
       return;
    }

    AddedGuidCount = 0;
    ModifiedGuidCount = 0;
    RemovedGuidCount = 0;
    AddedGuidMax = 0;
    ModifiedGuidMax = 0;
    RemovedGuidMax = 0;
    ModifiedGuids = NULL;
    AddedGuids = NULL;
    RemovedGuids = NULL;

    NextWmiRegInfo = 0;
    RetSizeLeft = RetSize;
    WmipEnterSMCritSection();
    do
    {
        RegInfo = (PBYTE)RegistrationInfo;
        if ((RegistrationInfo->NextWmiRegInfo > RetSizeLeft) ||
            (RegistrationInfo->BufferSize > RetSizeLeft) ||
            (RetSize < (FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                    RegistrationInfo->GuidCount * sizeof(WMIREGGUIDW))))
        {
            WmipDebugPrint(("WMI: REGINFO update block for %ws (%x) has wrong size\n",
                               DataSource->RegistryPath, ProviderId));
            break;
        }

        for (i = 0; i < RegistrationInfo->GuidCount; i++)
        {
            RegGuid = &RegistrationInfo->WmiRegGuid[i];
            if (RegGuid->Flags & WMIREG_FLAG_REMOVE_GUID)
            {
                if (WmipUpdateRemoveGuid(DataSource,
                                         RegGuid,
                                         &InstanceSet))
                {
                    WmipCachePtrs(&RegGuid->Guid,
                             InstanceSet,
                             &RemovedGuidCount,
                             &RemovedGuidMax,
                             &RemovedGuids);
                }
            } else  {
                Action = WmipUpdateModifyGuid(DataSource,
                                       RegGuid,
                                       RegistrationInfo,
                                       &InstanceSet);
                if (Action == 1)
                {
                    WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &AddedGuidCount,
                                 &AddedGuidMax,
                                 &AddedGuids);

                } else if (Action == 2) {
                    WmipCachePtrs(&RegGuid->Guid,
                                 InstanceSet,
                                 &ModifiedGuidCount,
                                 &ModifiedGuidMax,
                                 &ModifiedGuids);
                }
            }
        }

        NextWmiRegInfo = RegistrationInfo->NextWmiRegInfo;
        RegistrationInfo = (PWMIREGINFOW)(RegInfo + NextWmiRegInfo);
    } while (NextWmiRegInfo != 0);

    WmipLeaveSMCritSection();

    WmipUnreferenceDS(DataSource);

    if (RemovedGuidCount > 0)
    {
        for (i = 0; i < RemovedGuidCount; i++)
        {
            if (IsEqualGUID(RemovedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(RemovedGuids[i].InstanceSet,
                                     &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION);
            }
                
            InstanceSet = RemovedGuids[i].InstanceSet;

            WmipDisableCollectionForRemovedGuid(RemovedGuids[i].Guid,
                                                InstanceSet);

            WmipEnterSMCritSection();
            //
            // If IS is on the GE list then remove it
            if (InstanceSet->GuidISList.Flink != NULL)
            {
                RemoveEntryList(&InstanceSet->GuidISList);
                InstanceSet->GuidEntry->ISCount--;
            }

            if (! (InstanceSet->Flags & IS_NEWLY_REGISTERED))
            {
                WmipUnreferenceGE(InstanceSet->GuidEntry);
            }

            InstanceSet->GuidEntry = NULL;

            //
            // Remove IS from the DS List
            RemoveEntryList(&InstanceSet->DSISList);
            WmipUnreferenceIS(InstanceSet);
            WmipLeaveSMCritSection();
        }

        WmipSendGuidUpdateNotifications(RegistrationDelete,
                                    RemovedGuidCount,
                                    RemovedGuids);
        WmipFree(RemovedGuids);
    }

    if (ModifiedGuidCount > 0)
    {
        for (i = 0; i < ModifiedGuidCount; i++)
        {
            if (IsEqualGUID(ModifiedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(ModifiedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
        }
        
        WmipSendGuidUpdateNotifications(RegistrationUpdate,
                                    ModifiedGuidCount,
                                    ModifiedGuids);
        WmipFree(ModifiedGuids);
    }

    if (AddedGuidCount > 0)
    {
        for (i = 0; i < AddedGuidCount; i++)
        {
            if (IsEqualGUID(AddedGuids[i].Guid,
                            &WmipBinaryMofGuid))
            {
                WmipGenerateBinaryMofNotification(AddedGuids[i].InstanceSet,
                                      &GUID_MOF_RESOURCE_ADDED_NOTIFICATION);
            }
                
            WmipEnableCollectionForNewGuid(AddedGuids[i].Guid,
                                           AddedGuids[i].InstanceSet);
        }
        WmipSendGuidUpdateNotifications(RegistrationAdd,
                                    AddedGuidCount,
                                    AddedGuids);
        WmipFree(AddedGuids);
    }

}

BOOLEAN
WmipIsControlGuid(
    PBGUIDENTRY GuidEntry
    )
/*++

Routine Description:
    This routine determines whether a GUID is registered as a Traceable
    Guid and a Trace Control Guid. If any one of the instancesets for
    this Guid has the trace flag, then it is traceable Guid.

Arguments:
    GuidEntry  Pointer to the Guid Entry structure.

Return Value:


--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;

    if (GuidEntry != NULL)
    {
        WmipEnterSMCritSection();
        InstanceSetList = GuidEntry->ISHead.Flink;
        while (InstanceSetList != &GuidEntry->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            if ( (InstanceSet->Flags & IS_TRACED) &&
                 (InstanceSet->Flags & IS_CONTROL_GUID) )
            {
                WmipLeaveSMCritSection();
                return (TRUE);
            }
            InstanceSetList = InstanceSetList->Flink;
        }
        WmipLeaveSMCritSection();
    }
    return (FALSE);
}

VOID
WmipSaveTraceGuidMap(
    LPGUID          Guid,
    PBINSTANCESET   ControlInstanceSet
    )
/*++

Routine Description:
    This routine is called for an TRACE CONTROL GUID that's being Unregistered.
    If a logger session is on, then we save the GuidMap information
    so that at the end of logger stop, we can dump it to the
    logfile at the end.


Arguments:
    Guid                    Guid that's getting unregistered.
    ControlInstanceSet      InstanceSet that's going away.

Return Value:


--*/
{
    PNOTIFICATIONENTRY NotificationEntry;
    NotificationEntry = WmipFindNEByGuid(Guid, FALSE);

    if (NotificationEntry != NULL)
    {
        PBDATASOURCE  DataSource;
        PLIST_ENTRY   InstanceSetList;
        PBINSTANCESET InstanceSet;
        PGUIDMAPENTRY GuidMap;
        ULONGLONG     SystemTime;

        GetSystemTimeAsFileTime((struct _FILETIME *)&SystemTime);

        WmipEnterSMCritSection();
        DataSource = ControlInstanceSet->DataSource;

        //
        // From the DataSource of this Trace Control Instance, get
        // all the Trace Guids that's a part of this DataSource.
        //

        InstanceSetList = DataSource->ISHead.Flink;
        while (InstanceSetList != &DataSource->ISHead)
        {
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            DSISList);
            if (InstanceSet->Flags & IS_TRACED)
            {
               GuidMap = (PGUIDMAPENTRY) WmipAlloc(sizeof(GUIDMAPENTRY));
               if (GuidMap != NULL)
               {
                   GuidMap->GuidMap.Guid = (InstanceSet->GuidEntry->Guid);
                   GuidMap->GuidMap.GuidMapHandle = (ULONG_PTR)InstanceSet;
                   GuidMap->LoggerContext = NotificationEntry->LoggerContext;
                   GuidMap->GuidMap.SystemTime = SystemTime;
                   InsertTailList(GMHeadPtr, &GuidMap->Entry);
               }

            }
            InstanceSetList = InstanceSetList->Flink;
        }

        WmipLeaveSMCritSection();

        WmipUnreferenceNE(NotificationEntry);
    }
}

#if DBG
PTCHAR GuidToString(
    PTCHAR s,
    LPGUID piid
    )
{
    wsprintf(s, TEXT("%x-%x-%x-%x%x%x%x%x%x%x%x"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}
#endif

ULONG WmipRegisterInternalDataSource(
    void
    )
/*++

Routine Description:

    This routine will update the WMI internal data source by discovering all
    of the data sources that registered a guid using the PDO.

Arguments:


Return Value:


--*/
{
    ULONG Status;
    ULONG_PTR ProviderId;
    UCHAR RegInfoBuffer[sizeof(WMIREGINFOW) + 2 * sizeof(WMIREGGUIDW)];
    PWMIREGINFOW RegInfo = (PWMIREGINFOW)RegInfoBuffer;
    GUID InstanceInfoGuid = INSTANCE_INFO_GUID;
    GUID EnumerateGuidsGuid = ENUMERATE_GUIDS_GUID;
    
    memset(RegInfo, 0, sizeof(RegInfoBuffer));    
    RegInfo->BufferSize = sizeof(RegInfoBuffer);
    RegInfo->GuidCount = 2;
    RegInfo->WmiRegGuid[0].Guid = InstanceInfoGuid;
    RegInfo->WmiRegGuid[1].Guid = EnumerateGuidsGuid;
    ProviderId = INTERNAL_PROVIDER_ID;
    Status = WmipAddDataSource(NULL,
                               0,
                               0,
                               NULL,
                               RegInfo,
                               RegInfo->BufferSize,
                               &ProviderId,
                               FALSE);

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\cimmap\sample.h ===
//***************************************************************************
//
//  sample.h
//
//  Module: WINMGMT class provider sample code
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 2000 Microsoft Corporation
//
//***************************************************************************

#ifndef _sample_H_
#define _sample_H_


typedef LPVOID * PPVOID;


// Provider interfaces are provided by objects of this class
 
class CClassPro : public IWbemServices, public IWbemProviderInit
{

    private:
        
        HRESULT LookupWdmClass(    IWbemContext *pCtx,
                                   const BSTR CimClassName,
                                   CWdmClass **WdmClassPtr
                                  );

        CWdmClass *FindExistingWdmClass(
                                                    PWCHAR CimClassName
                                               );

        
        
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pCimServices;
        
     public:
        CClassPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
        ~CClassPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        SCODE GetByPath(IWbemContext  *pCtx, BSTR Path, IWbemClassObject FAR* FAR* pObj);

        //IWbemServices  

          HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED; };

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

};

typedef CClassPro *PCClassPro;

// This class is the class factory for CClassPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;

// These variables keep track of when the module can be unloaded

extern LONG       g_cObj;
extern LONG       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\chunk.c ===
/*++                 

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    chunk.c

Abstract:
    
    This routine will manage allocations of chunks of structures

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include <stdio.h>

#define WmipEnterCriticalSection() WmipEnterSMCritSection()
#define WmipLeaveCriticalSection() WmipLeaveSMCritSection()

//
// include implementation of chunk managment code
#include "chunkimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\sources.inc ===
!IF 0

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=wmi
MINORCOMP=wmicore

TARGETNAME=wmicore
TARGETTYPE=DYNLINK

DLLDEF=$(O)\wmicore.def
DLLENTRY=WmiCoreInitialize

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\rpcrt4.lib \
            $(SDK_LIB_PATH)\ntdll.lib

INCLUDES= $(INCLUDES);            \
          ..;                     \
          ..\..\inc;              \
          ..\..\..\..\inc;        \
          $(BASE_INC_PATH);       \
          $(PROJECT_ROOT)\published\wmi\inc;

C_DEFINES= $(C_DEFINES) -D__MIDL_USER_DEFINED

SOURCES_LIST= \
        ..\wmicore.rc \
	..\main.c \
	..\datastr.c \
	..\validate.c \
	..\alloc.c \
	..\wbem.c  \
	..\krnlmode.c \
	..\wmicore_server.c \
	..\wmidp_client.c \
	..\server.c \
	..\chunk.c

UMTYPE=windows

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\sharemem.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    sharemem.c

Abstract:
    
    WMI interface to shared memory data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

#ifdef WMI_USER_MODE

DWORD WmipEstablishSharedMemory(
    PBDATASOURCE DataSource,
    LPCTSTR SectionName,
    ULONG SectionSize
    )
/*++

Routine Description:

    This routine establishes a linkage to a shared memory data provider

Arguments:

    DataSource is the data source entry for the data provider
    SectionName is the name of the shared memory section
    SectionSize is the size of the shared memory section

Return Value:

    ERROR_SUCCESS or an error code

--*/        
{
    ULONG Status;
    
    // TODO: Validate Shared Memory Section
    DataSource->SectionName = WmipAlloc((_tcslen(SectionName) + 1) * sizeof(TCHAR));
    if (DataSource->SectionName != NULL)
    {
        _tcscpy(DataSource->SectionName, SectionName);
        DataSource->SectionSize = SectionSize;
        Status = ERROR_SUCCESS;
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return(Status);
}
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\krnlmode.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    krnlmode.c

Abstract:

    WMI interface to Kernel mode data providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

extern HANDLE WmipKMHandle;

PTCHAR WmipRegistryToImagePath(
    PTCHAR ImagePath,
    PTCHAR RegistryPath,
    UINT_PTR ProviderId
    )
/*++

Routine Description:

    This routine will determine the location of the device driver's image file
    from its registry path

Arguments:

    RegistryPath is a pointer to the driver's registry path

    ImagePath is buffer of length MAX_PATH and returns the image path

Return Value:

    pointer to Image path of driver or NULL if image path is unavailable

--*/
{
#define SystemRoot TEXT("\\SystemRoot\\")
#ifdef MEMPHIS
#define SystemRootDirectory TEXT("%WinDir%\\")
#else
#define SystemRootDirectory TEXT("%SystemRoot%\\")
#endif
#define SystemRootCharSize (( sizeof(SystemRoot) / sizeof(WCHAR) ) - 1)

#define DriversDirectory TEXT("\\System32\\Drivers\\")
#define NdisDriversDirectory TEXT("\\System\\")

#define QuestionPrefix TEXT("\\??\\")
#define QuestionPrefixSize (( sizeof(QuestionPrefix) / sizeof(WCHAR) ) - 1)

#define RegistryPrefix TEXT("\\Registry")
    HKEY RegKey;
    PTCHAR ImagePathPtr = NULL;
    ULONG ValueType;
    ULONG Size;
    TCHAR Buffer[MAX_PATH];
    TCHAR Buffer2[MAX_PATH];
    TCHAR FullRegistryPath[MAX_PATH];
    PTCHAR DriverName;
    ULONG Len;
    BOOLEAN DefaultImageName;
    PTCHAR DriversDirectoryPath;

    // CONSIDER: Do some grovelling around directories in case we don't find
    // the image.

#ifdef MEMPHIS
    //
    // On memphis the registry path could point to two places
    //     \Registry\Machine\System\CurrentControlSet\Services\Driver (Legacy)
    //     System\CurrentControlSet\Services\Class\USB\0001


    if (_tcsnicmp(RegistryPath, RegistryPrefix, sizeof(RegistryPrefix)-1) != 0)
    {
        //
          // This is a non legacy type registry path.
        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                       RegistryPath,
                       &RegKey) == ERROR_SUCCESS)
        {
            DriverName = Buffer2;
            Size = MAX_PATH * sizeof(WCHAR);

            if (RegQueryValueEx(RegKey,
                                TEXT("NTMPDriver"),
                                NULL,
                                &ValueType,
                                DriverName,
                                &Size) == ERROR_SUCCESS)
            {
                DriversDirectoryPath = DriversDirectory;
            } else if (RegQueryValueEx(RegKey,
                                TEXT("DeviceVxDs"),
                                NULL,
                                &ValueType,
                                DriverName,
                                &Size) == ERROR_SUCCESS)
            {
                DriversDirectoryPath = NdisDriversDirectory;
            } else {
                DriversDirectoryPath = NULL;
            }

            if ((DriversDirectoryPath != NULL) && (ValueType == REG_SZ))
            {
                Size = GetWindowsDirectory(Buffer, MAX_PATH);
                if ((Size != 0) &&
                    (Size <= (MAX_PATH - _tcslen(DriverName) - sizeof(DriversDirectory) - 1)))
                {
                    if (Buffer[Size-1] == TEXT('\\'))
                    {
                        Buffer[Size-1] = 0;
                    }
                    _tcscpy(ImagePath, Buffer);
                    _tcscat(ImagePath, DriversDirectoryPath);
                    _tcscat(ImagePath, DriverName);
                    ImagePathPtr = ImagePath;
                    RegCloseKey(RegKey);
                    return(ImagePathPtr);
                }
            }
            RegCloseKey(RegKey);
        }
    }
#endif

    //
    // Get the driver file name or the MOF image path from the KM
    // registry path. Here are the rules:
    //
    // 1. First check the MofImagePath value in the registry in case the
    //    mof resource is in a different file from the driver.
    // 2. Next check the ImagePath value since the mof resource is assumed
    //    to be part of the driver image.
    // 3. If no MofImagePath or ImagePath values then assume the mof resource
    //    is in the driver file and compose the driver file name as
    //    %SystemRoot%\System32\driver.sys.
    // 4. If MofImagePath or ImagePath was specified then
    //    - Check first char for % or second character for :, or prefix
    //      of \??\ and if so use ExpandEnvironmentStrings
    //    - Check first part of path for \SystemRoot\, if so rebuild string
    //      as %SystemRoot%\ and use ExpandEnvironementStrings
    //    - Assume format D below and prepend %SystemRoot%\ and use
    //      ExpandEnvironmentStrings

    // If MofImagePath or ImagePath value is present and it is a REG_EXPAND_SZ
    // then it is used to locate the file that holds the mof resource. It
    // can be in one of the following formats:
    //    Format A - %SystemRoot%\System32\Foo.Dll
    //    Format B -C:\WINNT\SYSTEM32\Drivers\Foo.SYS
    //    Format C - \SystemRoot\System32\Drivers\Foo.SYS
    //    Format D - System32\Drivers\Foo.Sys
    //    Format E - \??\c:\foo.sys


    Len = _tcslen(RegistryPath);

    if (Len > 0)
    {
        DriverName = RegistryPath + Len;
        while ((*(--DriverName) != '\\') && (--Len > 0)) ;
    }

    if (Len == 0)
    {
        WmipReportEventLog(EVENT_WMI_INVALID_REGPATH,
                           EVENTLOG_WARNING_TYPE,
                             0,
                           sizeof(UINT_PTR),
                           &ProviderId,
                           1,
                           RegistryPath);
        WmipDebugPrint(("WMI: Badly formed registry path %ws\n", RegistryPath));
        return(NULL);
    }

    DriverName++;

    _tcscpy(FullRegistryPath, TEXT("System\\CurrentControlSet\\Services\\"));
    _tcscat(FullRegistryPath, DriverName);
    DefaultImageName = TRUE;
    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                              FullRegistryPath,
                             &RegKey) == ERROR_SUCCESS)
    {
        Size = MAX_PATH * sizeof(WCHAR);
        if (RegQueryValueEx(RegKey,
                            TEXT("MofImagePath"),
                            NULL,
                            &ValueType,
                            (PBYTE)ImagePath,
                            &Size) == ERROR_SUCCESS)
        {
              DefaultImageName = FALSE;
        } else {
            Size = MAX_PATH * sizeof(WCHAR);
            if (RegQueryValueEx(RegKey,
                                TEXT("ImagePath"),
                                NULL,
                                &ValueType,
                                (PBYTE)ImagePath,
                                &Size) == ERROR_SUCCESS)
            {
                DefaultImageName = FALSE;
            }
        }
        RegCloseKey(RegKey);
    }

    if ((DefaultImageName) ||
        ((ValueType != REG_EXPAND_SZ) && (ValueType != REG_SZ)) ||
        (Size < (2 * sizeof(WCHAR))))
    {
        //
        // No special ImagePath or MofImagePath so assume image file is
        // %SystemRoot%\System32\Drivers\Driver.Sys
#ifdef MEMPHIS
        _tcscpy(Buffer, TEXT("%WinDir%\\System32\\Drivers\\"));
#else
        _tcscpy(Buffer, TEXT("%SystemRoot%\\System32\\Drivers\\"));
#endif
        _tcscat(Buffer, DriverName);
        _tcscat(Buffer, TEXT(".SYS"));
    } else {
        if (_tcsnicmp(ImagePath,
                      SystemRoot,
                      SystemRootCharSize) == 0)
        {
            //
            // Looks like format C
            _tcscpy(Buffer, SystemRootDirectory);
            _tcscat(Buffer, &ImagePath[SystemRootCharSize]);
        } else if ((*ImagePath == '%') ||
                   ( (Size > 3*sizeof(WCHAR)) && ImagePath[1] == TEXT(':')) )
        {
            //
            // Looks like format B or format A
            _tcscpy(Buffer, ImagePath);
        } else if (_tcsnicmp(ImagePath,
                             QuestionPrefix,
                             QuestionPrefixSize) == 0)
        {
            //
            // Looks like format E
            _tcscpy(Buffer, ImagePath+QuestionPrefixSize);
        } else {
            //
            // Assume format D
            _tcscpy(Buffer, SystemRootDirectory);
            _tcscat(Buffer, ImagePath);
        }
    }

    Size = ExpandEnvironmentStrings(Buffer,
                                    ImagePath,
                                    MAX_PATH);

#ifdef MEMPHIS
    WmipDebugPrint(("WMI: %s has mof in %s\n",
                     DriverName, ImagePath));
#else
    WmipDebugPrint(("WMI: %ws has mof in %ws\n",
                     DriverName, ImagePath));
#endif

    return(ImagePath);
}

ULONG WmipGetKmRegInfo(
    HANDLE WmiKMHandle,
    PKMREGINFO KMRegInfo,
    BOOLEAN UpdateInfo,
    PBYTE *RegistrationInfo,
    ULONG RegInfoSize,
    ULONG *RetSize
    )
/*++

Routine Description:

    This routine calls into the wmi device to query for new or updated
    registration information.

Arguments:

    WmiKMHandle is the WMI kernel mode service device handle

    KMRegInfo is a pointer to the KM registration info

    UpdateInfo is TRUE if caller is looking for update information or
        FALSE if caller is looking for new registration information.

    *RegistrationInfo on entry has a buffer that can be filled with registration
        information. If this buffer is not large enough then a new buffer
        is allocated and is returned in *RegInfo

    RegInfoSize has the number of bytes available in *RegInfo on entry

    *RetSize returns with the number of bytes returned from the IOCTL

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    OVERLAPPED Overlapped;
    BOOL IoctlSuccess;
    PBYTE RegInfo = *RegistrationInfo;
    ULONG Status;
    ULONG RetryCount = 0;

    Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        Status = GetLastError();
        WmipDebugPrint(("WMI: Couldn't create event for RegInfo IOCTL %d\n",
                        Status));
        return(Status);
    }

    KMRegInfo->Flags = UpdateInfo ? REGENTRY_FLAG_UPDREGINFO :
                                    REGENTRY_FLAG_NEWREGINFO;
    do
    {
        IoctlSuccess = DeviceIoControl(WmiKMHandle,
                          IOCTL_WMI_GET_REGINFO,
                          KMRegInfo,
                          sizeof(KMREGINFO),
                          RegInfo,
                          RegInfoSize,
                          RetSize,
                          &Overlapped);
        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmiKMHandle,
                                               &Overlapped,
                                               RetSize,
                                               TRUE);
        }
        if (IoctlSuccess)
        {
            Status = ERROR_SUCCESS;
            if (*RetSize == sizeof(ULONG))
            {
                RegInfoSize = *((ULONG *)RegInfo);
                if (RegInfo != *RegistrationInfo)
                {
                    WmipFree(RegInfo);
                }

                RegInfo = WmipAlloc(RegInfoSize);
                if (RegInfo == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            Status = GetLastError();
        }
    } while (( (Status == ERROR_SUCCESS) &&
               (*RetSize == sizeof(ULONG)) &&
               (RetryCount++ < 4) ) ||
             (Status == ERROR_WMI_TRY_AGAIN));

    if ((Status == ERROR_SUCCESS) && (*RetSize == sizeof(ULONG)))
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }

    *RegistrationInfo = RegInfo;

    CloseHandle(Overlapped.hEvent);

    return(Status);
}

void WmipUpdateKm(
    HANDLE WmiKMHandle,
    PKMREGINFO KMRegInfo
    )
/*++

Routine Description:

    This routine will query the KM data provider for its registration info
    and then call to register it in the WMI data structures.

Arguments:

    WmiKMHandle is the WMI kernel mode service device handle

    KMRegInfo is a pointer to the KM registration info
Return Value:


--*/
{
    BYTE RegInfoBuffer[INITIALREGINFOSIZE];
    PBYTE RegInfo;
    PBYTE RegInfoBase;
    ULONG_PTR ProviderId;
    WCHAR *RegistryPathPtr;
    TCHAR *ImagePathPtr;
    WCHAR RegistryPath[MAX_PATH];
    TCHAR ImagePath[MAX_PATH];
    PWMIREGINFOW WmiRegInfo;
    ULONG RegistryPathSize;
    ULONG Status;
    ULONG RegistryPathOffset;
#ifdef MEMPHIS
    PCHAR RegistryPathAnsi;
#endif
    ULONG RetSizeLeft;
    ULONG RetSize;

    RegInfo = RegInfoBuffer;
    Status = WmipGetKmRegInfo(WmiKMHandle,
                              KMRegInfo,
                              TRUE,
                              &RegInfo,
                              INITIALREGINFOSIZE,
                              &RetSize);

    RegInfoBase = RegInfo;
    if (Status == ERROR_SUCCESS)
    {
        ProviderId = KMRegInfo->ProviderId;
        RetSizeLeft = RetSize;
        do
        {
            WmiRegInfo = (PWMIREGINFOW)RegInfo;
            if (WmiRegInfo->BufferSize > RetSizeLeft)
            {
                 //
                // If there not enough room left in the buffer for what the
                // driver says is there then reject the buffer
                WmipDebugPrint(("WMI: Invalid buffer size for registration info\n"));
                goto Cleanup;
            }

            WmipUpdateDataSource(ProviderId,
                                 WmiRegInfo,
                                 RetSizeLeft);

            if (WmiRegInfo->NextWmiRegInfo > RetSizeLeft)
            {
                WmipDebugPrint(("WMI: NextWmiRegInfo pointer is out of range\n"));
                goto Cleanup;
            }

            RegInfo += WmiRegInfo->NextWmiRegInfo;
            RetSizeLeft -= WmiRegInfo->NextWmiRegInfo;

        } while (WmiRegInfo->NextWmiRegInfo != 0);
    }

Cleanup:
    if ((RegInfoBase != NULL) && (RegInfoBase != RegInfoBuffer))
    {
        WmipFree(RegInfoBase);
    }
}

void WmipRegisterKm(
    HANDLE WmiKMHandle,
    PKMREGINFO KMRegInfo
    )
/*++

Routine Description:

    This routine will query the KM data provider for its registration info
    and then call to register it in the WMI data structures.

Arguments:

    WmiKMHandle is the WMI kernel mode service device handle

    KMRegInfo is a pointer to the KM registration info

Return Value:


--*/
{
    BYTE RegInfoBuffer[INITIALREGINFOSIZE];
    PBYTE RegInfo;
    PBYTE RegInfoBase;
    ULONG_PTR ProviderId;
    WCHAR *RegistryPathPtr;
    TCHAR *ImagePathPtr;
    WCHAR RegistryPath[MAX_PATH];
    TCHAR ImagePath[MAX_PATH];
    PWMIREGINFOW WmiRegInfo;
    ULONG RegistryPathSize;
    ULONG Status;
    ULONG RegistryPathOffset;
#ifdef MEMPHIS
    PCHAR RegistryPathAnsi;
#endif
    ULONG RetSizeLeft;
    ULONG RetSize;

    RegInfo = RegInfoBuffer;
    Status = WmipGetKmRegInfo(WmiKMHandle,
                              KMRegInfo,
                              FALSE,
                              &RegInfo,
                              INITIALREGINFOSIZE,
                              &RetSize);

    RegInfoBase = RegInfo;
    if (Status == ERROR_SUCCESS)
    {
        ProviderId = KMRegInfo->ProviderId;
        RetSizeLeft = RetSize;
        do
        {
            WmiRegInfo = (PWMIREGINFOW)RegInfo;
            if (WmiRegInfo->BufferSize > RetSizeLeft)
            {
                 //
                // If there not enough room left in the buffer for what the
                // driver says is there then reject the buffer
                WmipDebugPrint(("WMI: Invalid buffer size for registration info\n"));
                goto Cleanup;
            }

            ImagePathPtr = NULL;
            RegistryPathOffset = WmiRegInfo->RegistryPath;

            if (RegistryPathOffset > RetSize)
            {
                WmipDebugPrint(("WMI: Bogus KM RegInfo for %x\n",
                                 KMRegInfo->ProviderId));
                goto Cleanup;
            }

            if (RegistryPathOffset != 0)
            {
                RegistryPathPtr = (PWCHAR)OffsetToPtr(RegInfo, WmiRegInfo->RegistryPath);
                RegistryPathSize = *RegistryPathPtr;
                if (WmipValidateCountedString(RegistryPathPtr))
                {
                    if ((RegistryPathSize < sizeof(RegistryPath)) &&
                        (RegistryPathSize != 0))
                    {
                        RegistryPathSize /= sizeof(WCHAR);
                        wcsncpy(RegistryPath, RegistryPathPtr+1, RegistryPathSize);
                        RegistryPath[RegistryPathSize] = UNICODE_NULL;
#ifdef MEMPHIS
                        RegistryPathAnsi = NULL;
                        Status = UnicodeToAnsi(RegistryPath,
                                               &RegistryPathAnsi,
                                               NULL);
                        if (Status != ERROR_SUCCESS)
                        {
                            WmipDebugPrint(("WMI: Error converting Registrypath to ansi\n"));
                        }
                        ImagePathPtr = WmipRegistryToImagePath(
                                                        ImagePath,
                                                        RegistryPathAnsi,
                                                        ProviderId);
                        if (RegistryPathAnsi != NULL)
                        {
                            WmipFree(RegistryPathAnsi);
                        }
#else
                        ImagePathPtr = WmipRegistryToImagePath(
                                                        ImagePath,
                                                        RegistryPath,
                                                        ProviderId);
#endif
                    } else {
                        WmipReportEventLog(EVENT_WMI_INVALID_REGPATH,
                                           EVENTLOG_WARNING_TYPE,
                                            0,
                                           sizeof(UINT_PTR),
                                           &ProviderId,
                                           1,
                                           RegistryPathPtr);
                        WmipDebugPrint(("WMI: Specified registry path is empty or too long %x\n",
                                    RegistryPathPtr));
                    }
                }
            }

            WmipAddDataSource(NULL,
                              0,
                              0,
                              ImagePathPtr,
                              WmiRegInfo,
                              RetSizeLeft,
                              &ProviderId,
                  FALSE);

            if (WmiRegInfo->NextWmiRegInfo > RetSizeLeft)
            {
                WmipDebugPrint(("WMI: NextWmiRegInfo pointer is out of range\n"));
                goto Cleanup;
            }

            RegInfo += WmiRegInfo->NextWmiRegInfo;
            RetSizeLeft -= WmiRegInfo->NextWmiRegInfo;

        } while (WmiRegInfo->NextWmiRegInfo != 0);
    } else {
        // Put something in eventlog
    }

Cleanup:
    if ((RegInfoBase != NULL) && (RegInfoBase != RegInfoBuffer))
    {
        WmipFree(RegInfoBase);
    }
}


ULONG WmipInitializeKM(
    HANDLE *WmiKMHandle
    )
/*++

Routine Description:

    Initialize access to kernel mode. Open the service device and query for
    all registered KM drivers then query each driver for its registration
    info and then try to register each driver in the user mode cache.

Arguments:

    WmiKMHandle is the WMI kernel mode service device handle

    KMRegInfo is a pointer to the KM registration info

Return Value:


--*/
{
    ULONG i;
    ULONG Status;
    KMREGINFO KmRegInfoStatic[1];
    PKMREGINFO KmRegInfo = KmRegInfoStatic;
    ULONG KmRegInfoSize, KmRegInfoCount;
    BOOL IoctlSuccess;
    ULONG RetSize;
    OVERLAPPED Overlapped;

    //
    // Open up the WMI service device
    *WmiKMHandle = CreateFile(
                     WMIServiceDeviceName,
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                     NULL
                     );
    Status = GetLastError();

    Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        return(GetLastError());
    }

    KmRegInfoSize = sizeof(KmRegInfoStatic);
    if (*WmiKMHandle != (HANDLE)-1)
    {
        //
        // Loop querying the WMI device for registration info until we hit
        // upon the right number of KMREGINFO
        do
        {
            IoctlSuccess = DeviceIoControl(*WmiKMHandle,
                           IOCTL_WMI_GET_ALL_REGISTRANT,
                           NULL,
                           0,
                           KmRegInfo,
                           KmRegInfoSize,
                           &RetSize,
                           &Overlapped);
            if (GetLastError() == ERROR_IO_PENDING)
            {
                IoctlSuccess = GetOverlappedResult(*WmiKMHandle,
                                                   &Overlapped,
                                                   &RetSize,
                                                   TRUE);
            }

            //
            // If this succeeds, but only returns a ULONG then our buffer was
            // too small and the ULONG has the size that we need
            if (IoctlSuccess && (RetSize == sizeof(ULONG)))
            {
                KmRegInfoSize = *((ULONG *)KmRegInfo);
                if (KmRegInfo != KmRegInfoStatic)
                {
                    WmipFree(KmRegInfo);
                }
                KmRegInfo = WmipAlloc(KmRegInfoSize);
                if (KmRegInfo == NULL)
                {
                    WmipDebugPrint(("WMI: Couldn't alloc memory for KmRegInfo\n"));
                    CloseHandle(Overlapped.hEvent);
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }
            } else {
                break;
            }
        } while (TRUE);

        if (IoctlSuccess)
        {
            //
            // We have got the registration list, so process all of the
            // registered drivers
            KmRegInfoCount = RetSize / sizeof(KMREGINFO);

            for (i = 0; i < KmRegInfoCount; i++)
            {
                WmipAssert(KmRegInfo[i].ProviderId != 0);
                WmipRegisterKm(*WmiKMHandle, &KmRegInfo[i]);
            }

            Status = ERROR_SUCCESS;

        } else {
            Status = GetLastError();
            WmipDebugPrint(("WMI: IOCTL_WMI_GET_ALL_REGISTRANT failed %x\n", Status));
            CloseHandle(*WmiKMHandle);
            *WmiKMHandle = (HANDLE)-1;
        }

        if (KmRegInfo != KmRegInfoStatic)
        {
            WmipFree(KmRegInfo);
        }

    } else {
        WmipReportEventLog(EVENT_WMI_CANT_OPEN_DEVICE,
                           EVENTLOG_ERROR_TYPE,
                               0,
                           sizeof(ULONG),
                           &Status,
                           0);
        WmipDebugPrint(("WMI: open service device failed %x\n", Status));
    }

    CloseHandle(Overlapped.hEvent);

    return(Status);
}

void WmipKMNonEventNotification(
    HANDLE WmiKMHandle,
    PWNODE_HEADER Wnode
    )
{
    PKMREGINFO KMRegInfo;

    //
    // Is the buffer size correct ?
    //
    if (Wnode->BufferSize == INTERNALNOTIFICATIONSIZE)
    {
        //
        // Make sure that correct notification type bits are set and only
        // those bits are set
        //
        WmipAssert((Wnode->Version &
                            NOTIFICATIONSLOT_MASK_NOTIFICATIONTYPES) != 0);
        WmipAssert((Wnode->Version &
                            ~NOTIFICATIONSLOT_MASK_NOTIFICATIONTYPES) == 0)


        //
        // Registration notifications need to handled in a specific order.
        // RegistrationDelete is always handled first and any other are
        // ignored. If a device is unregistering we can ignore any updates.
        // A RegistrationAdd is handled before a RegistrationUpdate.
        //
        KMRegInfo = (PKMREGINFO)((PCHAR)Wnode + sizeof(WNODE_HEADER));
        if (Wnode->Version & RegistrationDelete)
        {
            WmipRemoveDataSource(KMRegInfo->ProviderId);
        } else {
            if (Wnode->Version & RegistrationAdd)
            {
                WmipRegisterKm(WmiKMHandle, KMRegInfo);
            }

            if (Wnode->Version & RegistrationUpdate)
            {
                WmipUpdateKm(WmiKMHandle, KMRegInfo);
            }
        }
    } else {
        WmipDebugPrint(("WMI: Invalid non event notification buffer %x\n",
                        Wnode));
    }
}

#ifndef MEMPHIS


ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    PVOID OutBuffer,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode service device.  Any retry errors returned by the WMI device are
    handled in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;

    WmipAssert(WmipKMHandle != NULL);

    Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    do
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              OutBuffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);

        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }

        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);

    CloseHandle(Overlapped.hEvent);
    return(Status);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\main.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:

    WMI core dll main file

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID
#include "wmiump.h"

#ifdef MEMPHIS
#include "dbt.h"
#endif

HANDLE WmipKMHandle;
HANDLE WmipTerminationEvent;

ULONG WmipNotificationIODelay = 500;

#ifndef MEMPHIS
HANDLE WmipEventLogHandle;
PVOID WmipProcessHeap;

HANDLE WmipQueueReadNotificationTimer;
HANDLE WmipAsyncRpcApcThread;
HANDLE WmipRestrictedToken;

typedef enum
{
    InitializationRunning = 0,
    InitialTimerWaiting,
    TimerRunning,
    IoControlWaiting,
    WorkItemWaiting,
    ReadCompleteRunning,
    SecondaryTimerWaiting,
    ServiceShutdownRunning,
    BufferAllocTimerWaiting,
    GetPersistentThread,
    GetPersistentThreadFailed,
    RequeueGetPersistentThread,
    GetRequeueGetPersistentThreadWait,
    RequeueInitialTimerWaiting,
    QueueGetPerisitentThread
} THREADPOOLSTATUS;

THREADPOOLSTATUS WmipThreadPoolStatus;

SERVICE_STATUS WmiServiceStatus;
SERVICE_STATUS_HANDLE WmiServiceStatusHandle;

PSVCS_GLOBAL_DATA WmipSvcsGlobalData;
HANDLE WmipGlobalSvcRefHandle;

ULONG WmipQueueReadNotification(
    PVOID Context,
    BOOLEAN Condition
    );
#endif

BOOLEAN WmipServiceShutdown;

ULONG WmipNotificationLoop(
    HANDLE WmiKMHandle,
    HANDLE TerminationHandle
    );

ULONG WmipCoreInitialize(
    HANDLE *WmiKMHandle
    );

void WmipCoreDeinitialize(
    HANDLE WmiKMHandle
    );

BOOLEAN
WmiCoreInitialize(
    IN PVOID DllBase,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.
    It's primary purpose is to provide early initialization which must
    be prior to Wx86ProcessInit.

Arguments:

    DllHandle -

    Reason  - attach\detach

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/
{
    if (Reason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(DllBase);
    }

    return(TRUE);
}

ULONG WmiInitializeService(
    void
)
/*++

Routine Description:

    This routine will do the work of initializing the WMI service

Arguments:

    Context

Return Value:

    Error status value
--*/
{
    ULONG Status;

    //
    // Reinitialize some of the global variables. We do this in case the
    // service was stopped and restarted, but the dll was not unloaded and
    // reloaded.
    DSHeadPtr = &DSHead;
    InitializeListHead(DSHeadPtr);
    InitializeListHead(&DSChunkInfo.ChunkHead);

    GEHeadPtr = &GEHead;
    InitializeListHead(GEHeadPtr);
    InitializeListHead(&GEChunkInfo.ChunkHead);

    DCHeadPtr = &DCHead;
    InitializeListHead(DCHeadPtr);
    InitializeListHead(&DCChunkInfo.ChunkHead);

    NEHeadPtr = &NEHead;
    InitializeListHead(NEHeadPtr);
    InitializeListHead(&NEChunkInfo.ChunkHead);

    MRHeadPtr = &MRHead;
    InitializeListHead(MRHeadPtr);
    InitializeListHead(&MRChunkInfo.ChunkHead);

    InitializeListHead(&ISChunkInfo.ChunkHead);

#ifdef WMI_USER_MODE
    MCHeadPtr = &MCHead;
    InitializeListHead(MCHeadPtr);
    InitializeListHead(&MCChunkInfo.ChunkHead);
#endif

#ifndef MEMPHIS
    GMHeadPtr = &GMHead;
    InitializeListHead(GMHeadPtr);
    Status = RtlInitializeCriticalSection(&SMCritSect);
    if (! NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }
#endif

    WmipServiceShutdown = FALSE;

    WmipTerminationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (WmipTerminationEvent == NULL)
    {
        return(GetLastError());
    }

#ifdef MEMPHIS
    SMMutex = CreateMutex(NULL, FALSE, NULL);
    if (SMMutex == NULL)
    {
        CloseHandle(WmipTerminationEvent);
        return(GetLastError());
    }
#else

    WmipEventLogHandle = RegisterEventSource(NULL,
                                             L"WMI");
    if (WmipEventLogHandle == NULL)
    {
        WmipDebugPrint(("WMI: Couldn't register event source %d\n",
                        GetLastError()));
        //
        // This is not serious enough for us to quit the service        
    }    

    WmipProcessHeap = RtlCreateHeap(HEAP_GROWABLE,
                                    NULL,
                                    DLLRESERVEDHEAPSIZE,
                                    DLLCOMMITHEAPSIZE,
                                    NULL,
                                    NULL);

    if (WmipProcessHeap == NULL)
    {
        WmipDebugPrint(("WMI: Cannot create core WmipProcessHeap\n"));
        RtlDeleteCriticalSection(&SMCritSect);
        CloseHandle(WmipTerminationEvent);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
#endif

    //
    // Initialize core internal components of the service
    Status = WmipCoreInitialize(&WmipKMHandle);
    if (Status != ERROR_SUCCESS)
    {
        CloseHandle(WmipTerminationEvent);
#ifdef MEMPHIS
        CloseHandle(SMMutex);
#else
        if (WmipEventLogHandle != NULL)
        {
            DeregisterEventSource(WmipEventLogHandle);
        }
        RtlDestroyHeap(WmipProcessHeap);
        RtlDeleteCriticalSection(&SMCritSect);
#endif
        return(Status);
    }

#ifdef MEMPHIS
    //
    // Establish the RPC server
    Status = WmipRpcServerInitialize();
    if (Status != ERROR_SUCCESS)
    {
        //
        // If we can't establish an RPC server then bail out, no point to run
        WmipCoreDeinitialize(WmipKMHandle);
        CloseHandle(WmipTerminationEvent);
        CloseHandle(SMMutex);
        return(Status);
    }
#endif

    return(Status);
}

void WmiDeinitializeService(
    void
)
/*++

Routine Description:

    This routine will do the work of deinitializing the WMI service

Arguments:

    Context

Return Value:

    Error status value
--*/
{
    WmipCoreDeinitialize(WmipKMHandle);

#ifdef MEMPHIS
    WmipRpcServerDeinitialize();
    CloseHandle(SMMutex);
#else
    if (WmipEventLogHandle != NULL)
    {
        DeregisterEventSource(WmipEventLogHandle);
        WmipEventLogHandle = NULL;
    }

    if (WmipProcessHeap != NULL)
    {
        RtlDestroyHeap(WmipProcessHeap);
        WmipProcessHeap = NULL;
    }

    RtlDeleteCriticalSection(&SMCritSect);
#endif

    CloseHandle(WmipTerminationEvent);
}


#ifdef MEMPHIS
void WmiTerminateService(
    void
    )
{
    SetEvent(WmipTerminationEvent);
}

ULONG WmiRunService(
    ULONG Context,
    HINSTANCE InstanceHandle
    )
/*++

Routine Description:

    This is the main entrypoint for the WMI service. It will initialize WMI
    start up the WMI rpc server and then enter the main loop getting and
    dispatching notifications. This is the memphis only version.

Arguments:

    Context

Return Value:

    Error status value
--*/
{
    ULONG Status;
    MSG Msg;

    if (WmipKMHandle == (PVOID)-1)
    {
        //
        // On memphis we could have the situation where the WMI kernel mode
        // device is not created when the WMI service starts up. WMI driver
        // is only loaded on memphis when a driver is loaded that needs its
        // services. So it is possible that the system will boot with the
        // WMI kernel mode code and then a user mode provider will startup
        // the service (wmiexe.exe), and the service will not be able to
        // open the WMI device. When a subsequent driver that pulls in WMI
        // loads we need to get a notification here so that we can open
        // the WMI device and proceed normally with WmipNotificationLoop.
        // Note that in memphis kernel mode dlls (like wmi.sys) will never
        // be unloaded even if all the drivers that need them are.

        // Our plan then is to create a hidden window and wait for
        // WM_DEVICECHANGE messages with wParam set to DBT_DEVICEARRIVAL.
        // When this message arrives it means that a new PnP device has been
        // added to the system. Since (on memphis) only PnP devices can use
        // WMI we can check again to see if the WMI device can be opened.
        // If it can then we fall out of the loop and call
        // WmipNotificationLoop.

        HWND WindowHandle;

        Status = WmipCreateDeviceNotificationWindow(InstanceHandle,
                                                    &WindowHandle);
        if (Status == ERROR_SUCCESS)
        {
            while (GetMessage(&Msg, NULL, 0, 0))
            {
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }

            WmipDestroyDeviceNotificationWindow(InstanceHandle,
                                                WindowHandle);

            Status = WmipNotificationLoop(WmipKMHandle, WmipTerminationEvent);
        } else {
            //
            // If we couldn't create the window then forget about KM stuff
            WaitForSingleObject(WmipTerminationEvent, INFINITE);
        }
    } else {
        Status = WmipNotificationLoop(WmipKMHandle, WmipTerminationEvent);
    }

    return(Status);
}
#endif


ULONG WmipCoreInitialize(
    HANDLE *WmiKMHandle
    )
/*++

Routine Description:

    Initialization for WMI core fucntionality

Arguments:


Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    ULONG Status;
    PBGUIDENTRY GuidEntry;

    //
    // Build a guid entry for registration change notifications
    GuidEntry = WmipAllocGuidEntry();
    if (GuidEntry == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memcpy(&GuidEntry->Guid, &RegChangeNotificationGuid, sizeof(GUID));
    GuidEntry->Flags = GE_FLAG_INTERNAL;

    InsertTailList(GEHeadPtr, &GuidEntry->MainGEList);


    Status = WmipReadBuiltinMof();
    if (Status != ERROR_SUCCESS)
    {
        WmipDebugPrint(("WMI: Error reading builtin mof %d\n", Status));
    }


    Status = WmipRegisterInternalDataSource();
    if (Status != ERROR_SUCCESS)
    {
        return(Status);
    }

    //
    // Get registration information for all kernel mode data
    // providers.
    Status = WmipInitializeKM(WmiKMHandle);
#ifdef MEMPHIS
    //
    // On memphis it is ok to be running without wmi kernel mode code loaded
    if (Status != ERROR_SUCCESS)
    {
        Status = ERROR_SUCCESS;
    }
#endif

    return(Status);
}

void WmipCoreDeinitialize(
    HANDLE WmiKMHandle
    )
/*++

Routine Description:

    Deinitialization for WMI core fucntionality

Arguments:


Return Value:

--*/
{
    if (WmiKMHandle != (HANDLE)-1)
    {
        CloseHandle(WmiKMHandle);
    }
}

#ifdef MEMPHIS
ULONG WmipNotificationLoop(
    HANDLE WmiKMHandle,
    HANDLE TerminationEvent
    )
/*++

Routine Description:

    This is the main wmi service loop that waits for events to occur in
    kernel mode and then dispatches them to the appropriate user mode
    event sinks.

Arguments:


Return Value:

    Never returns or an error code
--*/
{
    BYTE *NotificationBuffer;
    ULONG NotificationBufferSize = STARTNOTIFICATIONBUFFERSIZE;
    BYTE *NewNotificationBuffer;
    ULONG NewNotificationBufferSize;
    ULONG RetSize;
    PWNODE_HEADER Wnode;
    BOOL IoctlSuccess;
    OVERLAPPED Overlapped;
    HANDLE WaitObjects[2];
    ULONG Status;
    ULONG RetSizeLeft;
    ULONG Linkage;

    Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Overlapped.hEvent == NULL)
    {
        return(GetLastError());
    }

    WaitObjects[0] = TerminationEvent;
    WaitObjects[1] = Overlapped.hEvent;

    NotificationBuffer = WmipAlloc(NotificationBufferSize);
    if (NotificationBuffer == NULL)
    {
        return(ERROR_NO_SYSTEM_RESOURCES);
    }

    while (1)
    {
        DeviceIoControl(WmiKMHandle,
                            IOCTL_WMI_READ_NOTIFICATIONS,
                            NULL,
                            0,
                            NotificationBuffer,
                            NotificationBufferSize,
                            &RetSize,
                            &Overlapped);

        IoctlSuccess = GetOverlappedResult(WmiKMHandle,
                                               &Overlapped,
                                               &RetSize,
                                               TRUE);
        if (IoctlSuccess)
        {

            Wnode = (PWNODE_HEADER)NotificationBuffer;
            WmipDebugPrint(("WMI: Received Notification %x length 0x%x\n",
                            NotificationBuffer,
                            RetSize));
            if ((RetSize == sizeof(WNODE_TOO_SMALL)) &&
                (Wnode->Flags & WNODE_FLAG_TOO_SMALL))
            {
                //
                // Buffer is not large enough to return an event so
                // increase buffer size.
                NewNotificationBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
                NewNotificationBuffer = WmipAlloc(NewNotificationBufferSize);
                if (NewNotificationBuffer != NULL)
                {
                    NotificationBufferSize = NewNotificationBufferSize;
                    WmipFree(NotificationBuffer);
                    NotificationBuffer = NewNotificationBuffer;
                }
                continue;
            }

            //
            // We have one or more events to process
            RetSizeLeft = RetSize;
            do
            {
                if ((RetSizeLeft >= sizeof(WNODE_HEADER)) &&
                    (Wnode->BufferSize <= RetSizeLeft))
                {
                    Linkage = Wnode->Linkage;
                    Wnode->Linkage = 0;

                    if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                    {
                        WmipKMNonEventNotification(WmiKMHandle, Wnode);
                    } else {
                        WmipEventNotification(Wnode, TRUE, RetSize);
                    }

                    if (Linkage != 0)
                    {
                        if (Linkage < RetSizeLeft)
                        {
                            Wnode = (PWNODE_HEADER)((PUCHAR)Wnode + Linkage);
                            RetSizeLeft -= Linkage;
                        } else {
                            WmipDebugPrint(("WMI: Invalid Linkage field %x in a WNODE_EVENT_ITEM\n",
                                             Linkage));
                            Linkage = 0;
                        }
                    }
                } else {
                    WmipDebugPrint(("WMI: Received bad notification Wnode %x BufferSize %x RetSize %x RetSizeLeft %x\n",
                        Wnode,
                        Wnode->BufferSize, RetSize, RetSizeLeft));
                    Linkage = 0;
                }
            } while (Linkage != 0);

        } else {
            WmipDebugPrint(("WMI: IOCTL_WMI_READ_NOTIFICATIONS failed %x\n",
                             GetLastError()));
            Sleep(60 * 1000);
        }
    }
}

#else
PBYTE WmipNotificationBuffer;
ULONG WmipNotificationBufferSize = STARTNOTIFICATIONBUFFERSIZE;
OVERLAPPED WmipNotificationOverlapped;
HANDLE WmipNotificationWait;



ULONG WmipReadNotificationComplete(
    PVOID Context
    )
/*++

Routine Description:

    Win32 work item that is executed because the DeviceIoControl in
    WmipQueueReadNotification completed. This work item assumes that it has
    been queued for execution in a non IO thread.

Arguments:

    Context

    Condition

Return Value:

--*/
{
    ULONG RetSize;
    PWNODE_HEADER Wnode;
    BOOL IoctlSuccess;
    ULONG RetSizeLeft;
    ULONG Linkage;
    BOOLEAN MultiEvent;
    ULONG NotificationIODelay;

    WmipThreadPoolStatus = ReadCompleteRunning;
    if (WmipServiceShutdown)
    {
        //
        // If service is shutdown then just return
        WmipThreadPoolStatus = ServiceShutdownRunning;
        return(0);
    }

    //
    // The IOCTL from the WMI device completed so that
    // means we have a notification to handle. Get the result
    // of the IOCTL and process it
    IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                       &WmipNotificationOverlapped,
                                       &RetSize,
                                       TRUE);

    if (IoctlSuccess)
    {
        NotificationIODelay = WmipNotificationIODelay;
        Wnode = (PWNODE_HEADER)WmipNotificationBuffer;
        WmipDebugPrint(("WMI: Received Notification %x length 0x%x\n",
                            WmipNotificationBuffer,
                            RetSize));

        if ((RetSize == sizeof(WNODE_TOO_SMALL)) &&
            (Wnode->Flags & WNODE_FLAG_TOO_SMALL))
        {
            //
            // Buffer is not large enough to return an event so
            // note the new size and free the old notification buffer.
            // The WmipQueueReadNotification work item will reallocate
            // the buffer with the new size
            WmipNotificationBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            WmipFree(WmipNotificationBuffer);
            WmipNotificationBuffer = NULL;
            NotificationIODelay = 0;
        } else {
            //
            // We have one or more events to process
            RetSizeLeft = RetSize;
            MultiEvent = FALSE;
            do
            {
                if ((RetSizeLeft >= sizeof(WNODE_HEADER)) &&
                    (Wnode->BufferSize <= RetSizeLeft))
                {
                    Linkage = Wnode->Linkage;
                    MultiEvent |= (Linkage != 0);
                    Wnode->Linkage = 0;

                    if (Wnode->Flags & WNODE_FLAG_INTERNAL)
                    {
                        WmipKMNonEventNotification(WmipKMHandle, Wnode);
                    } else {
                        WmipEventNotification(Wnode,
                                              (BOOLEAN)( ! MultiEvent),
                                              RetSize);
                    }

                    if (Linkage != 0)
                    {
                        if (Linkage < RetSizeLeft)
                        {
                            Wnode = (PWNODE_HEADER)((PUCHAR)Wnode + Linkage);
                            RetSizeLeft -= Linkage;
                        } else {
                            WmipDebugPrint(("WMI: Invalid Linkage field %x in a WNODE_EVENT_ITEM\n",
                                         Linkage));
                            Linkage = 0;
                        }
                    }
                } else {
                    WmipDebugPrint(("WMI: Received bad notification Wnode %x BufferSize %x RetSize %x RetSizeLeft %x\n",
                        Wnode,
                    Wnode->BufferSize, RetSize, RetSizeLeft));
                    Linkage = 0;
                }
            } while (Linkage != 0);

            //
            // If there are more events waiting then don't delay
            if (Wnode->Flags & WNODE_FLAG_INTERNAL2)
            {
                NotificationIODelay = 0;
                WmipDebugPrint(("WMI: Don't delay notficationread\n"));
            } else {
                WmipDebugPrint(("WMI: delaying notficationread\n"));
            }

            //
            // Now send out any events that were queued up
            if (MultiEvent)
            {
                WmipSendQueuedEvents();
            }
        }
    } else {
        //
        // If the IOCTL failed there is something really bad happening in
        // the WMI device so we don't want to spin just calling and getting
        // back an error.
        NotificationIODelay = 5000;
        WmipDebugPrint(("WMI: IOCTL_WMI_READ_NOTIFICATIONS failed %x\n",
                         GetLastError()));
    }

    //
    // Requeue the work item that initiates another notification read. We
    // add it to the timer queue and not the work queue so that we can
    // delay between notification reads. We do this so that in the case of
    // a notification storm the notifications can be batched. Doing this will
    // delay event delivery by up to WmipNotificationDely, but will decrease
    // the cpu utilized in the event of a storm.
    WmipThreadPoolStatus = SecondaryTimerWaiting;
    while ( ! CreateTimerQueueTimer(&WmipQueueReadNotificationTimer,
                            NULL,
                                WmipQueueReadNotification,
                                WmipKMHandle,
                                NotificationIODelay,
                                0,
                                WT_EXECUTEINIOTHREAD))
    {
        //
        // If this failed then hope it is a resource error and that it
        // will go away after waiting a second.
        WmipDebugPrint(("WMI: SetTimerQueueTimer requeue failed %d\n",
                        GetLastError()));

        //
        // It is a bad idea to sleep in a system pool thread, but there is
        // nothing else to do if we can't queue another read
        Sleep(1000);
    }
    return(0);
}

VOID WmipReadNotificationCompleteHack(
    PVOID Context,
    BOOLEAN Condition
    )
{
    if (WmipServiceShutdown)
    {
        //
        // If service is shutdown then just return
        WmipThreadPoolStatus = ServiceShutdownRunning;
        return;
    }    
    
    WmipThreadPoolStatus = WorkItemWaiting;
    while (! QueueUserWorkItem(WmipReadNotificationComplete,
                               Context,
                               WT_EXECUTEDEFAULT))
    {
        Sleep(1000);
    }
}

ULONG WmipQueueReadNotification(
    PVOID Context,
    BOOLEAN Condition
    )
/*++

Routine Description:

    Win32 work item that queues a read for notifications. This must have
    been queued for execution in an IO thread

Arguments:

    Context

Return Value:

--*/
{
    HANDLE WmiKMHandle = (HANDLE)Context;
    BOOL b, IoError;
    ULONG Status;
    HANDLE TimerQueue;

    TimerQueue = WmipQueueReadNotificationTimer;
    WmipQueueReadNotificationTimer = NULL;
    
    WmipThreadPoolStatus = TimerRunning;
    
    b = DeleteTimerQueueTimer(NULL,
                          TimerQueue,
                          NULL);
                      
    
    if (! b)
    {
        WmipDebugPrint(("WMI: DeleteTimerQueueTimer Failed %d\n",
                        GetLastError()));
    }

    if (WmipServiceShutdown)
    {
        //
        // If service is shutdown then just return
        WmipThreadPoolStatus = ServiceShutdownRunning;
        return(0);
    }
    
    //
    // make sure buffer is allocated properly. If the buffer was previously
    // too small then the wait callback (ie callback when DeviceIoControl
    // completes) will update the size of WmipNotificationBufferSize and
    // free WmipNotificationBuffer.
    while (WmipNotificationBuffer == NULL)
    {
        WmipNotificationBuffer = WmipAlloc(WmipNotificationBufferSize);
        if (WmipNotificationBuffer == NULL)
        {
            //
            // If we could not allocate a buffer then lets hope that this is
            // a temporary resource problem and so wait a second and try again
            WmipDebugPrint(("WMI: Could not reallocate buffer for NotificationRead\n"));
            WmipThreadPoolStatus = BufferAllocTimerWaiting;
            while ( ! CreateTimerQueueTimer(&WmipQueueReadNotificationTimer,
                            NULL,
                                WmipQueueReadNotification,
                                WmipKMHandle,
                                1000,
                                0,
                                WT_EXECUTEINIOTHREAD))
            {
                //
                // If this failed then hope it is a resource error and that it
                // will go away after waiting a second.
                WmipDebugPrint(("WMI: SetTimerQueueTimer 2 requeue failed %d\n",
                        GetLastError()));

                //
                // It is a bad idea to sleep in a system pool thread, but
                // there is nothing else to do if we can't queue another read
                Sleep(1000);
            }
            return(0);
        }
    }

    //
    // Queue a read for notifications
    do 
    {
        WmipThreadPoolStatus = IoControlWaiting;        
        if (! DeviceIoControl(WmiKMHandle,
                    IOCTL_WMI_READ_NOTIFICATIONS,
                    NULL,
                    0,
                    WmipNotificationBuffer,
                    WmipNotificationBufferSize,
                    NULL,
                    &WmipNotificationOverlapped))
        {
            Status = GetLastError();
            if ((Status != ERROR_SUCCESS) && 
                (Status != ERROR_IO_PENDING))
            {
                IoError = TRUE;
                WmipDebugPrint(("WMI: DeviceIoControl for notification failed %d\n",
                                Status));
                Sleep(1000);
            } else {
                IoError = FALSE;
            }
        } else {
            Status = ERROR_SUCCESS;
            IoError = FALSE;
        }        
    } while (IoError);
    
    return(0);
}

ULONG WmipGetPersistThread(
    PVOID Context
    )
{
    HANDLE Process, Thread;
    
    if (WmipServiceShutdown)
    {
        //
        // If service is shutdown then just return
        WmipThreadPoolStatus = ServiceShutdownRunning;
        return(0);
    }
    
    
    Process = GetCurrentProcess();
    Thread = GetCurrentThread();
    
    //
    // We should be running in a persistent thread. Get the thread handle.
        
    WmipThreadPoolStatus = GetPersistentThread;
    if  (! DuplicateHandle(Process,
                           Thread,
                           Process,
                           &WmipAsyncRpcApcThread,
                           THREAD_ALL_ACCESS,
                           FALSE,
                           0))
    {
        //
        // Duplication of handle failed, Wait and try again
        WmipThreadPoolStatus = GetPersistentThreadFailed;
        Sleep(1000);
        WmipThreadPoolStatus = RequeueGetPersistentThread;
        while (! QueueUserWorkItem(WmipGetPersistThread, 
                                   NULL,
                                   WT_EXECUTEINPERSISTENTTHREAD))
        {
            WmipThreadPoolStatus = GetRequeueGetPersistentThreadWait;
            Sleep(1000);
        }        
    } else {
        WmipThreadPoolStatus = InitialTimerWaiting;
        while ( ! CreateTimerQueueTimer(&WmipQueueReadNotificationTimer,
                                     NULL,
                                     WmipQueueReadNotification,
                                     WmipKMHandle,
                                     0,
                                     0,
                                     WT_EXECUTEINIOTHREAD))            
        {
            WmipThreadPoolStatus = RequeueInitialTimerWaiting;
            Sleep(1000);
        }
    }
    return(0);
}


#endif

#ifndef MEMPHIS
void WmipNotificationDeliveryApcRoutine
 (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Flags
    )
{
    ULONG RetVal;
    ULONG Status;
    PDCENTRY DataConsumer = (PDCENTRY)pAsync->UserInfo;

    InterlockedDecrement(&DataConsumer->RpcCallsOutstanding);

    WmipDebugPrint(("WMI: WmipNotificationDeliveryApcRoutine %x, 0x%x outstanding\n", pAsync, DataConsumer->RpcCallsOutstanding));

    Status = RpcAsyncCompleteCall(pAsync, &RetVal);
#if DBG
    if (Status != ERROR_SUCCESS)
    {
        WmipDebugPrint(("WMI: Server RpcAsyncCompleteCall returned %d\n",
                            Status));
    }
#endif

    WmipFree(pAsync);
    WmipUnreferenceDC(DataConsumer);
}
#endif

#ifdef MEMPHIS
void WmipDeliverNotification(
    PDCENTRY DataConsumer,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize
    )
/*++

Routine Description:

    This routine does the actual delivery of notifications via rpc

Arguments:

    DataConsumer is the data consumer to whom the event should be delivered

    Wnode has the WNODE_HEADER that describes the notification

Return Value:


--*/
{
    //
    // Don't deliver notification if data consumer has been cleaned up
    if (DataConsumer->Flags & DC_FLAG_RUNDOWN)
    {
        WmipDebugPrint(("WMI: Event not sent DC %x is rundown\n", DataConsumer));
        return;
    }

    try
    {
        WmipClient_NotificationDelivery(
                             (handle_t)DataConsumer->RpcBindingHandle,
                             WnodeSize,
                             (PBYTE)Wnode,
                             0,
                             NOTIFICATION_FLAG_BATCHED);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipDebugPrint(("WMI: NotificationDeliver threw exception %d\n",
                            GetExceptionCode()));
    }

}
#else

void WmipCalcLostEvents(
    PDCENTRY DataConsumer,
    PWNODE_HEADER Wnode
)    
{
    ULONG Linkage = 1;
    PNOTIFICATIONENTRY NotificationEntry;
    PDCREF DcRef;
	ULONG EventsLost;
    
    while (Linkage != 0)
    {
        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // Internal notifications are not counted
            //
            Linkage = 0;
        } else {
            if (Wnode->Flags & WNODE_FLAG_TRACED_GUID) 
            {
                //
                // External notifications are handled here

                NotificationEntry = WmipFindNEByGuid(&Wnode->Guid, FALSE);

                if (NotificationEntry != NULL)
                {
                    DcRef = WmipFindDCRefInNE(NotificationEntry,
                                              DataConsumer);
                    if (DcRef != NULL)
                    {
                        WmipEnterSMCritSection();
                        DcRef->LostEventCount += Wnode->CountLost + 1;
                        WmipLeaveSMCritSection();
                        WmipDebugPrint(("WMI: Lost event %d for NE %p, DC %p\n",
                                    DcRef->LostEventCount,
                                    NotificationEntry,
                                    DataConsumer));
                    }
                    WmipUnreferenceNE(NotificationEntry);
                }
            }
            Linkage = Wnode->Linkage;
        }
        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
    }    
}

void WmipDeliverNotification(
    PDCENTRY DataConsumer,
    PWNODE_HEADER Wnode,
    ULONG WnodeSize
    )
/*++

Routine Description:

    This routine does the actual delivery of notifications via rpc

Arguments:

    DataConsumer is the data consumer to whom the event should be delivered

    Wnode has the WNODE_HEADER that describes the notification

Return Value:


--*/
{
    PRPC_ASYNC_STATE RpcAsyncState;
    ULONG Status;

    //
    // Don't deliver notification if data consumer has been cleaned up
    if (DataConsumer->Flags & DC_FLAG_RUNDOWN)
    {
        WmipDebugPrint(("WMI: Event not sent DC %x is rundown\n", DataConsumer));	
        return;
    }

    if (DataConsumer->RpcCallsOutstanding >= RPCOUTSTANDINGCALLLIMIT)
    {
        WmipDebugPrint(("WMI: Event not sent DC %x has 0x%x calls outstandeing rundown\n", DataConsumer, DataConsumer->RpcCallsOutstanding));
        WmipCalcLostEvents(DataConsumer, Wnode);
		
        return;
    }

    Status = WmipRestrictToken(WmipRestrictedToken);
    
    if (Status != ERROR_SUCCESS)
    {	
        return;
    }

    RpcAsyncState = (PRPC_ASYNC_STATE)WmipAlloc(sizeof(RPC_ASYNC_STATE));
    if (RpcAsyncState == NULL)
    {
        WmipDebugPrint(("WMI: Couldn't allocate async state for call\n"));
        return;
    }

    Status = RpcAsyncInitializeHandle(RpcAsyncState,
                                      RPC_ASYNC_VERSION_1_0);
    if (Status != ERROR_SUCCESS)
    {
        WmipFree(RpcAsyncState);
        return;
    }

    WmipAssert(WmipAsyncRpcApcThread != NULL);
    
    RpcAsyncState->NotificationType = RpcNotificationTypeApc;
    RpcAsyncState->u.NotificationRoutine = WmipNotificationDeliveryApcRoutine;
    RpcAsyncState->u.APC.hThread = WmipAsyncRpcApcThread;
    RpcAsyncState->UserInfo = (PVOID)DataConsumer;

    InterlockedIncrement(&DataConsumer->RpcCallsOutstanding);
    WmipDebugPrint(("WMI: Calling Async NotificationDeliver %x, 0x%x outstanding\n",
                        RpcAsyncState, DataConsumer->RpcCallsOutstanding));

    //
    // Take an extra refcount so DC will stick around until the call completes
    WmipReferenceDC(DataConsumer);

    try
    {
        WmipClient_NotificationDelivery(
                             RpcAsyncState,
                             (handle_t)DataConsumer->RpcBindingHandle,
                             WnodeSize,
                             (PBYTE)Wnode,
                             0,
                             NOTIFICATION_FLAG_BATCHED);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        InterlockedDecrement(&DataConsumer->RpcCallsOutstanding);
        WmipUnreferenceDC(DataConsumer);
        WmipDebugPrint(("WMI: NotificationDeliver threw exception %d\n",
                            GetExceptionCode()));
    }
    WmipDebugPrint(("WMI: Return Async NotificationDeliver %x\n",
                        RpcAsyncState));
        	
    WmipUnrestrictToken();
}
#endif

PWNODE_HEADER WmipIncludeStaticNames(
    PWNODE_HEADER Wnode
    )
{
    PWMIINSTANCEINFO WmiInstanceInfo, TargetInstanceInfo;
    ULONG InstanceCount;
    PWNODE_HEADER WnodeFull;
    PWNODE_ALL_DATA WnodeAllData;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    ULONG i;
    PWCHAR InstanceName;
    ULONG InstanceNameLen;
    ULONG InstanceIndex;
    ULONG Status;
    LPGUID EventGuid = &Wnode->Guid;
    ULONG WnodeFullSize;
    PWCHAR TargetInstanceName;
    WCHAR Index[7];

    //
    // If no static instance names then nothing to do
    if (! (Wnode->Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES))
    {
        return(Wnode);
    }

    Status = GetGuidInfo(NULL,
                         EventGuid,
                         &InstanceCount,
                         &WmiInstanceInfo,
                         FALSE);
    if (Status != ERROR_SUCCESS)
    {
        //
        // If guid is not registered then nothing we can do
        WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0);
        WmipDebugPrint(("WMI: Static instance name in event, but guid not registered\n"));
        if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
        {
            WnodeAllData = (PWNODE_ALL_DATA)Wnode;
            WnodeAllData->OffsetInstanceNameOffsets = 0;
        } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
                   (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM))
        {
            WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
            WnodeSI->OffsetInstanceName = 0;
        }
        return(Wnode);
    }

    //
    // Select the InstanceInfo for the specified provider id
    TargetInstanceInfo = NULL;
    for (i = 0; i < InstanceCount; i++)
    {
        if (Wnode->ProviderId == WmiInstanceInfo[i].ProviderId)
        {
            TargetInstanceInfo = &WmiInstanceInfo[i];
            break;
        }
    }

    if (TargetInstanceInfo == NULL)
    {
        //
        // If no matching provider id
        WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0);
        WmipDebugPrint(("WMI: Static instance name in event, but provider id not registered\n"));
        midl_user_free(WmiInstanceInfo);
        return(Wnode);
    }

    if ((TargetInstanceInfo->Flags &
             (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) == 0)
    {
        WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0);
        WmipDebugPrint(("WMI: Static instance name event but guid registered as dynamic\n"));
        return(Wnode);
    }

    if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
    {
        //
        // Fill instance names in WNODE_ALL_DATA
        WnodeFullSize = Wnode->BufferSize +
                        (TargetInstanceInfo->InstanceCount * sizeof(ULONG)) +
                              WmipStaticInstanceNameSize(TargetInstanceInfo);
        WnodeFull = WmipAlloc(WnodeFullSize);
        if (WnodeFull == NULL)
        {
            WnodeFull = Wnode;
        } else {
            memcpy(WnodeFull, Wnode, Wnode->BufferSize);
            WnodeAllData = (PWNODE_ALL_DATA)WnodeFull;
            WmipInsertStaticNames(WnodeAllData,
                                  WnodeFullSize,
                                  TargetInstanceInfo);
        }

    } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
               (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM))
    {
        //
        // Fill instance names in WNODE_SINGLE_INSTANCE or _ITEM
        WnodeFull = Wnode;

        WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
        InstanceIndex = WnodeSI->InstanceIndex;
        if (InstanceIndex < TargetInstanceInfo->InstanceCount)
        {
            if (TargetInstanceInfo->Flags & IS_INSTANCE_STATICNAMES)
            {
                InstanceName = TargetInstanceInfo->StaticNamePtr[InstanceIndex];
                InstanceNameLen = (wcslen(InstanceName) + 2) * sizeof(WCHAR);
            } else if (TargetInstanceInfo->Flags & IS_INSTANCE_BASENAME) {
                InstanceName = TargetInstanceInfo->BaseName;
                InstanceNameLen = (wcslen(InstanceName) + 2 + MAXBASENAMESUFFIXSIZE) * sizeof(WCHAR);
            }

            //
            // Allocate a new Wnode and fill in the instance name
            WnodeFullSize = ((Wnode->BufferSize+1) & ~1) + InstanceNameLen;
            WnodeFull = WmipAlloc(WnodeFullSize);
            if (WnodeFull != NULL)
            {
                memcpy(WnodeFull, Wnode, Wnode->BufferSize);
                WnodeFull->BufferSize = WnodeFullSize;
                WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeFull;
                WnodeSI->OffsetInstanceName = (Wnode->BufferSize+1)& ~1;
                TargetInstanceName = (PWCHAR)((PBYTE)WnodeSI + WnodeSI->OffsetInstanceName);
                if (TargetInstanceInfo->Flags & IS_INSTANCE_STATICNAMES)
                {
                    InstanceNameLen -= sizeof(WCHAR);
                    *TargetInstanceName++ = (USHORT)InstanceNameLen;
                    wcscpy(TargetInstanceName, InstanceName);
                } else {
                    if (TargetInstanceInfo->Flags & IS_PDO_INSTANCENAME)
                    {
                        WnodeFull->Flags |= WNODE_FLAG_PDO_INSTANCE_NAMES;
                    }
#ifdef MEMPHIS
                    swprintf(Index, L"%d",
                              TargetInstanceInfo->BaseIndex + InstanceIndex);
                    wcscpy(TargetInstanceName+1, InstanceName);
                    wcscat(TargetInstanceName+1, Index);
                    InstanceNameLen = wcslen(TargetInstanceName+1);
#else
                    InstanceNameLen = wsprintfW(TargetInstanceName+1,
                              L"%ws%d", InstanceName,
                              TargetInstanceInfo->BaseIndex + InstanceIndex);
#endif
                    *TargetInstanceName = ((USHORT)InstanceNameLen+1) * sizeof(WCHAR);
                }
            } else {
                WmipDebugPrint(("WMI: Couldn't alloc memory for Static instance name in event\n"));
                WnodeFull = Wnode;
            }
        } else {
            WmipReportEventLog(EVENT_WMI_CANT_RESOLVE_INSTANCE,
                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0);
            WmipDebugPrint(("WMI: Static instance name index in event too large\n"));
        }
    }

    midl_user_free(WmiInstanceInfo);

    return(WnodeFull);
}

#define DCPERLOOP 16
void WmipSendQueuedEvents(
    void
    )
{
    PLIST_ENTRY DataConsumerList;
    PDCENTRY DataConsumer;
    PDCENTRY DCList[DCPERLOOP];
    ULONG DCCount, i;

    do
    {
        WmipEnterSMCritSection();
        DataConsumerList = DCHead.Flink;

        DCCount = 0;
        while ((DataConsumerList != &DCHead) &&
               (DCCount < DCPERLOOP))
        {
            DataConsumer = CONTAINING_RECORD(DataConsumerList,
                                             DCENTRY,
                                             MainDCList);

            if (DataConsumer->EventData != NULL)
            {
                DCList[DCCount++] = DataConsumer;
            }

            DataConsumerList = DataConsumerList->Flink;
        }
        WmipLeaveSMCritSection();

        for (i = 0; i < DCCount; i++)
        {
            //
            // Send off event, free queue buffer and unreference DC
            WmipDeliverNotification(DCList[i],
                                    (PWNODE_HEADER)DCList[i]->EventData,
                                    DCList[i]->NextEventOffset);

            WmipFree(DCList[i]->EventData);
            DCList[i]->EventData = NULL;
            WmipUnreferenceDC(DCList[i]);
        }

    } while (DataConsumerList != &DCHead);
}

void WmipDeliverEventToAllConsumers(
    PNOTIFICATIONENTRY NotificationEntry,
    PWNODE_HEADER Wnode
    )
{
    ULONG i;
    NOTIFICATIONENTRY NotificationEntryCopy;

CheckContinuation:
    //
    // While we own the critical section we make a copy of the
    // NotificationEntry so that it will remain consistent while we callout
    // to the event consumers. We also reference all of the data consumers
    // that will be receiving events so that they don't go away while we
    // are calling out. We don't need to worry about the NotificationEntry
    // going away since it was reference by the caller.

    WmipEnterSMCritSection();
    NotificationEntryCopy = *NotificationEntry;
    for (i = 0; i < DCREFPERNOTIFICATION; i++)
    {
        if (NotificationEntryCopy.DcRef[i].Flags & DCREF_FLAG_NOTIFICATION_ENABLED)
        {
            WmipReferenceDC(NotificationEntryCopy.DcRef[i].DcEntry);
        }
    }
    WmipLeaveSMCritSection();

    //
    // While we aren't holding the critical section we call out to all of the
    // data consumers who are interested in this event
    for (i = 0; i < DCREFPERNOTIFICATION; i++)
    {
        PDCREF DcRef = &NotificationEntryCopy.DcRef[i];
        PDCREF DcRef2 = &NotificationEntry->DcRef[i];
        
        if (DcRef->Flags & DCREF_FLAG_NOTIFICATION_ENABLED)
        {
            if (Wnode->Flags & WNODE_FLAG_TRACED_GUID) 
            {            
                Wnode->CountLost = InterlockedExchange(
                                                    &DcRef2->LostEventCount, 
                                                    0);
            }
            WmipDeliverNotification(DcRef->DcEntry,
                                    Wnode,
                                    Wnode->BufferSize);
            //
            // Now that the data consumer in the NotificationEntry
            // have been called we will unreference them so that they
            // can go away if they are freed
            WmipUnreferenceDC(DcRef->DcEntry);
        }
    }


    //
    // Finally we need to see if the notification entry has a continuation
    // block with more data consumers to notify. If so we go back and
    // do this all again. We don't worry about the continuation block going
    // away since it is only freed when the entire notification entry is
    // freed and that can't happen since the caller took an extra ref count
    // on it.
    if (NotificationEntryCopy.Continuation != NULL)
    {
        NotificationEntry = NotificationEntryCopy.Continuation;
        goto CheckContinuation;
    }
}

void WmipQueueEventToAllConsumers(
    PNOTIFICATIONENTRY NotificationEntry,
    PWNODE_HEADER Wnode,
    ULONG EventSizeGuess
    )
{
    ULONG i;
    NOTIFICATIONENTRY NotificationEntryCopy;
    PDCENTRY DataConsumer;
    ULONG DCCount;
    ULONG NextEventOffset, LastEventOffset;
    ULONG WnodeSize;
    PWNODE_HEADER EventBuffer;
    BOOLEAN FirstEventBuffer = FALSE;

    WmipEnterSMCritSection();
CheckContinuation:
    for (i = 0, DCCount = 0; i < DCREFPERNOTIFICATION; i++)
    {
        PDCREF DcRef = &NotificationEntry->DcRef[i];
        if (DcRef->Flags & DCREF_FLAG_NOTIFICATION_ENABLED)
        {
            DataConsumer = DcRef->DcEntry;

            //
            // if an event data buffer has not been allocated for the
            // data consumer yet then allocate one.
            if (DataConsumer->EventData == NULL)
            {
                DataConsumer->EventData = WmipAlloc(EventSizeGuess);
                if (DataConsumer->EventData == NULL)
                {
                     WmipDebugPrint(("WMI: Events lost since DataConsumer->EventData could not be allocated, size %d\n", EventSizeGuess));
                    continue;
                }
                DataConsumer->NextEventOffset = 0;
                FirstEventBuffer = TRUE;
                DataConsumer->EventDataSizeLeft = EventSizeGuess;
                WmipReferenceDC(DataConsumer);
            }

            //
            // Ensure there is enough room to copy the new event
            NextEventOffset = DataConsumer->NextEventOffset;
            LastEventOffset = DataConsumer->LastEventOffset;

            WnodeSize = Wnode->BufferSize;
            WnodeSize = (WnodeSize + 7) & ~7;
            if (DataConsumer->EventDataSizeLeft < WnodeSize)
            {
                EventSizeGuess = NextEventOffset +
                                 DataConsumer->EventDataSizeLeft;
                EventSizeGuess += (EventSizeGuess / 2) > WnodeSize ?
                                        (EventSizeGuess / 2) :
                                        (EventSizeGuess / 2) + WnodeSize;


                if (! WmipRealloc(&DataConsumer->EventData,
                                  NextEventOffset,
                                  EventSizeGuess,
                  TRUE))
                {
                    WmipDebugPrint(("WMI: Event lost, couldn't realloc DataConsumer->EventData for size %d\n", EventSizeGuess));
                    continue;
                }

                DataConsumer->EventDataSizeLeft = EventSizeGuess -
                                                  NextEventOffset;
                WmipAssert(DataConsumer->EventDataSizeLeft >= WnodeSize);
            }

            //
            // Copy the new event to the end of the buffer
            EventBuffer = (PWNODE_HEADER)OffsetToPtr(DataConsumer->EventData,
                                                     NextEventOffset);
            memcpy(EventBuffer, Wnode, Wnode->BufferSize);
            EventBuffer->Linkage = 0;
			
            if (EventBuffer->Flags & WNODE_FLAG_TRACED_GUID) 
            {            
                EventBuffer->CountLost = InterlockedExchange(
                                                    &DcRef->LostEventCount, 
                                                    0);
            }

            //
            // Link the previously last event to this one
            if (! FirstEventBuffer)
            {
                EventBuffer = (PWNODE_HEADER)OffsetToPtr(DataConsumer->EventData,
                                                         LastEventOffset);
                EventBuffer->Linkage = NextEventOffset - LastEventOffset;
            }

            DataConsumer->LastEventOffset = NextEventOffset;
            DataConsumer->NextEventOffset = NextEventOffset + WnodeSize;
            DataConsumer->EventDataSizeLeft -= WnodeSize;
        }
    }

    //
    // Finally we need to see if the notification entry has a continuation
    // block with more data consumers to notify. If so we go back and
    // do this all again. We don't worry about the continuation block going
    // away since it is only freed when the entire notification entry is
    // freed and that can't happen since the caller took an extra ref count
    // on it.
    if (NotificationEntry->Continuation != NULL)
    {
        NotificationEntry = NotificationEntry->Continuation;
        goto CheckContinuation;
    }

    WmipLeaveSMCritSection();
}

PWNODE_HEADER WmipDereferenceEvent(
    PWNODE_HEADER Wnode
    )
{
    ULONG WnodeTargetSize;
    ULONG IsStaticInstanceNames;
    ULONG InstanceNameLen, InstanceNameLen2;
    PWNODE_SINGLE_INSTANCE WnodeTarget;
    PWCHAR Ptr;
    PWNODE_EVENT_REFERENCE WnodeRef = (PWNODE_EVENT_REFERENCE)Wnode;
    PBDATASOURCE DataSource;
    ULONG Status;
    ULONG Retries;

    //
    // Determine if the data source is valid or not
    DataSource = WmipFindDSByProviderId(WnodeRef->WnodeHeader.ProviderId);
    if (DataSource == NULL)
    {
        WmipDebugPrint(("WMI: Invalid Data Source in referenced guid \n"));
        return(NULL);
    }
    
    //
    // Compute the size of any dynamic name that must go into the TargetWnode
    IsStaticInstanceNames = WnodeRef->WnodeHeader.Flags & 
                             WNODE_FLAG_STATIC_INSTANCE_NAMES;
    if (IsStaticInstanceNames == 0)
    {
        InstanceNameLen = *WnodeRef->TargetInstanceName + sizeof(USHORT);
    } else {
        InstanceNameLen = 0;
    }
    
    WnodeTargetSize = WnodeRef->TargetDataBlockSize + 
                          FIELD_OFFSET(WNODE_SINGLE_INSTANCE, 
                                       VariableData) +
                          InstanceNameLen + 
                          8;

    Retries = 0;
    do
    {
        WnodeTarget = WmipAlloc(WnodeTargetSize);
    
        if (WnodeTarget != NULL)
        {
            //
            // Build WNODE_SINGLE_INSTANCE that we use to query for event data
            memset(WnodeTarget, 0, WnodeTargetSize);

            WnodeTarget->WnodeHeader.BufferSize = WnodeTargetSize;
            memcpy(&WnodeTarget->WnodeHeader.Guid, 
                   &WnodeRef->TargetGuid,
                   sizeof(GUID));
            WnodeTarget->WnodeHeader.Version = WnodeRef->WnodeHeader.Version;
            WnodeTarget->WnodeHeader.Flags = WNODE_FLAG_SINGLE_INSTANCE |
                                           IsStaticInstanceNames;
                                       
            if (IsStaticInstanceNames != 0)
            {
                WnodeTarget->InstanceIndex = WnodeRef->TargetInstanceIndex;
                WnodeTarget->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                        VariableData);
            } else {            
                WnodeTarget->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                           VariableData);
                Ptr = (PWCHAR)OffsetToPtr(WnodeTarget, WnodeTarget->OffsetInstanceName);
                InstanceNameLen2 = InstanceNameLen - sizeof(USHORT);
                *Ptr++ = (USHORT)InstanceNameLen2;
                memcpy(Ptr, 
                       &WnodeRef->TargetInstanceName[1], 
                       InstanceNameLen2);
                //
                // Round data block offset to 8 byte alignment
                WnodeTarget->DataBlockOffset = ((FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                          VariableData) + 
                                            InstanceNameLen2 + 
                                            sizeof(USHORT)+7) & 0xfffffff8);
            }
            Status = WmipDeliverWnodeToDS(WmiGetSingleInstance,
                                          DataSource,
                                          (PWNODE_HEADER)WnodeTarget);
                                      
            if ((Status == ERROR_SUCCESS) &&
                (WnodeTarget->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
            {
                WnodeTargetSize = ((PWNODE_TOO_SMALL)WnodeTarget)->SizeNeeded;
                WmipFree(WnodeTarget);
                Retries++;
                Status = ERROR_MORE_DATA;
            }
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } while ((Status == ERROR_MORE_DATA) && (Retries < 2));
    
    WmipUnreferenceDS(DataSource);
    
    if (Status != ERROR_SUCCESS)
    {
        WmipReportEventLog(EVENT_WMI_CANT_GET_EVENT_DATA,

                           EVENTLOG_WARNING_TYPE,
                            0,
                           Wnode->BufferSize,
                           Wnode,
                           0);
        WmipDebugPrint(("WMI: Query to dereference WNODE failed %d\n",
                Status));
        if (WnodeTarget != NULL)
        {
            WmipFree(WnodeTarget);
            WnodeTarget = NULL;
        }
    } else {
        WnodeTarget->WnodeHeader.Flags |= (WnodeRef->WnodeHeader.Flags & 
                                              WNODE_FLAG_SEVERITY_MASK) |
                                             WNODE_FLAG_EVENT_ITEM;
    }
    return((PWNODE_HEADER)WnodeTarget);
}

void WmipEventNotification(
    PWNODE_HEADER Wnode,
    BOOLEAN SingleEvent,
    ULONG EventSizeGuess
    )
/*++

Routine Description:

    This routine is called to deliver a notification to all of the consumers
    who have registered to receive it. If the data provider
    fired a WNODE_EVENT_REFERENCE then we query for the guid that is
    referenced in the event and put the results of the query in the event.

Arguments:

    Wnode has the WNODE_HEADER that describes the notification

Return Value:


--*/
{
    PNOTIFICATIONENTRY NotificationEntry;
    LPGUID EventGuid = &Wnode->Guid;
    PWNODE_HEADER WnodeFull, WnodeTarget;

    //
    // If the event references a guid that needs to be queried then
    // go do the dereferencing here.
    if (Wnode->Flags & WNODE_FLAG_EVENT_REFERENCE)
    {
        WnodeTarget = WmipDereferenceEvent(Wnode);
        if (WnodeTarget == NULL)
        {
            return;
        }
        Wnode = WnodeTarget;
    } else {
        WnodeTarget = NULL;
    }

    //
    // Be sure to use the guid of the referenced event, not the event that
    // was originally fired.
    EventGuid = &Wnode->Guid;

    // If it is Trace error notification, disable providers
    //
#ifndef MEMPHIS
    if (IsEqualGUID(EventGuid, & TraceErrorGuid)) {
        WmipServiceDisableTraceProviders(Wnode);
    }
#endif

    //
    // See if this event has a static name and if so fill it in
    WnodeFull = WmipIncludeStaticNames(Wnode);

    //
    // Deliver notification to those data consumers who registered for it
    NotificationEntry = WmipFindNEByGuid(EventGuid, TRUE);
    if (NotificationEntry != NULL)
    {
        if (SingleEvent)
        {
            WmipDeliverEventToAllConsumers(NotificationEntry, WnodeFull);
        } else {
            WmipQueueEventToAllConsumers(NotificationEntry,
                                         WnodeFull,
                                         EventSizeGuess);
        }
        WmipUnreferenceNE(NotificationEntry);
    }

    if (WnodeFull != Wnode)
    {
        WmipFree(WnodeFull);
    }

    if (WnodeTarget != NULL)
    {
        WmipFree(WnodeTarget);
    }
}
 
ULONG WmipCleanupDataConsumer(
    PDCENTRY DataConsumer
#if DBG
    ,BOOLEAN *NotificationsEnabled,
    BOOLEAN *CollectionsEnabled
#endif
    )
/*++

Routine Description:

    This routine cleans up after a data consumer who has gone way. We walk
    the list of notifications and collections and if there is any enabled
    collections or notifications then these are disabled. Also any memory
    used by the data consumer is freed.

Arguments:

    DataConsumer is the data consumer to cleanup

    *NotificationsEnabled returns TRUE if the data consumer had left any
        notifications enabled on debug builds. On Free builds it always
        returns FALSE.

    *CollectionsEnabled returns TRUE if the data consumer had left any
        collections enabled on debug builds. On Free builds it always
        returns FALSE.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PLIST_ENTRY NEList;
    PNOTIFICATIONENTRY NotificationEntry, Continuation;
    ULONG i;
    TCHAR s[256];
    ULONG Cookie;

    //
    // Some yahoo is unregistering more than once
    if (DataConsumer->Flags & FLAG_ENTRY_ON_FREE_LIST)
    {
        WmipAssert(FALSE);
        return(ERROR_INVALID_PARAMETER);
    }

    WmipAssert(DataConsumer->RpcBindingHandle != 0);

    //
    // Loop over notifications to see if this data consumer left anything
    // enabled

CheckAgain:
    WmipEnterSMCritSection();
    NEList = NEHeadPtr->Flink;
    while (NEList != NEHeadPtr)
    {
        NotificationEntry = CONTAINING_RECORD(NEList,
                                              NOTIFICATIONENTRY,
                                              MainNotificationList);

        Continuation = NotificationEntry;
        while (Continuation != NULL)
        {
            for (i = 0; i < DCREFPERNOTIFICATION; i++)
            {
                if (NotificationEntry->DcRef[i].DcEntry == DataConsumer)
                {
                    WmipAssert(NotificationEntry->DcRef[i].Flags != 0);
                    if (NotificationEntry->DcRef[i].Flags & DCREF_FLAG_NOTIFICATION_ENABLED)
                    {
#if DBG
                        *NotificationsEnabled = TRUE;
#endif
                        WmipLeaveSMCritSection();

                        CollectOrEventWorker(
                                         DataConsumer,
                                         &NotificationEntry->Guid,
                                         FALSE,
                                         TRUE,
                                         &Cookie,
                                         0,
                                         0);

                        //
                        // We have to jump out and restart the loop
                        // since the notification entry could have
                        // been freed while in the NotificationControl
                        // routine
                        goto CheckAgain;
                    }

                    if (NotificationEntry->DcRef[i].Flags & DCREF_FLAG_COLLECTION_ENABLED)
                    {
#if DBG
                        *CollectionsEnabled = TRUE;
#endif
                        //
                        // We force the collection ref count for the DC entry
                        // to 1 in case there were multiple threads in the
                        // data consumer who had collection enabled
                        NotificationEntry->DcRef[i].CollectRefCount = 1;

                        WmipLeaveSMCritSection();
                        CollectionControl( (DCCTXHANDLE)DataConsumer,
                                         &NotificationEntry->Guid,
                                         FALSE);
                        //
                        // We have to jump out and restart the loop since
                        // the notification entry could have been freed
                        // while in the CollectionControl routine
                        goto CheckAgain;
                    }

                }
            }
            Continuation = Continuation->Continuation;
            NotificationEntry = Continuation;
        }
        NEList = NEList->Flink;
    }

    //
    // Mark DC as being rundown so no more events are sent to it.
    // Binding handle will be freed when the DataConsumer is freed.
    DataConsumer->Flags |= DC_FLAG_RUNDOWN;
    WmipDebugPrint(("WMI: DC %x has just been rundown\n", DataConsumer));

    WmipUnreferenceDC(DataConsumer);

    WmipLeaveSMCritSection();

    if ((WmipServiceShutdown) && (IsListEmpty(DCHeadPtr)))
    {
        //
        // Set event if there are no more data consumers attached
        // and we are waiting to exit service. Note that once we set this
        // event, all resources such as memory allocations, critical sections,
        // file handles, etc are gone and must not be used.
        if (WmipTerminationEvent != NULL)
        {
            SetEvent(WmipTerminationEvent);
        }
    }

    return(ERROR_SUCCESS);
}

void __cdecl WmipReportEventLog(
    ULONG MessageCode,
    WORD MessageType,
    WORD MessageCategory,
    DWORD RawDataSize,
    PVOID RawData,
    WORD StringCount,
    ...
    )
{
#ifndef MEMPHIS
    LPCTSTR StringList[MAX_MESSAGE_STRINGS];
    va_list pArg;
    ULONG i;

    if (WmipEventLogHandle != NULL)
    {
        if (StringCount > MAX_MESSAGE_STRINGS)
        {
            WmipAssert(FALSE);
            StringCount = MAX_MESSAGE_STRINGS;
        }

        va_start(pArg, StringCount);

        for (i = 0; i < StringCount; i++)
        {
            StringList[i] = va_arg(pArg, LPCTSTR);
        }

        ReportEvent(WmipEventLogHandle,
                    MessageType,
                    MessageCategory,
                    MessageCode,
                    NULL,
                    StringCount,
                    RawDataSize,
                    StringList,
                    RawData);
    }
#endif
}

#ifdef MEMPHIS

long WINAPI
DeviceNotificationWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    ULONG Status;

    WmipDebugPrint(("WMI: 0x%x Got Message %d, wParam 0x%x, lParam 0x%x\n",
                       hWnd, Message, wParam, lParam));

    //
    // If we get a WM_DEVICECHANGE message with wParam set to
    // DBT_DEVICEARRIVAL then it means that a new device has been loaded
    // on the system. We use this opportunity to recheck if the WMI device
    // has been created.
    if (Message == WM_DEVICECHANGE)
    {
        if (wParam == DBT_DEVICEARRIVAL)
        {
            //
            // Attempt kernel mode initialization. If it succeeds then
            // WmipKMHandle will be set and we will fall out of the GetMessage
            // loop, destroy the window, etc. If it fails then nothing has
            // changed.
            if (WmipKMHandle == (HANDLE)-1)
            {
                Status = WmipInitializeKM(&WmipKMHandle);
                WmipDebugPrint(("WMI: WmipInitializeKM returned %d\n", Status));
                if (Status == ERROR_SUCCESS)
                {
                    PostQuitMessage(0);
                }
            }
        }
    }

    return (DefWindowProc(hWnd, Message, wParam, lParam));
}

#define WMIHIDDENCLASSNAME "WMIHIDDENCLASSNAME"

ULONG WmipCreateDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND *DeviceNotificationWindow
    )
{
    WNDCLASS WndClass;
    ULONG Status;

    WndClass.style = CS_BYTEALIGNWINDOW;
    WndClass.lpfnWndProc = DeviceNotificationWndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = InstanceHandle;
    WndClass.hIcon = NULL;
    WndClass.hCursor = NULL;
    WndClass.hbrBackground = 0;
    WndClass.lpszMenuName = 0;
    WndClass.lpszClassName = WMIHIDDENCLASSNAME;

    if (! RegisterClass(&WndClass))
    {
        return(GetLastError());
    }


    *DeviceNotificationWindow = CreateWindowEx(0,
                           WMIHIDDENCLASSNAME,
                           NULL,
                           0,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           NULL,
                           NULL,
                           InstanceHandle,
                           NULL);
    if (*DeviceNotificationWindow == NULL)
    {
        Status = GetLastError();
        UnregisterClass(WMIHIDDENCLASSNAME,
                        InstanceHandle);
    } else {
        Status = ERROR_SUCCESS;
    }

    return(Status);
}

void WmipDestroyDeviceNotificationWindow(
    HINSTANCE InstanceHandle,
    HWND WindowHandle
    )
{
    DestroyWindow(WindowHandle);
    UnregisterClass(WMIHIDDENCLASSNAME,
                    InstanceHandle);
}
#endif

#ifndef MEMPHIS

#define WmipNoActiveDC() (IsListEmpty((&DCHead)))

void WmiServiceCtrlHandler(
    DWORD Opcode
    )
/*++

Routine Description:

    This routine is the service control handler for the WMI service. The
    service control manager will call this routine to pause, stop,
    continue or obtain the status of the WMI service.

Arguments:

    OpCode is the function that the service control manager asks WMI to
    perform

Return Value:

--*/
{
    ULONG Status;

    switch(Opcode)
    {
        case SERVICE_CONTROL_PAUSE:
        {
            WmipDebugPrint(("WMI: service does not support Pause\n"));
            break;
        }

        case SERVICE_CONTROL_CONTINUE:
        {
            WmipDebugPrint(("WMI: service does not support Continue\n"));
            break;
        }

        case SERVICE_CONTROL_STOP:
        {
            WmipEnterSMCritSection();
            if (WmipNoActiveDC())
            {
                //
                // No data consumers attached. We can shut down. First stop
                // the rpc interface so no new data consumers can attach
                // Remember we'll need to cleanup quickly since another
                // consumer may want to attach now.
                WmiServiceStatus.dwWin32ExitCode = 0;
                WmiServiceStatus.dwCurrentState  = SERVICE_STOP_PENDING;
                WmiServiceStatus.dwCheckPoint    = 0;
                WmiServiceStatus.dwWaitHint      = 0;

                if (!SetServiceStatus (WmiServiceStatusHandle,
                    &WmiServiceStatus))
                {
                    WmipLeaveSMCritSection();
                    Status = GetLastError();
                    WmipDebugPrint(("WMI: SetServiceStatus error %ld\n", Status));
                    break;
                }

                WmipSvcsGlobalData->StopRpcServer(wmicore_ServerIfHandle);

                WmipServiceShutdown = TRUE;
                WmipLeaveSMCritSection();

                WmiDeinitializeService();

                WmipNotificationBuffer = NULL;

                if (WmipNotificationWait != NULL)
                {
                     UnregisterWait(WmipNotificationWait);
                     WmipNotificationWait = NULL;
                }

                if (WmipNotificationOverlapped.hEvent != NULL)
                {
                    CloseHandle(WmipNotificationOverlapped.hEvent);
                    WmipNotificationOverlapped.hEvent = NULL;
                }
                
                if (WmipAsyncRpcApcThread != NULL)
                {
                    CloseHandle(WmipAsyncRpcApcThread);
                    WmipAsyncRpcApcThread = NULL;
                }
        
                if (WmipRestrictedToken != NULL)
                {
                    CloseHandle(WmipRestrictedToken);
                    WmipRestrictedToken = NULL;
                }                       

                WmiServiceStatus.dwCurrentState       = SERVICE_STOPPED;
                WmiServiceStatus.dwCheckPoint         = 0;
                WmiServiceStatus.dwWaitHint           = 0;
                WmiServiceStatus.dwWin32ExitCode      = ERROR_SUCCESS;
                WmiServiceStatus.dwServiceSpecificExitCode = ERROR_SUCCESS;

                WmipDebugPrint(("WMI: Leaving Service\n"));
            } else {
                WmipDebugPrint(("WMI: Service can't be stopped since data consumers are active\n"));
                 WmipLeaveSMCritSection();
            }
            break;
        }

        case SERVICE_CONTROL_INTERROGATE:
        {
            // Fall through to send current status.
            break;
        }

        default:
        {
            WmipDebugPrint(("WMI: Unrecognized opcode %ld\n", Opcode));
            break;
        }
    }

    //
    // Send current status.
    if (!SetServiceStatus (WmiServiceStatusHandle,  &WmiServiceStatus))
    {
        Status = GetLastError();
        WmipDebugPrint(("WMI: SetServiceStatus error %ld\n",Status));
    }
}

VOID
SVCS_ENTRY_POINT(
    DWORD               argc,
    LPWSTR              argv[],
    PSVCS_GLOBAL_DATA   SvcsGlobalData,
    HANDLE              SvcRefHandle
    )

/*++

Routine Description:

    This is the main thread of the WMI service. First the routine will
    initialize the service, call the service control manager to start
    listening for RPC calls on the WMI service's interface, and then enter
    the notification loop. If the notification loop returns then the
    service was requested to stop so the routine will stop the service's
    rpc interface, wait for all rpc clients to disconnect and then
    return. Note that once this routine returns the wmi service's dll
    is unloaded.

Arguments:

    argc is count of command-line arguments.

    argv is command-line arguments.

    SvcsGlobalData is a table of information the wmi service uses to
        interface with the service control manager.

    SvcRefHandle

Return Value:

    NONE

Note:


--*/
{
    DWORD Status;
    BOOLEAN NoDCReged;
    BOOLEAN ServiceInitialized;

    WmipSvcsGlobalData = SvcsGlobalData;
    WmipGlobalSvcRefHandle = SvcRefHandle;

    WmiServiceStatus.dwServiceType        = SERVICE_WIN32;
    WmiServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    WmiServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;
    WmiServiceStatus.dwWin32ExitCode      = 0;
    WmiServiceStatus.dwServiceSpecificExitCode = 0;
    WmiServiceStatus.dwCheckPoint         = 0;
    WmiServiceStatus.dwWaitHint           = 0;

    WmiServiceStatusHandle = RegisterServiceCtrlHandler(L"Wmi",
                                                       WmiServiceCtrlHandler);

    if (WmiServiceStatusHandle == 0)
    {
        WmipDebugPrint(("WMI: RegisterServiceCtrlHandler failed %d\n", GetLastError()));
        return;
    }

    //
    // Initialize the WMI service
    Status = WmiInitializeService();

    //
    // Obtain a restricted token to use when calling out
    if (Status == ERROR_SUCCESS)
    {
        Status = WmipCreateRestrictedToken(&WmipRestrictedToken);
    }

    //
    // Establish a work item to start the service running
                
    WmipNotificationOverlapped.hEvent = NULL;
    WmipNotificationWait = NULL;

    if (Status == ERROR_SUCCESS)
    {
        ServiceInitialized = TRUE;

        WmipNotificationOverlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (WmipNotificationOverlapped.hEvent != NULL)
        {
            if (RegisterWaitForSingleObject(&WmipNotificationWait,
                                  WmipNotificationOverlapped.hEvent,
                                          WmipReadNotificationCompleteHack,
                                          NULL,
                                          INFINITE,
                                          WT_EXECUTEINIOTHREAD))
            {
                WmipThreadPoolStatus = QueueGetPerisitentThread;
                if (! QueueUserWorkItem(WmipGetPersistThread, 
                                   NULL,
                                   WT_EXECUTEINPERSISTENTTHREAD))
                {
                    // TODO: Fire eventlog event
                    Status = GetLastError();
                    WmipDebugPrint(("WMI: SetTimerQueueTimer 3 failed %d\n", Status));
                }
            } else {
                Status = GetLastError();
                WmipDebugPrint(("WMI: RegisterWaitForSingleObjectEx failed %d\n", Status));
            }
        }
    } else {
        WmipDebugPrint(("WMI: WmiInitialize service failed %d\n", Status));
        ServiceInitialized = FALSE;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipSvcsGlobalData->StartRpcServer(
                                       WmipSvcsGlobalData->SvcsRpcPipeName,
                                       wmicore_ServerIfHandle);
                   
        if (Status == RPC_NT_TYPE_ALREADY_REGISTERED)
        {
            //
            // RPC_NT_TYPE_ALREADY_REGISTERED indicates that the rpc interface
            // has already been registered so it is safe to continue.
            Status = ERROR_SUCCESS;
        }

#if DBG
        if (Status != ERROR_SUCCESS)
        {
            WmipDebugPrint(("WMI: WmipSvcsGlobalData->StartRpcServer failed %d\n", Status));
        }
#endif
    }

    if (Status != ERROR_SUCCESS)
    {
        WmipServiceShutdown = TRUE;
        
        if (ServiceInitialized)
        {
            WmiDeinitializeService();
        }

        if (WmipNotificationWait != NULL)
        {
            UnregisterWait(WmipNotificationWait);
            WmipNotificationWait = NULL;
        }

        if (WmipNotificationOverlapped.hEvent != NULL)
        {
            CloseHandle(WmipNotificationOverlapped.hEvent);
            WmipNotificationOverlapped.hEvent = NULL;
        }

        if (WmipAsyncRpcApcThread != NULL)
        {
            CloseHandle(WmipAsyncRpcApcThread);
            WmipAsyncRpcApcThread = NULL;
        }
        
        if (WmipRestrictedToken != NULL)
        {
            CloseHandle(WmipRestrictedToken);
            WmipRestrictedToken = NULL;
        }
        
        //
        // If an error occurs we just stop ourselves
        WmiServiceStatus.dwCurrentState       = SERVICE_STOPPED;
        WmiServiceStatus.dwCheckPoint         = 0;
        WmiServiceStatus.dwWaitHint           = 0;
        WmiServiceStatus.dwWin32ExitCode      = Status;
        WmiServiceStatus.dwServiceSpecificExitCode = Status;

        SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus);
        return;
    }

    // Initialization complete - report running status.
    WmiServiceStatus.dwCurrentState       = SERVICE_RUNNING;
    WmiServiceStatus.dwCheckPoint         = 0;
    WmiServiceStatus.dwWaitHint           = 0;

    if (!SetServiceStatus (WmiServiceStatusHandle, &WmiServiceStatus))
    {
        Status = GetLastError();
        WmipDebugPrint(("WMI: SetServiceStatus error %ld\n",Status));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\server.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    server.c

Abstract:

    WMI server functionality

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "evntrace.h"
#include <rpc.h>

#ifndef MEMPHIS
#include <aclapi.h>
#endif

#define MAXSTR 1024

// {4EE0B301-94BC-11d0-A4EC-00A0C9062910}
GUID RegChangeNotificationGuid =
{ 0x4ee0b301, 0x94bc, 0x11d0, { 0xa4, 0xec, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } };

extern HANDLE WmipKMHandle;

#ifdef MEMPHIS
ULONG WmipRpcServerInitialize(
    void
    )
/*++

Routine Description:

    Initialize access to the RPC server that provides support from the
    WMI service

Arguments:


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;

    Status = RpcServerUseProtseqEp(WmiServiceRpcProtocolSequence,
                                   MaxRpcCalls,
                                   WmiServiceRpcEndpoint,
                                   NULL
                                   );

    if (Status == ERROR_SUCCESS)
    {
        Status = RpcServerRegisterIfEx(wmicore_ServerIfHandle,
                                 NULL,
                                 NULL,
                                 0,
                                 MaxRpcCalls,
                                 NULL);

        if (Status == ERROR_SUCCESS)
        {
            Status = RpcServerListen(MinRpcCalls,
                                     MaxRpcCalls,
                                     TRUE);
            if (Status != ERROR_SUCCESS)
            {
                RpcServerUnregisterIf(wmicore_ServerIfHandle, NULL, TRUE);
            }
        }
    }

    return(Status);
}

void WmipRpcServerDeinitialize(
    void
    )
/*++

Routine Description:

    Initialize access to the RPC server that provides support from the
    WMI service

Arguments:


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;

    Status = RpcServerUnregisterIf(wmicore_ServerIfHandle,
                                   NULL,
                                   TRUE);
}
#endif

#ifndef MEMPHIS
BOOLEAN
WmipIsRpcClientLocal(
    PVOID Context
    )
{
    ULONG IsLocal = 0;
    ULONG Status;

    Status = I_RpcBindingIsClientLocal(Context,
                                        &IsLocal);
                                    
    if ((Status != RPC_S_OK) ||
        (IsLocal == 0))
    {
        WmipDebugPrint(("WMI: Incoming remote service call received\n"));
        return(FALSE);
    }
    
    return(TRUE);
}
#endif

ULONG WmipGetInstanceInfo(
    IN PBINSTANCESET InstanceSet,
    OUT PWMIINSTANCEINFO Info
)
/*++

Routine Description:

    Build a WMIINSTANCEINFO structure from information in the INSTANCESET.
    This routine assumes that any synchronization of InstanceSet is done
    outsize of the routine.

Arguments:

    InstanceSet is the set of instances for which we are building the
        WMIINSTANCEINFO

    Info returns with a completed WMIINSTAMNCEINFO structure

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    PBDATASOURCE DataSource = InstanceSet->DataSource;
    ULONG j;
    PBINSTANCESET InstanceSetRef;
    PBISSTATICNAMES IsStaticNames = InstanceSet->IsStaticNames;
    ULONG Flags;
    ULONG Status = ERROR_SUCCESS;

    Info->BaseName = NULL;
    Info->StaticNamePtr = NULL;

    Flags = InstanceSet->Flags;

    //
    // Can't have both an instance base name and a static instance name list
    WmipAssert( (Flags & (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES)) !=
                         (IS_INSTANCE_BASENAME | IS_INSTANCE_STATICNAMES));

    //
    // Can't be both a kernel mode and user mode provider
    WmipAssert( (Flags & (IS_KM_PROVIDER | IS_UM_PROVIDER)) !=
                         (IS_KM_PROVIDER | IS_UM_PROVIDER))

    WmipAssert( (Flags & (IS_KM_PROVIDER | IS_SM_PROVIDER)) !=
                         (IS_KM_PROVIDER | IS_SM_PROVIDER))

    //
    // Copy BaseName info into Info->IsBaseName
    if (Flags & IS_INSTANCE_BASENAME)
    {
        Info->BaseIndex = InstanceSet->IsBaseName->BaseIndex;
        Info->BaseName = InstanceSet->IsBaseName->BaseName;

    //
    // Copy static instance names into Info
    } else if (Flags & IS_INSTANCE_STATICNAMES) {

        Info->StaticNamePtr = IsStaticNames->StaticNamePtr;
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // This is OK to cast this down from ULONG_PTR to ULONG. Only 
        // provider ids for Kernel mode drivers are important to the 
        // data consumer side and these are only 32 bits
        Info->ProviderId = (ULONG)DataSource->ProviderId;

        Info->Flags = Flags;
        Info->InstanceCount = InstanceSet->Count;

        Info->InstanceNameSize = 0;

        if (DataSource->BindingString != NULL)
        {
            Info->Flags |= IS_UM_PROVIDER;
        } else if (Info->ProviderId == INTERNAL_PROVIDER_ID) {
            Info->Flags |= IS_INTERNAL_PROVIDER;
        } else {
            Info->Flags |= IS_KM_PROVIDER;
        }
    }
    return(Status);
}

GUID GuidNull  =  NULL_GUID;

ULONG GetGuidInfo(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ LPGUID Guid,
    /* [out] */ ULONG __RPC_FAR *InstanceCount,
    /* [size_is][size_is][out] */ PWMIINSTANCEINFO __RPC_FAR *InstanceInfo,
    /* [in] */ BOOLEAN EnableCollection
    )
/*++

Routine Description:

    Obtain information about the instances available for a particular guid.
    If any of the data providers require a collection enable request to
    start data collection this routine will send it.

Arguments:

    Guid is the guid of interest
    *InstanceCount returns the count of data sources that implement the
        guid.
    *InstanceInfo returns an array of WMIINSTANCEINFO structures
    EnableCollection is TRUE then Collection requests will be forwarded to
        the data providers.


Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    PBGUIDENTRY GuidEntry;
    ULONG Count, i;
    PLIST_ENTRY InstanceSetList;
    PWMIINSTANCEINFO Info;
    PBINSTANCESET InstanceSet;
    ULONG Status;
    BOOLEAN Collecting;
#if DBG
    TCHAR s[MAX_PATH];
#endif

    WmipAssert(WmipValidateGuid(Guid));

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }

    if (IsEqualGUID(Guid, &GuidNull))
    {
        //
        // Request is for all unique WMIREGINFOs that are registered
        return(ERROR_WMI_GUID_NOT_FOUND);
    } else {
        //
        // See if the specific guid is registered at all
        GuidEntry = WmipFindGEByGuid(Guid, FALSE);
        if (GuidEntry == NULL)
        {
            return(ERROR_WMI_GUID_NOT_FOUND);
        }

        if (GuidEntry->Flags & GE_FLAG_INTERNAL)
        {
            WmipUnreferenceGE(GuidEntry);
            return(ERROR_WMI_GUID_NOT_FOUND);
        }


        //
        // We lock the registration information while picking out the 
        // information so that any changes that occur while this is in 
        // progress will notaffect us
        WmipEnterSMCritSection();

        Count = GuidEntry->ISCount;
        WmipAssert(Count != 0);

        //
        // We use MIDL to allocate the memory for us so that rpc can 
        // free it once the buffer has been transmitted back to the caller
        Info = midl_user_allocate(Count * sizeof(WMIINSTANCEINFO));
        if (Info == NULL)
        {
            WmipLeaveSMCritSection();
            WmipUnreferenceGE(GuidEntry);
            WmipDebugPrint(("WMI: Couldn't alloc memory for WMIINSTANCEINFO\n"));
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Loop over all instance sets and extract the instance name information
        // making sure that we don't overwrite if we have too many
        i = 0;
        InstanceSetList = GuidEntry->ISHead.Flink;
        Collecting = FALSE;
        while ((InstanceSetList != &GuidEntry->ISHead) && (i < Count))
        {
            WmipAssert(i < Count);
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);

            if ( ! ((InstanceSet->Flags & IS_TRACED) ||
                    ((InstanceSet->Flags & IS_EVENT_ONLY) && EnableCollection)))
            {
                //
                // Only those guids not Traced guids, event only guids
                // and unresolved references are not available for queries
                WmipGetInstanceInfo(InstanceSet, &Info[i]);
                Collecting = (Collecting || (InstanceSet->Flags & IS_EXPENSIVE));
                i++;
            }
            InstanceSetList = InstanceSetList->Flink;
        }

        WmipLeaveSMCritSection();

        if (i == 0)
        {
            //
            // If there are no guids available for querying then we can free
            // the buffers and return an error
            midl_user_free(Info);
            Info = NULL;
            Status = ERROR_WMI_GUID_NOT_FOUND;
        } else {
            if (i != Count)
            {
                //
                // if the actual number of InstanceSets does not match the number
                // stored in the guid entry then only return the actual number.
                // There probably was a traced guid
                Count = i;
                }

            if (EnableCollection && Collecting)
            {

                Status = CollectionControl(DcCtxHandle,
                                   Guid,
                                   TRUE);
            } else {
                Status = ERROR_SUCCESS;
            }
        }

        WmipUnreferenceGE(GuidEntry);
    }

    *InstanceInfo = Info;
    *InstanceCount = Count;
    return(Status);
}


ULONG ReleaseGuidInfo(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ LPGUID Guid
    )
/*++

Routine Description:

    Called when a data consumer is no longer querying a data block. This
    routine will send any collection disable requests if needed.

Arguments:

    Guid is the guid of interest

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    PBGUIDENTRY GuidEntry;
    ULONG i;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    ULONG Status;
    BOOLEAN Collecting;

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }
    
    if (! WmipValidateGuid(Guid))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // See if the guid is registered at all
    GuidEntry = WmipFindGEByGuid(Guid, FALSE);
    if (GuidEntry == NULL)
    {
        return(ERROR_WMI_GUID_NOT_FOUND);
    }

    //
    // We lock the registration information while picking out the information
    // so that any changes that occur while this is in progress will not
    // affect us
    WmipEnterSMCritSection();

    InstanceSetList = GuidEntry->ISHead.Flink;
    Collecting = FALSE;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        //
        // Loop over all instance sets to determine if any are expensive
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);

        if (InstanceSet->Flags & IS_EXPENSIVE)
        {
            WmipLeaveSMCritSection();
            //
            // One of the instances is expensive so disable collection
            Status = CollectionControl(DcCtxHandle,
                                       Guid,
                                       FALSE);
            WmipEnterSMCritSection();
            break;
        }

        InstanceSetList = InstanceSetList->Flink;
    }

    WmipLeaveSMCritSection();
    WmipUnreferenceGE(GuidEntry);

    return(ERROR_SUCCESS);
}

#ifndef MEMPHIS
#if 0
void WmipShowPrivs(
    HANDLE TokenHandle
    )
{
    PTOKEN_PRIVILEGES TokenPrivInfo;
    UCHAR Buffer[4096];
    BOOLEAN b;
    ULONG SizeNeeded;
    ULONG i;
       
    TokenPrivInfo = (PTOKEN_PRIVILEGES)Buffer;
    b = GetTokenInformation(TokenHandle,
                            TokenPrivileges,
                            TokenPrivInfo,
                            sizeof(Buffer),
                            &SizeNeeded);
    if (b)
    {
        WmipDebugPrint(("Priv count is %d\n", TokenPrivInfo->PrivilegeCount));
        for (i = 0; i < TokenPrivInfo->PrivilegeCount; i++)
        {
            WmipDebugPrint(("Priv %x%x has attr %x\n",
                   TokenPrivInfo->Privileges[i].Luid.HighPart,
                   TokenPrivInfo->Privileges[i].Luid.LowPart,
                   TokenPrivInfo->Privileges[i].Attributes));
        }
        WmipDebugPrint(("\n"));
    }
}
#endif

ULONG WmipCreateRestrictedToken(
    HANDLE *RestrictedTokenHandle
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    HANDLE TokenHandle;
    ULONG Status;
    
    if (OpenProcessToken(GetCurrentProcess(),
                    TOKEN_ALL_ACCESS,
                    &TokenHandle))
    {        
        if (DuplicateTokenEx(TokenHandle,
                           TOKEN_ALL_ACCESS,
                           NULL,
                           SecurityImpersonation,
                           TokenImpersonation,
                           RestrictedTokenHandle))
        {                        
            if (AdjustTokenPrivileges(*RestrictedTokenHandle,
                                          TRUE,
                                          NULL,
                                          0,
                                          NULL,
                                          0))
            {
                Status = ERROR_SUCCESS;
            } else {
                Status = GetLastError();
                CloseHandle(*RestrictedTokenHandle);
                *RestrictedTokenHandle = NULL;
            }                
        }
          
        CloseHandle(TokenHandle);

    } else {
        Status = GetLastError();
    }
    
    WmipAssert(Status == ERROR_SUCCESS);
    return(Status);
}


ULONG WmipRestrictToken(
    HANDLE RestrictedToken
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    ULONG Status;
    
    if (SetThreadToken(NULL, RestrictedToken))
    { 
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }
    
    WmipAssert(Status == ERROR_SUCCESS);
    return(Status);
}

ULONG WmipUnrestrictToken(
    void
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    ULONG Status;
    
    if (RevertToSelf())
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }

#if 0
    {
        HANDLE TokenHandle;
    
        if (ImpersonateSelf(SecurityImpersonation))
        {
            if (OpenThreadToken(GetCurrentThread(),
                    TOKEN_ALL_ACCESS,
                    TRUE,
                    &TokenHandle))
            {
                WmipDebugPrint(("WMI: After reversion:\n"));
                WmipShowPrivs(TokenHandle);
            }
        }
    }
#endif        
    WmipAssert(Status == ERROR_SUCCESS);
    return(Status);
}
#endif

#ifdef MEMPHIS
ULONG WmipBindToWmiClient(
    TCHAR *BindingString,
    RPC_BINDING_HANDLE *BindingHandle
    )
{
    ULONG Status;
    
    if (*BindingString != 0)
    {
        Status = RpcBindingFromStringBinding(BindingString,
                                             BindingHandle);
        if (Status == ERROR_SUCCESS)
        {
            WmipAssert(*BindingHandle != 0);
        }
    } else {
        WmipDebugPrint(("WMI: Invalid binding string %ws\n", BindingString));
        Status = ERROR_INVALID_PARAMETER;
    }
    return(Status);
}
#else
ULONG WmipBindToWmiClient(
    TCHAR *BindingString,
    RPC_BINDING_HANDLE *BindingHandle
    )
/*++

Routine Description:

    This routine will cause a binding to the WMI server in a data consumer
    or data provider. We need to setup identification impersonation, Dynamic
    tracking and effective only security. This means that the server will
    only get to see our access token (not use it), the rpc code will send
    over the token at the time of the call not when it first recorded it,
    and the token sent over will not include any privs that were disabled
    when the call is made.

Arguments:

    BindingString is the string binding for the server
        
    *BindingHandle returns with the RPC binding handle

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    ULONG Status;
    TCHAR *ObjectUuid;
    TCHAR *ProtSeq;
    TCHAR *NetworkAddr;
    TCHAR *EndPoint;
    TCHAR *NetworkOptions;
    TCHAR *SecureBindingString;
#define SecureNetworkOption TEXT("Security=Identification Static True")

    if (*BindingString != 0)
    {        
        
        Status = RpcStringBindingParse(BindingString,
                                           &ObjectUuid,
                                           &ProtSeq,
                                           &NetworkAddr,
                                           &EndPoint,
                                           &NetworkOptions);
        if (Status == ERROR_SUCCESS)
        {
            Status = RpcStringBindingCompose(ObjectUuid,
                                         ProtSeq,
                                         NetworkAddr,
                                         EndPoint,
                                         SecureNetworkOption,
                                         &SecureBindingString);
          
            if (Status == ERROR_SUCCESS)
            {
                WmipDebugPrint(("WMI: SecureBindingString %ws\n", 
                                     SecureBindingString));
                            
                Status = RpcBindingFromStringBinding(SecureBindingString,
                                                     BindingHandle);
                RpcStringFree(&SecureBindingString);
                if (Status == ERROR_SUCCESS)
                {
                    WmipAssert(*BindingHandle != 0);
        
                }
            }
            
            RpcStringFree(&ObjectUuid);
            RpcStringFree(&ProtSeq);
            RpcStringFree(&NetworkAddr);
            RpcStringFree(&EndPoint);
            RpcStringFree(&NetworkOptions);                        
            
        } else {
            WmipDebugPrint(("WMI: Invalid binding string (%d) %ws\n", 
                                Status, *BindingString));
        }
    } else {
        WmipDebugPrint(("WMI: Invalid binding string %ws\n", BindingString));
        Status = ERROR_INVALID_PARAMETER;
    }

    return(Status);
}
#endif    

ULONG RegisterDataConsumer(
    /* [out] */ DCCTXHANDLE *DcCtxHandle,
    /* [in, string] */ TCHAR *RpcBindingString
    )
/*++

Routine Description:

    This routine manages the registration of a data consumer's notification
    sinks. All notification sinks receive all internal (registration change)
    and those external (data provider fired) events for which the data
    consumer had registered for. Typically a data consumer will
    register its notification sink as soon as a guid is accesssed or an
    event enabled. The context handle will track the events and collections
    enabled by this data consumer so if the data consumer disappears cleanup
    can be handled by the rundown routine.

Arguments:

    *DcCtxHandle returns the data consumer context handle

    RpcBindingString is the binding string if notifications are sinked via RPC.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PDCENTRY DataConsumer;
    ULONG Status;

#ifndef MEMPHIS
    if (! WmipIsRpcClientLocal(NULL))
    {
        *DcCtxHandle = NULL;
        return(ERROR_ACCESS_DENIED);
    }
#endif

    DataConsumer = WmipAllocDataConsumer();

    if (DataConsumer != NULL)
    {
        Status = WmipBindToWmiClient(RpcBindingString,
                                     &DataConsumer->RpcBindingHandle);
                                
        
        if (Status == ERROR_SUCCESS)
        {
#if DBG
            TCHAR *SavedBindingString;
    
            SavedBindingString = WmipAlloc((_tcslen(RpcBindingString)+1) * 
                                           sizeof(TCHAR));
            if (SavedBindingString != NULL)
            {
                _tcscpy(SavedBindingString, RpcBindingString);
            }
            DataConsumer->BindingString = SavedBindingString;
#endif
            WmipEnterSMCritSection();
            InsertTailList(DCHeadPtr, &DataConsumer->MainDCList);
            WmipLeaveSMCritSection();                        
            
            *DcCtxHandle = (DCCTXHANDLE)DataConsumer;
        } else {
            DataConsumer->Flags |= DC_FLAG_RUNDOWN;        
            WmipUnreferenceDC(DataConsumer);
            *DcCtxHandle = NULL;
        }
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        *DcCtxHandle = NULL;
    }

    return(Status);
}

ULONG UnregisterDataConsumer(
    /* [in, out] */ DCCTXHANDLE *DcCtxHandle,
    /* [out] */ BOOLEAN *NotificationsEnabled,
    /* [out] */ BOOLEAN *CollectionsEnabled
    )
/*++

Routine Description:

    This routine unregisters a data consumer. The data consumer will not
    longer receive any notifications. Any notifications or collections that
    have been enabled by this data consumer will be disabled.

Arguments:

    *DcCtxHandle is the data consumer context handle to unregister

    *NotificationsEnabled returns TRUE if the data consumer had left any
        notifications enabled on debug builds. On Free builds it always
        returns FALSE.

    *CollectionsEnabled returns TRUE if the data consumer had left any
        collections enabled on debug builds. On Free builds it always
        returns FALSE.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    ULONG Status;

    if (! VERIFY_DCCTXHANDLE(*DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", *DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }
    
    Status = WmipCleanupDataConsumer( (PDCENTRY)*DcCtxHandle
#if DBG
                                      ,NotificationsEnabled,
                                      CollectionsEnabled
#endif
                                      );
    if (Status == ERROR_SUCCESS)
    {
        *DcCtxHandle = NULL;
    }
    return(Status);
}

ULONG IoctlActionCode[WmiExecuteMethodCall+1] =
{
    IOCTL_WMI_QUERY_ALL_DATA,
    IOCTL_WMI_QUERY_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_INSTANCE,
    IOCTL_WMI_SET_SINGLE_ITEM,
    IOCTL_WMI_ENABLE_EVENT,
    IOCTL_WMI_DISABLE_EVENT,
    IOCTL_WMI_ENABLE_COLLECTION,
    IOCTL_WMI_DISABLE_COLLECTION,
    IOCTL_WMI_GET_REGINFO,
    IOCTL_WMI_EXECUTE_METHOD
};


ULONG WmipDeliverWnodeToDS(
    ULONG ActionCode,
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode
)
{
    ULONG Ioctl;
    ULONG Status;
    ULONG RetSize;
    OVERLAPPED Overlapped;
    BOOL IoctlSuccess;
    ULONG Size = Wnode->BufferSize;

    //
    // Only the lower 32 bits of the provider id is significant for 
    // kernel mode providers
    Wnode->ProviderId = (ULONG)DataSource->ProviderId;

    if (DataSource->Flags & DS_KERNEL_MODE)
    {
        WmipAssert(WmipKMHandle != (PVOID)-1);

        Overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (Overlapped.hEvent != NULL)
        {
             Ioctl = IoctlActionCode[ActionCode];
             IoctlSuccess = DeviceIoControl(WmipKMHandle,
                                Ioctl,
                                (PBYTE)Wnode,
                                Size,
                                (PBYTE)Wnode,
                                Size,
                                &RetSize,
                                &Overlapped);

            if (GetLastError() == ERROR_IO_PENDING)
            {
                IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                                   &Overlapped,
                                                   &RetSize,
                                                   TRUE);
              }

            if (IoctlSuccess)
            {
                Status = ERROR_SUCCESS;
            } else {
                Status = GetLastError();
            }
            CloseHandle(Overlapped.hEvent);
        }
    } else {
        //
        // Provider is a user mode app
        Status = WmipRestrictToken(WmipRestrictedToken);
        if (Status == ERROR_SUCCESS)
        {
            try
            {
                //
                // In general WMI service only sends Enable/Disable requests
                // which dont have ansi/unicode requirements
                Status = WmipClient_ServiceRequest(
                                    DataSource->RpcBindingHandle,
                                    DataSource->RequestAddress,
                                    DataSource->RequestContext,
                                    ActionCode,
                                    Size,
                                    &Size,
                                    (PBYTE)Wnode,
                                    0
                                    );

            } except(EXCEPTION_EXECUTE_HANDLER) {
#if DBG
                Status = GetExceptionCode();
                WmipDebugPrint(("WMI: ServiceRquest thew exception %d\n",
                                     Status));
#endif
                Status = ERROR_WMI_DP_FAILED;
            }
            WmipUnrestrictToken();
        }
    }
    return(Status);
}


ULONG WmipSendEnableDisableRequest(
    ULONG ActionCode,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++

Routine Description:

    This routine will deliver an event or collection WNODE to all data
    providers of a guid. This routine assumes that it is called with the
    SM critical section held. The routine does not hold the critical
    section for the duration of the call.

Arguments:

    ActionCode is WMI_ENABLE_EVENTS, WMI_DISABLE_EVENTS,
        WMI_ENABLE_COLLECTION or WMI_DISABLE_COLLECTION

    GuidEntry is the guid entry for the guid that is being enabled/disable
        or collected/stop collected

    IsEvent is TRUE then ActionCode is to enable or disable events.
        If FALSE then ActionCode is to enable or disbale collecton

    IsTraceLog is TRUE then enable is only sent to those guids registered as
        being a tracelog guid

    LoggerContext is a logger context handle that should be placed in the
        HistoricalContext field of the WNODE_HEADER if IsTraceLog is TRUE.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
#if DBG
#define AVGISPERGUID 1
#else
#define AVGISPERGUID 64
#endif

    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSourceArray[AVGISPERGUID];
    PBDATASOURCE *DataSourceList;
    ULONG Size;
    ULONG Status;
    WNODE_HEADER Wnode;
    ULONG i;
    PBDATASOURCE DataSource;
    ULONG DSCount;
    BOOLEAN IsEnable;
    ULONG IsFlags;


    if ((GuidEntry == NULL) || (GuidEntry->Flags & GE_FLAG_INTERNAL))
    {
        //
        // Guids that have been unregistered and Internally defined guids
        // have no data source to send requests to, so just leave happily
        return(ERROR_SUCCESS);
    }

    IsEnable = ((ActionCode == WMI_ENABLE_EVENTS) ||
                (ActionCode == WMI_ENABLE_COLLECTION));
    IsFlags = IsEvent ? IS_ENABLE_EVENT : IS_ENABLE_COLLECTION;

    //
    // First we make a list of all of the DataSources that need to be called
    // while we have the critical section and take a reference on them so
    // they don't go away after we release them. Note that the DataSource
    // structure will stay, but the actual data provider may in fact go away.
    // In this case sending the request will fail.
    DSCount = 0;

    if (GuidEntry->ISCount > AVGISPERGUID)
    {
        DataSourceList = WmipAlloc(GuidEntry->ISCount * sizeof(PBDATASOURCE));
        if (DataSourceList == NULL)
        {
            WmipDebugPrint(("WMI: alloc failed for DataSource array in WmipSendEnableDisableRequest\n"));
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        DataSourceList = &DataSourceArray[0];
    }
#if DBG
    memset(DataSourceList, 0, GuidEntry->ISCount * sizeof(PBDATASOURCE));
#endif

    InstanceSetList = GuidEntry->ISHead.Flink;
    while ((InstanceSetList != &GuidEntry->ISHead) &&
           (DSCount < GuidEntry->ISCount))
    {
        WmipAssert(DSCount < GuidEntry->ISCount);
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);

        //
        // We send requests to those data providers that are not inprocs when
        // it is an event being enabled or it is collection being enabled
        // and they are defined to be expensive (collection needs to be
        // enabled)
        if (
             ( (IsTraceLog && (InstanceSet->Flags & IS_TRACED)) ||
               ( ! IsTraceLog && (! (InstanceSet->Flags & IS_TRACED)) &&
                 (IsEvent || (InstanceSet->Flags & IS_EXPENSIVE))
               )
             )
           )
        {
            if ( (! IsEnable && (InstanceSet->Flags & IsFlags)) ||
                 (IsEnable && ! (InstanceSet->Flags & IsFlags)) )
            {
                DataSourceList[DSCount] = InstanceSet->DataSource;
                WmipReferenceDS(DataSourceList[DSCount]);
                DSCount++;
            }

            if (IsEnable)
            {
                InstanceSet->Flags |= IsFlags;
            } else {
                InstanceSet->Flags &= ~IsFlags;
            }
        }

        InstanceSetList = InstanceSetList->Flink;
    }

    WmipLeaveSMCritSection();

    //
    // Now without the critical section we send the request to all of the
    // data providers. Any new data providers who register after we made our
    // list will be enabled by the registration code.
    if (DSCount > 0)
    {
        memset(&Wnode, 0, sizeof(WNODE_HEADER));
        memcpy(&Wnode.Guid, &GuidEntry->Guid, sizeof(GUID));
        Wnode.BufferSize = sizeof(WNODE_HEADER);
        if (IsTraceLog)
        {
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
        }

        for (i = 0; i < DSCount; i++)
        {
            DataSource = DataSourceList[i];
            WmipAssert(DataSource != NULL);

            WmipDeliverWnodeToDS(ActionCode, DataSource, &Wnode);

            WmipUnreferenceDS(DataSource);
        }
    }

    Status = ERROR_SUCCESS;

    if (DataSourceList != DataSourceArray)
    {
        WmipFree(DataSourceList);
    }

    WmipEnterSMCritSection();

    return(Status);
}

void WmipReleaseCollectionEnabled(
    PNOTIFICATIONENTRY NotificationEntry
    )
{
    WmipAssert(NotificationEntry->CollectInProgress != NULL);
    
    WmipDebugPrint(("WMI: %x enable releasning %p %x event %p\n",
                                 GetCurrentThreadId(),
                                     NotificationEntry,
                                     NotificationEntry->Flags,
                                 NotificationEntry->CollectInProgress));
    SetEvent(NotificationEntry->CollectInProgress);
    CloseHandle(NotificationEntry->CollectInProgress);
    NotificationEntry->CollectInProgress = NULL;
}

void WmipWaitForCollectionEnabled(
    PNOTIFICATIONENTRY NotificationEntry
    )
{
    WmipAssert((NotificationEntry->Flags & NE_FLAG_COLLECTION_IN_PROGRESS) ==
                   NE_FLAG_COLLECTION_IN_PROGRESS);
    
    //
    // Collection Enable/Disable is in progress so
    // we cannot return just yet. Right now there could be a 
    // disable request being processed and if we didn't wait, we
    // might get back to this caller before that disable request
    // got around to realizing that it needs to send and enable 
    // request (needed by this thread's caller). So we'd have a 
    // situation where a thread though that collection was enabled
    // but in reality it wasn't yet enabled.
    if (NotificationEntry->CollectInProgress == NULL)
    {
        NotificationEntry->CollectInProgress = CreateEvent(NULL,
                                                                   TRUE,
                                                                   FALSE,
                                                                   NULL);
        WmipDebugPrint(("WMI: %x for %p %x created event %p\n",
                                 GetCurrentThreadId(),
                                 NotificationEntry,
                                 NotificationEntry->Flags,
                                 NotificationEntry->CollectInProgress));
    }
            
    WmipLeaveSMCritSection();
    WmipDebugPrint(("WMI: %x waiting for %p %x on event %p\n",
                                 GetCurrentThreadId(),
                                     NotificationEntry,
                                     NotificationEntry->Flags,
                                 NotificationEntry->CollectInProgress));
    WaitForSingleObject(NotificationEntry->CollectInProgress, 
                                INFINITE);
    WmipDebugPrint(("WMI: %x done %p %x waiting on event %p\n",
                                 GetCurrentThreadId(),
                                     NotificationEntry,
                                     NotificationEntry->Flags,
                                 NotificationEntry->CollectInProgress));
    WmipEnterSMCritSection();
    
}

ULONG WmipSendEnableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an enable collection or notification request to
    all of the data providers that have registered the guid being enabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 0 to 1 then the enable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the enable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the enable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is greater than 0 and then send the enable
    request.


Arguments:

    NotificationEntry is the Notification entry that describes the guid
        being enabled.

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    if (IsEvent)
    {
        InProgressFlag = NE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = NotificationEntry->EventRefCount++;
    } else {
        InProgressFlag = NE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = NotificationEntry->CollectRefCount++;
        WmipDebugPrint(("WMI: %p enable collect for %p %x\n",
                  GetCurrentThreadId(),
                  NotificationEntry, NotificationEntry->Flags ));
    }

    //
    // If the guid is transitioning from a refcount of 0 to 1 and there
    // is not currently a request in progress, then we need to set the
    // request in progress flag, release the critical section and
    // send an enable request. If there is a request in progress we can't
    // do another request. Whenever the current request finishes  it
    // will notice the ref count change and send the enable request on
    // our behalf.
    if ((RefCount == 0) &&
        ! (NotificationEntry->Flags & InProgressFlag))
    {
        //
        // Take an extra ref count so that even if this gets disabled
        // while the enable request is in progress the NotificationEntry
        // will stay valid.
        WmipReferenceNE(NotificationEntry);
        NotificationEntry->Flags |= InProgressFlag;
        WmipDebugPrint(("WMI: %p NE %p flags -> %x at %d\n",
                  GetCurrentThreadId(),
                  NotificationEntry,
                  NotificationEntry->Flags,
                  __LINE__));

EnableNotification:
        Status = WmipSendEnableDisableRequest(IsEvent ?
                                                WMI_ENABLE_EVENTS :
                                                WMI_ENABLE_COLLECTION,
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

       RefCount = IsEvent ? NotificationEntry->EventRefCount :
                            NotificationEntry->CollectRefCount;

       if (RefCount == 0)
       {
           // This is the bogus situation we were worried about. While
           // the enable request was being processed the notification
           // was disabled. So leave the in progress flag set and
           // send the disable.

           Status = WmipSendEnableDisableRequest(IsEvent ?
                                                    WMI_DISABLE_EVENTS :
                                                    WMI_DISABLE_COLLECTION,
                                                 GuidEntry,
                                                 IsEvent,
                                                 IsTraceLog,
                                                 LoggerContext);

            RefCount = IsEvent ? NotificationEntry->EventRefCount :
                                 NotificationEntry->CollectRefCount;

            if (RefCount > 0)
            {
                //
                // We have hit a pathological case. One thread called to
                // enable and while the enable request was being processed
                // another thread called to disable, but was postponed
                // since the enable was in progress. So once the enable
                // completed we realized that the ref count reached 0 and
                // so we need to disable and sent the disable request.
                // But while the disable request was being processed
                // an enable request came in so now we need to enable
                // the notification. Sheesh.
                goto EnableNotification;
            }
        }
        NotificationEntry->Flags &= ~InProgressFlag;
        WmipDebugPrint(("WMI: %p NE %p flags -> %x at %d\n",
                  GetCurrentThreadId(),
                  NotificationEntry,
                  NotificationEntry->Flags,
                  __LINE__));
        
        //
        // If there are any other threads that were waiting until all of 
        // the enable/disable work completed, we close the event handle
        // to release them from their wait.
        //
        if ((! IsEvent) && (NotificationEntry->CollectInProgress != NULL))
        {            
            WmipReleaseCollectionEnabled(NotificationEntry);
        }

        //
        // Get rid of extra ref count we took above. Note that the
        // NotificationEntry could be going away here if there was a
        // disable while the enable was in progress.
        WmipUnreferenceNE(NotificationEntry);

    } else {
        if ((! IsEvent) && (NotificationEntry->Flags & InProgressFlag))
        {
            WmipDebugPrint(("WMI: %x going to wait for %p %x at %d\n",
                                          GetCurrentThreadId(),
                                          NotificationEntry,
                                          NotificationEntry->Flags,
                                          __LINE__));
            WmipWaitForCollectionEnabled(NotificationEntry);
            WmipDebugPrint(("WMI: %x done to wait for %p %x at %d\n",
                                          GetCurrentThreadId(),
                                          NotificationEntry,
                                          NotificationEntry->Flags,
                                          __LINE__));
            
        }
        
        Status = ERROR_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrint(("WMI: %p enable collect done for %p %x\n",
                  GetCurrentThreadId(),
                  NotificationEntry,
                  NotificationEntry->Flags));
    }

    return(Status);
}

ULONG WmipDoDisableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    )
{
    ULONG RefCount;
    ULONG Status;

DisableNotification:
    Status = WmipSendEnableDisableRequest(IsEvent ?
                                            WMI_DISABLE_EVENTS :
                                            WMI_DISABLE_COLLECTION,
                                          GuidEntry,
                                          IsEvent,
                                          IsTraceLog,
                                          LoggerContext);

    RefCount = IsEvent ? NotificationEntry->EventRefCount :
                         NotificationEntry->CollectRefCount;

    if (RefCount > 0)
    {
        //
        // While we were processing the disable request an
        // enable request arrived. Since the in progress
        // flag was set the enable request was not sent
        // so now we need to do that.

        Status = WmipSendEnableDisableRequest(IsEvent ?
                                                 WMI_ENABLE_EVENTS :
                                                 WMI_ENABLE_COLLECTION,
                                              GuidEntry,
                                              IsEvent,
                                              IsTraceLog,
                                              LoggerContext);

        RefCount = IsEvent ? NotificationEntry->EventRefCount:
                             NotificationEntry->CollectRefCount;

        if (RefCount == 0)
        {
            //
            // While processing the enable request above the
            // notification was disabled and since a request
            // was in progress the disable request was not
            // forwarded. Now it is time to forward the
            // request.
            goto DisableNotification;
        }
    }
    NotificationEntry->Flags &= ~InProgressFlag;
    WmipDebugPrint(("WMI: %p NE %p flags -> %x at %d\n",
                  GetCurrentThreadId(),
                  NotificationEntry,
                  NotificationEntry->Flags,
                  __LINE__));
    
    //
       // If there are any other threads that were waiting until all of 
    // the enable/disable work completed, we close the event handle
    // to release them from their wait.
    //
    if ((! IsEvent) && (NotificationEntry->CollectInProgress != NULL))
    {
        WmipReleaseCollectionEnabled(NotificationEntry);
    }
    
    return(Status);
}

ULONG WmipSendDisableRequest(
    PNOTIFICATIONENTRY NotificationEntry,
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext
    )
/*++
Routine Description:

    This routine will send an disable collection or notification request to
    all of the data providers that have registered the guid being disabled.
    This routine will manage any race conditions that might occur when
    multiple threads are enabling and disabling the notification
    simultaneously.

    This routine is called while the SM critical section is being held and
    will increment the appropriate reference count. if the ref count
    transitions from 1 to 0 then the disable request will need to be forwarded
    to the data providers otherwise the routine is all done and returns.
    Before sending the disable request the routine checks to see if any
    enable or disable requests are currently in progress and if not then sets
    the in progress flag, releases the critical section and sends the disable
    request. If there was a request in progress then the routine does not
    send a request, but just returns. When the other thread that was sending
    the request returns from processing the request it will recheck the
    refcount and notice that it is  0 and then send the disable
    request.


Arguments:

    NotificationEntry is the Notification entry that describes the guid
        being enabled.

    GuidEntry is the guid entry that describes the guid being enabled. For
        a notification it may be NULL.

    NotificationContext is the notification context to use if enabling events

    IsEvent is TRUE if notifications are being enables else FALSE if
        collection is being enabled

    IsTraceLog is TRUE if enable is for a trace log guid

    LoggerContext is a context value to forward in the enable request

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG InProgressFlag;
    ULONG RefCount;
    ULONG Status;

    if (IsEvent)
    {
        InProgressFlag = NE_FLAG_NOTIFICATION_IN_PROGRESS;
        RefCount = NotificationEntry->EventRefCount;
        if (RefCount == 0)
        {
            //
            // A bad data consumer is disabling his event more
            // than once. Just ignore it
            return(ERROR_SUCCESS);
        }

        RefCount = --NotificationEntry->EventRefCount;
    } else {
        WmipDebugPrint(("WMI: %x Disabling for %p %x\n",
                                 GetCurrentThreadId(),
                                 NotificationEntry,
                                 NotificationEntry->Flags));
        InProgressFlag = NE_FLAG_COLLECTION_IN_PROGRESS;
        RefCount = --NotificationEntry->CollectRefCount;
        WmipAssert(RefCount != 0xffffffff);
    }

    //
    // If we have transitioned to a refcount of zero and there is
    // not a request in progress then forward the disable request.
    if ((RefCount == 0) &&
        ! (NotificationEntry->Flags & InProgressFlag))
    {

        //
        // Take an extra ref count so that even if this gets
        // disabled while the disable request is in progress the
        // NotificationEntry will stay valid.
        WmipReferenceNE(NotificationEntry);
        NotificationEntry->Flags |= InProgressFlag;
        WmipDebugPrint(("WMI: %p NE %p flags -> %x at %d\n",
                  GetCurrentThreadId(),
                  NotificationEntry,
                  NotificationEntry->Flags,
                  __LINE__));

        Status = WmipDoDisableRequest(NotificationEntry,
                                      GuidEntry,
                                      IsEvent,
                                      IsTraceLog,
                                      LoggerContext,
                                      InProgressFlag);


        //
        // Get rid of extra ref count we took above.
        WmipUnreferenceNE(NotificationEntry);
    } else {
        Status = ERROR_SUCCESS;
    }

    if (! IsEvent)
    {
        WmipDebugPrint(("WMI: %x Disable complete for %p %x\n",
                                 GetCurrentThreadId(),
                                 NotificationEntry,
                                 NotificationEntry->Flags));
    }
    return(Status);
}

ULONG CollectOrEventWorker(
    PDCENTRY DataConsumer,
    LPGUID Guid,
    BOOLEAN Enable,
    BOOLEAN IsEvent,
    ULONG *NotificationCookie,
    ULONG64 LoggerContext,
    ULONG NotificationFlags
    )
/*++
Routine Description:

    This routine manages enabling and disabling events or collections. It
    will update the notification entries and forward requests as appropriate.
    Note that this routine will hold a mutex associated with the notification
    entry around the call to the data provider to enable or disable in order
    to avoid races.

Arguments:

    DataConsumer is the DC that is enabling the event or collection

    Guid specifies the guid to enable or disable

    Enable is TRUE to Enable collection or FALSE to disable collection

    IsEvent is TRUE if events are being enabled/disabled or FALSE if
        collection is being enabled/disabled

    *NotificationCookie on entry has the notification if Enable is TRUE. If
        Enable is FALSE then *NotificationCookie returns with the cookie
        passed when it was enabled.              

    LoggerContext is the logger context to use if enabling trace events

    NotificationFlags can have one of these values
        NOTIFICATION_TRACE_FLAG - enable or disable trace logging
        NOTIFICATION_FLAG_CALLBACK_DIRECT - enable or disable events
                                            for direct callback
        NOTIFICATION_FLAG_CALLBACK_QUEUED - enable or disable events
                                            for queued callback
        NOTIFICATION_WINDOW_HANDLE - enable/disable events for HWND delivery

        DCREF_FLAG_ANSI - Caller is enabling ansi events
Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    PDCREF DcRef, FreeDcRef;
    PNOTIFICATIONENTRY NotificationEntry;
    ULONG Status;
    PBGUIDENTRY GuidEntry;
    ULONG DcRefFlags;
    BOOLEAN IsTraceLog;
    ULONG EventRefCount;
#if DBG
    TCHAR s[MAX_PATH];
#endif

    WmipAssert(DataConsumer->RpcBindingHandle != 0);

    IsTraceLog = ((NotificationFlags & NOTIFICATION_TRACE_FLAG) != 0);

    if (IsEvent)
    {
        DcRefFlags = DCREF_FLAG_NOTIFICATION_ENABLED;
    } else {
        DcRefFlags = DCREF_FLAG_COLLECTION_ENABLED;
    }

    GuidEntry = WmipFindGEByGuid(Guid, FALSE);
    if (IsTraceLog && !WmipIsControlGuid(GuidEntry))
    {
        Status = ERROR_INVALID_OPERATION;
        goto done;
    }

    WmipEnterSMCritSection();
    NotificationEntry = WmipFindNEByGuid(Guid, FALSE);

    if (Enable)
    {
        if ((GuidEntry == NULL) && (! IsEvent))
        {
            //
            // A guid entry is required in the case of enabling collection
            WmipAssert(FALSE);
            if (NotificationEntry != NULL)
            {
                WmipUnreferenceNE(NotificationEntry);
            }
            WmipLeaveSMCritSection();
            return(ERROR_WMI_GUID_NOT_FOUND);
        }

        if (NotificationEntry == NULL)
        {
            //
            // There is no notification entry setup for this yet. Allocate
            // one and add it to the main NE list
            NotificationEntry = WmipAllocNotificationEntry();
            if (NotificationEntry == NULL)
            {
                //
                // Failed to allocate Notification Entry so clean up
                WmipLeaveSMCritSection();
                if (GuidEntry != NULL)
                {
                    WmipUnreferenceGE(GuidEntry);
                }
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            //
            // Initialize Notification Entry and put it on main list
            if (IsTraceLog)
            {
                NotificationEntry->LoggerContext = LoggerContext;
                NotificationEntry->Flags |= NOTIFICATION_TRACE_FLAG;
            }
            memcpy(&NotificationEntry->Guid, Guid, sizeof(GUID));
            InsertTailList(NEHeadPtr,
                           &NotificationEntry->MainNotificationList);
            if (IsTraceLog)
            {
            //
            // No DcRef for trace notification, since we tie it to a logger
            //
                Status = WmipSendEnableRequest(NotificationEntry,
                                       GuidEntry,
                                       IsEvent,
                                       IsTraceLog,
                                       LoggerContext);

                if (GuidEntry != NULL)
                {
                    WmipUnreferenceGE(GuidEntry);
                }
                WmipLeaveSMCritSection();
                return Status;
            }
        }
        else // Notification != NULL
        {
            Status = ERROR_SUCCESS;
            if (IsTraceLog)
            {
                Status = ERROR_WMI_ALREADY_ENABLED;
            }
            else if ((NotificationEntry->Flags & NOTIFICATION_TRACE_FLAG) != 0)
            {   // prevent enabling existing traced Guid as regular event
                Status = ERROR_INVALID_OPERATION;
            }
            
            if (Status != ERROR_SUCCESS)
            {
                //
                // if trace is already enabled for this GUID, not do it again
                //
                WmipUnreferenceNE(NotificationEntry);
                if (GuidEntry != NULL) 
                {
                    WmipUnreferenceGE(GuidEntry);
                }
                WmipLeaveSMCritSection();
                return Status;
            }
        }

        //
        // Now that we have a notification entry fill in the data consumer
        // reference
        DcRef = WmipFindExistingAndFreeDCRefInNE(NotificationEntry,
                                                 DataConsumer,
                                                 &FreeDcRef);
        if (DcRef != NULL)
        {
            if (DcRef->Flags & DcRefFlags)
            {
                if (DcRefFlags & DCREF_FLAG_NOTIFICATION_ENABLED)
                {
                    InterlockedIncrement(&DcRef->EventRefCount);
                } else {
                    //
                    // If a data consumer is enabling collection while
                    // collection is already enabled then increment the
                    // DCEntry refcount, but not the NotificationEntry
                    // refcount. The latter is only changed when the
                    // DCEntry is added or removed. This situation could occur
                    // when many threads in a data consumer are opening
                    // the same guid at the same time.
                    WmipAssert(DcRefFlags & DCREF_FLAG_COLLECTION_ENABLED);
                    DcRef->CollectRefCount++;
                    if (NotificationEntry->Flags & NE_FLAG_COLLECTION_IN_PROGRESS)
                    {
                        WmipDebugPrint(("WMI: %x going to wait for %p %x at %d\n",
                                          GetCurrentThreadId(),
                                          NotificationEntry,
                                          NotificationEntry->Flags,
                                          __LINE__));
                        WmipWaitForCollectionEnabled(NotificationEntry);
                        WmipDebugPrint(("WMI: %x done to wait for %p %x at %d\n",
                                          GetCurrentThreadId(),
                                          NotificationEntry,
                                          NotificationEntry->Flags,
                                          __LINE__));
                    }
                }
        
                Status = ERROR_SUCCESS;
                if (GuidEntry != NULL)
                {
                    WmipUnreferenceGE(GuidEntry);
                }
                WmipUnreferenceNE(NotificationEntry);
                WmipLeaveSMCritSection();
                return(Status);
            }
        } else if (FreeDcRef != NULL) {
            //
            // Data consumer is not referenced in NotificationEntry so
            // initialize a new data consumer reference block
            DcRef = FreeDcRef;
            DcRef->DcEntry = DataConsumer;
	    DcRef->LostEventCount = 0;
        } else {
            //
            // We could not allocate a free DCRef from the notification entry
            if (GuidEntry != NULL)
            {
                WmipUnreferenceGE(GuidEntry);
            }
            WmipUnreferenceNE(NotificationEntry);
            WmipLeaveSMCritSection();
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // We have a DCRef for this so update it by setting the flags
        // bumping the ref count and setting up the notification info
        DcRef->Flags |= DcRefFlags;
        if (IsEvent)
        {
            InterlockedIncrement(&DcRef->EventRefCount);
        } else {
            DcRef->CollectRefCount++;
        }

        //
        // Note WmipSendEnableRequest may not hold critical section through
        // the entire call.
        Status = WmipSendEnableRequest(NotificationEntry,
                                       GuidEntry,
                                       IsEvent,
                                       IsTraceLog,
                                       LoggerContext);

        //
        // We leave a reference on the notification entry to account for
        // the event being enabled or the first time a collection was enabled.
        // The reference will be removed when the event or last collection is
        // disabled.

        WmipLeaveSMCritSection();

    } else {
        //
        // Here is where we process a disable collection request.

        if (NotificationEntry != NULL)
        {
            if (IsTraceLog)
            {
                Status = WmipSendDisableRequest(NotificationEntry,
                                       GuidEntry,
                                       IsEvent,
                                       IsTraceLog,
                                       LoggerContext);

                WmipUnreferenceNE(NotificationEntry);
                WmipAssert(NotificationEntry->RefCount == 1);
                WmipUnreferenceNE(NotificationEntry);
                if (GuidEntry)
                {
                    WmipUnreferenceGE(GuidEntry);
                }
                WmipLeaveSMCritSection();
                return Status;
            }
            DcRef = WmipFindDCRefInNE(NotificationEntry,
                                      DataConsumer);
            if (DcRef != NULL)
            {
                //
                // Make sure we are disabling something that has been
                // previously enabled
                if ((IsEvent &&
                     ! (DcRef->Flags & DCREF_FLAG_NOTIFICATION_ENABLED)) ||
                    ( (! IsEvent) &&
                     ! (DcRef->Flags & DCREF_FLAG_COLLECTION_ENABLED)))
                {
                    WmipLeaveSMCritSection();
                    WmipUnreferenceNE(NotificationEntry);
                    Status = ERROR_WMI_ALREADY_DISABLED;
                    goto done;
                }

                //
                // We found the DCRef which is begin disabled. Clear
                // flags and possibly entire DCRef
                if (! IsEvent)
                {
                    //
                    // Disable collection
                    DcRef->CollectRefCount--;
                    WmipAssert(DcRef->CollectRefCount != (ULONG)-1);
                    if (DcRef->CollectRefCount > 0)
                    {
                        
                        WmipLeaveSMCritSection();
                        WmipUnreferenceNE(NotificationEntry);
                        Status = ERROR_SUCCESS;
                        goto done;
                    }
                    
                    //
                    // We fall through to allow the DCEntry to be cleaned up
                    // since the CollectionRefCount for the DCEntry has
                    // reached 0.
                        
                } else {
                    //
                    // Disable an event
                    EventRefCount = InterlockedDecrement(&DcRef->EventRefCount);
                    WmipAssert(EventRefCount != (ULONG)-1);
                    if (EventRefCount > 0)
                    {
                        WmipLeaveSMCritSection();
                        WmipUnreferenceNE(NotificationEntry);
                        Status = ERROR_SUCCESS;
                        goto done;
                    }
                }
                
                WmipUnreferenceNE(NotificationEntry);
                
                //
                // All cookies for notification completely disabled so send
                // disable events and possibly clean up data structures
                DcRef->Flags &= ~DcRefFlags;

                if ((DcRef->Flags & (DCREF_FLAG_NOTIFICATION_ENABLED |
                                     DCREF_FLAG_COLLECTION_ENABLED)) == 0)
                {
                    DcRef->DcEntry = NULL;
                }

                WmipSendDisableRequest(NotificationEntry,
                                       GuidEntry,
                                       IsEvent,
                                       IsTraceLog,
                                       LoggerContext);

                //
                // We unreference twice: once to account for the reference
                // gained above in WmipFindNEByGuid and once to account for
                // the reference taken when the event or first collection was
                // enabled
                WmipUnreferenceNE(NotificationEntry);

                Status = ERROR_SUCCESS;
            } else {
                //
                // Attempt to disable an event which has no DcRef
                Status = ERROR_WMI_ALREADY_DISABLED;
                WmipUnreferenceNE(NotificationEntry);
            }
        } else {
            //
            // Attempt to disable an event which has no NotificationEntry
            Status = ERROR_WMI_ALREADY_DISABLED;
        }
        WmipLeaveSMCritSection();
    }

done:
    if (GuidEntry != NULL)
    {
        WmipUnreferenceGE(GuidEntry);
    }
    return(Status);
}

ULONG CollectionControl(
    /* [in]*/  DCCTXHANDLE DcCtxHandle,
    /* [in] */ LPGUID Guid,
    /* [in] */ BOOLEAN Enable
    )
/*++
Routine Description:

    This routine manages enabling and disabling collection of data for those
    guids that are marked as expensive to collect.

Arguments:

    DcCtxHandle is the data consumer context handle

    Guid specifies the guid to enable collection

    Enable is TRUE to Enable collection or FALSE to disable collection

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }
    
    return(CollectOrEventWorker(
               (PDCENTRY)DcCtxHandle,
               Guid,
               Enable,
               FALSE,
               NULL,
               0,
               0));
}

ULONG NotificationControl(
    /* [in]*/  DCCTXHANDLE DcCtxHandle,
    /* [in] */ LPGUID Guid,
    /* [in] */ BOOLEAN Enable,
    /* [in, out] */ ULONG *NotificationCookie,
    /* [in] */ ULONG64 LoggerContext,
    /* [in] */ ULONG NotificationFlags
    )
/*++
Routine Description:

    This routine manages enabling and disabling of event generation for a
    guid.

Arguments:

    Guid specifies the guid to enable event generation

    Enable is TRUE to Enable collection or FALSE to disable event generation

    NotificationCookie is the cookie that represents a notification callback
        context on the client side

    LoggerContext is the logger context handle for calls enabling a trace
        logger

    NotificationFlags specify the type of notification (event or callback)

Return Value:

    ERROR_SUCCESS or an error code
--*/
{
    ULONG Status;
#ifndef MEMPHIS
    ULONG IsTraceLog;
#endif
    
    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }    
    
#ifndef MEMPHIS
    //
    // RegChangeNotificationGuid does not need to have its access checked
    // since it is used for registration notifications back to the data
    // consumers and we do not want to restrict it in any way.
    IsTraceLog = ((NotificationFlags & NOTIFICATION_TRACE_FLAG) != 0);

    if ((!IsEqualGUID(Guid, &RegChangeNotificationGuid)) ||
        (IsTraceLog))
    {
        Status = RpcImpersonateClient(0);
        if (Status == ERROR_SUCCESS)
        {
            if (IsTraceLog) 
            {
                Status = WmipCheckGuidAccess(Guid, TRACELOG_GUID_ENABLE);
            }
            else 
            {
                Status = WmipCheckGuidAccess(Guid, WMIGUID_NOTIFICATION);
            }

            RpcRevertToSelf();
        }
        if (Status != ERROR_SUCCESS)
        {
            return(Status);
        }
    }
#endif
    Status = CollectOrEventWorker(
               (PDCENTRY)DcCtxHandle,
               Guid,
               Enable,
               TRUE,
               NotificationCookie,
               LoggerContext,
               NotificationFlags);
    return(Status);
}


void __RPC_USER DCCTXHANDLE_rundown(
    DCCTXHANDLE DcCtxHandle
    )
/*++
Routine Description:

    This is the rundown routine for a DC context handle. Whenever a data
    consumer goes away unexpectedly we need to clean up any events or
    collections that he has left enabled

Arguments:

    DcCtxHandle is the Data consumer context handle

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
#if DBG
    BOOLEAN NotificationsEnabled, CollectionsEnabled;
#endif

    WmipCleanupDataConsumer((PDCENTRY)DcCtxHandle
#if DBG
                                      ,&NotificationsEnabled,
                                      &CollectionsEnabled
#endif
                                                          );
}

ULONG RegisterGuids(
    /* [out] */ DPCTXHANDLE __RPC_FAR *DpCtxHandle,
    /* [string][in] */ TCHAR __RPC_FAR *RpcBinding,
    /* [in] */ ULONG RequestCookie,
    /* [out][in] */ ULONG __RPC_FAR *GuidCount,
    /* [size_is][size_is][out][in] */ PTRACEGUIDMAP __RPC_FAR *GuidMap,
    /* [in] */ LPCWSTR ImagePath,
    /* [in] */ ULONG Size,
    /* [size_is][in] */ BYTE __RPC_FAR *WmiRegInfo,
    /* [out] */ ULONG64 *LoggerContext)
{
    ULONG Status;
    ULONG_PTR ProviderId = 0;
    PWMIREGINFOW  RegInfo = (PWMIREGINFOW)WmiRegInfo;
    WMIREGGUIDW UNALIGNED64 *RegGuid = RegInfo->WmiRegGuid;
    PTRACEGUIDMAP pGuidMap = *GuidMap;
    PBGUIDENTRY GuidEntry;
    PNOTIFICATIONENTRY NotificationEntry;
    ULONG i;

#ifndef MEMPHIS
    if (! WmipIsRpcClientLocal(NULL))
    {
        *DpCtxHandle = NULL;
        return(ERROR_ACCESS_DENIED);
    }
#endif

    *LoggerContext = 0;

    Status = WmipAddDataSource(
                             RpcBinding,
                             RequestCookie,
                             0,
                             (LPTSTR)ImagePath, 
                             RegInfo,
                             Size,
                             &ProviderId,
                             FALSE);

    if (Status == ERROR_SUCCESS)
    {
        PBDATASOURCE DataSource;
        PBINSTANCESET InstanceSet;

        DataSource = WmipFindDSByProviderId(ProviderId);
        if (DataSource == NULL)
        {
            WmipAssert(FALSE);
            *DpCtxHandle = NULL;
            *GuidCount = 0;
            return (ERROR_WMI_GUID_NOT_FOUND);
        }

        //
        // Establish binding to Data provider
        Status = WmipBindToWmiClient(DataSource->BindingString,
                                     &DataSource->RpcBindingHandle);
                                 
        if (Status == ERROR_SUCCESS)
        {
            *DpCtxHandle = (DPCTXHANDLE)DataSource;
            //
            // If the Registration was successful then find the
            // the GuidEntry for these Trace Guids and return them as well.
            //

            *GuidCount = RegInfo->GuidCount;
            for (i = 0; i < *GuidCount; i++, RegGuid++, pGuidMap++)
            {
                InstanceSet = WmipFindISByGuid( DataSource, &RegGuid->Guid );
                if (InstanceSet == NULL)
                {
                    WmipUnreferenceDS(DataSource);
                    return( ERROR_WMI_GUID_NOT_FOUND );
                }
                pGuidMap->Guid = RegGuid->Guid;
                pGuidMap->GuidMapHandle = (ULONG_PTR)InstanceSet;
                WmipUnreferenceIS(InstanceSet);
            }
            WmipUnreferenceDS(DataSource);

            //
            // Find out if this Guid is currently Enabled. If so find its
            // LoggerContext
            //

            RegGuid = RegInfo->WmiRegGuid;
            NotificationEntry = WmipFindNEByGuid(&RegGuid->Guid, FALSE);
            if (NotificationEntry != NULL)
            {
                if ((NotificationEntry->Flags & NOTIFICATION_TRACE_FLAG) != 0)
                {
                    *LoggerContext = NotificationEntry->LoggerContext;
                }
                WmipUnreferenceNE(NotificationEntry);
            }
        } else {
            //
            // Unreference twice so that it is removed from the DS lists
            WmipUnreferenceDS(DataSource);
            WmipUnreferenceDS(DataSource);
            *DpCtxHandle = NULL;
            *GuidCount = 0;
        }
    } else {
        *DpCtxHandle = NULL;
        *GuidCount = 0;
    }

    return(Status);
}

ULONG UnregisterGuids(
    /* [in, out] */ DPCTXHANDLE *DpCtxHandle,
    /* [in]      */ LPGUID Guid,
    /* [out]     */ ULONG64 *LoggerContext
)
{
    PBDATASOURCE DataSource = *DpCtxHandle;
    ULONG Status;
    
    if (VERIFY_DPCTXHANDLE(*DpCtxHandle))
    {
        PNOTIFICATIONENTRY NotificationEntry;
        *LoggerContext = 0;

        WmipRemoveDataSourceByDS(DataSource);
        *DpCtxHandle = NULL;

        //
        // Check to see if this GUID got disabled in the middle
        // of Unregister Call. If so, send the LoggerContext back
        //

        NotificationEntry = WmipFindNEByGuid(Guid, FALSE);
        if (NotificationEntry != NULL)
        {
            if ((NotificationEntry->Flags & NOTIFICATION_TRACE_FLAG) != 0)
            {
                *LoggerContext = NotificationEntry->LoggerContext;
            }
            WmipUnreferenceNE(NotificationEntry);
        }

        Status = ERROR_SUCCESS;

    } else {
        WmipDebugPrint(("WMI: Invalid DPCTXHANDLE %x\n", *DpCtxHandle));
        Status = ERROR_INVALID_PARAMETER;
    }
    
    return(Status);
}

void __RPC_USER DPCTXHANDLE_rundown(
    DPCTXHANDLE DpCtxHandle
    )
{
    WmipDebugPrint(("WMI: DP Context rundown for %x\n", DpCtxHandle));
    WmipRemoveDataSource((ULONG_PTR)DpCtxHandle);
}


ULONG WmipUniqueEndpointIndex;

ULONG GetUniqueEndpointIndex(
    void
    )
/*++
Routine Description:

    This routine will provide a mostly unique index that data consumers
    and data providers use to create a unique RPC endpoint.

Arguments:

Return Value:

    A mostly unique endpoint index or 0 in case of failure.

--*/
{
    ULONG Index;

#ifndef MEMPHIS
    if (! WmipIsRpcClientLocal(NULL))
    {
        return(0);
    }
#endif

    WmipEnterSMCritSection();
    if (++WmipUniqueEndpointIndex == 0)
    {
        //
        // If we have wrapped around we want to avoid returning 0
        // as that indicates failure.
        WmipUniqueEndpointIndex = 1;
    }
    Index = WmipUniqueEndpointIndex;
    WmipLeaveSMCritSection();
    return(Index);
}

ULONG
GetGuidPropertiesFromGuidEntry(
    PWMIGUIDPROPERTIES GuidInfo, 
    PGUIDENTRY GuidEntry)
/*++
Routine Description:

    This routine fills GuidInfo with the properties for the Guid
    represented by the GuidEntry. Note that this call is made holding
    the SMCritSection.

Arguments:

Return Value:

   ERROR_SUCCESS or an error code 

--*/
{
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    PNOTIFICATIONENTRY NotificationEntry;

    GuidInfo->GuidType = WMI_GUIDTYPE_DATA;
    GuidInfo->IsEnabled = FALSE;
    GuidInfo->LoggerId = 0;
    GuidInfo->EnableLevel = 0;
    GuidInfo->EnableFlags = 0;

    InstanceSetList = GuidEntry->ISHead.Flink;
    while (InstanceSetList != &GuidEntry->ISHead)
    {
        InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                        INSTANCESET,
                                        GuidISList);
        if (InstanceSet->Flags & IS_EVENT_ONLY) 
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_EVENT;
        }
        if (((InstanceSet->Flags & IS_ENABLE_EVENT) ||
            (InstanceSet->Flags & IS_ENABLE_COLLECTION)) ||
            (InstanceSet->Flags & IS_COLLECTING))
        {
            GuidInfo->IsEnabled = TRUE;
        }
        if ( (InstanceSet->Flags & IS_TRACED) &&
             (InstanceSet->Flags & IS_CONTROL_GUID) )
        {
            GuidInfo->GuidType = WMI_GUIDTYPE_TRACECONTROL;
            break;
        }
        InstanceSetList = InstanceSetList->Flink;
    }

    NotificationEntry = WmipFindNEByGuid(&GuidEntry->Guid, FALSE);

    if (NotificationEntry != NULL)
    {
        if (GuidInfo->GuidType == WMI_GUIDTYPE_TRACECONTROL) {
            //
            // If a NotificationEntry is found for a TraceControlGuid
            // it means that it is enabled.
            //
            ULONG64 LoggerContext = NotificationEntry->LoggerContext;
            GuidInfo->IsEnabled = TRUE; 
            GuidInfo->LoggerId = WmipGetLoggerId(LoggerContext);
            GuidInfo->EnableLevel = WmipGetLoggerEnableLevel(LoggerContext);
            GuidInfo->EnableFlags = WmipGetLoggerEnableFlags(LoggerContext);
        }
        WmipUnreferenceNE(NotificationEntry);
    }
    return ERROR_SUCCESS;
}

ULONG EnumerateGuids(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ ULONG MaxGuidCount,
    /* [in] */ ULONG MaxGuidInfoCount,
    /* [out] */ ULONG __RPC_FAR *TotalGuidCount,
    /* [out] */ ULONG __RPC_FAR *GuidCount,
    /* [out] */ ULONG __RPC_FAR *GuidInfoCount,
    /* [length_is][size_is][out] */ LPGUID GuidList,
    /* [length_is][size_is][out] */ PWMIGUIDPROPERTIES GuidInfo)
{
    ULONG i, i1;
    PGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }
    
    WmipEnterSMCritSection();
    GuidEntryList = GEHeadPtr->Flink;

    i = 0;
    i1 = 0;
    while(GuidEntryList != GEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        if (! (GuidEntry->Flags & GE_FLAG_INTERNAL))
        {
            if ((i++ < MaxGuidCount))
            {
                *GuidList = GuidEntry->Guid;
                GuidList++;
                if (i1++ < MaxGuidInfoCount)
                {
                    GetGuidPropertiesFromGuidEntry(GuidInfo, GuidEntry);
                    GuidInfo++;
                }
            }
        }
        GuidEntryList = GuidEntryList->Flink;
    }
    WmipLeaveSMCritSection();

    *TotalGuidCount = i;
    *GuidCount = i1;
    *GuidInfoCount = (i1 > MaxGuidInfoCount) ? MaxGuidInfoCount: i1;
    return( (i <= MaxGuidCount) ? ERROR_SUCCESS : ERROR_MORE_DATA);
}

ULONG GetMofResource(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [out] */ ULONG *MofResourceCount,
    /* [out, sizeis(, *MofResourceCount)] */ PMOFRESOURCEINFOW *MofResourceInfo
    )
{
    ULONG Status;
    PMOFRESOURCEINFOW MRInfo;
    ULONG MRCount;
    ULONG i;
    PLIST_ENTRY MofResourceList;
    PMOFRESOURCE MofResource;
    
    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }    
    
    //
    // TODO: Restrict this call to only admins or the LocalSystem Account
    //       It is really only for WBEM

    *MofResourceInfo = NULL;
    *MofResourceCount = 0;

    //
    // Looking for the entire list of Mof resources
    MRCount = 0;
    WmipEnterSMCritSection();
    MofResourceList = MRHeadPtr->Flink;
    while (MofResourceList != MRHeadPtr)
    {
        MofResource = CONTAINING_RECORD(MofResourceList,
                                                MOFRESOURCE,
                                                MainMRList);
        MRCount++;
        MofResourceList = MofResourceList->Flink;
    }

    MRInfo = midl_user_allocate(MRCount * sizeof(MOFRESOURCEINFOW));
    if (MRInfo != NULL)
    {
        MofResourceList = MRHeadPtr->Flink;
        i = 0;
        while (MofResourceList != MRHeadPtr)
        {
            MofResource = CONTAINING_RECORD(MofResourceList,
                                                MOFRESOURCE,
                                                MainMRList);
            WmipAssert(i < MRCount);
            MRInfo[i].ImagePath = MofResource->MofImagePath;
            MRInfo[i].ResourceName = MofResource->MofResourceName;
            MRInfo[i].ResourceSize = 0;
            MRInfo[i].ResourceBuffer = NULL;
            i++;
            MofResourceList = MofResourceList->Flink;
        }
        *MofResourceInfo = MRInfo;
        *MofResourceCount = MRCount;
        Status = ERROR_SUCCESS;
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    WmipLeaveSMCritSection();

    return(Status);
}

void __RPC_FAR * __RPC_USER WmipMidlUserAllocate(size_t len)
{
    return(WmipAlloc(len));
}

void __RPC_USER WmipMidlUserFree(void __RPC_FAR * ptr)
{
    WmipFree(ptr);
}

#ifndef MEMPHIS

ULONG EnumerateTraceGuidMap(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ ULONG MaxGuidCount,
    /* [out] */ ULONG __RPC_FAR *TotalGuidCount,
    /* [out] */ ULONG __RPC_FAR *GuidCount,
    /* [length_is][size_is][out] */ PTRACEGUIDMAP GuidList)
{
    ULONG i, i1;
    PGUIDENTRY GuidEntry;
    PLIST_ENTRY GuidEntryList;
    PLIST_ENTRY GuidMapEntryList;
    PGUIDMAPENTRY GuidMapEntry;

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }

    WmipEnterSMCritSection();
    GuidEntryList = GEHeadPtr->Flink;
    
    i = 0;
    i1 = 0;
    while(GuidEntryList != GEHeadPtr)
    {
        GuidEntry = CONTAINING_RECORD(GuidEntryList,
                                     GUIDENTRY,
                                     MainGEList);

        if ( !(GuidEntry->Flags & GE_FLAG_INTERNAL) )
           // && (WmipIsItaTraceGuid(GuidEntry) ) )
        {
            PLIST_ENTRY InstanceSetList;
            PBINSTANCESET InstanceSet;

            if (GuidEntry != NULL)
            {
                InstanceSetList = GuidEntry->ISHead.Flink;
                while (InstanceSetList != &GuidEntry->ISHead)
                {
                    InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
                    if (InstanceSet->Flags & IS_TRACED)
                    {
                        if ((i++ < MaxGuidCount) && (GuidList != NULL))
                        {
                            GuidList->Guid = GuidEntry->Guid;
                            GuidList->GuidMapHandle = (ULONG_PTR)InstanceSet;
                            GuidList++;
                            i1++;
                        }
                    }
                    InstanceSetList = InstanceSetList->Flink;
                }
            }
        }
        GuidEntryList = GuidEntryList->Flink;
    }


    //
    // TODO: Need to walk through the GMHead list as well to list the
    // Guids that have been UnRegistered


    GuidMapEntryList = GMHeadPtr->Flink;
    while(GuidMapEntryList != GMHeadPtr)
    {
        GuidMapEntry = CONTAINING_RECORD(GuidMapEntryList,
                                         GUIDMAPENTRY,
                                         Entry);
        if ((i++ < MaxGuidCount) && (GuidList != NULL))
        {
            *GuidList = GuidMapEntry->GuidMap;
            GuidList++; i1++;
        }
        GuidMapEntryList = GuidMapEntryList->Flink;
    }

    WmipLeaveSMCritSection();

    *TotalGuidCount = i;
    *GuidCount = i1;
    return( (i <= MaxGuidCount) ? ERROR_SUCCESS : ERROR_MORE_DATA);
}

ULONG
WmipDisableTraceWorkItem(
    PVOID pContext
    )
{
    PLIST_ENTRY NEList;
    PNOTIFICATIONENTRY NotificationEntry = (PNOTIFICATIONENTRY) pContext;
    PBGUIDENTRY GuidEntry;
    ULONG status;
    PLIST_ENTRY GuidMapEntryList;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG LoggerId = WmipGetLoggerId(NotificationEntry->LoggerContext);

    WmipEnterSMCritSection();

    GuidEntry = WmipFindGEByGuid(&NotificationEntry->Guid, FALSE);
    status = WmipSendDisableRequest(NotificationEntry,
                         GuidEntry,
                         TRUE,
                         TRUE,
                         NotificationEntry->LoggerContext);
    if (GuidEntry)
        WmipUnreferenceGE(GuidEntry);


    GuidMapEntryList = GMHeadPtr->Flink;

    while(GuidMapEntryList != GMHeadPtr)
    {
        GuidMapEntry = CONTAINING_RECORD(GuidMapEntryList,
                                 GUIDMAPENTRY,
                                 Entry);
        GuidMapEntryList = GuidMapEntryList->Flink;

        if (WmipGetLoggerId(GuidMapEntry->LoggerContext) == LoggerId ) {
            RemoveEntryList(&GuidMapEntry->Entry);
            WmipFree(GuidMapEntry);
        }
    }
    WmipUnreferenceNE(NotificationEntry);   // One taken for the work item

    WmipUnreferenceNE(NotificationEntry);   // One from trace enable 

    WmipLeaveSMCritSection();

    return ERROR_SUCCESS;

}



ULONG
WmipServiceDisableTraceProviders(
    PWNODE_HEADER pWnode
    )
{
    PLIST_ENTRY NEList;
    PNOTIFICATIONENTRY NotificationEntry;
    PBGUIDENTRY GuidEntry;
    ULONG status;
    PLIST_ENTRY GuidMapEntryList;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG LoggerId;
    PTRACE_ENABLE_CONTEXT pContext;


    if (pWnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG)))
    {
        ULONG64 LoggerContext = pWnode->HistoricalContext;
        ULONG   Status   = * ((ULONG *)
                              (((PUCHAR) pWnode) + sizeof(WNODE_HEADER)));

        if (Status != STATUS_LOG_FILE_FULL) 
            return ERROR_SUCCESS;

        LoggerId = WmipGetLoggerId(LoggerContext);
        pContext = (PTRACE_ENABLE_CONTEXT) &LoggerContext;

        if ((LoggerId == KERNEL_LOGGER_ID) ||
            (LoggerId == 0)) {
            return ERROR_INVALID_HANDLE;
        }

        WmipEnterSMCritSection();

        NEList = NEHeadPtr->Flink;
        while (NEList != NEHeadPtr)
        {
            NotificationEntry = CONTAINING_RECORD(NEList,
                                                  NOTIFICATIONENTRY,
                                                  MainNotificationList);
            NEList = NEList->Flink;
    
            if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE)
            {
                continue;
            }
            if ((NotificationEntry->Flags & NOTIFICATION_TRACE_FLAG)
               && ((NotificationEntry->Flags & NE_FLAG_TRACEDISABLE_IN_PROGRESS)
                  != NE_FLAG_TRACEDISABLE_IN_PROGRESS)
                && (WmipGetLoggerId(NotificationEntry->LoggerContext)
                         == LoggerId)) {

                NotificationEntry->Flags |= NE_FLAG_TRACEDISABLE_IN_PROGRESS;

                // Take an extra ref count on the Notification Entry
                WmipReferenceNE(NotificationEntry);

                // Call the Work item
                QueueUserWorkItem (WmipDisableTraceWorkItem,
                                   (PVOID)NotificationEntry,
                                   WT_EXECUTELONGFUNCTION);
            }
        }
        WmipLeaveSMCritSection();
    }
    return ERROR_SUCCESS;
}

ULONG
DisableTraceProviders(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ LPGUID  Guid,
    /* [in] */ ULONG64 LoggerContext
)
/*++
Routine Description:

    This routine is called immediately after a logger has been stopped
    successfully to clean up all the existing Notification Entries
    enabled to that logger.

Arguments:

    LoggerContext

Return Value:

    ERROR_SUCCESS
--*/
{
    PLIST_ENTRY NEList;
    PNOTIFICATIONENTRY NotificationEntry;
    PBGUIDENTRY GuidEntry;
    ULONG status;
    PLIST_ENTRY GuidMapEntryList;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG LoggerId = WmipGetLoggerId(LoggerContext);
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT) &LoggerContext;

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }

    if ((LoggerId == KERNEL_LOGGER_ID) || 
        (LoggerId == 0)) {
        return ERROR_INVALID_HANDLE;
    }

    WmipEnterSMCritSection();

    NEList = NEHeadPtr->Flink;
    while (NEList != NEHeadPtr)
    {
        NotificationEntry = CONTAINING_RECORD(NEList,
                                              NOTIFICATIONENTRY,
                                              MainNotificationList);
        NEList = NEList->Flink;

        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE)
        {
            //
            // If this is a PrivateLoggerHandle, we must compare the Guid
            // to determine the right Trace Provider.
            //
            if ( !IsEqualGUID(Guid, & NotificationEntry->Guid ) )
            {
                continue;
            }
        }

        if ((NotificationEntry->Flags & NOTIFICATION_TRACE_FLAG)
                && WmipGetLoggerId(NotificationEntry->LoggerContext)
                     == LoggerId) {

            GuidEntry = WmipFindGEByGuid(&NotificationEntry->Guid, FALSE);
            status = WmipSendDisableRequest(NotificationEntry,
                         GuidEntry,
                         TRUE,
                         TRUE,
                         LoggerContext);
            if (GuidEntry)
                WmipUnreferenceGE(GuidEntry);

            GuidMapEntryList = GMHeadPtr->Flink;

            while(GuidMapEntryList != GMHeadPtr)
            {
                GuidMapEntry = CONTAINING_RECORD(GuidMapEntryList,
                                         GUIDMAPENTRY,
                                         Entry);
                GuidMapEntryList = GuidMapEntryList->Flink;

                if (WmipGetLoggerId(GuidMapEntry->LoggerContext) == LoggerId) {
                    RemoveEntryList(&GuidMapEntry->Entry);
                    WmipFree(GuidMapEntry);
                }
            }
            WmipUnreferenceNE(NotificationEntry);
        }
    }
    WmipLeaveSMCritSection();

    return ERROR_SUCCESS;
}

ULONG UmLogRequest(
    /* [in] */ DCCTXHANDLE DcCtxHandle,
    /* [in] */ ULONG RequestCode,
    /* [in] */ ULONG WnodeSize,
    /* [out][in] */ ULONG __RPC_FAR *SizeUsed,
    /* [out] */ ULONG __RPC_FAR *SizeNeeded,
    /* [length_is][size_is][out][in] */ BYTE __RPC_FAR *Wnode)
/*++

Routine Description:

    This routine routes a user mode private logger creation request to the
    appropriate datasource (Trace Provider of the specified Control Guid).
    If multiple datasources exist for this Guid, this will result in a 
    logger created in each one. The caller must have LOGGER_CREATION rights
    on the Guid.
    

Arguments:

    DcCtxHandle - data consumer context handle

    RequestCode - for Start, Stop or Query Logger
    WnodeSize - size of data block to be passed on to the Provider
    *SizeUsed - returns the size used for return data
    *SizeNeeded - returns the size needed for return data
    Wnode - Data Block containing the WMI_LOGGER_INFORMATION.

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
#if DBG
#define AVGISPERGUID 1
#else
#define AVGISPERGUID 64
#endif
    LPGUID Guid;
    PLIST_ENTRY InstanceSetList;
    PBGUIDENTRY GuidEntry;
    PBINSTANCESET InstanceSet;
    PBDATASOURCE DataSourceArray[AVGISPERGUID];
    PBDATASOURCE *DataSourceList;
    PBDATASOURCE DataSource;
    PBINSTANCESET ISArray[AVGISPERGUID];
    PBINSTANCESET *ISList;
    PBYTE LoggerInfo = Wnode;
    ULONG Status;
    ULONG i;
    ULONG DSCount       = 0;
    ULONG RequiredSize  = 0;
    ULONG RemainingSize = 0;
    ULONG SizePassedIn  = 0;
    ULONG SizePassMax   = sizeof(WMI_LOGGER_INFORMATION)
                        + 2 * MAXSTR * sizeof(WCHAR);
    ULONG SizeFilled    = 0;
    ULONG lRequestCode  = RequestCode;
    BOOL  fEnabledOnly  = (lRequestCode == TRACELOG_QUERYENABLED);

    PBYTE WnodeTemp = NULL;

    if (fEnabledOnly) {
        lRequestCode = TRACELOG_QUERYALL;
    }

    if (! VERIFY_DCCTXHANDLE(DcCtxHandle))
    {
        WmipDebugPrint(("WMI: Invalid DCCTXHANDLE %x\n", DcCtxHandle));
        return(ERROR_INVALID_PARAMETER);
    }
    
    if ((WnodeSize < sizeof(WMI_LOGGER_INFORMATION)) ||
        (WnodeSize < ((PWNODE_HEADER)Wnode)->BufferSize)) {
        return ERROR_INVALID_PARAMETER;
    }

    Guid = &((PWNODE_HEADER)Wnode)->Guid;
    //
    // Check to see if the client has access to start logger on this Guid
    //

    Status = RpcImpersonateClient(0);
    if (Status == ERROR_SUCCESS)
    {
        if (lRequestCode != TRACELOG_QUERYALL) {
            Status = WmipCheckGuidAccess(Guid, TRACELOG_CREATE_INPROC);
        }
        RpcRevertToSelf();
    }
    if (Status != ERROR_SUCCESS)
    {
        return(Status);
    }

    if (RequestCode == TRACELOG_UPDATE) {
        WnodeTemp = WmipAlloc(WnodeSize);
        if (WnodeTemp == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlCopyMemory(WnodeTemp, Wnode, WnodeSize);
    }

    WmipEnterSMCritSection();
    if (lRequestCode == TRACELOG_QUERYALL) {
        PLIST_ENTRY           GENext = GEHeadPtr->Flink;
        ULONG                 DSSize      = AVGISPERGUID;
        BOOLEAN               fDSListFull = FALSE;

        DataSourceList = WmipAlloc(DSSize * sizeof(PBDATASOURCE));
        if (DataSourceList == NULL) {
            WmipLeaveSMCritSection();
            goto cleanup;
        }

        while (GENext != GEHeadPtr) {
            if (fDSListFull)
                break;

            GuidEntry = CONTAINING_RECORD(GENext, GUIDENTRY, MainGEList);
            WmipReferenceGE(GuidEntry);

            if (fEnabledOnly) {
                PNOTIFICATIONENTRY NotificationEntry =
                                WmipFindNEByGuid(& GuidEntry->Guid, FALSE);
                PTRACE_ENABLE_CONTEXT pContext;

                if (NotificationEntry == NULL) {
                    goto GetNextGuidEntry;
                }
                pContext = (PTRACE_ENABLE_CONTEXT)
                           & NotificationEntry->LoggerContext;
                if (! pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE){
                    WmipUnreferenceNE(NotificationEntry);
                    goto GetNextGuidEntry;
                }
                WmipUnreferenceNE(NotificationEntry);
            }

            try {
                InstanceSetList = GuidEntry->ISHead.Flink;
                while (InstanceSetList != & GuidEntry->ISHead) {

                    if (fDSListFull) {
                        goto GetNextGuidEntry;
                    }

                    InstanceSet = CONTAINING_RECORD(
                            InstanceSetList, INSTANCESET, GuidISList);

                    if (   (   (InstanceSet->Flags & IS_TRACED)
                            && (InstanceSet->Flags & IS_CONTROL_GUID))
                        && (   (InstanceSet->Flags & IS_ENABLE_EVENT)
                            || (InstanceSet->Flags & IS_ENABLE_COLLECTION)
                            || (InstanceSet->Flags & IS_COLLECTING))
                        && !(InstanceSet->DataSource->Flags & DS_KERNEL_MODE))
                    {
                        DataSourceList[DSCount] = InstanceSet->DataSource;
                        WmipReferenceDS(DataSourceList[DSCount]);
                        DSCount ++;

                        if (DSCount >= DSSize) {
                            if (!WmipRealloc((PVOID *) & DataSourceList,
                                             DSSize * sizeof(PBDATASOURCE),
                                             2 * DSSize * sizeof(PBDATASOURCE),
                                             TRUE))
                            {
                                fDSListFull = TRUE;
                            }
                            DSSize = 2 * DSSize;
                        }
                    }
                    InstanceSetList = InstanceSetList->Flink;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                WmipDebugPrint(("WMI: UmLogRequest() threw exception %d, Bogus GuidEntry.\n",
                        GetExceptionCode()));
            }

GetNextGuidEntry:
            WmipUnreferenceGE(GuidEntry);
            GENext = GENext->Flink;
        }
        GuidEntry    = NULL;
        lRequestCode = TRACELOG_QUERY;
    }
    else {
        // From the ControlGuid we get the data source ...
        // 
        GuidEntry = WmipFindGEByGuid(Guid, FALSE);
        if (!WmipIsControlGuid(GuidEntry))
        {
            Status = ERROR_INVALID_OPERATION;
            WmipLeaveSMCritSection();
            goto cleanup;
        }

        // NOTE: If there are multiple DataSources for the Guid, we will end up 
        // creating a logger in each Provider with this. 
        //
        // First we make a list of all of the DataSources that need to be called
        // while we have the critical section and take a reference on them so
        // they don't go away after we release them. Note that the DataSource
        // structure will stay, but the actual data provider may in fact go away.
        // In this case sending the request will fail.

        DSCount = 0;

        if (GuidEntry->ISCount > AVGISPERGUID)
        {
            DataSourceList = WmipAlloc(GuidEntry->ISCount * sizeof(PBDATASOURCE));
            if (DataSourceList == NULL)
            {
                WmipLeaveSMCritSection();
                goto cleanup;
            }
        } else {
            DataSourceList = &DataSourceArray[0];
        }
#if DBG
        memset(DataSourceList, 0, GuidEntry->ISCount * sizeof(PBDATASOURCE));
#endif

        InstanceSetList = GuidEntry->ISHead.Flink;
        while ((InstanceSetList != &GuidEntry->ISHead) &&
               (DSCount < GuidEntry->ISCount))
        {
            WmipAssert(DSCount < GuidEntry->ISCount);
            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                            INSTANCESET,
                                            GuidISList);
            DataSource = InstanceSet->DataSource;
            if ( ((InstanceSet->Flags & IS_TRACED) &&
                     (InstanceSet->Flags & IS_CONTROL_GUID)) &&
                     !(DataSource->Flags & DS_KERNEL_MODE) )
            {
                DataSourceList[DSCount] = DataSource; 
                WmipReferenceDS(DataSourceList[DSCount]);
                DSCount++;
            }
            InstanceSetList = InstanceSetList->Flink;
        }
    }
    WmipLeaveSMCritSection();

    // Now without the critical section we send the request to all of the
    // data providers. Any new data providers who register after we made our
    // list will be enabled by the registration code.

    ((PWMI_LOGGER_INFORMATION)Wnode)->InstanceCount = DSCount;
    *SizeNeeded = 0;
    *SizeUsed = 0;
    RemainingSize = WnodeSize;

    if (DSCount > 0)
    {
        for (i = 0; i < DSCount; i++)
        {
            if (RequestCode == TRACELOG_UPDATE) {
                RtlCopyMemory(Wnode, WnodeTemp, WnodeSize);
                ((PWMI_LOGGER_INFORMATION)Wnode)->InstanceCount = DSCount;
            }

            DataSource   = DataSourceList[i];
            SizePassedIn = (RemainingSize > SizePassMax)
                         ? SizePassMax : RemainingSize;
            SizeFilled   = SizePassedIn;
            ((PWNODE_HEADER) LoggerInfo)->BufferSize = SizePassedIn;
            WmipAssert(DataSource != NULL);
            ((PWMI_LOGGER_INFORMATION)Wnode)->InstanceId = i;

            ((PWNODE_HEADER)Wnode)->ClientContext = DataSource->RequestAddress;

            if (!(DataSource->Flags & DS_KERNEL_MODE))
            {
                Status = WmipRestrictToken(WmipRestrictedToken);
                if (Status == ERROR_SUCCESS)
                {
                    try
                    {
                
                        Status = WmipClient_LoggerCreation(
                                                    DataSource->RpcBindingHandle,
                                                    lRequestCode,
                                                    SizePassedIn,
                                                    &SizeFilled,
                                                    &RequiredSize,
                                                    LoggerInfo
                                                    );

                    } except(EXCEPTION_EXECUTE_HANDLER) {

                        Status = GetExceptionCode();
                        WmipDebugPrint(("WMI: UmLogCreate threw exception %d\n",
                                         Status));

                        Status = ERROR_WMI_DP_FAILED;
                    }

                    WmipUnrestrictToken();

                    if (Status == ERROR_SUCCESS) 
                    {
                        WmipEnterSMCritSection();
                        InstanceSet = WmipFindISInDSByGuid(DataSource, Guid);
                        WmipLeaveSMCritSection();
                        if (InstanceSet != NULL) 
                        {
                            if (lRequestCode == TRACELOG_START)
                            {
                                InstanceSet->Flags |= IS_COLLECTING;
                            }
                            else if (lRequestCode == TRACELOG_STOP)
                            {
                                InstanceSet->Flags &= ~IS_COLLECTING;
                            }
                            WmipUnreferenceIS(InstanceSet);
                        }
                        //
                        // If querying multiple providers we return
                        // properties from each one. 
                        //
                        if (lRequestCode == TRACELOG_QUERY) {
                            *SizeUsed += RequiredSize;
                            if (*SizeUsed > WnodeSize) {
                                *SizeUsed = WnodeSize;
                            }
                            if (RemainingSize > RequiredSize) {
                                LoggerInfo += RequiredSize;
                                RemainingSize -= RequiredSize;
                            }
                        }
                        else {
                            *SizeUsed = RequiredSize;
                        } 
                    }
                    *SizeNeeded += RequiredSize;
                }
            }
            WmipUnreferenceDS(DataSource);
        }
    }

    if (* SizeUsed > 0) {
        Status = ERROR_SUCCESS;
    }

    if (DataSourceList != DataSourceArray)
    {
        WmipFree(DataSourceList);
    }

cleanup:
    if (WnodeTemp != NULL) {
        WmipFree(WnodeTemp);
    }

    if (GuidEntry != NULL)
    {
        WmipUnreferenceGE(GuidEntry);
    }

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\validate.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    validate.c

Abstract:
    
    WMI data validation routines

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"


BOOLEAN WmipValidateCountedString(
    WCHAR *String
    )
/*++

Routine Description:

    This routine will verify that the counted string passed has the correct
    count, all of the characters are present.
    correct place.

Arguments:

    String is the unicode string to validate


Return Value:

    TRUE if string is valid else FALSE

--*/        
{
    BOOLEAN Valid;
    USHORT Length;
    
    if (String == NULL)
    {
        Valid = FALSE;
    } else {
        try
        {
            Length = *String / sizeof(WCHAR);
            if (Length != 0)
            {
#if DBG
                int i;
                WCHAR c;
                
                for (i = 0; i < Length; i++)
                {
                    c = String[i];
                }                
#endif
                Valid = TRUE;
            } else {
                WmipDebugPrint(("WMI: Empty string validated %x\n", String));
                Valid = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WmipDebugPrint(("WMI: Bad string pointer %x\n", String));
            Valid = FALSE;
        }    
    }
    
    return(Valid);
}

BOOLEAN WmipValidateGuid(
    LPGUID Guid
    )
/*++

Routine Description:

    This routine will ensure that all 16 bytes of the guid can be read

Arguments:

    Guid is a pointer to a guid to be validated

Return Value:

    TRUE if valid else FALSE

--*/        
{
    BOOLEAN Valid;
    GUID DestGuid;
    
    if (Guid == NULL)
    {
        Valid = FALSE;
        WmipDebugPrint(("WMI: NULL guid pointer \n"));
    } else {
        try
        {
            memcpy(&DestGuid, Guid, sizeof(GUID));
            Valid = TRUE;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            WmipDebugPrint(("WMI: Bad guid pointer %x\n", Guid));
            Valid = FALSE;
        }
    }
    return(Valid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\wmicore_server.c ===
#include "wmicore_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\wbem.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wbem.c

Abstract:
    
    WMI interface to WBEM/HMOM

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"


ULONG WmipBuildMofClassInfo(
    PBDATASOURCE DataSource,
    LPWSTR ImagePath,
    LPWSTR MofResourceName,
    PBOOLEAN NewMofResource
    )
/*++

Routine Description:

    This routine will build MOFCLASSINFO structures for each guid that is 
    described in the MOF for the data source. If there are any errors in the
    mof resource then no mof information from the resource is retained and the
    resource data is unloaded. 

Arguments:

    DataSource is the data source structure of the data provider
        
    ImagePath points at a string that has the full path to the image
        file that contains the MOF resource
            
    MofResourceName points at a string that has the name of the MOF
        resource
        
Return Value:


--*/        
{
    PMOFRESOURCE MofResource;
    ULONG NewMofResourceCount;
    ULONG i;
    BOOLEAN FreeBuffer;
        
    MofResource = WmipFindMRByNames(ImagePath, 
                                    MofResourceName);
                     
    if (MofResource == NULL)
    {
        //
        // Mof Resource not previously specified, so allocate a new one
        MofResource = WmipAllocMofResource();
        if (MofResource == NULL)
        {    
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        MofResource->MofImagePath = WmipAlloc((wcslen(ImagePath)+1) * sizeof(WCHAR));
        MofResource->MofResourceName = WmipAlloc((wcslen(MofResourceName) + 1) * sizeof(WCHAR));

        if ((MofResource->MofImagePath == NULL) || 
            (MofResource->MofResourceName == NULL))
        {
            //
            // Allocation cleanup routine will free any memory alloced for MR
            WmipUnreferenceMR(MofResource);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    
        wcscpy(MofResource->MofImagePath, ImagePath);
        wcscpy(MofResource->MofResourceName, MofResourceName);

        WmipEnterSMCritSection();
        InsertTailList(MRHeadPtr, &MofResource->MainMRList);
        WmipLeaveSMCritSection();
    	*NewMofResource = TRUE;
    } else {
    	*NewMofResource = FALSE;
    }
    
    if (DataSource != NULL)
    {
        WmipEnterSMCritSection();
        for (i = 0; i < DataSource->MofResourceCount; i++)
        {
            if (DataSource->MofResources[i] == MofResource)
	        {
				//
				// If this mof resource is already been registered for
				// this data source then we do not need to worry about
				// it anymore.
				//
				WmipUnreferenceMR(MofResource);
                break;
    	    }
            
            if (DataSource->MofResources[i] == NULL)
            {
                DataSource->MofResources[i] = MofResource;
                break;
            }
        }
            
        if (i == DataSource->MofResourceCount)
        {
            NewMofResourceCount = DataSource->MofResourceCount + 
                                  AVGMOFRESOURCECOUNT;
            if (DataSource->MofResources != 
                     DataSource->StaticMofResources)
            {
                FreeBuffer = TRUE;
            } else {
                FreeBuffer = FALSE;
            }
        
            if (WmipRealloc((PVOID *)&DataSource->MofResources,
                         DataSource->MofResourceCount * sizeof(PMOFRESOURCE),
                         NewMofResourceCount * sizeof(PMOFRESOURCE),
                         FreeBuffer )  )
            {
                DataSource->MofResourceCount = NewMofResourceCount;
                DataSource->MofResources[i] = MofResource;
            }
        }
        WmipLeaveSMCritSection();
    }

    return(ERROR_SUCCESS);
}

ULONG WmipReadBuiltinMof(
    void
    )
/*++

Routine Description:

    This routine will load all of the standard mof resources that come as
    as a part of WMI.

Arguments:

        
Return Value:


--*/        
{
    ULONG Status;
    BOOLEAN NewMofResource;
    
    Status = WmipBuildMofClassInfo(
                            NULL,
                            WMICOREDLLNAME, 
                            WMICOREMOFRESOURCENAME,
                            &NewMofResource);
                
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\core\wmidp_client.c ===
#include "wmidp_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\chunk.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    chunk.c

Abstract:
    
    This routine will manage allocations of chunks of structures

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include <stdio.h>

#define WmipEnterCriticalSection() WmipEnterPMCritSection()
#define WmipLeaveCriticalSection() WmipLeavePMCritSection()

//
// include implementation of chunk managment code
#include "chunkimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\dcapi.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dcapi.c

Abstract:

    WMI data consumer api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

#ifndef MEMPHIS
#include <aclapi.h>
#endif

ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *DataBlockGuid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
)
/*+++

Routine Description:

    This routine prepares for accessing data items contained within the data
    block represented by the guid passed. If successful it returns a handle
    that can be used to query and set data blocks maintained by data providers
    that have registered the guid. Any data providers that had registered the
    guid as expensive will receive a request to enable collection of data for
    the guid if collection was not previously enabled.

Arguments:

    DataBlockGuid - Pointer to guid that represents the data block

    DesiredAccess - Specifies the type of access to the object. Not used on
        Windows 98

    *DataBlockHandle - If successful returns a handle to the data block

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG Status;
    HANDLE KernelHandle;
    GUID Guid;
    ULONG Ioctl;
    
    WmipInitProcessHeap();

    //
    // Validate the passed parameters
    //
    if ((DataBlockGuid == NULL) ||
        (DataBlockHandle == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }
    
    if ((DesiredAccess & WMIGUID_NOTIFICATION) &&
        ((DesiredAccess & (WMIGUID_QUERY | WMIGUID_SET | WMIGUID_EXECUTE))  != 0))
    {
        //
        // If you want to open the guid for notifications then it cannot
        // be opened for query and set operations
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        *DataBlockHandle = NULL;
        Guid = *DataBlockGuid;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (DesiredAccess == 0)
    {
        DesiredAccess =  ( WMIGUID_QUERY | WMIGUID_SET |  WMIGUID_EXECUTE );
    }

    //
    // Obtain a handle for the guid only if it is registered
    //
    if (DesiredAccess & WMIGUID_NOTIFICATION)
    {
        //
        // Opening a handle strictly for notifications
        //
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_EVENTS;
    } else {
        //
        // Otherwise we assume that opening for query/set
        //
        Ioctl = IOCTL_WMI_OPEN_GUID_FOR_QUERYSET;
    }
    Status = WmipOpenKernelGuid(&Guid,
                                DesiredAccess,
                                &KernelHandle,
                                Ioctl);

    if (Status == ERROR_SUCCESS)
    {
        //
        // if we were able to open the guid then try to return the handle
        //
        try
        {
            *DataBlockHandle = KernelHandle;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CloseHandle(KernelHandle);
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
)
/*+++

Routine Description:

    This routine terminates all access to the data block managed by the
    data block handle passed and free any resources associated with it. Any
    data providers that were providing data blocks for this handle and were
    marked as expensive to collect will receive a collection disable request
    if this is the last handle to the data block to close.

Arguments:

    DataBlockHandle - Handle of data block to which access is closed

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG Status;
    BOOL Ok;
    
    WmipInitProcessHeap();

    try
    {
        Ok = CloseHandle(DataBlockHandle);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // We may get an invalid handle exception and if so we catch it here
        // and just return an error
        //
        return(ERROR_INVALID_HANDLE);
    }
    
    if (Ok)
    {
        Status = ERROR_SUCCESS;
    } else {
        Status = GetLastError();
    }
    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT LPVOID Buffer
    )
/*++

Routine Description:

    ANSI thunk to WMIQueryAllDataW

    NOTE: This api will not translate any unicode strings in the data block
          from unicode to ANSI, but will translate the InstanceName string.
--*/
{
    ULONG Status;

    Status = WmiQueryAllDataW(DataBlockHandle,
                              BufferSize,
                              Buffer);

    if (Status == ERROR_SUCCESS)
    {
        Status = WmipConvertWADToAnsi((PWNODE_ALL_DATA)Buffer);
    }

    return(Status);
}


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
    )
/*+++

Routine Description:

    This routine allows a data consumer to query for all data items of
    all instances of a data block. WMI will call all data providers that
    registered for the guid represented by DataBlockHandle with a query all
    data request. Each data provider will fill a WNODE_ALL_DATA with all
    of its instances of the data block. WMI will link each of the
    WNODE_ALL_DATA structures by placing the offset from the current
    WNODE_ALL_DATA struccture to the next WNODE_ALL_DATA in the Linkage
    field in the WNODE_HEADER. A value of 0 in the Linkage field indicates
    that the WNODE_ALL_DATA is the last in the chain.


Arguments:

    DataBlockHandle - Handle to data block being queried

    *InOutBufferSize - on entry has the maximum size available in Buffer.
                  If ERROR_BUFFER_TOO_SMALL is returned then returns the size
                  of buffer needed to return data. The minimum valid buffer
                  size that can be passed is sizeof(WNODE_TOO_SMALL).

    OutBuffer - If ERROR_SUCCESS is returned then the buffer contains a
             WNODE_ALL_DATA for the data block.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    ULONG SizeNeeded;
    PWNODE_HEADER Wnode;
    WNODE_ALL_DATA WnodeAllData;
    PWNODE_TOO_SMALL WnodeTooSmall = (PWNODE_TOO_SMALL)&WnodeAllData;
    ULONG Status;
    LPVOID Buffer;
    ULONG RetSize;
    ULONG BufferSize;
    LPVOID BufferAllocated;
        
    WmipInitProcessHeap();

    //
    // Validate passed Parameters
    //
    try
    {
        BufferSize = *InOutBufferSize;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (BufferSize >= 0x80000000)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // If Buffer is not specified or is too small then we can only return
    // the size needed.
    //
    if ((OutBuffer == NULL) || (BufferSize < sizeof(WNODE_ALL_DATA)))
    {
        Buffer = (LPVOID)WnodeTooSmall;
        BufferSize = sizeof(WNODE_ALL_DATA);
        BufferAllocated = NULL;
    } else {
        Buffer = WmipAlloc(BufferSize);
        if (Buffer == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        BufferAllocated = Buffer;
    }

    //
    // Build the wnode and pass down to KM for execution
    //
    Wnode = (PWNODE_HEADER)Buffer;
    WmipBuildWnodeHeader(Wnode,
                         sizeof(WNODE_HEADER),
                         WNODE_FLAG_ALL_DATA,
                         DataBlockHandle);

    Status = WmipSendWmiRequest(
                                    WMI_GET_ALL_DATA,
                                    Wnode,
                                    sizeof(WNODE_HEADER),
                                    Wnode,
                                    BufferSize,
                                    &RetSize);

    if ((Status == ERROR_SUCCESS) &&
        ( (RetSize < sizeof(WNODE_HEADER))  ||
          (RetSize < Wnode->BufferSize)))
    {
        //
        // If we return success, but the output size is incorrect then we
        // flag an error. If this occurs then it indicates some problem
        // in the WMI KM code.
        //
        WmipAssert(FALSE);
        Status = ERROR_WMI_DP_FAILED;
    }

    if (Status == ERROR_SUCCESS)
    {
        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // If this is an internal guid, try the call internally
            //
            Wnode->Flags &= ~WNODE_FLAG_INTERNAL;
            Status = WmipInternalProvider(WmiGetAllData,
                                          Wnode,
                                          BufferSize,
                                          Wnode,
                                          &RetSize);
                                          
            if (Status != ERROR_SUCCESS)
            {
                goto done;
            }
        } 
    
        if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
        {
            //
            // There is not enough room to complete the query so we
            // remember how much the data provider needs and then add
            // in how much WMI needs for the instance names.

            SizeNeeded = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
            Status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            //
            // We had enough room so report the size we used
            //
            SizeNeeded = RetSize;
            
            if (Wnode == (PWNODE_HEADER)WnodeTooSmall)
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        
        //
        // Copy back into the caller's buffer the BufferSize and the Buffer
        //
        try
        {
            *InOutBufferSize = SizeNeeded;
            if ((Status == ERROR_SUCCESS) &&
                (Wnode != (PWNODE_HEADER)WnodeTooSmall))
            {
                memcpy(OutBuffer, Buffer, SizeNeeded);
                Status = ERROR_SUCCESS;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    
done:
    if (BufferAllocated != NULL)
    {
        WmipFree(BufferAllocated);
    }

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;

    WmipInitProcessHeap();
    
    Status = WmiQueryAllDataMultipleW(HandleList,
                                      HandleCount,
                                      InOutBufferSize,
                                      OutBuffer);

    if ((Status == ERROR_SUCCESS) && (*InOutBufferSize > 0))
    {
        Status = WmipConvertWADToAnsi((PWNODE_ALL_DATA)OutBuffer);
    }

    return(Status);
}

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    PWMIQADMULTIPLE QadMultiple;
    ULONG RetSize;
    ULONG QadMultipleSize;
    ULONG i;
    ULONG OutBufferSize;
    ULONG Status;
    WNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    
    WmipInitProcessHeap();
    
    if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
    {
        QadMultipleSize = sizeof(WMIQADMULTIPLE) + 
                                       ((HandleCount-1) * sizeof(HANDLE3264));
                                   
        QadMultiple = WmipAlloc(QadMultipleSize);
        if (QadMultiple != NULL)
        {
            QadMultiple->HandleCount = HandleCount;
            try
            {
                for (i = 0; i < HandleCount; i++)
                {
                    WmipSetHandle3264(QadMultiple->Handles[i], HandleList[i]);
                }
                OutBufferSize = *InOutBufferSize;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                WmipFree(QadMultiple);
                SetLastError(ERROR_NOACCESS);
                return(ERROR_NOACCESS);
            }
            
            if (OutBufferSize < sizeof(WNODE_ALL_DATA))
            {
                Wnode = (PWNODE_HEADER)&WnodeTooSmall;
                OutBufferSize = sizeof(WNODE_TOO_SMALL);
            } else {
                Wnode = (PWNODE_HEADER)OutBuffer;
            }
            
            Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_QAD_MULTIPLE,
                                  QadMultiple,
                                  QadMultipleSize,
                                  Wnode,
                                  OutBufferSize,
                                  &RetSize,
                                  NULL);
                              
            WmipFree(QadMultiple);

            if (Status == ERROR_SUCCESS)
            {
                if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
                {       
                    RetSize = ((PWNODE_TOO_SMALL)(Wnode))->SizeNeeded;
                    Status = ERROR_INSUFFICIENT_BUFFER;
                } else if (Wnode == (PWNODE_HEADER)&WnodeTooSmall) {
                    Status = ERROR_INSUFFICIENT_BUFFER;
                }
    
                try
                {
                    *InOutBufferSize = RetSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }
            }
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Status);
    return(Status);     
}

ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT LPVOID Buffer
    )
/*++

Routine Description:

    ANSI thunk to WMIQuerySingleInstanceW

    NOTE: This api will not translate any unicode strings in the data block
          from unicode to ANSI, but will translate the InstanceName string.
--*/
{
    LPWSTR InstanceNameUnicode;
    ULONG Status;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Ptr;

    WmipInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiQuerySingleInstanceW(DataBlockHandle,
                                         InstanceNameUnicode,
                                         BufferSize,
                                         Buffer);

        if (Status == ERROR_SUCCESS)
        {
            //
            // Convert Instance name from unicode back to ANSI. We assume
            // that the ansi size will never be larger than the unicode size
            // so we can convert in place.
            Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
            Ptr = (PWCHAR)(((PUCHAR)Buffer) + Wnode->OffsetInstanceName);
            Status = WmipCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
            if (Status != ERROR_SUCCESS)
            {
                SetLastError(Status);
            } else {
                Wnode->WnodeHeader.Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;
            }
        }

        if (InstanceNameUnicode != NULL)
        {
            WmipFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
    )
/*+++

Routine Description:

    This routine will query a single data provider for the values of a single
    instance of the data block represented by the DataBlockHandle. WMI will
    determine the appropriate data provider to which to send a query single
    instance request and if successful return a WNODE_SINGLE_INSTANCE to
    the caller.

Arguments:

    DataBlockHandle - Handle to data block to query

    InstanceName - name of the instance for which data is being queried

    *BufferSize - on entry has the maximum size available in pBuffer. If
                  ERROR_BUFFER_TOO_SMALL is returned then returns the size of
                  buffer needed to return data. The minimum valid buffer
                  size that can be passed is sizeof(WNODE_TOO_SMALL).

    Buffer - If ERROR_SUCCESS is returned then the buffer contains a
             WNODE_SINGLE_ITEM for the data block.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG Status, ReturnStatus;
    PWCHAR WnodePtr;
    ULONG BufferNeeded;
    ULONG BufferSize;
    LPVOID Buffer;
    ULONG RetSize;
    ULONG InstanceNameLen;

    WmipInitProcessHeap();

    //
    // Validate input parameters
    //
    if ((InstanceName == NULL) ||
        (InOutBufferSize == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Calculate the size of the buffer needed to build the WNODE to send
    // to the driver. We add up the WNODE_SINGLE_INSTANCE header, the
    // instance name length and text and pad it out to an 8 byte boundry
    //
    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
        BufferSize = *InOutBufferSize;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Make sure we have a resonable buffer size
    //
    if (BufferSize >= 0x80000000)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    BufferNeeded = (FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                 VariableData) +
                   InstanceNameLen +
                   sizeof(USHORT) + 7) & ~7;

    //
    // if user passed a NULL buffer or one that is smaller than the
    // size needed to hold the WNODE then we allocate a small buffer on
    // its behalf and call to obtain the size needed.
    if ((OutBuffer == NULL) ||
        (BufferSize < BufferNeeded))
    {
        BufferSize = BufferNeeded;
    }

    Buffer = WmipAlloc(BufferSize);
    if (Buffer == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    //
    Wnode = (PWNODE_SINGLE_INSTANCE)Buffer;
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                  VariableData));
    WmipBuildWnodeHeader(&Wnode->WnodeHeader, 
                         BufferNeeded,
                         WNODE_FLAG_SINGLE_INSTANCE,
                         DataBlockHandle);

    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData);
    Wnode->DataBlockOffset = BufferNeeded;

    //
    // Copy InstanceName into the WnodeSingleInstance for the query.
    //
    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;
    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipFree(Buffer);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    Status = WmipSendWmiRequest(
                                WMI_GET_SINGLE_INSTANCE,
                                (PWNODE_HEADER)Wnode,
                                BufferNeeded,
                                Wnode,
                                BufferSize,
                                &RetSize);

    if (Status == ERROR_SUCCESS)
    {
        //
        // Successful return, we either have success or a buffer too small
        //
        if ((RetSize < sizeof(WNODE_HEADER) ||
            ((RetSize >= sizeof(ULONG)) &&
             (RetSize < Wnode->WnodeHeader.BufferSize))))
        {
            //
            // if we get an incosistent WNODE back this may indicate a
            // problem with the WMI KM code
            //
            Status = ERROR_WMI_DP_FAILED;
            WmipAssert(FALSE);
         } else {
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_INTERNAL)
            {
                //
                // If this is an internal guid, try the call internally
                //
                Wnode->WnodeHeader.Flags &= ~WNODE_FLAG_INTERNAL;
                Wnode->WnodeHeader.BufferSize = BufferNeeded;
                Status = WmipInternalProvider( WmiGetSingleInstance,
                                          (PWNODE_HEADER)Wnode,
                                          BufferSize,
                                          Wnode,
                                          &RetSize);
                                          
                if (Status != ERROR_SUCCESS)
                {
                    goto done;
                }
            } 
    
            if (Wnode->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL)
            {
                //
                // Our buffer was too small so try to return the size needed
                //
                Status = ERROR_INSUFFICIENT_BUFFER;
                try
                {
                    *InOutBufferSize = ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            } else {
                //
                // We have a result from our query so we just copy back
                // the results.
                //
                try
                {
                    if (*InOutBufferSize >= RetSize)
                    {
                        memcpy(OutBuffer, Wnode, RetSize);
                    } else {
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }
                    *InOutBufferSize = RetSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    
done:
    WmipFree(Buffer);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN LPCWSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;
    WNODE_TOO_SMALL WnodeTooSmall;
    ULONG i;
    ULONG OutBufferSize;
    ULONG QsiMultipleSize;
    ULONG Len;
    PWMIQSIMULTIPLE QsiMultiple;
    PWNODE_HEADER Wnode;
    ULONG RetSize;
    HANDLE Handle;
    
    WmipInitProcessHeap();
    
    if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
    {
        QsiMultipleSize = sizeof(WMIQSIMULTIPLE) + 
                                     ((HandleCount-1)*sizeof(WMIQSIINFO));
                                 
        QsiMultiple = WmipAlloc(QsiMultipleSize);
        if (QsiMultiple != NULL)
        {
            try
            {
                OutBufferSize = *InOutBufferSize;

                QsiMultiple->QueryCount = HandleCount;
                for (i = 0; i < HandleCount; i++)
                {
                    Handle = HandleList[i];

                    WmipSetHandle3264(QsiMultiple->QsiInfo[i].Handle, Handle);
#if defined(_WIN64)             
                    QsiMultiple->QsiInfo[i].InstanceName.Buffer = (PWSTR)InstanceNames[i];
#else
                    QsiMultiple->QsiInfo[i].InstanceName.Dummy = (ULONG64)(IntToPtr(PtrToInt(InstanceNames[i])));
#endif

                    Len = wcslen(InstanceNames[i]) * sizeof(WCHAR);
                    QsiMultiple->QsiInfo[i].InstanceName.Length = (USHORT)Len;
                    QsiMultiple->QsiInfo[i].InstanceName.MaximumLength = (USHORT)Len;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                WmipFree(QsiMultiple);
                SetLastError(ERROR_NOACCESS);
                return(ERROR_NOACCESS);
            }
            
            if (OutBufferSize < sizeof(WNODE_TOO_SMALL))
            {
                Wnode = (PWNODE_HEADER)&WnodeTooSmall;
                OutBufferSize = sizeof(WNODE_TOO_SMALL);
            } else {
                Wnode = (PWNODE_HEADER)OutBuffer;
            }
            
            Status = WmipSendWmiKMRequest(NULL,
                                          IOCTL_WMI_QSI_MULTIPLE,
                                          QsiMultiple,
                                          QsiMultipleSize,
                                          Wnode,
                                          OutBufferSize,
                                          &RetSize,
                                          NULL);
                                                  
            WmipFree(QsiMultiple);

            if (Status == ERROR_SUCCESS)
            {
                if (Wnode->Flags & WNODE_FLAG_TOO_SMALL)
                {       
                    RetSize = ((PWNODE_TOO_SMALL)(Wnode))->SizeNeeded;
                    Status = ERROR_INSUFFICIENT_BUFFER;
                }

                try
                {
                    *InOutBufferSize = RetSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }
            }
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN LPCSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
)
{
    ULONG Status;
    ULONG Linkage;
    PWNODE_SINGLE_INSTANCE Wnode;
    PWCHAR Ptr;
    PWCHAR *UnicodeInstanceNames;
    ULONG UnicodeInstanceNamesSize;
    ULONG i;
    
    WmipInitProcessHeap();
    
    if ((HandleCount != 0) && (HandleCount < QUERYMULIPLEHANDLELIMIT))
    {
        UnicodeInstanceNamesSize = HandleCount * sizeof(PWCHAR);
        UnicodeInstanceNames = WmipAlloc(UnicodeInstanceNamesSize);
        if (UnicodeInstanceNames != NULL)
        {
            memset(UnicodeInstanceNames, 0, UnicodeInstanceNamesSize);
            for (i = 0; i < HandleCount; i++)
            {
                Status = AnsiToUnicode(InstanceNames[i], 
                                       &UnicodeInstanceNames[i]);
                if (Status != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
            
            Status = WmiQuerySingleInstanceMultipleW(HandleList,
                                             UnicodeInstanceNames,
                                             HandleCount,
                                             InOutBufferSize,
                                             OutBuffer);

            if ((Status == ERROR_SUCCESS) && (*InOutBufferSize > 0))
            {
                Linkage = 1;
                Wnode = (PWNODE_SINGLE_INSTANCE)OutBuffer;
                while ((Status == ERROR_SUCCESS) && (Linkage != 0))
                {
                    Ptr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
                    Status = WmipCountedUnicodeToCountedAnsi(Ptr, (PCHAR)Ptr);
                    Linkage = Wnode->WnodeHeader.Linkage;
                    Wnode = (PWNODE_SINGLE_INSTANCE)OffsetToPtr(Wnode, Linkage);
                }
            }

Cleanup:            
            for (i = 0; i < HandleCount; i++)
            {
                if (UnicodeInstanceNames[i] != NULL)
                {
                    if (UnicodeInstanceNames[i] != NULL)
                    {
                        WmipFree(UnicodeInstanceNames[i]);
                    }
                }
            }
            WmipFree(UnicodeInstanceNames);
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        Status = ERROR_INVALID_PARAMETER;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*++

Routine Description:

    ANSI thunk to WMISetSingleInstanceW

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR InstanceNameUnicode;

    WmipInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiSetSingleInstanceW(DataBlockHandle,
                                    InstanceNameUnicode,
                                    Version,
                                    ValueBufferSize,
                                    ValueBuffer);
        if (InstanceNameUnicode != NULL)
        {
            WmipFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*+++

Routine Description:

    This routine will send a set single instance request to the appropriate
    data provider to request changing all data items for a single instances
    of a data block. A data provider is free to silently ignore any change
    requests or only change some data items within an instance.

Arguments:

    DataBlockHandle - Handle to data block

    InstanceName - name of the instance for which data is being set

    Version - specifies the version of the data block being passed in
              ValueBuffer

    ValueBufferSize - on entry has the size of the data block containing the
                 new values for the instance of the data block passed in
                 ValueBuffer

    ValueBuffer - passes new values for instance

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_INSTANCE Wnode;
    ULONG InstanceNameLen;
    ULONG Status;
    PWCHAR WnodePtr;
    ULONG BufferSize;
    ULONG RetSize;

    WmipInitProcessHeap();

    //
    // Validate input parameters
    if ((InstanceName == NULL) ||
        (ValueBuffer == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // The WNODE_SINGLE_INSTANCE that we need to send to the data provider
    // must be large enough to hold the WNODE, the instance name of the
    // item being set, padding so that the data block is on a 8 byte
    // boundry and space for the new data block.
    BufferSize = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                 InstanceNameLen + sizeof(USHORT) + ValueBufferSize + 7;

    Wnode = WmipAlloc(BufferSize);
    if (Wnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    //
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData));
    WmipBuildWnodeHeader(&Wnode->WnodeHeader,
                         BufferSize,
                         WNODE_FLAG_SINGLE_INSTANCE,
                         DataBlockHandle);
    Wnode->WnodeHeader.Version = Version;
    
    Wnode->SizeDataBlock = ValueBufferSize;
    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                             VariableData);

    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;

    Wnode->DataBlockOffset = (Wnode->OffsetInstanceName +
                              InstanceNameLen + sizeof(USHORT) + 7) & ~7;

    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
        memcpy((PCHAR)Wnode + Wnode->DataBlockOffset,
                ValueBuffer,
                ValueBufferSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipFree(Wnode);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Send down the set request and reprot the results
    //
    Status = WmipSendWmiRequest(
                                    WMI_SET_SINGLE_INSTANCE,
                                    (PWNODE_HEADER)Wnode,
                                    BufferSize,
                                    Wnode,
                                    ValueBufferSize,
                                    &RetSize);
    WmipFree(Wnode);
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*++

Routine Description:

    ANSI thunk to WMISetSingleItemA

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR InstanceNameUnicode;

    WmipInitProcessHeap();

    InstanceNameUnicode = NULL;
    Status = AnsiToUnicode(InstanceName, &InstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiSetSingleItemW(DataBlockHandle,
                                    InstanceNameUnicode,
                                    DataItemId,
                                    Version,
                                    ValueBufferSize,
                                    ValueBuffer);
        if (InstanceNameUnicode != NULL)
        {
            WmipFree(InstanceNameUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN LPVOID ValueBuffer
    )
/*+++

Routine Description:

    This routine will send a set single item request to the appropriate data
    provider to request changing a specific data item within a specific
    instance of a data block. A data provider can silently ignore a change
    request.

Arguments:

    DataBlockHandle - Handle to data block

    InstanceName - name of the instance for which data is being set

    Version - specifies the version of the data block being passed in
              ValueBuffer

    DataItemId - Data item id of item to set

    ValueBufferSize - on entry has the size of the new value for the
                      data item which is passed in pBuffer.

    ValueBuffer - passes new value for data item

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_SINGLE_ITEM Wnode;
    ULONG InstanceNameLen;
    ULONG Status;
    PBYTE WnodeBuffer;
    PWCHAR WnodePtr;
    ULONG BufferSize;
    ULONG RetSize;

    WmipInitProcessHeap();

    //
    // Validate passed parameters
    //
    if ((InstanceName == NULL) ||
        (ValueBuffer == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    try
    {
        InstanceNameLen = wcslen(InstanceName) * sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    BufferSize = FIELD_OFFSET(WNODE_SINGLE_ITEM, VariableData) +
                 InstanceNameLen + sizeof(USHORT) +
                 ValueBufferSize + 7;

    Wnode = WmipAlloc(BufferSize);
    if (Wnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE we want to send to the DP
    memset(Wnode, 0, FIELD_OFFSET(WNODE_SINGLE_ITEM, VariableData));
    WmipBuildWnodeHeader(&Wnode->WnodeHeader,
                         BufferSize,
                         WNODE_FLAG_SINGLE_ITEM,
                         DataBlockHandle);
    Wnode->WnodeHeader.Version = Version;
    
    Wnode->ItemId = DataItemId;
    Wnode->SizeDataItem = ValueBufferSize;

    Wnode->OffsetInstanceName = FIELD_OFFSET(WNODE_SINGLE_ITEM,VariableData);
    Wnode->DataBlockOffset = (Wnode->OffsetInstanceName +
                             InstanceNameLen + sizeof(USHORT) + 7) & ~7;

    WnodePtr = (PWCHAR)OffsetToPtr(Wnode, Wnode->OffsetInstanceName);
    *WnodePtr++ = (USHORT)InstanceNameLen;
    try
    {
        memcpy(WnodePtr, InstanceName, InstanceNameLen);
        memcpy((PCHAR)Wnode + Wnode->DataBlockOffset, 
               ValueBuffer, 
               ValueBufferSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = ERROR_INVALID_PARAMETER;
        WmipFree(Wnode);
        SetLastError(Status);
        return(Status);
    }

    //
    // Send down the request and report the result
    //
    Status = WmipSendWmiRequest(
                                    WMI_SET_SINGLE_ITEM,
                                    (PWNODE_HEADER)Wnode,
                                    BufferSize,
                                    Wnode,
                                    ValueBufferSize,
                                    &RetSize);

    WmipFree(Wnode);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN LPVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    )
/*++

Routine Description:

    ANSI thunk to WmiExecuteMethodW

    NOTE: This api will not translate any fields in the returned WNODE
          from unicode to ANSI.
--*/
{
    ULONG Status;
    LPWSTR MethodInstanceNameUnicode;
    LPWSTR InputInstanceNameUnicode;
    PWCHAR Ptr;

    WmipInitProcessHeap();

    if (MethodInstanceName == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    MethodInstanceNameUnicode = NULL;
    Status = AnsiToUnicode(MethodInstanceName,
                           &MethodInstanceNameUnicode);
    if (Status == ERROR_SUCCESS)
    {
        Status = WmiExecuteMethodW(MethodDataBlockHandle,
                                   MethodInstanceNameUnicode,
                                   MethodId,
                                   InputValueBufferSize,
                                   InputValueBuffer,
                                   OutputBufferSize,
                                   OutputBuffer);

        if (MethodInstanceNameUnicode != NULL)
        {
            WmipFree(MethodInstanceNameUnicode);
        }
    }

    return(Status);
}

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN LPVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    )
/*+++

Routine Description:

    This routine will invoke a method on a WMI data provider. A method is a
    call to have the data provider do something rather than a query or a
    set. A WNODE_SINGLE_INSTANCE is built as the input parameters to a
    method and a WNODE_SINGLE_INSTANCE is returned as output from a method.

Arguments:

    MethodDataBlockHandle - Handle to data block that contains method

    MethodInstanceName - Name of instance of data block on which the method
                         should be executed.

    MethodId - Id value that specifies which method within the guid to
               execute.

    InputValueBufferSize - on entry has the size of the data block containing the
                 values for the instance of the data block passed in
                 ValueBuffer that serves as the input parameters

    InputValueBuffer - passes new values for instance that serves as the
                 input parameters. This can be NULL if there is no input

    *OutputBufferSize - on entry has the maxiumum size in bytes that can be
              written into Buffer and on return contains the actual
                  number of bytes written into Buffer. This can be NULL
                  if no output is expected to be returned, however if output
                  is returned the caller will not know how large a buffer
                  is needed to return it.

    OutputBuffer - buffer in which to return the output WNODE_SINGLE_INSTANCE.
                   This can be NULL if there is no output WNODE or the
                   caller wants to determine the size needed for the
                   output WNODE.

Return Value:

    Returns ERROR_SUCCESS or an error code.

---*/
{
    PWNODE_METHOD_ITEM MethodWnode;
    PWNODE_HEADER WnodeHeader;
    ULONG MethodInstanceNameLen;
    ULONG MethodWnodeSize, MethodWnodeOffset;
    ULONG Status;
    ULONG BufferSize;
    PWCHAR InstanceNamePtr;
    ULONG OutSize;
    PUCHAR DataPtr;
    ULONG BaseMethodWnodeSize;
    ULONG RetSize;

    WmipInitProcessHeap();

    //
    // Validate input parameters
    if ((MethodInstanceName == NULL) ||
        ((InputValueBuffer == NULL) &&
         (InputValueBufferSize != 0)))
    {
        //
        // All input parameters must be specifies or all input parameters
        // must NOT be specified.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Caller can pass a NULL output buffer when he only wants to get the
    // size needed for the output buffer or the method returns a void.
    //
    if (OutputBuffer == NULL)
    {
        BufferSize = 0;
    } else {
        if (OutputBufferSize != NULL)
        {
            try
            {
                BufferSize = *OutputBufferSize;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(ERROR_INVALID_PARAMETER);
            }

            if (BufferSize >= 0x80000000)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(ERROR_INVALID_PARAMETER);
            }
        } else {
            //
            // OutputBuffer is specified, but OutBufferSize is not specified
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return(ERROR_INVALID_PARAMETER);
        }
    }

    try
    {
        MethodInstanceNameLen = wcslen(MethodInstanceName) *
                                    sizeof(WCHAR);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // We need to allocate a buffer that is large enough for the
    // WNODE_METHOD_ITEM that contains the method call and any data passed
    // into the method

    //
    // Compute the size of the WNODE that can be returned from the provider
    BaseMethodWnodeSize = (FIELD_OFFSET(WNODE_METHOD_ITEM, VariableData) +
                       MethodInstanceNameLen + sizeof(USHORT) + 7) & ~7;

    OutSize = BaseMethodWnodeSize + BufferSize;

    //
    // Make sure we allocate enough room for the larger of the input or
    // output buffers.
    if (InputValueBufferSize > BufferSize)
    {
        BufferSize = InputValueBufferSize;
    }
    MethodWnodeSize = BaseMethodWnodeSize + BufferSize;

    MethodWnode = (PWNODE_METHOD_ITEM)WmipAlloc(MethodWnodeSize);
    if (MethodWnode == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build WNODE_METHOD_ITEM containing method being called
    //
    memset(MethodWnode, 0, FIELD_OFFSET(WNODE_METHOD_ITEM, VariableData));
    MethodWnode->MethodId = MethodId;
    MethodWnode->OffsetInstanceName = FIELD_OFFSET(WNODE_METHOD_ITEM,
                                                   VariableData);
    MethodWnode->DataBlockOffset = BaseMethodWnodeSize;
    InstanceNamePtr = (PWCHAR)OffsetToPtr(MethodWnode,
                                          MethodWnode->OffsetInstanceName);
    *InstanceNamePtr++ = (USHORT)MethodInstanceNameLen;
    try
    {
        memcpy(InstanceNamePtr,
                   MethodInstanceName,
                   MethodInstanceNameLen);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipFree(MethodWnode);
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if (InputValueBuffer != NULL)
    {
        MethodWnode->SizeDataBlock = InputValueBufferSize;
        DataPtr = (PUCHAR)OffsetToPtr(MethodWnode,
                                      MethodWnode->DataBlockOffset);
        try
        {
            memcpy(DataPtr, InputValueBuffer, InputValueBufferSize);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            WmipFree(MethodWnode);
            SetLastError(ERROR_INVALID_PARAMETER);
            return(ERROR_INVALID_PARAMETER);
        }
    }
    
    WmipBuildWnodeHeader(&MethodWnode->WnodeHeader,
                         MethodWnode->DataBlockOffset + 
                             MethodWnode->SizeDataBlock,
                         WNODE_FLAG_METHOD_ITEM,
                         MethodDataBlockHandle);

    Status = WmipSendWmiRequest(
                                    WMI_EXECUTE_METHOD,
                                    (PWNODE_HEADER)MethodWnode,
                                    MethodWnode->WnodeHeader.BufferSize,
                                    MethodWnode,
                                    OutSize,
                                    &RetSize);

    if ((Status == ERROR_SUCCESS) &&
        ((RetSize < sizeof(WNODE_TOO_SMALL) ||
         ((RetSize >= sizeof(ULONG)) &&
          (RetSize < MethodWnode->WnodeHeader.BufferSize)))))
    {
        Status = ERROR_WMI_DP_FAILED;
        WmipAssert(FALSE);
    }  
    
    if (Status == ERROR_SUCCESS)
    {
        WnodeHeader = (PWNODE_HEADER)MethodWnode;
        if (WnodeHeader->Flags & WNODE_FLAG_TOO_SMALL)
        {
            Status = ERROR_INSUFFICIENT_BUFFER;
            if (OutputBufferSize != NULL)
            {
                try
                {
                    *OutputBufferSize = ((PWNODE_TOO_SMALL)WnodeHeader)->SizeNeeded -
                                     BaseMethodWnodeSize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        } else {
            //
            // Success, return results to caller
            //
            try
            {
                if (OutputBufferSize != NULL)
                {
                    if (*OutputBufferSize >=  MethodWnode->SizeDataBlock)
                    {
                        if (OutputBuffer != NULL)
                        {
                            DataPtr = (PUCHAR)OffsetToPtr(MethodWnode,
                                               MethodWnode->DataBlockOffset);
                            memcpy(OutputBuffer,
                                   DataPtr,
                                   MethodWnode->SizeDataBlock);
                        }
                    } else {
                        Status = ERROR_INSUFFICIENT_BUFFER;
                    }

                    *OutputBufferSize = MethodWnode->SizeDataBlock;
                } else if (MethodWnode->SizeDataBlock != 0) {
                    Status = ERROR_INSUFFICIENT_BUFFER;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALID_PARAMETER;
            }
        }
    }

    WmipFree(MethodWnode);

    SetLastError(Status);
    return(Status);
}

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    )
/*+++

Routine Description:

    This routine frees a buffer allocated by WMI. This routine is typically
    used by applications that receive events via the Window message
    notification mechanism.

Arguments:

    Buffer is a buffer returned by WMI that the app wishes to free

Return Value:

---*/
{
    WmipInitProcessHeap();

    if (Buffer != NULL)
    {
        WmipDebugPrint(("WMI: WMIFreeBuffer(%x)\n", Buffer));
        WmipFree(Buffer);
    } else {
        WmipDebugPrint(("WMI: NULL passed to WMIFreeBuffer\n"));
    }
}

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
/*+++

Routine Description:

    ANSI thunk to NotificationRegistration

Return Value:

    Returns ERROR_SUCCESS or an error code

---*/
{
    return(WmipNotificationRegistration(Guid,
                                        Enable,
                                        DeliveryInfo,
                                        DeliveryContext,
                                        0,
                                        Flags,
                                        TRUE));

}

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
/*+++

Routine Description:

    This routine allows a data consumer to register or unregister for
    notification of events fired by WMI data providers. Notifications are
    delivered via callbackor via a posted meesage to a window.

Arguments:

    Guid is pointer to the guid whose events are being registered for

    Enable is TRUE if enabling notifications else FALSE. If FALSE the
        Destination and DestinationInformation parameters are ignored.

    DeliveryInfo has the callback function pointer or window handle to which
        to deliver the notifications for the guid.

    DeliveryContext has a context value or additional information to use
        when delivering the notification.

    Flags are a set of flags that define how the notification is delivered.
        DeliveryInfo and DeliveryContext have different meanings depending
        upon the value in Flags:

        NOTIFICATION_WINDOW_HANDLE is set when notifications for the guid
            are to be delivered by posting a message to the window handle
            passed in DeliveryInfo. The message posted is the value that
            is returned from the call to
            RegisterWindowMessage(WMINOTIFICATIONWINDOWMESSAGE) with the
            wParam set to the pointer to the Wnode containing the notification
            and lParam set to the context value passed in DeliveryContext.
            The caller MUST free the Wnode passed in wParam by calling
            WMIFreeBuffer.

        NOTIFICATION_CALLBACK_DIRECT is set when notifications for the
            guid are to be delivered by direct callback. Whenever a
            notification arrives WMI creates a new thread dedicated to
            calling the callback function with the notification. This
            mechanism provides the shortest latency from notification firing
            to notification delivery, although it is the most expensive
            mechanism. The callback function pointer is passed in DeliveryInfo
            and must conform to the prototype described by the type
            NOTIFICATIONCALLBACK. The context value passed in the callback
            is specified by the DeliveryContext parameter. WMI does not
            serialize calling the callback function so it must be reentrant.

        NOTIFICATION_CALLBACK_QUEUED is set when notifications for the
            guid are to be delivered by a queued callback. Whenever a
            notification arrives WMI places it at the end of an internal
            queue. A single thread monitors this queue and calls the callback
            function serially for each notification in the queue. This
            mechanism provides low overhead for event delivery, however
            notification delivery can be delayed if the callback function
            for an earlier notification does not complete quickly.
            The callback function pointer is passed in DeliveryInfo
            and must conform to the prototype described by the type
            NOTIFICATIONCALLBACK. The context value passed in the callback
            is specified by the DeliveryContext parameter. WMI does
            serialize calling the callback function so it need not be
            reentrant provided it is not also used for
            NOTIFICATION_CALLBACK_DIRECT notififications. NOTE THAT THIS
            IS NOT YET IMPLEMENTED.

        NOTIFICATION_TRACE_FLAG is set when the caller wishes to enable
            trace logging in the data provider for the guid. DeliveryInfo
            specifies the trace logger handle to be passed to the data
            provider. DeliveryContext is not used. No notifications are
            generated to the caller when this flag is set.


        Note that all of the above flags are mutually exclusive.

Return Value:

    Returns ERROR_SUCCESS or an error code

---*/
{
    return(WmipNotificationRegistration(Guid,
                                        Enable,
                                        DeliveryInfo,
                                        DeliveryContext,
                                        0,
                                        Flags,
                                        FALSE));

}

// TODO: Make WmiFile

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT PCHAR InstanceNames
    )
/*++

Routine Description:

    ANSI thunk to WMIFileHandleToInstanceNameW

--*/
{
    ULONG Status;
    PWCHAR InstanceNamesUnicode;
    PWCHAR WCharPtr;
    PCHAR Ansi, AnsiPtr;
    ULONG AnsiLen, AnsiSize;
    ULONG CharAvailable, CharReturned;
    ULONG AnsiStringSize;

    WmipInitProcessHeap();

    CharAvailable = *NumberCharacters;
    CharReturned = CharAvailable;

    do
    {
        //
        // We loop until we call with a buffer big enough to return
        // the entire list of instance names.
        InstanceNamesUnicode = WmipAlloc(CharReturned * sizeof(WCHAR));

        if (InstanceNamesUnicode == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            SetLastError(Status);
            return(Status);
        }

        Status = WmiFileHandleToInstanceNameW(DataBlockHandle,
                                              FileHandle,
                                              &CharReturned,
                                              InstanceNamesUnicode);

        if (Status != ERROR_INSUFFICIENT_BUFFER)
        {
            break;
        }

        WmipFree(InstanceNamesUnicode);
    } while (TRUE);

    //
    // CONSIDER: MB Strings
    if (Status == ERROR_SUCCESS)
    {
        //
        // Determine the size needed for the ansi buffer
        WCharPtr = InstanceNamesUnicode;
        AnsiSize = 1;
        while (*WCharPtr != UNICODE_NULL)
        {
            Status = AnsiSizeForUnicodeString(WCharPtr, &AnsiStringSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }

            AnsiSize += AnsiStringSize;
            WCharPtr += wcslen(WCharPtr)+1;
        }

        //
        // CONSIDER: MB String
        if (AnsiSize > CharAvailable)
        {
            Status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            //
            // Copy the list of unicode strings to ansi strings. End of list
            // is double NULL.
            AnsiPtr = InstanceNames;
            try
            {
                AnsiPtr[0] = 0;
                AnsiPtr[1] = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_NOACCESS;
                goto Done;
            }
            WCharPtr = InstanceNamesUnicode;
            while (*WCharPtr != UNICODE_NULL)
            {
                try
                {
                    Status = UnicodeToAnsi(WCharPtr, &AnsiPtr, &AnsiLen);
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }

                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;
                *AnsiPtr = 0;
                WCharPtr += wcslen(WCharPtr)+1;
            }
        }

Done:
        try
        {
            *NumberCharacters = AnsiSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = ERROR_NOACCESS;
        }
    }

    WmipFree(InstanceNamesUnicode);

    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT PWCHAR InstanceNames
    )
/*+++

Routine Description:

    This routine will return all of the WMI instance names provided for a
    data block within the device stack targeted by a file handle. Note
    that not all data providers will support this functionality.

Arguments:

    DataBlockHandle - Handle to data block

    FileHandle - handle to a device whose stack is targeted

    *NumberCharacters - On entry has maximum size in characters of Buffer. If
        ERROR_BUFFER_TOO_SMALL is returned then it returns with the number
        of character needed.

    InstanceNames - if successful, returns with a list of single null
        terminated strings which are the WMI instance names. The last instance
        name is double null terminated

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    PWMIFHTOINSTANCENAME FhToInstanceName;
    ULONG RetSize;
    ULONG Status;
    WCHAR LocalInstanceNames[2];
    ULONG BufferSize;
    ULONG SizeNeeded;
    WCHAR Suffix[MAX_PATH];
    ULONG SuffixLen, CharsNeeded;

    WmipInitProcessHeap();

    BufferSize = *NumberCharacters;

    //
    // Start off by assuming that there is only one instance name and so
    // only alloc space for that.
    //
    SizeNeeded = FIELD_OFFSET(WMIFHTOINSTANCENAME, InstanceNames) +
           (MAX_PATH * sizeof(WCHAR));
Again:
    FhToInstanceName = WmipAlloc(SizeNeeded + sizeof(WCHAR));
    if (FhToInstanceName == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);

    }

    WmipSetHandle3264(FhToInstanceName->FileHandle, FileHandle);
    WmipSetHandle3264(FhToInstanceName->KernelHandle, DataBlockHandle);

    Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_TRANSLATE_FILE_HANDLE,
                                  FhToInstanceName,
                                  FIELD_OFFSET(WMIFHTOINSTANCENAME,
                                               InstanceNames),
                                  FhToInstanceName,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);
    if (Status == ERROR_SUCCESS)
    {
        if (RetSize == sizeof(ULONG))
        {
            //
            // If buffer passed was too small then try with a bigger buffer
            //
            SizeNeeded = FhToInstanceName->SizeNeeded + sizeof(WCHAR);
            WmipFree(FhToInstanceName);
            goto Again;
        } else {
            if ((RetSize < sizeof(WMIFHTOINSTANCENAME)) ||
                (RetSize < (ULONG)(FhToInstanceName->InstanceNameLength +
                            FIELD_OFFSET(WMIFHTOINSTANCENAME, InstanceNames))))
            {
                //
                // WMI KM returned a bogus size which should not happen
                //
                Status = ERROR_WMI_DP_FAILED;
                WmipAssert(FALSE);
            } else {
                
                //
                // Copy the results back to the users buffer if 
                // there is enough space
                //
                SuffixLen = swprintf(Suffix, L"_%d",
                                     FhToInstanceName->BaseIndex);
                
                try
                {
                    CharsNeeded = (FhToInstanceName->InstanceNameLength /
                                         sizeof(WCHAR)) + SuffixLen + 1;
                    
                    *NumberCharacters = CharsNeeded;
                    if (BufferSize >= FhToInstanceName->InstanceNameLength)
                    {
                        wcscpy(InstanceNames,
                               &FhToInstanceName->InstanceNames[0]);
                        wcscat(InstanceNames, Suffix);
                        InstanceNames[CharsNeeded-2] = UNICODE_NULL;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }

    WmipFree(FhToInstanceName);
    SetLastError(Status);

    return(Status);

}

ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *InOutGuidCount
    )
/*++

Routine Description:

    This routine will enumerate all of the guids that are
    registered with WMI.

Arguments:

    GuidList is a pointer to an array of guids that is returned with the

    *GuidCount on entry is the number of guids that can be written to
        GuidList and if ERROR_SUCCESS is returned it has the actual number
        of guids written to GuidList. If ERROR_MORE_DATA is returned
        it has the total number of guids that are available to be returned.


Return Value:

    ERROR_SUCCESS if all guids returned, ERROR_MORE_DATA if not all guids
    were returned or another error code on error

--*/
{
    ULONG Status;
    PWMIGUIDLISTINFO GuidListInfo;
    ULONG GuidCount;
    ULONG SizeNeeded;
    ULONG RetSize;
    ULONG i;

    WmipInitProcessHeap();
    
    try
    {
        GuidCount = *InOutGuidCount;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    if ((GuidList == NULL) && (GuidCount != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }
    
    //
    // Allocate space for returning guids
    //
    SizeNeeded = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                     GuidCount * sizeof(WMIGUIDPROPERTIES);
    
    GuidListInfo = WmipAlloc(SizeNeeded);
    if (GuidListInfo != NULL)
    {
        Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_ENUMERATE_GUIDS,
                                  GuidListInfo,
                                  SizeNeeded,
                                  GuidListInfo,
                                  SizeNeeded,
                                  &RetSize,
                                  NULL);
                              
        if (Status == ERROR_SUCCESS)
        {
            if ((RetSize < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) ||
                (RetSize < (FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                            GuidListInfo->ReturnedGuidCount * sizeof(WMIGUIDPROPERTIES))))
            {
                //
                // WMI KM returned to us a bad size which should not happen
                //
                Status = ERROR_WMI_DP_FAILED;
                WmipAssert(FALSE);
            } else {
                try
                {
                    for (i = 0; i < GuidListInfo->ReturnedGuidCount; i++)
                    {
                        GuidList[i] = GuidListInfo->GuidList[i].Guid;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                }
                
                try
                {
                    //
                    // Return the total guid count which is also the actual
                    // guid count if we returned all guids correctly
                    //
                    *InOutGuidCount = GuidListInfo->TotalGuidCount;
                    if (GuidListInfo->ReturnedGuidCount != GuidListInfo->TotalGuidCount)
                    {
                        //
                        // If we did not return all of the guids, change 
                        // return status to something more appropriate
                        //
                        Status = ERROR_MORE_DATA;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_INVALID_PARAMETER;
                }                    
            }
        }
                              
                              
        WmipFree(GuidListInfo);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    SetLastError(Status);
    return(Status);
}

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT PCHAR InstanceName,
    IN ULONG InstanceNameLength,
    IN PCHAR DevInst,
    IN ULONG InstanceIndex
    )
/*++

Routine Description:

    This routine will convert a device instance name and an instance index
    into a WMI instance name.

Arguments:

    InstanceName is a pointer to a buffer that returns with the WMI instance
        name if the buffer is large enough

    InstanceNameLength has the number of characters that can be written into
        InstanceName

    DevInst is the Device Instance Name

    InstanceIndex is the instance index

Return Value:

    number of characters that compose the WMI instance name

--*/
{
    CHAR Temp[MAX_PATH];
    ULONG SizeNeeded;

    WmipInitProcessHeap();

    sprintf(Temp, "_%d", InstanceIndex);
    SizeNeeded = strlen(Temp) + strlen(DevInst) + 1;
    if (InstanceNameLength >= SizeNeeded)
    {
        strcpy(InstanceName, DevInst);
        strcat(InstanceName, Temp);
    }
    return(SizeNeeded);
}

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT PWCHAR InstanceName,
    IN ULONG InstanceNameLength,
    IN PWCHAR DevInst,
    IN ULONG InstanceIndex
    )
{
    WCHAR Temp[MAX_PATH];
    ULONG SizeNeeded;

    WmipInitProcessHeap();

    swprintf(Temp, L"_%d", InstanceIndex);
    SizeNeeded = wcslen(Temp) + wcslen(DevInst) + 1;
    if (InstanceNameLength >= SizeNeeded)
    {
        wcscpy(InstanceName, DevInst);
        wcscat(InstanceName, Temp);
    }
    return(SizeNeeded);
}

ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE DataBlockHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    )
/*++

Routine Description:

    This routine will query information about a specific guid based upon
    the guid handle passed

Arguments:

    GuidHandle is the handle to the GUID whose information is being queried

    GuidInfo returns with the guid information

Return Value:

    ERROR_SUCCESS or error code

--*/
{
    WMIQUERYGUIDINFO QueryGuidInfo;
    ULONG Status;
    ULONG RetSize;

    WmipInitProcessHeap();

    WmipSetHandle3264(QueryGuidInfo.KernelHandle, DataBlockHandle);
    Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_QUERY_GUID_INFO,
                                  &QueryGuidInfo,
                                  sizeof(QueryGuidInfo),
                                  &QueryGuidInfo,
                                  sizeof(QueryGuidInfo),
                                  &RetSize,
                                  NULL);

    if (Status == ERROR_SUCCESS)
    {
        if (RetSize == sizeof(QueryGuidInfo))
        {
            try
            {
                GuidInfo->IsExpensive = QueryGuidInfo.IsExpensive;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                SetLastError(ERROR_NOACCESS);
                return(ERROR_NOACCESS);
            }
        } else {
            //
            // WMI KM returned an invalid size which should not happen
            //
            Status = ERROR_WMI_DP_FAILED;
            WmipAssert(FALSE);
        }
    }

    SetLastError(Status);
    return(Status);
}



ULONG
WMIAPI
WmiReceiveNotificationsW(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
)
{
    return(WmipReceiveNotifications(HandleCount,
                                    HandleList,
                                    Callback,
                                    DeliveryContext,
                                    FALSE,
                                    RECEIVE_ACTION_NONE,
                                    NULL,
                                    NULL));
}

ULONG
WMIAPI
WmiReceiveNotificationsA(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
)
{
    return(WmipReceiveNotifications(HandleCount,
                                    HandleList,
                                    Callback,
                                    DeliveryContext,
                                    TRUE,
                                    RECEIVE_ACTION_NONE,
                                    NULL,
                                    NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\handle.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:
    
    Implements WMI GUID handle management code

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include <rpc.h>

BOOLEAN WmipIsNumber(
    LPCWSTR String
    )
{
    while (*String != UNICODE_NULL)
    {
        if ((*String < L'0') || 
            (*String++ > L'9'))
        {
            return(FALSE);
        }
    }
    return(TRUE);
}


#define WmipWStringSizeInBytes(string) \
    ( ( (wcslen((string)) + 1) * sizeof(WCHAR) ) )


ULONG WmipBaseCookieIndex;
LIST_ENTRY WmipCookieHead = {&WmipCookieHead, &WmipCookieHead};


PNOTIFYCOOKIE WmipFindCookieByGuid(
    LPGUID Guid,
    PNOTIFYCOOKIECHUNK *Chunk
    )
/*+++

Routine Description:

    This routine assumes the PM critical section is held
        
Arguments:


Return Value:

---*/
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIECHUNK CookieChunk;
    PNOTIFYCOOKIE Cookie;
    ULONG i;
    
    CookieList = WmipCookieHead.Flink;
    while (CookieList != &WmipCookieHead)
    {
        CookieChunk = CONTAINING_RECORD(CookieList,
                                        NOTIFYCOOKIECHUNK,
                                        Next);

        for (i = 0; i < NOTIFYCOOKIESPERCHUNK; i++)
        {
            Cookie = &CookieChunk->Cookies[i];
            if ((Cookie->InUse) &&
                (IsEqualGUID(Guid, &Cookie->Guid)))
            {
                *Chunk = CookieChunk;
                return(Cookie);
            }
        }
        
        CookieList = CookieList->Flink;
    }
    return(NULL);
}

ULONG WmipAllocateCookie(
    PVOID DeliveryInfo,
    PVOID DeliveryContext,
    LPGUID Guid
    )
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIECHUNK CookieChunk;
    PNOTIFYCOOKIE Cookie;
    ULONG i;
    ULONG CheckSlot, FreeSlot;
    
    WmipEnterPMCritSection();

    while (1)
    {
        CookieList = WmipCookieHead.Flink;
        while (CookieList != &WmipCookieHead)
        {
            CookieChunk = CONTAINING_RECORD(CookieList,
                                            NOTIFYCOOKIECHUNK,
                                            Next);
            if (! CookieChunk->Full)
            {
                FreeSlot = CookieChunk->FreeSlot;
                for (i = 0; i < NOTIFYCOOKIESPERCHUNK; i++)
                {
                    CheckSlot = (FreeSlot + i) % NOTIFYCOOKIESPERCHUNK;
                    if (! CookieChunk->Cookies[CheckSlot].InUse)
                    {
                        //
                        // We found a free cookie slot
                        Cookie = &CookieChunk->Cookies[CheckSlot];
                        Cookie->InUse = TRUE;
                        CookieChunk->FreeSlot = (USHORT)((CheckSlot + 1) % NOTIFYCOOKIESPERCHUNK);
                        WmipLeavePMCritSection();
                        Cookie->DeliveryInfo = DeliveryInfo;
                        Cookie->DeliveryContext = DeliveryContext;
                        Cookie->Guid = *Guid;
                        return(CookieChunk->BaseSlot + CheckSlot + 1);
                    }
                }
            
                //
                // All slots were full so mark as such
                CookieChunk->Full = TRUE;
            }
            CookieList = CookieList->Flink;
        }
    
        //
        // No free cookie slots, allocate a new chunk
        CookieChunk = WmipAlloc(sizeof(NOTIFYCOOKIECHUNK));
        if (CookieChunk == NULL)
        {
            WmipLeavePMCritSection();
            return(0);
        }
        
        memset(CookieChunk, 0, sizeof(NOTIFYCOOKIECHUNK));
        CookieChunk->BaseSlot = WmipBaseCookieIndex;
        WmipBaseCookieIndex += NOTIFYCOOKIESPERCHUNK;
        InsertHeadList(&WmipCookieHead, &CookieChunk->Next);
    }
}

PNOTIFYCOOKIE WmipFindCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PNOTIFYCOOKIECHUNK *Chunk
    )
/*+++

Routine Description:

    This routine assumes the PM critical section is held
        
Arguments:


Return Value:

---*/
{
    PLIST_ENTRY CookieList;
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;
    
    WmipAssert(CookieSlot != 0);
    
    CookieSlot--;
    
    CookieList = WmipCookieHead.Flink;
    while (CookieList != &WmipCookieHead)
    {
        CookieChunk = CONTAINING_RECORD(CookieList,
                                        NOTIFYCOOKIECHUNK,
                                        Next);
                                    
        if ((CookieSlot >= CookieChunk->BaseSlot) &&
            (CookieSlot < (CookieChunk->BaseSlot + NOTIFYCOOKIESPERCHUNK)))
        {
            Cookie = &CookieChunk->Cookies[CookieSlot - CookieChunk->BaseSlot];
            if (Guid != NULL)
            {
                if ((! Cookie->InUse) ||
                    (! IsEqualGUID(&Cookie->Guid, Guid)))
                {
                    Cookie = WmipFindCookieByGuid(Guid, &CookieChunk);
                }
            } else {
                if (! (Cookie->InUse) )
                    return NULL;
            }
            
            *Chunk = CookieChunk;
            return(Cookie);
        }
        
        CookieList = CookieList->Flink;
    }
    
    if (Guid != NULL)
    {
        Cookie = WmipFindCookieByGuid(Guid, &CookieChunk);
    } else {
        Cookie = NULL;
    }
    
    return(Cookie);
}

void WmipFreeCookie(
    ULONG CookieSlot
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;
    
    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, NULL, &CookieChunk);
    if (Cookie != NULL)
    {
        Cookie->InUse = FALSE;
        CookieChunk->Full = FALSE;
        CookieChunk->FreeSlot = (USHORT)(CookieSlot - CookieChunk->BaseSlot - 1);
    }
    WmipLeavePMCritSection();
}

void
WmipGetGuidInCookie(
    ULONG CookieSlot,
    LPGUID Guid
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;

    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, NULL, &CookieChunk);
    if (Cookie != NULL)
    {
        *Guid = Cookie->Guid;
    }
    WmipLeavePMCritSection();

    return;
}



BOOLEAN WmipLookupCookie(
    ULONG CookieSlot,
    LPGUID Guid,
    PVOID *DeliveryInfo,
    PVOID *DeliveryContext
    )
{
    PNOTIFYCOOKIE Cookie;
    PNOTIFYCOOKIECHUNK CookieChunk;    
    
    WmipEnterPMCritSection();
    Cookie = WmipFindCookie(CookieSlot, Guid, &CookieChunk);
    if (Cookie != NULL)
    {
        *DeliveryInfo = Cookie->DeliveryInfo;
        *DeliveryContext = Cookie->DeliveryContext;
    }
    WmipLeavePMCritSection();
    
    return(Cookie != NULL);
}


#if DBG
PCHAR GuidToStringA(
    PCHAR s,
    LPGUID piid
    )
{
    GUID XGuid = *piid;
    
    sprintf(s, "%x-%x-%x-%x%x%x%x%x%x%x%x",
               XGuid.Data1, XGuid.Data2, 
               XGuid.Data3,
               XGuid.Data4[0], XGuid.Data4[1],
               XGuid.Data4[2], XGuid.Data4[3],
               XGuid.Data4[4], XGuid.Data4[5],
               XGuid.Data4[6], XGuid.Data4[7]);

    return(s);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\intrnldp.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    intrnldp.c

Abstract:

    Implements WMI internal data provider

Author:

    21-Feb-1998 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "wmidata.h"
#include <cfgmgr32.h>

#define INSTANCE_INFO_GUID_INDEX 0
#define ENUMERATE_GUIDS_GUID_INDEX 1
#define DEFAULT_GUID_COUNT        100

GUID WmipInternalGuidList[] = 
{
    INSTANCE_INFO_GUID,
    ENUMERATE_GUIDS_GUID
};

#define WmipInternalGuidCount  (sizeof(WmipInternalGuidList) / sizeof(GUID))

PWCHAR GuidToWString(
    PWCHAR s,
    LPGUID piid
    )
{
    swprintf(s, (L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
               piid->Data1, piid->Data2,
               piid->Data3,
               piid->Data4[0], piid->Data4[1],
               piid->Data4[2], piid->Data4[3],
               piid->Data4[4], piid->Data4[5],
               piid->Data4[6], piid->Data4[7]);

    return(s);
}

ULONG WmipFindGuid(
    LPGUID Guid
    )
{
    ULONG i;
    
    for (i = 0; i < WmipInternalGuidCount; i++)
    {
        if (memcmp(Guid, &WmipInternalGuidList[i], sizeof(GUID)) == 0)
        {
            break;
        }
    }
    return(i);
}

typedef
DWORD
(*PCMGETDEVNODEREGISTRYPROPERTYW)(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
typedef
DWORD
(*PCMLOCATEDEVNODEW)(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
     
typedef
DWORD
(*PCMLOCATEDEVNODEA)(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
#ifdef UNICODE
#define PCMLOCATEDEVNODE PCMLOCATEDEVNODEW
#else
#define PCMLOCATEDEVNODE PCMLOCATEDEVNODEA
#endif

     
void WmipGetDevInstProperty(
    IN DEVINST DevInst,
    IN ULONG Property,
    IN OUT PBOOLEAN BufferFull,
    IN OUT PUCHAR *OutBuffer,
    IN OUT PULONG BufferLeft,
    IN OUT PULONG BufferNeeded,
    IN PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty
    )
{
    PWCHAR WCharPtr;
    PUCHAR PropertyBuffer;
    ULONG PropertyBufferLength;
    ULONG Type;
    ULONG Status;
    ULONG BufferUsed;
    ULONG Size;
#ifdef MEMPHIS
    ULONG PropertyBufferLengthAnsi;
    PCHAR PropertyBufferAnsi;
    CHAR AnsiBuffer[MAX_PATH];
#endif
    
#ifdef MEMPHIS
    PropertyBufferAnsi = AnsiBuffer;
    PropertyBufferLengthAnsi = sizeof(AnsiBuffer);
    Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                             Property,
                                             &Type,
                                             PropertyBufferAnsi,
                                             &PropertyBufferLengthAnsi,
                                             0);
    if (Status == CR_BUFFER_SMALL)
    {
        PropertyBufferAnsi = WmipAlloc(PropertyBufferLengthAnsi);
        if (PropertyBufferAnsi != NULL)
        {
            Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                                   Property,
                                                   &Type,
                                                   PropertyBufferAnsi,
                                                   &PropertyBufferLengthAnsi,
                                                   0);            
        } else {
            Status = CR_OUT_OF_MEMORY;
        }
    }
    
    if (Status == CR_SUCCESS)
    {
        if (UnicodeSizeForAnsiString(PropertyBufferAnsi,
                                     &Size) != ERROR_SUCCESS)
        {   
            Status = CR_FAILURE;
        }
    }
#endif

    if ((*BufferFull) || (*BufferLeft == 0))
    {
        PropertyBufferLength = 0;
        PropertyBuffer = NULL;
    } else {
        PropertyBufferLength = *BufferLeft - sizeof(USHORT);
        PropertyBuffer = *OutBuffer + sizeof(USHORT);
    }
    
#ifdef MEMPHIS
    if (Status == CR_SUCCESS)
    {
        if (PropertyBufferLength >= Size)
        {
            if (AnsiToUnicode(PropertyBufferAnsi,
                              (PWCHAR *)&PropertyBuffer) != ERROR_SUCCESS)
            {
                Status = CR_FAILURE;
            }
        } else {
            Status = CR_BUFFER_SMALL;
        }
        PropertyBufferLength = Size;        
    }
    
    if (PropertyBufferAnsi != AnsiBuffer)
    {
        WmipFree(PropertyBufferAnsi);
    }
#else
    Status = (*CMGetDevNodeRegistryProperty)(DevInst,
                                             Property,
                                             &Type,
                                             PropertyBuffer,
                                             &PropertyBufferLength,
                                             0);
#endif

    BufferUsed = PropertyBufferLength + sizeof(USHORT);
    if (Status == CR_SUCCESS) 
    {
        PropertyBuffer -= sizeof(USHORT);
        *((PUSHORT)PropertyBuffer) = (USHORT)PropertyBufferLength;
        *BufferLeft -= BufferUsed;
        *OutBuffer += BufferUsed;
        *BufferNeeded += BufferUsed;
    } else if (Status == CR_BUFFER_SMALL) {
        *BufferNeeded += BufferUsed;                
        *BufferFull = TRUE;
    } else {
        *BufferNeeded += 2;
        if ((! *BufferFull) && (*BufferLeft >= sizeof(USHORT)))
        {
            PropertyBuffer -= sizeof(USHORT);
            *((PUSHORT)PropertyBuffer) = 0;
            *BufferLeft -= sizeof(USHORT);
            *OutBuffer += sizeof(USHORT);
        } else {
            *BufferFull = TRUE;
        }
    }    
}


ULONG WmipGetDevInstInfo(
    PWCHAR DevInstName,
    ULONG MaxSize,
    PUCHAR OutBuffer,
    ULONG *RetSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{
    PUCHAR Buffer;
    DEVINST DevInst;
    ULONG Status;
    ULONG BufferNeeded;
    ULONG BufferLeft;
    BOOLEAN BufferFull;
    PWCHAR WCharPtr;
#ifdef MEMPHIS
    PCHAR AnsiDevInstName;
#endif

    // TODO: Memphis string translations
    
#ifdef MEMPHIS
    AnsiDevInstName = NULL;
    Status = UnicodeToAnsi(DevInstName,
                           &AnsiDevInstName,
                           NULL);
           
    if (Status == ERROR_SUCCESS)
    {
        Status = (*CMLocateDevNode)(&DevInst,
                                    AnsiDevInstName,
                                    CM_LOCATE_DEVNODE_NORMAL);
        WmipFree(AnsiDevInstName);
    }
#else    
    Status = (*CMLocateDevNode)(&DevInst,
                               DevInstName,
                               CM_LOCATE_DEVNODE_NORMAL);
#endif
    if (Status == CR_SUCCESS)
    {
        BufferFull = (MaxSize == 0);
        BufferNeeded = 0;
        BufferLeft = MaxSize;
        
        WCharPtr = (PWCHAR)OutBuffer;

        WmipGetDevInstProperty(DevInst,
                               CM_DRP_FRIENDLYNAME,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        WmipGetDevInstProperty(DevInst,
                               CM_DRP_DEVICEDESC,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        WmipGetDevInstProperty(DevInst,
                               CM_DRP_LOCATION_INFORMATION,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        WmipGetDevInstProperty(DevInst,
                               CM_DRP_MFG,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
        
        WmipGetDevInstProperty(DevInst,
                               CM_DRP_SERVICE,
                               &BufferFull,
                               &((PUCHAR)WCharPtr),
                               &BufferLeft,
                               &BufferNeeded,
                               CMGetDevNodeRegistryProperty);
               
        Status = BufferFull ? ERROR_INSUFFICIENT_BUFFER : ERROR_SUCCESS;
        *RetSize = BufferNeeded;
    } else {
        Status = ERROR_INVALID_DATA;
    }                               
    
    return(Status);
}

PWCHAR WmipCountedToSzAndTrim(
    PWCHAR InNamePtr,
    PWCHAR OutNameBuffer,
    ULONG OutNameSizeInBytes,
    BOOLEAN Trim
    )
{
    PWCHAR WCharPtr, DevInstName;
    ULONG DevInstNameLength;
    ULONG i;
        
    WCharPtr = InNamePtr;
    DevInstNameLength = *WCharPtr++;
    
    if (DevInstNameLength >= OutNameSizeInBytes)
    {
        DevInstName = WmipAlloc( DevInstNameLength + sizeof(USHORT));
    } else {
        DevInstName = OutNameBuffer;
    }

	if (DevInstName != NULL)
	{
		memcpy(DevInstName, WCharPtr, DevInstNameLength);
		DevInstNameLength /= sizeof(WCHAR);
		DevInstName[DevInstNameLength--] = UNICODE_NULL;
    
		if (Trim)
		{
			//
			// Trim off the final _xxx from the Instance name to convert it to
			// the Device Instance Name
			WCharPtr = DevInstName + DevInstNameLength;
			i = DevInstNameLength;
			while ((*WCharPtr != L'_') && (i-- != 0)) 
			{
				WCharPtr--;
			}
			*WCharPtr = UNICODE_NULL;
		}
    }
    
    return(DevInstName);
}

ULONG WmipQuerySingleInstanceInfo(
    PWNODE_SINGLE_INSTANCE Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetWnodeSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{
    WCHAR DevInstBuffer[MAX_PATH];
    PWCHAR WCharPtr;
    PWCHAR DevInstName;
    ULONG DevInstNameLength;
    ULONG i;
    ULONG BufferSize;
    ULONG MaxBufferSize;
    ULONG WnodeNeeded;
    PUCHAR Buffer;
    ULONG Status;
    
    WmipAssert(! (Wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES));
    WmipAssert(Wnode->OffsetInstanceName < Wnode->WnodeHeader.BufferSize);
    WmipAssert(Wnode->DataBlockOffset <= MaxWnodeSize);    
    
    WCharPtr = (PWCHAR)((PUCHAR)Wnode + Wnode->OffsetInstanceName);
    DevInstName =  WmipCountedToSzAndTrim(WCharPtr,
                                          DevInstBuffer,
                                          sizeof(DevInstBuffer),
                                          TRUE);

	if (DevInstName != NULL)
	{
		Buffer = (PUCHAR)OffsetToPtr(Wnode, Wnode->DataBlockOffset);
		MaxBufferSize = MaxWnodeSize - Wnode->DataBlockOffset;

		BufferSize = 0;
		Status = WmipGetDevInstInfo(DevInstName,
                                MaxBufferSize,
                                Buffer,
                                &BufferSize,
                                CMLocateDevNode,
                                CMGetDevNodeRegistryProperty);
    
		WnodeNeeded = Wnode->DataBlockOffset + BufferSize;
    
		if (Status == ERROR_SUCCESS)
		{
			WmiInsertTimestamp((PWNODE_HEADER)Wnode);
			Wnode->WnodeHeader.BufferSize = WnodeNeeded;
			Wnode->SizeDataBlock = BufferSize;
			*RetWnodeSize = WnodeNeeded;
		} else if (Status == ERROR_INSUFFICIENT_BUFFER) {
			WmipAssert(MaxWnodeSize > sizeof(WNODE_TOO_SMALL));
           
			Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
			((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = WnodeNeeded;
			Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
			*RetWnodeSize = sizeof(WNODE_TOO_SMALL);
			Status = ERROR_SUCCESS;
		}
    
		if (DevInstName != DevInstBuffer)
		{
			WmipFree(DevInstName);
		}
	} else {
		Status = ERROR_NOT_ENOUGH_MEMORY;
	}
    
    return(Status);    
}

GUID PnPDeviceIdGuid = DATA_PROVIDER_PNPID_GUID;

ULONG WmipComputeInstanceCount(
    PWNODE_ALL_DATA WAD,
    ULONG WnodeSize,
    PULONG InstanceCount
    )
{
    ULONG Linkage;
    ULONG Count = 0;
    
    do
    {
        Linkage = WAD->WnodeHeader.Linkage;
        
        if (Linkage > WnodeSize)
        {
            WmipDebugPrint(("WMI: Badly formed Wnode %x\n", WAD));
            WmipAssert(FALSE);
            return(ERROR_INVALID_DATA);
        }

        Count += WAD->InstanceCount;
        
        WnodeSize -= Linkage;
        WAD = (PWNODE_ALL_DATA)OffsetToPtr(WAD, WAD->WnodeHeader.Linkage);
    } while (Linkage != 0);            
    
    *InstanceCount = Count;
    return(ERROR_SUCCESS);
}


ULONG WmipQueryAllInstanceInfo(
    PWNODE_ALL_DATA OutWAD,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize,
    PCMLOCATEDEVNODE CMLocateDevNode,
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty    
   )
{

    ULONG Status;
    PWNODE_ALL_DATA PnPIdWAD;
    WMIHANDLE PnPIdHandle;
    ULONG Size, Retries;
    ULONG InstanceCount;
    POFFSETINSTANCEDATAANDLENGTH OutOffsetNameLenPtr;
    ULONG OutOffsetInstanceNameOffsets;
    PULONG OutOffsetInstanceNameOffsetsPtr;
    ULONG OutSizeNeeded, OutInstanceCounter = 0;
    BOOLEAN OutIsFull = FALSE;
    ULONG OutNameOffset;
    ULONG OutNameSizeNeeded;
    ULONG OutSizeLeft;
    ULONG OutDataSize;
    PWCHAR OutNamePtr;
    PWNODE_ALL_DATA InWAD;
    BOOLEAN IsFixedSize;
    PWCHAR InNamePtr;
    PWCHAR InPnPIdPtr;
    ULONG FixedNameSize;
    ULONG i;
    PWCHAR DevInstName;
    WCHAR DevInstBuffer[MAX_PATH];    
    POFFSETINSTANCEDATAANDLENGTH InOffsetNameLenPtr;
    PUCHAR Buffer;    
    ULONG Linkage;
    PULONG InOffsetInstanceNamePtr;
    PWNODE_TOO_SMALL WTS;
    ULONG OutDataOffset;
    
    //
    // Obtain the complete list of device instance ids
    //
    Status = WmiOpenBlock(&PnPDeviceIdGuid, WMIGUID_QUERY, &PnPIdHandle);
    if (Status == ERROR_SUCCESS)
    {
        Size = 0x1000;
        Retries = 0;
        PnPIdWAD = NULL;
        do
        {
            if (PnPIdWAD != NULL)
            {
                WmipFree(PnPIdWAD);
            }
            
            PnPIdWAD = (PWNODE_ALL_DATA)WmipAlloc(Size);
            
            if (PnPIdWAD != NULL)
            {
                Status = WmiQueryAllDataW(PnPIdHandle,
                                          &Size,
                                          PnPIdWAD);
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } while ((Status == ERROR_INSUFFICIENT_BUFFER) && 
                 (Retries++ < 5));
             
        if (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            WmipAssert(FALSE);
            Status = ERROR_WMI_DP_NOT_FOUND;
        }
        
        WmiCloseBlock(PnPIdHandle);
    }
    
    if (Status == ERROR_SUCCESS)
    {
        Status = WmipComputeInstanceCount(PnPIdWAD,
                                          Size,
                                          &InstanceCount);
                                      
        if (Status == ERROR_SUCCESS)
        {
            
            //
            // Prepare output WNODE
            OutOffsetNameLenPtr = OutWAD->OffsetInstanceDataAndLength;
    
            OutOffsetInstanceNameOffsets = sizeof(WNODE_ALL_DATA) + 
                    (InstanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH));
            OutOffsetInstanceNameOffsetsPtr = (PULONG)OffsetToPtr(OutWAD,
                                               OutOffsetInstanceNameOffsets);

            OutSizeNeeded = ((OutOffsetInstanceNameOffsets + 
                                   (InstanceCount * sizeof(ULONG))) + 7) & ~7;
        
                               
            WmipDebugPrint(("WMI: Basic OutSizeNeeded = 0x%x\n", OutSizeNeeded));
                               
            //
            // Loop over all device instance ids returned and build
            // output wnode
            
            InWAD = PnPIdWAD;
            do
            {
                //
                // Get Instance and device instance id from input wnode
                InOffsetInstanceNamePtr = (PULONG)OffsetToPtr(InWAD,
                                           InWAD->OffsetInstanceNameOffsets);
                                       
                // TODO: Validate InOffsetInstanceNamePtr
                                       
                if (InWAD->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
                {
                    IsFixedSize = TRUE;
                    InPnPIdPtr = (PWCHAR)OffsetToPtr(InWAD, 
                                                InWAD->DataBlockOffset);
                    FixedNameSize = (InWAD->FixedInstanceSize + 7) & ~7;
                } else {
                    IsFixedSize = FALSE;
                    InOffsetNameLenPtr = InWAD->OffsetInstanceDataAndLength;
                }
            
                for (i = 0; i < InWAD->InstanceCount; i++)
                {
                    if (! IsFixedSize)
                    {
                        InPnPIdPtr = (PWCHAR)OffsetToPtr(InWAD, 
                                    InOffsetNameLenPtr[i].OffsetInstanceData);
                    }

                    InNamePtr = (PWCHAR)OffsetToPtr(InWAD, 
                                            InOffsetInstanceNamePtr[i]);
                                        
                    //
                    // TODO: Validate InNamePtr and InPnPIdPtr
                    if (FALSE)
                    {
                        //
                        // If we hit a bad instance name then we throw out the
                        // entire wnode
                        WmipDebugPrint(("WMI: Badly formed instance name %x\n",
                                           InNamePtr));
                        WmipAssert(FALSE);
                        break;
                    }
                    
                    DevInstName = WmipCountedToSzAndTrim(InPnPIdPtr, 
                                                    DevInstBuffer, 
                                                    sizeof(DevInstBuffer),
                                                    FALSE);

					if (DevInstName != NULL)
					{
						WmipDebugPrint(("WMI: Processing %ws\n", DevInstName));
                                                
                                                
						//
						// Compute size and location of the output instance name
						// It needs to start on a word boundry and end on a 8 byte
						// boundry
						OutNameOffset = (OutSizeNeeded+1) & ~1;
						OutNameSizeNeeded = OutNameOffset - OutSizeNeeded;
						OutNameSizeNeeded += *InNamePtr + sizeof(USHORT);
						OutNameSizeNeeded =  ((OutNameOffset + OutNameSizeNeeded + 7) & ~7) - OutNameOffset;
                    
						WmipDebugPrint(("WMI: OutNameSizeNeeded = 0x%x\n", OutNameSizeNeeded));
						OutDataOffset = OutSizeNeeded + OutNameSizeNeeded;
						if ((OutIsFull) || 
							(OutDataOffset > MaxWnodeSize))
						{
							WmipDebugPrint(("    WMI: OutIsFull\n"));
							Buffer = NULL;
							OutSizeLeft = 0;
							OutIsFull = TRUE;
						} else {
							Buffer = (PUCHAR)OffsetToPtr(OutWAD, 
														 OutDataOffset);
							OutSizeLeft = MaxWnodeSize - OutDataOffset;
							WmipDebugPrint(("    WMI: Out Not Full, OutSizeLeft = 0x%x at 0x%x\n", OutSizeLeft, OutDataOffset));
						}
                
						//
						// Now that we have the name, lets get the vital info
						Status = WmipGetDevInstInfo(DevInstName,
                                             OutSizeLeft,
                                             Buffer,
                                             &OutDataSize,
                                             CMLocateDevNode,
                                             CMGetDevNodeRegistryProperty);
                                         
						WmipDebugPrint(("    WMI: GetInfo -> %d, OutDataSize 0x%x\n", Status, OutDataSize));
						if (Status == ERROR_SUCCESS)
						{
							//
							// We were able to get all of the data so fill in the
							// instance name
							OutNamePtr = (PWCHAR)OffsetToPtr(OutWAD, 
                                                         OutNameOffset);
							*OutOffsetInstanceNameOffsetsPtr++ = OutNameOffset;
							*OutNamePtr++ = *InNamePtr;
							memcpy(OutNamePtr, InNamePtr+1, *InNamePtr);
                    
							//
							// Now fill in the output data
							OutOffsetNameLenPtr[OutInstanceCounter].OffsetInstanceData = OutDataOffset;
							OutOffsetNameLenPtr[OutInstanceCounter].LengthInstanceData = OutDataSize;
							OutInstanceCounter++;
						} else if (Status == ERROR_INSUFFICIENT_BUFFER) {
							OutIsFull = TRUE;
							OutInstanceCounter++;
						} else {
							OutNameSizeNeeded = 0;
							OutDataSize = 0;
						}
                
						OutSizeNeeded += (OutNameSizeNeeded + OutDataSize);
						WmipDebugPrint(("    WMI: OutSizeNeeded = 0x%x\n", OutSizeNeeded));
                    
						if (DevInstName != DevInstBuffer)
						{
							WmipFree(DevInstName);
						}
					} else {
						return(ERROR_NOT_ENOUGH_MEMORY);
					}
                  
                    if (IsFixedSize)
                    {
                        InPnPIdPtr = (PWCHAR)((PUCHAR)InPnPIdPtr + FixedNameSize);
                    }
                }
                        
                Linkage = InWAD->WnodeHeader.Linkage;
                InWAD = (PWNODE_ALL_DATA)OffsetToPtr(InWAD, 
                                                  InWAD->WnodeHeader.Linkage);
            } while (Linkage != 0);            
        }
    }
    
    //
    // Output wnode post processing. If not enough room then return a
    // WNODE_TOO_SMALL, otherwise fill in WNODE_ALL_DATA fields
    if ((OutInstanceCounter > 0) || (Status == ERROR_SUCCESS))
    {
        if (OutIsFull)
        {
            WTS = (PWNODE_TOO_SMALL)OutWAD;
            WTS->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            WTS->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            WTS->SizeNeeded = OutSizeNeeded;        
            *RetSize = sizeof(WNODE_TOO_SMALL);
        } else {
            OutWAD->WnodeHeader.BufferSize = OutSizeNeeded;
            OutWAD->InstanceCount = OutInstanceCounter;
            OutWAD->OffsetInstanceNameOffsets = OutOffsetInstanceNameOffsets;
            *RetSize = OutSizeNeeded;
        }
        Status = ERROR_SUCCESS;
    }
    
    return(Status);
}

#ifdef MEMPHIS
#define CFGMGRDLL TEXT("cfgmgr32.dll")
#else
#define CFGMGRDLL TEXT("setupapi.dll")
#endif

ULONG WmipQueryInstanceInfo(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   )
{
    HMODULE CfgMgr32ModuleHandle;
    PCMGETDEVNODEREGISTRYPROPERTYW CMGetDevNodeRegistryProperty;
    PCMLOCATEDEVNODE CMLocateDevNode;
    ULONG Status;
    
    //
    // Ensure this is a request we support
    if ((ActionCode != WmiGetSingleInstance) &&
        (ActionCode != WmiGetAllData))
    {
        return(ERROR_INVALID_FUNCTION);
    }
    
    //
    // First we try to demand load cfgmgr32.dll
    CfgMgr32ModuleHandle = LoadLibrary(CFGMGRDLL);
    if (CfgMgr32ModuleHandle != NULL)
    {
#ifdef MEMPHIS        
        CMLocateDevNode = (PCMLOCATEDEVNODEA)GetProcAddress(CfgMgr32ModuleHandle,
                                      "CM_Locate_DevNodeA");
#else
        CMLocateDevNode = (PCMLOCATEDEVNODEW)GetProcAddress(CfgMgr32ModuleHandle,
                                      "CM_Locate_DevNodeW");
#endif
        CMGetDevNodeRegistryProperty = (PCMGETDEVNODEREGISTRYPROPERTYW)
                                        GetProcAddress(CfgMgr32ModuleHandle,
#ifdef MEMPHIS
                                         "CM_Get_DevNode_Registry_PropertyA");
#else
                                         "CM_Get_DevNode_Registry_PropertyW");
#endif                 
        if ((CMLocateDevNode == NULL) ||
            (CMGetDevNodeRegistryProperty == NULL))
        {
            FreeLibrary(CfgMgr32ModuleHandle);
            WmipDebugPrint(("WMI: Couldn't get CfgMgr32 prog addresses %d\n",
                            GetLastError()));
            return(GetLastError());
        }
    } else {
        WmipDebugPrint(("WMI: Couldn't load CfgMgr32 %d\n",
                            GetLastError()));
        return(GetLastError());
    }
    
    if (ActionCode == WmiGetSingleInstance)
    {
        Status = WmipQuerySingleInstanceInfo((PWNODE_SINGLE_INSTANCE)Wnode,
                                               MaxWnodeSize,
                                               OutBuffer,
                                               RetSize,
                                               CMLocateDevNode,
                                               CMGetDevNodeRegistryProperty);
    } else if (ActionCode == WmiGetAllData) {
        Status = WmipQueryAllInstanceInfo((PWNODE_ALL_DATA)Wnode,
                                               MaxWnodeSize,
                                               OutBuffer,
                                               RetSize,
                                               CMLocateDevNode,
                                               CMGetDevNodeRegistryProperty);
    } else {
        WmipAssert(FALSE);
    }
        
    FreeLibrary(CfgMgr32ModuleHandle);
    return(Status);
}

ULONG
WmipEnumRegGuids(
    PWMIGUIDLISTINFO *pGuidInfo
    )
{
    ULONG Status = ERROR_SUCCESS;
    ULONG MaxGuidCount = 0;
    PWMIGUIDLISTINFO GuidInfo;
    ULONG RetSize;
    ULONG GuidInfoSize;

    MaxGuidCount = DEFAULT_GUID_COUNT;
retry:
    GuidInfoSize = FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                     MaxGuidCount * sizeof(WMIGUIDPROPERTIES);
	     
    GuidInfo = (PWMIGUIDLISTINFO)WmipAlloc(GuidInfoSize);

    if (GuidInfo == NULL)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    
    RtlZeroMemory(GuidInfo, GuidInfoSize);

    Status = WmipSendWmiKMRequest(NULL,
                                  IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES,
                                  GuidInfo,
                                  GuidInfoSize,
                                  GuidInfo,
                                  GuidInfoSize,
                                  &RetSize,
                                  NULL);
    if (Status == ERROR_SUCCESS)
    {
        if ((RetSize < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList)) ||
            (RetSize < (FIELD_OFFSET(WMIGUIDLISTINFO, GuidList) + 
                GuidInfo->ReturnedGuidCount * sizeof(WMIGUIDPROPERTIES))))
        {
            //
            // WMI KM returned to us a bad size which should not happen
            //
            Status = ERROR_WMI_DP_FAILED;
            WmipAssert(FALSE);
	    WmipFree(GuidInfo);
        } else {

            //
            // If RPC was successful, then build a WMI DataBlock with the data
            //
  
            if (GuidInfo->TotalGuidCount > GuidInfo->ReturnedGuidCount) {
                MaxGuidCount = GuidInfo->TotalGuidCount;
                WmipFree(GuidInfo);
                goto retry;
            }
        }

        //
        // If the call was successful, return the pointers and the caller
        // must free the storage. 
        //

        *pGuidInfo = GuidInfo;
    }

    return Status;
}


ULONG
WmipEnumerateGuids(
    PWNODE_ALL_DATA Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize)
{
    ULONG Status = ERROR_SUCCESS;
    PWMIGUIDLISTINFO GuidInfo = NULL;
    ULONG ReturnGuidCount = 0;

    Status = WmipEnumRegGuids(&GuidInfo);

    if (Status == ERROR_SUCCESS) {

        PWMIGUIDPROPERTIES pGuidProperties = GuidInfo->GuidList;
        LPGUID  pGuid;
        WCHAR s[256];
        ULONG InstanceNameOffset;
        ULONG i;
        ULONG InstanceDataSize = sizeof(WMIGUIDPROPERTIES) - 
		                  FIELD_OFFSET(WMIGUIDPROPERTIES, GuidType);
        ULONG FixedInstanceSizeWithPadding = (InstanceDataSize+7) & ~7;    
        USHORT GuidStringSize = 76;
        ULONG SizeNeeded;
        PUCHAR BytePtr;
        PULONG UlongPtr;
        PUCHAR NamePtr;
        ULONG DataBlockOffset;

	WmipAssert(GuidInfo->ReturnedGuidCount == GuidInfo->TotalGuidCount);
	ReturnGuidCount = GuidInfo->ReturnedGuidCount;
        SizeNeeded = sizeof(WNODE_ALL_DATA) + 
                     ReturnGuidCount * (FixedInstanceSizeWithPadding +
                                        GuidStringSize +
                                        sizeof(ULONG) + 
                                        sizeof(WCHAR));

        if (MaxWnodeSize < SizeNeeded) {
            // 
            // Build WNODE_TOO_SMALL
            //

            WmipAssert(MaxWnodeSize > sizeof(WNODE_TOO_SMALL));

            Wnode->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
            ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = SizeNeeded;
            Wnode->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
            *RetSize = sizeof(WNODE_TOO_SMALL);
            WmipFree(GuidInfo);
            return ERROR_SUCCESS;
        }

        Wnode->InstanceCount = ReturnGuidCount;
        Wnode->FixedInstanceSize = InstanceDataSize;
        Wnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;

        DataBlockOffset = sizeof(WNODE_ALL_DATA);

        //
        // pad out to an 8 byte boundary.
        //
        DataBlockOffset = (DataBlockOffset + 7) & ~7;

        Wnode->DataBlockOffset = DataBlockOffset;

        BytePtr = (PUCHAR)((PUCHAR)Wnode + DataBlockOffset);
        
        
        InstanceNameOffset = DataBlockOffset + 
                             (ReturnGuidCount * FixedInstanceSizeWithPadding);
        Wnode->OffsetInstanceNameOffsets = InstanceNameOffset;
                            
        UlongPtr = (PULONG)((PUCHAR)Wnode + InstanceNameOffset);

        NamePtr = (PUCHAR)UlongPtr;
        NamePtr = (PUCHAR)((PUCHAR)NamePtr + (ReturnGuidCount * sizeof(ULONG)));

        for (i=0; i < ReturnGuidCount; i++) {
            //
            // Copy the fixed instance datablock
            //
            RtlCopyMemory(BytePtr, 
                          &pGuidProperties->GuidType, 
                          Wnode->FixedInstanceSize);
            BytePtr += FixedInstanceSizeWithPadding;

            //
            // Set the Offset to InstanceName
            //
            *UlongPtr++ = (ULONG)((PCHAR)NamePtr - (PCHAR)Wnode); 
            //
            // Copy over the Instance Name
            //
            *((USHORT *)NamePtr) = GuidStringSize;
            NamePtr += sizeof(USHORT);
            GuidToWString(s, &pGuidProperties->Guid);
            RtlCopyMemory(NamePtr, s, GuidStringSize);
            NamePtr += GuidStringSize;

            pGuidProperties++; 
        }
        WmiInsertTimestamp((PWNODE_HEADER)Wnode);
        *RetSize = SizeNeeded;
        Wnode->WnodeHeader.BufferSize = SizeNeeded;

        WmipFree(GuidInfo);
    }
    return Status;
}

ULONG WmipInternalProvider(
    ULONG ActionCode,
    PWNODE_HEADER Wnode,
    ULONG MaxWnodeSize,
    PVOID OutBuffer,
    ULONG *RetSize
   )
{
    ULONG GuidIndex;
    ULONG Status;
    
    WmipAssert((PVOID)Wnode == OutBuffer);
    
    GuidIndex = WmipFindGuid(&Wnode->Guid);
    
    switch(GuidIndex)
    {
        case INSTANCE_INFO_GUID_INDEX:
        {
            Status = WmipQueryInstanceInfo(ActionCode,
                                           Wnode,
                                           MaxWnodeSize,
                                           OutBuffer,
                                           RetSize);
            break;
        }
	
        case ENUMERATE_GUIDS_GUID_INDEX:
        {
            //
            //
            // Need an RPC call to the server to get the desired data.
            //
            if (ActionCode == WmiGetAllData)
                Status = WmipEnumerateGuids((PWNODE_ALL_DATA)Wnode,
                                            MaxWnodeSize,
                                            OutBuffer,
                                            RetSize);
            else
                Status = ERROR_INVALID_FUNCTION;

            break;
        }

        default:
        {
            Status = ERROR_WMI_GUID_NOT_FOUND;
        }
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\logapi.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    logapi.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:


--*/

#ifndef MEMPHIS
#ifdef DBG
#include <stdio.h> // only for fprintf
#endif
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include <ntverp.h>
#include "wmiump.h"
#include "evntrace.h"
#include "tracelib.h"

#define MAXSTR                          1024

#define MAXINST                         0XFFFFFFFF
#define TRACE_RETRY_COUNT               5

#define TRACE_HEADER_FULL   (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_FULL_HEADER << 16))

#define TRACE_HEADER_INSTANCE (TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE \
                            | (TRACE_HEADER_TYPE_INSTANCE << 16))

ULONG   WmipIsBBTOn = 0;


//
// This guid is used by RegisterTraceGuids when register a tracelog
// provider. Any ACLs for controlling registration should be placed on
// this guid. Note that since the kernel will created unnamed guid
// objects, multiple tracelog providers can register without issue.
//
// {DF8480A1-7492-4f45-AB78-1084642581FB}
GUID RegisterReservedGuid = { 0xdf8480a1, 0x7492, 0x4f45, 0xab, 0x78, 0x10, 0x84, 0x64, 0x25, 0x81, 0xfb };

//
// Local Data Structures Used
//
typedef struct _TRACE_REG_PACKET {
    ULONG RegistrationCookie;
    ULONG Reserved;
} TRACE_REG_PACKET, *PTRACE_REG_PACKET;

HANDLE WmipDeviceHandle = NULL;

VOID
WmipCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    );

VOID
WmipCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    );


NTSTATUS
WmipTraceUmMessage(
    IN ULONG    Size,
    IN ULONG64  LoggerHandle,
    IN ULONG    MessageFlags,
    IN LPGUID   MessageGuid,
    IN USHORT   MessageNumber,
    va_list     MessageArgList
);

VOID
WmipFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    );

ULONG
WmipCheckForEnoughFreeSpace(
    PWCHAR FullLogFileName,
    ULONG  FullLogFileNameLen,
    ULONG  MaxFileSizeSpecified,
    ULONG  AppendMode
    );

VOID
WmipFixupLoggerStrings(
    PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG Offset = sizeof(WMI_LOGGER_INFORMATION);
    ULONG LoggerInfoSize;

    if (LoggerInfo == NULL)
        return;

    LoggerInfoSize = LoggerInfo->Wnode.BufferSize;

    if (LoggerInfoSize <= Offset)

        return;

    //
    // Fixup LoggerName first
    //

    if (LoggerInfo->LoggerName.Length > 0) {
        LoggerInfo->LoggerName.Buffer = (PWCHAR) ((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LoggerName.MaximumLength;
    }

    if (LoggerInfoSize <= Offset) 
        return;

    if (LoggerInfo->LogFileName.Length > 0) {
        LoggerInfo->LogFileName.Buffer = (PWCHAR)((PUCHAR)LoggerInfo + Offset);
        Offset += LoggerInfo->LogFileName.MaximumLength;
    }

#ifdef DBG
    WmipAssert(LoggerInfoSize >= Offset);
#endif
}

ULONG
WmipCheckForEnoughFreeSpace(
    PWCHAR FullLogFileName,
    ULONG  FullLogFileNameLen,
    ULONG  MaxFileSizeSpecified,
    ULONG  AppendMode
    )
{
    ULONG NeededSpace = MaxFileSizeSpecified;
    ULONG SizeNeeded;
    UINT ReturnedSizeNeeded;
    PWCHAR strLogFileDir = NULL;
    WCHAR strSystemDir[MAX_PATH];

    if (NeededSpace && AppendMode) {
        ULONG Status;
        WIN32_FILE_ATTRIBUTE_DATA FileAttributes;
        ULONGLONG ExistingFileSize;
        ULONG ExistingFileSizeInMBytes;
        if (GetFileAttributesExW(FullLogFileName,
                                 GetFileExInfoStandard,
                                 (LPVOID)(&FileAttributes))) {

            ExistingFileSize = (((ULONGLONG)FileAttributes.nFileSizeHigh) << 32)
                             + FileAttributes.nFileSizeLow;
            ExistingFileSizeInMBytes = (ULONG)(ExistingFileSize / (1024 * 1024));
            if (ExistingFileSizeInMBytes >= NeededSpace) {
                return ERROR_DISK_FULL;
            }
            else {
                NeededSpace -= ExistingFileSizeInMBytes;
            }
        } 
        else { // GetFileAttributesExW() failed
            Status = GetLastError();
            // If the file is not found, advapi32.dll treats 
            // the case as EVENT_TRACE_FILE_MODE_NEWFILE
            // So, we will let it go here.
            if (ERROR_FILE_NOT_FOUND != Status) { 
                return Status;
            }
        }                       
    }

    ReturnedSizeNeeded = GetSystemDirectoryW(strSystemDir, MAX_PATH);
    if (ReturnedSizeNeeded == 0) {
        return GetLastError();
    }

    if (ReturnedSizeNeeded < 2 || FullLogFileNameLen < 2) {
        // This really cannot happen. 
        return ERROR_INVALID_PARAMETER;
    }
    if (FullLogFileName[1] == L':' && strSystemDir[1] == L':') {
        if (!_wcsnicmp(FullLogFileName, strSystemDir, 1)) {
            NeededSpace += 200;
        }
    }

    // Check for space only when we have to
    if (NeededSpace) {
        int i;
        ULARGE_INTEGER FreeBytesAvailable, TotalNumberOfBytes;
        ULONG FreeMegaBytes;

        strLogFileDir = WmipAlloc((FullLogFileNameLen + 1) * sizeof(WCHAR));
        if (strLogFileDir == NULL) {
            return ERROR_OUTOFMEMORY;
        }
        wcsncpy(strLogFileDir, FullLogFileName, FullLogFileNameLen);
        for (i = FullLogFileNameLen - 1; i >= 0; i--) {
            if (strLogFileDir[i] == L'\\' || strLogFileDir[i] == L'/') {
                strLogFileDir[i] = '\0';
                break;
            }
        }
        if (i < 0) {
            // This really cannot happen. 
            WmipFree(strLogFileDir);
            strLogFileDir = NULL;
        }
        // it also works with network paths
        if (GetDiskFreeSpaceExW(strLogFileDir,
                               &FreeBytesAvailable,
                               &TotalNumberOfBytes,
                               NULL)) {
            FreeMegaBytes = (ULONG)(FreeBytesAvailable.QuadPart / (1024 *1024));
            WmipFree(strLogFileDir);
            if (FreeMegaBytes < NeededSpace) {
                return ERROR_DISK_FULL;
            }
        }
        else {
            WmipFree(strLogFileDir);
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}

ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the ANSI version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ANSI_STRING AnsiString;
    ULONG IsLogFile;
    LPSTR CapturedName;
    ULONG SizeNeeded;
    ULONG LogFileNameLen, LoggerNameLen;
    PCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PCHAR Buffer=NULL;
    PCHAR FullPathName=NULL;
    ULONG FullPathNameSize = MAXSTR;


    WmipInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return WmipSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        // LoggerName is a Mandatory Parameter. Must provide space for it. 
        //
        LoggerNameLen = strlen(LoggerName);
        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + LoggerNameLen + 1;

        //
        // Rules for Kernel Logger Identification
        // 1. If the logger name is "NT Kernel Logger", it is the kernel logger, and 
        //    the System GUID is copied as well.
        // 2. If the GUID is equal to the System GUID, but not the name, reject the session.
        //
        if (!strcmp(LoggerName, KERNEL_LOGGER_NAMEA)) {
            Properties->Wnode.Guid = SystemTraceControlGuid;
        }
        else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) { 
            // LoggerName is not "NT Kernel Logger", but Guid is
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range. 
        //
        if (Properties->LoggerNameOffset > 0) 
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            ULONG RetValue;

            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = ((PCHAR)Properties + Properties->LogFileNameOffset );
            SizeNeeded += sizeof (LogFileName);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }
            RetValue = GetFullPathName(LogFileName, FullPathNameSize, FullPathName, NULL);

            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = strlen(LogFileName);
            if (LogFileNameLen == 0) 
                IsLogFile = FALSE;

        }
        else 
            IsLogFile = FALSE;

        //
        //  Check to see if there is room in the Properties structure
        //  to return both the InstanceName (LoggerName) and the LogFileName
        //
            

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        CapturedName = (LPSTR) LoggerName;
        LoggerNameLen = strlen(CapturedName);

        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
            if (!IsLogFile) {
                ErrorCode = ERROR_BAD_PATHNAME;
                goto Cleanup;
            }
        }

        if ((Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            if (   (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            if (   (Properties->MaximumFileSize == 0)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (!IsLogFile)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        //
        // Relogger is supported only with Private Logger
        //
        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            if (!(Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) 
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            if ((Properties->MaximumFileSize == 0) ||
                (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
                (IsLogFile != TRUE)
               ){
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            Buffer = WmipAlloc((LogFileNameLen+64) * sizeof(CHAR) );
            if (Buffer == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }

            sprintf(Buffer, LogFileName, 1);
            if (RtlEqualMemory(LogFileName, Buffer, LogFileNameLen) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

    // For UserMode logger the LoggerName and LogFileName must be
    // passed in as offsets. 
    //
        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) +
                     (LoggerNameLen  + 1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);
            SizeNeeded += FlagExt->Length * sizeof(ULONG);
        }

        SizeNeeded = (SizeNeeded +7) & ~7;

        LoggerInfo = WmipAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires Ansi strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        WmipCopyPropertiesToInfo(
            (PEVENT_TRACE_PROPERTIES) Properties,
            LoggerInfo);

        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;


        RtlInitAnsiString(&AnsiString, CapturedName);

        LoggerInfo->LoggerName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LoggerNameLen + 1));
        LoggerInfo->LoggerName.Buffer =
                (LPWSTR) (  ((PUCHAR) LoggerInfo)
                          + sizeof(WMI_LOGGER_INFORMATION));
        Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName,
                    &AnsiString, FALSE);
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipNtStatusToDosError(Status);
            goto Cleanup;
        }

        if (IsLogFile) {
            LoggerInfo->LogFileName.MaximumLength =
                                (USHORT) (sizeof(WCHAR) * (LogFileNameLen + 1));
            LoggerInfo->LogFileName.Buffer =
                    (LPWSTR) (  ((PUCHAR) LoggerInfo)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + LoggerInfo->LoggerName.MaximumLength);

            RtlInitAnsiString(&AnsiString, LogFileName);
            Status = RtlAnsiStringToUnicodeString(
                        &LoggerInfo->LogFileName,
                        &AnsiString, FALSE);

            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipNtStatusToDosError(Status);
                goto Cleanup;
            }

            Status = WmipCheckForEnoughFreeSpace(LoggerInfo->LogFileName.Buffer, 
                                                 LogFileNameLen, 
                                                 Properties->MaximumFileSize,
                                                 (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND));
            if (Status != ERROR_SUCCESS) {
                ErrorCode = Status;
                goto Cleanup;
            }
        }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }


        ErrorCode = WmipStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PCHAR pLoggerName, pLogFileName;

            WmipCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            if (Properties->LoggerNameOffset == 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            
            pLoggerName = (PCHAR)((PCHAR)Properties + 
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            RequiredLength = strlen(CapturedName) + 1;
            if (RequiredLength <= AvailableLength) {
               strcpy(pLoggerName, CapturedName); 
            }
            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            // 
            // If there is room copy fullpath name
            //
            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;



            if ( (LogFileNameLen > 0) && (AvailableLength >= LogFileNameLen) ) {

                pLogFileName = (PCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

                strcpy(pLogFileName, LogFileName);

            }
        }
    }


    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipNtStatusToDosError( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)     
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)   
        WmipFree(FullPathName);
    if (Buffer != NULL)         
        WmipFree(Buffer); 

    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
StartTraceW(
    OUT    PTRACEHANDLE            LoggerHandle,
    IN     LPCWSTR                 LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
/*++

Routine Description:

    This is the Unicode version routine to start a logger.
    The caller must pass in a pointer to accept the returned logger handle,
    and must provide a valid logger name.

Arguments:

    LoggerHandle    The handle to the logger to be returned.

    LoggerName      A unique name for the logger

    Properties      Logger properties. If the caller wishes to use WMI's
                    defaults, all the numeric values must be set to 0.
                    Furthermore, the LoggerName and LogFileName fields
                    within must point to sufficient storage for the names
                    to be returned.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode;
    PWMI_LOGGER_INFORMATION LoggerInfo = NULL;
    ULONG  IsLogFile;
    LPWSTR CapturedName;
    ULONG  SizeNeeded;
    USHORT LogFileNameLen, LoggerNameLen;
    PWCHAR LogFileName;
    PTRACE_ENABLE_FLAG_EXTENSION FlagExt = NULL;
    PWCHAR Buffer = NULL;
    PWCHAR FullPathName = NULL;
    ULONG FullPathNameSize = MAXSTR;
    ULONG RetValue;
    ULONG RelogPropSize = 0;


    WmipInitProcessHeap();
    
    // first check to make sure that arguments passed are alright
    //

    if (Properties == NULL || LoggerHandle == NULL) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    if (LoggerName == NULL) {
        return WmipSetDosError(ERROR_INVALID_NAME);
    }

    IsLogFile = TRUE;
    LogFileNameLen = 0;
    LoggerNameLen = 0;
    LogFileName = NULL;

    try {
        // LoggerName is a Mandatory Parameter. Must provide space for it.
        //
        CapturedName = (LPWSTR) LoggerName;
        LoggerNameLen =  (USHORT) wcslen(CapturedName);

        SizeNeeded = sizeof (EVENT_TRACE_PROPERTIES) + (LoggerNameLen + 1) * sizeof(WCHAR);

        //
        // Rules for Kernel Logger Identification
        // 1. If the logger name is "NT Kernel Logger", it is the kernel logger, and 
        //    the System GUID is copied as well.
        // 2. If the GUID is equal to the System GUID, but not the name, reject the session.
        //
        if (!wcscmp(LoggerName, KERNEL_LOGGER_NAMEW)) {
            Properties->Wnode.Guid = SystemTraceControlGuid;
        }
        else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) { 
            // LoggerName is not "NT Kernel Logger", but Guid is
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0)
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES)) 
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
                return WmipSetDosError(ERROR_INVALID_PARAMETER);

            LogFileName = (PWCHAR)((char*)Properties + 
                              Properties->LogFileNameOffset);
            SizeNeeded += (wcslen(LogFileName) +1) * sizeof(WCHAR);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                return WmipSetDosError(ERROR_OUTOFMEMORY);
            }

            RetValue = GetFullPathNameW(LogFileName, FullPathNameSize, FullPathName,NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize =  RetValue;
                    goto Retry;
                }
                else {
                    LogFileName = FullPathName;
                }
            }
            LogFileNameLen = (USHORT) wcslen(LogFileName);
            if (LogFileNameLen <= 0)
                IsLogFile = FALSE;
        }
        else 
            IsLogFile = FALSE;

        //
        // Check to see if there is room for both LogFileName and
        // LoggerName (InstanceName) to be returned
        //

        if (Properties->Wnode.BufferSize < SizeNeeded) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }

        LoggerNameLen = (USHORT) wcslen(CapturedName);
        if (LoggerNameLen <= 0) {
            ErrorCode = ERROR_INVALID_NAME;
            goto Cleanup;
        }

        if (!(Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
            if (!IsLogFile) {
                ErrorCode = ERROR_BAD_PATHNAME;
                goto Cleanup;
            }
        }
        if ((Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE) &&
            (Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) ) {
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) {
            if (   (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_REAL_TIME_MODE)) {
                ErrorCode = ERROR_INVALID_PARAMETER; 
                goto Cleanup;
            }
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            if (   (Properties->MaximumFileSize == 0)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (!IsLogFile)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        //
        // Relogger is supported only with Private Logger
        //
        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            if (!(Properties->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)
                || (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND) ) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
            if ((Properties->MaximumFileSize == 0) ||
                (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ||
                (IsLogFile != TRUE) 
               ){
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            //
            // Check to see if there a %d Pattern in the LogFileName
            //
            Buffer = WmipAlloc((LogFileNameLen+64) * sizeof(WCHAR) );
            if (Buffer == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            
            swprintf(Buffer, LogFileName, 1);
            if (RtlEqualMemory(LogFileName, Buffer, LogFileNameLen * sizeof(WCHAR))) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 
                     (LoggerNameLen +1) * sizeof(WCHAR) +
                     (LogFileNameLen + 1) * sizeof(WCHAR);

        if (Properties->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            FlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &Properties->EnableFlags;
            if ((FlagExt->Length == 0) || (FlagExt->Offset == 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            SizeNeeded += FlagExt->Length * sizeof(ULONG);            
        }

        //
        // If RELOG mode, then pass on the LOGFILE_HEADER from old logfile 
        // appended to the LOGGER_INFORMATION
        //

        if (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) {
            PSYSTEM_TRACE_HEADER pSysHeader;
            pSysHeader = (PSYSTEM_TRACE_HEADER) ((PUCHAR)Properties + sizeof(EVENT_TRACE_PROPERTIES) );
            RelogPropSize = pSysHeader->Packet.Size;
            SizeNeeded += RelogPropSize;
        }

        SizeNeeded = (SizeNeeded +7) & ~7;
        LoggerInfo = WmipAlloc(SizeNeeded);
        if (LoggerInfo == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(LoggerInfo, SizeNeeded);

    // at this point, we need to prepare WMI_LOGGER_INFORMATION
    // which requires wide char strings to be converted to UNICODE_STRING
    //
        *LoggerHandle = 0;

        WmipCopyPropertiesToInfo(Properties, LoggerInfo);
        //
        // If we are relogging, the caller passes in the number of processors
        // for the Private logger to use via the ProviderId field in Wnode
        //

        LoggerInfo->NumberOfProcessors = Properties->Wnode.ProviderId;
        LoggerInfo->Wnode.ProviderId = 0;

        LoggerInfo->LoggerName.MaximumLength =
                sizeof(WCHAR) * (LoggerNameLen + 1);
        LoggerInfo->LoggerName.Length =
                sizeof(WCHAR) * LoggerNameLen;
        LoggerInfo->LoggerName.Buffer = (PWCHAR)
                (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION));
        wcsncpy(LoggerInfo->LoggerName.Buffer, LoggerName, LoggerNameLen);

        if (IsLogFile) {
            ULONG Status;

            LoggerInfo->LogFileName.MaximumLength =
                    sizeof(WCHAR) * (LogFileNameLen + 1);
            LoggerInfo->LogFileName.Length =
                    sizeof(WCHAR) * LogFileNameLen;
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                    (((PUCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                   + LoggerInfo->LoggerName.MaximumLength);
            wcsncpy(LoggerInfo->LogFileName.Buffer,
                    LogFileName,
                    LogFileNameLen);

            Status = WmipCheckForEnoughFreeSpace(LoggerInfo->LogFileName.Buffer, 
                                                 LogFileNameLen, 
                                                 Properties->MaximumFileSize,
                                                 (Properties->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND));
            if (Status != ERROR_SUCCESS) {
                ErrorCode = Status;
                goto Cleanup;
            }
       }

        LoggerInfo->Wnode.BufferSize = SizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        if (LoggerInfo->EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;
            ULONG Offset;
            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION) &LoggerInfo->EnableFlags;
            Offset = SizeNeeded - (FlagExt->Length * sizeof(ULONG));
            tFlagExt->Offset = (USHORT) Offset;
            RtlCopyMemory(
                (PCHAR) LoggerInfo + Offset,
                (PCHAR) Properties + FlagExt->Offset,
                FlagExt->Length * sizeof(ULONG) );
        }
        if ( (Properties->LogFileMode & EVENT_TRACE_RELOG_MODE) &&
             (RelogPropSize > 0) )  {
            PSYSTEM_TRACE_HEADER pRelog, pSysHeader;
            PTRACE_LOGFILE_HEADER Relog;

            pRelog = (PSYSTEM_TRACE_HEADER) ( ((PUCHAR) LoggerInfo) + 
                                              sizeof(WMI_LOGGER_INFORMATION) + 
                                              LoggerInfo->LoggerName.MaximumLength +
                                              LoggerInfo->LogFileName.MaximumLength);

            pSysHeader =  (PSYSTEM_TRACE_HEADER) ( (PUCHAR)Properties + sizeof(EVENT_TRACE_PROPERTIES) );

            RtlCopyMemory(pRelog, pSysHeader, RelogPropSize);

        }

        ErrorCode = WmipStartLogger(LoggerInfo);

        if (ErrorCode == ERROR_SUCCESS) {
            ULONG AvailableLength, RequiredLength;
            PWCHAR pLoggerName;
            PWCHAR pLogFileName;

            WmipCopyInfoToProperties(LoggerInfo, Properties);
            if (Properties->LoggerNameOffset > 0) {
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
            }
            pLoggerName = (PWCHAR)((PCHAR)Properties +
                                  Properties->LoggerNameOffset );

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                AvailableLength =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;


            RequiredLength = (wcslen(CapturedName) + 1) * sizeof(WCHAR);
            if (RequiredLength <= AvailableLength) {
               wcscpy(pLoggerName, CapturedName);
            }

            *LoggerHandle = LoggerInfo->Wnode.HistoricalContext;

            //
            // If there is room for FullPath name, return it
            // TODO: Do the same for ANSI code...
            // 

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                AvailableLength = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                AvailableLength =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;


            RequiredLength = LoggerInfo->LogFileName.Length;

            pLogFileName = (PWCHAR)((PCHAR)Properties +
                                           Properties->LogFileNameOffset );

            if ( (RequiredLength > 0) &&  (RequiredLength <= AvailableLength) ) {
                wcsncpy(pLogFileName, LoggerInfo->LogFileName.Buffer, LogFileNameLen);
                pLogFileName[LogFileNameLen] = L'\0';
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipNtStatusToDosError( GetExceptionCode() );
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)
        WmipFree(FullPathName);
    if (Buffer != NULL) 
        WmipFree(Buffer);
    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE LoggerHandle,
    IN LPCSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH   - to flush the logger

Return Value:

    The status of performing the action requested.

--*/
{
    NTSTATUS Status;
    ULONG ErrorCode;

    BOOLEAN IsKernelTrace = FALSE;
    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PCHAR                   FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   FullPathNameSize = MAXSTR;
    ULONG                   RetValue;

    WmipInitProcessHeap();

    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    try {
        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //
        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (LoggerName != NULL) {
            LoggerNameLen = strlen(LoggerName) + 1;
            //
            // Rules for Kernel Logger Identification when a string is given instead of handle
            // 1. If the logger name is "NT Kernel Logger", it is the kernel logger, and 
            //    the System GUID is copied as well.
            // 2. If the GUID is equal to the System GUID, but not the name, reject the session.
            // 3. If the logger name is null or of size 0, and the GUID is equal to the System 
            //    GUID, let it proceed as the kernel logger.
            //
            if (!strcmp(LoggerName, KERNEL_LOGGER_NAMEA)) {
                Properties->Wnode.Guid = SystemTraceControlGuid;
            }
            else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) { 
                // LoggerName is not "NT Kernel Logger", but Guid is
                if (strlen(LoggerName) > 0) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }
        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            IsKernelTrace = TRUE;
        }
        if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            if ((LoggerName == NULL) || (strlen(LoggerName) <= 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:
    // Extra 32 bytes for UMlogger to append instance name to logfilename. 
    LogFileNameLen += 16;
    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);
    sizeNeeded = (sizeNeeded +7) & ~7;
    LoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    WmipInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    WmipInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));

    // Look for logger name first
    //
    try {
        if (LoggerName != NULL) {
            if (strlen(LoggerName) > 0) {
                ANSI_STRING AnsiString;

                RtlInitAnsiString(&AnsiString, LoggerName);
                Status = RtlAnsiStringToUnicodeString(
                    &LoggerInfo->LoggerName, &AnsiString, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipNtStatusToDosError(Status);
                    goto Cleanup;
                }
            }
        }

        LoggerInfo->LogFileName.Buffer = (PWCHAR)
                (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                        + LoggerInfo->LoggerName.MaximumLength);

        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            PCHAR  strLogFileName;

            strLogFileName = (PCHAR) (  ((PCHAR) Properties)
                                      + Properties->LogFileNameOffset);
Retry:
            FullPathName = WmipAlloc(FullPathNameSize);
            if (FullPathName == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RetValue = GetFullPathName(strLogFileName, FullPathNameSize, FullPathName, NULL); 
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileName = FullPathName;
                }
            }

            lenLogFileName = strlen(strLogFileName);
            if (lenLogFileName > 0) {
                ANSI_STRING ansiLogFileName;

                RtlInitAnsiString(& ansiLogFileName, strLogFileName);
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));

                Status = RtlAnsiStringToUnicodeString(
                        & LoggerInfo->LogFileName, & ansiLogFileName, FALSE);
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipNtStatusToDosError(Status);
                    goto Cleanup;
                }
            }
        }
        // stuff the loggerhandle in Wnode
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers the Guid is required to  determine the provider
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;
        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = WmipQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = WmipStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            WmipCopyPropertiesToInfo((PEVENT_TRACE_PROPERTIES) Properties,
                                     LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            ErrorCode = WmipQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = WmipFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry 
    // with sufficient buffer space for the two strings. The size required 
    // is returned in the MaximuumLength field. 
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                WmipFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                WmipFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }


        if (ErrorCode == ERROR_SUCCESS) {
            ANSI_STRING String;
            PCHAR pLoggerName, pLogFileName;
            ULONG BytesAvailable;
            ULONG Length = 0;
//
// need to convert the strings back
//
            WmipCopyInfoToProperties(
                LoggerInfo, 
                (PEVENT_TRACE_PROPERTIES)Properties);

            WmipFixupLoggerStrings(LoggerInfo);

            if (Properties->LoggerNameOffset == 0) 
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset > Properties->LogFileNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else
                BytesAvailable =  Properties->LogFileNameOffset -
                                  Properties->LoggerNameOffset;

            Status = RtlUnicodeStringToAnsiString(
                                &String, &LoggerInfo->LoggerName, TRUE);
            if (NT_SUCCESS(Status)) {
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + Length 
                                            + LoggerInfo->LogFileName.Length + 2 * sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PCHAR) ((PCHAR)Properties +
                                Properties->LoggerNameOffset);
                    RtlZeroMemory(pLoggerName, BytesAvailable);
                    if (Length > 0) {
                        strncpy(pLoggerName, String.Buffer, Length);
                    }
                }
                RtlFreeAnsiString(&String);
                ErrorCode = RtlNtStatusToDosError(Status);
            }

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset + 
                                                Length;
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset)
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            Status = RtlUnicodeStringToAnsiString(
                                    &String, &LoggerInfo->LogFileName, TRUE);

            if (NT_SUCCESS(Status)) {
                Length = String.Length;
                if (BytesAvailable < (Length + sizeof(CHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = (Properties->Wnode.BufferSize - BytesAvailable) + Length + sizeof(CHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {
                    pLogFileName = (PCHAR) ((PCHAR)Properties +
                                                    Properties->LogFileNameOffset);
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    strncpy(pLogFileName, String.Buffer, Length );
                }
                RtlFreeAnsiString(&String);
                ErrorCode = RtlNtStatusToDosError(Status);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipNtStatusToDosError(GetExceptionCode());
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL) 
        WmipFree(FullPathName);
    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE LoggerHandle,
    IN LPCWSTR LoggerName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG Control
    )
/*++

Routine Description:

    This is the ANSI version routine to control and query an existing logger.
    The caller must pass in either a valid handle, or a logger name to
    reference the logger instance. If both are given, the logger name will
    be used.

Arguments:

    LoggerHandle    The handle to the logger instance.

    LoggerName      A instance name for the logger

    Properties      Logger properties to be returned to the caller.

    Control         This can be one of the following:
                    EVENT_TRACE_CONTROL_QUERY     - to query the logger
                    EVENT_TRACE_CONTROL_STOP      - to stop the logger
                    EVENT_TRACE_CONTROL_UPDATE    - to update the logger
                    EVENT_TRACE_CONTROL_FLUSH     - to flush the logger

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode;
    BOOLEAN IsKernelTrace = FALSE;

    PWMI_LOGGER_INFORMATION LoggerInfo     = NULL;
    PWCHAR                  strLoggerName  = NULL;
    PWCHAR                  strLogFileName = NULL;
    ULONG                   sizeNeeded     = 0;
    PWCHAR                  FullPathName = NULL;
    ULONG                   LoggerNameLen = MAXSTR;
    ULONG                   LogFileNameLen = MAXSTR;
    ULONG                   RetValue;

    WmipInitProcessHeap();
    
    if (Properties == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    try {
        if (Properties->Wnode.BufferSize < sizeof(EVENT_TRACE_PROPERTIES) ) {
            ErrorCode = ERROR_BAD_LENGTH;
            goto Cleanup;
        }
        //
        // If the caller supplied loggername and LogFileName offsets
        // make sure they are in range.
        //

        if (Properties->LoggerNameOffset > 0) {
            if ((Properties->LoggerNameOffset < sizeof (EVENT_TRACE_PROPERTIES))
            || (Properties->LoggerNameOffset > Properties->Wnode.BufferSize)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (Properties->LogFileNameOffset > 0) {
            if ((Properties->LogFileNameOffset < sizeof(EVENT_TRACE_PROPERTIES))
            || (Properties->LogFileNameOffset > Properties->Wnode.BufferSize))
            {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        if (LoggerName != NULL) {
            LoggerNameLen = wcslen(LoggerName) + 1;
            //
            // Rules for Kernel Logger Identification when a string is given instead of handle
            // 1. If the logger name is "NT Kernel Logger", it is the kernel logger, and 
            //    the System GUID is copied as well.
            // 2. If the GUID is equal to the System GUID, but not the name, reject the session.
            // 3. If the logger name is null or of size 0, and the GUID is equal to the System 
            //    GUID, let it proceed as the kernel logger.
            //
            if (!wcscmp(LoggerName, KERNEL_LOGGER_NAMEW)) {
                Properties->Wnode.Guid = SystemTraceControlGuid;
            }
            else if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) { 
                // LoggerName is not "NT Kernel Logger", but Guid is
                if (wcslen(LoggerName) > 0) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }
        if (IsEqualGUID(&Properties->Wnode.Guid, &SystemTraceControlGuid)) {
            IsKernelTrace = TRUE;
        }
        if ((LoggerHandle == 0) && (!IsKernelTrace)) {
            if ((LoggerName == NULL) || (wcslen(LoggerName) <= 0)) {
                ErrorCode = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = ERROR_NOACCESS;
        goto Cleanup;
    }

RetryFull:
    //
    // Add an extra 16 characters to the LogFileName since the UMLogger 
    // could munge the name to add the PIDs at the end. 
    //
    LogFileNameLen += 16;
    sizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + (LoggerNameLen + LogFileNameLen) * sizeof(WCHAR);

    sizeNeeded = (sizeNeeded +7) & ~7;
    LoggerInfo = (PWMI_LOGGER_INFORMATION) WmipAlloc(sizeNeeded);
    if (LoggerInfo == NULL) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(LoggerInfo, sizeNeeded);

    strLoggerName  = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION));
    WmipInitString(&LoggerInfo->LoggerName,
                   strLoggerName,
                   LoggerNameLen * sizeof(WCHAR));
    strLogFileName = (PWCHAR) (  ((PUCHAR) LoggerInfo)
                            + sizeof(WMI_LOGGER_INFORMATION)
                            + LoggerNameLen * sizeof(WCHAR));
    WmipInitString(&LoggerInfo->LogFileName,
                   strLogFileName,
                   LogFileNameLen * sizeof(WCHAR));
    try {
        if (LoggerName != NULL) {
            if (wcslen(LoggerName) > 0) {
                wcscpy(strLoggerName, (PWCHAR) LoggerName);
                RtlInitUnicodeString(&LoggerInfo->LoggerName, strLoggerName);
            }
        }
        
        if (Properties->LogFileNameOffset >= sizeof(EVENT_TRACE_PROPERTIES)) {
            ULONG  lenLogFileName;
            PWCHAR strLogFileName;
            ULONG FullPathNameSize = MAXSTR;

            strLogFileName = (PWCHAR) (  ((PCHAR) Properties)
                                       + Properties->LogFileNameOffset);

Retry:
            FullPathName = WmipAlloc(FullPathNameSize * sizeof(WCHAR));
            if (FullPathName == NULL) {
                ErrorCode = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            RetValue = GetFullPathNameW(strLogFileName, FullPathNameSize, FullPathName, NULL);
            if (RetValue != 0) {
                if (RetValue > FullPathNameSize) {
                    WmipFree(FullPathName);
                    FullPathNameSize = RetValue;
                    goto Retry;
                }
                else {
                    strLogFileName = FullPathName;
                }
            }

            lenLogFileName = wcslen(strLogFileName);
            LoggerInfo->LogFileName.Buffer = (PWCHAR)
                        (((PCHAR) LoggerInfo) + sizeof(WMI_LOGGER_INFORMATION)
                                + LoggerInfo->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                LoggerInfo->LogFileName.MaximumLength =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName + 1));
                LoggerInfo->LogFileName.Length =
                        sizeof(WCHAR) * ((USHORT) (lenLogFileName));
                wcsncpy(LoggerInfo->LogFileName.Buffer,
                        strLogFileName,
                        lenLogFileName);
            }
            else {
                LoggerInfo->LogFileName.Length = 0;
                LoggerInfo->LogFileName.MaximumLength = MAXSTR * sizeof(WCHAR);
            }
        }

        LoggerInfo->LogFileMode = Properties->LogFileMode;
        LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
        LoggerInfo->Wnode.BufferSize = sizeNeeded;
        LoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

        //
        // For Private Loggers, the Guid must be supplied
        //

        LoggerInfo->Wnode.Guid = Properties->Wnode.Guid;

        switch (Control) {
        case EVENT_TRACE_CONTROL_QUERY  :
            ErrorCode = WmipQueryLogger(LoggerInfo, FALSE);
            break;
        case EVENT_TRACE_CONTROL_STOP   :
            ErrorCode = WmipStopLogger(LoggerInfo);
            break;
        case EVENT_TRACE_CONTROL_UPDATE :
            WmipCopyPropertiesToInfo(Properties, LoggerInfo);
            LoggerInfo->Wnode.HistoricalContext = LoggerHandle;
            ErrorCode = WmipQueryLogger(LoggerInfo, TRUE);
            break;
        case EVENT_TRACE_CONTROL_FLUSH :
            ErrorCode = WmipFlushLogger(LoggerInfo); 
            break;

        default :
            ErrorCode = ERROR_INVALID_PARAMETER;
        }

    //
    // The Kernel call could fail with ERROR_MORE_DATA and we need to retry
    // with sufficient buffer space for the two strings. The size required
    // is returned in the MaximuumLength field.
    //

        if (ErrorCode == ERROR_MORE_DATA) {
            LogFileNameLen = LoggerInfo->LogFileName.MaximumLength / sizeof(WCHAR);
            LoggerNameLen = LoggerInfo->LoggerName.MaximumLength / sizeof(WCHAR);
            if (LoggerInfo != NULL) {
                WmipFree(LoggerInfo);
                LoggerInfo = NULL;
            }
            if (FullPathName != NULL) {
                WmipFree(FullPathName);
                FullPathName = NULL;
            }
            goto RetryFull;
        }
    
        if (ErrorCode == ERROR_SUCCESS) {
            ULONG Length = 0;
            ULONG BytesAvailable = 0;
            PWCHAR pLoggerName, pLogFileName;
            WmipCopyInfoToProperties(LoggerInfo, Properties);

            WmipFixupLoggerStrings(LoggerInfo);

            if (Properties->LoggerNameOffset == 0)
                Properties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

            if (Properties->LoggerNameOffset >  Properties->LogFileNameOffset ) 
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LoggerNameOffset;
            else 
                BytesAvailable =  Properties->LogFileNameOffset - 
                                  Properties->LoggerNameOffset;
            Length = LoggerInfo->LoggerName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR) )) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) + 
                                                   Length + LoggerInfo->LogFileName.Length + 2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                    goto Cleanup;
                }
                else {
                    pLoggerName = (PWCHAR) ((PCHAR)Properties + 
                                                Properties->LoggerNameOffset);
                    wcsncpy(pLoggerName, LoggerInfo->LoggerName.Buffer, Length/2 );
                }
            }

            if (Properties->LogFileNameOffset == 0) {
                Properties->LogFileNameOffset = Properties->LoggerNameOffset +
                                                Length;
            }

            if (Properties->LogFileNameOffset > Properties->LoggerNameOffset )
                BytesAvailable = Properties->Wnode.BufferSize -
                                 Properties->LogFileNameOffset;
            else
                BytesAvailable =  Properties->LoggerNameOffset -
                                  Properties->LogFileNameOffset;

            //
            // Check for space to return LogFileName. 
            //
            Length = LoggerInfo->LogFileName.Length;
            if (Length > 0) {
                if (BytesAvailable < (Length + sizeof(WCHAR)) ) {
                    PWNODE_TOO_SMALL WnodeSmall = (PWNODE_TOO_SMALL) Properties;
                    WnodeSmall->SizeNeeded = sizeof(EVENT_TRACE_PROPERTIES) +
                                                   Length + LoggerInfo->LogFileName.Length + 2 * sizeof(WCHAR);
                    WnodeSmall->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;

                    Length = BytesAvailable - sizeof(WCHAR);
                    ErrorCode = ERROR_MORE_DATA;
                }
                else {

                    pLogFileName = (PWCHAR) ((PCHAR)Properties +
                                                    Properties->LogFileNameOffset);
                    RtlZeroMemory(pLogFileName, BytesAvailable);

                    wcsncpy(pLogFileName, 
                            LoggerInfo->LogFileName.Buffer, Length/2 );
               }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ErrorCode = WmipNtStatusToDosError(GetExceptionCode());
    }

Cleanup:
    if (LoggerInfo != NULL)
        WmipFree(LoggerInfo);
    if (FullPathName != NULL)
        WmipFree(FullPathName);

    return WmipSetDosError(ErrorCode);
}

ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    )
{
    ULONG status;
    PTRACE_ENABLE_CONTEXT pTraceHandle = (PTRACE_ENABLE_CONTEXT)&TraceHandle;
    PWMI_LOGGER_INFORMATION pLoggerInfo;
    ULONG Flags;
    GUID Guid;
    BOOLEAN IsKernelTrace = FALSE;
    ULONG SizeNeeded = 0;
    ULONG RetryCount = 1;

    WmipInitProcessHeap();

    // We only accept T/F for Enable code. In future, we really should take
    // enumerated request codes. Declaring the Enable as ULONG instead
    // of BOOLEAN should give us room for expansion.

    if ( (ControlGuid == NULL) 
         || (EnableLevel > 255) 
         || ((Enable != TRUE) && (Enable != FALSE)) ) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    try {
        Guid = *ControlGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }

    //
    // Check to see the Heap and CritSec Guid
    //

    if( IsEqualGUID(&HeapGuid,&Guid) 
        || IsEqualGUID(&CritSecGuid,&Guid)
        ){

        WMITRACEENABLEDISABLEINFO TraceEnableInfo;
        ULONG ReturnSize;

        TraceEnableInfo.Guid = Guid;
        TraceEnableInfo.Enable = (BOOLEAN)Enable;

        status =  WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENABLE_DISABLE_TRACELOG,
                                       &TraceEnableInfo,
                                      sizeof(WMITRACEENABLEDISABLEINFO),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);

        return WmipSetDosError(status);
    }

    //
    // Check to see if this is a valid TraceHandle or not by query
    //
    SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + 2 * MAXSTR;

Retry:

    SizeNeeded = (SizeNeeded +7) & ~7;

    pLoggerInfo = WmipAlloc(SizeNeeded);
    if (pLoggerInfo == NULL) {
        return WmipSetDosError(ERROR_OUTOFMEMORY);
    }

    RtlZeroMemory(pLoggerInfo, SizeNeeded);
    pLoggerInfo->Wnode.HistoricalContext = TraceHandle;
    if (IsEqualGUID(&Guid, &SystemTraceControlGuid)) {
        WmiSetLoggerId(KERNEL_LOGGER_ID, &pLoggerInfo->Wnode.HistoricalContext);
        IsKernelTrace = TRUE;
    }
    else {
        // Validate TraceHandle is in range
       pLoggerInfo->Wnode.HistoricalContext = TraceHandle;
    }
    pLoggerInfo->Wnode.BufferSize = SizeNeeded;
    pLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;

    //
    // For PRIVATE logger, We need the Guid to determine the Provider
    //
    pLoggerInfo->Wnode.Guid   = Guid;

    status = WmipQueryLogger(pLoggerInfo, FALSE);
    if (status != ERROR_SUCCESS) {
        WmipFree(pLoggerInfo);

        if ((status == ERROR_MORE_DATA) && 
            (pTraceHandle->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
            SizeNeeded = RetryCount * (sizeof(WMI_LOGGER_INFORMATION) 
                                       + 2 * MAXSTR);
            if (RetryCount++ > TRACE_RETRY_COUNT) 
                return WmipSetDosError(status);
            goto Retry;
        }
        return WmipSetDosError(status);
    }

    if (IsKernelTrace) {
        Flags = pLoggerInfo->EnableFlags; 
        //
        // If Enabling, we need to pass down the final state of the flags
        // ie., the old flags plus the new flags. 
        // If disabling, we need to pass down the only the flags that 
        // are already turned on and being turned off now. 
        //
        if (Enable) {
            Flags |= EnableFlag;
        }
        else {
            Flags &= EnableFlag;
        } 

        // 
        // At this point if the Flags are 0, then no change is being 
        // requested. 
        //
        
        if (Flags) {
            pLoggerInfo->EnableFlags = Flags;
            status = WmipQueryLogger(pLoggerInfo, TRUE);
        }
        WmipFree(pLoggerInfo);
        return WmipSetDosError(status); 
    }
    else {
        WmipFree(pLoggerInfo);
        pTraceHandle->Level = (UCHAR)EnableLevel;
    }

    pTraceHandle->EnableFlags = EnableFlag;
    
    //
    // This is done from the Control Process which can call this API for 
    // any known Guid. The service must maintain the information about 
    // whether the Guid is a valid Trace Guid or not. 
    //
    if (TraceHandle == (TRACEHANDLE)0) {
       return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }
    
    try {
            status = WmipNotificationRegistration(
                        &Guid,
                        (UCHAR)Enable,
                        (NOTIFICATIONCALLBACK) 0x0,
                        0, 
                        TraceHandle,
                        NOTIFICATION_TRACE_FLAG, FALSE);
            if (status != ERROR_SUCCESS)
                return WmipSetDosError(status);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }
    return WmipSetDosError(status);
}



ULONG
WmipTraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PWNODE_HEADER Wnode
    )
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    PEVENT_TRACE_HEADER EventTrace = (PEVENT_TRACE_HEADER)Wnode;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;


    Wnode->HistoricalContext = LoggerHandle;
    if ( (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) && (WmipIsBBTOn == 0) ) {
            goto UmOnly;
    }

    Size = EventTrace->Size;
    //
    // Now the LoggerHandle is expected to be filled in by the caller.
    //  But check to see if it has a valid value.
    //

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
         return ERROR_INVALID_HANDLE;
    }

    if (WmipIsBBTOn) {
        WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &Wnode->HistoricalContext);
    }

	NtStatus = NtTraceEvent(NULL,
                            ETW_NT_FLAGS_TRACE_HEADER,
                            sizeof(WNODE_HEADER),
                            Wnode);

	return WmipNtStatusToDosError( NtStatus );

UmOnly:

    return WmiTraceUmEvent(Wnode);

}


ULONG 
WMIAPI
TraceEvent(
    IN TRACEHANDLE LoggerHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    )
{
    ULONG Status, SavedMarker;
    PULONG TraceMarker;
    ULONG Size;
    ULONGLONG SavedGuidPtr;
    BOOLEAN RestoreSavedGuidPtr = FALSE;
    // PWNODE_HEADER Wnode = (PWNODE_HEADER) EventTrace;
    ULONG Flags;

    WmipInitProcessHeap();
    
    if (EventTrace == NULL ) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        TraceMarker = (PULONG) EventTrace;
        SavedMarker = *TraceMarker;

        Flags = EventTrace->Flags;

        EventTrace->Flags |= WNODE_FLAG_TRACED_GUID; 
        
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_TRACE_HEADER)) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        *TraceMarker = 0;
        EventTrace->Size = (USHORT)Size;
        
        *TraceMarker |= TRACE_HEADER_FULL;
        if (EventTrace->Flags & WNODE_FLAG_USE_GUID_PTR) {
            RestoreSavedGuidPtr = TRUE;
            SavedGuidPtr = EventTrace->GuidPtr;
        }
        Status = WmipTraceEvent(LoggerHandle, (PWNODE_HEADER) EventTrace);
        *TraceMarker = SavedMarker;
        EventTrace->Flags = Flags;
        if (RestoreSavedGuidPtr) {
            EventTrace->GuidPtr = SavedGuidPtr;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError( GetExceptionCode() );
    }

    return WmipSetDosError(Status);
}




ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE  LoggerHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    )
{
    PULONG TraceMarker;
    PGUIDMAPENTRY GuidMapEntry;
    ULONG Size, SavedMarker;
    ULONG Flags;
    // PWNODE_HEADER Wnode = (PWNODE_HEADER) EventTrace;
    PEVENT_INSTANCE_HEADER InstanceHeader= (PEVENT_INSTANCE_HEADER) EventTrace;
    ULONG Status;

    WmipInitProcessHeap();
    
    if ((EventTrace == NULL ) || (pInstInfo == NULL)) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        Flags = EventTrace->Flags;
        TraceMarker = (PULONG) EventTrace;
        SavedMarker = *TraceMarker;
        Flags |= WNODE_FLAG_TRACED_GUID; 
        
        Size = EventTrace->Size;
        if (Size < sizeof(EVENT_INSTANCE_HEADER)) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        GuidMapEntry =  (PGUIDMAPENTRY) pInstInfo->RegHandle;
        if (GuidMapEntry == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        *TraceMarker = 0;
        EventTrace->Size = (USHORT)Size;
        
        *TraceMarker |= TRACE_HEADER_INSTANCE;

        //
        // With EVENT_INSTANCE_HEADER we don't want the logger
        // to try to dereference the GuidPtr since it is
        // just a hash value for the Guid and not really a LPGUID.
        //

        if (EventTrace->Flags & WNODE_FLAG_USE_GUID_PTR) {
            EventTrace->Flags  &= ~WNODE_FLAG_USE_GUID_PTR;
        }

        InstanceHeader->InstanceId = pInstInfo->InstanceId;
        InstanceHeader->RegHandle= GuidMapEntry->GuidMap.GuidMapHandle;
        if (pParentInstInfo != NULL) {
            GuidMapEntry =  (PGUIDMAPENTRY) pParentInstInfo->RegHandle;
            if (GuidMapEntry == NULL) {
                *TraceMarker = SavedMarker;
                return WmipSetDosError(ERROR_INVALID_PARAMETER);
            }
            InstanceHeader->ParentInstanceId =
                                   pParentInstInfo->InstanceId;
            InstanceHeader->ParentRegHandle =
                                   GuidMapEntry->GuidMap.GuidMapHandle;
        }

        Status = WmipTraceEvent(LoggerHandle, (PWNODE_HEADER) EventTrace);

        EventTrace->Flags = Flags;
        *TraceMarker = SavedMarker;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError( GetExceptionCode() );
    }

    return WmipSetDosError(Status);
}

ULONG 
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    )
{

    GUID Guid;
    ULONG SizeNeeded, StringPos, StringSize, WmiRegSize;
    PWMIREGINFOW pWmiRegInfo;
    PTRACE_GUID_REGISTRATION GuidRegPtr;
    PWMIREGGUIDW WmiRegGuidPtr;
    PWCHAR StringPtr;
    PGUIDMAPENTRY pGuidMapEntry, pControlGMEntry;
    PTRACEGUIDMAP GuidMapHandle = NULL, TraceGuidMap = NULL;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    PTRACE_REG_PACKET RegPacket;
    TRACEHANDLE LoggerContext = 0;
    HANDLE InProgressEvent = NULL, TraceCtxHandle;
    ULONG RegistrationCookie;
    ULONG Status;
    ULONG i;

    WmipInitProcessHeap();
    
    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (GuidCount <= 0) ||
        (GuidReg == NULL)  ||
        (ControlGuid == NULL) ||
        (GuidCount > WMIMAXREGGUIDCOUNT) )
    {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    try {
        Guid = *ControlGuid;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(WmipNtStatusToDosError(GetExceptionCode()));
    }

    // 
    // Allocate temporary space (WMIREGINFO and TRACEGUIDMAP).
    // 

    //
    // Get size for WMIREGINFO for controlGuid + GuidCount.
    //
    GuidCount++;
    StringPos = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW);
    WmiRegSize = StringPos;
    if (MofImagePath == NULL) {
        MofImagePath = L"";
    }

    if (MofResourceName != NULL) {
        WmiRegSize += (wcslen(MofResourceName) + 2) * sizeof(WCHAR);
    }
    WmiRegSize += (wcslen(MofImagePath) + 2) * sizeof(WCHAR);
    WmiRegSize = (WmiRegSize + 7) & ~7;
    SizeNeeded = WmiRegSize;

    //
    // Get size for the storage for the GUIDMAPHANDLE structure
    //
    SizeNeeded += sizeof(TRACEGUIDMAP) * GuidCount;

    pWmiRegInfo = WmipAlloc(SizeNeeded);

    if (pWmiRegInfo != NULL) // Temporary space allocation succeeded
    {
        // Zero memory before losng SizeNeeded
        RtlZeroMemory(pWmiRegInfo, SizeNeeded);

        //
        // Allocate space for persistent (non-temporary) structures (List for GuidMapEntrys and TraceRegInfo)
        //

        //
        // Get size for pControlGMEntry
        //
        SizeNeeded = sizeof(GUIDMAPENTRY);
        //
        // Get size for pTraceRegInfo
        //
        SizeNeeded += sizeof(TRACE_REG_INFO);
        //
        // Get size for Guid Map Entries
        //
        SizeNeeded += sizeof(GUIDMAPENTRY) * GuidCount;

        pControlGMEntry = WmipAlloc(SizeNeeded);

        if (pControlGMEntry != NULL) // Persistent space allocation succeeded.
        {
            // Zero memory before losng SizeNeeded
            RtlZeroMemory(pControlGMEntry, SizeNeeded);

            //
            // Initialize WmiRegInfo
            //
            pWmiRegInfo->BufferSize = WmiRegSize;
            pWmiRegInfo->GuidCount = GuidCount;

            WmiRegGuidPtr = &pWmiRegInfo->WmiRegGuid[0];
            WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
            WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;

            try {
                *RegistrationHandle = (TRACEHANDLE) 0;    
                WmiRegGuidPtr->Guid = Guid;
                for (i = 1; i < GuidCount; i++) {
                    WmiRegGuidPtr = &pWmiRegInfo->WmiRegGuid[i];
                    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
                    GuidRegPtr = &GuidReg[i-1];
                    WmiRegGuidPtr->Guid = *GuidRegPtr->Guid;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                WmipFree(pWmiRegInfo);
                WmipFree(pControlGMEntry);
                return WmipSetDosError(WmipNtStatusToDosError(GetExceptionCode()));
            }
            // Copy MOF resource path and name into WmiRegInfo
            if (MofResourceName != NULL) {
                pWmiRegInfo->MofResourceName = StringPos;
                StringPtr = (PWCHAR)OffsetToPtr(pWmiRegInfo, StringPos);
                Status = WmipCopyStringToCountedUnicode(MofResourceName,
                                                        StringPtr,
                                                        &StringSize,
                                                        FALSE);
                StringPos += StringSize;
                WmipAssert(StringPos <= WmiRegSize);
            }
            if (MofImagePath != NULL) {
                pWmiRegInfo->RegistryPath = StringPos;
                StringPtr = (PWCHAR)OffsetToPtr(pWmiRegInfo, StringPos);
                Status = WmipCopyStringToCountedUnicode(MofImagePath,
                                                        StringPtr,
                                                        &StringSize,
                                                        FALSE);
                StringPos += StringSize;
                WmipAssert(StringPos <= WmiRegSize);
            }
            //
            // Assign pointer to Guid Map Handle (no initialization needed here)
            //
            GuidMapHandle = (PTRACEGUIDMAP)((PUCHAR)pWmiRegInfo + WmiRegSize);

            //
            // Initialize pControlGMEntry
            //
            InitializeListHead(&pControlGMEntry->Entry);
            //
            // Initialize TraceRegInfo
            //
            pTraceRegInfo = (PTRACE_REG_INFO)((PUCHAR)pControlGMEntry + sizeof(GUIDMAPENTRY));
            pControlGMEntry->pControlGuidData = pTraceRegInfo;
            pTraceRegInfo->NotifyRoutine = RequestAddress;
            //
            // Initialize the list of Guid Map Entries.
            //
            pGuidMapEntry = (PGUIDMAPENTRY)((PUCHAR)pTraceRegInfo + sizeof(TRACE_REG_INFO));
            for (i=1; i < GuidCount; i++) {
                InsertTailList(&pControlGMEntry->Entry, &pGuidMapEntry->Entry);
                pGuidMapEntry = (PGUIDMAPENTRY)((PUCHAR)pGuidMapEntry + sizeof(GUIDMAPENTRY));
            }
            //
            // Manual reset, Initially not signalled
            //
            InProgressEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (InProgressEvent != NULL) // CreateEvent succeeded
            {
                pTraceRegInfo->InProgressEvent = InProgressEvent;
                //
                // Allocate Registration Cookie 
                // 
                RegistrationCookie = WmipAllocateCookie(pControlGMEntry, 
                                                        RequestContext,
                                                        (LPGUID)&Guid);
                if (RegistrationCookie != 0) // Cookie allocation succeeded
                {
                    pTraceRegInfo->RegistrationCookie = RegistrationCookie;
#ifdef DBG
                    WmipDebugPrint(("WMI TRACE REG: AllocateCookie %d Callback %X\n", 
                                RegistrationCookie, RequestAddress));
#endif
                }
                else // Cookie allocation failed
                {
                    pTraceRegInfo->InProgressEvent = NULL;
                    NtClose(InProgressEvent);
                    WmipFree(pWmiRegInfo);
                    WmipFree(pControlGMEntry);
                    return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
                }
            } 
            else // CreateEvent failed
            {
                WmipFree(pWmiRegInfo);
                WmipFree(pControlGMEntry);
                return WmipSetDosError(ERROR_OBJECT_NOT_FOUND);
            }
        } 
        else // Persistent space allocation failed
        {
            WmipFree(pWmiRegInfo);
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
    } 
    else // Temporary space allocation failed
    {
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    Status = WmipRegisterGuids(&RegisterReservedGuid,
                               RegistrationCookie,
                               pWmiRegInfo,
                               GuidCount,
                               &GuidMapHandle,
                               &LoggerContext,
                               &TraceCtxHandle);

    if (Status == ERROR_SUCCESS) // Call to Kernel succeeded
    {
        TraceGuidMap = &GuidMapHandle[0];
        pControlGMEntry->GuidMap = *TraceGuidMap; 
        pTraceRegInfo->TraceCtxHandle = TraceCtxHandle;
        try 
        {
            PLIST_ENTRY Head, Next;
            RegPacket = (PTRACE_REG_PACKET)RegistrationHandle;
            RegPacket->RegistrationCookie = RegistrationCookie; 
            Head = &pControlGMEntry->Entry;
            Next = Head->Flink;
            for (i = 1; ((i < GuidCount) && (Head != Next)); i++) {
                pGuidMapEntry = CONTAINING_RECORD(Next, GUIDMAPENTRY,Entry);
                Next = Next->Flink;
                pGuidMapEntry->InstanceId = 0;
                TraceGuidMap = &GuidMapHandle[i];
                pGuidMapEntry->GuidMap = *TraceGuidMap;
                GuidRegPtr = &GuidReg[i-1];
                GuidRegPtr->RegHandle = pGuidMapEntry;
             }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = WmipNtStatusToDosError(GetExceptionCode());
        }

        if (Status == ERROR_SUCCESS) // Guid Map Entry List initialization succeeded
        {
            //
            // Place the registration handle on the list of handles to
            // wait for notifications from
            //
            Status = WmipAddHandleToEventPump(&Guid,
                                             (PVOID)TraceCtxHandle, // Needed for UM Logger to Reply 
                                             0,
                                             0,
                                             TraceCtxHandle);
            if (Status == ERROR_SUCCESS && LoggerContext) // Adding handle to pump succeeded
            {
                //
                // We will make the Enable/Disable notification here.
                //
                WNODE_HEADER Wnode;
                PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerContext;
                ULONG InOutSize;
                BOOLEAN DeliverNotification = TRUE;
                RtlZeroMemory(&Wnode, sizeof(Wnode));
                Wnode.BufferSize = sizeof(Wnode);
                Wnode.HistoricalContext = LoggerContext;
                Wnode.Guid = Guid; 
                if (pContext->InternalFlag & 
                    EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
                    // Before Delivering this Notification
                    // make sure that the Process Private logger
                    // is running. 
                    pTraceRegInfo->EnabledState = TRUE;
                    if (!WmipIsPrivateLoggerOn()) {
                        DeliverNotification = FALSE;
                    }     
                }
                if (DeliverNotification) {
                    try {
                        InOutSize = Wnode.BufferSize;
                        Status = (RequestAddress)(WMI_ENABLE_EVENTS,
                                     RequestContext,
                                     &InOutSize,
                                     &Wnode);
                    } except (EXCEPTION_EXECUTE_HANDLER) {
    #if DBG
                        Status = GetExceptionCode();
                        WmipDebugPrint(("WMI: Enable Call caused exception%d\n",
                            Status));
    #endif
                        Status = ERROR_WMI_DP_FAILED;
                    }
                }
            }
        }
		if (Status != ERROR_SUCCESS) // One of the three failed: Enable, Adding handle to a pump, or Guid Map Entry List initialization
        {
			NtSetEvent(InProgressEvent, NULL);
			pTraceRegInfo->InProgressEvent = NULL;
			NtClose(InProgressEvent);
			WmipFree(pWmiRegInfo);
            UnregisterTraceGuids(*RegistrationHandle);
            *RegistrationHandle = 0;
			return (WmipSetDosError(Status));
        }
    } 
    else // Call to Kernel failed
    {
        // Cannot call UnregisterTraceGuids() so we need to clean up here
		NtSetEvent(InProgressEvent, NULL);
		pTraceRegInfo->InProgressEvent = NULL;
		NtClose(InProgressEvent);
		WmipFree(pWmiRegInfo);
        WmipFree(pControlGMEntry);
        WmipFreeCookie(RegistrationCookie);
		return (WmipSetDosError(Status));
    }

    NtSetEvent(InProgressEvent, NULL);
    pTraceRegInfo->InProgressEvent = NULL;
    NtClose(InProgressEvent);
    WmipFree(pWmiRegInfo);
    return (WmipSetDosError(Status));

}

ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST RequestAddress,
    IN PVOID        RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG        GuidCount,
    IN PTRACE_GUID_REGISTRATION GuidReg,
    IN LPCSTR       MofImagePath,
    IN LPCSTR       MofResourceName,
    IN PTRACEHANDLE  RegistrationHandle
    )
/*++

Routine Description:

    ANSI thunk to RegisterTraceGuidsW

--*/
{
    LPWSTR MofImagePathUnicode = NULL;
    LPWSTR MofResourceNameUnicode = NULL;
    ULONG Status;

    WmipInitProcessHeap();
    
    if ((RequestAddress == NULL) ||
        (RegistrationHandle == NULL) ||
        (GuidCount <= 0) ||
        (GuidReg == NULL)  ||
        (ControlGuid == NULL) || 
        (GuidCount > WMIMAXREGGUIDCOUNT) )
    {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    Status = AnsiToUnicode(MofImagePath, &MofImagePathUnicode);
    if (Status == ERROR_SUCCESS) {
        if (MofResourceName) {
            Status = AnsiToUnicode(MofResourceName, &MofResourceNameUnicode);
        }
        if (Status == ERROR_SUCCESS) {

            Status = RegisterTraceGuidsW(RequestAddress,
                                        RequestContext,
                                        ControlGuid,
                                        GuidCount,
                                        GuidReg,
                                        MofImagePathUnicode,
                                        MofResourceNameUnicode,
                                        RegistrationHandle
                                        );
            if (MofResourceNameUnicode) {
                WmipFree(MofResourceNameUnicode);
            }
        }
        if (MofImagePathUnicode) {
            WmipFree(MofImagePathUnicode);
        }
    }
    return(Status);
}

ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    )
{
    // First check if the handle belongs to a Trace Control Guid. 
    // Then UnRegister all the regular trace guids controlled by 
    // this control guid and free up the storage allocated to maintain 
    // the TRACEGUIDMAPENTRY structures.

    // Get to the real Registration Handle, stashed away in 
    // in the internal structures and pass it onto the call.  

    PGUIDMAPENTRY pControlGMEntry, GuidMapBase;
    WMIHANDLE WmiRegistrationHandle;
    PLIST_ENTRY Next, Head;
    ULONG Status;
    PVOID RequestContext;
    PTRACE_REG_INFO pTraceRegInfo = NULL;
    PTRACE_REG_PACKET RegPacket; 
    GUID ControlGuid;
    ULONG64 LoggerContext = 0;
    WMIDPREQUEST RequestAddress;

    WmipInitProcessHeap();
    
    if (RegistrationHandle == 0) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    RegPacket = (PTRACE_REG_PACKET)&RegistrationHandle;

    if (!WmipLookupCookie(RegPacket->RegistrationCookie, 
                          NULL,
                          &pControlGMEntry,
                          &RequestContext) ){
        WmipDebugPrint(("WMI: LOOKUP COOKIE FAILED\n"));
        return(ERROR_INVALID_PARAMETER);
    }
        
    try {

        if (pControlGMEntry->pControlGuidData == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

    //
    // Free the Registration Cookie 
    //

        pTraceRegInfo = pControlGMEntry->pControlGuidData;
        RequestAddress = pTraceRegInfo->NotifyRoutine;

        WmipGetGuidInCookie(pTraceRegInfo->RegistrationCookie, &ControlGuid);

        WmipFreeCookie(pTraceRegInfo->RegistrationCookie);
        WmiRegistrationHandle = (WMIHANDLE)pTraceRegInfo->TraceCtxHandle;
        if (WmiRegistrationHandle == NULL) {
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        Status =  WmiUnregisterGuids(WmiRegistrationHandle, 
                                     &ControlGuid, 
                                     &LoggerContext);

    //
    // All the TraceGuidMapEntry structures are cleaned up when  
    // WmipFree(pControlGMEntry) is called. 
    //

    //
    // Check to see if we need to fire the Disable callback
    // before freeing the TraceRegInfo
    //

        if ((Status == ERROR_SUCCESS) && LoggerContext) {
            WNODE_HEADER Wnode;
            ULONG InOutSize = sizeof(Wnode);

            RtlZeroMemory(&Wnode, sizeof(Wnode));
            Wnode.BufferSize = sizeof(Wnode);
            Wnode.HistoricalContext = LoggerContext;
            Wnode.Guid = ControlGuid;
            Status = (RequestAddress)(WMI_DISABLE_EVENTS,
                            RequestContext,
                            &InOutSize,
                            &Wnode);
        }
        // This will clear all the space allocated (refer to RegisterTraceGuids())
        WmipFree(pControlGMEntry);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError(GetExceptionCode());
#ifdef DBG
        WmipDebugPrint(("WMI: Exception in UnRegisterTraceGuids Bad handle\n"));
#endif 
    }

    RegistrationHandle = 0;

    return WmipSetDosError(Status);
}

ULONG
WmipQueryAllUmTraceW(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    PWCHAR                     strSrcW;
    PWCHAR                     strDestW;

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = (LoggerInfoSize +7) & ~7;
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) WmipAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    WmipInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    WmipInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    status = WmipSendUmLogRequest(
                    (fEnabledOnly) ? (TRACELOG_QUERYENABLED) : (TRACELOG_QUERYALL),
                    pLoggerInfo
                    );

    if (status != ERROR_SUCCESS)
        goto Cleanup;

    while (i < PropertyArrayCount && Offset < SizeUsed) {

        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);

        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(WCHAR) * (lenLoggerName + 1)
               + sizeof(WCHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {

            WmipCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            strSrcW = (PWCHAR) (  ((PUCHAR) pLoggerInfoCurrent)
                                  + sizeof(WMI_LOGGER_INFORMATION));
            if (lenLoggerName > 0) {
                if (PropertyArray[i]->LoggerNameOffset == 0) {
                    PropertyArray[i]->LoggerNameOffset =
                                    sizeof(EVENT_TRACE_PROPERTIES);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LoggerNameOffset);
                wcsncpy(strDestW, strSrcW, lenLoggerName);
                strDestW[lenLoggerName] = 0;
            }

            strSrcW = (PWCHAR) (((PUCHAR) pLoggerInfoCurrent)
                              + sizeof(WMI_LOGGER_INFORMATION)
                              + pLoggerInfoCurrent->LoggerName.MaximumLength);
            if (lenLogFileName > 0) {
                if (PropertyArray[i]->LogFileNameOffset == 0) {
                    PropertyArray[i]->LogFileNameOffset =
                            PropertyArray[i]->LoggerNameOffset
                            + sizeof(WCHAR) * (lenLoggerName + 1);
                }
                strDestW = (PWCHAR) (  ((PUCHAR) PropertyArray[i])
                                     + PropertyArray[i]->LogFileNameOffset);
                wcsncpy(strDestW, strSrcW, lenLogFileName);
                strDestW[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        WmipFree(pLoggerInfo);

    return WmipSetDosError(status);
}

ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{
    ULONG i, status;
    ULONG returnCount = 0;
    EVENT_TRACE_PROPERTIES LoggerInfo;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;

    WmipInitProcessHeap();

    if ((LoggerCount == NULL)  
        || (PropertyArrayCount > MAXLOGGERS)
        || (PropertyArray == NULL)
        || (PropertyArrayCount == 0))
        return ERROR_INVALID_PARAMETER;
    if (*PropertyArray == NULL) 
        return ERROR_INVALID_PARAMETER;
    
    try {
        *LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            if (returnCount < PropertyArrayCount) {
                pLoggerInfo = PropertyArray[returnCount];
            }
            else {
                pLoggerInfo = &LoggerInfo; 
                RtlZeroMemory(pLoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                pLoggerInfo->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);
            }
            WmiSetLoggerId(i, &pLoggerInfo->Wnode.HistoricalContext);
            status = ControlTraceW(
                            (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                            NULL,
                            pLoggerInfo,
                            EVENT_TRACE_CONTROL_QUERY);
            if (status == ERROR_SUCCESS)
                returnCount++;
        }
        *LoggerCount = returnCount;
        status = WmipQueryAllUmTraceW(PropertyArray,
                                      FALSE,
                                      PropertyArrayCount,
                                      LoggerCount);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(ERROR_NOACCESS);
    }
    

    if (returnCount > PropertyArrayCount)
        return ERROR_MORE_DATA;
    else 
        return ERROR_SUCCESS;
}

ULONG
WmipQueryAllUmTraceA(
    OUT PEVENT_TRACE_PROPERTIES * PropertyArray,
    IN  BOOLEAN                   fEnabledOnly,
    IN  ULONG                     PropertyArrayCount,
    OUT PULONG                    LoggerCount)
{
    PWMI_LOGGER_INFORMATION    pLoggerInfo;
    PWMI_LOGGER_INFORMATION    pLoggerInfoCurrent;
    ULONG                      LoggerInfoSize;
    ULONG                      SizeUsed;
    ULONG                      SizeNeeded = 0;
    ULONG                      Length;
    ULONG                      lenLoggerName;
    ULONG                      lenLogFileName;
    ULONG                      Offset     = 0;
    ULONG                      i          = * LoggerCount;
    ULONG                      status;
    ANSI_STRING                strBufferA;
    PUCHAR                     strDestA;

    LoggerInfoSize = (PropertyArrayCount - i)
                   * (  sizeof(WMI_LOGGER_INFORMATION)
                      + 2 * MAXSTR * sizeof(WCHAR));
    LoggerInfoSize = (LoggerInfoSize +7) & ~7;
    pLoggerInfo    = (PWMI_LOGGER_INFORMATION) WmipAlloc(LoggerInfoSize);
    if (pLoggerInfo == NULL) {
        status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pLoggerInfo, LoggerInfoSize);
    Length = sizeof(WMI_LOGGER_INFORMATION);
    WmipInitString(& pLoggerInfo->LoggerName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    Length += MAXSTR * sizeof(WCHAR);
    WmipInitString(& pLoggerInfo->LogFileName,
                   (PWCHAR) ((PUCHAR) pLoggerInfo + Length),
                   MAXSTR * sizeof(WCHAR));
    SizeUsed = pLoggerInfo->Wnode.BufferSize = LoggerInfoSize;


    // 
    // TODO: Provide SizeNeeded case
    //

    status = WmipSendUmLogRequest(
                        (fEnabledOnly) ? (TRACELOG_QUERYENABLED)
                                       : (TRACELOG_QUERYALL),
                        pLoggerInfo
                    );

    if (status != ERROR_SUCCESS)
        goto Cleanup;


    while (i < PropertyArrayCount && Offset < SizeUsed) {
        PTRACE_ENABLE_CONTEXT pContext;

        pLoggerInfoCurrent = (PWMI_LOGGER_INFORMATION)
                             (((PUCHAR) pLoggerInfo) + Offset);
        pContext = (PTRACE_ENABLE_CONTEXT)
                        & pLoggerInfoCurrent->Wnode.HistoricalContext;
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;

        lenLoggerName = pLoggerInfoCurrent->LoggerName.Length / sizeof(WCHAR);
        if (lenLoggerName >= MAXSTR)
            lenLoggerName = MAXSTR - 1;

        lenLogFileName = pLoggerInfoCurrent->LogFileName.Length / sizeof(WCHAR);
        if (lenLogFileName >= MAXSTR)
            lenLogFileName = MAXSTR - 1;

        Length = sizeof(EVENT_TRACE_PROPERTIES)
               + sizeof(CHAR) * (lenLoggerName + 1)
               + sizeof(CHAR) * (lenLogFileName + 1);
        if (PropertyArray[i]->Wnode.BufferSize >= Length) {
            WmipCopyInfoToProperties(pLoggerInfoCurrent, PropertyArray[i]);

            if (lenLoggerName > 0) {
                pLoggerInfoCurrent->LoggerName.Buffer = (PWCHAR)
                                        (  ((PUCHAR) pLoggerInfoCurrent)
                                         + sizeof(WMI_LOGGER_INFORMATION));
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LoggerName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LoggerNameOffset == 0) {
                        PropertyArray[i]->LoggerNameOffset =
                                        sizeof(EVENT_TRACE_PROPERTIES);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LoggerNameOffset);
                    strcpy(strDestA, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLoggerName] = 0;
            }

            if (lenLogFileName > 0) {
                pLoggerInfoCurrent->LogFileName.Buffer = (PWCHAR)
                              (  ((PUCHAR) pLoggerInfoCurrent)
                               + sizeof(WMI_LOGGER_INFORMATION)
                               + pLoggerInfoCurrent->LoggerName.MaximumLength);
                status = RtlUnicodeStringToAnsiString(& strBufferA,
                                & pLoggerInfoCurrent->LogFileName, TRUE);
                if (NT_SUCCESS(status)) {
                    if (PropertyArray[i]->LogFileNameOffset == 0) {
                        PropertyArray[i]->LogFileNameOffset =
                                         sizeof(EVENT_TRACE_PROPERTIES)
                                       + sizeof(CHAR) * (lenLoggerName + 1);
                    }
                    strDestA = (PCHAR) (  ((PUCHAR) PropertyArray[i])
                                         + PropertyArray[i]->LogFileNameOffset);
                    strcpy(strDestA, strBufferA.Buffer);
                    RtlFreeAnsiString(& strBufferA);
                }
                strDestA[lenLogFileName] = 0;
            }
        }

        Offset = Offset
               + sizeof(WMI_LOGGER_INFORMATION)
               + pLoggerInfoCurrent->LogFileName.MaximumLength
               + pLoggerInfoCurrent->LoggerName.MaximumLength;
        i ++;
    }

    * LoggerCount = i;
    status = (* LoggerCount > PropertyArrayCount)
           ? ERROR_MORE_DATA : ERROR_SUCCESS;
Cleanup:
    if (pLoggerInfo)
        WmipFree(pLoggerInfo);

    return WmipSetDosError(status);
}

ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN  ULONG  PropertyArrayCount,
    OUT PULONG LoggerCount
    )
{
    ULONG i, status;
    ULONG returnCount = 0;
    EVENT_TRACE_PROPERTIES  LoggerInfo;
    PEVENT_TRACE_PROPERTIES pLoggerInfo;

    WmipInitProcessHeap();

    if ((LoggerCount == NULL)
        || (PropertyArrayCount > MAXLOGGERS)
        || (PropertyArray == NULL)
        || (PropertyArrayCount == 0))
        return ERROR_INVALID_PARAMETER;
    if (*PropertyArray == NULL)
        return ERROR_INVALID_PARAMETER;

    try {
        *LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            if (returnCount < PropertyArrayCount) 
                pLoggerInfo = PropertyArray[returnCount];
            else {
                pLoggerInfo = &LoggerInfo;
                RtlZeroMemory(pLoggerInfo, sizeof(EVENT_TRACE_PROPERTIES));
                pLoggerInfo->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES);
            }

            WmiSetLoggerId(i, &pLoggerInfo->Wnode.HistoricalContext);

            status = ControlTraceA(
                        (TRACEHANDLE)pLoggerInfo->Wnode.HistoricalContext,
                        NULL,
                        pLoggerInfo,
                        EVENT_TRACE_CONTROL_QUERY);
            if (status == ERROR_SUCCESS)
                returnCount++;
        }
        *LoggerCount = returnCount;
        status = WmipQueryAllUmTraceA(PropertyArray,
                                      FALSE,
                                      PropertyArrayCount,
                                      LoggerCount);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
       return WmipSetDosError(ERROR_NOACCESS);
    }
    if (returnCount > PropertyArrayCount)
        return ERROR_MORE_DATA;
    else 
        return ERROR_SUCCESS;
}

TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    )
{
    TRACEHANDLE LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    USHORT LoggerId;

    WmipInitProcessHeap();
    
    if (Buffer == NULL) {
        WmipSetDosError(ERROR_INVALID_PARAMETER);
        return LoggerHandle;
    }

    try {
        if (((PWNODE_HEADER)Buffer)->BufferSize < sizeof(WNODE_HEADER)) {
            WmipSetDosError(ERROR_BAD_LENGTH);
            return LoggerHandle;
        }
        LoggerHandle = (TRACEHANDLE)((PWNODE_HEADER)Buffer)->HistoricalContext;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        WmipSetDosError(ERROR_NOACCESS);
        return (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    LoggerId = WmiGetLoggerId(LoggerHandle);
    if ((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID)) 
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        LoggerHandle = (TRACEHANDLE) INVALID_HANDLE_VALUE;
    }
    return LoggerHandle;
}

UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE LoggerHandle
    )
{
    UCHAR Level;
    USHORT LoggerId;

    WmipInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);

    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Level = WmiGetLoggerEnableLevel(LoggerHandle);
    return Level;
}

ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE LoggerHandle
    )
{
    ULONG Flags;
    USHORT LoggerId;

    WmipInitProcessHeap();

    LoggerId = WmiGetLoggerId(LoggerHandle);
    if (((LoggerId >= MAXLOGGERS) && (LoggerId != KERNEL_LOGGER_ID))
            || (LoggerHandle == (TRACEHANDLE) NULL))
    {
        WmipSetDosError(ERROR_INVALID_HANDLE);
        return 0;
    }
    Flags = WmiGetLoggerEnableFlags(LoggerHandle);
    return Flags;
}

ULONG
WMIAPI
CreateTraceInstanceId(
    IN PVOID RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInst
    )
/*++

Routine Description:

    This call takes the Registration Handle for a traced GUID and fills in the 
    instanceId in the EVENT_INSTANCE_INFO structure provided by the caller. 

Arguments:

    RegHandle       Registration Handle for the Guid. 

    pInst           Pointer to the Instance information

Return Value:

    The status of performing the action requested.

--*/
{
    PGUIDMAPENTRY GuidMapEntry;

    WmipInitProcessHeap();
    
    if ((RegHandle == NULL) || (pInst == NULL)) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    } 
    try {
        pInst->RegHandle = RegHandle;
        GuidMapEntry =  (PGUIDMAPENTRY) RegHandle;
        if (GuidMapEntry->InstanceId >= MAXINST) {
            InterlockedCompareExchange(&GuidMapEntry->InstanceId, MAXINST, 0);
        }
        pInst->InstanceId = InterlockedIncrement(&GuidMapEntry->InstanceId);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipSetDosError(WmipNtStatusToDosError(GetExceptionCode()));
    }

    return ERROR_SUCCESS;
}


ULONG
WMIAPI
EnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    )
/*++

Routine Description:

    This call returns all the registered trace control guids
    with their current status.

Arguments:

    GuidPropertiesArray Points to buffers to write trace control guid properties

    PropertyArrayCount  Size of the array provided

    GuidCount           Number of GUIDs written in the Array. If the
                        Array was smaller than the required size, GuidCount
                        returns the size needed.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    PWMIGUIDLISTINFO pGuidListInfo;
    ULONG i, j;

    WmipInitProcessHeap();

    try {
        if ( (GuidPropertiesArray == NULL)  || (*GuidPropertiesArray == NULL) ){
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }
        for (i=0; i < PropertyArrayCount; i++) {
            if (GuidPropertiesArray[i] == NULL) {
                return WmipSetDosError(ERROR_INVALID_PARAMETER);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError( GetExceptionCode() );
        return WmipSetDosError(Status);
    }




    Status = WmipEnumRegGuids(&pGuidListInfo);

    if (Status == ERROR_SUCCESS) {
        try {

            PWMIGUIDPROPERTIES pGuidProperties = pGuidListInfo->GuidList;
            ULONG i, j = 0;

            for (i=0; i < pGuidListInfo->ReturnedGuidCount; i++) {

                if (pGuidProperties->GuidType == 0) { // Trace Control Guid

                    if (j >=  PropertyArrayCount) {
                        Status = ERROR_MORE_DATA;
                    }
                    else {
                        RtlCopyMemory(GuidPropertiesArray[j],
                                      pGuidProperties,
                                      sizeof(WMIGUIDPROPERTIES)
                                     );
                    }
                    j++;
                }
                pGuidProperties++;
            }
            *GuidCount = j;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            Status = WmipNtStatusToDosError( GetExceptionCode() );
        }

        WmipFree(pGuidListInfo);
    }

    return WmipSetDosError(Status);

}


// Stub APIs
ULONG
WMIAPI
QueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}

ULONG
WMIAPI
QueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_QUERY);
}

ULONG
WMIAPI
StopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}

ULONG
WMIAPI
StopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_STOP);
}


ULONG
WMIAPI
UpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceA(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}

ULONG
WMIAPI
UpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_UPDATE);
}

ULONG
WMIAPI
FlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceA(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}

ULONG
WMIAPI
FlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    )
{
    return ControlTraceW(
              TraceHandle, InstanceName, Properties, EVENT_TRACE_CONTROL_FLUSH);
}


ULONG 
WmipTraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     ArgList
)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatus;
    PULONG TraceMarker;
    ULONG Size;
    ULONG Flags;
    ULONG dataBytes, argCount ;
    BOOLEAN UserModeOnly = FALSE;
    USHORT    LoggerId;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&LoggerHandle;
    va_list ap ;
    PMESSAGE_TRACE_USER pMessage = NULL ;
    try {
        //
        // Determine the number bytes to follow header
        //
        dataBytes = 0 ;             // For Count of Bytes
        argCount = 0 ;              // For Count of Arguments
        { // Allocation Block
            
            PCHAR source;
            ap = ArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                    size_t elemBytes;
                    elemBytes = va_arg (ap, size_t);
                    dataBytes += elemBytes;
                    argCount++ ;
            }
         } // end of allocation block


        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE){
            UserModeOnly = TRUE;
            goto UmOnly;
        }
        //
        // Now the LoggerHandle is expected to be filled in by the caller.
        //  But check to see if it has a valid value.
        //

        LoggerId = WmiGetLoggerId(LoggerHandle);
        if ((LoggerId == 0) || (LoggerId == KERNEL_LOGGER_ID)) {
             return ERROR_INVALID_HANDLE;
        }

        Size = dataBytes + sizeof(MESSAGE_TRACE_USER) ;

        if (Size > TRACE_MESSAGE_MAXIMUM_SIZE) {
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return(ERROR_BUFFER_OVERFLOW);
        }
        
        pMessage = (PMESSAGE_TRACE_USER)WmipAlloc(Size);
        if (pMessage == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pMessage->MessageHeader.Marker = TRACE_MESSAGE | TRACE_HEADER_FLAG ;
        //
        // Fill in Header.
        //
        pMessage->MessageFlags = MessageFlags ;
        pMessage->MessageHeader.Packet.MessageNumber = MessageNumber ;
        pMessage->LoggerHandle = (ULONG64)LoggerHandle ;
        // GUID ? or CompnentID ?
        if (MessageFlags&TRACE_MESSAGE_COMPONENTID) {
            RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(ULONG)) ;
        } else if (MessageFlags&TRACE_MESSAGE_GUID) { // Can't have both
        	RtlCopyMemory(&pMessage->MessageGuid,MessageGuid,sizeof(GUID));
        }
        pMessage->DataSize = dataBytes ;
        //
        // Now Copy in the Data.
        //
        { // Allocation Block
            va_list ap;
            PCHAR dest = (PCHAR)&pMessage->Data ;
            PCHAR source;
            ap = ArgList ;
            while ((source = va_arg (ap, PVOID)) != NULL) {
                size_t elemBytes;
                elemBytes = va_arg (ap, size_t);
                RtlCopyMemory (dest, source, elemBytes);
                dest += elemBytes;
            }
        } // Allocation Block
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (pMessage != NULL) {
            WmipFree(pMessage);
        }
        return WmipNtStatusToDosError( GetExceptionCode() );
    }

    NtStatus = NtTraceEvent((HANDLE)LoggerHandle,
                            ETW_NT_FLAGS_TRACE_MESSAGE,
                            Size,
                            pMessage);

UmOnly:

    try {
        if (UserModeOnly) {
            NtStatus = WmipTraceUmMessage(dataBytes,
                                         (ULONG64)LoggerHandle,
                                         MessageFlags,
                                         MessageGuid,
                                         MessageNumber,
                                         ArgList);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return WmipNtStatusToDosError(GetExceptionCode());
    }

    if (pMessage != NULL) {
            WmipFree(pMessage);
    }
    return WmipNtStatusToDosError( NtStatus );

}

ULONG
WMIAPI
TraceMessage(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    ...
)
/*++
Routine Description:
This routine is used by WMI data providers to trace events.
It expects the user to pass in the handle to the logger.
Also, the user cannot ask to log something that is larger than
the buffer size (minus buffer header).

Arguments:
//    IN TRACEHANDLE LoggerHandle   - LoggerHandle obtained earlier
//    IN USHORT MessageFlags,         - Flags which both control what standard values are logged and
//                                    also included in the message header to control decoding
//    IN PGUID MessageGuid,         - Pointer to the message GUID of this set of messages or if
//                                    TRACE_COMPONENTID is set the actual compnent ID
//    IN USHORT MessageNumber,      - The type of message being logged, associates it with the 
//                                    appropriate format string  
//    ...                           - List of arguments to be processed with the format string
//                                    these are stored as pairs of
//                                      PVOID - ptr to argument
//                                      ULONG - size of argument
//                                    and terminated by a pointer to NULL, length of zero pair.


Return Value:
    Status
--*/
{
    ULONG Status ;
    va_list ArgList ;

    WmipInitProcessHeap();
    
    try {
         va_start(ArgList,MessageNumber);
         Status = WmipTraceMessage(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, ArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}


ULONG
WMIAPI
TraceMessageVa(
    IN TRACEHANDLE LoggerHandle,
    IN ULONG       MessageFlags,
    IN LPGUID      MessageGuid,
    IN USHORT      MessageNumber,
    IN va_list     MessageArgList
)
// The Va version of TraceMessage
{
    ULONG Status ;

    WmipInitProcessHeap();
    
    try {
        Status = WmipTraceMessage(LoggerHandle, MessageFlags, MessageGuid, MessageNumber, MessageArgList);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = WmipNtStatusToDosError( GetExceptionCode() );
    }
    return WmipSetDosError(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\dpapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dpapi.c

Abstract:
    
    WMI data provider api set

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"


ULONG WmipCountedAnsiToCountedUnicode(
    PCHAR Ansi, 
    PWCHAR Unicode
    )
/*++

Routine Description:

    Translate a counted ansi string into a counted unicode string.
    Conversion may be done inplace, that is Ansi == Unicode.

Arguments:

    Ansi is the counted ansi string to convert to UNICODE
        
    Unicode is the buffer to place the converted string into

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCHAR APtr;
    PWCHAR WPtr;
    ULONG AnsiSize, UnicodeSize;
    ULONG Status;
    
    AnsiSize = *((PUSHORT)Ansi);
    APtr = WmipAlloc(AnsiSize + 1);
    if (APtr != NULL)
    {
        memcpy(APtr, Ansi + sizeof(USHORT), AnsiSize);
        APtr[AnsiSize] = 0;
        
        WPtr = NULL;                
        Status = AnsiToUnicode(APtr, &WPtr);
        if (Status == ERROR_SUCCESS)
        {
            UnicodeSize = (wcslen(WPtr)+1) * sizeof(WCHAR);
            *Unicode = (USHORT)UnicodeSize; 
            memcpy(Unicode+1, WPtr, UnicodeSize);
            Status = ERROR_SUCCESS;
            WmipFree(WPtr);
        } 
        WmipFree(APtr);        
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}


ULONG WmipCountedUnicodeToCountedAnsi(
    PWCHAR Unicode,
    PCHAR Ansi
    )
/*++

Routine Description:

    Translate a counted ansi string into a counted unicode string.
    Conversion may be done inplace, that is Ansi == Unicode.

Arguments:

    Unicode is the counted unicode string to convert to ansi

    Ansi is the buffer to place the converted string into
        
Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    PCHAR APtr;
    PWCHAR WPtr;
    ULONG AnsiSize, UnicodeSize;
    ULONG Status;
    
    UnicodeSize = *Unicode;
    WPtr = WmipAlloc(UnicodeSize + sizeof(WCHAR));
    if (WPtr != NULL)
    {
        memcpy(WPtr, Unicode + 1, UnicodeSize);
        WPtr[UnicodeSize/sizeof(WCHAR)] = UNICODE_NULL;

        APtr = NULL;
        Status = UnicodeToAnsi(WPtr, &APtr, &AnsiSize);
        if (Status == ERROR_SUCCESS)
        {
            *((PUSHORT)Ansi) = (USHORT)AnsiSize; 
            memcpy(Ansi+sizeof(USHORT), APtr, AnsiSize);
            Status = ERROR_SUCCESS;
            WmipFree(APtr);
        } 
        WmipFree(WPtr);        
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}

ULONG WmipCopyStringToCountedUnicode(
    LPCWSTR String,
    PWCHAR CountedString,
    ULONG *BytesUsed,
    BOOLEAN ConvertFromAnsi        
    )
/*++

Routine Description:

    This routine will copy an ansi ro unicode C string to a counted unicode
    string.
        
Arguments:

    String is the ansi or unicode incoming string
        
    Counted string is a pointer to where to write counted unicode string
        
    *BytesUsed returns number of bytes used to build counted unicode string
        
    ConvertFromAnsi is TRUE if String is an ANSI string 

Return Value:

    ERROR_SUCCESS or an error code

--*/
{
    USHORT StringSize;
    PWCHAR StringPtr = CountedString+1;
    ULONG Status;
    
    if (ConvertFromAnsi)
    {
        StringSize = (strlen((PCHAR)String) +1) * sizeof(WCHAR);
        Status = AnsiToUnicode((PCHAR)String,
                               &StringPtr);
    } else {
        StringSize = (wcslen(String) +1) * sizeof(WCHAR);
        wcscpy(StringPtr, String);
        Status = ERROR_SUCCESS;
    }
    
    *CountedString = StringSize;
     *BytesUsed = StringSize + sizeof(USHORT);                

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\logsup.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    logsup.c

Abstract:

    WMI logger api set. The routines here will need to appear like they
    are system calls. They are necessary to do the necessary error checking
    and do most of the legwork that can be done outside the kernel. The
    kernel portion will subsequently only deal with the actual logging
    and tracing.

Author:

    28-May-1997 JeePang

Revision History:

--*/

#ifndef MEMPHIS
#include <nt.h>
#include <ntrtl.h>          // for ntutrl.h
#include <nturtl.h>         // for RTL_CRITICAL_SECTION in winbase.h/wtypes.h
#include <wtypes.h>         // for LPGUID in wmium.h
#include "wmiump.h"
#include "evntrace.h"
#include "traceump.h"
#include "tracelib.h"
#include <math.h>

NTSTATUS
WmipProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    );

NTSTATUS
WmipThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    );

ULONG WmiTraceAlignment = DEFAULT_TRACE_ALIGNMENT;

ULONG
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to start
    the logger. All the required parameters must be in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    ULONG BufferSize;
    ACCESS_MASK DesiredAccess = 0;
    LPGUID Guid;
    PVOID SavedChecksum;
    ULONG SavedLogFileMode;
    BOOLEAN IsKernelTrace = FALSE;
    BOOLEAN bLogFile = FALSE;
    BOOLEAN bRealTime = FALSE;
    WMI_REF_CLOCK RefClock;
    LARGE_INTEGER RefClockSys, RefClockPerf, RefClockCycle;
    LARGE_INTEGER Frequency;


    Guid = &LoggerInfo->Wnode.Guid;

    if( IsEqualGUID(&HeapGuid,Guid) 
        || IsEqualGUID(&CritSecGuid,Guid)
        ){

        WMINTDLLLOGGERINFO NtdllLoggerInfo;

        NtdllLoggerInfo.LoggerInfo = LoggerInfo;
        RtlCopyMemory(&LoggerInfo->Wnode.Guid, &NtdllTraceGuid, sizeof(GUID));
        NtdllLoggerInfo.IsGet = FALSE;


        Status =  WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_NTDLL_LOGGERINFO,
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &BufferSize,
                        NULL
                        );

        return WmipSetDosError(Status);
    }

    if (IsEqualGUID(Guid, &SystemTraceControlGuid) ||
        IsEqualGUID(Guid, &WmiEventLoggerGuid)) {
        IsKernelTrace = TRUE;
        DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
    }
    if ((LoggerInfo->LogFileName.Length > 0) &&
        (LoggerInfo->LogFileName.Buffer != NULL)) {
        DesiredAccess |= TRACELOG_CREATE_ONDISK;
        bLogFile = TRUE;
    }
    SavedLogFileMode = LoggerInfo->LogFileMode;
    if (SavedLogFileMode & EVENT_TRACE_REAL_TIME_MODE) {
        DesiredAccess |= TRACELOG_CREATE_REALTIME;
        bRealTime = TRUE;
    }
    Status = WmipCheckGuidAccess( Guid, DesiredAccess );

    if (Status != ERROR_SUCCESS) {
        return Status;
    }

    //
    // If the user didn't specify the clock type, set the default clock type
    // system time.
    //

    if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_PERFCOUNTER &&
        LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME &&
        LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_CPUCYCLE) {
        LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    }

    //
    // Take a reference timestamp before actually starting the logger
    //
    RefClockSys.QuadPart = WmipGetSystemTime();
    RefClockCycle.QuadPart = WmipGetCycleCount();
    Status = NtQueryPerformanceCounter(&RefClockPerf, &Frequency);
        
    if (SavedLogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = WmipSendUmLogRequest(
                    WmiStartLoggerCode,
                    LoggerInfo
                    );
    }
    else if (IsKernelTrace) {
        //
        // In order to capture the process/thread rundown accurately, we need to
        // start kernel logger in two steps. Start logger with delay write,
        // do rundown from user mode and then updatelogger with filename.
        //
        WMI_LOGGER_INFORMATION DelayLoggerInfo;
        ULONG EnableFlags = LoggerInfo->EnableFlags;
        //
        // If it's only realtime start logger in one step
        //

        if (bRealTime && !bLogFile) {

            BufferSize = LoggerInfo->BufferSize * 1024;
            Status =  WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_START_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );
            return WmipSetDosError(Status);
        }

        if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
            PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

            tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                       &LoggerInfo->EnableFlags;
            EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
        }


        RtlCopyMemory(&DelayLoggerInfo, LoggerInfo, sizeof(WMI_LOGGER_INFORMATION));
        RtlZeroMemory(&DelayLoggerInfo.LogFileName, sizeof(UNICODE_STRING) );

        DelayLoggerInfo.Wnode.BufferSize = sizeof(WMI_LOGGER_INFORMATION);

        DelayLoggerInfo.LogFileMode |= EVENT_TRACE_DELAY_OPEN_FILE_MODE;

        //
        // Since there's no filename in step 1 of StartLogger we need to mask
        // the NEWFILE mode to prevent kernel trying to generate a file
        //
        DelayLoggerInfo.LogFileMode &= ~EVENT_TRACE_FILE_MODE_NEWFILE;

        DelayLoggerInfo.EnableFlags = (EVENT_TRACE_FLAG_PROCESS & EnableFlags);
        DelayLoggerInfo.EnableFlags |= (EVENT_TRACE_FLAG_THREAD & EnableFlags);
        DelayLoggerInfo.EnableFlags |= (EVENT_TRACE_FLAG_IMAGE_LOAD & EnableFlags);

        BufferSize = DelayLoggerInfo.BufferSize * 1024;
        Status = WmipSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_START_LOGGER,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &DelayLoggerInfo,
                    DelayLoggerInfo.Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
        if (Status != ERROR_SUCCESS) {
            return Status;
        }

        LoggerInfo->Wnode.ClientContext = DelayLoggerInfo.Wnode.ClientContext;

        //
        // We need to pick up any parameter adjustment done by the kernel
        // here so UpdateTrace does not fail.
        //
        LoggerInfo->Wnode.HistoricalContext = DelayLoggerInfo.Wnode.HistoricalContext;
        LoggerInfo->MinimumBuffers          = DelayLoggerInfo.MinimumBuffers;
        LoggerInfo->MaximumBuffers          = DelayLoggerInfo.MaximumBuffers;
        LoggerInfo->NumberOfBuffers         = DelayLoggerInfo.NumberOfBuffers;
        LoggerInfo->BufferSize              = DelayLoggerInfo.BufferSize;
        LoggerInfo->AgeLimit                = DelayLoggerInfo.AgeLimit;

        BufferSize = LoggerInfo->BufferSize * 1024;

        //
        //  Add the LogHeader
        //
        LoggerInfo->Checksum = NULL;
        if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_PERFCOUNTER) {
            RefClock.StartPerfClock = RefClockPerf;
        } else if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_CPUCYCLE) {
            RefClock.StartPerfClock= RefClockCycle;
        } else {
            RefClock.StartPerfClock = RefClockSys;
        }
        RefClock.StartTime = RefClockSys;

        Status = WmipAddLogHeaderToLogFile(LoggerInfo, &RefClock, FALSE);

        if (Status == ERROR_SUCCESS) {
            SavedChecksum = LoggerInfo->Checksum;
            //
            // Update the logger with the filename
            //
            Status = WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_UPDATE_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
                        NULL
                        );


            if (LoggerInfo->Checksum != NULL) {
                WmipFree(LoggerInfo->Checksum);
            }
        }

        if (Status != ERROR_SUCCESS) {
            ULONG lStatus;

            //
            // Logger must be stopped now
            //
            lStatus = WmipSendWmiKMRequest(
                    NULL,
                    IOCTL_WMI_STOP_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );

            LoggerInfo->LogFileMode = SavedLogFileMode;
            return WmipSetDosError(Status);
        }
        else {
            if (LoggerInfo->LogFileHandle != NULL) {
                NtClose(LoggerInfo->LogFileHandle);
                LoggerInfo->LogFileHandle = NULL;
            }
        }
    }
    else {
        Status = WmipQueryLogger(LoggerInfo, FALSE);
        if (Status == ERROR_WMI_INSTANCE_NOT_FOUND) {       // Logger is already running
            LoggerInfo->Checksum = NULL;
            // 
            // Query for supported clock types.  If an unsupported clock type
            // is specified this LoggerInfo will contain the kernel's default
            //
            Status = WmipSendWmiKMRequest(NULL,
                                          IOCTL_WMI_CLOCK_TYPE,
                                          LoggerInfo,
                                          LoggerInfo->Wnode.BufferSize,
                                          LoggerInfo,
                                          LoggerInfo->Wnode.BufferSize,
                                          &BufferSize,
                                          NULL
                                        );

            if (Status != ERROR_SUCCESS) {
                return WmipSetDosError(Status);
            }
            if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                RefClock.StartPerfClock = RefClockPerf;
            } else if (LoggerInfo->Wnode.ClientContext == EVENT_TRACE_CLOCK_CPUCYCLE) {
                RefClock.StartPerfClock= RefClockCycle;
            } else {
                RefClock.StartPerfClock = RefClockSys;
            }
            RefClock.StartTime = RefClockSys;


            Status = WmipAddLogHeaderToLogFile(LoggerInfo, &RefClock, FALSE);
            if (Status != ERROR_SUCCESS) {
                return WmipSetDosError(Status);
            }

            BufferSize = LoggerInfo->BufferSize * 1024;
            SavedChecksum = LoggerInfo->Checksum;

            Status = WmipSendWmiKMRequest(       // actually start the logger here
            		    NULL,
                        IOCTL_WMI_START_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &BufferSize,
    		            NULL
                        );
            if (Status == ERROR_SUCCESS) {
                if (LoggerInfo->LogFileHandle != NULL) {
                    NtClose(LoggerInfo->LogFileHandle);
                    LoggerInfo->LogFileHandle = NULL;
                }
            }
            else if ( (Status != ERROR_MORE_DATA) &&
                      !(LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)) {
                if (LoggerInfo->LogFileName.Buffer != NULL) {
                    DeleteFileW(LoggerInfo->LogFileName.Buffer);
                }
            }

            if (SavedChecksum != NULL) {
                WmipFree(SavedChecksum);
            }
        }
        else {
            if ((Status == ERROR_SUCCESS) ||
                (Status == ERROR_MORE_DATA))
                Status = ERROR_ALREADY_EXISTS;
        }
    }
    //
    // Restore the LogFileMode
    //
    LoggerInfo->LogFileMode = SavedLogFileMode;

    return WmipSetDosError(Status);
}


ULONG
WmipFinalizeLogFileHeader(
    IN PWMI_LOGGER_INFORMATION LoggerInfo
    )
{
    ULONG                     Status    = ERROR_SUCCESS;
    ULONG                     ErrorCode = ERROR_SUCCESS;
    HANDLE                    LogFile   = INVALID_HANDLE_VALUE;
    LARGE_INTEGER             CurrentTime;
    ULONG                     BuffersWritten;
    WMI_LOGGER_CONTEXT        Logger;
    IO_STATUS_BLOCK           IoStatus;
    FILE_POSITION_INFORMATION FileInfo;
    FILE_STANDARD_INFORMATION FileSize;
    PWMI_BUFFER_HEADER        Buffer;  // need to initialize buffer first
    SYSTEM_BASIC_INFORMATION  SystemInfo;
    ULONG                     EnableFlags;
    ULONG                     IsGlobalForKernel = FALSE;
    USHORT                    LoggerId = 0;

    RtlZeroMemory(&Logger, sizeof(WMI_LOGGER_CONTEXT));
    Logger.BufferSpace = NULL;
    if (LoggerInfo->LogFileName.Length > 0 ) {
        // open the file for writing synchronously for the logger
        //    others may want to read it as well.
        //
        LogFile = CreateFileW(
                   (LPWSTR)LoggerInfo->LogFileName.Buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL
                   );
        if (LogFile == INVALID_HANDLE_VALUE) {
            ErrorCode = WmipSetDosError(GetLastError());
            goto cleanup;
        }

        // Truncate the file size if in PREALLOCATE mode
        if (LoggerInfo->MaximumFileSize && 
            (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
            // Do this only when we haven't reach the max file size
            if (LoggerInfo->MaximumFileSize > (((ULONGLONG)LoggerInfo->BuffersWritten * (ULONGLONG)LoggerInfo->BufferSize) / 1024)) {
                IO_STATUS_BLOCK IoStatusBlock;
                FILE_END_OF_FILE_INFORMATION EOFInfo;

                EOFInfo.EndOfFile.QuadPart = (ULONGLONG)LoggerInfo->BuffersWritten * (ULONGLONG)LoggerInfo->BufferSize * 1024;
                // Checksum64 in WMI_LOGGER_INFORMATION has the number of GuidMap buffers.
                EOFInfo.EndOfFile.QuadPart += LoggerInfo->Checksum64 * (ULONGLONG)LoggerInfo->BufferSize * 1024;

                Status = NtSetInformationFile(LogFile,
                                              &IoStatusBlock,
                                              &EOFInfo,
                                              sizeof(FILE_END_OF_FILE_INFORMATION),
                                              FileEndOfFileInformation);
                if (!NT_SUCCESS(Status)) {
                    NtClose(LogFile);
                    ErrorCode = WmipNtStatusToDosError(Status);
                    goto cleanup;
                }
            }
        }

        Logger.BuffersWritten = LoggerInfo->BuffersWritten;

        Logger.BufferSpace = WmipAlloc(LoggerInfo->BufferSize * 1024);
        if (Logger.BufferSpace == NULL) {
            ErrorCode = WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            goto cleanup;
        }
        Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
        RtlZeroMemory(Buffer, LoggerInfo->BufferSize * 1024);
        Buffer->Wnode.BufferSize = LoggerInfo->BufferSize * 1024;
        Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
        Buffer->EventsLost = 0;
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        Buffer->Wnode.Guid = LoggerInfo->Wnode.Guid;
        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &SystemInfo, sizeof (SystemInfo), NULL);

        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipNtStatusToDosError(Status);
            goto cleanup;
        }
        Logger.TimerResolution = SystemInfo.TimerResolution;
        Logger.LogFileHandle = LogFile;
        Logger.BufferSize = LoggerInfo->BufferSize * 1024;

        // For Circular LogFile the process rundown data is appended at the
        // last buffer written and not to the end of file.
        //
        Status = NtQueryInformationFile(
                    LogFile,
                    &IoStatus,
                    &FileSize,
                    sizeof(FILE_STANDARD_INFORMATION),
                    FileStandardInformation
                        );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipNtStatusToDosError(Status);
            goto cleanup;
        }

        //
        // For Kernel Boot Traces, we need to do the Rundown. 
        // configuration at this time. 
        // 1. The Logger ID is GLOBAL_LOGGER_ID
        // 2. The LoggerName is NT_KERNEL_LOGGER
        //
        // The First condition is true for any GlobalLogger but 
        // condition 2 is TRUE only when it is collecting kernel traces. 
        //

        LoggerId = WmiGetLoggerId (LoggerInfo->Wnode.HistoricalContext);

        if ( (LoggerId == WMI_GLOBAL_LOGGER_ID)      &&
             (LoggerInfo->LoggerName.Length > 0)     && 
             (LoggerInfo->LoggerName.Buffer != NULL) &&
             (!wcscmp(LoggerInfo->LoggerName.Buffer, KERNEL_LOGGER_NAMEW))
           ) {
            IsGlobalForKernel = TRUE;
        }

        if ( (IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) ||
              IsGlobalForKernel )  {
            if (IsGlobalForKernel) {
                ULONG      CpuSpeed;
                ULONG      CpuNum = 0;
                
                //
                // For boot traces we need to re-set the CPU Speed in the
                // log file header as it is not available in the registry 
                // when the log file header is first created.
                //
                if (NT_SUCCESS(WmipGetCpuSpeed(&CpuNum, &CpuSpeed))) {          
                    FileInfo.CurrentByteOffset.QuadPart =
                        LOGFILE_FIELD_OFFSET(CpuSpeedInMHz);
                    
                    Status = NtSetInformationFile(
                        LogFile,
                        &IoStatus,
                        &FileInfo,
                        sizeof(FILE_POSITION_INFORMATION),
                        FilePositionInformation
                        );
                    if (!NT_SUCCESS(Status)) {
                        ErrorCode = WmipNtStatusToDosError(Status);
                        goto cleanup;
                    }
                    
                    Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &CpuSpeed,
                        sizeof(CpuSpeed),
                        NULL,
                        NULL
                        );
                    
                    //
                    // I don't like this.  However, write failures are never a
                    // failure case for the log file so I'll follow their 
                    // trend... for now.
                    //
                    if (NT_SUCCESS(Status)) {
                        NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                    }                
                }
            }

            if (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) {
                ULONG BufferSize = LoggerInfo->BufferSize;  // in KB
                ULONG BuffersWritten = LoggerInfo->BuffersWritten;
                ULONG maxBuffers = (LoggerInfo->MaximumFileSize * 1024) / BufferSize;
                ULONG LastBuffer;
                ULONG StartBuffers;

                FileInfo.CurrentByteOffset.QuadPart =
                                         LOGFILE_FIELD_OFFSET(StartBuffers);
                Status = NtSetInformationFile(
                                     LogFile,
                                     &IoStatus,
                                     &FileInfo,
                                     sizeof(FILE_POSITION_INFORMATION),
                                     FilePositionInformation
                                     );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipNtStatusToDosError(Status);
                    goto cleanup;
                }

                Status = NtReadFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &StartBuffers,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    ErrorCode = WmipNtStatusToDosError(Status);
                    goto cleanup;
                }

                LastBuffer = (maxBuffers > StartBuffers) ?
                             (StartBuffers + (BuffersWritten - StartBuffers)
                             % (maxBuffers - StartBuffers))
                             : 0;
                FileInfo.CurrentByteOffset.QuadPart =  LastBuffer *
                                                       BufferSize * 1024;
            }
            else {
                FileInfo.CurrentByteOffset = FileSize.EndOfFile;
            }

            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipNtStatusToDosError(Status);
                goto cleanup;
            }

            EnableFlags = LoggerInfo->EnableFlags;

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;

                if (LoggerInfo->Wnode.BufferSize >= (tFlagExt->Offset + sizeof(ULONG)) )  {
                    EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
                }
                else {
                    EnableFlags = 0;    // Should not happen.
                }
            }

            Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

            WmipProcessRunDown(&Logger, FALSE, EnableFlags);

            if (IsGlobalForKernel) {
                WmipDumpHardwareConfig(&Logger);
            }

            {
                PWMI_BUFFER_HEADER Buffer1 =
                                (PWMI_BUFFER_HEADER) Logger.BufferSpace;
                    if (Buffer1->Offset < Logger.BufferSize) {
                        RtlFillMemory(
                                (char *) Logger.BufferSpace + Buffer1->Offset,
                                Logger.BufferSize - Buffer1->Offset,
                                0xFF);
                    }
            }
            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        Logger.BufferSpace,
                        Logger.BufferSize,
                        NULL,
                        NULL);
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                Logger.BuffersWritten++;
            }
        }
        else { // For Application Traces, need to dump the guidmaps again.

    // Set the FilePointer to end of file so that Rundown data may be appended.
    //
            FileInfo.CurrentByteOffset = FileSize.EndOfFile;
            Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipNtStatusToDosError(Status);
                goto cleanup;
            }

            // Dump the Guid Maps once more at the End.
            //
            Buffer->EventsLost = 0;
            Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
            BuffersWritten = Logger.BuffersWritten;

            if (WmipDumpGuidMaps(&Logger, NULL, FALSE) > 0) {
                if (Buffer->Offset < Logger.BufferSize) {
                    RtlFillMemory(
                            (char *) Logger.BufferSpace + Buffer->Offset,
                            Logger.BufferSize - Buffer->Offset,
                            0xFF);
                }
                Status = NtWriteFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            Logger.BufferSpace,
                            Logger.BufferSize,
                            NULL,
                            NULL);
                if (NT_SUCCESS(Status)) {
                    NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
                    Logger.BuffersWritten = BuffersWritten;
                }
            }
        }

        // TODO: should use memory-mapped file

        // Update the EndTime stamp field in LogFile. No Need to 
        // to do it if it's Relogged File. The old logfile
        // header already has the correct value. 
        //
        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) ) {
            FileInfo.CurrentByteOffset.QuadPart =
                                    LOGFILE_FIELD_OFFSET(EndTime);
            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipNtStatusToDosError(Status);
                goto cleanup;
            }

            // End Time is always wallclock time.
            //
            CurrentTime.QuadPart = WmipGetSystemTime();
            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &CurrentTime,
                        sizeof(ULONGLONG),
                        NULL,
                        NULL
                        );
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            }
        }

       // Update the Number of Buffers Written field in the header
       //
        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(BuffersWritten);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipNtStatusToDosError(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &Logger.BuffersWritten,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

        ErrorCode = RtlNtStatusToDosError(Status);
        LoggerInfo->BuffersWritten = Logger.BuffersWritten;

        //
        // Write the BuffersLost information into the logfile
        //


        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(BuffersLost);
        Status = NtSetInformationFile(
                     LogFile,
                     &IoStatus,
                     &FileInfo,
                     sizeof(FILE_POSITION_INFORMATION),
                     FilePositionInformation
                     );
        if (!NT_SUCCESS(Status)) {
            ErrorCode = WmipNtStatusToDosError(Status);
            goto cleanup;
        }

        Status = NtWriteFile(
                    LogFile,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    &LoggerInfo->LogBuffersLost,
                    sizeof(ULONG),
                    NULL,
                    NULL
                    );
        if (NT_SUCCESS(Status)) {
            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        }

        //
        // Write the EventsLost information into the logfile
        //


        //
        // No need to update EventsLost for Relogged File. Old LogFileHeader
        // already has the right value. 
        // 

        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_RELOG_MODE) ) {
            FileInfo.CurrentByteOffset.QuadPart =
                                LOGFILE_FIELD_OFFSET(EventsLost);
            Status = NtSetInformationFile(
                         LogFile,
                         &IoStatus,
                         &FileInfo,
                         sizeof(FILE_POSITION_INFORMATION),
                         FilePositionInformation
                         );
            if (!NT_SUCCESS(Status)) {
                ErrorCode = WmipNtStatusToDosError(Status);
                goto cleanup;
            }

            Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &LoggerInfo->EventsLost,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
            if (NT_SUCCESS(Status)) {
                NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            }
        }

    }

cleanup:
    if (LogFile != INVALID_HANDLE_VALUE) {
        NtClose(LogFile);
    }
    if (Logger.BufferSpace != NULL) {
        WmipFree(Logger.BufferSpace);
    }
    return WmipSetDosError(ErrorCode);
}

ULONG
WmipStopLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to stop
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG ErrorCode, ReturnSize;
    PTRACE_ENABLE_CONTEXT pContext;

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    //
    //Check For Heap and Crit Sec Guid.
    //

    if( IsEqualGUID(&HeapGuid,&LoggerInfo->Wnode.Guid) 
        || IsEqualGUID(&CritSecGuid,&LoggerInfo->Wnode.Guid)
        ){

        WMINTDLLLOGGERINFO NtdllLoggerInfo;
        ULONG BufferSize;
        
        LoggerInfo->Wnode.BufferSize = 0;
		RtlCopyMemory(&LoggerInfo->Wnode.Guid, &NtdllTraceGuid, sizeof(GUID));

        NtdllLoggerInfo.LoggerInfo = LoggerInfo;
        NtdllLoggerInfo.IsGet = FALSE;


        ErrorCode =  WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_NTDLL_LOGGERINFO,
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &NtdllLoggerInfo,
                        sizeof(WMINTDLLLOGGERINFO),
                        &BufferSize,
                        NULL
                        );

        return WmipSetDosError(ErrorCode);
    }

    pContext = (PTRACE_ENABLE_CONTEXT) & LoggerInfo->Wnode.HistoricalContext;
    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        ErrorCode = WmipSendUmLogRequest(WmiStopLoggerCode, LoggerInfo);
        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
        pContext->LoggerId     = 1;
    }
    else {


        ErrorCode = WmipSendWmiKMRequest(
                        NULL,
                        IOCTL_WMI_STOP_LOGGER,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        LoggerInfo,
                        LoggerInfo->Wnode.BufferSize,
                        &ReturnSize,
                        NULL
                        );

//
// if logging to a file, then update the EndTime, BuffersWritten and do
// process rundown for kernel trace.
//
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = WmipFinalizeLogFileHeader(LoggerInfo);
        }
    }

    return WmipSetDosError(ErrorCode);
}


ULONG
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN ULONG Update
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to query
    the logger. All the properties of the logger will be returned in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status, ReturnSize;
    HANDLE LogFileHandle = NULL;
    PTRACE_ENABLE_CONTEXT pContext;
    BOOLEAN bAddAppendFlag = FALSE;
    ULONG SavedLogFileMode;

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    LoggerInfo->Checksum      = NULL;
    LoggerInfo->LogFileHandle = NULL;
    pContext = (PTRACE_ENABLE_CONTEXT) &LoggerInfo->Wnode.HistoricalContext;

    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    //
    // If UPDATE and a new logfile is given throw in the LogFileHeader
    //
    if (   Update
        && LoggerInfo->LogFileName.Length > 0
        && !(   (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
             || (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE))) {
        Status = WmipAddLogHeaderToLogFile(LoggerInfo, NULL, Update);
        if (Status  != ERROR_SUCCESS) {
            return WmipSetDosError(Status);
        }

        LogFileHandle = LoggerInfo->LogFileHandle;
        bAddAppendFlag = TRUE;
        //
        // If we are switching to a new file, make sure it is append mode
        //
        SavedLogFileMode = LoggerInfo->LogFileMode;
    }


    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE ||
        pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {

        pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
        pContext->LoggerId     = 1;

        Status = WmipSendUmLogRequest(
                    (Update) ? (WmiUpdateLoggerCode) : (WmiQueryLoggerCode),
                    LoggerInfo
                    );
    }
    else {
        Status = WmipSendWmiKMRequest(
                    NULL,
                    (Update ? IOCTL_WMI_UPDATE_LOGGER : IOCTL_WMI_QUERY_LOGGER),
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &ReturnSize,
                    NULL
                    );

        if (LoggerInfo->Checksum != NULL) {
            WmipFree(LoggerInfo->Checksum);
        }
    }
    if (bAddAppendFlag) {
        LoggerInfo->LogFileMode = SavedLogFileMode;
    }
    return WmipSetDosError(Status);
}

PVOID
WmipGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_THREAD_INFORMATION pThread,
    IN ULONG GroupType,
    IN ULONG RequiredSize
    )
{
    PSYSTEM_TRACE_HEADER Header;
    PWMI_BUFFER_HEADER Buffer;
    THREAD_BASIC_INFORMATION ThreadInfo;
    KERNEL_USER_TIMES ThreadCpu;
    NTSTATUS Status;
    ULONG BytesUsed;
    PCLIENT_ID Cid;

    RequiredSize += sizeof (SYSTEM_TRACE_HEADER);   // add in header

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    Buffer = (PWMI_BUFFER_HEADER) Logger->BufferSpace;

    if (RequiredSize > Logger->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        WmipSetDosError(ERROR_BUFFER_OVERFLOW);
        return NULL;
    }

    if (RequiredSize > (Logger->BufferSize - Buffer->Offset)) {
        ULONG Status;
        IO_STATUS_BLOCK IoStatus;

        if (Buffer->Offset < Logger->BufferSize) {
            RtlFillMemory(
                    (char *) Buffer + Buffer->Offset,
                    Logger->BufferSize - Buffer->Offset,
                    0xFF);
        }
        Status = NtWriteFile(
                    Logger->LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    Logger->BufferSize,
                    NULL,
                    NULL);
        Buffer->EventsLost = 0;
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        if (!NT_SUCCESS(Status)) {
            return NULL;
        }
        Logger->BuffersWritten++;
    }
    Header = (PSYSTEM_TRACE_HEADER) ((char*)Buffer + Buffer->Offset);

    if (Logger->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
        LARGE_INTEGER Frequency;
        ULONGLONG Counter = 0;
        Status = NtQueryPerformanceCounter((PLARGE_INTEGER)&Counter,
                                            &Frequency);
        Header->SystemTime.QuadPart = Counter;
    } else if (Logger->UsePerfClock == EVENT_TRACE_CLOCK_CPUCYCLE) {
        Header->SystemTime.QuadPart = WmipGetCycleCount();
    } else {
        Header->SystemTime.QuadPart = WmipGetSystemTime();
    }

    Header->Header = (GroupType << 16) + RequiredSize;
    Header->Marker = SYSTEM_TRACE_MARKER;

    if (pThread == NULL) {
        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof ThreadInfo, NULL);
        if (NT_SUCCESS(Status)) {
            Cid = &ThreadInfo.ClientId;
            Header->ThreadId = HandleToUlong(Cid->UniqueThread);
            Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        }

        Status = NtQueryInformationThread(
                    NtCurrentThread(),
                    ThreadTimes,
                    &ThreadCpu, sizeof ThreadCpu, NULL);
        if (NT_SUCCESS(Status)) {
            Header->KernelTime = (ULONG) (ThreadCpu.KernelTime.QuadPart
                                      / Logger->TimerResolution);
            Header->UserTime   = (ULONG) (ThreadCpu.UserTime.QuadPart
                                      / Logger->TimerResolution);
        }
    }
    else {
        Cid = &pThread->ClientId;
        Header->ThreadId = HandleToUlong(Cid->UniqueThread);
        Header->ProcessId = HandleToUlong(Cid->UniqueProcess);
        Header->KernelTime = (ULONG) (pThread->KernelTime.QuadPart
                                / Logger->TimerResolution);
        Header->UserTime = (ULONG) (pThread->UserTime.QuadPart
                                / Logger->TimerResolution);
    }

    Buffer->Offset += RequiredSize;
    // If there is room, throw in a end of buffer marker.

    BytesUsed = Buffer->Offset;
    if ( BytesUsed <= (Logger->BufferSize-sizeof(ULONG)) ) {
        *((long*)((char*)Buffer+Buffer->Offset)) = -1;
    }
    return (PVOID) ( (char*) Header + sizeof(SYSTEM_TRACE_HEADER) );
}


VOID
WmipCopyPropertiesToInfo(
    IN PEVENT_TRACE_PROPERTIES Properties,
    IN PWMI_LOGGER_INFORMATION Info
    )
{
    ULONG SavedBufferSize = Info->Wnode.BufferSize;

    RtlCopyMemory(&Info->Wnode, &Properties->Wnode, sizeof(WNODE_HEADER));

    Info->Wnode.BufferSize = SavedBufferSize;

    Info->BufferSize            = Properties->BufferSize;
    Info->MinimumBuffers        = Properties->MinimumBuffers;
    Info->MaximumBuffers        = Properties->MaximumBuffers;
    Info->NumberOfBuffers       = Properties->NumberOfBuffers;
    Info->FreeBuffers           = Properties->FreeBuffers;
    Info->EventsLost            = Properties->EventsLost;
    Info->BuffersWritten        = Properties->BuffersWritten;
    Info->LoggerThreadId        = Properties->LoggerThreadId;
    Info->MaximumFileSize       = Properties->MaximumFileSize;
    Info->EnableFlags           = Properties->EnableFlags;
    Info->LogFileMode           = Properties->LogFileMode;
    Info->FlushTimer            = Properties->FlushTimer;
    Info->LogBuffersLost        = Properties->LogBuffersLost;
    Info->AgeLimit              = Properties->AgeLimit;
    Info->RealTimeBuffersLost   = Properties->RealTimeBuffersLost;
}

VOID
WmipCopyInfoToProperties(
    IN PWMI_LOGGER_INFORMATION Info,
    IN PEVENT_TRACE_PROPERTIES Properties
    )
{
    ULONG SavedSize = Properties->Wnode.BufferSize;
    RtlCopyMemory(&Properties->Wnode, &Info->Wnode, sizeof(WNODE_HEADER));
    Properties->Wnode.BufferSize = SavedSize;

    Properties->BufferSize            = Info->BufferSize;
    Properties->MinimumBuffers        = Info->MinimumBuffers;
    Properties->MaximumBuffers        = Info->MaximumBuffers;
    Properties->NumberOfBuffers       = Info->NumberOfBuffers;
    Properties->FreeBuffers           = Info->FreeBuffers;
    Properties->EventsLost            = Info->EventsLost;
    Properties->BuffersWritten        = Info->BuffersWritten;
    Properties->LoggerThreadId        = Info->LoggerThreadId;
    Properties->MaximumFileSize       = Info->MaximumFileSize;
    Properties->EnableFlags           = Info->EnableFlags;
    Properties->LogFileMode           = Info->LogFileMode;
    Properties->FlushTimer            = Info->FlushTimer;
    Properties->LogBuffersLost        = Info->LogBuffersLost;
    Properties->AgeLimit              = Info->AgeLimit;
    Properties->RealTimeBuffersLost   = Info->RealTimeBuffersLost;
}

NTSTATUS
WmipThreadRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PSYSTEM_PROCESS_INFORMATION pProcessInfo,
    IN ULONG StartFlag,
    IN BOOLEAN bExtended
    )
{
    PSYSTEM_THREAD_INFORMATION pThreadInfo;
    ULONG GroupType;
    ULONG i;
    ULONG Size;
    ULONG SystemThreadInfoSize;
    PWMI_EXTENDED_THREAD_INFORMATION ThreadInfo;

    pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);

    GroupType = EVENT_TRACE_GROUP_THREAD +
                ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                             : EVENT_TRACE_TYPE_DC_END);

    Size = sizeof(WMI_EXTENDED_THREAD_INFORMATION);


    SystemThreadInfoSize = (bExtended)  ? sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION)
                                        : sizeof(SYSTEM_THREAD_INFORMATION);
    for (i=0; i < pProcessInfo->NumberOfThreads; i++) {
        if (pThreadInfo == NULL)
            break;
        ThreadInfo = (PWMI_EXTENDED_THREAD_INFORMATION)
                      WmipGetTraceBuffer( Logger,
                                          pThreadInfo,
                                          GroupType,
                                          Size );

        if (ThreadInfo) {
            ThreadInfo->ProcessId =
                HandleToUlong(pThreadInfo->ClientId.UniqueProcess);
            ThreadInfo->ThreadId =
                HandleToUlong(pThreadInfo->ClientId.UniqueThread);

            if (bExtended) {
                PSYSTEM_EXTENDED_THREAD_INFORMATION pExtThreadInfo;
                pExtThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) pThreadInfo;
                ThreadInfo->StackBase = pExtThreadInfo->StackBase;
                ThreadInfo->StackLimit = pExtThreadInfo->StackLimit;

                ThreadInfo->StartAddr = pExtThreadInfo->ThreadInfo.StartAddress;
                ThreadInfo->Win32StartAddr = pExtThreadInfo->Win32StartAddress;
                ThreadInfo->UserStackBase = NULL;
                ThreadInfo->UserStackLimit = NULL;
                ThreadInfo->WaitMode = -1;
            }
            else {
                ThreadInfo->StackBase = NULL;
                ThreadInfo->StackLimit = NULL;
                ThreadInfo->StartAddr = NULL;
                ThreadInfo->Win32StartAddr = NULL;
                ThreadInfo->UserStackBase = NULL;
                ThreadInfo->UserStackLimit = NULL;
                ThreadInfo->WaitMode = -1;
            }
        }
        pThreadInfo  = (PSYSTEM_THREAD_INFORMATION)( (char*)pThreadInfo + SystemThreadInfoSize );
    }
    return STATUS_SUCCESS;
}

void
WmipLogImageLoadEvent(
    IN HANDLE ProcessID,
    IN PWMI_LOGGER_CONTEXT pLogger,
    IN PRTL_PROCESS_MODULE_INFORMATION pModuleInfo,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
)
{
    UNICODE_STRING wstrModuleName;
    ANSI_STRING    astrModuleName;
    ULONG          sizeModuleName;
    ULONG          sizeBuffer;
    PCHAR          pAuxInfo;
    PWMI_IMAGELOAD_INFORMATION ImageLoadInfo;

    if ((pLogger == NULL) || (pModuleInfo == NULL) || (pThreadInfo == NULL))
        return;

    RtlInitAnsiString( & astrModuleName, pModuleInfo->FullPathName);

    sizeModuleName = sizeof(WCHAR) * (astrModuleName.Length);
    sizeBuffer     = sizeModuleName + sizeof(WCHAR)
                   + FIELD_OFFSET (WMI_IMAGELOAD_INFORMATION, FileName);

    ImageLoadInfo = (PWMI_IMAGELOAD_INFORMATION)
                     WmipGetTraceBuffer(
                        pLogger,
                        pThreadInfo,
                        EVENT_TRACE_GROUP_PROCESS + EVENT_TRACE_TYPE_LOAD,
                        sizeBuffer);

    if (ImageLoadInfo == NULL) {
        return;
    }

    ImageLoadInfo->ImageBase = pModuleInfo->ImageBase;
    ImageLoadInfo->ImageSize = pModuleInfo->ImageSize;
    ImageLoadInfo->ProcessId = HandleToUlong(ProcessID);

    wstrModuleName.Buffer    = (LPWSTR) &ImageLoadInfo->FileName[0];

    wstrModuleName.MaximumLength = (USHORT) sizeModuleName + sizeof(WCHAR);
    RtlAnsiStringToUnicodeString(& wstrModuleName, & astrModuleName, FALSE);
}

ULONG
WmipSysModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo
    )
{
    NTSTATUS   status = STATUS_SUCCESS;
    char     * pLargeBuffer1;
    ULONG      ReturnLength;
    ULONG      CurrentBufferSize;

    ULONG                           i;
    PRTL_PROCESS_MODULES            pModules;
    PRTL_PROCESS_MODULE_INFORMATION pModuleInfo;

    pLargeBuffer1 = WmipMemReserve(MAX_BUFFER_SIZE);

    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    if (WmipMemCommit(pLargeBuffer1, BUFFER_SIZE) == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    CurrentBufferSize = BUFFER_SIZE;

retry:
    status = NtQuerySystemInformation(
                    SystemModuleInformation,
                    pLargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength);

    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        // Increase buffer size.
        //
        CurrentBufferSize += 8192;

        if (WmipMemCommit(pLargeBuffer1, CurrentBufferSize) == NULL)
        {
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    pModules = (PRTL_PROCESS_MODULES) pLargeBuffer1;

    for (i = 0, pModuleInfo = & (pModules->Modules[0]);
         i < pModules->NumberOfModules;
         i ++, pModuleInfo ++)
    {
        WmipLogImageLoadEvent(NULL, pLogger, pModuleInfo, pThreadInfo);
    }

Cleanup:
    if (pLargeBuffer1)
    {
        WmipMemFree(pLargeBuffer1);
    }
    return WmipSetDosError(WmipNtStatusToDosError(status));
}

ULONG
WmipProcessModuleRunDown(
    IN PWMI_LOGGER_CONTEXT        pLogger,
    IN HANDLE                     ProcessID,
    IN PSYSTEM_THREAD_INFORMATION pThreadInfo)
{
    NTSTATUS               status = STATUS_SUCCESS;
    ULONG                  i;
    PRTL_DEBUG_INFORMATION pLargeBuffer1 = NULL;

    pLargeBuffer1 = RtlCreateQueryDebugBuffer(0, FALSE);
    if (pLargeBuffer1 == NULL)
    {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    status = RtlQueryProcessDebugInformation(
                    ProcessID,
                    RTL_QUERY_PROCESS_NONINVASIVE |  RTL_QUERY_PROCESS_MODULES,
                    pLargeBuffer1);

    if ( !NT_SUCCESS(status) || (pLargeBuffer1->Modules == NULL) )
    {
        goto Cleanup;
    }

    for (i = 0; i < pLargeBuffer1->Modules->NumberOfModules; i ++)
    {
        WmipLogImageLoadEvent(
                ProcessID,
                pLogger,
                & (pLargeBuffer1->Modules->Modules[i]),
                pThreadInfo);
    }

Cleanup:
    if (pLargeBuffer1)
    {
        RtlDestroyQueryDebugBuffer(pLargeBuffer1);
    }
    return WmipSetDosError(WmipNtStatusToDosError(status));
}

NTSTATUS
WmipProcessRunDown(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN ULONG StartFlag,
    IN ULONG fEnableFlags
    )
{
    PSYSTEM_PROCESS_INFORMATION  pProcessInfo;
    PSYSTEM_THREAD_INFORMATION   pThreadInfo;
    char* LargeBuffer1;
    NTSTATUS status;
    ULONG ReturnLength;
    ULONG CurrentBufferSize;
    ULONG GroupType;
    ULONG TotalOffset = 0;
    OBJECT_ATTRIBUTES objectAttributes;
    BOOLEAN WasEnabled = TRUE;
    BOOLEAN bExtended = TRUE;

    LargeBuffer1 = WmipMemReserve ( MAX_BUFFER_SIZE );
    if (LargeBuffer1 == NULL) {
        return STATUS_NO_MEMORY;
    }

    if (WmipMemCommit (LargeBuffer1, BUFFER_SIZE) == NULL) {
        return STATUS_NO_MEMORY;
    }

    CurrentBufferSize = BUFFER_SIZE;
    retry:
    if (bExtended) {
        status = NtQuerySystemInformation(
                    SystemExtendedProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }
    else {
        status = NtQuerySystemInformation(
                    SystemProcessInformation,
                    LargeBuffer1,
                    CurrentBufferSize,
                    &ReturnLength
                    );
    }

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (WmipMemCommit (LargeBuffer1, CurrentBufferSize) == NULL) {
            return STATUS_NO_MEMORY;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {

        if (bExtended) {
            bExtended = FALSE;
            goto retry;
        }

        WmipMemFree(LargeBuffer1);
        return(status);
    }


    //
    // Adjust Privileges to obtain the module information
    //

    if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    TRUE, FALSE, &WasEnabled);
        if (!NT_SUCCESS(status)) {
            WmipMemFree(LargeBuffer1);
            return  (status);
        }
    }


    TotalOffset = 0;
    pProcessInfo = (SYSTEM_PROCESS_INFORMATION *) LargeBuffer1;
    while (TRUE) {
        ULONG Size;
        ULONG Length = 0;
        ULONG SidLength = 0;
        PUCHAR AuxPtr;
        PULONG_PTR AuxInfo;
        ANSI_STRING s;
        HANDLE Token;
        HANDLE pProcess;
        PCLIENT_ID Cid;
        ULONG TempInfo[128];
        PWMI_PROCESS_INFORMATION WmiProcessInfo;

        Size = FIELD_OFFSET(WMI_PROCESS_INFORMATION, Sid);

        GroupType = EVENT_TRACE_GROUP_PROCESS +
                    ((StartFlag) ? EVENT_TRACE_TYPE_DC_START
                                 : EVENT_TRACE_TYPE_DC_END);

        pThreadInfo = (PSYSTEM_THREAD_INFORMATION) (pProcessInfo+1);
        if (pProcessInfo->NumberOfThreads > 0) {
            Cid = (PCLIENT_ID) &pThreadInfo->ClientId;
        }
        else {
            Cid = NULL;
        }

        // if at termination, rundown thread first before process
        if ( (!StartFlag) &&
             (fEnableFlags & EVENT_TRACE_FLAG_THREAD) ){
            status = WmipThreadRunDown(Logger,
                                       pProcessInfo,
                                       StartFlag,
                                       bExtended);
            if (!NT_SUCCESS(status)) {
                break;
            }

        }

        if (fEnableFlags & EVENT_TRACE_FLAG_PROCESS) {

            if ( pProcessInfo->ImageName.Buffer  &&
                     pProcessInfo->ImageName.Length > 0 ) {
                RtlUnicodeStringToAnsiString(
                                     &s,
                                     (PUNICODE_STRING)&pProcessInfo->ImageName,
                                     TRUE);
                Length = s.Length + 1;
            }
            else {
                Length = 1;
            }

            InitializeObjectAttributes(
                    &objectAttributes, 0, 0, NULL, NULL);
            status = NtOpenProcess(
                                  &pProcess,
                                  PROCESS_QUERY_INFORMATION,
                                  &objectAttributes,
                                  Cid);
            if (NT_SUCCESS(status)) {
                status = NtOpenProcessToken(
                                      pProcess,
                                      TOKEN_READ,
                                      &Token);
                if (NT_SUCCESS(status)) {

                    status = NtQueryInformationToken(
                                             Token,
                                             TokenUser,
                                             TempInfo,
                                             256,
                                             &SidLength);
                    NtClose(Token);
                }
                NtClose(pProcess);
            }
            if ( (!NT_SUCCESS(status)) || SidLength <= 0) {
                TempInfo[0] = 0;
                SidLength = sizeof(ULONG);
            }

            Size += Length + SidLength;
            WmiProcessInfo = (PWMI_PROCESS_INFORMATION)
                              WmipGetTraceBuffer( Logger,
                                                  pThreadInfo,
                                                  GroupType,
                                                  Size);
            if (WmiProcessInfo == NULL) {
                status = STATUS_NO_MEMORY;
                break;
            }
            WmiProcessInfo->ProcessId = HandleToUlong(pProcessInfo->UniqueProcessId);
            WmiProcessInfo->ParentId = HandleToUlong(pProcessInfo->InheritedFromUniqueProcessId);
            WmiProcessInfo->SessionId = pProcessInfo->SessionId;
            WmiProcessInfo->PageDirectoryBase = pProcessInfo->PageDirectoryBase;
            WmiProcessInfo->ExitStatus = 0;

            AuxPtr = (PUCHAR) (&WmiProcessInfo->Sid);

            RtlCopyMemory(AuxPtr, &TempInfo, SidLength);
            AuxPtr += SidLength;

            if ( Length > 1) {
                RtlCopyMemory(AuxPtr, s.Buffer, Length);
                AuxPtr += Length;
                RtlFreeAnsiString(&s);
            }
            *AuxPtr = '\0';
            AuxPtr++;
        }

        // if at beginning, trace threads after process
        if (StartFlag) {

            if (fEnableFlags & EVENT_TRACE_FLAG_THREAD) {
                WmipThreadRunDown(Logger, pProcessInfo, StartFlag, bExtended);
            }

            if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
                if (pProcessInfo->UniqueProcessId == 0) {
                    WmipSysModuleRunDown(Logger, pThreadInfo);
                }
                else
                    WmipProcessModuleRunDown(
                            Logger,
                            (HANDLE) pProcessInfo->UniqueProcessId,
                            pThreadInfo);
            }
        }
        if (pProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
    }

    //
    // Restore privileges back to what it was before
    //

    if (fEnableFlags & EVENT_TRACE_FLAG_IMAGE_LOAD) {
        status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    WasEnabled,
                                    FALSE,
                                    &WasEnabled);
    }


    WmipMemFree(LargeBuffer1);

    return status;
}

VOID
WmipInitString(
    IN PVOID Destination,
    IN PVOID Buffer,
    IN ULONG Size
    )
{
    PSTRING s = (PSTRING) Destination;

    s->Buffer = Buffer;
    s->Length = 0;
    if (Buffer != NULL)
        s->MaximumLength = (USHORT) Size;
    else
        s->MaximumLength = 0;
}

VOID
WmipGenericTraceEnable(
    IN ULONG RequestCode,
    IN PVOID Buffer,
    IN OUT PVOID *RequestAddress
    )
{
    PGUIDMAPENTRY pControlGMEntry = *RequestAddress;
    PWNODE_HEADER Wnode = (PWNODE_HEADER) Buffer;
    PTRACE_REG_INFO pTraceRegInfo;
    PTRACE_ENABLE_CONTEXT pContext = (PTRACE_ENABLE_CONTEXT)&Wnode->HistoricalContext;

    *RequestAddress = NULL;

    if (Wnode == NULL || pControlGMEntry == NULL)
        return;

    if (!Wnode->Flags & WNODE_FLAG_TRACED_GUID)
        return;

    pTraceRegInfo  = pControlGMEntry->pControlGuidData;

    WmipAssert(pTraceRegInfo != NULL);


    if (pTraceRegInfo->InProgressEvent != NULL) {
        LARGE_INTEGER Timeout = {(ULONG)(-NOTIFY_RETRY_COUNT * 1000 * 10), -1};
// TODO: Raghu - what if it times out??
        NtWaitForSingleObject(pTraceRegInfo->InProgressEvent, 0, &Timeout);
    }

    *RequestAddress = pTraceRegInfo->NotifyRoutine;

    if (RequestCode == WMI_ENABLE_EVENTS) {
        pControlGMEntry->LoggerContext = Wnode->HistoricalContext;
        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
            pTraceRegInfo->EnabledState = TRUE;
            if (!WmipIsPrivateLoggerOn())
               *RequestAddress = NULL; // Do not notify if the logger is not up.
        }
    }
    else if (RequestCode == WMI_DISABLE_EVENTS) {
        if (pContext->InternalFlag & EVENT_TRACE_INTERNAL_FLAG_PRIVATE) {
            pTraceRegInfo->EnabledState = FALSE;
        }
        pControlGMEntry->LoggerContext = 0;
    }
}


ULONG 
WmipRelogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PSYSTEM_TRACE_HEADER RelogProp
    )
{
    PTRACE_LOGFILE_HEADER RelogFileHeader;
    LPWSTR FileName = NULL;
    ULONG RelogPropSize;
    HANDLE LogFile = INVALID_HANDLE_VALUE;
    ULONG BufferSize;
    IO_STATUS_BLOCK IoStatus;
    PWMI_BUFFER_HEADER Buffer;
    LPWSTR FileNameBuffer = NULL;
    PUCHAR BufferSpace;
    NTSTATUS Status;

    RelogFileHeader = (PTRACE_LOGFILE_HEADER) ((PUCHAR)RelogProp +
                                               sizeof(SYSTEM_TRACE_HEADER) );
    RelogPropSize = RelogProp->Packet.Size;
    FileName = (LPWSTR) LoggerInfo->LogFileName.Buffer;
    if (FileName == NULL) {
        return WmipSetDosError(ERROR_BAD_PATHNAME);
    }

    LogFile = WmipCreateFile(
                FileName,
                FILE_GENERIC_WRITE,
                FILE_SHARE_READ,
                FILE_OVERWRITE_IF,
                0);

    if (LogFile == INVALID_HANDLE_VALUE) {
        return WmipSetDosError(ERROR_BAD_PATHNAME);
    }

    LoggerInfo->LogFileHandle = LogFile;
    LoggerInfo->Wnode.ClientContext = RelogFileHeader->ReservedFlags;
    LoggerInfo->NumberOfProcessors = RelogFileHeader->NumberOfProcessors;

    BufferSize = LoggerInfo->BufferSize * 1024;
    BufferSpace   = WmipAlloc(BufferSize);
    if (BufferSpace == NULL) {
        NtClose(LogFile);
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    // initialize buffer first
    RtlZeroMemory(BufferSpace, BufferSize);
    Buffer         = (PWMI_BUFFER_HEADER) BufferSpace;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);

    //
    // We are making this an Application Trace always. 
    // However, if two application traces are relogged
    // the Guidmaps are not really consolidated. 
    //

    Buffer->Wnode.Guid   = LoggerInfo->Wnode.Guid;
    RelogFileHeader->LogFileMode = EVENT_TRACE_RELOG_MODE;

    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Flags   = WNODE_FLAG_TRACED_GUID;
    RelogFileHeader->BuffersWritten = 1;
    LoggerInfo->BuffersWritten = 1;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER) + RelogPropSize;
    //
    // Copy the Old LogFileHeader 
    //
    RtlCopyMemory((char*) Buffer + sizeof(WMI_BUFFER_HEADER),
                  RelogProp,
                  RelogPropSize 
                 );

    if (Buffer->Offset < BufferSize) {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                BufferSize - Buffer->Offset,
                0xFF);
    }
    Status = NtWriteFile(
            LogFile,
            NULL,
            NULL,
            NULL,
            &IoStatus,
            BufferSpace,
            BufferSize,
            NULL,
            NULL);
    NtClose(LogFile);

    LogFile = CreateFileW(
                 FileName,
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_NO_BUFFERING,
                 NULL
                 );

    WmipFree(BufferSpace);

    if (LogFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }
    LoggerInfo->LogFileHandle = LogFile;

    return ERROR_SUCCESS;

}





ULONG
WmipAddLogHeaderToLogFile(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_REF_CLOCK              RefClock,
    IN     ULONG                   Update
    )
{
    NTSTATUS Status;
    HANDLE LogFile = INVALID_HANDLE_VALUE;
    ULONG BufferSize;
    ULONG MemorySize;
    ULONG TraceKernel;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    WMI_LOGGER_CONTEXT Logger;
    IO_STATUS_BLOCK IoStatus;
    PWMI_BUFFER_HEADER Buffer;
    FILE_POSITION_INFORMATION FileInfo;
    LPWSTR FileName = NULL;
    LPWSTR FileNameBuffer = NULL;
    ULONG HeaderSize;

    struct WMI_LOGFILE_HEADER {
           WMI_BUFFER_HEADER    BufferHeader;
           SYSTEM_TRACE_HEADER  SystemHeader;
           TRACE_LOGFILE_HEADER LogFileHeader;
    };
    struct WMI_LOGFILE_HEADER LoggerBuffer;
    BOOLEAN bLogFileAppend =
                    (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_APPEND)
                  ? (TRUE) : (FALSE);

    if (LoggerInfo == NULL)
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ( !(LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return WmipSetDosError(ERROR_INVALID_PARAMETER);

    if ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_NEWFILE)  &&
        (LoggerInfo->LogFileName.Length > 0)) {
        FileName = (LPWSTR) WmipAlloc(LoggerInfo->LogFileName.Length + 64);
        if (FileName == NULL) {
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        swprintf(FileName, LoggerInfo->LogFileName.Buffer, 1);
        FileNameBuffer = FileName;
    }
    if (FileName == NULL)
        FileName = (LPWSTR) LoggerInfo->LogFileName.Buffer;

    //
    // If it is Append Mode, we need to open the file and make sure the
    // pick up the BufferSize
    //

    if ( bLogFileAppend ) {

        FILE_STANDARD_INFORMATION FileStdInfo;
        
        ULONG ReadSize   = sizeof(WMI_BUFFER_HEADER)
                         + sizeof(SYSTEM_TRACE_HEADER)
                         + sizeof(TRACE_LOGFILE_HEADER);
        ULONG nBytesRead = 0;

        //
        //  Update and Append do not mix. To Append LoggerInfo
        //  must have LogFileName
        //

        if ( (Update) || (LoggerInfo->LogFileName.Length <= 0) ) {
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_INVALID_PARAMETER);
        }

        LogFile = CreateFileW(FileName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (LogFile == INVALID_HANDLE_VALUE) {
            // cannot OPEN_EXISTING, assume that logfile is not there and
            // create a new one.
            //
            bLogFileAppend = FALSE;
            LoggerInfo->LogFileMode = LoggerInfo->LogFileMode
                                    & (~ (EVENT_TRACE_FILE_MODE_APPEND));
        }

        else {
            // read TRACE_LOGFILE_HEADER structure and update LoggerInfo
            // members.
            //
            Status = ReadFile(LogFile,
                              (LPVOID) & LoggerBuffer,
                              ReadSize,
                              & nBytesRead,
                              NULL);
            if (nBytesRead < ReadSize) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_BAD_PATHNAME);
            }
            if (  LoggerBuffer.LogFileHeader.LogFileMode
                & EVENT_TRACE_FILE_MODE_CIRCULAR) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_BAD_PATHNAME);
            }
            LoggerInfo->BufferSize      =
                            LoggerBuffer.LogFileHeader.BufferSize / 1024;
            //
            // If it's append, the GuidMap buffers are not accounted for
            // in the BuffersWritten count. The starttrace call will fail
            // on checksum error if it is not adjusted properly. However, 
            // this will trash the GuidMap entries in this file.
            //
            Status = NtQueryInformationFile(
                        LogFile,
                        &IoStatus,
                        &FileStdInfo,
                        sizeof(FILE_STANDARD_INFORMATION),
                        FileStandardInformation
                            );
            if (NT_SUCCESS(Status) ) {
                ULONG64 FileSize = FileStdInfo.AllocationSize.QuadPart;
                ULONG64 BuffersWritten = FileSize / (ULONG64) LoggerBuffer.LogFileHeader.BufferSize;
                LoggerInfo->BuffersWritten = (ULONG)BuffersWritten;
                LoggerBuffer.LogFileHeader.BuffersWritten = (ULONG)BuffersWritten;
            }
            else {
               NtClose(LogFile);
               if (FileNameBuffer != NULL) {
                   WmipFree(FileNameBuffer);
               }
                return WmipNtStatusToDosError(Status);
            }

            LoggerInfo->MaximumFileSize =
                            LoggerBuffer.LogFileHeader.MaximumFileSize;

            // Write back logfile append mode so WmipFinalizeLogFile() correctly
            // update BuffersWritten field
            //
            FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(EndTime);
            Status = NtSetInformationFile(LogFile,
                                          & IoStatus,
                                          & FileInfo,
                                          sizeof(FILE_POSITION_INFORMATION),
                                          FilePositionInformation);
            if (!NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(WmipNtStatusToDosError(Status));
            }
            LoggerBuffer.LogFileHeader.EndTime.QuadPart = 0;
            Status = NtWriteFile(LogFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 & IoStatus,
                                 & LoggerBuffer.LogFileHeader.EndTime,
                                 sizeof(LARGE_INTEGER),
                                 NULL,
                                 NULL);
            if (! NT_SUCCESS(Status)) {
                NtClose(LogFile);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(WmipNtStatusToDosError(Status));
            }

            // build checksum structure
            //
            if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
                LoggerInfo->Checksum = NULL;
            }
            else {
                LoggerInfo->Checksum = WmipAlloc(
                        sizeof(WNODE_HEADER) + sizeof(TRACE_LOGFILE_HEADER));
                if (LoggerInfo->Checksum != NULL) {
                    PBYTE ptrChecksum = LoggerInfo->Checksum;
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.BufferHeader,
                                  sizeof(WNODE_HEADER));
                    ptrChecksum += sizeof(WNODE_HEADER);
                    RtlCopyMemory(ptrChecksum,
                                  & LoggerBuffer.LogFileHeader,
                                  sizeof(TRACE_LOGFILE_HEADER));
                }
                else {
                    if (FileNameBuffer != NULL) {
                        WmipFree(FileNameBuffer);
                    }
                    return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
                }
            }
        }
    }

    // get the system parameters first

    LoggerInfo->LogFileHandle = NULL;

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &SystemInfo, sizeof (SystemInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        if (FileNameBuffer != NULL) {
            WmipFree(FileNameBuffer);
        }
        return WmipSetDosError(WmipNtStatusToDosError(Status));
    }

    // choose some logical default value for buffer size if user
    // has not provided one

    MemorySize = SystemInfo.NumberOfPhysicalPages * SystemInfo.PageSize
                    / 1024 / 1024;
    if (MemorySize <= 32)
        BufferSize      = SystemInfo.PageSize;
    else if (MemorySize <= 64)
        BufferSize      = SystemInfo.PageSize;
    else if (MemorySize <= 128)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize <= 256)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize > 512)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize <= 256)
        BufferSize      = SystemInfo.PageSize * 2;
    else if (MemorySize > 512)
        BufferSize      = 64 * 1024;        // allocation size
    else       // > 256 && < 512
        BufferSize      = SystemInfo.PageSize * 2;

    if (LoggerInfo->BufferSize > 1024)      // limit to 1Mb
        BufferSize = 1024 * 1024;
    else if (LoggerInfo->BufferSize > 0)
        BufferSize = LoggerInfo->BufferSize * 1024;

    TraceKernel = IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid);
    if (!TraceKernel) {
        GUID guid;
        RtlZeroMemory(&guid, sizeof(GUID));
        if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &guid)) {
            // Generate a Guid for this logger stream
            // This will ensure  buffer filtering at the WMI service
            // based on this GUID.
            UUID uid;
            UuidCreate(&uid);
            LoggerInfo->Wnode.Guid = uid;
        }
    }

    if (!Update) {
        // don't want to update BufferSize information if the request is
        // to update logger session
        //
        LoggerInfo->BufferSize = BufferSize / 1024;
    }

    if (LoggerInfo->LogFileName.Length <= 0)
        return  ERROR_SUCCESS; //goto SendToKm;
    //
    // We assumed the exposed API has checked for either RealTime or FileName
    // is provided

    //
    // open the file for writing synchronously for the logger
    // others may want to read it as well.
    // For logfile append mode, logfile has been opened previously
    //
    if (! bLogFileAppend) {
/*        LogFile = CreateFileW(
                       (PWCHAR) LoggerInfo->LogFileName.Buffer,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                       );  */
        LogFile = WmipCreateFile(
                    FileName,
                    FILE_GENERIC_WRITE,
                    FILE_SHARE_READ,
                    FILE_OVERWRITE_IF,
                    0);

        if (LogFile == INVALID_HANDLE_VALUE) {
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_BAD_PATHNAME);
        }
    }

    LoggerInfo->LogFileHandle = LogFile;


    //
    // If this is an Update call, then we need to pick up the original
    // buffer size for the LogFileHeader.
    //

    if (Update) {
        PWMI_LOGGER_INFORMATION pTempLoggerInfo;
        PWCHAR strLoggerName = NULL;
        PWCHAR strLogFileName = NULL;
        ULONG ErrCode;
        ULONG SizeNeeded = sizeof(WMI_LOGGER_INFORMATION) + MAXSTR * sizeof(WCHAR) * 2;
        SizeNeeded = (SizeNeeded +7) & ~7;
        pTempLoggerInfo = WmipAlloc(SizeNeeded);
        if (pTempLoggerInfo == NULL) {
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        RtlZeroMemory(pTempLoggerInfo, SizeNeeded);
        pTempLoggerInfo->Wnode.BufferSize = SizeNeeded;
        pTempLoggerInfo->Wnode.Flags |= WNODE_FLAG_TRACED_GUID;
        pTempLoggerInfo->Wnode.HistoricalContext = LoggerInfo->Wnode.HistoricalContext;
        pTempLoggerInfo->Wnode.Guid = LoggerInfo->Wnode.Guid;

        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            pTempLoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;
        }

        strLoggerName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION));
        WmipInitString(&pTempLoggerInfo->LoggerName,
                       strLoggerName,
                       MAXSTR * sizeof(WCHAR));
        if (LoggerInfo->LoggerName.Length > 0) {
            RtlCopyUnicodeString( &pTempLoggerInfo->LoggerName,
                                  &LoggerInfo->LoggerName);
        }


        strLogFileName = (PWCHAR) ( ((PUCHAR) pTempLoggerInfo)
                                    + sizeof(WMI_LOGGER_INFORMATION)
                                    + MAXSTR * sizeof(WCHAR) );
        WmipInitString(&pTempLoggerInfo->LogFileName,
                       strLogFileName,
                       MAXSTR * sizeof(WCHAR) );

        //
        // Call QueryLogger
        //
        ErrCode = WmipQueryLogger(pTempLoggerInfo, FALSE);

        BufferSize = pTempLoggerInfo->BufferSize * 1024;
        WmipFree(pTempLoggerInfo);

        if (ErrCode != ERROR_SUCCESS) {
            return ErrCode;
        }
    }
    //
    // Before Allocating the Buffer for Logfile Header make
    // sure the buffer size is atleast as large as the LogFileHeader
    //

    HeaderSize =  sizeof(LoggerBuffer)
                        + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                        + LoggerInfo->LogFileName.Length + sizeof(WCHAR);

    if (HeaderSize > BufferSize) {
        //
        //  Round it to the nearest power of 2 and check for max size 1 MB
        //
        double dTemp = log (HeaderSize / 1024.0) / log (2.0);
        ULONG lTemp = (ULONG) (dTemp + 0.99);
        HeaderSize = (1 << lTemp);
        if (HeaderSize > 1024) {
            NtClose(LogFile);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }
        LoggerInfo->BufferSize = HeaderSize;
        BufferSize = HeaderSize * 1024;
    }



    // allocate a buffer to write logger header and process/thread
    // rundown information
    //
    Logger.LogFileHandle   = LogFile;
    Logger.BufferSize      = BufferSize;
    Logger.TimerResolution = SystemInfo.TimerResolution;
    Logger.BufferSpace          = WmipAlloc(BufferSize);
    if (Logger.BufferSpace == NULL) {
        NtClose(LogFile);
        if (FileNameBuffer != NULL) {
            WmipFree(FileNameBuffer);
        }
        return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
    }

    Logger.UsePerfClock = LoggerInfo->Wnode.ClientContext;

    // initialize buffer first
    RtlZeroMemory(Logger.BufferSpace, BufferSize);
    Buffer         = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
    if (TraceKernel) {
        Buffer->Wnode.Guid   = SystemTraceControlGuid;
    }
    else {
        Buffer->Wnode.Guid   = LoggerInfo->Wnode.Guid;
    }
    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Flags      = WNODE_FLAG_TRACED_GUID;

    if (bLogFileAppend) {
        Logger.BuffersWritten  = LoggerBuffer.LogFileHeader.BuffersWritten;
        SetFilePointer(LogFile, 0, NULL, FILE_END);
    }
    else {
        PTRACE_LOGFILE_HEADER LogfileHeader;
        OSVERSIONINFO sVersionInfo;
        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER Frequency;
        ULONG CpuNum = 0, CpuSpeed;
        
        Status = NtQueryPerformanceCounter(&CurrentTime, &Frequency);

        Logger.BuffersWritten  = 0;
        HeaderSize =  sizeof(TRACE_LOGFILE_HEADER)
                        + LoggerInfo->LoggerName.Length + sizeof(WCHAR)
                        + LoggerInfo->LogFileName.Length + sizeof(WCHAR);



        LogfileHeader = (PTRACE_LOGFILE_HEADER)
                        WmipGetTraceBuffer(
                            &Logger,
                            NULL,
                            EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_INFO,
                            HeaderSize
                            );
        if (LogfileHeader == NULL) {
            NtClose(LogFile);
            WmipFree(Logger.BufferSpace);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
        }


        LogfileHeader->PerfFreq = Frequency;
        LogfileHeader->ReservedFlags = Logger.UsePerfClock;
        if (NT_SUCCESS(WmipGetCpuSpeed(&CpuNum, &CpuSpeed))) {
            LogfileHeader->CpuSpeedInMHz = CpuSpeed;
        }

        //
        // Start and End Times are wall clock time
        //
        if (RefClock != NULL) {
            PSYSTEM_TRACE_HEADER Header;
            LogfileHeader->StartTime = RefClock->StartTime;
            Header = (PSYSTEM_TRACE_HEADER) ( (char *) LogfileHeader - sizeof(SYSTEM_TRACE_HEADER) );
            Header->SystemTime = RefClock->StartPerfClock;
        }
        else {
            LogfileHeader->StartTime.QuadPart = WmipGetSystemTime();
        }

        RtlZeroMemory(&sVersionInfo, sizeof(OSVERSIONINFO));
        sVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&sVersionInfo);

        LogfileHeader->BufferSize = BufferSize;
        LogfileHeader->VersionDetail.MajorVersion =
                                         (UCHAR)sVersionInfo.dwMajorVersion;
        LogfileHeader->VersionDetail.MinorVersion =
                                         (UCHAR)sVersionInfo.dwMinorVersion;
        LogfileHeader->VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
        LogfileHeader->VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
        LogfileHeader->ProviderVersion = sVersionInfo.dwBuildNumber;
        LogfileHeader->StartBuffers = 1;
        LogfileHeader->LogFileMode
                = LoggerInfo->LogFileMode & (~(EVENT_TRACE_REAL_TIME_MODE));
        LogfileHeader->NumberOfProcessors = SystemInfo.NumberOfProcessors;
        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)
        {
            LoggerInfo->NumberOfProcessors = SystemInfo.NumberOfProcessors;
        }
        LogfileHeader->MaximumFileSize = LoggerInfo->MaximumFileSize;

        LogfileHeader->TimerResolution = SystemInfo.TimerResolution;

        LogfileHeader->LoggerName = (PWCHAR) ( (PUCHAR) LogfileHeader
                                    + sizeof(TRACE_LOGFILE_HEADER) );
        LogfileHeader->LogFileName = (PWCHAR) ((PUCHAR)LogfileHeader->LoggerName
                                    + LoggerInfo->LoggerName.Length
                                    + sizeof (WCHAR));
        RtlCopyMemory(LogfileHeader->LoggerName,
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length + sizeof(WCHAR));
        RtlCopyMemory(LogfileHeader->LogFileName,
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length + sizeof(WCHAR));
        GetTimeZoneInformation(&LogfileHeader->TimeZone);
        LogfileHeader->PointerSize = sizeof(PVOID);

        if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
            LoggerInfo->Checksum = NULL;
        }
        else {
            LoggerInfo->Checksum = WmipAlloc(
                            sizeof(WNODE_HEADER)
                          + sizeof(TRACE_LOGFILE_HEADER));
            if (LoggerInfo->Checksum != NULL) {
                PBYTE ptrChecksum = LoggerInfo->Checksum;
                RtlCopyMemory(ptrChecksum, Buffer, sizeof(WNODE_HEADER));
                ptrChecksum += sizeof(WNODE_HEADER);
                RtlCopyMemory(
                    ptrChecksum, LogfileHeader, sizeof(TRACE_LOGFILE_HEADER));
            }
            else {
                NtClose(LogFile);
                WmipFree(Logger.BufferSpace);
                if (FileNameBuffer != NULL) {
                    WmipFree(FileNameBuffer);
                }
                return WmipSetDosError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
    }

    // Dump the GuidMaps to File at the Start
    //
    if (!Update) {
        if (TraceKernel) {
            ULONG EnableFlags = LoggerInfo->EnableFlags;

            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                PTRACE_ENABLE_FLAG_EXTENSION tFlagExt;

                tFlagExt = (PTRACE_ENABLE_FLAG_EXTENSION)
                           &LoggerInfo->EnableFlags;
                EnableFlags = *(PULONG)((PCHAR)LoggerInfo + tFlagExt->Offset);
            }

            WmipDumpHardwareConfig(&Logger);


            WmipProcessRunDown( &Logger, TRUE, EnableFlags );
        }
        else {
            WmipDumpGuidMaps(&Logger, NULL, FALSE);
        }
    }

    Buffer = (PWMI_BUFFER_HEADER) Logger.BufferSpace;
    // flush the last buffer
    if ( (Buffer->Offset < Logger.BufferSize)     &&
         (Buffer->Offset > sizeof(WMI_BUFFER_HEADER)) )
    {
        RtlFillMemory(
                (char *) Buffer + Buffer->Offset,
                Logger.BufferSize - Buffer->Offset,
                0xFF);
        Status = NtWriteFile(
                LogFile,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                Logger.BufferSpace,
                BufferSize,
                NULL,
                NULL);

        Logger.BuffersWritten++;
    }

    if ((LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_CIRCULAR) ) {
        //
        // We need to write the number of StartBuffers in the
        // Circular Logfile header to process it properly.

        FileInfo.CurrentByteOffset.QuadPart =
                            LOGFILE_FIELD_OFFSET(StartBuffers);

        Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
        if (!NT_SUCCESS(Status)) {
            NtClose(LogFile);
            if (FileNameBuffer != NULL) {
                WmipFree(FileNameBuffer);
            }
            return WmipSetDosError(WmipNtStatusToDosError(Status));
        }

        Status = NtWriteFile(
                            LogFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            &Logger.BuffersWritten,
                            sizeof(ULONG),
                            NULL,
                            NULL
                            );
        if (NT_SUCCESS(Status)) {
            PTRACE_LOGFILE_HEADER pLogFileHeader;

            NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
            //
            // update StartBuffers in Checksum
            //
            if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
                if (LoggerInfo->Checksum == NULL) {
                    CloseHandle(LogFile);
                    return (ERROR_INVALID_DATA);
                }
                pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                         (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
                pLogFileHeader->StartBuffers = Logger.BuffersWritten;
            }
        }
    }

    //
    // As a last thing update the Number of BuffersWritten so far
    // in the header and also update the checksum. This is to prevent
    // Logger failing Update calls under high load.
    //

    FileInfo.CurrentByteOffset.QuadPart =
                    LOGFILE_FIELD_OFFSET(BuffersWritten);

    Status = NtSetInformationFile(
                             LogFile,
                             &IoStatus,
                             &FileInfo,
                             sizeof(FILE_POSITION_INFORMATION),
                             FilePositionInformation
                             );
    if (!NT_SUCCESS(Status)) {
        NtClose(LogFile);
        return WmipSetDosError(WmipNtStatusToDosError(Status));
    }

    Status = NtWriteFile(
                        LogFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        &Logger.BuffersWritten,
                        sizeof(ULONG),
                        NULL,
                        NULL
                        );
    if (NT_SUCCESS(Status)) {
        PTRACE_LOGFILE_HEADER pLogFileHeader;

        NtFlushBuffersFile(Logger.LogFileHandle, &IoStatus);
        //
        // update StartBuffers in Checksum
        //
        if ( !(LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE)) {
            if (LoggerInfo->Checksum == NULL) {
                CloseHandle(LogFile);
                return (ERROR_INVALID_DATA);
            }
            pLogFileHeader = (PTRACE_LOGFILE_HEADER)
                     (((PUCHAR) LoggerInfo->Checksum) + sizeof(WNODE_HEADER));
            pLogFileHeader->BuffersWritten = Logger.BuffersWritten;
        }
    }

    // Extend the file size if in PREALLOCATE mode
    if (LoggerInfo->MaximumFileSize && 
        (LoggerInfo->LogFileMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
        IO_STATUS_BLOCK IoStatusBlock;
        FILE_END_OF_FILE_INFORMATION EOFInfo;

        EOFInfo.EndOfFile.QuadPart = ((ULONGLONG)LoggerInfo->MaximumFileSize) * (1024 * 1024);

        Status = NtSetInformationFile(LogFile,
                                      &IoStatusBlock,
                                      &EOFInfo,
                                      sizeof(FILE_END_OF_FILE_INFORMATION),
                                      FileEndOfFileInformation);
        if (!NT_SUCCESS(Status)) {
            NtClose(LogFile);
            return WmipSetDosError(WmipNtStatusToDosError(Status));
        }
    }

    NtClose(LogFile);

    LogFile = CreateFileW(
                 FileName,
                 GENERIC_WRITE,
                 FILE_SHARE_READ,
                 NULL,
                 OPEN_EXISTING,
                 FILE_FLAG_NO_BUFFERING,
                 NULL
                 );
    if (FileNameBuffer != NULL) {
        WmipFree(FileNameBuffer);
    }
    WmipFree(Logger.BufferSpace);

    if (LogFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }
    LoggerInfo->LogFileHandle = LogFile;
    LoggerInfo->BuffersWritten = Logger.BuffersWritten;
    return ERROR_SUCCESS;
}

ULONG
WmipDumpGuidMaps(
    IN PWMI_LOGGER_CONTEXT Logger,
    IN PLIST_ENTRY GuidMapListHeadPtr,
    IN ULONG RealTimeFlag
    )
/*++

Routine Description:

    This routine communicates with the WMI Service and obtains all the
    Trace Guids that are currently registered and those guids that unregistered
    in the middle of a Logging session.
    The GuidMaps are dumped to the logfile or added to the current GuidMapList
    for real time processing.

Arguments:

    Logger          Logger Context.
    RealTimeFlag    Flag to denote real time processing.

Return Value:

    Returns the number of Trace GUIDS obtained from the WMI service.

--*/
{
    ULONG Status;
    PTRACEGUIDMAP GuidMapList = NULL;
    ULONG MaxGuidCount;
    ULONG TotalGuidCount;
    ULONG ReturnGuidCount;
    ULONG BusyRetries;

    // Ensure that wmi service is around and willing to send us notifications
#if 0	
    Status = WmipEnableNotifications();
#else
    Status = ERROR_INVALID_PARAMETER;
#endif
    if (Status != ERROR_SUCCESS)
    {
        SetLastError(Status);
        return(0);
    }
    MaxGuidCount = 10;
retry:
    TotalGuidCount = 0;
    ReturnGuidCount = 0;
    GuidMapList = WmipAlloc(MaxGuidCount * sizeof(TRACEGUIDMAP));
    if (GuidMapList == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (0);
    }
    RtlZeroMemory(GuidMapList, MaxGuidCount * sizeof(TRACEGUIDMAP));

    BusyRetries = 0;
    do
    {
       try
       {
#if 0	
           Status = EnumerateTraceGuidMap(WmipDcCtxHandle,
                                      MaxGuidCount,
                                      &TotalGuidCount,
                                      &ReturnGuidCount,
                                      GuidMapList);
#endif			
       } except(EXCEPTION_EXECUTE_HANDLER) {
           Status = GetExceptionCode();
           if (Status == STATUS_ACCESS_VIOLATION)
           {
                Status = ERROR_NOACCESS;
                WmipFree(GuidMapList);
                SetLastError(Status);
                return (0);
           }
       }
        if (Status == RPC_S_SERVER_TOO_BUSY)
        {
            WmipDebugPrint(("WMI: EnumerateTraceGuidMap too busy for the %d time\n",
                                      BusyRetries));
            Sleep(RPC_BUSY_WAIT_TIMER);
            BusyRetries++;
        }
    } while ((Status == RPC_S_SERVER_TOO_BUSY) &&
             (BusyRetries < RPC_BUSY_WAIT_RETRIES));

    //
    // If RPC was successful, then write out these events to logfile.
    //

    if (Status == ERROR_MORE_DATA) {
        MaxGuidCount = TotalGuidCount;
        WmipFree(GuidMapList);
        goto retry;
    }
    else if (Status == ERROR_SUCCESS) {
       ULONG GroupType;
       ULONG i;
       ULONG Size;
       PULONG AuxInfo;
       PTRACEGUIDMAP pTraceGuidMap = GuidMapList;


       GroupType = EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_GUIDMAP;
       Size = sizeof(TRACEGUIDMAP);

       for (i=0; i < ReturnGuidCount; i++) {
            if (RealTimeFlag) {
                WmipAddGuidHandleToGuidMapList(GuidMapListHeadPtr, pTraceGuidMap->GuidMapHandle,
                                               &pTraceGuidMap->Guid);
            }
            else {
                AuxInfo = (PULONG) WmipGetTraceBuffer(
                               Logger,
                               NULL,
                               GroupType,
                               Size);
               if (AuxInfo == NULL) {
                    WmipFree(GuidMapList);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                   return(0);
               }
               RtlCopyMemory(AuxInfo, pTraceGuidMap, sizeof(TRACEGUIDMAP));
            }
           pTraceGuidMap++;
       }
    }
    WmipFree(GuidMapList);
    WmipSetDosError(Status);
    return(ReturnGuidCount);
}

ULONG
WmiUnregisterGuids(
    IN WMIHANDLE WMIHandle,
    IN LPGUID    Guid,
    OUT ULONG64  *LoggerContext
)
/*++

Routine Description:

    This routine informs WMI that a data provider is no longer available
    to receive requests for the guids previously registered. WMI will
    unregister any guids registered with this handle.

Arguments:

    WMIHandle - Handle returned from WMIRegisterGuids that represents
                the guids whose data is not longer available.
    Guid -      Pointer to the control Guid which is unregistering

    LoggerContext - Returned value of the LoggerContext

Return Value:

    Returns status code

--*/
{
    ULONG Status;
    ULONG ReturnSize;
    WMIUNREGGUIDS UnregGuids;

    UnregGuids.RequestHandle.Handle64 = (ULONG64)WMIHandle;
    UnregGuids.Guid = *Guid;

    Status = WmipSendWmiKMRequest(NULL,
                                         IOCTL_WMI_UNREGISTER_GUIDS,
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &UnregGuids,
                                         sizeof(WMIUNREGGUIDS),
                                         &ReturnSize,
                                         NULL);
                                    

    if (Status == ERROR_SUCCESS) 
    {
        Status = WmipRemoveFromGNList(Guid, 
                                    (PVOID) WMIHandle);
    }

    WmipSetDosError(Status);
    return(Status);

}

ULONG
WmipFlushLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This is the actual routine to communicate with the kernel to start
    the logger. All the required parameters must be in LoggerInfo.

Arguments:

    LoggerInfo      The actual parameters to be passed to and return from
                    kernel.

Return Value:

    The status of performing the action requested.

--*/
{
    ULONG Status;
    ULONG BufferSize;
    PTRACE_ENABLE_CONTEXT pContext;

    if (   (LoggerInfo == NULL)
        || (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        || (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID))) {
        return WmipSetDosError(ERROR_INVALID_PARAMETER);
    }

    pContext = (PTRACE_ENABLE_CONTEXT) & LoggerInfo->Wnode.HistoricalContext;
    if (   (pContext->InternalFlag != 0)
        && (pContext->InternalFlag != EVENT_TRACE_INTERNAL_FLAG_PRIVATE)) {
        // Currently only one possible InternalFlag value. This will filter
        // out some bogus LoggerHandle
        //
        return WmipSetDosError(ERROR_INVALID_HANDLE);
    }

    if (LoggerInfo->LogFileMode & EVENT_TRACE_PRIVATE_LOGGER_MODE) {
        Status = WmipSendUmLogRequest(
                    WmiFlushLoggerCode,
                    LoggerInfo
                    );
    }
    else {

        Status = WmipSendWmiKMRequest(       // actually start the logger here
                    NULL,
                    IOCTL_WMI_FLUSH_LOGGER,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    LoggerInfo,
                    LoggerInfo->Wnode.BufferSize,
                    &BufferSize,
                    NULL
                    );
    }

    return WmipSetDosError(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\mofapi.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    mofapi.c

Abstract:
    
    WMI MOF access apis

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"

ULONG 
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    )
/*++

Routine Description:

    ANSI thunk to WMIMofEnumerateResourcesA

--*/
{
    ULONG Status;
    PMOFRESOURCEINFOW MofResourceInfoUnicode;
    PMOFRESOURCEINFOA MofResourceInfoAnsi;
    PCHAR AnsiPtr;
    PCHAR Ansi;
    ULONG i, AnsiSize, AnsiStructureSize;
    ULONG MofResourceCountUnicode;
    ULONG AnsiLen;
    ULONG AnsiImagePathSize;
    ULONG AnsiResourceNameSize;
    
    WmipInitProcessHeap();
    
    Status = WmiMofEnumerateResourcesW(MofResourceHandle,
                                       &MofResourceCountUnicode,
                                       &MofResourceInfoUnicode);
                                   
    if (Status == ERROR_SUCCESS)
    {
        //
        // Walk the unicode MOFRESOURCEINFOW to determine the ansi size needed
        // for all of the ansi MOFRESOURCEINFOA structures and strings. We 
        // determine the entire size and allocate a single block that holds
        // all of it since that is what WMIMofEnumerateResourceInfoW does.

        AnsiStructureSize = MofResourceCountUnicode * sizeof(MOFRESOURCEINFOA);
        AnsiSize = AnsiStructureSize;
        for (i = 0; i < MofResourceCountUnicode; i++)
        {
            Status = AnsiSizeForUnicodeString(MofResourceInfoUnicode[i].ImagePath,
                                              &AnsiImagePathSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }
                        
            Status = AnsiSizeForUnicodeString(MofResourceInfoUnicode[i].ResourceName,
                                              &AnsiResourceNameSize);
            if (Status != ERROR_SUCCESS)
            {
                goto Done;
            }
                        
            AnsiSize += AnsiImagePathSize + AnsiResourceNameSize;
        }
        
        MofResourceInfoAnsi = WmipAlloc(AnsiSize);
        if (MofResourceInfoAnsi != NULL)
        {
            AnsiPtr = (PCHAR)((PUCHAR)MofResourceInfoAnsi + AnsiStructureSize);
            for (i = 0; i < MofResourceCountUnicode; i++)
               {
                MofResourceInfoAnsi[i].ResourceSize = MofResourceInfoUnicode[i].ResourceSize;
                MofResourceInfoAnsi[i].ResourceBuffer = MofResourceInfoUnicode[i].ResourceBuffer;

                MofResourceInfoAnsi[i].ImagePath = AnsiPtr;
                Status = UnicodeToAnsi(MofResourceInfoUnicode[i].ImagePath, 
                                       &MofResourceInfoAnsi[i].ImagePath,
                                       &AnsiLen);
                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;

                MofResourceInfoAnsi[i].ResourceName = AnsiPtr;
                Status = UnicodeToAnsi(MofResourceInfoUnicode[i].ResourceName, 
                                       &MofResourceInfoAnsi[i].ResourceName,
                                       &AnsiLen);
                if (Status != ERROR_SUCCESS)
                {
                    break;
                }
                AnsiPtr += AnsiLen;

            }
            
            if (Status == ERROR_SUCCESS)
            {
                try
                {
                    *MofResourceInfo = MofResourceInfoAnsi;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = ERROR_NOACCESS;
                    WmipFree(MofResourceInfoAnsi);
                }
            }
         } else {
            //
            // Not enough memory for ansi thunking so free unicode 
               // mof class info and return an error.
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

Done:        
        WmiFreeBuffer(MofResourceInfoUnicode);
    }    
    
    SetLastError(Status);
    return(Status);
}

PTCHAR WmipRegistryToImagePath(
    PTCHAR ImagePath,
    PTCHAR RegistryPath
    )
/*++

Routine Description:

    This routine will determine the location of the device driver's image file
    from its registry path

Arguments:

    RegistryPath is a pointer to the driver's registry path

    ImagePath is buffer of length MAX_PATH and returns the image path

Return Value:

    pointer to Image path of driver or NULL if image path is unavailable

--*/
{
#define SystemRoot TEXT("\\SystemRoot\\")
#ifdef MEMPHIS
#define SystemRootDirectory TEXT("%WinDir%\\")
#else
#define SystemRootDirectory TEXT("%SystemRoot%\\")
#endif
#define SystemRootCharSize (( sizeof(SystemRoot) / sizeof(WCHAR) ) - 1)

#define DriversDirectory TEXT("\\System32\\Drivers\\")
#define NdisDriversDirectory TEXT("\\System\\")

#define QuestionPrefix TEXT("\\??\\")
#define QuestionPrefixSize (( sizeof(QuestionPrefix) / sizeof(WCHAR) ) - 1)

#define RegistryPrefix TEXT("\\Registry")
    HKEY RegKey;
    PTCHAR ImagePathPtr = NULL;
    ULONG ValueType;
    ULONG Size;
    PTCHAR DriverName;
    ULONG Len;
    BOOLEAN DefaultImageName;
    PTCHAR DriversDirectoryPath;
    TCHAR *Buffer;
    TCHAR *FullRegistryPath;
    
    Buffer = (PTCHAR)WmipAlloc(2 * MAX_PATH * sizeof(TCHAR));
    if (Buffer != NULL)
    {
        FullRegistryPath = Buffer + MAX_PATH;

#ifdef MEMPHIS
        TCHAR Buffer2[MAX_PATH];

        //
        // On memphis the registry path could point to two places
        //     \Registry\Machine\System\CurrentControlSet\Services\Driver (Legacy)
        //     System\CurrentControlSet\Services\Class\USB\0001


        if (_tcsnicmp(RegistryPath, RegistryPrefix, sizeof(RegistryPrefix)-1) != 0)
        {
            //
              // This is a non legacy type registry path.
            if (RegOpenKey(HKEY_LOCAL_MACHINE,
                           RegistryPath,
                           &RegKey) == ERROR_SUCCESS)
            {
                DriverName = Buffer2;
                Size = MAX_PATH * sizeof(WCHAR);

                if (RegQueryValueEx(RegKey,
                                    TEXT("NTMPDriver"),
                                    NULL,
                                    &ValueType,
                                    DriverName,
                                    &Size) == ERROR_SUCCESS)
                {
                    DriversDirectoryPath = DriversDirectory;
                } else if (RegQueryValueEx(RegKey,
                                    TEXT("DeviceVxDs"),
                                    NULL,
                                    &ValueType,
                                    DriverName,
                                    &Size) == ERROR_SUCCESS)
                {
                    DriversDirectoryPath = NdisDriversDirectory;
                } else {
                    DriversDirectoryPath = NULL;
                }

                if ((DriversDirectoryPath != NULL) && (ValueType == REG_SZ))
                {
                    Size = GetWindowsDirectory(Buffer, MAX_PATH);
                    if ((Size != 0) &&
                        (Size <= (MAX_PATH - _tcslen(DriverName) - sizeof(DriversDirectory) - 1)))
                    {
                        if (Buffer[Size-1] == TEXT('\\'))
                        {
                            Buffer[Size-1] = 0;
                        }
                        _tcscpy(ImagePath, Buffer);
                        _tcscat(ImagePath, DriversDirectoryPath);
                        _tcscat(ImagePath, DriverName);
                        ImagePathPtr = ImagePath;
                        RegCloseKey(RegKey);
                        WmipFree(Buffer);
                        return(ImagePathPtr);
                    }
                }
                RegCloseKey(RegKey);
            }
        }
#endif

        //
        // Get the driver file name or the MOF image path from the KM
        // registry path. Here are the rules:
        //
        // 1. First check the MofImagePath value in the registry in case the
        //    mof resource is in a different file from the driver.
        // 2. Next check the ImagePath value since the mof resource is assumed
        //    to be part of the driver image.
        // 3. If no MofImagePath or ImagePath values then assume the mof resource
        //    is in the driver file and compose the driver file name as
        //    %SystemRoot%\System32\driver.sys.
        // 4. If MofImagePath or ImagePath was specified then
        //    - Check first char for % or second character for :, or prefix
        //      of \??\ and if so use ExpandEnvironmentStrings
        //    - Check first part of path for \SystemRoot\, if so rebuild string
        //      as %SystemRoot%\ and use ExpandEnvironementStrings
        //    - Assume format D below and prepend %SystemRoot%\ and use
        //      ExpandEnvironmentStrings

        // If MofImagePath or ImagePath value is present and it is a REG_EXPAND_SZ
        // then it is used to locate the file that holds the mof resource. It
        // can be in one of the following formats:
        //    Format A - %SystemRoot%\System32\Foo.Dll
        //    Format B -C:\WINNT\SYSTEM32\Drivers\Foo.SYS
        //    Format C - \SystemRoot\System32\Drivers\Foo.SYS
        //    Format D - System32\Drivers\Foo.Sys
        //    Format E - \??\c:\foo.sys


        Len = _tcslen(RegistryPath);

        if (Len > 0)
        {
            DriverName = RegistryPath + Len;
            while ((*(--DriverName) != '\\') && (--Len > 0)) ;
        }

        if (Len == 0)
        {
            WmipDebugPrint(("WMI: Badly formed registry path %ws\n", RegistryPath));
            WmipFree(Buffer);
            return(NULL);
        }

        DriverName++;

        _tcscpy(FullRegistryPath, TEXT("System\\CurrentControlSet\\Services\\"));
        _tcscat(FullRegistryPath, DriverName);
        DefaultImageName = TRUE;
        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                                  FullRegistryPath,
                                 &RegKey) == ERROR_SUCCESS)
        {
            Size = MAX_PATH * sizeof(WCHAR);
            if (RegQueryValueEx(RegKey,
                                TEXT("MofImagePath"),
                                NULL,
                                &ValueType,
                                (PBYTE)ImagePath,
                                &Size) == ERROR_SUCCESS)
            {
                  DefaultImageName = FALSE;
            } else {
                Size = MAX_PATH * sizeof(WCHAR);
                if (RegQueryValueEx(RegKey,
                                    TEXT("ImagePath"),
                                    NULL,
                                    &ValueType,
                                    (PBYTE)ImagePath,
                                    &Size) == ERROR_SUCCESS)
                {
                    DefaultImageName = FALSE;
                }
            }
            RegCloseKey(RegKey);
        }

        if ((DefaultImageName) ||
            ((ValueType != REG_EXPAND_SZ) && (ValueType != REG_SZ)) ||
            (Size < (2 * sizeof(WCHAR))))
        {
            //
            // No special ImagePath or MofImagePath so assume image file is
            // %SystemRoot%\System32\Drivers\Driver.Sys
#ifdef MEMPHIS
            _tcscpy(Buffer, TEXT("%WinDir%\\System32\\Drivers\\"));
#else
            _tcscpy(Buffer, TEXT("%SystemRoot%\\System32\\Drivers\\"));
#endif
            _tcscat(Buffer, DriverName);
            _tcscat(Buffer, TEXT(".SYS"));
        } else {
            if (_tcsnicmp(ImagePath,
                          SystemRoot,
                          SystemRootCharSize) == 0)
            {
                //
                // Looks like format C
                _tcscpy(Buffer, SystemRootDirectory);
                _tcscat(Buffer, &ImagePath[SystemRootCharSize]);
            } else if ((*ImagePath == '%') ||
                       ( (Size > 3*sizeof(WCHAR)) && ImagePath[1] == TEXT(':')) )
            {
                //
                // Looks like format B or format A
                _tcscpy(Buffer, ImagePath);
            } else if (_tcsnicmp(ImagePath,
                                 QuestionPrefix,
                                 QuestionPrefixSize) == 0)
            {
                //
                // Looks like format E
                _tcscpy(Buffer, ImagePath+QuestionPrefixSize);
            } else {
                //
                // Assume format D
                _tcscpy(Buffer, SystemRootDirectory);
                _tcscat(Buffer, ImagePath);
            }
        }

        Size = ExpandEnvironmentStrings(Buffer,
                                        ImagePath,
                                        MAX_PATH);

#ifdef MEMPHIS
        WmipDebugPrint(("WMI: %s has mof in %s\n",
                         DriverName, ImagePath));
#else
        WmipDebugPrint(("WMI: %ws has mof in %ws\n",
                         DriverName, ImagePath));
#endif
        WmipFree(Buffer);
    } else {
        ImagePath = NULL;
    }

    return(ImagePath);
}

typedef struct
{
    ULONG Count;
    ULONG MaxCount;
    PWCHAR *List;
} ENUMLANGCTX, *PENUMLANGCTX;


BOOL EnumUILanguageCallback(
    LPWSTR Language,
    LONG_PTR Context
)
{
    PENUMLANGCTX EnumLangCtx = (PENUMLANGCTX)Context;
    PWCHAR *p;
    PWCHAR w;
    ULONG NewMaxCount;

    if (EnumLangCtx->Count == EnumLangCtx->MaxCount)
    {
        NewMaxCount = EnumLangCtx->MaxCount * 2;
        p = WmipAlloc( sizeof(PWCHAR) * NewMaxCount);
        if (p != NULL)
        {
            memset(p, 0, sizeof(PWCHAR) * NewMaxCount);
            memcpy(p, EnumLangCtx->List, EnumLangCtx->Count * sizeof(PWCHAR));
            WmipFree(EnumLangCtx->List);
            EnumLangCtx->List = p;
            EnumLangCtx->MaxCount = NewMaxCount;
        } else {
            return(FALSE);
        }
    }

    w = WmipAlloc( (wcslen(Language)+1) * sizeof(WCHAR) );
    if (w != NULL)
    {
        EnumLangCtx->List[EnumLangCtx->Count++] = w;
        wcscpy(w, Language);
    } else {
        return(FALSE);
    }
    
    return(TRUE);
}

ULONG
WmipGetLanguageList(
    PWCHAR **List,
    PULONG Count
    )
{
    ENUMLANGCTX EnumLangCtx;
    BOOL b;
    ULONG Status;

    *List = NULL;
    *Count = 0;
    
    EnumLangCtx.Count = 0;
    EnumLangCtx.MaxCount = 8;
    EnumLangCtx.List = WmipAlloc( 8 * sizeof(PWCHAR) );

    if (EnumLangCtx.List != NULL)
    {
        b = EnumUILanguages(EnumUILanguageCallback,
                            0,
                            (LONG_PTR)&EnumLangCtx);

        if (b)
        {
            *Count = EnumLangCtx.Count;
            *List = EnumLangCtx.List;
            Status = ERROR_SUCCESS;
        } else {
            if (EnumLangCtx.List != NULL)
            {
                WmipFree(EnumLangCtx.List);
            }
            Status = GetLastError();
        }
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}

BOOLEAN
WmipFileExists(
    PWCHAR FileName
    )
{
    HANDLE FindHandle;
    BOOLEAN Found;
    PWIN32_FIND_DATA FindData;

    FindData = (PWIN32_FIND_DATA)WmipAlloc(sizeof(WIN32_FIND_DATA));

    if (FindData != NULL)
    {
        //
        // Now we need to make sure that the file a ctually exists
        //
        FindHandle = FindFirstFile(FileName,
                                   FindData);
        if (FindHandle == INVALID_HANDLE_VALUE)
        {
            Found = FALSE;
        } else {
            FindClose(FindHandle);
            Found = TRUE;
        }
        WmipFree(FindData);
    } else {
        Found = FALSE;
    }
    return(Found);
}

ULONG WmipGetWindowsDirectory(
    PWCHAR *s,
    PWCHAR Static,
    ULONG StaticSize
    )
{
    ULONG Size;
    ULONG Status = ERROR_SUCCESS;

    Size = GetWindowsDirectory(Static, StaticSize);
    if (Size > StaticSize)
    {
        Size += sizeof(UNICODE_NULL);
        *s = WmipAlloc(Size * sizeof(WCHAR));
        if (*s != NULL)
        {
            Size = GetWindowsDirectory(*s, Size);
        } else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else if (Size == 0) {
        Status = GetLastError();
    } else {
        *s = Static;
    }

    if (Status == ERROR_SUCCESS)
    {
        if ( (*s)[Size-1] == L'\\')
        {
            (*s)[Size-1] = 0;
        }
    }
    return(Status);
}

BOOLEAN
WmipCopyMRString(
    PWCHAR Buffer,
    ULONG BufferRemaining,
    PULONG BufferUsed,
    PWCHAR SourceString
    )
{
    BOOLEAN BufferNotFull;
    ULONG len;
    
    len = wcslen(SourceString) + 1;
    if (len <= BufferRemaining)
    {
        wcscpy(Buffer, SourceString);
        *BufferUsed = len;
        BufferNotFull = TRUE;
    } else {
        BufferNotFull = FALSE;
    }
    return(BufferNotFull);
}


BOOLEAN WmipCopyCountedString(
    PUCHAR Base,
    PULONG Offset,
    PULONG BufferRemaining,
    PWCHAR SourceString
    )
{
    PWCHAR w;
    ULONG BufferUsed;
    ULONG BytesUsed;
    BOOLEAN BufferNotFull;
    
    if (*BufferRemaining > 1)
    {
        w = (PWCHAR)OffsetToPtr(Base, *Offset);
        (*BufferRemaining)--;
                        
        BufferNotFull = WmipCopyMRString(w+1,
                                         *BufferRemaining,
                                         &BufferUsed,
                                         SourceString);
        if (BufferNotFull)
        {
            BytesUsed = BufferUsed * sizeof(WCHAR);
            *w = (USHORT)BytesUsed;
            (*BufferRemaining) -= BufferUsed;
            (*Offset) += BytesUsed + sizeof(USHORT);
        }
    } else {
        BufferNotFull = FALSE;
    }
    return(BufferNotFull);
}


ULONG
WmipBuildMUIPath(
    PWCHAR Buffer,
    ULONG BufferRemaining,
    PULONG BufferUsed,
    PWCHAR EnglishPath,
    PWCHAR Language,
    PBOOLEAN BufferNotFull  
    )
{
    #define FallbackDir L"\\MUI\\Fallback\\"
    #define MUIPath L"\\MUI\\"
    #define MUITail L".mui"
    
    ULONG EnglishLen;
    PWCHAR WinDir;
    PWCHAR s, p;
    ULONG len;
    ULONG Status, SizeNeeded;
    PWCHAR LanguagePath;
    PWCHAR WinDirStatic;

    WinDirStatic = WmipAlloc((MAX_PATH+1) * sizeof(WCHAR));

    if (WinDirStatic != NULL)
    {
        Status = ERROR_FILE_NOT_FOUND;

        LanguagePath = Buffer;  

        WmipDebugPrint(("WMI: Building MUI path for %ws in language %ws\n",
                             EnglishPath, Language));

        EnglishLen = wcslen(EnglishPath);
        p = EnglishPath + EnglishLen;
        len = EnglishLen;

        //
        // Work from the end of the string to try to find the last \ so
        // we can then slip in the language name
        //
        while ( (len != 0) && (*p != L'\\'))
        {
            len--;
            p--;
        }

        if (len != 0)
        {
            p++;
        }
        WmipDebugPrint(("WMI: Tail of %ws is %ws\n", EnglishPath, p));

        //
        // First try looking in <path>\\MUI\\<lang id> which is where 3rd
        // parties will install their resource only drivers. We look for
        // foo.sys and then foo.sys.mui.
        //
        SizeNeeded = len + wcslen(Language) + wcslen(MUIPath) + 1 + wcslen(p) + 1 + wcslen(MUITail);

        if (SizeNeeded <= BufferRemaining)
        {
            if (len != 0)
            {
                wcsncpy(LanguagePath, EnglishPath, len);
                LanguagePath[len] = 0;
                wcscat(LanguagePath, MUIPath);
            } else {
                LanguagePath[len] = 0;
            }

            wcscat(LanguagePath, Language);
            wcscat(LanguagePath, L"\\");
            wcscat(LanguagePath, p);
            if (WmipFileExists(LanguagePath))
            {
                *BufferUsed = wcslen(LanguagePath) + 1;
                *BufferNotFull = TRUE;
                Status = ERROR_SUCCESS;
                WmipDebugPrint(("WMI: #1 - Found %ws\n", LanguagePath));
            } else {
                wcscat(LanguagePath, MUITail);
                if (WmipFileExists(LanguagePath))
                {
                    *BufferUsed = wcslen(LanguagePath) + 1;
                    *BufferNotFull = TRUE;
                    Status = ERROR_SUCCESS;
                    WmipDebugPrint(("WMI: #2 - Found %ws\n", LanguagePath));
                }           
            }
        } else {
            *BufferNotFull = FALSE;
            Status = ERROR_SUCCESS;
        }



        if (Status != ERROR_SUCCESS)
        {
            //
            // Next lets check the fallback directory,
            // %windir%\MUI\Fallback\<lang id>. This is where system components
            // are installed by default.
            //
            Status = WmipGetWindowsDirectory(&WinDir,
                                        WinDirStatic,
                                        sizeof(WinDirStatic)/ sizeof(WCHAR));
            if (Status == ERROR_SUCCESS)
            {
                SizeNeeded = wcslen(WinDir) +
                             wcslen(FallbackDir) +
                             wcslen(Language) +
                             1 +
                             wcslen(p) + 1 +
                             wcslen(MUITail);

                if (SizeNeeded <= BufferRemaining)
                {
                    wcscpy(LanguagePath, WinDir);
                    wcscat(LanguagePath, FallbackDir);
                    wcscat(LanguagePath, Language);
                    wcscat(LanguagePath, L"\\");
                    wcscat(LanguagePath, p);
                    wcscat(LanguagePath, MUITail);

                    if ( WmipFileExists(LanguagePath))
                    {
                        *BufferUsed = wcslen(LanguagePath) + 1;
                        *BufferNotFull = TRUE;
                        Status = ERROR_SUCCESS;
                        WmipDebugPrint(("WMI: #3 - Found %ws\n", LanguagePath));
                    } else {
                        Status = ERROR_FILE_NOT_FOUND;
                    }
                } else {
                    *BufferNotFull = FALSE;
                    Status = ERROR_SUCCESS;
                }

                if (WinDir != WinDirStatic)
                {
                    WmipFree(WinDir);
                }
            }
        }
        WmipFree(WinDirStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    return(Status);
}

#if DBG 
    #define MOFLISTSIZEGUESS  1
#else       
    #define MOFLISTSIZEGUESS  10
#endif

ULONG
WmipGetMofResourceList(
    PWMIMOFLIST *MofListPtr
    )
{
    ULONG MofListSize;
    PWMIMOFLIST MofList;
    ULONG RetSize;
    ULONG Status;
    
    //
    // Make an intelligent guess as to the size needed to get all of 
    // the MOF resources
    //
    *MofListPtr = NULL;
    MofListSize = MOFLISTSIZEGUESS * (sizeof(WMIMOFLIST) + 
                                          (MAX_PATH + 
                                           MAX_PATH) * sizeof(WCHAR));
                                       
    MofList = WmipAlloc(MofListSize);
    if (MofList != NULL)
    {    
        Status = WmipSendWmiKMRequest(NULL,
                                      IOCTL_WMI_ENUMERATE_MOF_RESOURCES,
                                      NULL,
                                      0,
                                      MofList,
                                      MofListSize,
                                      &RetSize,
                                      NULL);
              
        if ((Status == ERROR_SUCCESS) && (RetSize == sizeof(ULONG)))
        {
            //
            // The buffer was too small, but we now know how much we'll 
            // need.
            //
            MofListSize = MofList->MofListCount;
            WmipFree(MofList);
            MofList = WmipAlloc(MofListSize);
            if (MofList != NULL)
            {
                //
                // Now lets retry the query
                //
                Status = WmipSendWmiKMRequest(NULL,
                                          IOCTL_WMI_ENUMERATE_MOF_RESOURCES,
                                          NULL,
                                          0,
                                          MofList,
                                          MofListSize,
                                          &RetSize,
                                          NULL);

            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS) 
    {
        if (RetSize >= sizeof(WMIMOFLIST))
        {
            *MofListPtr = MofList;
        } else {
            Status = ERROR_INVALID_PARAMETER;
            WmipFree(MofList);
        }
    } else if (MofList != NULL) {
        WmipFree(MofList);
    }
    return(Status);
}

ULONG 
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    )
/*++

Routine Description:

    This routine will enumerate one or all of the MOF resources that are 
    registered with WMI. 

Arguments:

    MofResourceHandle is reserved and must be 0
        
    *MofResourceCount returns with the count of MOFRESOURCEINFO structures
        returned in *MofResourceInfo.
            
    *MofResourceInfo returns with a pointer to an array of MOFRESOURCEINFO
        structures. The caller MUST call WMIFreeBuffer with *MofResourceInfo
        in order to ensure that there are no memory leaks.
        

Return Value:

    ERROR_SUCCESS or an error code

--*/        
{
    ULONG Status, SubStatus;
    PWMIMOFLIST MofList;
    ULONG MofListCount;
    ULONG MRInfoSize;
    ULONG MRCount;
    PWCHAR MRBuffer;
    PMOFRESOURCEINFOW MRInfo;
    PWCHAR RegPath, ResName, ImagePath;
    PWMIMOFENTRY MofEntry;
    ULONG i, j;
    PWCHAR *LanguageList;
    ULONG LanguageCount;
    BOOLEAN b;
    ULONG HeaderLen;
    ULONG MRBufferRemaining;
    PWCHAR ResourcePtr;
    ULONG BufferUsed;   
    PWCHAR ImagePathStatic;
    
    WmipInitProcessHeap();

    if (MofResourceHandle != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    ImagePathStatic = WmipAlloc(MAX_PATH * sizeof(WCHAR));
    if (ImagePathStatic != NULL)
    {   
        *MofResourceInfo = NULL;

        Status = WmipGetMofResourceList(&MofList);

        if (Status == ERROR_SUCCESS) 
        {
            //
            // Ok, we have got a valid list of mofs. Now we need to 
            // loop over them all and convert the regpaths into image
            // paths
            //

            Status = WmipGetLanguageList(&LanguageList,
                                         &LanguageCount);

            if (Status == ERROR_SUCCESS)
            {
                MofListCount = MofList->MofListCount;


                //
                // Take a guess as to the size of the buffer needed to
                // satisfy the complete list of mof resources
                //
                HeaderLen = (MofListCount * (LanguageCount+1)) *
                            sizeof(MOFRESOURCEINFOW);
    #if DBG
                MRInfoSize = HeaderLen + 2 * (MAX_PATH * sizeof(WCHAR));
    #else
                MRInfoSize = HeaderLen + (2*MofListCount * (MAX_PATH * sizeof(WCHAR)));
    #endif
                MRInfo = NULL;

                do
                {
    TryAgain:                   
                    if (MRInfo != NULL)
                    {
                        WmipDebugPrint(("WMI: MofList was too small, retry 0x%x bytes\n",
                                        MRInfoSize));
                        WmipFree(MRInfo);
                    }

                    MRInfo = WmipAlloc(MRInfoSize);

                    if (MRInfo != NULL)
                    {
                        memset(MRInfo, 0, MRInfoSize);
                        MRBuffer = (PWCHAR)OffsetToPtr(MRInfo, HeaderLen);
                        MRBufferRemaining = (MRInfoSize - HeaderLen) / sizeof(WCHAR);

                        MRCount = 0;
                        for (i = 0; i < MofListCount; i++)
                        {
                            //
                            // Pull out thee image path and resource names
                            //
                            MofEntry = &MofList->MofEntry[i];
                            RegPath = (PWCHAR)OffsetToPtr(MofList, MofEntry->RegPathOffset);
                            ResName = (PWCHAR)OffsetToPtr(MofList, MofEntry->ResourceOffset);
                            if (*ResName != 0)
                            {
                                if ((MofEntry->Flags & WMIMOFENTRY_FLAG_USERMODE) == 0)
                                {
                                    ImagePath = WmipRegistryToImagePath(ImagePathStatic,
                                        RegPath);

                                } else {
                                    ImagePath = RegPath;
                                }

                                if (ImagePath != NULL)
                                {
                                    //
                                    // If we've got a valid image path then
                                    // out it and the resource name into the
                                    // output buffer
                                    //
                                    MRInfo[MRCount].ImagePath = MRBuffer;
                                    b = WmipCopyMRString(MRBuffer,
                                        MRBufferRemaining,
                                        &BufferUsed,
                                        ImagePath);
                                    if (! b)
                                    {
                                        //
                                        // The buffer was not big enough so we
                                        // double the size used and try again
                                        //
                                        MRInfoSize *= 2;
                                        goto TryAgain;
                                    }
                                    MRBuffer += BufferUsed;
                                    MRBufferRemaining -= BufferUsed;

                                    WmipDebugPrint(("WMI: Add ImagePath %p (%ws) to MRList at position %d\n",
                                                    MRInfo[MRCount].ImagePath,
                                                    MRInfo[MRCount].ImagePath,
                                                    MRCount));

                                    MRInfo[MRCount].ResourceName = MRBuffer;
                                    ResourcePtr = MRBuffer;
                                    WmipCopyMRString(MRBuffer,
                                        MRBufferRemaining,
                                        &BufferUsed,
                                        ResName);
                                    if (! b)
                                    {
                                        //
                                        // The buffer was not big enough so we
                                        // double the size used and try again
                                        //
                                        MRInfoSize *= 2;
                                        goto TryAgain;
                                    }
                                    MRBuffer += BufferUsed;
                                    MRBufferRemaining -= BufferUsed;

                                    WmipDebugPrint(("WMI: Add Resource %p (%ws) to MRList at position %d\n",
                                                    MRInfo[MRCount].ResourceName,
                                                    MRInfo[MRCount].ResourceName,
                                                    MRCount));


                                    MRCount++;

                                    for (j = 0; j < LanguageCount; j++)
                                    {             
                                        MRInfo[MRCount].ImagePath = MRBuffer;
                                        SubStatus = WmipBuildMUIPath(MRBuffer,
                                            MRBufferRemaining,
                                            &BufferUsed,
                                            ImagePath,
                                            LanguageList[j],
                                            &b);


                                        if (SubStatus == ERROR_SUCCESS) 
                                        {
                                            if (! b)
                                            {
                                                //
                                                // The buffer was not big enough so we
                                                // double the size used and try again
                                                //
                                                MRInfoSize *= 2;
                                                goto TryAgain;
                                            }
                                            MRBuffer += BufferUsed;
                                            MRBufferRemaining -= BufferUsed;

                                            WmipDebugPrint(("WMI: Add ImagePath %p (%ws) to MRList at position %d\n",
                                                MRInfo[MRCount].ImagePath,
                                                MRInfo[MRCount].ImagePath,
                                                MRCount));

                                            //
                                            // We did find a MUI resource
                                            // so add it to the list
                                            //
                                            MRInfo[MRCount].ResourceName = ResourcePtr;
                                            WmipDebugPrint(("WMI: Add Resource %p (%ws) to MRList at position %d\n",
                                                MRInfo[MRCount].ResourceName,
                                                MRInfo[MRCount].ResourceName,
                                                MRCount));
                                            MRCount++;
                                        }                                    
                                    }
                                }
                            }
                        }
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } while (FALSE);                

                //
                // Free up memory used to hold the language list
                //
                for (i = 0; i < LanguageCount; i++)
                {
                    WmipFree(LanguageList[i]);
                }
                WmipFree(LanguageList);

                *MofResourceCount = MRCount;
                *MofResourceInfo = MRInfo;
            }
            WmipFree(MofList);      
        }
        WmipFree(ImagePathStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
            
    SetLastError(Status);
    return(Status);
}

ULONG WmipBuildMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN PWMIMOFLIST MofList,
    IN PWCHAR *LanguageList,
    IN ULONG LanguageCount,
    IN BOOLEAN IncludeNeutralLanguage,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    PWNODE_ALL_DATA WnodeAD;
    ULONG BytesUsed, BufferUsed;
    BOOLEAN BufferNotFull;
    PWCHAR RegPath, ImagePath, ResourceName;
    ULONG SizeNeeded;
    ULONG InstanceCount, MaxInstanceCount;
    ULONG Status;
    ULONG Offset;
    POFFSETINSTANCEDATAANDLENGTH DataLenPtr;
    PWCHAR w;
    PULONG InstanceNamesOffsets;
    PWCHAR InstanceNames;
    ULONG BufferRemaining;
    ULONG i,j;
    PWMIMOFENTRY MofEntry;  
    PWCHAR ImagePathStatic;
        
    WmipAssert(WnodeSI->WnodeHeader.Flags & WNODE_FLAG_SINGLE_INSTANCE);

    ImagePathStatic = WmipAlloc(MAX_PATH * sizeof(WCHAR));
    if (ImagePathStatic != NULL)
    {
        //
        // Figure out how large the WNODE_ALL_DATA will need to be and
        // guess at how much space to allocate for the image paths and
        // resource names
        //
        if (IncludeNeutralLanguage)
        {
            MaxInstanceCount = (LanguageCount + 1);
        } else {
            MaxInstanceCount = LanguageCount;
        }
        MaxInstanceCount *=  MofList->MofListCount;


    #if DBG
        SizeNeeded = sizeof(WNODE_ALL_DATA) +
                                    (MaxInstanceCount *
                                     (sizeof(ULONG) +  // offset to instance name
                                      sizeof(USHORT) + // instance name length
                                      sizeof(OFFSETINSTANCEDATAANDLENGTH))) +
                             64;
    #else
        SizeNeeded = sizeof(WNODE_ALL_DATA) +
                                    (MaxInstanceCount *
                                     (sizeof(ULONG) +  // offset to instance name
                                      sizeof(USHORT) + // instance name length
                                      sizeof(OFFSETINSTANCEDATAANDLENGTH))) +
                             0x1000;
    #endif
        WnodeAD = NULL;
        do
        {
    TryAgain:
            if (WnodeAD != NULL)
            {
                WmipFree(WnodeAD);
            }

            WnodeAD = WmipAlloc(SizeNeeded);
            if (WnodeAD != NULL)
            {
                //
                // Build up WNODE_ALL_DATA with all mof resources
                //
                memset(WnodeAD, 0, SizeNeeded);

                WnodeAD->WnodeHeader = WnodeSI->WnodeHeader;
                WnodeAD->WnodeHeader.Flags = WNODE_FLAG_ALL_DATA |
                                             WNODE_FLAG_EVENT_ITEM;
                WnodeAD->WnodeHeader.BufferSize = SizeNeeded;
                WnodeAD->WnodeHeader.Linkage = 0;

                //
                // Establish pointer to the data offset and length
                // structure and allocate space for all instances
                //
                Offset = FIELD_OFFSET(WNODE_ALL_DATA,
                                               OffsetInstanceDataAndLength);
                DataLenPtr = (POFFSETINSTANCEDATAANDLENGTH)OffsetToPtr(WnodeAD,
                                                                               Offset);
                Offset = (Offset +
                                  (MaxInstanceCount *
                                   sizeof(OFFSETINSTANCEDATAANDLENGTH)) + 7) & ~7;

                //
                // Establish the instance name offsets and fill in
                // the empty instance names. Note we point them all
                // to the same offset which is an empty instance
                // name.
                //
                InstanceNamesOffsets = (PULONG)OffsetToPtr(WnodeAD,
                                                                  Offset);

                WnodeAD->OffsetInstanceNameOffsets = Offset;                    
                Offset = Offset + (MaxInstanceCount * sizeof(ULONG));
                InstanceNames = (PWCHAR)OffsetToPtr(WnodeAD, Offset);
                *InstanceNames = 0;
                for (i = 0; i < MaxInstanceCount; i++)
                {
                    InstanceNamesOffsets[i] = Offset;
                }

                //
                // Establish a pointer to the data block for all of
                // the instances
                //
                Offset = (Offset +
                                  (MaxInstanceCount * sizeof(USHORT)) + 7) & ~7;
                WnodeAD->DataBlockOffset = Offset;

                BufferRemaining = (SizeNeeded - Offset) / sizeof(WCHAR);

                InstanceCount = 0;                  

                //
                // Loop over all mof resources in list
                //
                for (j = 0; j < MofList->MofListCount; j++)
                {
                    MofEntry = &MofList->MofEntry[j];
                    RegPath = (PWCHAR)OffsetToPtr(MofList,
                                          MofEntry->RegPathOffset);

                    //
                    // Convert regpath to image path if needed
                    //
                    if ((MofEntry->Flags & WMIMOFENTRY_FLAG_USERMODE) == 0)
                    {
                        ImagePath = WmipRegistryToImagePath(ImagePathStatic,
                                                            RegPath+1);
                    } else {
                        ImagePath = RegPath;
                    }

                    if (ImagePath != NULL)
                    {
                        ResourceName = (PWCHAR)OffsetToPtr(MofList,
                                               MofEntry->ResourceOffset);

                        //
                        // Now lets go and build up the data for each
                        // instance. First fill in the language neutral mof
                        // if we are supposed to
                        //
                        if (IncludeNeutralLanguage)
                        {

                            DataLenPtr[InstanceCount].OffsetInstanceData = Offset;

                            if ((! WmipCopyCountedString((PUCHAR)WnodeAD,
                                                     &Offset,
                                                     &BufferRemaining,
                                                     ImagePath))        ||
                                (! WmipCopyCountedString((PUCHAR)WnodeAD,
                                                  &Offset,
                                                  &BufferRemaining,
                                                  ResourceName)))
                            {
                                SizeNeeded *=2;
                                goto TryAgain;
                            }

                            DataLenPtr[InstanceCount].LengthInstanceData = Offset -
                                                                           DataLenPtr[InstanceCount].OffsetInstanceData;

                            InstanceCount++;

                            //
                            // We cheat here and do not align the offset on an
                            // 8 byte boundry for the next data block since we
                            // know the data type is a WCHAR and we know we are
                            // on a 2 byte boundry.
                            //
                        }

                        //
                        // Now loop over and build language specific mof
                        // resources
                        //
                        for (i = 0; i < LanguageCount; i++)
                        {
                            DataLenPtr[InstanceCount].OffsetInstanceData = Offset;
                            if (BufferRemaining > 1)
                            {
                                w = (PWCHAR)OffsetToPtr(WnodeAD, Offset);

                                Status = WmipBuildMUIPath(w+1,
                                                       BufferRemaining - 1,
                                                       &BufferUsed,
                                                       ImagePath,
                                                       LanguageList[i],
                                                       &BufferNotFull);
                                if (Status == ERROR_SUCCESS)
                                {
                                    if (BufferNotFull)
                                    {
                                        BufferRemaining--;
                                        BytesUsed = BufferUsed * sizeof(WCHAR);
                                        *w = (USHORT)BytesUsed;
                                        BufferRemaining -= BufferUsed;
                                        Offset += (BytesUsed + sizeof(USHORT));

                                        if (! WmipCopyCountedString((PUCHAR)WnodeAD,
                                                  &Offset,
                                                  &BufferRemaining,
                                                  ResourceName))
                                        {
                                            SizeNeeded *=2;
                                            goto TryAgain;
                                        }

                                        DataLenPtr[InstanceCount].LengthInstanceData = Offset - DataLenPtr[InstanceCount].OffsetInstanceData;

                                        //
                                        // We cheat here and do not align the offset on an
                                        // 8 byte boundry for the next data block since we
                                        // know the data type is a WCHAR and we know we are
                                        // on a 2 byte boundry.
                                        //

                                        InstanceCount++;
                                    } else {
                                        SizeNeeded *=2;
                                        goto TryAgain;                                  
                                    }
                                }
                            } else {
                                SizeNeeded *=2;
                                goto TryAgain;                                  
                            }
                        }
                    }
                } 
            } else {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } while (FALSE);

        if (WnodeAD != NULL)
        {
            WnodeAD->InstanceCount = InstanceCount;
            WmipMakeEventCallbacks((PWNODE_HEADER)WnodeAD,
                                           Callback,
                                           DeliveryContext,
                                           IsAnsi);
            WmipFree(WnodeAD);
            Status = ERROR_SUCCESS;
        }
        WmipFree(ImagePathStatic);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(Status);
}


void WmipProcessMofAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    PWCHAR RegPath, ResourceName;
    PWCHAR *LanguageList;
    ULONG LanguageCount;
    ULONG Status;
    PWMIMOFLIST MofList;
    ULONG i;
    PWMIMOFENTRY MofEntry;
    ULONG Offset;
    ULONG SizeNeeded;
    PWCHAR w;
        
    RegPath = (PWCHAR)OffsetToPtr(WnodeSI, WnodeSI->DataBlockOffset);
    
    WmipAssert(*RegPath != 0);

    ResourceName = (PWCHAR)OffsetToPtr(WnodeSI,
                                           WnodeSI->DataBlockOffset +
                                           sizeof(USHORT) + 
                                           *RegPath++ + 
                                           sizeof(USHORT));
    
    SizeNeeded = sizeof(WMIMOFLIST) + ((wcslen(RegPath) +
                                           (wcslen(ResourceName) + 2)) * sizeof(WCHAR));
        
    MofList = (PWMIMOFLIST)WmipAlloc(SizeNeeded);
    if (MofList != NULL)
    {
        Status = WmipGetLanguageList(&LanguageList,
                                         &LanguageCount);

        if (Status == ERROR_SUCCESS)
        {
            MofList->MofListCount = 1;
            MofEntry = &MofList->MofEntry[0];
            
            Offset = sizeof(WMIMOFLIST);
            
            MofEntry->RegPathOffset = Offset;
            w = (PWCHAR)OffsetToPtr(MofList, Offset);
            wcscpy(w, RegPath);
            Offset += (wcslen(RegPath) + 1) * sizeof(WCHAR);
            
            MofEntry->ResourceOffset = Offset;
            w = (PWCHAR)OffsetToPtr(MofList, Offset);
            wcscpy(w, ResourceName);
            
            if (WnodeSI->WnodeHeader.ProviderId == MOFEVENT_ACTION_REGISTRY_PATH)
            {
                MofEntry->Flags = 0;
            } else {
                MofEntry->Flags = WMIMOFENTRY_FLAG_USERMODE;
            }
            
            Status = WmipBuildMofAddRemoveEvent(WnodeSI,
                                                MofList,
                                                LanguageList,
                                                LanguageCount,
                                                TRUE,
                                                Callback,
                                                DeliveryContext,
                                                IsAnsi);
            //
            // Free up memory used to hold the language list
            //
            for (i = 0; i < LanguageCount; i++)
            {
                WmipFree(LanguageList[i]);
            }
            
            WmipFree(LanguageList);
        }
        
        WmipFree(MofList);
    } else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    if (Status != ERROR_SUCCESS)
    {
        //
        // If the WNODE_ALL_DATA event wasn't fired then just fire the
        // WNDOE_SINGLE_INSTANCE event so at least we get the language
        // neutral mof
        //
        WnodeSI->WnodeHeader.Flags &= ~WNODE_FLAG_INTERNAL;
        WmipMakeEventCallbacks((PWNODE_HEADER)WnodeSI,
                               Callback,
                               DeliveryContext,
                               IsAnsi);
    }
}

void WmipProcessLanguageAddRemoveEvent(
    IN PWNODE_SINGLE_INSTANCE WnodeSI,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    ULONG Status;
    PWMIMOFLIST MofList;
    PWCHAR Language;
    
    //
    // Get list of mof resources and build an event with the list of
    // resources for the language that is coming or going
    //

    Status = WmipGetMofResourceList(&MofList);

    if (Status == ERROR_SUCCESS)
    {
        Language = (PWCHAR)OffsetToPtr(WnodeSI,
                               WnodeSI->DataBlockOffset + sizeof(USHORT));
        Status = WmipBuildMofAddRemoveEvent(WnodeSI,
                                            MofList,
                                            &Language,
                                            1,
                                            FALSE,
                                            Callback,
                                            DeliveryContext,
                                            IsAnsi);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\main.c ===
/*++                 

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    main.c

Abstract:
    
    WMI  dll main file

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#define INITGUID
#include "wmiump.h"
#include "evntrace.h"
#include <rpc.h>

#ifndef MEMPHIS
RTL_CRITICAL_SECTION PMCritSect;
PVOID WmipProcessHeap;
HANDLE WmipDeviceHandle;
#else
HANDLE PMMutex;
#endif

extern HANDLE WmipWin32Event;

HMODULE WmipDllHandle;

void WmipDeinitializeDll(
    void
    );

void WmipDeinitializeAccess(
    PTCHAR *RpcStringBinding
    );

ULONG WmipInitializeDll(
    void
    );

HINSTANCE DllInstanceHandle;

extern HANDLE WmipKMHandle;

BOOLEAN
WmiDllInitialize(
    IN PVOID DllBase,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function implements Win32 base dll initialization.

Arguments:

    DllHandle - 

    Reason  - attach\detach

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG Status = ERROR_SUCCESS;
    ULONG Foo;

    DllInstanceHandle = (HINSTANCE)DllBase;
    
    if (Reason == DLL_PROCESS_ATTACH)       
    {
#if DBG
        Foo = WmipLoggingEnabled ? 1 : 0;
        WmipGetRegistryValue(LoggingEnableValueText,
                             &Foo);
        WmipLoggingEnabled = (Foo == 0) ? FALSE : TRUE;
#endif
        Status = WmipInitializeDll();
    
    } else if (Reason == DLL_PROCESS_DETACH) {

#ifndef MEMPHIS
        // Flush out UM buffers to logfile
        //
#if 0       
        WmipFlushUmLoggerBuffer();
#endif
#endif
        //
        // DOn't need to clean up if process is exiting
        if (Context == NULL)
        {            
            WmipDeinitializeDll();
        }

        if (WmipKMHandle != (HANDLE)NULL)
        {
            CloseHandle(WmipKMHandle);
        }
    }
    
    return(Status == ERROR_SUCCESS);
}


ULONG WmipInitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{

#ifdef MEMPHIS        
    PMMutex = CreateMutex(NULL, FALSE, NULL);
    if (PMMutex == NULL)
    {
        return(GetLastError());
    }
#else
    ULONG Status;

    Status = RtlInitializeCriticalSection(&PMCritSect);
    
    if (! NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }
    
#endif

    return(ERROR_SUCCESS);
}

#ifndef MEMPHIS
VOID
WmipCreateHeap(
    void
    )
{
    WmipEnterPMCritSection();
    
    if (WmipProcessHeap == NULL)
    {
        WmipProcessHeap = RtlCreateHeap(HEAP_GROWABLE,
                                        NULL,
                                        DLLRESERVEDHEAPSIZE,
                                        DLLCOMMITHEAPSIZE,
                                        NULL,
                                        NULL);
                
        if (WmipProcessHeap == NULL)
        {
            WmipDebugPrint(("WMI: Cannot create WmipProcessHeap, using process default\n"));
            WmipProcessHeap = RtlProcessHeap();
        }
    }
    
    WmipLeavePMCritSection();    
}
#endif

void WmipDeinitializeDll(
    void
    )
/*+++

Routine Description:

Arguments:

Return Value:

---*/
{
#ifdef MEMPHIS
    CloseHandle(PMMutex);
#else
    RtlDeleteCriticalSection(&PMCritSect);    
    if ((WmipProcessHeap != NULL) &&
        (WmipProcessHeap != RtlProcessHeap()))

    {
        RtlDestroyHeap(WmipProcessHeap);
    }
    if (WmipDeviceHandle != NULL) 
    {
        CloseHandle(WmipDeviceHandle);
    }
#endif
    if (WmipWin32Event != NULL)
    {
        CloseHandle(WmipWin32Event);
    }   
}


#if DBG

void WmipGetRegistryValue(
    TCHAR *ValueName,
    PULONG Value
    )
{
    HKEY Key;
    DWORD Type;
    DWORD ValueSize;
    ULONG Status;

    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        WmiRegKeyText,
                        &Key);

    if (Status == ERROR_SUCCESS)
    {
        ValueSize = sizeof(ULONG);
        Status = RegQueryValueEx(Key,
                                 ValueName,
                                 NULL,
                                 &Type,
                                 (LPBYTE)Value,
                                 &ValueSize);

        if ((Status == ERROR_SUCCESS) &&
            (Type == REG_DWORD))
        {
            WmipDebugPrint(("WMI: %ws from registry is %d\n",
                            ValueName,
                            *Value));
        }
        RegCloseKey(Key);
    }   
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Alan Warwick

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=wmi
MINORCOMP=wmidll

TARGETLIBS= \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\user32.lib \
            $(SDK_LIB_PATH)\rpcrt4.lib \
            $(SDK_LIB_PATH)\ntdll.lib

INCLUDES=$(INCLUDES);       \
         ..;                \
         ..\..\inc;         \
         ..\..\..\..\inc;   \
         $(BASE_INC_PATH);  \
         $(PROJECT_ROOT)\published\wmi\inc; \

C_DEFINES=$(C_DEFINES) -D__MIDL_USER_DEFINED

SOURCES_LIST= \
        ..\main.c \
        ..\dcapi.c \
        ..\dpapi.c \
        ..\request.c \
        ..\handle.c \
        ..\notify.c \
        ..\chunk.c \
        ..\mofapi.c \
        ..\logapi.c \
        ..\logsup.c \
        ..\tracedc.c \
        ..\tracehw.c \
        ..\tracelib.c \
        ..\intrnldp.c \
        ..\umlog.c  \
        ..\srvmain.c

UMTYPE=windows

# USE_MSVCRT=1 for debug builds and USE_NTDLL=1 for retail
USE_MSVCRT=1
#USE_NTDLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\wmi\dll\notify.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Handles incoming notifications and requests for consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#include "wmiump.h"
#include "evntrace.h"
#include "ntcsrdll.h"



//
// These globals are essentially parameters passed from the thread crating
// the event pump. The creating thread will alloc all of these resources
// so that it can know whether the pump thread will be successful or not.
// If we ever wanted to be able to have multiple pump threads then we'd
// need to move the globals into a structure and pass the struructure to the
// pump thread.
//
HANDLE WmipEventDeviceHandle;
HANDLE WmipPumpCommandEvent;
HANDLE WmipMyProcessHandle;
OVERLAPPED WmipOverlapped1, WmipOverlapped2;
PUCHAR WmipEventBuffer1, WmipEventBuffer2;
ULONG WmipEventBufferSize1, WmipEventBufferSize2;

//
// How long to wait before the event pump thread times out. On checked
// builds we want to stress the event pump and so we timeout almost
// right away. On free builds we want to be more cautious so we timeout
// after 5 minutes.
//
#if DBG
#define EVENT_NOTIFICATION_WAIT 1
#else
#define EVENT_NOTIFICATION_WAIT (5 * 60 * 1000)
#endif

ULONG WmipEventNotificationWait = EVENT_NOTIFICATION_WAIT;

typedef enum
{
    EVENT_PUMP_ZERO,         // Pump thread has not been started yet
    EVENT_PUMP_IDLE,         // Pump thread was started, but then exited
    EVENT_PUMP_RUNNING,      // Pump thread is running
    EVENT_PUMP_STOPPING      // Pump thread is in process of stopping
} EVENTPUMPSTATE, *PEVENTPUMPSTATE;

EVENTPUMPSTATE WmipPumpState = EVENT_PUMP_ZERO;
BOOLEAN WmipNewPumpThreadPending;

#define WmipSendPumpCommand() SetEvent(WmipPumpCommandEvent);

#define WmipIsPumpStopping() \
    ((WmipPumpState == EVENT_PUMP_STOPPING) ? TRUE : FALSE)

ULONG WmipEventPumpFromKernel(
    PVOID Param
    );

void WmipExternalNotification(
    NOTIFICATIONCALLBACK Callback,
    ULONG_PTR Context,
    PWNODE_HEADER Wnode
    )
/*++

Routine Description:

    This routine dispatches an event to the appropriate callback
    routine. This process only receives events from the WMI service that
    need to be dispatched within this process. The callback address for the
    specific event is passed by the wmi service in Wnode->Linkage.

Arguments:

    Callback is address to callback

    Context is the context to callback with

    Wnode has event to deliver

Return Value:

--*/
{
    try
    {
        (*Callback)(Wnode, Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        WmipDebugPrint(("NotificationCallbackRoutine threw exception %d\n",
            GetExceptionCode()));
    }
}


#ifdef MEMPHIS
ULONG WmipExternalNotificationThread(
    PNOTIFDELIVERYCTX NDContext
    )
/*++

Routine Description:

    This routine is the thread function used to deliver events to event
    consumers on memphis.

Arguments:

    NDContext specifies the information about how to callback the application
    with the event.

Return Value:

--*/
{
    WmipExternalNotification(NDContext->Callback,
                             NDContext->Context,
                             NDContext->Wnode);
    WmipFree(NDContext);
    return(0);
}
#endif

void
WmipProcessExternalEvent(
    PWNODE_HEADER Wnode,
    ULONG WnodeSize,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG NotificationFlags
)
{
    HANDLE ThreadHandle;
    PNOTIFDELIVERYCTX NDContext;
    PWNODE_HEADER *WnodePtr;
    BOOLEAN WnodePtrOk;
    PWNODE_HEADER WnodeCopy;
    DWORD ThreadId;
    BOOLEAN PostOk;
    ULONG Status;
    PVOID NotificationAddress;
    PVOID NotificationContext;

    NotificationAddress = DeliveryInfo;
    NotificationContext = (PVOID)DeliveryContext;

    if (NotificationFlags & NOTIFICATION_FLAG_CALLBACK_DIRECT)
    {
        //
        // Callback notifications can happen in this thread or a new
        // thread. It is up to the server to decide.
#ifdef MEMPHIS
        if (NotificationFlags & DCREF_FLAG_NO_EXTRA_THREAD)
        {
            WmipExternalNotification(
                                    (NOTIFICATIONCALLBACK)NotificationAddress,
                                    (ULONG_PTR)NotificationContext,
                                    Wnode);
        } else {
            NDContext = WmipAlloc(FIELD_OFFSET(NOTIFDELIVERYCTX,
                                                    WnodeBuffer) + WnodeSize);
            if (NDContext != NULL)
            {
                NDContext->Callback = (NOTIFICATIONCALLBACK)NotificationAddress;
                NDContext->Context = (ULONG_PTR)NotificationContext;
                WnodeCopy = (PWNODE_HEADER)NDContext->WnodeBuffer;
                memcpy(WnodeCopy, Wnode, WnodeSize);
                NDContext->Wnode = WnodeCopy;
                ThreadHandle = CreateThread(NULL,
                                              0,
                                              WmipExternalNotificationThread,
                                              NDContext,
                                              0,
                                              &ThreadId);
                if (ThreadHandle != NULL)
                {
                    CloseHandle(ThreadHandle);
                } else {
                     WmipDebugPrint(("WMI: Event dropped due to thread creation failure\n"));
                }
            } else {
                WmipDebugPrint(("WMI: Event dropped due to lack of memory\n"));
            }
        }
#else
        //
        // On NT we deliver events in this thread since
        // the service is using async rpc.
        WmipExternalNotification(
                            (NOTIFICATIONCALLBACK)NotificationAddress,
                            (ULONG_PTR)NotificationContext,
                            Wnode);
#endif
    }
}


void WmipInternalNotification(
    IN PWNODE_HEADER Wnode,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi    
    )
{
    ULONG ActionCode, Cookie;
    PUCHAR Buffer = (PUCHAR)Wnode;

    //
    // This is an internal event, which is really a callback
    // from kernel mode
    //
    ActionCode = Wnode->ProviderId;
    Cookie = Wnode->CountLost;
#if DBG
    WmipDebugPrint(("WMI: Got internal event Action %d, Cookie %x\n",
                             ActionCode, Cookie));
#endif


    // if this is a trace guid enable/disable call use the cookie
    // to get the address


    if ( (Wnode->Flags & WNODE_FLAG_TRACED_GUID) || (ActionCode == WmiMBRequest) )
    {
        switch (ActionCode) {
            case WmiEnableEvents:
            case WmiDisableEvents:
            {
                WMIDPREQUEST WmiDPRequest;
                PVOID RequestAddress;
                PVOID RequestContext;
                ULONG Status;
                ULONG BufferSize = Wnode->BufferSize;

                if (Wnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG64)) ) {
                    PULONG64 pLoggerContext = (PULONG64)(Buffer + sizeof(WNODE_HEADER));
                    Wnode->HistoricalContext = *pLoggerContext;
                }
                else {
#if DBG
                    WmipDebugPrint(("WMI: Wnode size %d is small for Trace notifications\n", Wnode->BufferSize));
#endif
                }

                if (WmipLookupCookie(Cookie,
                                     &Wnode->Guid,
                                     &RequestAddress,
                                     &RequestContext)) {
                    WmiDPRequest = (WMIDPREQUEST)RequestAddress;

                    try
                    {
#ifndef MEMPHIS


                        WmipGenericTraceEnable(Wnode->ProviderId, Buffer, (PVOID*)&WmiDPRequest);

#endif
                        if (*WmiDPRequest != NULL) {
                            Status = (*WmiDPRequest)(Wnode->ProviderId,
                                                 RequestContext,
                                                 &BufferSize,
                                                 Buffer);
                        }
                        else
                            Status = ERROR_WMI_DP_NOT_FOUND;
                    } except (EXCEPTION_EXECUTE_HANDLER) {
#if DBG
                        Status = GetExceptionCode();
                        WmipDebugPrint(("WMI: Service request call caused an exception %d\n",
                                        Status));
#endif
                        Status = ERROR_WMI_DP_FAILED;
                    }

                }
                break;
            }
            case WmiMBRequest:
            {
                PGUIDNOTIFICATION GNEntry;
                PVOID DeliveryInfo = NULL;
                ULONG_PTR DeliveryContext1;
                ULONG i;
                PWMI_LOGGER_INFORMATION LoggerInfo;

                if (Wnode->BufferSize < (sizeof(WNODE_HEADER) + sizeof(WMI_LOGGER_INFORMATION)) )
                {
#if DBG
                    SetLastError(ERROR_WMI_DP_FAILED);
                    WmipDebugPrint(("WMI: WmiMBRequest with invalid buffer size %d\n",
                                        Wnode->BufferSize));
#endif
                    return;
                }

                LoggerInfo = (PWMI_LOGGER_INFORMATION) ((PUCHAR)Wnode + sizeof(WNODE_HEADER));


                GNEntry = WmipFindGuidNotification(&LoggerInfo->Wnode.Guid);

                if (GNEntry != NULL)
                {
                    WmipEnterPMCritSection();
                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        if ((GNEntry->Notifyee[i].DeliveryInfo != NULL) &&
                            (! WmipIsNotifyeePendingClose(&(GNEntry->Notifyee[i]))))
                        {
                            //
                            // TODO: We expect only one entry here. Restrict at registration.
                            //
                            DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                            DeliveryContext1 = GNEntry->Notifyee[i].DeliveryContext;
                            break;
                        }
                    }
                    WmipLeavePMCritSection();
                    WmipDereferenceGNEntry(GNEntry);
                }
                
                if (DeliveryInfo != NULL)
                {
                    LoggerInfo->Wnode.CountLost = Wnode->CountLost;
                    WmipProcessUMRequest(LoggerInfo, DeliveryInfo, Wnode->Version);
                }
                break;
            }
            default:
            {
#if DBG
                SetLastError(ERROR_WMI_DP_FAILED);
                WmipDebugPrint(("WMI: WmiMBRequest failed. Delivery Info not found\n" ));
#endif
            }
        }
    } else if (IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_ADDED_NOTIFICATION) ||
               IsEqualGUID(&Wnode->Guid, &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION) )
    {
        switch (ActionCode)
        {
            case MOFEVENT_ACTION_IMAGE_PATH:
            case MOFEVENT_ACTION_REGISTRY_PATH:
            {
                //
                // We got a MOF resource added or removed notification. We have
                // to convert from regpath to imagepath and then get the list
                // of MUI image paths
                //
                WmipProcessMofAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                         Callback,
                                         DeliveryContext,
                                         IsAnsi);
                break;
            }

            case MOFEVENT_ACTION_LANGUAGE_CHANGE:
            {
                //
                // This is a notification for adding or removing a language
                // from the system. We need to figure out which language is
                // coming or going and then build a list of the affected mof
                // resources and send mof added or removed notifications for
                // all mof resources
                //
                WmipProcessLanguageAddRemoveEvent((PWNODE_SINGLE_INSTANCE)Wnode,
                                          Callback,
                                          DeliveryContext,
                                          IsAnsi);
                break;
            }


            default:
            {
                WmipAssert(FALSE);
            }
        }
    }
}

void WmipConvertEventToAnsi(
    PWNODE_HEADER Wnode
    )
{
    PWCHAR WPtr;

    if (Wnode->Flags & WNODE_FLAG_ALL_DATA)
    {
        WmipConvertWADToAnsi((PWNODE_ALL_DATA)Wnode);
    } else if ((Wnode->Flags & WNODE_FLAG_SINGLE_INSTANCE) ||
               (Wnode->Flags & WNODE_FLAG_SINGLE_ITEM)) {

        WPtr = (PWCHAR)OffsetToPtr(Wnode,
                           ((PWNODE_SINGLE_INSTANCE)Wnode)->OffsetInstanceName);
        WmipCountedUnicodeToCountedAnsi(WPtr, (PCHAR)WPtr);
    }

    Wnode->Flags |= WNODE_FLAG_ANSI_INSTANCENAMES;

}

void WmipDeliverAllEvents(
    PUCHAR Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Linkage = 1;
    ULONG CompositeFlags;
    ULONG i;
    PGUIDNOTIFICATION GNEntry;
    ULONG Flags;
    PVOID DeliveryInfo;
    ULONG_PTR DeliveryContext;
    ULONG WnodeSize;
    ULONG CurrentOffset;
#if DBG
    PWNODE_HEADER LastWnode;
#endif          
    
    CurrentOffset = 0;
    while (Linkage != 0)
    {
        //
        // External notifications are handled here

        Linkage = Wnode->Linkage;
        Wnode->Linkage = 0;

        if (Wnode->Flags & WNODE_FLAG_INTERNAL)
        {
            //
            // This is an internal event, which is really a callback
            // from kernel mode
            //
            WmipInternalNotification(Wnode,
                                    NULL,
                                    0,
                                    FALSE);
        } else {        
            //
            // This is a plain old event, figure out who owns it and'
            // go deliver it
            //
            GNEntry = WmipFindGuidNotification(&Wnode->Guid);
            if (GNEntry != NULL)
            {
                CompositeFlags = 0;

                WnodeSize = Wnode->BufferSize;

                for (i = 0; i < GNEntry->NotifyeeCount; i++)
                {
                    WmipEnterPMCritSection();
                    Flags = GNEntry->Notifyee[i].Flags;
                    DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                    DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                    WmipLeavePMCritSection();
                    if ((DeliveryInfo != NULL) &&
                        ((Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == 0) &&
                          ((Flags & DCREF_FLAG_ANSI) == 0))
                    {
                        WmipProcessExternalEvent(Wnode,
                                                WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                    }
                    CompositeFlags |= Flags;
                }

                //
                // If there is any demand for ANSI events then convert
                // event to ansi and send it off
                if (CompositeFlags & DCREF_FLAG_ANSI)
                {
                    //
                    // Caller wants ansi notification - convert
                    // instance names
                    //
                    WmipConvertEventToAnsi(Wnode);

                    for (i = 0; i < GNEntry->NotifyeeCount; i++)
                    {
                        WmipEnterPMCritSection();
                        Flags = GNEntry->Notifyee[i].Flags;
                        DeliveryInfo = GNEntry->Notifyee[i].DeliveryInfo;
                        DeliveryContext = GNEntry->Notifyee[i].DeliveryContext;
                        WmipLeavePMCritSection();
                        if ((DeliveryInfo != NULL) &&
                            ((Flags & NOTIFICATION_FLAG_PENDING_CLOSE) == 0) &&
                            (Flags & DCREF_FLAG_ANSI))
                        {
                            WmipProcessExternalEvent(Wnode,
                                                     WnodeSize,
                                                     DeliveryInfo,
                                                     DeliveryContext,
                                                     Flags);
                        }
                    }
                }
                WmipDereferenceGNEntry(GNEntry);
            }
        }

#if DBG
        LastWnode = Wnode;
#endif
        Wnode = (PWNODE_HEADER)OffsetToPtr(Wnode, Linkage);
        CurrentOffset += Linkage;
        
        if (CurrentOffset >= BufferSize)
        {
            WmipDebugPrint(("WMI: Invalid linkage field 0x%x in WNODE %p. Buffer %p, Length 0x%x\n",
                            Linkage, LastWnode, Buffer, BufferSize));
            Linkage = 0;
        }
    }
}

LIST_ENTRY WmipGNHead = {&WmipGNHead, &WmipGNHead};
PLIST_ENTRY WmipGNHeadPtr = &WmipGNHead;

BOOLEAN
WmipDereferenceGNEntry(
    PGUIDNOTIFICATION GNEntry
    )
{
    ULONG RefCount;
    BOOLEAN IsFreed;
#if DBG
    ULONG i;
#endif

    WmipEnterPMCritSection();
    RefCount = InterlockedDecrement(&GNEntry->RefCount);
    if (RefCount == 0)
    {
        RemoveEntryList(&GNEntry->GNList);
        WmipLeavePMCritSection();
#if DBG
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            WmipAssert(GNEntry->Notifyee[i].DeliveryInfo == NULL);
        }
#endif
        if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
        {
            WmipFree(GNEntry->Notifyee);
        }

        WmipFreeGNEntry(GNEntry);
        IsFreed = TRUE;
    } else {
        IsFreed = FALSE;
        WmipLeavePMCritSection();
    }
    return(IsFreed);
}

PGUIDNOTIFICATION
WmipFindGuidNotification(
    LPGUID Guid
    )
{
    PLIST_ENTRY GNList;
    PGUIDNOTIFICATION GNEntry;

    WmipEnterPMCritSection();
    GNList = WmipGNHead.Flink;
    while (GNList != &WmipGNHead)
    {
        GNEntry = (PGUIDNOTIFICATION)CONTAINING_RECORD(GNList,
                                    GUIDNOTIFICATION,
                                    GNList);

        if (IsEqualGUID(Guid, &GNEntry->Guid))
        {
            WmipAssert(GNEntry->RefCount > 0);
            WmipReferenceGNEntry(GNEntry);
            WmipLeavePMCritSection();
            return(GNEntry);
        }
        GNList = GNList->Flink;
    }
    WmipLeavePMCritSection();
    return(NULL);
}

ULONG
WmipAddToGNList(
    LPGUID Guid,
    PVOID DeliveryInfo,
    ULONG_PTR DeliveryContext,
    ULONG Flags,
    HANDLE GuidHandle
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG NewCount;
    PNOTIFYEE NewNotifyee;
    BOOLEAN AllFull;
    ULONG EmptySlot;
    ULONG i;
#if DBG
    CHAR s[MAX_PATH];
#endif

    WmipEnterPMCritSection();
    GNEntry = WmipFindGuidNotification(Guid);

    if (GNEntry == NULL)
    {
        GNEntry = WmipAllocGNEntry();
        if (GNEntry == NULL)
        {
            WmipLeavePMCritSection();
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        memset(GNEntry, 0, sizeof(GUIDNOTIFICATION));

        GNEntry->Guid = *Guid;
        GNEntry->RefCount = 1;
        GNEntry->NotifyeeCount = STATIC_NOTIFYEE_COUNT;
        GNEntry->Notifyee = GNEntry->StaticNotifyee;
        InsertHeadList(&WmipGNHead, &GNEntry->GNList);
    }

    //
    // We have got a GUIDNOTIFICATION by newly allocating one or by finding
    // an existing one.
    AllFull = TRUE;
    for (i = 0; i < GNEntry->NotifyeeCount; i++)
    {
        if ((GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo) &&
            (! WmipIsNotifyeePendingClose(&GNEntry->Notifyee[i])))
        {
            WmipDebugPrint(("WMI: Duplicate Notification Enable for guid %s, 0x%x\n",
                             GuidToStringA(s, Guid), DeliveryInfo));
            WmipLeavePMCritSection();
            WmipDereferenceGNEntry(GNEntry);
            return(ERROR_WMI_ALREADY_ENABLED);
        } else if (AllFull && (GNEntry->Notifyee[i].DeliveryInfo == NULL)) {
            EmptySlot = i;
            AllFull = FALSE;
        }
    }

    if (! AllFull)
    {
        GNEntry->Notifyee[EmptySlot].DeliveryInfo = DeliveryInfo;
        GNEntry->Notifyee[EmptySlot].DeliveryContext = DeliveryContext;
        GNEntry->Notifyee[EmptySlot].Flags = Flags;
        GNEntry->Notifyee[EmptySlot].GuidHandle = GuidHandle;
        WmipDebugPrint(("WMI: [%x - %x] Handle %x for %s added to GN at %p\n",
                        GetCurrentProcessId(), GetCurrentThreadId(),
                        GuidHandle,
                        GuidToStringA(s, Guid),
                        &GNEntry->Notifyee[EmptySlot]));
        WmipLeavePMCritSection();
        return(ERROR_SUCCESS);
    }

    //
    // All Notifyee structs are full so allocate a new chunk
    NewCount = GNEntry->NotifyeeCount * 2;
    NewNotifyee = WmipAlloc(NewCount * sizeof(NOTIFYEE));
    if (NewNotifyee == NULL)
    {
        WmipLeavePMCritSection();
        WmipDereferenceGNEntry(GNEntry);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    memset(NewNotifyee, 0, NewCount * sizeof(NOTIFYEE));
    memcpy(NewNotifyee, GNEntry->Notifyee,
                              GNEntry->NotifyeeCount * sizeof(NOTIFYEE));

    if (GNEntry->NotifyeeCount != STATIC_NOTIFYEE_COUNT)
    {
        WmipFree(GNEntry->Notifyee);
    }

    GNEntry->Notifyee = NewNotifyee;
    GNEntry->NotifyeeCount = NewCount;

    GNEntry->Notifyee[i].DeliveryInfo = DeliveryInfo;
    GNEntry->Notifyee[i].DeliveryContext = DeliveryContext;
    GNEntry->Notifyee[i].Flags = Flags;
    GNEntry->Notifyee[i].GuidHandle = GuidHandle;
    WmipDebugPrint(("WMI: [%x - %x] Handle %x for %s added to GN at %p\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    GuidHandle,
                    GuidToStringA(s, Guid),
                    &GNEntry->Notifyee[i]));
    WmipLeavePMCritSection();
    return(ERROR_SUCCESS);

}

BOOLEAN WmipCloseNotifyee(
    PNOTIFYEE Notifyee,
    PGUIDNOTIFICATION GuidNotification
    )
{
    //
    // This routine assumes the PM Criticial Section is held
    //
    
    WmipDebugPrint(("WMI: [%x - %x] Handle %x Closed at %p\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    Notifyee->GuidHandle,
                    Notifyee));
        
    CloseHandle(Notifyee->GuidHandle);
    Notifyee->DeliveryInfo = NULL;
    Notifyee->Flags = 0;
    
    return(WmipDereferenceGNEntry(GuidNotification));
}

void WmipMarkPendingCloseNotifyee(
    PNOTIFYEE Notifyee
#if DBG
    , LPGUID Guid
#endif
    )
{
    WMIMARKASCLOSED MarkAsClosed;
    ULONG ReturnSize;
    NTSTATUS Status;
#if DBG
    char s[MAX_PATH];
#endif

    //
    // This routine assumes the PM Critical Section is held
    //
    
    //
    // The pump thread is running we need to
    // sync with it. Mark the handle as pending
    // closure.  Call into the kernel and inform it
    // that the handle should no longer receive
    // events. The pump thread will do the dirty
    // work of closing the handle. Also
    // the pump thread will unreference the GNEntry so that
    // it doesn't go away until after the handle is closed.
    // Lastly the pump thread needs to reset the
    // DeliveryInfo memory to NULL so that the slot is not
    // reused.
    //

    WmipDebugPrint(("WMI: [%x - %x] Handle %x for %s marked for close GN at %p\n",
                    GetCurrentProcessId(), GetCurrentThreadId(),
                    Notifyee->GuidHandle,
                    GuidToStringA(s, Guid),
                    Notifyee));
    Notifyee->Flags |= NOTIFICATION_FLAG_PENDING_CLOSE;

    WmipSetHandle3264(MarkAsClosed.Handle, Notifyee->GuidHandle);                       
    Status = WmipSendWmiKMRequest(NULL,
                         IOCTL_WMI_MARK_HANDLE_AS_CLOSED,
                         &MarkAsClosed,
                         sizeof(MarkAsClosed),
                         NULL,
                         0,
                         &ReturnSize,
                         NULL);
//  
// Only enable this for testing. If the request fails then it is not a
// fatal situaion
//
//    WmipAssert(Status == ERROR_SUCCESS);
}

ULONG
WmipRemoveFromGNList(
    LPGUID Guid,
    PVOID DeliveryInfo
    )
{
    PGUIDNOTIFICATION GNEntry;
    ULONG i;
    ULONG Count;
    ULONG Status;

    GNEntry = WmipFindGuidNotification(Guid);

    if (GNEntry != NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        Count = 0;

        WmipEnterPMCritSection();
        for (i = 0; i < GNEntry->NotifyeeCount; i++)
        {
            if (GNEntry->Notifyee[i].DeliveryInfo != NULL)
            {
                if ((GNEntry->Notifyee[i].DeliveryInfo == DeliveryInfo) &&
                    ( ! WmipIsNotifyeePendingClose(&GNEntry->Notifyee[i])) &&
                    (Status != ERROR_SUCCESS))
                {
                    if ((WmipPumpState == EVENT_PUMP_ZERO) ||
                        (WmipPumpState == EVENT_PUMP_IDLE) )
                    {
                        //
                        // If the pump thread is not running then we
                        // don't need to worry about synchronizing with
                        // it. We can go ahead and close the handle and
                        // clean up the GNLIST
                        //
                        WmipCloseNotifyee(&GNEntry->Notifyee[i],
                                         GNEntry);
                    } else {
                        //
                        // Since the pump thread is running we need to
                        // postpone the actual handle closure to the
                        // pump thread. 
                        //
                        WmipMarkPendingCloseNotifyee(&GNEntry->Notifyee[i]
#if DBG
                                                    , Guid
#endif
                            );
                    }

                    Status = ERROR_SUCCESS;
                    break;
                } else if (! WmipIsNotifyeePendingClose(&GNEntry->Notifyee[i])) {
                    Count++;
                }
            }
        }
        

        //
        // This hack will allow removal from the GNLIST in the case that the
        // passed DeliveryInfo does not match the DeliveryInfo in the GNEntry.
        // This is allowed only when there is only one NOTIFYEE in the GNENTRY
        // In the past we only supported one notifyee per guid in a process
        // and so we allowed the caller not to pass a valid DeliveryInfo when
        // unrefistering.

        if ((Status != ERROR_SUCCESS) &&
            (GNEntry->NotifyeeCount == STATIC_NOTIFYEE_COUNT) &&
            (Count == 1))
        {
            if ((GNEntry->Notifyee[0].DeliveryInfo != NULL) &&
                ( ! WmipIsNotifyeePendingClose(&GNEntry->Notifyee[0])))
            {
                if ((WmipPumpState == EVENT_PUMP_ZERO) ||
                    (WmipPumpState == EVENT_PUMP_IDLE) )
                {
                    WmipCloseNotifyee(&GNEntry->Notifyee[0],
                                     GNEntry);
                } else {
                    //
                    // Since the pump thread is running we need to
                    // postpone the actual handle closure to the
                    // pump thread. 
                    //
                    WmipMarkPendingCloseNotifyee(&GNEntry->Notifyee[0]
#if DBG
                                                    , Guid
#endif
                                                );
                }
                
                Status = ERROR_SUCCESS;
                
            } else if ((GNEntry->Notifyee[1].DeliveryInfo != NULL) &&
                ( ! WmipIsNotifyeePendingClose(&GNEntry->Notifyee[1]))) {
                if ((WmipPumpState == EVENT_PUMP_ZERO) ||
                    (WmipPumpState == EVENT_PUMP_IDLE) )
                {
                    WmipCloseNotifyee(&GNEntry->Notifyee[1],
                                     GNEntry);
                } else {
                    //
                    // Since the pump thread is running we need to
                    // postpone the actual handle closure to the
                    // pump thread. 
                    //
                    WmipMarkPendingCloseNotifyee(&GNEntry->Notifyee[1]
#if DBG
                                                    , Guid
#endif
                                                );
                }
                
                Status = ERROR_SUCCESS;
            }
        }

        WmipLeavePMCritSection();
        WmipDereferenceGNEntry(GNEntry);
    } else {
        Status = ERROR_WMI_ALREADY_DISABLED;
    }

    return(Status);
}

PVOID WmipAllocDontFail(
    ULONG SizeNeeded,
    BOOLEAN *HoldCritSect
    )
{
    PVOID Buffer;

    do
    {
        Buffer = WmipAlloc(SizeNeeded);
        if (Buffer != NULL)
        {
            return(Buffer);
        }

        //
        // Out of memory so we'll sleep and hope that things will get
        // better later
        //
        if (*HoldCritSect)
        {
            //
            // If we are holding the PM critical section then we need
            // to release it. The caller is going to need to check if
            // the critical section was released and if so then deal
            // with it
            //
            *HoldCritSect = FALSE;
            WmipLeavePMCritSection();
        }
        Sleep(250);
    } while (1);
}

void WmipProcessEventBuffer(
    PUCHAR Buffer,
    ULONG ReturnSize,
    PUCHAR *PrimaryBuffer,
    ULONG *PrimaryBufferSize,
    PUCHAR *BackupBuffer,
    ULONG *BackupBufferSize,
    BOOLEAN ReallocateBuffers
    )
{
    PWNODE_TOO_SMALL WnodeTooSmall;
    ULONG SizeNeeded;
    BOOLEAN HoldCritSection;

    WnodeTooSmall = (PWNODE_TOO_SMALL)Buffer;
    if ((ReturnSize == sizeof(WNODE_TOO_SMALL)) &&
        (WnodeTooSmall->WnodeHeader.Flags & WNODE_FLAG_TOO_SMALL))
    {
        //
        // The buffer passed to kernel mode was too small
        // so we need to make it larger and then try the
        // request again.
        //
        if (ReallocateBuffers)
        {
            //
            // Only do this if the caller is prepared for us to
            // allocate a new set of buffers
            //
            SizeNeeded = WnodeTooSmall->SizeNeeded;

            WmipAssert(*PrimaryBuffer != NULL);
            WmipFree(*PrimaryBuffer);
            WmipDebugPrint(("WMI: [%x - %x] Free primary %x\n",
                            GetCurrentProcessId(), GetCurrentThreadId(),
                            *PrimaryBuffer));
            HoldCritSection = FALSE;
            *PrimaryBuffer = WmipAllocDontFail(SizeNeeded, &HoldCritSection);
            WmipDebugPrint(("WMI: [%x - %x] Realloc primary %x\n",
                            GetCurrentProcessId(), GetCurrentThreadId(),
                            *PrimaryBuffer));
            *PrimaryBufferSize = SizeNeeded;

            WmipAssert(*BackupBuffer != NULL);
            WmipFree(*BackupBuffer);
            WmipDebugPrint(("WMI: [%x - %x] Free backup %x\n",
                            GetCurrentProcessId(), GetCurrentThreadId(),
                            *BackupBuffer));
            HoldCritSection = FALSE;
            *BackupBuffer = WmipAllocDontFail(SizeNeeded, &HoldCritSection);
            WmipDebugPrint(("WMI: [%x - %x] Realloc backup %x\n",
                            GetCurrentProcessId(), GetCurrentThreadId(),
                            *BackupBuffer));
            *BackupBufferSize = SizeNeeded;
        }
    } else if (ReturnSize >= sizeof(WNODE_HEADER)) {
        //
        // The buffer return from kernel looks good so go and
        // deliver the events returned
        //
        WmipDeliverAllEvents(Buffer, ReturnSize);
    } else {
        //
        // If this completes successfully then we expect a decent size, but
        // we didn't get one
        //
        WmipDebugPrint(("WMI: Bad size 0x%x returned for notification query %p\n",
                                  ReturnSize, Buffer));

        WmipAssert(FALSE);
    }
}


ULONG
WmipReceiveNotifications(
    IN ULONG HandleCount,
    IN HANDLE *HandleList,
    IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext,
    IN BOOLEAN IsAnsi,
    IN ULONG Action,
    IN PUSER_THREAD_START_ROUTINE UserModeCallback,
    IN HANDLE ProcessHandle
    )
{
    ULONG Status;
    ULONG ReturnSize;
    PWMIRECEIVENOTIFICATION RcvNotification;
    ULONG RcvNotificationSize;
    PUCHAR Buffer;
    ULONG BufferSize;
    PWNODE_TOO_SMALL WnodeTooSmall;
    PWNODE_HEADER Wnode;
    ULONG i;
    ULONG Linkage;

    if (HandleCount == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(ERROR_INVALID_PARAMETER);
    }

    RcvNotificationSize = sizeof(WMIRECEIVENOTIFICATION) +
                          ((HandleCount-1) * sizeof(HANDLE3264));

    RcvNotification = WmipAlloc(RcvNotificationSize);

    if (RcvNotification != NULL)
    {

        Status = ERROR_SUCCESS;
        RcvNotification->Action = Action;
        WmipSetPVoid3264(RcvNotification->UserModeCallback, UserModeCallback);
        WmipSetHandle3264(RcvNotification->UserModeProcess, ProcessHandle);
        RcvNotification->HandleCount = HandleCount;
        for (i = 0; i < HandleCount; i++)
        {
            try
            {
                RcvNotification->Handles[i].Handle = HandleList[i];
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = ERROR_INVALI