mode,
                (PVOID *)(&KeyBody),
                NULL
                );
    if (NT_SUCCESS(status)) {
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistryExclusive();
        //
        // no edits, on keys marked for deletion
        //
        if (KeyBody->KeyControlBlock->Delete) {
            status = STATUS_KEY_DELETED;
        } else if ( KeyBody->KeyControlBlock->KeyCell != KeyBody->KeyControlBlock->KeyHive->BaseBlock->RootCell ) {
            status = STATUS_INVALID_PARAMETER;
        } else {
            status = CmCompressKey(KeyBody->KeyControlBlock->KeyHive);
        }

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);
    }


    return status;
}

NTSTATUS
NtLockRegistryKey(
    __in HANDLE           KeyHandle
    )

/*++

Routine Description:

    Locks the specified registry key for writing

Arguments:

    KeyHandle - Handle of the key to be locked.

Return Value:

    NTSTATUS

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS        status;
    PCM_KEY_BODY    KeyBody;

    CM_PAGED_CODE();

    PreviousMode = KeGetPreviousMode();

    if ( (PreviousMode != KernelMode) || 
         !SeSinglePrivilegeCheck(SeLockMemoryPrivilege, PreviousMode)) {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    status = ObReferenceObjectByHandle(
                KeyHandle,
                KEY_WRITE,
                CmpKeyObjectType,
                PreviousMode,
                (PVOID *)(&KeyBody),
                NULL
                );

    if (NT_SUCCESS(status)) {
        //
        // we only need shared access
        //
        BEGIN_LOCK_CHECKPOINT;
        CmpLockRegistry();

        status = CmLockKcbForWrite(KeyBody->KeyControlBlock);

        CmpUnlockRegistry();
        END_LOCK_CHECKPOINT;

        ObDereferenceObject((PVOID)KeyBody);

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\dbgk\dbgkport.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dbgkport.c

Abstract:

    This module implements the dbg primitives to access a process'
    DebugPort and ExceptionPort.

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSendApiMessage)
#pragma alloc_text(PAGE, DbgkForwardException)
#pragma alloc_text(PAGE, DbgkpSendApiMessageLpc)
#endif


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    PEPROCESS Process;

    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    Process = PsGetCurrentProcess();

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = DbgkpQueueMessage (Process, PsGetCurrentThread (), ApiMsg, 0, NULL);

    ZwFlushInstructionCache (NtCurrentProcess (), NULL, 0);
    if ( SuspendProcess ) {
        DbgkpResumeProcess();
    }

    return st;
}

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    Port - Supplies the address of a port to send the api message.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    ULONG_PTR MessageBuffer[PORT_TOTAL_MAXIMUM_MESSAGE_LENGTH/sizeof (ULONG_PTR)];


    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    PS_SET_BITS (&PsGetCurrentProcess()->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = LpcRequestWaitReplyPortEx (Port,
                    (PPORT_MESSAGE) ApiMsg,
                    (PPORT_MESSAGE) &MessageBuffer[0]);

    ZwFlushInstructionCache(NtCurrentProcess(), NULL, 0);
    if (NT_SUCCESS (st)) {
        RtlCopyMemory(ApiMsg,MessageBuffer,sizeof(*ApiMsg));
    }

    if (SuspendProcess) {
        DbgkpResumeProcess();
    }

    return st;
}

DECLSPEC_NOINLINE
BOOLEAN
DbgkForwardException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN DebugException,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This function is called forward an exception to the calling process's
    debug or subsystem exception port.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    DebugException - Supplies a boolean variable that specifies whether
        this exception is to be forwarded to the process's
        DebugPort(TRUE), or to its ExceptionPort(FALSE).

Return Value:

    TRUE - The process has a DebugPort or an ExceptionPort, and the reply
        received from the port indicated that the exception was handled.

    FALSE - The process either does not have a DebugPort or
        ExceptionPort, or the process has a port, but the reply received
        from the port indicated that the exception was not handled.

--*/

{
    PEPROCESS Process;
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXCEPTION args;
    NTSTATUS st;
    BOOLEAN LpcPort;

    PAGED_CODE();

    args = &m.u.Exception;

    //
    // Initialize the debug LPC message with default information.
    //

    DBGKM_FORMAT_API_MSG(m,DbgKmExceptionApi,sizeof(*args));

    //
    // Get the address of the destination LPC port.
    //

    Process = PsGetCurrentProcess();
    if (DebugException) {
        if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
            Port = NULL;
        } else {
            Port = Process->DebugPort;
        }
        LpcPort = FALSE;
    } else {
        Port = Process->ExceptionPort;
        m.h.u2.ZeroInit = LPC_EXCEPTION;
        LpcPort = TRUE;
    }

    //
    // If the destination LPC port address is NULL, then return FALSE.
    //

    if (Port == NULL) {
        return FALSE;
    }

    //
    // Fill in the remainder of the debug LPC message.
    //

    args->ExceptionRecord = *ExceptionRecord;
    args->FirstChance = !SecondChance;

    //
    // Send the debug message to the destination LPC port.
    //

    if (LpcPort) {
        st = DbgkpSendApiMessageLpc(&m,Port,DebugException);
    } else {
        st = DbgkpSendApiMessage(&m,DebugException);
    }


    //
    // If the send was not successful, then return a FALSE indicating that
    // the port did not handle the exception. Otherwise, if the debug port
    // is specified, then look at the return status in the message.
    //

    if (!NT_SUCCESS(st) ||
        ((DebugException) &&
        (m.ReturnedStatus == DBG_EXCEPTION_NOT_HANDLED || !NT_SUCCESS(m.ReturnedStatus)))) {
        return FALSE;

    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\dbgk\dbgkproc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dbgkproc.c

Abstract:

    This module implements process control primitives for the
    Dbg component of NT

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSuspendProcess)
#pragma alloc_text(PAGE, DbgkpResumeProcess)
#pragma alloc_text(PAGE, DbgkpSectionToFileHandle)
#pragma alloc_text(PAGE, DbgkCreateThread)
#pragma alloc_text(PAGE, DbgkExitThread)
#pragma alloc_text(PAGE, DbgkExitProcess)
#pragma alloc_text(PAGE, DbgkMapViewOfSection)
#pragma alloc_text(PAGE, DbgkUnMapViewOfSection)
#endif

                 

BOOLEAN
DbgkpSuspendProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to suspend.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Freeze the execution of all threads in the current process, but the
    // calling thread. If we are in the process of being deleted don't do this.
    //
    if ((PsGetCurrentProcess()->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) == 0) {
        KeFreezeAllThreads();
        return TRUE;
    }

    return FALSE;
}

VOID
DbgkpResumeProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to resume.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    //
    // Thaw the execution of all threads in the current process, but
    // the calling thread.
    //

    KeThawAllThreads();

    return;
}

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    )

/*++

Routine Description:

    This function opens a handle to the file associated with the processes
    section. The file is opened such that it can be duplicated all the way to
    the UI where the UI can either map the file or read the file to get
    the debug info.

Arguments:

    SectionObject - Supplies the section whose associated file is to be opened.

Return Value:

    NULL - The file could not be opened.

    NON-NULL - Returns a handle to the file associated with the specified
        section.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    POBJECT_NAME_INFORMATION FileNameInfo;

    PAGED_CODE();

    Status = MmGetFileNameForSection(SectionObject, &FileNameInfo);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    }

    InitializeObjectAttributes(
        &Obja,
        &FileNameInfo->Name,
        OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    ExFreePool(FileNameInfo);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    } else {
        return Handle;
    }
}


VOID
DbgkCreateThread(
    PETHREAD Thread,
    PVOID StartAddress
    )

/*++

Routine Description:

    This function is called when a new thread begins to execute. If the
    thread has an associated DebugPort, then a message is sent thru the
    port.

    If this thread is the first thread in the process, then this event
    is translated into a CreateProcessInfo message.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    Thread - New thread just being started

    StartAddress - Supplies the start address for the thread that is
        starting.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PEPROCESS Process;
    PDBGKM_LOAD_DLL LoadDllArgs;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PIMAGE_NT_HEADERS NtHeaders;
    PTEB Teb;
    ULONG OldFlags;
#if defined(_WIN64)
    PVOID Wow64Process;
#endif

    PAGED_CODE();

    Process = PsGetCurrentProcessByThread (Thread);

#if defined(_WIN64)
    Wow64Process = Process->Wow64Process;
#endif

    OldFlags = PS_TEST_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED|PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE);

    if ((OldFlags&PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE) == 0 && PsImageNotifyEnabled) {
        IMAGE_INFO ImageInfo;
        UNICODE_STRING UnicodeFileName;
        POBJECT_NAME_INFORMATION FileNameInfo;

        //
        // notification of main .exe
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = Process->SectionBaseAddress;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (Process->SectionBaseAddress);
    
            if (NtHeaders) {
#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, SizeOfImage);
                } else {
#endif
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, SizeOfImage);
#if defined(_WIN64)
                }
#endif
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }
        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        Status = MmGetFileNameForSection (Process->SectionObject, &FileNameInfo);
        if (FileNameInfo != NULL) {
            PsCallImageNotifyRoutines (&FileNameInfo->Name,
                                       Process->UniqueProcessId,
                                       &ImageInfo);
            ExFreePool (FileNameInfo);
        } else {
            PsCallImageNotifyRoutines (NULL,
                                       Process->UniqueProcessId,
                                       &ImageInfo);
        }

        //
        // and of ntdll.dll
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = PsSystemDllBase;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (PsSystemDllBase);
            if ( NtHeaders ) {
#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, SizeOfImage);
                } else {
#endif
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, SizeOfImage);
#if defined(_WIN64)
                }
#endif
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }

        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        RtlInitUnicodeString (&UnicodeFileName,
                              L"\\SystemRoot\\System32\\ntdll.dll");
        PsCallImageNotifyRoutines (&UnicodeFileName,
                                   Process->UniqueProcessId,
                                   &ImageInfo);
    }


    Port = Process->DebugPort;

    if (Port == NULL) {
        return;
    }

    //
    // Make sure we only get one create process message
    //

    if ((OldFlags&PS_PROCESS_FLAGS_CREATE_REPORTED) == 0) {

        //
        // This is a create process
        //

        CreateThreadArgs = &m.u.CreateProcessInfo.InitialThread;
        CreateThreadArgs->SubSystemKey = 0;

        CreateProcessArgs = &m.u.CreateProcessInfo;
        CreateProcessArgs->SubSystemKey = 0;
        CreateProcessArgs->FileHandle = DbgkpSectionToFileHandle(
                                            Process->SectionObject
                                            );
        CreateProcessArgs->BaseOfImage = Process->SectionBaseAddress;
        CreateThreadArgs->StartAddress = NULL;
        CreateProcessArgs->DebugInfoFileOffset = 0;
        CreateProcessArgs->DebugInfoSize = 0;

        try {
                        
            NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);

            if ( NtHeaders ) {

#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    CreateThreadArgs->StartAddress = UlongToPtr (DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, ImageBase) +
                        DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, AddressOfEntryPoint));
                } else {
#endif
                    CreateThreadArgs->StartAddress = (PVOID) (DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, ImageBase) +
                        DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, AddressOfEntryPoint));
#if defined(_WIN64)
                }
#endif

                //
                // The following fields are safe for Wow64 as the offsets
                // are the same for a PE32+ as a PE32 header.
                //
                
                CreateProcessArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                CreateProcessArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CreateThreadArgs->StartAddress = NULL;
            CreateProcessArgs->DebugInfoFileOffset = 0;
            CreateProcessArgs->DebugInfoSize = 0;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmCreateProcessApi,sizeof(*CreateProcessArgs));

        DbgkpSendApiMessage(&m,FALSE);

        if (CreateProcessArgs->FileHandle != NULL) {
            ObCloseHandle(CreateProcessArgs->FileHandle, KernelMode);
        }

        LoadDllArgs = &m.u.LoadDll;
        LoadDllArgs->BaseOfDll = PsSystemDllBase;
        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;
        LoadDllArgs->NamePointer = NULL;

        Teb = NULL;
        try {
            NtHeaders = RtlImageNtHeader(PsSystemDllBase);
            if ( NtHeaders ) {
                LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }

            //
            // Normaly the ntdll loaded fills in this pointer for the debug API's. We fake it here
            // as ntdll isn't loaded yet and it can't load itself.
            //

            Teb = Thread->Tcb.Teb;
            if (Teb != NULL) {
                wcsncpy (Teb->StaticUnicodeBuffer,
                         L"ntdll.dll",
                         sizeof (Teb->StaticUnicodeBuffer) / sizeof (Teb->StaticUnicodeBuffer[0]));
                Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
                LoadDllArgs->NamePointer = &Teb->NtTib.ArbitraryUserPointer;
            }
            
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LoadDllArgs->DebugInfoFileOffset = 0;
            LoadDllArgs->DebugInfoSize = 0;
            LoadDllArgs->NamePointer = NULL;
        }

        //
        // Send load dll section for NT dll !
        //

        InitializeObjectAttributes(
            &Obja,
            (PUNICODE_STRING)&PsNtDllPathName,
            OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        Status = ZwOpenFile(
                    &LoadDllArgs->FileHandle,
                    (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

        if (!NT_SUCCESS (Status)) {
            LoadDllArgs->FileHandle = NULL;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));
        DbgkpSendApiMessage(&m,TRUE);

        if (LoadDllArgs->FileHandle != NULL) {
            ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
        }

        try {
            if (Teb != NULL) {
                Teb->NtTib.ArbitraryUserPointer = NULL;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

    } else {

        CreateThreadArgs = &m.u.CreateThread;
        CreateThreadArgs->SubSystemKey = 0;
        CreateThreadArgs->StartAddress = StartAddress;

        DBGKM_FORMAT_API_MSG (m,DbgKmCreateThreadApi,sizeof(*CreateThreadArgs));

        DbgkpSendApiMessage (&m,TRUE);
    }
}

VOID
DbgkExitThread(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a new thread terminates. At this
    point, the thread will no longer execute in user-mode. No other
    exit processing has occured.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting thread.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_THREAD args;
    PEPROCESS Process;
    BOOLEAN Frozen;

    PAGED_CODE();

    Process = PsGetCurrentProcess();
    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    args = &m.u.ExitThread;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitThreadApi,sizeof(*args));

    Frozen = DbgkpSuspendProcess();

    DbgkpSendApiMessage(&m,FALSE);

    if (Frozen) {
        DbgkpResumeProcess();
    }
}

VOID
DbgkExitProcess(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a process terminates. The address
    space of the process is still intact, but no threads exist in
    the process.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting process.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_PROCESS args;
    PEPROCESS Process;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    //
    // this ensures that other timed lockers of the process will bail
    // since this call is done while holding the process lock, and lock duration
    // is controlled by debugger
    //
    KeQuerySystemTime(&Process->ExitTime);

    args = &m.u.ExitProcess;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitProcessApi,sizeof(*args));

    DbgkpSendApiMessage(&m,FALSE);

}

VOID
DbgkMapViewOfSection(
    IN PVOID SectionObject,
    IN PVOID BaseAddress,
    IN ULONG SectionOffset,
    IN ULONG_PTR ViewSize
    )

/*++

Routine Description:

    This function is called when the current process successfully
    maps a view of an image section. If the process has an associated
    debug port, then a load dll message is sent.

Arguments:

    SectionObject - Supplies a pointer to the section mapped by the
        process.

    BaseAddress - Supplies the base address of where the section is
        mapped in the current process address space.

    SectionOffset - Supplies the offset in the section where the
        process' mapped view begins.

    ViewSize - Supplies the size of the mapped view.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_LOAD_DLL LoadDllArgs;
    PEPROCESS Process;
    PIMAGE_NT_HEADERS NtHeaders;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (SectionOffset);
    UNREFERENCED_PARAMETER (ViewSize);

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    LoadDllArgs = &m.u.LoadDll;
    LoadDllArgs->FileHandle = DbgkpSectionToFileHandle(SectionObject);
    LoadDllArgs->BaseOfDll = BaseAddress;
    LoadDllArgs->DebugInfoFileOffset = 0;
    LoadDllArgs->DebugInfoSize = 0;

    //
    // The loader fills in the module name in this pointer before mapping
    // the section.  It's a very poor linkage.
    //

    LoadDllArgs->NamePointer = &NtCurrentTeb()->NtTib.ArbitraryUserPointer;

    try {

        NtHeaders = RtlImageNtHeader (BaseAddress);

        if (NtHeaders != NULL) {
            LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
            LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;
        LoadDllArgs->NamePointer = NULL;

    }

    DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
    if (LoadDllArgs->FileHandle != NULL) {
        ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
    }
}

VOID
DbgkUnMapViewOfSection(
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This function is called when the current process successfully
    un maps a view of an image section. If the process has an associated
    debug port, then an "unmap view of section" message is sent.

Arguments:

    BaseAddress - Supplies the base address of the section being unmapped.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_UNLOAD_DLL UnloadDllArgs;

    PAGED_CODE();

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = PsGetCurrentProcess()->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    UnloadDllArgs = &m.u.UnloadDll;
    UnloadDllArgs->BaseAddress = BaseAddress;

    DBGKM_FORMAT_API_MSG(m,DbgKmUnloadDllApi,sizeof(*UnloadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\callback.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    callback.c

Abstract:

   This module implements the executive callback object. Functions are
   provided to open, register, unregister , and notify callback objects.

Revision History:

    Added low overhead callbacks for critical components like thread/registry etc.
    These routines have a high probability of not requiring any locks for an
    individual call.

--*/


#include "exp.h"

//
// Callback Specific Access Rights.
//

#define CALLBACK_MODIFY_STATE    0x0001

#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                             CALLBACK_MODIFY_STATE )



//
// Event to wait for registration to become idle
//

KEVENT ExpCallbackEvent;


//
// Lock used when fast referencing fails.
//
EX_PUSH_LOCK ExpCallBackFlush;

//
// Debug flag to force certain code paths. Let it get optimized away on free builds.
//
#if DBG

BOOLEAN ExpCallBackReturnRefs = FALSE;

#else

const
BOOLEAN ExpCallBackReturnRefs = FALSE;

#endif

//
// Address of callback object type descriptor.
//

POBJECT_TYPE ExCallbackObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for callback objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpCallbackMapping = {
    STANDARD_RIGHTS_READ ,
    STANDARD_RIGHTS_WRITE | CALLBACK_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    CALLBACK_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Executive callback object structure definition.
//

typedef struct _CALLBACK_OBJECT {
    ULONG               Signature;
    KSPIN_LOCK          Lock;
    LIST_ENTRY          RegisteredCallbacks;
    BOOLEAN             AllowMultipleCallbacks;
    UCHAR               reserved[3];
} CALLBACK_OBJECT , *PCALLBACK_OBJECT;

//
// Executive callback registration structure definition.
//

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY          Link;
    PCALLBACK_OBJECT    CallbackObject;
    PCALLBACK_FUNCTION  CallbackFunction;
    PVOID               CallbackContext;
    ULONG               Busy;
    BOOLEAN             UnregisterWaiting;
} CALLBACK_REGISTRATION , *PCALLBACK_REGISTRATION;


VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpInitializeCallbacks)
#pragma alloc_text(PAGE, ExCreateCallback)
#pragma alloc_text(PAGE, ExpDeleteCallback)
#pragma alloc_text(PAGE, ExInitializeCallBack)
#pragma alloc_text(PAGE, ExCompareExchangeCallBack)
#pragma alloc_text(PAGE, ExCallCallBack)
#pragma alloc_text(PAGE, ExFreeCallBack)
#pragma alloc_text(PAGE, ExAllocateCallBack)
#pragma alloc_text(PAGE, ExReferenceCallBackBlock)
#pragma alloc_text(PAGE, ExGetCallBackBlockRoutine)
#pragma alloc_text(PAGE, ExWaitForCallBacks)
#pragma alloc_text(PAGE, ExGetCallBackBlockContext)
#pragma alloc_text(PAGE, ExDereferenceCallBackBlock)
#endif

BOOLEAN
ExpInitializeCallbacks (
    )

/*++

Routine Description:

    This function creates the callback object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the timer object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    UNICODE_STRING unicodeString;
    ULONG           i;
    HANDLE          handle;

    //
    // Initialize the slow referencing lock
    //
    ExInitializePushLock (&ExpCallBackFlush);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&unicodeString, L"Callback");

    //
    // Create timer object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpCallbackMapping;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteCallback;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.ValidAccessMask = CALLBACK_ALL_ACCESS;
    Status = ObCreateObjectType(&unicodeString,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExCallbackObjectType);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    RtlInitUnicodeString( &unicodeString, ExpWstrCallback );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        SePublicDefaultSd
        );

    Status = NtCreateDirectoryObject(
                &handle,
                DIRECTORY_ALL_ACCESS,
                &ObjectAttributes
            );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    NtClose (handle);

    //
    // Initialize event to wait on for Unregisters which occur while
    // notifications are in progress
    //

    KeInitializeEvent (&ExpCallbackEvent, NotificationEvent, 0);

    //
    // Initialize NT global callbacks
    //

    for (i=0; ExpInitializeCallback[i].CallBackObject; i++) {

        //
        // Create named calledback
        //

        RtlInitUnicodeString(&unicodeString, ExpInitializeCallback[i].CallbackName);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &unicodeString,
            OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        Status = ExCreateCallback (
                        ExpInitializeCallback[i].CallBackObject,
                        &ObjectAttributes,
                        TRUE,
                        TRUE
                        );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    return TRUE;
}

NTSTATUS
ExCreateCallback (
    __deref_out PCALLBACK_OBJECT * CallbackObject,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN Create,
    __in BOOLEAN AllowMultipleCallbacks
    )

/*++

Routine Description:

    This function opens a callback object with the specified callback
    object. If the callback object does not exist or it is a NULL then
    a callback object will be created if create is TRUE. If a callbackobject
    is created it will only support multiple registered callbacks if
    AllowMulitipleCallbacks is TRUE.

Arguments:

    CallbackObject - Supplies a pointer to a variable that will receive the
        Callback object.

    CallbackName  - Supplies a pointer to a object name that will receive the

    Create - Supplies a flag which indicates whether a callback object will
        be created or not .

    AllowMultipleCallbacks - Supplies a flag which indicates only support
        multiple registered callbacks.

Return Value:

    NTSTATUS.

--*/

{
    PCALLBACK_OBJECT cbObject;
    NTSTATUS Status;
    HANDLE Handle;

    PAGED_CODE();

    //
    // Initializing cbObject & Handle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    Handle = NULL;
    cbObject = NULL;

    //
    // If named callback, open handle to it
    //

    if (ObjectAttributes->ObjectName) {
        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExCallbackObjectType,
                                    KernelMode,
                                    NULL,
                                    0,   // DesiredAccess,
                                    NULL,
                                    &Handle);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    //
    // If not opened, check if callback should be created
    //

    if (!NT_SUCCESS(Status) && Create ) {

        Status = ObCreateObject(KernelMode,
                                ExCallbackObjectType,
                                ObjectAttributes,
                                KernelMode,
                                NULL,
                                sizeof(CALLBACK_OBJECT),
                                0,
                                0,
                                (PVOID *)&cbObject );

        if(NT_SUCCESS(Status)){

            //
            // Fill in structure signature
            //

            cbObject->Signature = 'llaC';

            //
            // It will support multiple registered callbacks if
            // AllowMultipleCallbacks is TRUE.
            //

            cbObject->AllowMultipleCallbacks = AllowMultipleCallbacks;

            //
            // Initialize CallbackObject queue.
            //

            InitializeListHead( &cbObject->RegisteredCallbacks );

            //
            // Initialize spinlock
            //

            KeInitializeSpinLock (&cbObject->Lock);


            //
            // Put the object in the root directory
            //

            Status = ObInsertObject (
                     cbObject,
                     NULL,
                     FILE_READ_DATA,
                     0,
                     NULL,
                     &Handle );

        }

    }

    if(NT_SUCCESS(Status)){

        //
        // Add one to callback object reference count.
        //

        Status = ObReferenceObjectByHandle (
                    Handle,
                    0,          // DesiredAccess
                    ExCallbackObjectType,
                    KernelMode,
                    &cbObject,
                    NULL
                    );

        ZwClose (Handle);
    }

    //
    // If success, returns a referenced pointer to the CallbackObject.
    //

    if (NT_SUCCESS(Status)) {
        *CallbackObject = cbObject;
    }

    return Status;
}

VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    )
{
#if !DBG
    UNREFERENCED_PARAMETER (CallbackObject);
#endif

    ASSERT (IsListEmpty(&CallbackObject->RegisteredCallbacks));
}

PVOID
ExRegisterCallback (
    __inout PCALLBACK_OBJECT   CallbackObject,
    __in PCALLBACK_FUNCTION CallbackFunction,
    __in_opt PVOID CallbackContext
    )

/*++

Routine Description:

    This routine allows a caller to register that it would like to have its
    callback Function invoked when the callback notification call occurs.

Arguments:

    CallbackObject - Supplies a pointer to a CallbackObject.

    CallbackFunction - Supplies a pointer to a function which is to
        be executed when the Callback notification occurs.

    CallbackContext - Supplies a pointer to an arbitrary data structure
        that will be passed to the function specified by the CallbackFunction
        parameter.

Return Value:

    Returns handle to callback registration.

--*/
{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    BOOLEAN                 Inserted;
    KIRQL                   OldIrql;

    ASSERT (CallbackFunction);
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Add reference to object
    //

    ObReferenceObject (CallbackObject);

    //
    // Begin by attempting to allocate storage for the CallbackRegistration.
    // one cannot be allocated, return the error status.
    //

    CallbackRegistration = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( CALLBACK_REGISTRATION ),
                                'eRBC'
                                );


    if( !CallbackRegistration ) {
       ObDereferenceObject (CallbackObject);
       return NULL;
    }


    //
    // Initialize the callback packet
    //

    CallbackRegistration->CallbackObject    = CallbackObject;
    CallbackRegistration->CallbackFunction  = CallbackFunction;
    CallbackRegistration->CallbackContext   = CallbackContext;
    CallbackRegistration->Busy              = 0;
    CallbackRegistration->UnregisterWaiting = FALSE;


    Inserted = FALSE;
    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    if( CallbackObject->AllowMultipleCallbacks ||
        IsListEmpty( &CallbackObject->RegisteredCallbacks ) ) {

       //
       // add CallbackRegistration to tail
       //


       Inserted = TRUE;
       InsertTailList( &CallbackObject->RegisteredCallbacks,
                       &CallbackRegistration->Link );
    }

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    if (!Inserted) {
       ExFreePool (CallbackRegistration);

       ObDereferenceObject (CallbackObject);

       CallbackRegistration = NULL;
    }

    return (PVOID) CallbackRegistration;
}


VOID
ExUnregisterCallback (
    __inout PVOID CbRegistration
    )

/*++

Routine Description:

    This function removes the callback registration for the callbacks
    from the list of callback object .

Arguments:

    CallbackRegistration - Pointer to device object for the file system.

Return Value:

    None.

--*/

{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    PCALLBACK_OBJECT        CallbackObject;
    KIRQL                   OldIrql;

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    CallbackRegistration = (PCALLBACK_REGISTRATION) CbRegistration;
    CallbackObject = CallbackRegistration->CallbackObject;

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // Wait for registration
    //

    while (CallbackRegistration->Busy) {

        //
        // Set waiting flag, then wait.  (not performance critical - use
        // single global event to wait for any and all unregister waits)
        //

        CallbackRegistration->UnregisterWaiting = TRUE;
        KeClearEvent (&ExpCallbackEvent);
        KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

        KeWaitForSingleObject (
            &ExpCallbackEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );

        //
        // Synchronize with callback object and recheck registration busy
        //

        KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);
    }

    //
    // Registration not busy, remove it from the callback object
    //

    RemoveEntryList (&CallbackRegistration->Link);
    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    //
    // Free memory used for CallbackRegistration
    //

    ExFreePool (CallbackRegistration);

    //
    // Remove reference count on CallbackObject
    //

    ObDereferenceObject (CallbackObject);
}

VOID
ExNotifyCallback (
    __in PCALLBACK_OBJECT     CallbackObject,
    __in_opt PVOID                Argument1,
    __in_opt PVOID                Argument2
    )

/*++

Routine Description:

    This function notifies all registered callbacks .

Arguments:

    CallbackObject - supplies a pointer to the callback object should be
            notified.

    SystemArgument1 - supplies a pointer will be passed to callback function.

    SystemArgument2 - supplies a pointer will be passed to callback function.

Return Value:

    None.

--*/

{
    PLIST_ENTRY             Link;
    PCALLBACK_REGISTRATION  CallbackRegistration;
    KIRQL                   OldIrql;

    if (CallbackObject == NULL || IsListEmpty (&CallbackObject->RegisteredCallbacks)) {
        return ;
    }

    //
    // Synchronize with callback object
    //

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // call registered callbacks at callers IRQL level
    // ( done if FIFO order of registration )
    //

    if (OldIrql == DISPATCH_LEVEL) {

        //
        // OldIrql is DISPATCH_LEVEL, just invoke all callbacks without
        // releasing the lock
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // Notify registration
            //

            CallbackRegistration->CallbackFunction(
                       CallbackRegistration->CallbackContext,
                       Argument1,
                       Argument2
                       );

        }   // next registration

    } else {

        //
        // OldIrql is < DISPATCH_LEVEL, the code being called may be pageable
        // and the callback object spinlock needs to be released around
        // each registration callback.
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink ) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // If registration is being removed, don't bother calling it
            //

            if (!CallbackRegistration->UnregisterWaiting) {

                //
                // Set registration busy
                //

                CallbackRegistration->Busy += 1;

                //
                // Release SpinLock and notify this callback
                //

                KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

                CallbackRegistration->CallbackFunction(
                           CallbackRegistration->CallbackContext,
                           Argument1,
                           Argument2
                           );

                //
                // Synchronize with CallbackObject
                //

                KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

                //
                // Remove our busy count
                //

                CallbackRegistration->Busy -= 1;

                //
                // If the registration removal is pending, kick global
                // event let unregister continue
                //

                if (CallbackRegistration->UnregisterWaiting  &&
                    CallbackRegistration->Busy == 0) {
                    KeSetEvent (&ExpCallbackEvent, 0, FALSE);
                }
            }
        }
    }


    //
    // Release callback
    //

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);
}

VOID
ExInitializeCallBack (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function initializes a low overhead callback.

Arguments:

    CallBack - Pointer to the callback structure

Return Value:

    None.

--*/
{
    ExFastRefInitialize (&CallBack->RoutineBlock, NULL);
}


PEX_CALLBACK_ROUTINE_BLOCK
ExAllocateCallBack (
    IN PEX_CALLBACK_FUNCTION Function,
    IN PVOID Context
    )
/*++

Routine Description:

    This function allocates a low overhead callback.

Arguments:

    Function - Routine to issue callbacks to
    Context  - A context value to issue

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Allocated block or NULL if allocation fails.

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK NewBlock;

    NewBlock = ExAllocatePoolWithTag (PagedPool,
                                      sizeof (EX_CALLBACK_ROUTINE_BLOCK),
                                      'brbC');
    if (NewBlock != NULL) {
        NewBlock->Function = Function;
        NewBlock->Context = Context;
        ExInitializeRundownProtection (&NewBlock->RundownProtect);
    }
    return NewBlock;
}

VOID
ExFreeCallBack (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function destroys a low overhead callback block.

Arguments:

    CallBackBlock - Call back block to destroy

Return Value:

    None.

--*/
{

    ExFreePool (CallBackBlock);
}

VOID
ExWaitForCallBacks (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function waits for all outcalls on the specified
    callback block to complete

Arguments:

    CallBackBlock - Call back block to wait for

Return Value:

    None.

--*/
{
    //
    // Wait for all active callbacks to be finished.
    //
    ExWaitForRundownProtectionRelease (&CallBackBlock->RundownProtect);
}


BOOLEAN
ExCompareExchangeCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK NewBlock,
    IN PEX_CALLBACK_ROUTINE_BLOCK OldBlock
    )
/*++

Routine Description:

    This function assigns, removes or swaps a low overhead callback function.

Arguments:

    CallBack - Callback structure to be modified

    NewBlock - New block to be installed in the callback

    OldBlock - The old block that must be there now to be replaced

Return Value:

    BOOLEAN - TRUE: The swap occured, FALSE: The swap failed

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK ReplacedBlock;

    if (NewBlock != NULL) {
        //
        // Add the additional references to the routine block
        //
        if (!ExAcquireRundownProtectionEx (&NewBlock->RundownProtect,
                                           ExFastRefGetAdditionalReferenceCount () + 1)) {
            ASSERTMSG ("Callback block is already undergoing rundown", FALSE);
            return FALSE;
        }
    }

    //
    // Attempt to replace the existing object and balance all the reference counts
    //
    OldRef = ExFastRefCompareSwapObject (&CallBack->RoutineBlock,
                                         NewBlock,
                                         OldBlock);

    ReplacedBlock = ExFastRefGetObject (OldRef);

    //
    // See if the swap occured. If it didn't undo the original references we added.
    // If it did then release remaining references on the original
    //
    if (ReplacedBlock == OldBlock) {
        PKTHREAD CurrentThread;
        //
        // We need to flush out any slow referencers at this point. We do this by
        // acquiring and releasing a lock.
        //
        if (ReplacedBlock != NULL) {
            CurrentThread = KeGetCurrentThread ();

            KeEnterCriticalRegionThread (CurrentThread);

            ExAcquireReleasePushLockExclusive (&ExpCallBackFlush);

            KeLeaveCriticalRegionThread (CurrentThread);

            ExReleaseRundownProtectionEx (&ReplacedBlock->RundownProtect,
                                          ExFastRefGetUnusedReferences (OldRef) + 1);

        }
        return TRUE;
    } else {
        //
        // The swap failed. Remove the addition references if we had added any.
        //
        if (NewBlock != NULL) {
            ExReleaseRundownProtectionEx (&NewBlock->RundownProtect,
                                          ExFastRefGetAdditionalReferenceCount () + 1);
        }
        return FALSE;
    }
}

PEX_CALLBACK_ROUTINE_BLOCK
ExReferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function takes a reference on the call back block inside the
    callback structure.

Arguments:

    CallBack - Call back to obtain the call back block from

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Referenced structure or NULL if these wasn't one

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;

    //
    // Get a reference to the callback block if we can.
    //
    OldRef = ExFastReference (&CallBack->RoutineBlock);

    //
    // If there is no callback then return
    //
    if (ExFastRefObjectNull (OldRef)) {
        return NULL;
    }
    //
    // If we didn't get a reference then use a lock to get one.
    //
    if (!ExFastRefCanBeReferenced (OldRef)) {
        PKTHREAD CurrentThread;
        CurrentThread = KeGetCurrentThread ();

        KeEnterCriticalRegionThread (CurrentThread);

        ExAcquirePushLockExclusive (&ExpCallBackFlush);

        CallBackBlock = ExFastRefGetObject (CallBack->RoutineBlock);
        if (CallBackBlock && !ExAcquireRundownProtection (&CallBackBlock->RundownProtect)) {
            CallBackBlock = NULL;
        }

        ExReleasePushLockExclusive (&ExpCallBackFlush);

        KeLeaveCriticalRegionThread (CurrentThread);

        if (CallBackBlock == NULL) {
            return NULL;
        }

    } else {
        CallBackBlock = ExFastRefGetObject (OldRef);

        //
        // If we just removed the last reference then attempt fix it up.
        //
        if (ExFastRefIsLastReference (OldRef) && !ExpCallBackReturnRefs) {
            ULONG RefsToAdd;

            RefsToAdd = ExFastRefGetAdditionalReferenceCount ();

            //
            // If we can't add the references then just give up
            //
            if (ExAcquireRundownProtectionEx (&CallBackBlock->RundownProtect,
                                              RefsToAdd)) {
                //
                // Repopulate the cached refs. If this fails we just give them back.
                //
                if (!ExFastRefAddAdditionalReferenceCounts (&CallBack->RoutineBlock,
                                                            CallBackBlock,
                                                            RefsToAdd)) {
                    ExReleaseRundownProtectionEx (&CallBackBlock->RundownProtect,
                                                  RefsToAdd);
                }
            }
        }
    }

    return CallBackBlock;
}

PEX_CALLBACK_FUNCTION
ExGetCallBackBlockRoutine (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the routine associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain routine for

Return Value:

    PEX_CALLBACK_FUNCTION - The function pointer associated with this block

--*/
{
    return CallBackBlock->Function;
}

PVOID
ExGetCallBackBlockContext (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the context associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain context for

Return Value:

    PVOID - The context associated with this block

--*/
{
    return CallBackBlock->Context;
}


VOID
ExDereferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This returns a reference previous obtained on a call back block

Arguments:

    CallBackBlock - Call back block to return reference to

Return Value:

    None

--*/
{
    if (ExpCallBackReturnRefs || !ExFastRefDereference (&CallBack->RoutineBlock, CallBackBlock)) {
        ExReleaseRundownProtection (&CallBackBlock->RundownProtect);
    }
}


NTSTATUS
ExCallCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
/*++

Routine Description:

    This function calls the callback thats inside a callback structure

Arguments:

    CallBack - Call back that needs to be called through

    Argument1 - Caller provided argument to pass on

    Argument2 - Caller provided argument to pass on

Return Value:

    NTSTATUS - Status returned by callback or STATUS_SUCCESS if theres wasn't one

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;
    NTSTATUS Status;

    CallBackBlock = ExReferenceCallBackBlock (CallBack);
    if (CallBackBlock) {
        //
        // Call the function
        //
        Status = CallBackBlock->Function (CallBackBlock->Context, Argument1, Argument2);

        ExDereferenceCallBackBlock (CallBack, CallBackBlock);
    } else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\delay.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    delay.c

Abstract:

   This module implements the executive delay execution system service.

--*/

#include "exp.h"

#pragma alloc_text(PAGE, NtDelayExecution)

NTSTATUS
NtDelayExecution (
    __in BOOLEAN Alertable,
    __in PLARGE_INTEGER DelayInterval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    DelayInterval - Supplies the absolute of relative time over which the
        delay is to occur.

Return Value:

    NTSTATUS.

--*/

{

    LARGE_INTEGER Interval;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get previous processor mode and probe delay interval address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForReadSmallStructure(DelayInterval, sizeof(LARGE_INTEGER), sizeof(ULONG));
            Interval = *DelayInterval;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {
        Interval = *DelayInterval;
    }

    //
    // Delay execution for the specified amount of time.
    //

    return KeDelayExecutionThread(PreviousMode, Alertable, &Interval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\eventpr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    eventpr.c

Abstract:

    This module implements the executive event pair object.  Functions
    are provided to create, open, waitlow, waithi, setlow, sethi,
    sethiwaitlo, setlowaithi.

--*/

#include "exp.h"

//
// Address of event pair object type descriptor.
//

POBJECT_TYPE ExEventPairObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event pair objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpEventPairMapping = {
    STANDARD_RIGHTS_READ | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    EVENT_PAIR_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#pragma alloc_text(INIT, ExpEventPairInitialization)
#pragma alloc_text(PAGE, NtCreateEventPair)
#pragma alloc_text(PAGE, NtOpenEventPair)
#pragma alloc_text(PAGE, NtWaitLowEventPair)
#pragma alloc_text(PAGE, NtWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetLowWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetHighWaitLowEventPair)
#pragma alloc_text(PAGE, NtSetHighEventPair)
#pragma alloc_text(PAGE, NtSetLowEventPair)

BOOLEAN
ExpEventPairInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the event pair object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event pair object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"EventPair");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventPairMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EEVENT_PAIR);
    ObjectTypeInitializer.ValidAccessMask = EVENT_PAIR_ALL_ACCESS;
    ObjectTypeInitializer.UseDefaultObject = TRUE;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventPairObjectType);

    //
    // If the event pair object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateEventPair (
    __out PHANDLE EventPairHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function creates an event pair object, sets it initial state,
    and opens a handle to the object with the specified desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive the
        event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes
        structure.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventPairObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(EEVENT_PAIR),
                            0,
                            0,
                            &EventPair);

    //
    // If the event pair object was successfully allocated, then
    // initialize the event pair object and attempt to insert the
    // event pair object in the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEventPair(&EventPair->KernelEventPair);
        Status = ObInsertObject((PVOID)EventPair,
                                NULL,
                                DesiredAccess,
                                0,
                                NULL,
                                &Handle);

        //
        // If the event pair object was successfully inserted in the
        // current process' handle table, then attempt to write the
        // event pair object handle value.  If the write attempt
        // fails, then do not report an error.  When the caller
        // attempts to access the handle value, an access violation
        // will occur.

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventPairHandle = Handle;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *EventPairHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEventPair (
    __out PHANDLE EventPairHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event pair object with the specified
    desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive
        the event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);

        } except (ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event pair object with the specified
    // desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventPairObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event
    // pair object handle value.  If the write attempt fails, then do
    // not report an error.  When the caller attempts to access the
    // handle value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventPairHandle = Handle;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            *EventPairHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitLowEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForLowEventPair(&EventPair->KernelEventPair,
                                       PreviousMode,
                                       FALSE,
                                       NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitHighEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForHighEventPair(&EventPair->KernelEventPair,
                                        PreviousMode,
                                        FALSE,
                                        NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowWaitHighEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair and then
    waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeSetLowWaitHighEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighWaitLowEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair and then
    waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeSetHighWaitLowEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        KeSetLowEventPair(&EventPair->KernelEventPair,
                          EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighEventPair (
    __in HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       &EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        KeSetHighEventPair(&EventPair->KernelEventPair,
                           EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\exatom.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exatom.c

Abstract:

    This file contains functions for manipulating global atom tables
    stored in kernel space.

--*/

#include "exp.h"
#pragma hdrstop

//
// Define maximum size of an atom name.
//

#define COPY_STACK_SIZE (RTL_ATOM_MAXIMUM_NAME_LENGTH * sizeof(WCHAR))

C_ASSERT(COPY_STACK_SIZE <= 1024);

//
// Define dummy global atom table address prototype.
//

PVOID
ExpDummyGetAtomTable (
    VOID
    );

#pragma alloc_text(PAGE, NtAddAtom)
#pragma alloc_text(PAGE, NtDeleteAtom)
#pragma alloc_text(PAGE, NtFindAtom)
#pragma alloc_text(PAGE, NtQueryInformationAtom)
#pragma alloc_text(PAGE, ExpDummyGetAtomTable)

//
// Define function variable that holds the address of the callout routine.
//

PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout = ExpDummyGetAtomTable;

NTSTATUS
NtAddAtom (
    __in_bcount_opt(Length) PWSTR AtomName,
    __in ULONG Length,
    __out_opt PRTL_ATOM Atom
    )

/*++

Routine Description:

    This function adds the specified atom to the global atom table.

Arguments:

    AtomName - Supplies a pointer to an unicode atom name.

    Length - Supplies the length of the atom name in bytes.

    Atom - Supplies an optional pointer to a variable that receives the atom
        value.

Return Value:

    The service status is returned as the function value.

--*/

{

    PVOID AtomTable = (ExGlobalAtomTableCallout)();
    PWSTR CapturedAtomName;
    KPROCESSOR_MODE PreviousMode;
    RTL_ATOM ReturnAtom;
    ULONG_PTR StackArray[(COPY_STACK_SIZE / sizeof(ULONG_PTR)) + 1];
    NTSTATUS Status;

    PAGED_CODE();

    //
    // If the atom table is not defined, then return access denied.
    //

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // If the atom length is too large, then return invalid parameter. 
    //

    if (Length > COPY_STACK_SIZE) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the previous mode is user, then probe and copy the arguments as
    // appropriate.
    //
    // N.B. It is known that the length is less than a page from the above
    //      check and, therefore, a small buffer probe can be used.
    //

    PreviousMode = KeGetPreviousMode();
    CapturedAtomName = AtomName;
    if (PreviousMode != KernelMode) {
        try {
            if (ARGUMENT_PRESENT(Atom)) {
                ProbeForWriteUshort(Atom);
            }
    
            if (ARGUMENT_PRESENT(AtomName)) {
                ProbeForRead(AtomName, Length, sizeof(WCHAR));
                CapturedAtomName = (PWSTR)&StackArray[0];
                RtlCopyMemory(CapturedAtomName, AtomName, Length);
                CapturedAtomName[Length / sizeof (WCHAR)] = UNICODE_NULL;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Add the specified name to the global atom table.
    //

    Status = RtlAddAtomToAtomTable(AtomTable, CapturedAtomName, &ReturnAtom);
    if ((ARGUMENT_PRESENT(Atom)) && (NT_SUCCESS(Status))) {
        if (PreviousMode != KernelMode) {
            try {
                *Atom = ReturnAtom;

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

        } else {
            *Atom = ReturnAtom;
        }
    }

    return Status;
}

NTSTATUS
NtFindAtom (
    __in_bcount_opt(Length) PWSTR AtomName,
    __in ULONG Length,
    __out_opt PRTL_ATOM Atom
    )

/*++

Routine Description:

    This function looks up the specified atom in the global atom table.

Arguments:

    AtomName - Supplies a pointer to an unicode atom name.

    Length - Supplies the length of the atom name in bytes.

    Atom - Supplies an optional pointer to a variable that receives the atom
        value.

Return Value:

    The service status is returned as the function value.

--*/

{

    PVOID AtomTable = (ExGlobalAtomTableCallout)();
    PWSTR CapturedAtomName;
    KPROCESSOR_MODE PreviousMode;
    RTL_ATOM ReturnAtom;
    ULONG_PTR StackArray[(COPY_STACK_SIZE / sizeof(ULONG_PTR)) + 1];
    NTSTATUS Status;

    PAGED_CODE();

    //
    // If the atom table is not defined, then return access denied.
    //

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // If the atom length is too large, then return invalid parameter. 
    //

    if (Length > COPY_STACK_SIZE) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the previous mode is user, then probe and copy the arguments as
    // appropriate.
    //
    // N.B. It is known that the length is less than a page from the above
    //      check and, therefore, a small buffer probe can be used.
    //

    PreviousMode = KeGetPreviousMode();
    CapturedAtomName = AtomName;
    if (PreviousMode != KernelMode) {
        try {
            if (ARGUMENT_PRESENT(Atom)) {
                ProbeForWriteUshort(Atom);
            }
    
            if (ARGUMENT_PRESENT(AtomName)) {
                ProbeForRead(AtomName, Length, sizeof(WCHAR));
                CapturedAtomName = (PWSTR)&StackArray[0];
                RtlCopyMemory(CapturedAtomName, AtomName, Length);
                CapturedAtomName[Length / sizeof (WCHAR)] = UNICODE_NULL;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Lookup the specified name in the global atom table.
    //

    Status = RtlLookupAtomInAtomTable(AtomTable, CapturedAtomName, &ReturnAtom);
    if ((ARGUMENT_PRESENT(Atom)) && (NT_SUCCESS(Status))) {
        if (PreviousMode != KernelMode) {
            try {
                *Atom = ReturnAtom;

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }

        } else {
            *Atom = ReturnAtom;
        }
    }

    return Status;
}

NTSTATUS
NtDeleteAtom (
    __in RTL_ATOM Atom
    )

/*++

Routine Description:

    This function deletes the specified atom from the global atom table.

Arguments:

    Atom - Supplies the atom identification.

Return Value:

    The deletion status is returned as the function value.

--*/

{

    PVOID AtomTable = (ExGlobalAtomTableCallout)();

    PAGED_CODE();

    //
    // If the atom table is not defined, then return access denied.
    //

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    return RtlDeleteAtomFromAtomTable(AtomTable, Atom);
}

NTSTATUS
NtQueryInformationAtom (
    __in RTL_ATOM Atom,
    __in ATOM_INFORMATION_CLASS InformationClass,
    __out_bcount(AtomInformationLength) PVOID AtomInformation,
    __in ULONG AtomInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the specified information for the specified atom.

Arguments:

    Atom - Supplies the atom identification.

    
Return Value:

--*/

{

    ULONG AtomFlags;
    PVOID AtomTable = (ExGlobalAtomTableCallout)();
    PATOM_BASIC_INFORMATION BasicInfo;
    ULONG NameLength;
    KPROCESSOR_MODE PreviousMode;
    ULONG RequiredLength;
    NTSTATUS Status;
    PATOM_TABLE_INFORMATION TableInfo;
    ULONG UsageCount;

    PAGED_CODE();

    //
    // If the atom table is not defined, then return access denied.
    //

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Query atom information.
    //

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWrite(AtomInformation, AtomInformationLength, sizeof(ULONG));
            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        RequiredLength = 0;
        switch (InformationClass) {

            //
            // Query basic atom information.
            //

        case AtomBasicInformation:
            RequiredLength = FIELD_OFFSET(ATOM_BASIC_INFORMATION, Name);
            if (AtomInformationLength < RequiredLength) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            BasicInfo = (PATOM_BASIC_INFORMATION)AtomInformation;
            UsageCount = 0;
            NameLength = AtomInformationLength - RequiredLength;
            BasicInfo->Name[ 0 ] = UNICODE_NULL;
            Status = RtlQueryAtomInAtomTable(AtomTable,
                                             Atom,
                                             &UsageCount,
                                             &AtomFlags,
                                             &BasicInfo->Name[0],
                                             &NameLength );

            if (NT_SUCCESS(Status)) {
                BasicInfo->UsageCount = (USHORT)UsageCount;
                BasicInfo->Flags = (USHORT)AtomFlags;
                BasicInfo->NameLength = (USHORT)NameLength;
                RequiredLength += NameLength + sizeof(WCHAR);
            }

            break;

            //
            // Query atom table information.
            //

        case AtomTableInformation:
            RequiredLength = FIELD_OFFSET(ATOM_TABLE_INFORMATION, Atoms);
            if (AtomInformationLength < RequiredLength) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TableInfo = (PATOM_TABLE_INFORMATION)AtomInformation;
            Status = RtlQueryAtomsInAtomTable(AtomTable,
                                              (AtomInformationLength - RequiredLength) / sizeof(RTL_ATOM),
                                              &TableInfo->NumberOfAtoms,
                                              &TableInfo->Atoms[0]);

            if (NT_SUCCESS(Status)) {
                RequiredLength += TableInfo->NumberOfAtoms * sizeof(RTL_ATOM);
            }

            break;

            //
            // Invalid information class.
            //

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
        }

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = RequiredLength;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

PVOID
ExpDummyGetAtomTable (
    VOID
    )

/*++

Routine Description:

    This function is a dummy function that is used until the win32k subsystem
    defines the atom table call back address.

Arguments:

    None.

Return Value:

    NULL.

--*/

{

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\callperf.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    callperf.c

Abstract:

   This module implements the functions necessary to collect call data.

--*/

#include "exp.h"

VOID
ExInitializeCallData (
    IN PCALL_PERFORMANCE_DATA CallData
    )

/*++

Routine Description:

    This function initializes a call performance data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        that is initialized.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize the spinlock and listheads for the call performance
    // data structure.
    //

    KeInitializeSpinLock(&CallData->SpinLock);
    for (Index = 0; Index < CALL_HASH_TABLE_SIZE; Index += 1) {
        InitializeListHead(&CallData->HashTable[Index]);
    }
}

VOID
ExRecordCallerInHashTable (
    IN PCALL_PERFORMANCE_DATA CallData,
    IN PVOID CallersAddress,
    IN PVOID CallersCaller
    )

/*++

Routine Description:

    This function records call data in the specified call performance
    data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        in which the call data is recorded.

    CallersAddress - Supplies the address of the caller of a function.

    CallersCaller - Supplies the address of the caller of a caller of
        a function.

Return Value:

    None.

--*/

{

    PCALL_HASH_ENTRY HashEntry;
    ULONG Hash;
    PCALL_HASH_ENTRY MatchEntry;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    //
    // If the initialization phase is not zero, then collect call performance
    // data.
    //

    if (InitializationPhase != 0) {

        //
        // Acquire the call performance data structure spinlock.
        //

        ExAcquireSpinLock(&CallData->SpinLock, &OldIrql);

        //
        // Lookup the callers address in call performance data hash table. If
        // the address does not exist in the table, then create a new entry.
        //

        Hash = (ULONG)((ULONG_PTR)CallersAddress ^ (ULONG_PTR)CallersCaller);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ (Hash)) & (CALL_HASH_TABLE_SIZE - 1);
        MatchEntry = NULL;
        NextEntry = CallData->HashTable[Hash].Flink;
        while (NextEntry != &CallData->HashTable[Hash]) {
            HashEntry = CONTAINING_RECORD(NextEntry,
                                          CALL_HASH_ENTRY,
                                          ListEntry);

            if ((HashEntry->CallersAddress == CallersAddress) &&
                (HashEntry->CallersCaller == CallersCaller)) {
                MatchEntry = HashEntry;
                break;
            }

            NextEntry = NextEntry->Flink;
        }

        //
        // If a matching caller address was found, then update the call site
        // statistics. Otherwise, allocate a new hash entry and initialize
        // call site statistics.
        //

        if (MatchEntry != NULL) {
            MatchEntry->CallCount += 1;

        } else {
            MatchEntry = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(CALL_HASH_ENTRY),
                                              'CdHe');

            if (MatchEntry != NULL) {
                MatchEntry->CallersAddress = CallersAddress;
                MatchEntry->CallersCaller = CallersCaller;
                MatchEntry->CallCount = 1;
                InsertTailList(&CallData->HashTable[Hash],
                               &MatchEntry->ListEntry);
            }
        }

        //
        // Release the call performance data structure spinlock.
        //

        ExReleaseSpinLock(&CallData->SpinLock, OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\event.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    event.c

Abstract:

   This module implements the executive event object. Functions are provided
   to create, open, set, reset, pulse, and query event objects.

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpEventBoost = EVENT_INCREMENT;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExEventObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpEventMapping = {
    STANDARD_RIGHTS_READ | EVENT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    EVENT_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#pragma alloc_text(INIT, ExpEventInitialization)
#pragma alloc_text(PAGE, NtClearEvent)
#pragma alloc_text(PAGE, NtCreateEvent)
#pragma alloc_text(PAGE, NtOpenEvent)
#pragma alloc_text(PAGE, NtPulseEvent)
#pragma alloc_text(PAGE, NtQueryEvent)
#pragma alloc_text(PAGE, NtResetEvent)
#pragma alloc_text(PAGE, NtSetEvent)
#pragma alloc_text(PAGE, NtSetEventBoostPriority)

BOOLEAN
ExpEventInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the event object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Event");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KEVENT);
    ObjectTypeInitializer.ValidAccessMask = EVENT_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtClearEvent (
    __in HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled and dereference event object.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        KeClearEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCreateEvent (
    __out PHANDLE EventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in EVENT_TYPE EventType,
    __in BOOLEAN InitialState
    )

/*++

Routine Description:

    This function creates an event object, sets it initial state to the
    specified value, and opens a handle to the object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    EventType - Supplies the type of the event (autoclearing or notification).

    InitialState - Supplies the initial state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((EventType != NotificationEvent) && (EventType != SynchronizationEvent)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KEVENT),
                            0,
                            0,
                            &Event);

    //
    // If the event object was successfully allocated, then initialize the
    // event object and attempt to insert the event object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEvent((PKEVENT)Event, EventType, InitialState);
        Status = ObInsertObject(Event,
                                NULL,
                                DesiredAccess,
                                0,
                                NULL,
                                &Handle);

        //
        // If the event object was successfully inserted in the current
        // process' handle table, then attempt to write the event object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventHandle = Handle;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *EventHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEvent (
    __out PHANDLE EventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event object
    // handle value. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventHandle = Handle;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            *EventHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtPulseEvent (
    __in HANDLE EventHandle,
    __out_opt PLONG PreviousState
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state, attempts to
    satisfy as many waits as possible, and then resets the state of the
    event object to Not-Signaled.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (ARGUMENT_PRESENT(PreviousState) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousState);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then pulse the event object,
    // dereference event object, and write the previous state value if
    // specified. If the write of the previous state fails, then do not
    // report an error. When the caller attempts to access the previous
    // state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KePulseEvent((PKEVENT)Event, ExpEventBoost, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryEvent (
    __in HANDLE EventHandle,
    __in EVENT_INFORMATION_CLASS EventInformationClass,
    __out_bcount(EventInformationLength) PVOID EventInformation,
    __in ULONG EventInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the state of an event object and returns the
    requested information in the specified record structure.

Arguments:

    EventHandle - Supplies a handle to an event object.

    EventInformationClass - Supplies the class of information being requested.

    EventInformation - Supplies a pointer to a record that is to receive the
        requested information.

    EventInformationLength - Supplies the length of the record that is to
        receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    PEVENT_BASIC_INFORMATION Information;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;
    EVENT_TYPE EventType;

    //
    // Check argument validity.
    //

    if (EventInformationClass != EventBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (EventInformationLength != sizeof(EVENT_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWrite(EventInformation,
                          sizeof(EVENT_BASIC_INFORMATION),
                          sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_QUERY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then read the current state of
    // the event object, deference event object, fill in the information
    // structure, and return the length of the information structure if
    // specified. If the write of the event information or the return
    // length fails, then do not report an error. When the caller accesses
    // the information structure or length an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeReadStateEvent(Event);
        EventType = Event->Header.Type;
        Information = EventInformation;
        ObDereferenceObject(Event);
        if (PreviousMode != KernelMode) {
            try {
                Information->EventType = EventType;
                Information->EventState = State;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            Information->EventType = EventType;
            Information->EventState = State;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtResetEvent (
    __in HANDLE EventHandle,
    __out_opt PLONG PreviousState
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (ARGUMENT_PRESENT(PreviousState) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousState);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled, dereference event object, and write the
    // previous state value if specified. If the write of the previous
    // state fails, then do not report an error. When the caller attempts
    // to access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KeResetEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEvent (
    __in HANDLE EventHandle,
    __out_opt PLONG PreviousState
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and attempts to
    satisfy as many waits as possible.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    try {
        if ((PreviousMode != KernelMode) && ARGUMENT_PRESENT(PreviousState)) {
            ProbeForWriteLong(PreviousState);
        }

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the event object to the
    // Signaled state, dereference event object, and write the previous
    // state value if specified. If the write of the previous state fails,
    // then do not report an error. When the caller attempts to access the
    // previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KeSetEvent((PKEVENT)Event, ExpEventBoost, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            try {
                *PreviousState = State;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEventBoostPriority (
    __in HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and performs
    a special priority boost operation.

    N.B. This service can only be performed on synchronization events.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then check the type of event object.
    // If the event object is a notification event, then return an object
    // type mismatch status. Otherwise, set the specified event and boost
    // the unwaited thread priority as appropriate.
    //

    if (NT_SUCCESS(Status)) {
        if (Event->Header.Type == NotificationEvent) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;

        } else {
            KeSetEventBoostPriority(Event, NULL);
        }

        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\handle.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    handle.c

Abstract:

    This module implements a set of functions for supporting handles.

Revision History:

    Support dynamic changes to the number of levels we use. The code
    performs the best for typical handle table sizes and scales better.

    Make the handle allocate, free and duplicate paths mostly lock free except
    for the lock entry locks, table expansion and locks to solve the A-B-A problem.

--*/

#include "exp.h"
#pragma hdrstop

//
//  Local constants and support routines
//

//
//  Define global structures that link all handle tables together except the
//  ones where the user has called RemoveHandleTable
//

#if DBG

BOOLEAN ExTraceAllTables = FALSE;

#define TRACE_ALL_TABLES ExTraceAllTables

#else

#define TRACE_ALL_TABLES FALSE

#endif

EX_PUSH_LOCK HandleTableListLock;

ULONG TotalTraceBuffers = 0;

#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGED")
#endif

LIST_ENTRY HandleTableListHead;

#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif

#if DBG
#define EXHANDLE_EXTRA_CHECKS 0
#else
#define EXHANDLE_EXTRA_CHECKS 0
#endif

#if EXHANDLE_EXTRA_CHECKS

#define EXASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#else

#define EXASSERT ASSERT

#endif

//
//  This is the sign low bit used to lock handle table entries
//

#define EXHANDLE_TABLE_ENTRY_LOCK_BIT    1

#define EX_ADDITIONAL_INFO_SIGNATURE (-2)

#define ExpIsValidObjectEntry(Entry) \
    ( (Entry != NULL) && (Entry->Object != NULL) && (Entry->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) )


#define TABLE_PAGE_SIZE PAGE_SIZE

//
// Absolute maximum number of handles allowed
//
#define MAX_HANDLES (1<<24)

#if EXHANDLE_EXTRA_CHECKS

//
// Mask for next free value from the free lists.
//
#define FREE_HANDLE_MASK ((MAX_HANDLES<<2) - 1)

#else

//
// When no checks compiled in this gets optimized away
//
#define FREE_HANDLE_MASK 0xFFFFFFFF

#endif

//
// Mask for the free list sequence number
//
#define FREE_SEQ_MASK (0xFFFFFFFF & ~FREE_HANDLE_MASK)


#if (FREE_HANDLE_MASK == 0xFFFFFFFF)
#define FREE_SEQ_INC 0
#define GetNextSeq() 0
#else
//
// Increment value to progress the sequence number
//
#define FREE_SEQ_INC  (FREE_HANDLE_MASK + 1)
ULONG CurrentSeq = 0;
#define GetNextSeq() (CurrentSeq += FREE_SEQ_INC)
#endif



#define LOWLEVEL_COUNT (TABLE_PAGE_SIZE / sizeof(HANDLE_TABLE_ENTRY))
#define MIDLEVEL_COUNT (PAGE_SIZE / sizeof(PHANDLE_TABLE_ENTRY))
#define HIGHLEVEL_COUNT  MAX_HANDLES / (LOWLEVEL_COUNT * MIDLEVEL_COUNT)

#define LOWLEVEL_THRESHOLD LOWLEVEL_COUNT
#define MIDLEVEL_THRESHOLD (MIDLEVEL_COUNT * LOWLEVEL_COUNT)
#define HIGHLEVEL_THRESHOLD (MIDLEVEL_COUNT * MIDLEVEL_COUNT * LOWLEVEL_COUNT)

#define HIGHLEVEL_SIZE (HIGHLEVEL_COUNT * sizeof (PHANDLE_TABLE_ENTRY))

#define LEVEL_CODE_MASK 3

//
//  Local support routines
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL,
    IN BOOLEAN DoInit
    );

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    );

BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    );

PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE Handle
    );

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    );

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle
    );

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    );

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    );

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    );

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    );

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    );

VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    );

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    );

VOID
ExpUpdateDebugInfo(
    PHANDLE_TABLE HandleTable,
    PETHREAD CurrentThread,
    HANDLE Handle,
    ULONG Type
    );

PVOID
ExpAllocateTablePagedPoolNoZero (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExInitializeHandleTablePackage)
#pragma alloc_text(INIT, ExSetHandleTableStrictFIFO)
#pragma alloc_text(PAGE, ExUnlockHandleTableEntry)
#pragma alloc_text(PAGE, ExCreateHandleTable)
#pragma alloc_text(PAGE, ExRemoveHandleTable)
#pragma alloc_text(PAGE, ExDestroyHandleTable)
#pragma alloc_text(PAGE, ExEnumHandleTable)
#pragma alloc_text(PAGE, ExDupHandleTable)
#pragma alloc_text(PAGE, ExSnapShotHandleTables)
#pragma alloc_text(PAGE, ExCreateHandle)
#pragma alloc_text(PAGE, ExDestroyHandle)
#pragma alloc_text(PAGE, ExChangeHandle)
#pragma alloc_text(PAGE, ExMapHandleToPointer)
#pragma alloc_text(PAGE, ExMapHandleToPointerEx)
#pragma alloc_text(PAGE, ExpAllocateHandleTable)
#pragma alloc_text(PAGE, ExpFreeHandleTable)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntry)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntrySlow)
#pragma alloc_text(PAGE, ExpFreeHandleTableEntry)
#pragma alloc_text(PAGE, ExpLookupHandleTableEntry)
#pragma alloc_text(PAGE, ExSweepHandleTable)
#pragma alloc_text(PAGE, ExpAllocateMidLevelTable)
#pragma alloc_text(PAGE, ExpAllocateTablePagedPool)
#pragma alloc_text(PAGE, ExpAllocateTablePagedPoolNoZero)
#pragma alloc_text(PAGE, ExpFreeTablePagedPool)
#pragma alloc_text(PAGE, ExpAllocateLowLevelTable)
#pragma alloc_text(PAGE, ExSetHandleInfo)
#pragma alloc_text(PAGE, ExpGetHandleInfo)
#pragma alloc_text(PAGE, ExSnapShotHandleTablesEx)
#pragma alloc_text(PAGE, ExpFreeLowLevelTable)
#pragma alloc_text(PAGE, ExpBlockOnLockedHandleEntry)
#pragma alloc_text(PAGE, ExpMoveFreeHandles)
#pragma alloc_text(PAGE, ExEnableHandleTracing)
#pragma alloc_text(PAGE, ExDereferenceHandleDebugInfo)
#pragma alloc_text(PAGE, ExReferenceHandleDebugInfo)
#pragma alloc_text(PAGE, ExpUpdateDebugInfo)
#endif

//
// Define macros to lock and unlock the handle table.
// We use this lock only for handle table expansion.
//
#define ExpLockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                   \
    ExAcquirePushLockExclusive (&xxHandleTable->HandleTableLock[0]); \
}


#define ExpUnlockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    ExReleasePushLockExclusive (&xxHandleTable->HandleTableLock[0]);   \
    KeLeaveCriticalRegionThread (xxCurrentThread);                     \
}
    
#define ExpLockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                      \
    ExAcquirePushLockShared (&xxHandleTable->HandleTableLock[xxIdx]);   \
}


#define ExpUnlockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    ExReleasePushLockShared (&xxHandleTable->HandleTableLock[xxIdx]);     \
    KeLeaveCriticalRegionThread (xxCurrentThread);                        \
}



FORCEINLINE
ULONG
ExpInterlockedExchange (
    IN OUT PULONG Index,
    IN ULONG FirstIndex,
    IN PHANDLE_TABLE_ENTRY Entry
    )
/*++

Routine Description:

    This performs the following steps:
    1. Set Entry->NextFreeTableEntry = *Index
    2. Loops until *Index == (the value of *Index when we entered the function)
       When they're equal, we set *Index = FirstIndex


Arguments:

    Index - Points to the ULONG we want to set.
    
    FirstIndex - New value to set Index to.

    Entry - TableEntry that will get the initial value of *Index before it's
            updated.

Return Value:

    New value of *Index (i.e. FirstIndex).

--*/
{
    ULONG OldIndex, NewIndex;

    EXASSERT (Entry->Object == NULL);

    //
    // Load new value and generate the sequence number on pushes
    //

    NewIndex = FirstIndex + GetNextSeq();

    while (1) {

        //
        // remember original value and
        // archive it in NextFreeTableEntry.
        //

        OldIndex = ReadForWriteAccess (Index);
        Entry->NextFreeTableEntry = OldIndex;

        
        //
        // Swap in the new value, and if the swap occurs
        // successfully, we're done.
        //
        if (OldIndex == (ULONG) InterlockedCompareExchange ((PLONG)Index,
                                                            NewIndex,
                                                            OldIndex)) {
            return OldIndex;
        }
    }
}

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    )
{
    ULONG OldValue, NewValue;
    ULONG Index, OldIndex, NewIndex, FreeSize;
    PHANDLE_TABLE_ENTRY Entry, FirstEntry;
    EXHANDLE Handle;
    ULONG Idx;
    BOOLEAN StrictFIFO;

    //
    // First remove all the handles from the free list so we can add them to the
    // list we use for allocates.
    //

    OldValue = InterlockedExchange ((PLONG)&HandleTable->LastFree,
                                    0);
    Index = OldValue;
    if (Index == 0) {
        //
        // There are no free handles.  Nothing to do.
        //
        return OldValue;
    }

       
    //
    // We are pushing old entries onto the free list.
    // We have the A-B-A problem here as these items may have been moved here because
    // another thread was using them in the pop code.
    //
    for (Idx = 1; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx]);
    }
    StrictFIFO = HandleTable->StrictFIFO;
 
    //
    // If we are strict FIFO then reverse the list to make handle reuse rare.
    //
    if (!StrictFIFO) {
        //
        // We have a complete chain here. If there is no existing chain we
        // can just push this one without any hassles. If we can't then
        // we can just fall into the reversing code anyway as we need
        // to find the end of the chain to continue it.
        //

        //
        // This is a push so create a new sequence number
        //

        if (InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                        OldValue + GetNextSeq(),
                                        0) == 0) {
            return OldValue;
        }
    }

    //
    // Loop over all the entries and reverse the chain.
    //
    FreeSize = OldIndex = 0;
    FirstEntry = NULL;
    while (1) {
        FreeSize++;
        Handle.Value = Index;
        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);

        EXASSERT (Entry->Object == NULL);

        NewIndex = Entry->NextFreeTableEntry;
        Entry->NextFreeTableEntry = OldIndex;
        if (OldIndex == 0) {
            FirstEntry = Entry;
        }
        OldIndex = Index;
        if (NewIndex == 0) {
            break;
        }
        Index = NewIndex;
    }

    NewValue = ExpInterlockedExchange (&HandleTable->FirstFree,
                                       OldIndex,
                                       FirstEntry);

    //
    // If we haven't got a pool of a few handles then force
    // table expansion to keep the free handle size high
    //
    if (FreeSize < 100 && StrictFIFO) {
        OldValue = 0;
    }
    return OldValue;
}

PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE pHandle
    )
/*++

Routine Description:

    This routine does a fast allocate of a free handle. It's lock free if
    possible.

    Only the rare case of handle table expansion is covered by the handle
    table lock.

Arguments:

    HandleTable - Supplies the handle table being allocated from.

    pHandle - Handle returned

Return Value:

    PHANDLE_TABLE_ENTRY - The allocated handle table entry pointer or NULL
                          on failure.

--*/
{
    PKTHREAD CurrentThread;
    ULONG OldValue, NewValue, NewValue1;
    PHANDLE_TABLE_ENTRY Entry;
    EXHANDLE Handle;
    BOOLEAN RetVal;
    ULONG Idx;


    CurrentThread = KeGetCurrentThread ();
    while (1) {

        OldValue = HandleTable->FirstFree;


        while (OldValue == 0) {
            //
            //  Lock the handle table for exclusive access as we will be
            //  allocating a new table level.
            //
            ExpLockHandleTableExclusive (HandleTable, CurrentThread);

            //
            // If we have multiple threads trying to expand the table at
            // the same time then by just acquiring the table lock we
            // force those threads to complete their allocations and
            // populate the free list. We must check the free list here
            // so we don't expand the list twice without needing to.
            //

            OldValue = HandleTable->FirstFree;
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // See if we have any handles on the alternate free list
            // These handles need some locking to move them over.
            //
            OldValue = ExpMoveFreeHandles (HandleTable);
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // This must be the first thread attempting expansion or all the
            // free handles allocated by another thread got used up in the gap.
            //

            RetVal = ExpAllocateHandleTableEntrySlow (HandleTable, TRUE);

            ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);


            OldValue = HandleTable->FirstFree;

            //
            // If ExpAllocateHandleTableEntrySlow had a failed allocation
            // then we want to fail the call.  We check for free entries
            // before we exit just in case they got allocated or freed by
            // somebody else in the gap.
            //

            if (!RetVal) {
                if (OldValue == 0) {
                    pHandle->GenericHandleOverlay = NULL;
                    return NULL;
                }            
            }
        }


        Handle.Value = (OldValue & FREE_HANDLE_MASK);

        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);

        Idx = ((OldValue & FREE_HANDLE_MASK)>>2) % HANDLE_TABLE_LOCKS;
        ExpLockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (OldValue != *(volatile ULONG *) &HandleTable->FirstFree) {
            ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);
            continue;
        }

        KeMemoryBarrier ();

        NewValue = *(volatile ULONG *) &Entry->NextFreeTableEntry;

        NewValue1 = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                                NewValue,
                                                OldValue);

        ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (NewValue1 == OldValue) {
            EXASSERT ((NewValue & FREE_HANDLE_MASK) < HandleTable->NextHandleNeedingPool);
            break;
        } else {
            //
            // We should have eliminated the A-B-A problem so if only the sequence number has
            // changed we are broken.
            //
            EXASSERT ((NewValue1 & FREE_HANDLE_MASK) != (OldValue & FREE_HANDLE_MASK));
        }
    }
    InterlockedIncrement (&HandleTable->HandleCount);

    *pHandle = Handle;
    
    return Entry;
}


VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )
{
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
    LONG_PTR CurrentValue;

    //
    // Queue our wait block to be signaled by a releasing thread.
    //

    ExBlockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);

    CurrentValue = HandleTableEntry->Value;
    if (CurrentValue == 0 || (CurrentValue&EXHANDLE_TABLE_ENTRY_LOCK_BIT) != 0) {
        ExUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
    } else {
        ExWaitForUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
   }
}


BOOLEAN
FORCEINLINE
ExpLockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine locks the specified handle table entry.  After the entry is
    locked the sign bit will be set.

Arguments:

    HandleTable - Supplies the handle table containing the entry being locked.

    HandleTableEntry - Supplies the handle table entry being locked.

Return Value:

    TRUE if the entry is valid and locked, and FALSE if the entry is
    marked free.

--*/

{
    LONG_PTR NewValue;
    LONG_PTR CurrentValue;

    //
    // We are about to take a lock. Make sure we are protected.
    //
    ASSERT ((KeGetCurrentThread()->CombinedApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  We'll keep on looping reading in the value, making sure it is not null,
    //  and if it is not currently locked we'll try for the lock and return
    //  true if we get it.  Otherwise we'll pause a bit and then try again.
    //


    while (TRUE) {

        CurrentValue = ReadForWriteAccess(((volatile LONG_PTR *)&HandleTableEntry->Object));

        //
        //  If the handle value is greater than zero then it is not currently
        //  locked and we should try for the lock, by setting the lock bit and
        //  doing an interlocked exchange.
        //

        if (CurrentValue & EXHANDLE_TABLE_ENTRY_LOCK_BIT) {

            //
            // Remove the
            //
            NewValue = CurrentValue - EXHANDLE_TABLE_ENTRY_LOCK_BIT;

            if ((LONG_PTR)(InterlockedCompareExchangePointer (&HandleTableEntry->Object,
                                                              (PVOID)NewValue,
                                                              (PVOID)CurrentValue)) == CurrentValue) {

                return TRUE;
            }
        } else {
            //
            //  Make sure the handle table entry is not freed
            //

            if (CurrentValue == 0) {

                return FALSE;
            }
        }
        ExpBlockOnLockedHandleEntry (HandleTable, HandleTableEntry);
    }
}


NTKERNELAPI
VOID
FORCEINLINE
ExUnlockHandleTableEntry (
    __inout PHANDLE_TABLE HandleTable,
    __inout PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine unlocks the specified handle table entry.  After the entry is
    unlocked the sign bit will be clear.

Arguments:

    HandleTable - Supplies the handle table containing the entry being unlocked.

    HandleTableEntry - Supplies the handle table entry being unlocked.

Return Value:

    None.

--*/

{
    LONG_PTR OldValue;

    PAGED_CODE();

    //
    // We are about to release a lock. Make sure we are protected from suspension.
    //
    ASSERT ((KeGetCurrentThread()->CombinedApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  This routine does not need to loop and attempt the unlock operation more
    //  than once because by definition the caller has the entry already locked
    //  and no one can be changing the value without the lock.
    //


#if defined (_WIN64)

    OldValue = InterlockedExchangeAdd64 ((PLONGLONG) &HandleTableEntry->Value, EXHANDLE_TABLE_ENTRY_LOCK_BIT);


#else

    OldValue = InterlockedOr ((LONG *) &HandleTableEntry->Value, EXHANDLE_TABLE_ENTRY_LOCK_BIT);


#endif

    EXASSERT ((OldValue&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);

    return;
}


NTKERNELAPI
VOID
ExInitializeHandleTablePackage (
    VOID
    )

/*++

Routine Description:

    This routine is called once at system initialization to setup the ex handle
    table package

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the handle table synchronization resource and list head
    //

    InitializeListHead( &HandleTableListHead );
    ExInitializePushLock( &HandleTableListLock );

    return;
}


NTKERNELAPI
PHANDLE_TABLE
ExCreateHandleTable (
    __in_opt struct _EPROCESS *Process
    )

/*++

Routine Description:

    This function allocate and initialize a new new handle table

Arguments:

    Process - Supplies an optional pointer to the process against which quota
        will be charged.

Return Value:

    If a handle table is successfully created, then the address of the
    handle table is returned as the function value. Otherwise, a value
    NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE HandleTable;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Allocate and initialize a handle table descriptor
    //

    HandleTable = ExpAllocateHandleTable( Process, TRUE );

    if (HandleTable == NULL) {
        return NULL;
    }
    //
    //  Insert the handle table in the handle table list.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive( &HandleTableListLock );

    InsertTailList( &HandleTableListHead, &HandleTable->HandleTableList );

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);


    //
    //  And return to our caller
    //

    return HandleTable;
}


NTKERNELAPI
VOID
ExRemoveHandleTable (
    __inout PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This function removes the specified exhandle table from the list of
    exhandle tables.  Used by PS and ATOM packages to make sure their handle
    tables are not in the list enumerated by the ExSnapShotHandleTables
    routine and the !handle debugger extension.

Arguments:

    HandleTable - Supplies a pointer to a handle table

Return Value:

    None.

--*/

{
    PKTHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First, acquire the global handle table lock
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive( &HandleTableListLock );

    //
    //  Remove the handle table from the handle table list.  This routine is
    //  written so that multiple calls to remove a handle table will not
    //  corrupt the system.
    //

    RemoveEntryList( &HandleTable->HandleTableList );
    InitializeListHead( &HandleTable->HandleTableList );

    //
    //  Now release the global lock and return to our caller
    //

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return;
}


NTKERNELAPI
VOID
ExDestroyHandleTable (
    __inout PHANDLE_TABLE HandleTable,
    __in EX_DESTROY_HANDLE_ROUTINE DestroyHandleProcedure OPTIONAL
    )

/*++

Routine Description:

    This function destroys the specified handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    DestroyHandleProcedure - Supplies a pointer to a function to call for each
        valid handle entry in the handle table.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    //
    //  Remove the handle table from the handle table list
    //

    ExRemoveHandleTable( HandleTable );

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.  But first test that we have
    //  call back to use
    //

    if (ARGUMENT_PRESENT(DestroyHandleProcedure)) {

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                (*DestroyHandleProcedure)( Handle.GenericHandleOverlay );
            }
        }
    }

    //
    //  Now free up the handle table memory and return to our caller
    //

    ExpFreeHandleTable( HandleTable );

    return;
}


NTKERNELAPI
VOID
ExSweepHandleTable (
    __in PHANDLE_TABLE HandleTable,
    __in EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    __in PVOID EnumParameter
    )

/*++

Routine Description:

    This function sweeps a handle table in a unsynchronized manner.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    EnumHandleProcedure - Supplies a pointer to a function to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.
    //
    Handle.Value = HANDLE_VALUE_INC;

    while ((HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL) {

        do {

            //
            //  Only do the callback if the entry is not free
            //
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                (*EnumHandleProcedure)( HandleTableEntry,
                                        Handle.GenericHandleOverlay,
                                        EnumParameter );
            }
            Handle.Value += HANDLE_VALUE_INC;
            HandleTableEntry++;
        } while ((Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC)) != 0);
        // Skip past the first entry that's not a real entry
        Handle.Value += HANDLE_VALUE_INC;
    }

    return;
}



NTKERNELAPI
BOOLEAN
ExEnumHandleTable (
    __in PHANDLE_TABLE HandleTable,
    __in EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    __in PVOID EnumParameter,
    __out_opt PHANDLE Handle
    )

/*++

Routine Description:

    This function enumerates all the valid handles in a handle table.
    For each valid handle in the handle table, the specified eumeration
    function is called. If the enumeration function returns TRUE, then
    the enumeration is stopped, the current handle is returned to the
    caller via the optional Handle parameter, and this function returns
    TRUE to indicated that the enumeration stopped at a specific handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    EnumHandleProcedure - Supplies a pointer to a function to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

    Handle - Supplies an optional pointer a variable that receives the
        Handle value that the enumeration stopped at. Contents of the
        variable only valid if this function returns TRUE.

Return Value:

    If the enumeration stopped at a specific handle, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    PKTHREAD CurrentThread;
    BOOLEAN ResultValue;
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Our initial return value is false until the enumeration callback
    //  function tells us otherwise
    //

    ResultValue = FALSE;

    //
    //  Iterate through the handle table and for each handle that is
    //  allocated we'll invoke the call back.  Note that this loop exits
    //  when we get a null handle table entry.  We know there will be no
    //  more possible entries after the first null one is encountered
    //  because we allocate memory for the handles in a dense fashion
    //

    KeEnterCriticalRegionThread (CurrentThread);

    for (LocalHandle.Value = 0; // does essentially the following "LocalHandle.Index = 0, LocalHandle.TagBits = 0;"
         (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, LocalHandle )) != NULL;
         LocalHandle.Value += HANDLE_VALUE_INC) {

        //
        //  Only do the callback if the entry is not free
        //

        if ( ExpIsValidObjectEntry( HandleTableEntry ) ) {

            //
            //  Lock the handle table entry because we're about to give
            //  it to the callback function, then release the entry
            //  right after the call back.
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                //
                //  Invoke the callback, and if it returns true then set
                //  the proper output values and break out of the loop.
                //

                ResultValue = (*EnumHandleProcedure)( HandleTableEntry,
                                                      LocalHandle.GenericHandleOverlay,
                                                      EnumParameter );

                ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

                if (ResultValue) {
                    if (ARGUMENT_PRESENT( Handle )) {

                        *Handle = LocalHandle.GenericHandleOverlay;
                    }
                    break;
                }
            }
        }
    }
    KeLeaveCriticalRegionThread (CurrentThread);


    return ResultValue;
}


NTKERNELAPI
PHANDLE_TABLE
ExDupHandleTable (
    __inout_opt struct _EPROCESS *Process,
    __in PHANDLE_TABLE OldHandleTable,
    __in EX_DUPLICATE_HANDLE_ROUTINE DupHandleProcedure,
    __in ULONG_PTR Mask
    )

/*++

Routine Description:

    This function creates a duplicate copy of the specified handle table.

Arguments:

    Process - Supplies an optional to the process to charge quota to.

    OldHandleTable - Supplies a pointer to a handle table.

    DupHandleProcedure - Supplies an optional pointer to a function to call
        for each valid handle in the duplicated handle table.

    Mask - Mask applied to the object pointer to work outif we need to duplicate

Return Value:

    If the specified handle table is successfully duplicated, then the
    address of the new handle table is returned as the function value.
    Otherwise, a value NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE NewHandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY OldHandleTableEntry;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;
    BOOLEAN FreeEntry;
    NTSTATUS Status;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First allocate a new handle table.  If this fails then
    //  return immediately to our caller
    //

    NewHandleTable = ExpAllocateHandleTable( Process, FALSE );

    if (NewHandleTable == NULL) {

        return NULL;
    }


    //
    //  Now we'll build up the new handle table. We do this by calling
    //  allocating new handle table entries, and "fooling" the worker
    //  routine to allocate keep on allocating until the next free
    //  index needing pool are equal
    //
    while (NewHandleTable->NextHandleNeedingPool < OldHandleTable->NextHandleNeedingPool) {

        //
        //  Call the worker routine to grow the new handle table.  If
        //  not successful then free the new table as far as we got,
        //  set our output variable and exit out here
        //
        if (!ExpAllocateHandleTableEntrySlow (NewHandleTable, FALSE)) {

            ExpFreeHandleTable (NewHandleTable);
            return NULL;
        }
    }

    //
    // Make sure any table reads occur after the value we fetched from NextHandleNeedingPool
    //

    KeMemoryBarrier ();

    //
    //  Now modify the new handle table to think it has zero handles
    //  and set its free list to start on the same index as the old
    //  free list
    //

    NewHandleTable->HandleCount = 0;
    NewHandleTable->ExtraInfoPages = 0;
    NewHandleTable->FirstFree = 0;

    //
    //  Now for every valid index value we'll copy over the old entry into
    //  the new entry
    //


    Handle.Value = HANDLE_VALUE_INC;

    KeEnterCriticalRegionThread (CurrentThread);
    while ((NewHandleTableEntry = ExpLookupHandleTableEntry( NewHandleTable, Handle )) != NULL) {

        //
        // Lookup the old entry.
        //

        OldHandleTableEntry = ExpLookupHandleTableEntry( OldHandleTable, Handle );

        do {

            //
            //  If the old entry is free then simply copy over the entire
            //  old entry to the new entry.  The lock command will tell us
            //  if the entry is free.
            //
            if ((OldHandleTableEntry->Value&Mask) == 0 ||
                !ExpLockHandleTableEntry( OldHandleTable, OldHandleTableEntry )) {
                FreeEntry = TRUE;
            } else {

                PHANDLE_TABLE_ENTRY_INFO EntryInfo;
                
                //
                //  Otherwise we have a non empty entry.  So now copy it
                //  over, and unlock the old entry.  In both cases we bump
                //  the handle count because either the entry is going into
                //  the new table or we're going to remove it with Exp Free
                //  Handle Table Entry which will decrement the handle count
                //

                *NewHandleTableEntry = *OldHandleTableEntry;

                //
                //  Copy the entry info data, if any
                //

                Status = STATUS_SUCCESS;
                EntryInfo = ExGetHandleInfo(OldHandleTable, Handle.GenericHandleOverlay, TRUE);

                if (EntryInfo) {

                    Status = ExSetHandleInfo(NewHandleTable, Handle.GenericHandleOverlay, EntryInfo, TRUE);
                }


                //
                //  Invoke the callback and if it returns true then we
                //  unlock the new entry
                //

                if (NT_SUCCESS (Status)) {
                    if  ((*DupHandleProcedure) (Process,
                                                OldHandleTable,
                                                OldHandleTableEntry,
                                                NewHandleTableEntry)) {

                        if (NewHandleTable->DebugInfo != NULL) {
                            ExpUpdateDebugInfo(
                                NewHandleTable,
                                PsGetCurrentThread (),
                                Handle.GenericHandleOverlay,
                                HANDLE_TRACE_DB_OPEN);
                        }
                        //
                        // Since there is no route to the new table yet we can just
                        // clear the lock bit
                        //
                        NewHandleTableEntry->Value |= EXHANDLE_TABLE_ENTRY_LOCK_BIT;
                        NewHandleTable->HandleCount += 1;
                        FreeEntry = FALSE;
                    } else {
                        if (EntryInfo) {
                            EntryInfo->AuditMask = 0;
                        }

                        FreeEntry = TRUE;
                    }
                } else {
                    //
                    // Duplicate routine doesn't want this handle duplicated so free it
                    //
                    ExUnlockHandleTableEntry( OldHandleTable, OldHandleTableEntry );
                    FreeEntry = TRUE;
                }

            }
            if (FreeEntry) {
                NewHandleTableEntry->Object = NULL;
                NewHandleTableEntry->NextFreeTableEntry =
                    NewHandleTable->FirstFree;
                NewHandleTable->FirstFree = (ULONG) Handle.Value;
            }
            Handle.Value += HANDLE_VALUE_INC;
            NewHandleTableEntry++;
            OldHandleTableEntry++;

        } while ((Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC)) != 0);

        Handle.Value += HANDLE_VALUE_INC; // Skip past the first entry thats not a real entry
    }

    //
    //  Insert the handle table in the handle table list.
    //

    ExAcquirePushLockExclusive( &HandleTableListLock );

    InsertTailList( &HandleTableListHead, &NewHandleTable->HandleTableList );

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    //
    //  lastly return the new handle table to our caller
    //

    return NewHandleTable;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTables (
    __in PEX_SNAPSHOT_HANDLE_ENTRY SnapShotHandleEntry,
    __inout PSYSTEM_HANDLE_INFORMATION HandleInformation,
    __in ULONG Length,
    __inout PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();


    Status = STATUS_SUCCESS;

    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockShared( &HandleTableListLock );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleasePushLockShared( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTablesEx (
    __in PEX_SNAPSHOT_HANDLE_ENTRY_EX SnapShotHandleEntry,
    __inout PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    __in ULONG Length,
    __inout PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    Status = STATUS_SUCCESS;


    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockShared( &HandleTableListLock );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleasePushLockShared( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
HANDLE
ExCreateHandle (
    __inout PHANDLE_TABLE HandleTable,
    __in PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This function creates a handle entry in the specified handle table and
    returns a handle for the entry.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    HandleEntry - Supplies a pointer to the handle entry for which a
        handle entry is created.

Return Value:

    If the handle entry is successfully created, then value of the created
    handle is returned as the function value.  Otherwise, a value of zero is
    returned.

--*/

{
    EXHANDLE Handle;
    PETHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;

    PAGED_CODE();

    //
    //  Set out output variable to zero (i.e., null) before going on
    //

    //
    // Clears Handle.Index and Handle.TagBits
    //

    Handle.GenericHandleOverlay = NULL;


    //
    //  Allocate a new handle table entry, and get the handle value
    //

    NewHandleTableEntry = ExpAllocateHandleTableEntry( HandleTable,
                                                       &Handle );

    //
    //  If we really got a handle then copy over the template and unlock
    //  the entry
    //

    if (NewHandleTableEntry != NULL) {

        CurrentThread = PsGetCurrentThread ();

        //
        // We are about to create a locked entry so protect against suspension
        //
        KeEnterCriticalRegionThread (&CurrentThread->Tcb);

        *NewHandleTableEntry = *HandleTableEntry;

        //
        // If we are debugging handle operations then save away the details
        //
        if (HandleTable->DebugInfo != NULL) {
            ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle.GenericHandleOverlay, HANDLE_TRACE_DB_OPEN);
        }

        ExUnlockHandleTableEntry( HandleTable, NewHandleTableEntry );

        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    return Handle.GenericHandleOverlay;
}


NTKERNELAPI
BOOLEAN
ExDestroyHandle (
    __inout PHANDLE_TABLE HandleTable,
    __in HANDLE Handle,
    __inout_opt PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This function removes a handle from a handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    Handle - Supplies the handle value of the entry to remove.

    HandleTableEntry - Optionally supplies a pointer to the handle
        table entry being destroyed.  If supplied the entry is
        assume to be locked.

Return Value:

    If the specified handle is successfully removed, then a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PETHREAD CurrentThread;
    PVOID Object;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = PsGetCurrentThread ();

    //
    //  If the caller did not supply the optional handle table entry then
    //  locate the entry via the supplied handle, make sure it is real, and
    //  then lock the entry.
    //

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    if (HandleTableEntry == NULL) {

        HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                      LocalHandle );

        if (!ExpIsValidObjectEntry(HandleTableEntry)) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }


        if (!ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }
    } else {
        EXASSERT ((HandleTableEntry->Value&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);
    }


    //
    // If we are debugging handle operations then save away the details
    //

    if (HandleTable->DebugInfo != NULL) {
        ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle, HANDLE_TRACE_DB_CLOSE);
    }

    //
    //  At this point we have a locked handle table entry.  Now mark it free
    //  which does the implicit unlock.  The system will not allocate it
    //  again until we add it to the free list which we will do right after
    //  we take out the lock
    //

    Object = InterlockedExchangePointer (&HandleTableEntry->Object, NULL);

    EXASSERT (Object != NULL);
    EXASSERT ((((ULONG_PTR)Object)&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);


    ExpFreeHandleTableEntry( HandleTable,
                             LocalHandle,
                             HandleTableEntry );

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    return TRUE;
}


NTKERNELAPI
BOOLEAN
ExChangeHandle (
    __in PHANDLE_TABLE HandleTable,
    __in HANDLE Handle,
    __in PEX_CHANGE_HANDLE_ROUTINE ChangeRoutine,
    __in ULONG_PTR Parameter
    )

/*++

Routine Description:

    This function provides the capability to change the contents of the
    handle entry corrsponding to the specified handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle for the handle entry that is changed.

    ChangeRoutine - Supplies a pointer to a function that is called to
        perform the change.

    Parameter - Supplies an uninterpreted parameter that is passed to
        the change routine.

Return Value:

    If the operation was successfully performed, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PKTHREAD CurrentThread;

    PHANDLE_TABLE_ENTRY HandleTableEntry;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = KeGetCurrentThread ();

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpIsValidObjectEntry(HandleTableEntry)) {

        return FALSE;
    }



    //
    //  Try and lock the handle table entry,  If this fails then that's
    //  because someone freed the handle
    //

    //
    //  Make sure we can't get suspended and then invoke the callback
    //

    KeEnterCriticalRegionThread (CurrentThread);

    if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {


        ReturnValue = (*ChangeRoutine)( HandleTableEntry, Parameter );
        
        ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

    } else {
        ReturnValue = FALSE;
    }

    KeLeaveCriticalRegionThread (CurrentThread);

    return ReturnValue;
}


NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointer (
    __in PHANDLE_TABLE HandleTable,
    __in HANDLE Handle
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    if ((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) {
        return NULL;
    }

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {
        //
        // If we are debugging handle operations then save away the details
        //

        if (HandleTable->DebugInfo != NULL) {
            ExpUpdateDebugInfo(HandleTable, PsGetCurrentThread (), Handle, HANDLE_TRACE_DB_BADREF);
        }
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointerEx (
    __in PHANDLE_TABLE HandleTable,
    __in HANDLE Handle,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

    PreviousMode - Previous mode of caller

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry = NULL;
    PETHREAD CurrentThread;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //    

    if (((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) ||
        ((HandleTableEntry = ExpLookupHandleTableEntry(HandleTable, LocalHandle)) == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {

        //
        // If we are debugging handle operations then save away the details
        //

        if (HandleTable->DebugInfo != NULL) {
            CurrentThread = PsGetCurrentThread ();
            ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle, HANDLE_TRACE_DB_BADREF);

            //
            // Since we have a non-null DebugInfo for the handle table of this
            // process it means application verifier was enabled for this process.
            //

            if (PreviousMode == UserMode) {

                if (!KeIsAttachedProcess()) {

                    //
                    // If the current process is marked for verification
                    // then we will raise an exception in user mode. In case
                    // application verifier is enabled system wide we will 
                    // break first.
                    //
                                                 
                    if ((NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
                        
                        DbgPrint ("AVRF: Invalid handle %p in process %p \n", 
                                  Handle,
                                  PsGetCurrentProcess());

//                        DbgBreakPoint ();
                    }

                    KeRaiseUserException (STATUS_INVALID_HANDLE);
                }
            } else {

                //
                // We bugcheck for kernel handles only if we have the handle
                // exceptions flag set system-wide. This way a user enabling
                // application verifier for a process will not get bugchecks
                // only user mode errors.
                //

                if ((NtGlobalFlag & FLG_ENABLE_HANDLE_EXCEPTIONS)) {

                    KeBugCheckEx(INVALID_KERNEL_HANDLE,
                                 (ULONG_PTR)Handle,
                                 (ULONG_PTR)HandleTable,
                                 (ULONG_PTR)HandleTableEntry,
                                 0x1);
                }
            }
        }
        
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

//
//  Local Support Routine
//

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    )
{
    PVOID PoolMemory;

    PoolMemory = ExAllocatePoolWithTag( PagedPool,
                                        NumberOfBytes,
                                        'btbO' );
    if (PoolMemory != NULL) {

        RtlZeroMemory( PoolMemory,
                       NumberOfBytes );

        if (ARGUMENT_PRESENT(QuotaProcess)) {

            if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota ( QuotaProcess,
                                                             NumberOfBytes ))) {
                ExFreePool( PoolMemory );
                PoolMemory = NULL;
            }

        }
    }

    return PoolMemory;
}

PVOID
ExpAllocateTablePagedPoolNoZero (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    )
{
    PVOID PoolMemory;

    PoolMemory = ExAllocatePoolWithTag( PagedPool,
                                        NumberOfBytes,
                                        'btbO' );
    if (PoolMemory != NULL) {

        if (ARGUMENT_PRESENT(QuotaProcess)) {

            if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota ( QuotaProcess,
                                                             NumberOfBytes ))) {
                ExFreePool( PoolMemory );
                PoolMemory = NULL;
            }

        }
    }

    return PoolMemory;
}


//
//  Local Support Routine
//

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    )
{

    ExFreePool( PoolMemory );

    if ( QuotaProcess ) {

        PsReturnProcessPagedPoolQuota( QuotaProcess,
                                       NumberOfBytes
                                     );
    }
}



PHANDLE_TRACE_DEBUG_INFO
ExReferenceHandleDebugInfo (
    IN PHANDLE_TABLE HandleTable
    )
{
    LONG RetVal;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PKTHREAD CurrentThread;

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableShared (HandleTable, CurrentThread, 0);

    DebugInfo = HandleTable->DebugInfo;

    if (DebugInfo != NULL) {
        RetVal = InterlockedIncrement (&DebugInfo->RefCount);
        ASSERT (RetVal > 0);
    }

    ExpUnlockHandleTableShared (HandleTable, CurrentThread, 0);

    return DebugInfo;
}


VOID
ExDereferenceHandleDebugInfo (
    IN PHANDLE_TABLE HandleTable,
    IN PHANDLE_TRACE_DEBUG_INFO DebugInfo
    )
{
    ULONG TraceSize;
    ULONG TableSize;
    LONG RetVal;

    RetVal = InterlockedDecrement (&DebugInfo->RefCount);

    ASSERT (RetVal >= 0);

    if (RetVal == 0) {

        TableSize = DebugInfo->TableSize;
        TraceSize = sizeof (*DebugInfo) + TableSize * sizeof (DebugInfo->TraceDb[0]) - sizeof (DebugInfo->TraceDb);

        ExFreePool (DebugInfo);

        if (HandleTable->QuotaProcess != NULL) {
            PsReturnProcessNonPagedPoolQuota (HandleTable->QuotaProcess,
                                              TraceSize);
        }

        InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, -(LONG)TableSize);
    }
}

NTKERNELAPI
NTSTATUS
ExDisableHandleTracing (
    __inout PHANDLE_TABLE HandleTable
    )
/*++

Routine Description:

    This routine turns off handle tracing for the specified table

Arguments:

    HandleTable - Table to disable tracing in


Return Value:

    NTSTATUS - Status of operation

--*/
{
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PKTHREAD CurrentThread;

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableExclusive (HandleTable, CurrentThread);

    DebugInfo = HandleTable->DebugInfo;

    HandleTable->DebugInfo = NULL;

    ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);

    if (DebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);
    }

    return STATUS_SUCCESS;
}

C_ASSERT (RTL_FIELD_SIZE (HANDLE_TRACE_DEBUG_INFO, TraceDb[0]) <= MAXULONG);

NTKERNELAPI
NTSTATUS
ExEnableHandleTracing (
    __inout PHANDLE_TABLE HandleTable,
    __in ULONG Slots
    )
/*++

Routine Description:

    This routine turns on handle tracing for the specified table

Arguments:

    HandleTable - Table to enable tracing in


Return Value:

    NTSTATUS - Status of operation

--*/

{
    PHANDLE_TRACE_DEBUG_INFO DebugInfo, OldDebugInfo;
    PEPROCESS Process;
    PKTHREAD CurrentThread;
    NTSTATUS Status;
    SIZE_T TotalNow;
    extern SIZE_T MmMaximumNonPagedPoolInBytes;
    SIZE_T TraceSize;
    LONG TotalSlots;

    if (Slots == 0) {
        TotalSlots = HANDLE_TRACE_DB_DEFAULT_STACKS;
    } else {
        if (Slots < HANDLE_TRACE_DB_MIN_STACKS) {
            TotalSlots = HANDLE_TRACE_DB_MIN_STACKS;
        } else {
            TotalSlots = Slots;
        }

        if (TotalSlots < 0 || TotalSlots > HANDLE_TRACE_DB_MAX_STACKS) {
            TotalSlots = HANDLE_TRACE_DB_MAX_STACKS;
        }

        //
        // Round the value up to the next power of 2
        //

        while ((TotalSlots & (TotalSlots - 1)) != 0) {
            TotalSlots |= (TotalSlots - 1);
            TotalSlots += 1;
        }
    }

    //
    // Total slots needs to be a power of two
    //
    ASSERT ((TotalSlots & (TotalSlots - 1)) == 0);
    ASSERT (TotalSlots > 0 && TotalSlots <= HANDLE_TRACE_DB_MAX_STACKS);

    TraceSize = sizeof (*DebugInfo) + TotalSlots * sizeof (DebugInfo->TraceDb[0]) - sizeof (DebugInfo->TraceDb);

    TotalNow = InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, TotalSlots);

    //
    // See if more than 5/16 (31.25%) of non paged pool has been used.
    // Note that performing math in this manner offers improved efficiency 
    // and avoids overflow.
    //

    if (((ULONGLONG) TotalNow) * sizeof (DebugInfo->TraceDb[0]) > 
        ((MmMaximumNonPagedPoolInBytes >> 2) + (MmMaximumNonPagedPoolInBytes >> 4))) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto return_and_exit;
    }

    Process = HandleTable->QuotaProcess;

    if (Process) {
        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   TraceSize);
        if (!NT_SUCCESS (Status)) {
            goto return_and_exit;
        }
    }

    //
    // Allocate the handle debug database
    //
    DebugInfo = ExAllocatePoolWithTag (NonPagedPool,
                                       TraceSize,
                                       'dtbO');
    if (DebugInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto quota_return_and_exit;
    }
    RtlZeroMemory (DebugInfo, TraceSize);

    DebugInfo->RefCount = 1;
    DebugInfo->TableSize = TotalSlots;

    ExInitializeFastMutex(&DebugInfo->CloseCompactionLock);

    //
    // Since we are tracing then we should enforce strict FIFO
    // Only do this for tables with processes so we leave atom tables alone.
    //
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }

    //
    // Put the new table in place releasing any existing table
    //

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableExclusive (HandleTable, CurrentThread);

    OldDebugInfo = HandleTable->DebugInfo;

    HandleTable->DebugInfo = DebugInfo;

    ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);

    if (OldDebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, OldDebugInfo);
    }

    return STATUS_SUCCESS;

quota_return_and_exit:

    if (Process) {
        PsReturnProcessNonPagedPoolQuota (Process,
                                          TraceSize);
    }


return_and_exit:

    InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, -TotalSlots);
    return Status;
}

//
//  Local Support Routine
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine will allocate and initialize a new handle table
    structure.  The new structure consists of the basic handle table
    struct plus the first allocation needed to store handles.  This is
    really one page divided up into the top level node, the first mid
    level node, and one bottom level node.

Arguments:

    Process - Optionally supplies the process to charge quota for the
        handle table

    DoInit - If FALSE then we are being called by duplicate and we don't need
             the free list built for the caller

Return Value:

    A pointer to the new handle table or NULL if unsuccessful at getting
    pool.

--*/

{
    PHANDLE_TABLE HandleTable;
    PHANDLE_TABLE_ENTRY HandleTableTable, HandleEntry;
    ULONG i, Idx;

    PAGED_CODE();

    //
    //  If any allocation or quota failures happen we will catch it in the
    //  following try-except clause and cleanup after outselves before
    //  we return null
    //

    //
    //  First allocate the handle table, make sure we got one, charge quota
    //  for it and then zero it out
    //

    HandleTable = (PHANDLE_TABLE)ExAllocatePoolWithTag (PagedPool,
                                                        sizeof(HANDLE_TABLE),
                                                        'btbO');
    if (HandleTable == NULL) {
        return NULL;
    }

    if (ARGUMENT_PRESENT(Process)) {

        if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota( Process,
                                                        sizeof(HANDLE_TABLE)))) {
            ExFreePool( HandleTable );
            return NULL;
        }
    }


    RtlZeroMemory( HandleTable, sizeof(HANDLE_TABLE) );


    //
    //  Now allocate space of the top level, one mid level and one bottom
    //  level table structure.  This will all fit on a page, maybe two.
    //

    HandleTableTable = ExpAllocateTablePagedPoolNoZero ( Process,
                                                         TABLE_PAGE_SIZE
                                                        );

    if ( HandleTableTable == NULL ) {

        ExFreePool( HandleTable );

        if (ARGUMENT_PRESENT(Process)) {

            PsReturnProcessPagedPoolQuota (Process,
                                           sizeof(HANDLE_TABLE));
        }
            
        return NULL;
    }
        
    HandleTable->TableCode = (ULONG_PTR)HandleTableTable;


    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    HandleEntry = &HandleTableTable[0];

    HandleEntry->NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;
    HandleEntry->Value = 0;

    //
    // For duplicate calls we skip building the free list as we rebuild it manually as
    // we traverse the old table we are duplicating
    //
    if (DoInit) {
        HandleEntry++;
        //
        //  Now setup the free list.  We do this by chaining together the free
        //  entries such that each free entry give the next free index (i.e.,
        //  like a fat chain).  The chain is terminated with a 0.  Note that
        //  we'll skip handle zero because our callers will get that value
        //  confused with null.
        //


        for (i = 1; i < LOWLEVEL_COUNT - 1; i += 1) {

            HandleEntry->Value = 0;
            HandleEntry->NextFreeTableEntry = (i+1)*HANDLE_VALUE_INC;
            HandleEntry++;
        }
        HandleEntry->Value = 0;
        HandleEntry->NextFreeTableEntry = 0;

        HandleTable->FirstFree = HANDLE_VALUE_INC;

    }
    

    HandleTable->NextHandleNeedingPool = LOWLEVEL_COUNT * HANDLE_VALUE_INC;

    //
    //  Setup the necessary process information
    //

    HandleTable->QuotaProcess = Process;
    HandleTable->UniqueProcessId = PsGetCurrentProcess()->UniqueProcessId;
    HandleTable->Flags = 0;

#if DBG && !EXHANDLE_EXTRA_CHECKS
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }
#endif

    //
    //  Initialize the handle table lock. This is only used by table expansion.
    //

    for (Idx = 0; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExInitializePushLock (&HandleTable->HandleTableLock[Idx]);
    }

    //
    //  Initialize the blocker for handle entry lock contention.
    //

    ExInitializePushLock (&HandleTable->HandleContentionEvent);

    if (TRACE_ALL_TABLES) {
        ExEnableHandleTracing (HandleTable, 0);    
    }

    //
    //  And return to our caller
    //

    return HandleTable;
}

//
//  Local Support Routine
//

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    )

/*++

Routine Description:

    This worker routine frees a low-level handle table
    and the additional info memory, if any.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    //
    //  Check whether we have a pool allocated for the additional info
    //

    if (TableLevel1[0].Object) {

        ExpFreeTablePagedPool( QuotaProcess,
                               TableLevel1[0].Object,
                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO)
                             );
    }

    //
    //  Now free the low level table and return the quota for the process
    //

    ExpFreeTablePagedPool( QuotaProcess,
                           TableLevel1,
                           TABLE_PAGE_SIZE
                         );
    
    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This worker routine tears down and frees the specified handle table.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    PEPROCESS Process;
    ULONG i,j;
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);

    PAGED_CODE();

    //
    //  Unmask the level bits
    //

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;
    Process = HandleTable->QuotaProcess;

    //
    //  We need to free all pages. We have 3 cases, depending on the number
    //  of levels
    //


    if (TableLevel == 0) {

        //
        //  There is a single level handle table. We'll simply free the buffer
        //

        PHANDLE_TABLE_ENTRY TableLevel1 = (PHANDLE_TABLE_ENTRY)CapturedTable;
        
        ExpFreeLowLevelTable( Process, TableLevel1 );

    } else if (TableLevel == 1) {

        //
        //  We have 2 levels in the handle table
        //
        
        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        for (i = 0; i < MIDLEVEL_COUNT; i++) {

            //
            //  loop through the pointers to the low-level tables, and free each one
            //

            if (TableLevel2[i] == NULL) {

                break;
            }
            
            ExpFreeLowLevelTable( Process, TableLevel2[i] );
        }
        
        //
        //  Free the top level table
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel2,
                               PAGE_SIZE
                             );

    } else {

        //
        //  Here we handle the case where we have a 3 level handle table
        //

        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        //
        //  Iterates through the high-level pointers to mid-table
        //

        for (i = 0; i < HIGHLEVEL_COUNT; i++) {

            if (TableLevel3[i] == NULL) {

                break;
            }
            
            //
            //  Iterate through the mid-level table
            //  and free every low-level page
            //

            for (j = 0; j < MIDLEVEL_COUNT; j++) {

                if (TableLevel3[i][j] == NULL) {

                    break;
                }
                
                ExpFreeLowLevelTable( Process, TableLevel3[i][j] );
            }

            ExpFreeTablePagedPool( Process,
                                   TableLevel3[i],
                                   PAGE_SIZE
                                 );
        }
        
        //
        //  Free the top-level array
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel3,
                               HIGHLEVEL_SIZE
                             );
    }

    //
    // Free any debug info if we have any.
    //

    if (HandleTable->DebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, HandleTable->DebugInfo);
    }

    //
    //  Finally deallocate the handle table itself
    //

    ExFreePool( HandleTable );

    if (Process != NULL) {

        PsReturnProcessPagedPoolQuota (Process,
                                       sizeof(HANDLE_TABLE));
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine allocates a new low level table
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE the caller (duplicate) doesn't need the free list maintained

Return Value:

    Returns - a pointer to a low-level table if allocation is
        successful otherwise the return value is null.

--*/

{
    ULONG k;
    PHANDLE_TABLE_ENTRY NewLowLevel = NULL, HandleEntry;
    ULONG BaseHandle;
    
    //
    //  Allocate the pool for lower level
    //

    NewLowLevel = ExpAllocateTablePagedPoolNoZero( HandleTable->QuotaProcess,
                                                   TABLE_PAGE_SIZE
                                                 );

    if (NewLowLevel == NULL) {

        return NULL;
    }

    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    HandleEntry = &NewLowLevel[0];

    HandleEntry->NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;
    HandleEntry->Value = 0;

    //
    // Initialize the free list within this page if the caller wants this
    //
    if (DoInit) {

        HandleEntry++;

        //
        //  Now add the new entries to the free list.  To do this we
        //  chain the new free entries together.  We are guaranteed to
        //  have at least one new buffer.  The second buffer we need
        //  to check for.
        //
        //  We reserve the first entry in the table to the structure with
        //  additional info
        //
        //
        //  Do the guaranteed first buffer
        //

        BaseHandle = HandleTable->NextHandleNeedingPool + 2 * HANDLE_VALUE_INC;
        for (k = BaseHandle; k < BaseHandle + (LOWLEVEL_COUNT - 2) * HANDLE_VALUE_INC; k += HANDLE_VALUE_INC) {

            HandleEntry->NextFreeTableEntry = k;
            HandleEntry->Value = 0;
            HandleEntry++;
        }
        HandleEntry->NextFreeTableEntry = 0;
        HandleEntry->Value = 0;
    }


    return NewLowLevel;    
}

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    )

/*++

Routine Description:

    This worker routine allocates a mid-level table. This is an array with
    pointers to low-level tables.
    It will allocate also a low-level table and will save it in the first index
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE the caller (duplicate) does not want the free list build

    pNewLowLevel - Returns the new low level table for later free list chaining

Return Value:

    Returns a pointer to the new mid-level table allocated
    
--*/

{
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY NewLowLevel;
    
    NewMidLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                             PAGE_SIZE
                                           );

    if (NewMidLevel == NULL) {

        return NULL;
    }

    //
    //  If we need a new mid-level, we'll need a low-level too.
    //  We'll create one and if success we'll save it at the first position
    //

    NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

    if (NewLowLevel == NULL) {

        ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                               NewMidLevel,
                               PAGE_SIZE
                             );

        return NULL;
    }
    
    //
    //  Set the low-level table at the first index
    //

    NewMidLevel[0] = NewLowLevel;
    *pNewLowLevel = NewLowLevel;

    return NewMidLevel;
}



BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine allocates a new handle table entry for the specified
    handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE then the caller (duplicate) doesn't need the free list built

Return Value:

    BOOLEAN - TRUE, Retry the fast allocation path, FALSE, We failed to allocate memory

--*/

{
    ULONG i,j;

    PHANDLE_TABLE_ENTRY NewLowLevel;
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY **NewHighLevel;
    ULONG NewFree, OldFree;
    ULONG OldIndex;
    PVOID OldValue;
    
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    
    PAGED_CODE();

    //
    // Initializing NewLowLevel is not needed for
    // correctness but without it the compiler cannot compile this code
    // W4 to check for use of uninitialized variables.
    //

    NewLowLevel = NULL;

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;


    if ( TableLevel == 0 ) {

        //
        //  We have a single level. We need to ad a mid-layer
        //  to the process handle table
        //

        NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );

        if (NewMidLevel == NULL) {
            return FALSE;
        }

        //
        //  Since ExpAllocateMidLevelTable initialize the 
        //  first position with a new table, we need to move it in 
        //  the second position, and store in the first position the current one
        //

        NewMidLevel[1] = NewMidLevel[0];
        NewMidLevel[0] = (PHANDLE_TABLE_ENTRY)CapturedTable;
            
        //
        //  Encode the current level and set it to the handle table process
        //

        CapturedTable = ((ULONG_PTR)NewMidLevel) | 1;
            
        OldValue = InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );


    } else if (TableLevel == 1) {

        //
        //  We have a 2 levels handle table
        //

        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        //
        //  Test whether the index we need to create is still in the 
        //  range for a 2 layers table
        //

        i = HandleTable->NextHandleNeedingPool / (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

        if (i < MIDLEVEL_COUNT) {

            //
            //  We just need to allocate a new low-level
            //  table
            //
                
            NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

            if (NewLowLevel == NULL) {
                return FALSE;
            }

            //
            //  Set the new one to the table, at appropriate position
            //

            OldValue = InterlockedExchangePointer( (PVOID *) (&TableLevel2[i]), NewLowLevel );
            EXASSERT (OldValue == NULL);

        } else {

            //
            //  We exhausted the 2 level domain. We need to insert a new one
            //

            NewHighLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                                      HIGHLEVEL_SIZE
                                                    );

            if (NewHighLevel == NULL) {

                return FALSE;
            }
                
            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );

            if (NewMidLevel == NULL) {
                    
                ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                                       NewHighLevel,
                                       HIGHLEVEL_SIZE
                                     );

                return FALSE;
            }

            //
            //  Initialize the first index with the previous mid-level layer
            //

            NewHighLevel[0] = (PHANDLE_TABLE_ENTRY*)CapturedTable;
            NewHighLevel[1] = NewMidLevel;

            //
            //  Encode the level into the table pointer
            //

            CapturedTable = ((ULONG_PTR)NewHighLevel) | 2;

            //
            //  Change the handle table pointer with this one
            //

            OldValue = InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );

        }

    } else if (TableLevel == 2) {

        //
        //  we have already a table with 3 levels
        //

        ULONG RemainingIndex;
        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        i = HandleTable->NextHandleNeedingPool / (MIDLEVEL_THRESHOLD * HANDLE_VALUE_INC);

        //
        //  Check whether we exhausted all possible indexes.
        //

        if (i >= HIGHLEVEL_COUNT) {

            return FALSE;
        }

        if (TableLevel3[i] == NULL) {

            //
            //  The new available handle points to a free mid-level entry
            //  We need then to allocate a new one and save it in that position
            //

            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );
                
            if (NewMidLevel == NULL) {
                    
                return FALSE;
            }             

            OldValue = InterlockedExchangePointer( (PVOID *) &(TableLevel3[i]), NewMidLevel );
            EXASSERT (OldValue == NULL);

        } else {

            //
            //  We have already a mid-level table. We just need to add a new low-level one
            //  at the end
            //
                
            RemainingIndex = (HandleTable->NextHandleNeedingPool / HANDLE_VALUE_INC) -
                              i * MIDLEVEL_THRESHOLD;
            j = RemainingIndex / LOWLEVEL_COUNT;

            NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

            if (NewLowLevel == NULL) {

                return FALSE;
            }

            OldValue = InterlockedExchangePointer( (PVOID *)(&TableLevel3[i][j]) , NewLowLevel );
            EXASSERT (OldValue == NULL);
        }
    }

    //
    // This must be done after the table pointers so that new created handles
    // are valid before being freed.
    //
    OldIndex = InterlockedExchangeAdd ((PLONG) &HandleTable->NextHandleNeedingPool,
                                       LOWLEVEL_COUNT * HANDLE_VALUE_INC);


    if (DoInit) {
        //
        // Generate a new sequence number since this is a push
        //
        OldIndex += HANDLE_VALUE_INC + GetNextSeq();

        //
        // Now free the handles. These are all ready to be accepted by the lookup logic now.
        //
        while (1) {
            OldFree = ReadForWriteAccess (&HandleTable->FirstFree);
            NewLowLevel[LOWLEVEL_COUNT - 1].NextFreeTableEntry = OldFree;

            //
            // These are new entries that have never existed before. We can't have an A-B-A problem
            // with these so we don't need to take any locks
            //


            NewFree = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                                  OldIndex,
                                                  OldFree);
            if (NewFree == OldFree) {
                break;
            }
        }
    }
    return TRUE;
}


VOID
ExSetHandleTableStrictFIFO (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This routine marks a handle table so that handle allocation is done in
    a strict FIFO order.


Arguments:

    HandleTable - Supplies the handle table being changed to FIFO

Return Value:

    None.

--*/

{
    HandleTable->StrictFIFO = TRUE;
}


//
//  Local Support Routine
//

//
//  The following is a global variable only present in the checked builds
//  to help catch apps that reuse handle values after they're closed.
//

#if DBG
BOOLEAN ExReuseHandles = 1;
#endif //DBG

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This worker routine returns the specified handle table entry to the free
    list for the handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the parent handle table being modified

    Handle - Supplies the handle of the entry being freed

    HandleTableEntry - Supplies the table entry being freed

Return Value:

    None.

--*/

{
    PHANDLE_TABLE_ENTRY_INFO EntryInfo;
    ULONG OldFree, NewFree, *Free;
    PKTHREAD CurrentThread;
    ULONG Idx;
    ULONG SeqInc;

    PAGED_CODE();

    EXASSERT (HandleTableEntry->Object == NULL);
    EXASSERT (HandleTableEntry == ExpLookupHandleTableEntry (HandleTable, Handle));

    //
    //  Clear the AuditMask flags if these are present into the table
    //

    EntryInfo = ExGetHandleInfo(HandleTable, Handle.GenericHandleOverlay, TRUE);

    if (EntryInfo) {

        EntryInfo->AuditMask = 0;
    }

    //
    //  A free is simply a push onto the free table entry stack, or in the
    //  debug case we'll sometimes just float the entry to catch apps who
    //  reuse a recycled handle value.
    //

    InterlockedDecrement (&HandleTable->HandleCount);
    CurrentThread = KeGetCurrentThread ();

    NewFree = (ULONG) Handle.Value & ~(HANDLE_VALUE_INC - 1);

#if DBG
    if (ExReuseHandles) {
#endif //DBG

        if (!HandleTable->StrictFIFO) {


            //
            // We are pushing potentially old entries onto the free list.
            // Prevent the A-B-A problem by shifting to an alternate list
            // read this element has the list head out of the loop.
            //
            Idx = (NewFree>>2) % HANDLE_TABLE_LOCKS;
            if (ExTryAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx])) {
                SeqInc = GetNextSeq();
                Free = &HandleTable->FirstFree;
            } else {
                SeqInc = 0;
                Free = &HandleTable->LastFree;
            }
        } else {
            SeqInc = 0;
            Free = &HandleTable->LastFree;
        }

        while (1) {


            OldFree = ReadForWriteAccess (Free);
            HandleTableEntry->NextFreeTableEntry = OldFree;


            if ((ULONG)InterlockedCompareExchange ((PLONG)Free,
                                                   NewFree + SeqInc,
                                                   OldFree) == OldFree) {

                EXASSERT ((OldFree & FREE_HANDLE_MASK) < HandleTable->NextHandleNeedingPool);

                break;
            }
        }

#if DBG
    } else {

        HandleTableEntry->NextFreeTableEntry = 0;
    }
#endif //DBG


    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE tHandle
    )

/*++

Routine Description:

    This routine looks up and returns the table entry for the
    specified handle value.

Arguments:

    HandleTable - Supplies the handle table being queried

    tHandle - Supplies the handle value being queried

Return Value:

    Returns a pointer to the corresponding table entry for the input
        handle.  Or NULL if the handle value is invalid (i.e., too large
        for the tables current allocation.

--*/

{
    ULONG_PTR i,j,k;
    ULONG_PTR CapturedTable;
    ULONG TableLevel;
    PHANDLE_TABLE_ENTRY Entry = NULL;
    EXHANDLE Handle;

    PUCHAR TableLevel1;
    PUCHAR TableLevel2;
    PUCHAR TableLevel3;

    ULONG_PTR MaxHandle;

    PAGED_CODE();


    //
    // Extract the handle index
    //
    Handle = tHandle;

    Handle.TagBits = 0;

    MaxHandle = *(volatile ULONG *) &HandleTable->NextHandleNeedingPool;

    //
    // See if this can be a valid handle given the table levels.
    //
    if (Handle.Value >= MaxHandle) {
        return NULL;        
    }

    //
    // Now fetch the table address and level bits. We must preserve the
    // ordering here.
    //
    CapturedTable = *(volatile ULONG_PTR *) &HandleTable->TableCode;

    //
    //  we need to capture the current table. This routine is lock free
    //  so another thread may change the table at HandleTable->TableCode
    //

    TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    CapturedTable = CapturedTable - TableLevel;

    //
    //  The lookup code depends on number of levels we have
    //

    switch (TableLevel) {
        
        case 0:
            
            //
            //  We have a simple index into the array, for a single level
            //  handle table
            //


            TableLevel1 = (PUCHAR) CapturedTable;

            //
            // The index for this level is already scaled by a factor of 4. Take advantage of this
            //

            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[Handle.Value *
                                                       (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;
        
        case 1:
            
            //
            //  we have a 2 level handle table. We need to get the upper index
            //  and lower index into the array
            //


            TableLevel2 = (PUCHAR) CapturedTable;

            i = Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

            Handle.Value -= i;
            j = Handle.Value / ((LOWLEVEL_COUNT * HANDLE_VALUE_INC) / sizeof (PHANDLE_TABLE_ENTRY));

            TableLevel1 =  (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel2[j];
            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[i * (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;
        
        case 2:
            
            //
            //  We have here a three level handle table.
            //


            TableLevel3 = (PUCHAR) CapturedTable;

            i = Handle.Value  % (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

            Handle.Value -= i;

            k = Handle.Value / ((LOWLEVEL_COUNT * HANDLE_VALUE_INC) / sizeof (PHANDLE_TABLE_ENTRY));

            j = k % (MIDLEVEL_COUNT * sizeof (PHANDLE_TABLE_ENTRY));

            k -= j;

            k /= MIDLEVEL_COUNT;


            TableLevel2 = (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel3[k];
            TableLevel1 = (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel2[j];
            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[i * (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;

        default :
            _assume (0);
    }

    return Entry;
}

NTKERNELAPI
NTSTATUS
ExSetHandleInfo (
    __inout PHANDLE_TABLE HandleTable,
    __in HANDLE Handle,
    __in PHANDLE_TABLE_ENTRY_INFO EntryInfo,
    __in BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine set the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    NTSTATUS Status;
    PHANDLE_TABLE_ENTRY TableEntry;
    PHANDLE_TABLE_ENTRY_INFO InfoTable;

    Status = STATUS_UNSUCCESSFUL;
    TableEntry = NULL;
    CurrentThread = NULL;

    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {
        CurrentThread = KeGetCurrentThread ();
        KeEnterCriticalRegionThread (CurrentThread);
        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            KeLeaveCriticalRegionThread (CurrentThread);
            
            return STATUS_UNSUCCESSFUL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) {

        if ( TableEntry ) {
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
            KeLeaveCriticalRegionThread (CurrentThread);
        }

        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Check whether we need to allocate a new table
    //
    InfoTable = InfoStructure->InfoTable;
    if (InfoTable == NULL) {
        //
        //  Nobody allocated the Infotable so far.
        //  We'll do it right now
        //

        InfoTable = ExpAllocateTablePagedPool (HandleTable->QuotaProcess,
                                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
            
        if (InfoTable) {

            //
            // Update the number of pages for extra info. If somebody beat us to it then free the
            // new table
            //
            if (InterlockedCompareExchangePointer (&InfoStructure->InfoTable,
                                                   InfoTable,
                                                   NULL) == NULL) {

                InterlockedIncrement(&HandleTable->ExtraInfoPages);

            } else {
                ExpFreeTablePagedPool (HandleTable->QuotaProcess,
                                       InfoTable,
                                       LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
                InfoTable = InfoStructure->InfoTable;
            }
        }
    }

    if (InfoTable != NULL) {
        
        //
        //  Calculate the index and copy the structure
        //

        ExHandle.GenericHandleOverlay = Handle;

        InfoTable[ExHandle.Index % LOWLEVEL_COUNT] = *EntryInfo;

        Status = STATUS_SUCCESS;
    }

    if ( TableEntry ) {

        ExUnlockHandleTableEntry( HandleTable, TableEntry );
        KeLeaveCriticalRegionThread (CurrentThread);
    }
    
    return Status;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY_INFO
ExpGetHandleInfo (
    __in PHANDLE_TABLE HandleTable,
    __in HANDLE Handle,
    __in BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine reads the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    PHANDLE_TABLE_ENTRY TableEntry = NULL;
    
    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {

        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            
            return NULL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle 
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE ||
        InfoStructure->InfoTable == NULL) {

        if ( TableEntry ) {
            
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
        }

        return NULL;
    }


    //
    //  Return a pointer to the info structure
    //

    ExHandle.GenericHandleOverlay = Handle;

    return &(InfoStructure->InfoTable[ExHandle.Index % LOWLEVEL_COUNT]);
}

#if DBG
ULONG g_ulExpUpdateDebugInfoDebugLevel = 0;
#endif
void ExpUpdateDebugInfo(
    PHANDLE_TABLE HandleTable,
    PETHREAD CurrentThread,
    HANDLE Handle,
    ULONG Type) 
{
    BOOLEAN LockAcquired = FALSE;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;

    DebugInfo = ExReferenceHandleDebugInfo (HandleTable);

    if (DebugInfo == NULL) {
        return;
    }

#if DBG
    if (g_ulExpUpdateDebugInfoDebugLevel > 10)
    {
        DbgPrint ("ExpUpdateDebugInfo() BitMaskFlags=0x%x, CurrentStackIndex=%d, Handle=0x%p, Type=%d \n", 
                  DebugInfo->BitMaskFlags,
                  DebugInfo->CurrentStackIndex,
                  Handle,
                  Type);
    }
#endif
    if (DebugInfo->BitMaskFlags & (HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO | HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE)) {
        //
        // we wish to preserve lock-free behavior in the non-compaction path
        // so we lock only in this path
        //
        ExAcquireFastMutex(&DebugInfo->CloseCompactionLock);
        LockAcquired = TRUE;
    }

    if (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO) {
        //
        // clean debug info, but not the fast mutex!
        //

        ASSERT(LockAcquired);

        DebugInfo->BitMaskFlags &= ~HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO;
        DebugInfo->BitMaskFlags &= ~HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND;
        DebugInfo->BitMaskFlags |= HANDLE_TRACE_DEBUG_INFO_WAS_SOMETIME_CLEANED;
        DebugInfo->CurrentStackIndex = 0;
        RtlZeroMemory (DebugInfo->TraceDb,
                       sizeof (*DebugInfo) +
                       DebugInfo->TableSize * sizeof (DebugInfo->TraceDb[0]) -
                       sizeof (DebugInfo->TraceDb));
    }

    if (
        (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE) &&
        (Type == HANDLE_TRACE_DB_CLOSE)
       ){
        //
        // This is assuming that either:
        // 1) this flag was set from the beginning, so there are no close items.
        // 2) this flag was set via KD, in which case HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO
        //    must have been set also, so again there are no close items
        //
        ULONG uiMaxNumOfItemsInTraceDb;
        ULONG uiNextItem;

        ASSERT(LockAcquired);

        //
        // look for the matching open item, remove them from the list, and compact the list
        //
        uiMaxNumOfItemsInTraceDb = (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND) ? DebugInfo->TableSize : DebugInfo->CurrentStackIndex ;
        for (uiNextItem = 1; uiNextItem <= uiMaxNumOfItemsInTraceDb; uiNextItem++) {
            //
            // if HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE is on
            // there could be no HANDLE_TRACE_DB_CLOSE items
            // This ASSERT can fire if the HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE flag
            // is set dynamically, so another thread was not using the locks to add
            // items to the list, and could have added a HANDLE_TRACE_DB_CLOSE item.
            //
            ASSERT(DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Type != HANDLE_TRACE_DB_CLOSE);

            if (
                (DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Type == HANDLE_TRACE_DB_OPEN) &&
                (DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Handle == Handle) 
                ) {
                //
                // found the matching open, compact the list
                //
                ULONG IndexToMoveBack;
                DebugInfo->CurrentStackIndex--;
                IndexToMoveBack = DebugInfo->CurrentStackIndex % DebugInfo->TableSize;
                if (0 != IndexToMoveBack)
                {
                    DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize] = DebugInfo->TraceDb[IndexToMoveBack];
                }
                else
                {
                    //
                    // the list is already empty
                    //
                }
                break;
            }
        }
        if (!(uiNextItem <= uiMaxNumOfItemsInTraceDb)) {
            //
            // a matching open was not found.
            // this must mean that we wrapped around, or cleaned the list sometime after
            // it was created
            // or that a duplicated handle was created before handle tracking was initiated
            // so we cannot ASSERT for that
            //
            /*
            ASSERT(
                (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_SOMETIME_CLEANED) ||
                (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND)
                );
                */
            //
            // just ignore this HANDLE_TRACE_DB_CLOSE
            //
        }
    }
    else
    {
        PHANDLE_TRACE_DB_ENTRY DebugEntry;
        ULONG Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                   % DebugInfo->TableSize;
        ASSERT((Type != HANDLE_TRACE_DB_CLOSE) || (!(DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE)));
        if (0 == Index) {
            //
            // this is a wraparound of the db, mark it as such, and if there's 
            // a debugger attached break into it
            //
            DebugInfo->BitMaskFlags |= HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND;
            if(DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_BREAK_ON_WRAP_AROUND)
            {
                __try {
                    DbgBreakPoint();
                }
                __except(1) {
                    NOTHING;
                }
            }
        }
        DebugEntry = &DebugInfo->TraceDb[Index];
        DebugEntry->ClientId = CurrentThread->Cid;
        DebugEntry->Handle   = Handle;
        DebugEntry->Type     = Type;
        Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
        RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);
    }

    if (LockAcquired)
    {
        ExReleaseFastMutex(&DebugInfo->CloseCompactionLock);
    }

    ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);
}

VOID
ExHandleTest (
    )
{
    PHANDLE_TABLE HandleTable;
    ULONG i, j, k;
#define MAX_ALLOCS 20
    PHANDLE_TABLE_ENTRY HandleEntryArray[MAX_ALLOCS];
    EXHANDLE Handle[MAX_ALLOCS];
    LARGE_INTEGER CurrentTime;

    HandleTable = PsGetCurrentProcess ()->ObjectTable;
    HandleTable->StrictFIFO = 0;

    k = 0;
    for (i = 0; i < 100000; i++) {
        KeQuerySystemTime (&CurrentTime);
        for (j = 0; j < MAX_ALLOCS; j++) {
            //
            // Clears Handle.Index and Handle.TagBits
            //

            Handle[j].GenericHandleOverlay = NULL;


            //
            //  Allocate a new handle table entry, and get the handle value
            //

            HandleEntryArray[j] = ExpAllocateHandleTableEntry (HandleTable,
                                                               &Handle[j]);
            if (HandleEntryArray[j] != NULL) {
                HandleEntryArray[j]->NextFreeTableEntry = 0x88888888;
            }
        }

        for (j = MAX_ALLOCS; j > 0; j--) {
            k = k + CurrentTime.LowPart;
            k = k % j;
            CurrentTime.QuadPart >>= 3;
            if (HandleEntryArray[k] != NULL) {
                //
                // Free the entry
                //
                ExpFreeHandleTableEntry (HandleTable,
                                         Handle[k],
                                         HandleEntryArray[k]);
                HandleEntryArray[k] = HandleEntryArray[j-1];
                HandleEntryArray[j-1] = NULL;
                Handle[k] = Handle[j-1];
                Handle[j-1].GenericHandleOverlay = NULL;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\exp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exp.h

Abstract:

    This module contains the private (internal) header file for the
    executive.

--*/

#ifndef _EXP_
#define _EXP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4706)   // assignment within conditional
#pragma warning(disable:4324)   // structure was padded
#pragma warning(disable:4328)   // greater alignment than needed
#pragma warning(disable:4054)   // cast of function pointer to PVOID

#include "ntos.h"
#include "zwapi.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "ki.h"
#include "stdio.h"
#include "pool.h"


//
// Executive information initialization structure
//

typedef struct {
    PCALLBACK_OBJECT    *CallBackObject;
    PWSTR               CallbackName;
} EXP_INITIALIZE_GLOBAL_CALLBACKS;

//
// Executive macros
//
//

// This macro returns the address of a field given the type of the structure, pointer to
// the base of the structure and the name of the field whose address is to be computed.
// This returns the same value as &Base->Member
//

#define EX_FIELD_ADDRESS(Type, Base, Member) ((PUCHAR)Base + FIELD_OFFSET(Type, Member))

//
// This macro is used like a C for loop and iterates over all the entries in the list.
//
// _Type - Name of the data type for each element in the list
// _Link - Name of the field of type LIST_ENTRY used to link the elements.
// _Head - Pointer to the head of the list.
// _Current - Points to the iterated element.
//
// Example:     EX_FOR_EACH_IN_LIST(SYSTEM_FIRMWARE_TABLE_HANDLER_NODE,
//                                  FirmwareTableProviderList,
//                                  &ExpFirmwareTableProviderListHead,
//                                  HandlerListCurrent) {
//
//                  /* Do something with Current */
//
//              }
//

#define EX_FOR_EACH_IN_LIST(_Type, _Link, _Head, _Current)                                             \
    for((_Current) = CONTAINING_RECORD((_Head)->Flink, _Type, _Link);                                   \
       (_Head) != (PLIST_ENTRY)EX_FIELD_ADDRESS(_Type, _Current, _Link);                               \
       (_Current) = CONTAINING_RECORD(((PLIST_ENTRY)EX_FIELD_ADDRESS(_Type, _Current, _Link))->Flink,  \
                                     _Type,                                                          \
                                     _Link)                                                          \
       )


//
// Executive object and other initialization function definitions.
//

NTSTATUS
ExpWorkerInitialization (
    VOID
    );

BOOLEAN
ExpEventInitialization (
    VOID
    );

BOOLEAN
ExpEventPairInitialization (
    VOID
    );

BOOLEAN
ExpMutantInitialization (
    VOID
    );

BOOLEAN
ExpSemaphoreInitialization (
    VOID
    );

BOOLEAN
ExpTimerInitialization (
    VOID
    );

BOOLEAN
ExpWin32Initialization (
    VOID
    );

BOOLEAN
ExpResourceInitialization (
    VOID
    );

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    );

BOOLEAN
ExpInitSystemPhase0 (
    VOID
    );

BOOLEAN
ExpInitSystemPhase1 (
    VOID
    );

BOOLEAN
ExpProfileInitialization (
    );

BOOLEAN
ExpUuidInitialization (
    );

VOID
ExpProfileDelete (
    IN PVOID Object
    );


BOOLEAN
ExpInitializeCallbacks (
    VOID
    );

BOOLEAN
ExpSysEventInitialization (
    VOID
    );

VOID
ExpCheckSystemInfoWork (
    IN PVOID Context
    );

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    );

VOID
ExpCheckSystemInformation (
    PVOID Context,
    PVOID InformationClass,
    PVOID Argument2
    );


VOID
ExpTimeZoneWork (
    IN PVOID Context
    );

VOID
ExpTimeRefreshDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExpTimeRefreshWork (
    IN PVOID Context
    );

VOID
ExpTimeZoneDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExInitializeTimeRefresh (
    VOID
    );

VOID
ExpCheckForWorker (
    IN PVOID p,
    IN SIZE_T Size
    );

VOID
ExpShutdownWorkerThreads (
    VOID
    );

BOOLEAN
ExpSystemOK (
    IN int     safelevel,
    IN BOOLEAN evalflag
    );

#if defined(_WIN64)

NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    );

#endif

NTSTATUS
ExpGetSystemProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    );

NTSTATUS
ExApplyCodePatch (
    IN PVOID PatchInfoPtr,
    IN SIZE_T PatchSize
    );

VOID
ExpInitializePushLocks (
    VOID
    );

ULONG ExpNtExpirationData[3];
BOOLEAN ExpSetupModeDetected;
LARGE_INTEGER ExpSetupSystemPrefix;
HANDLE ExpSetupKey;
BOOLEAN ExpSystemPrefixValid;

#ifdef _PNP_POWER_

extern WORK_QUEUE_ITEM ExpCheckSystemInfoWorkItem;
extern LONG ExpCheckSystemInfoBusy;
extern const WCHAR ExpWstrSystemInformation[];
extern const WCHAR ExpWstrSystemInformationValue[];

#endif // _PNP_POWER_

extern const WCHAR ExpWstrCallback[];
extern const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[];

extern BOOLEAN ExpInTextModeSetup;
extern BOOLEAN ExpTooLateForErrors;

extern FAST_MUTEX ExpEnvironmentLock;
extern ERESOURCE ExpKeyManipLock;

extern GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];
extern GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

extern LIST_ENTRY ExNPagedLookasideListHead;
extern KSPIN_LOCK ExNPagedLookasideLock;
extern LIST_ENTRY ExPagedLookasideListHead;
extern KSPIN_LOCK ExPagedLookasideLock;
extern LIST_ENTRY ExPoolLookasideListHead;
extern PEPROCESS ExpDefaultErrorPortProcess;
extern HANDLE ExpDefaultErrorPort;
extern HANDLE ExpProductTypeKey;
extern PVOID ExpControlKey[2];
extern LIST_ENTRY ExpFirmwareTableProviderListHead;
extern ERESOURCE  ExpFirmwareTableResource;

#endif // _EXP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\exdata.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exdata.c

Abstract:

    This module contains the global read/write data for the I/O system.

--*/

#include "exp.h"

//
// Executive callbacks.
//

PCALLBACK_OBJECT ExCbSetSystemTime;
PCALLBACK_OBJECT ExCbSetSystemState;
PCALLBACK_OBJECT ExCbPowerState;

#ifdef _PNP_POWER_

//
// Work Item to scan SystemInformation levels
//

WORK_QUEUE_ITEM ExpCheckSystemInfoWorkItem;

#endif


//
// Pageable data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

#ifdef _PNP_POWER_

const WCHAR ExpWstrSystemInformation[] = L"Control\\System Information";
const WCHAR ExpWstrSystemInformationValue[] = L"Value";

#endif

//
// Initialization time data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const WCHAR ExpWstrCallback[] = L"\\Callback";

const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[] = {
    &ExCbSetSystemTime,             L"\\Callback\\SetSystemTime",
    &ExCbSetSystemState,            L"\\Callback\\SetSystemState",
    &ExCbPowerState,                L"\\Callback\\PowerState",
    NULL,                           NULL
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

#ifdef _PNP_POWER_

LONG ExpCheckSystemInfoBusy = 0;

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\exinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exinit.c

Abstract:

    The module contains the the initialization code for the executive
    component. It also contains the display string and shutdown system
    services.

--*/

#include "exp.h"
#include <zwapi.h>
#include <inbv.h>
#include "safeboot.h"

#pragma alloc_text(INIT, ExInitPoolLookasidePointers)
#pragma alloc_text(INIT, ExInitSystem)
#pragma alloc_text(INIT, ExpInitSystemPhase0)
#pragma alloc_text(INIT, ExpInitSystemPhase1)
#pragma alloc_text(INIT, ExComputeTickCountMultiplier)
#pragma alloc_text(PAGE, NtShutdownSystem)
#pragma alloc_text(PAGE, ExSystemExceptionFilter)
#pragma alloc_text(INIT, ExInitializeSystemLookasideList)

//
// Tick count multiplier.
//

ULONG ExpTickCountMultiplier;
ULONG ExpHydraEnabled;
static ULONG ExpSuiteMask;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

VOID
ExInitPoolLookasidePointers (
    VOID
    )

/*++

Routine Description:

    This function initializes the PRCB lookaside pointers to temporary
    values that will be updated during phase 1 initialization.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    PKPRCB Prcb;

    //
    // Initialize the paged and nonpaged small pool lookaside list
    // pointers in the PRCB to temporarily point to the global pool
    // lookaside lists. During phase 1 initialization per processor
    // lookaside lists are allocated and the pointer to these lists
    // are established in the PRCB of each processor.
    //

    Prcb = KeGetCurrentPrcb();
    for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {
        Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
        ExInitializeSListHead(&Lookaside->ListHead);
        Prcb->PPNPagedLookasideList[Index].P = Lookaside;
        Prcb->PPNPagedLookasideList[Index].L = Lookaside;

        Lookaside = &ExpSmallPagedPoolLookasideLists[Index];
        ExInitializeSListHead(&Lookaside->ListHead);
        Prcb->PPPagedLookasideList[Index].P = Lookaside;
        Prcb->PPPagedLookasideList[Index].L = Lookaside;
    }

    return;
}

BOOLEAN
ExInitSystem (
    VOID
    )

/*++

Routine Description:

    This function initializes the executive component of the NT system.
    It will perform Phase 0 or Phase 1 initialization as appropriate.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is success. Otherwise
    a value of FALSE is returned.

--*/

{
    switch ( InitializationPhase ) {

    case 0:
        (void) ExpSystemOK(0, FALSE);
        return ExpInitSystemPhase0();
    case 1:
        (void) ExpSystemOK(1, TRUE);
        return ExpInitSystemPhase1();
    default:
        KeBugCheckEx(UNEXPECTED_INITIALIZATION_CALL, 3, InitializationPhase, 0, 0);
    }
}

BOOLEAN
ExpInitSystemPhase0 (
    VOID
    )

/*++

Routine Description:

    This function performs Phase 0 initialization of the executive component
    of the NT system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is success. Otherwise
    a value of FALSE is returned.

--*/

{

    ULONG Index;
    BOOLEAN Initialized = TRUE;
    PGENERAL_LOOKASIDE Lookaside;

    //
    // Initialize Resource objects, currently required during SE
    // Phase 0 initialization.
    //

    if (ExpResourceInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Resource initialization failed\n"));
    }

    //
    // Initialize query/set environment variable synchronization fast
    // mutex.
    //

    ExInitializeFastMutex(&ExpEnvironmentLock);

    //
    // Initialize the key manipulation resource.
    //

    ExInitializeResourceLite(&ExpKeyManipLock);

    //
    // Initialize the paged and nonpaged small pool lookaside structures,
    //

    InitializeListHead(&ExPoolLookasideListHead);
    for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {
        Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
        ExInitializeSystemLookasideList(Lookaside,
                                        NonPagedPool,
                                        (Index + 1) * sizeof (POOL_BLOCK),
                                        'looP',
                                        256,
                                        &ExPoolLookasideListHead);

        Lookaside = &ExpSmallPagedPoolLookasideLists[Index];
        ExInitializeSystemLookasideList(Lookaside,
                                        PagedPool,
                                        (Index + 1) * sizeof (POOL_BLOCK),
                                        'looP',
                                        256,
                                        &ExPoolLookasideListHead);
    }

    //
    // Initialize the nonpaged and paged system lookaside lists.
    //

    InitializeListHead(&ExNPagedLookasideListHead);
    KeInitializeSpinLock(&ExNPagedLookasideLock);
    InitializeListHead(&ExPagedLookasideListHead);
    KeInitializeSpinLock(&ExPagedLookasideLock);

    //
    // Initialize the system paged and nonpaged lookaside list.
    //

    InitializeListHead(&ExSystemLookasideListHead);

    //
    // Initialize the Firmware table provider list
    //
    InitializeListHead(&ExpFirmwareTableProviderListHead);

    //
    // Initialize the FirmwareTableProvider resource
    //
    ExInitializeResourceLite(&ExpFirmwareTableResource);
    
    return ExpSystemOK(2, Initialized);
}

BOOLEAN
ExpInitSystemPhase1 (
    VOID
    )

/*++

Routine Description:

    This function performs Phase 1 initialization of the executive component
    of the NT system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization succeeded.  Otherwise
    a value of FALSE is returned.

--*/

{

    ULONG Index;
    BOOLEAN Initialized = TRUE;
    ULONG List;
    PGENERAL_LOOKASIDE Lookaside;
    PKPRCB Prcb;

    //
    // Initialize the ATOM package
    //

    RtlInitializeAtomPackage( 'motA' );

    //
    // Initialize pushlocks.
    //

    ExpInitializePushLocks ();

    //
    // Initialize the worker threads.
    //

    if (!NT_SUCCESS (ExpWorkerInitialization())) {
        Initialized = FALSE;
        KdPrint(("Executive: Worker thread initialization failed\n"));
    }

    //
    // Initialize the executive objects.
    //

    if (ExpEventInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Event initialization failed\n"));
    }

    if (ExpEventPairInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Event Pair initialization failed\n"));
    }

    if (ExpMutantInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Mutant initialization failed\n"));
    }
    if (ExpInitializeCallbacks() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Callback initialization failed\n"));
    }

    if (ExpSemaphoreInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Semaphore initialization failed\n"));
    }

    if (ExpTimerInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Timer initialization failed\n"));
    }

    if (ExpProfileInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Profile initialization failed\n"));
    }

    if (ExpUuidInitialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Uuid initialization failed\n"));
    }

    if (!NT_SUCCESS (ExpKeyedEventInitialization ())) {
        Initialized = FALSE;
        KdPrint(("Executive: Keyed event initialization failed\n"));
    }

    if (ExpWin32Initialization() == FALSE) {
        Initialized = FALSE;
        KdPrint(("Executive: Win32 initialization failed\n"));
    }

    //
    // Initialize per processor paged and nonpaged pool lookaside lists.
    //

    for (Index = 0; Index < (ULONG)KeNumberProcessors; Index += 1) {
        Prcb = KiProcessorBlock[Index];

        //
        // Allocate all of the lookaside list structures at once so they will
        // be dense and aligned properly.
        //

        Lookaside =  ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(GENERAL_LOOKASIDE) * POOL_SMALL_LISTS * 2,
                                           'LooP');

        //
        // If the allocation succeeded, then initialize and fill in the new
        // per processor lookaside structures. Otherwise, use the default
        // structures initialized during phase zero.
        //

        if (Lookaside != NULL) {
            for (List = 0; List < POOL_SMALL_LISTS; List += 1) {
                ExInitializeSystemLookasideList(Lookaside,
                                                NonPagedPool,
                                                (List + 1) * sizeof (POOL_BLOCK),
                                                'LooP',
                                                256,
                                                &ExPoolLookasideListHead);
    
                Prcb->PPNPagedLookasideList[List].P = Lookaside;
                Lookaside += 1;
  
                ExInitializeSystemLookasideList(Lookaside,
                                                PagedPool,
                                                (List + 1) * sizeof (POOL_BLOCK),
                                                'LooP',
                                                256,
                                                &ExPoolLookasideListHead);
    
                Prcb->PPPagedLookasideList[List].P = Lookaside;
                Lookaside += 1;
            }
        }
    }

    return Initialized;
}

ULONG
ExComputeTickCountMultiplier (
    IN ULONG TimeIncrement
    )

/*++

Routine Description:

    This routine computes the tick count multiplier that is used to
    compute a tick count value.

Arguments:

    TimeIncrement - Supplies the clock increment value in 100ns units.

Return Value:

    A scaled integer/fraction value is returned as the function result.

--*/

{

    ULONG FractionPart;
    ULONG IntegerPart;
    ULONG Index;
    ULONG Remainder;

    //
    // Compute the integer part of the tick count multiplier.
    //
    // The integer part is the whole number of milliseconds between
    // clock interrupts. It is assumed that this value is always less
    // than 128.
    //

    IntegerPart = TimeIncrement / (10 * 1000);

    //
    // Compute the fraction part of the tick count multiplier.
    //
    // The fraction part is the fraction milliseconds between clock
    // interrupts and is computed to an accuracy of 24 bits.
    //

    Remainder = TimeIncrement - (IntegerPart * (10 * 1000));
    FractionPart = 0;
    for (Index = 0; Index < 24; Index += 1) {
        FractionPart <<= 1;
        Remainder <<= 1;
        if (Remainder >= (10 * 1000)) {
            Remainder -= (10 * 1000);
            FractionPart |= 1;
        }
    }

    //
    // The tick count multiplier is equal to the integer part shifted
    // left by 24 bits and added to the 24 bit fraction.
    //

    return (IntegerPart << 24) | FractionPart;
}

NTSTATUS
NtShutdownSystem (
    __in SHUTDOWN_ACTION Action
    )

/*++

Routine Description:

    This service is used to safely shutdown the system.

    N.B. The caller must have SeShutdownPrivilege to shut down the
        system.

Arguments:

    Action - Supplies an action that is to be taken after having shutdown.

Return Value:

    !NT_SUCCESS - The operation failed or the caller did not have appropriate
        privileges.

--*/

{
    POWER_ACTION        SystemAction;
    NTSTATUS            Status;

    //
    // Convert shutdown action to system action
    //

    switch (Action) {
        case ShutdownNoReboot:  SystemAction = PowerActionShutdown;         break;
        case ShutdownReboot:    SystemAction = PowerActionShutdownReset;    break;
        case ShutdownPowerOff:  SystemAction = PowerActionShutdownOff;      break;
        default:
            return STATUS_INVALID_PARAMETER;
    }

    //
    // Bypass policy manager and pass directly to SetSystemPowerState
    //

    Status = NtSetSystemPowerState (
                SystemAction,
                PowerSystemSleeping3,
                POWER_ACTION_OVERRIDE_APPS | POWER_ACTION_DISABLE_WAKES | POWER_ACTION_CRITICAL
                );

    return Status;
}


int
ExSystemExceptionFilter( VOID )
{
    return( KeGetPreviousMode() != KernelMode ? EXCEPTION_EXECUTE_HANDLER
                                            : EXCEPTION_CONTINUE_SEARCH
          );
}



NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    )

/*++

Routine Description:

    Returns previous mode.  This routine is exported from the kernel so
    that drivers can call it, as they may have to do probing of
    embedded pointers to user structures on IOCTL calls that the I/O
    system can't probe for them on the FastIo path, which does not pass
    previous mode via the FastIo parameters.

Arguments:

    None.

Return Value:

    return-value - Either KernelMode or UserMode

--*/

{
    return KeGetPreviousMode();
}

VOID
ExInitializeSystemLookasideList (
    IN PGENERAL_LOOKASIDE Lookaside,
    IN POOL_TYPE Type,
    IN ULONG Size,
    IN ULONG Tag,
    IN USHORT Depth,
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    This function initializes a system lookaside list structure and inserts
    the structure in the specified lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Type - Supplies the pool type of the lookaside list.

    Size - Supplies the size of the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

    ListHead - Supplies a pointer to the lookaside list into which the
        lookaside list structure is to be inserted.

Return Value:

    None.

--*/

{

    //
    // Initialize pool lookaside list structure and insert the structure
    // in the pool lookaside list.
    //

    ExInitializeSListHead(&Lookaside->ListHead);
    Lookaside->Allocate = &ExAllocatePoolWithTag;
    Lookaside->Free = &ExFreePool;
    Lookaside->Depth = 2;
    Lookaside->MaximumDepth = Depth;
    Lookaside->TotalAllocates = 0;
    Lookaside->AllocateHits = 0;
    Lookaside->TotalFrees = 0;
    Lookaside->FreeHits = 0;
    Lookaside->Type = Type;
    Lookaside->Tag = Tag;
    Lookaside->Size = Size;
    Lookaside->LastTotalAllocates = 0;
    Lookaside->LastAllocateHits = 0;
    InsertTailList(ListHead, &Lookaside->ListEntry);
    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\keyedevent.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    keyedevent.c

Abstract:

    This module houses routines that do keyed event processing.

--*/

#include "exp.h"
#pragma hdrstop

#pragma alloc_text(INIT, ExpKeyedEventInitialization)
#pragma alloc_text(PAGE, NtCreateKeyedEvent)
#pragma alloc_text(PAGE, NtOpenKeyedEvent)
#pragma alloc_text(PAGE, NtReleaseKeyedEvent)
#pragma alloc_text(PAGE, NtWaitForKeyedEvent)

//
// Define the keyed event object type
//
typedef struct _KEYED_EVENT_OBJECT {
    EX_PUSH_LOCK Lock;
    LIST_ENTRY WaitQueue;
} KEYED_EVENT_OBJECT, *PKEYED_EVENT_OBJECT;

POBJECT_TYPE ExpKeyedEventObjectType;

//
// The low bit of the keyvalue signifies that we are a release thread waiting
// for the wait thread to enter the keyed event code.
//

#define KEYVALUE_RELEASE 1

#define LOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    KeEnterCriticalRegionThread (&(xxxCurrentThread)->Tcb);                \
    ExAcquirePushLockExclusive (&(xxxKeyedEventObject)->Lock);             \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);               \
    KeLeaveCriticalRegionThread (&(xxxCurrentThread)->Tcb);                  \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE(xxxKeyedEventObject) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);     \
}

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    )

/*++

Routine Description:

    Initialize the keyed event objects and globals.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    OBJECT_ATTRIBUTES oa;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Dacl;
    ULONG DaclLength;
    HANDLE KeyedEventHandle;
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | KEYEDEVENT_WAIT,
                                      STANDARD_RIGHTS_WRITE | KEYEDEVENT_WAKE,
                                      STANDARD_RIGHTS_EXECUTE,
                                      KEYEDEVENT_ALL_ACCESS};


    PAGED_CODE ();

    RtlInitUnicodeString (&Name, L"KeyedEvent");

    oti.Length                    = sizeof (oti);
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = PagedPool;
    oti.ValidAccessMask           = KEYEDEVENT_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;
    oti.UseDefaultObject          = TRUE;

    Status = ObCreateObjectType (&Name, &oti, NULL, &ExpKeyedEventObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Create a global object for processes that are out of memory
    //

    Status = RtlCreateSecurityDescriptor (&SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    DaclLength = sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) * 3 +
                 RtlLengthSid (SeLocalSystemSid) +
                 RtlLengthSid (SeAliasAdminsSid) +
                 RtlLengthSid (SeWorldSid);

    Dacl = ExAllocatePoolWithTag (PagedPool, DaclLength, 'lcaD');

    if (Dacl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlCreateAcl (Dacl, DaclLength, ACL_REVISION);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_WAIT|KEYEDEVENT_WAKE|READ_CONTROL,
                                     SeWorldSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeAliasAdminsSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeLocalSystemSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

  
    Status = RtlSetDaclSecurityDescriptor (&SecurityDescriptor,
                                           TRUE,
                                           Dacl,
                                           FALSE);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    RtlInitUnicodeString (&Name, L"\\KernelObjects\\CritSecOutOfMemoryEvent");
    InitializeObjectAttributes (&oa, &Name, OBJ_PERMANENT, NULL, &SecurityDescriptor);
    Status = ZwCreateKeyedEvent (&KeyedEventHandle,
                                 KEYEDEVENT_ALL_ACCESS,
                                 &oa,
                                 0);
    ExFreePool (Dacl);
    if (NT_SUCCESS (Status)) {
        Status = ZwClose (KeyedEventHandle);
    }

    return Status;
}

NTSTATUS
NtCreateKeyedEvent (
    __out PHANDLE KeyedEventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in ULONG Flags
    )

/*++

Routine Description:

    Create a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Create a new keyed event object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             ExpKeyedEventObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (KEYED_EVENT_OBJECT),
                             0,
                             0,
                             &KeyedEventObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the lock and wait queue
    //
    ExInitializePushLock (&KeyedEventObject->Lock);
    InitializeListHead (&KeyedEventObject->WaitQueue);

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (KeyedEventObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *KeyedEventHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the memory for the handle.
        // No point closing the handle as process rundown will do that and we don't
        // know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

NTSTATUS
NtOpenKeyedEvent (
    __out PHANDLE KeyedEventHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    Open a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/

{
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Open handle to the keyed event object with the specified desired access.
    //

    Status = ObOpenObjectByName (ObjectAttributes,
                                 ExpKeyedEventObjectType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle);

    if (NT_SUCCESS (Status)) {
        try {
            *KeyedEventHandle = Handle;
        } except (ExSystemExceptionFilter ()) {
            Status = GetExceptionCode ();
        }
    }

    return Status;
}

NTSTATUS
NtReleaseKeyedEvent (
    __in HANDLE KeyedEventHandle,
    __in PVOID KeyValue,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    Release a previous or soon to be waiter with a matching key

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the waiter against

    Alertable - Should the wait be alertable, we rarely should have to wait

    Timeout   - Timeout value for the wait, waits should be rare

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue = NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAKE,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT (CurrentThread->KeyedEventInUse == 0);
    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 1;

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        if (ListEntry == ListHead) {
            //
            // We could not find a key matching ours in the list.
            // Either somebody called us with wrong values or the waiter
            // has not managed to get queued yet. We wait ourselves
            // to be released by the waiter.
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = (PVOID) (((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE);
            //
            // Insert the thread at the head of the list. We establish an invariant
            // were release waiters are always at the front of the queue to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertHeadList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
            if (TargetThread->KeyedWaitValue == KeyValue &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread != NULL) {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    } else {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);

        //
        // If we were woken by termination then we must manually remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    }

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 0;

    ObDereferenceObject (KeyedEventObject);

    return Status;
}

NTSTATUS
NtWaitForKeyedEvent (
    __in HANDLE KeyedEventHandle,
    __in PVOID KeyValue,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    Wait on the keyed event for a specific release

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the release thread against

    Alertable - Makes the wait alertable or not

    Timeout - Timeout value for wait

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue=NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAIT,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT (CurrentThread->KeyedEventInUse == 0);
    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 1;

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
        if (ListEntry == ListHead ||
            (((ULONG_PTR)(TargetThread->KeyedWaitValue))&KEYVALUE_RELEASE) == 0) {
            //
            // We could not find a key matching ours in the list so we must wait
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = KeyValue;

            //
            // Insert the thread at the tail of the list. We establish an invariant
            // were waiters are always at the back of the queue behind releasers to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertTailList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            if (TargetThread->KeyedWaitValue == (PVOID)(((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE) &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }
    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread == NULL) {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        //
        // If we were woken by termination then we must manually remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    } else {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 0;

    ObDereferenceObject (KeyedEventObject);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\harderr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    harderr.c

Abstract:

    This module implements NT Hard Error APIs

--*/

#include "exp.h"

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    );

#if defined(_AMD64_)

VOID
ExpSystemErrorHandler2 (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    );

#endif

#pragma alloc_text(PAGE, NtRaiseHardError)
#pragma alloc_text(PAGE, NtSetDefaultHardErrorPort)
#pragma alloc_text(PAGE, ExRaiseHardError)
#pragma alloc_text(PAGE, ExpRaiseHardError)
#pragma alloc_text(PAGELK, ExpSystemErrorHandler)

#define HARDERROR_MSG_OVERHEAD (sizeof(HARDERROR_MSG) - sizeof(PORT_MESSAGE))
#define HARDERROR_API_MSG_LENGTH \
            sizeof(HARDERROR_MSG)<<16 | (HARDERROR_MSG_OVERHEAD)

PEPROCESS ExpDefaultErrorPortProcess;

#define STARTING 0
#define STARTED 1
#define SHUTDOWN 2

BOOLEAN ExReadyForErrors = FALSE;

ULONG HardErrorState = STARTING;
BOOLEAN ExpTooLateForErrors = FALSE;
HANDLE ExpDefaultErrorPort;

extern PVOID PsSystemDllDllBase;

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

#if defined(_AMD64_)

VOID
ExpSystemErrorHandler2 (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    )

#else

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    )

#endif

{
    ULONG Counter;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG_PTR ParameterVector[MAXIMUM_HARDERROR_PARAMETERS];
    CHAR DefaultFormatBuffer[32];
    CHAR ExpSystemErrorBuffer[256];
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PSZ ErrorCaption;
    CHAR const* ErrorFormatString;
    ANSI_STRING Astr;
    UNICODE_STRING Ustr;
    OEM_STRING Ostr;
    PSZ OemCaption;
    PSZ OemMessage;
    static char const* UnknownHardError = "Unknown Hard Error";

    PAGED_CODE();

#if !defined(_AMD64_)

    //
    // This handler is called whenever a hard error occurs before the
    // default handler has been installed.
    //
    // This is done regardless of whether or not the process has chosen
    // default hard error processing.
    //

    //
    // Capture the callers context as closely as possible into the debugger's
    // processor state area of the Prcb
    //
    // N.B. There may be some prologue code that shuffles registers such that
    //      they get destroyed.
    //
    // This code is here only for crash dumps.
    //

    RtlCaptureContext (&KeGetCurrentPrcb()->ProcessorState.ContextFrame);
    KiSaveProcessorControlState (&KeGetCurrentPrcb()->ProcessorState);

#endif

    DefaultFormatBuffer[0] = '\0';
    RtlZeroMemory (ParameterVector, sizeof(ParameterVector));

    RtlCopyMemory (ParameterVector, Parameters, NumberOfParameters * sizeof (ULONG_PTR));

    for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

        if (UnicodeStringParameterMask & 1 << Counter) {

            strcat(DefaultFormatBuffer," %s");

            Status = RtlUnicodeStringToAnsiString (&AnsiString,
                                                   (PUNICODE_STRING)Parameters[Counter],
                                                   TRUE);
            if (NT_SUCCESS (Status)) {

                ParameterVector[Counter] = (ULONG_PTR)AnsiString.Buffer;
            } else {
                ParameterVector[Counter] = (ULONG_PTR)L"???";
            }
        }
        else {
            strcat(DefaultFormatBuffer," %x");
        }
    }

    strcat(DefaultFormatBuffer,"\n");

    ErrorFormatString = (char const *)DefaultFormatBuffer;
    ErrorCaption = (PSZ) UnknownHardError;

    if (PsSystemDllDllBase != NULL) {

        try {

            //
            // If we are on a DBCS code page, we have to use ENGLISH resource
            // instead of default resource because HalDisplayString() can only
            // display ASCII characters on the blue screen.
            //

            Status = RtlFindMessage (PsSystemDllDllBase,
                                     11,
                                     NlsMbCodePageTag ?
                                     MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) :
                                     0,
                                     ErrorStatus,
                                     &MessageEntry);

            if (!NT_SUCCESS(Status)) {
                ErrorCaption = (PSZ) UnknownHardError;
                ErrorFormatString = (char const *)UnknownHardError;
            }
            else {
                if (MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

                    //
                    // Message resource is Unicode.  Convert to ANSI.
                    //

                    RtlInitUnicodeString (&Ustr, (PCWSTR)MessageEntry->Text);
                    Astr.Length = (USHORT) RtlUnicodeStringToAnsiSize (&Ustr);

                    ErrorCaption = ExAllocatePoolWithTag (NonPagedPool,
                                                          Astr.Length+16,
                                                          ' rrE');

                    if (ErrorCaption != NULL) {
                        Astr.MaximumLength = Astr.Length + 16;
                        Astr.Buffer = ErrorCaption;
                        Status = RtlUnicodeStringToAnsiString(&Astr, &Ustr, FALSE);
                        if (!NT_SUCCESS(Status)) {
                            ExFreePool(ErrorCaption);
                            ErrorCaption = (PSZ) UnknownHardError;
                            ErrorFormatString = (char const *)UnknownHardError;
                        }
                    }
                    else {
                        ErrorCaption = (PSZ) UnknownHardError;
                        ErrorFormatString = (char const *) UnknownHardError;
                    }
                }
                else {
                    ErrorCaption = ExAllocatePoolWithTag(NonPagedPool,
                                    strlen((PCHAR)MessageEntry->Text)+16,
                                    ' rrE');

                    if (ErrorCaption != NULL) {
                        strcpy(ErrorCaption,(PCHAR)MessageEntry->Text);
                    }
                    else {
                        ErrorFormatString = (char const *)UnknownHardError;
                        ErrorCaption = (PSZ) UnknownHardError;
                    }
                }

                if (ErrorCaption != UnknownHardError) {

                    //
                    // It's assumed the Error String from the message table
                    // is in the format:
                    //
                    // {ErrorCaption}\r\n\0ErrorFormatString\0.
                    //
                    // Parse out the caption.
                    //

                    ErrorFormatString = ErrorCaption;
                    Counter = (ULONG) strlen(ErrorCaption);

                    while (Counter && *ErrorFormatString >= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }

                    *(char*)ErrorFormatString++ = '\0';
                    Counter -= 1;

                    while (Counter && *ErrorFormatString && *ErrorFormatString <= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }
                }

                if (!Counter) {
                    // Bad Format String.
                    ErrorFormatString = (char const *)"";
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorFormatString = (char const *)UnknownHardError;
            ErrorCaption = (PSZ) UnknownHardError;
        }
    }

    try {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nSTOP: %lx %s\n",
                   ErrorStatus,
                   ErrorCaption);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nHardError %lx\n",
                   ErrorStatus);
    }

    ASSERT(ExPageLockHandle);
    MmLockPageableSectionByHandle(ExPageLockHandle);

    //
    // Take the caption and convert it to OEM.
    //

    OemCaption = (PSZ) UnknownHardError;
    OemMessage = (PSZ) UnknownHardError;

    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);

    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt1;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT)RtlUnicodeStringToOemSize(&Ustr);
    Ostr.MaximumLength = Ostr.Length;
    Ostr.Buffer = ExAllocatePoolWithTag(NonPagedPool, Ostr.Length, ' rrE');
    OemCaption = Ostr.Buffer;

    if (Ostr.Buffer != NULL) {
        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto punt1;
        }
    }

    //
    // Can't do much of anything after calling HalDisplayString...
    //

punt1:

    try {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   (const char *)ErrorFormatString,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   "Exception Processing Message %lx Parameters %lx %lx %lx %lx",
                   ErrorStatus,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }


    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);
    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt2;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT) RtlUnicodeStringToOemSize (&Ustr);
    Ostr.MaximumLength = Ostr.Length;

    Ostr.Buffer = ExAllocatePoolWithTag (NonPagedPool, Ostr.Length, ' rrE');

    OemMessage = Ostr.Buffer;

    if (Ostr.Buffer) {

        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);

        if (!NT_SUCCESS(Status)) {
            goto punt2;
        }
    }

punt2:

    ASSERT (sizeof(PVOID) == sizeof(ULONG_PTR));
    ASSERT (sizeof(ULONG) == sizeof(NTSTATUS));

    //
    // We don't come back from here.
    //

    if (CallShutdown) {

        PoShutdownBugCheck (TRUE,
                            FATAL_UNHANDLED_HARD_ERROR,
                            (ULONG)ErrorStatus,
                            (ULONG_PTR)&(ParameterVector[0]),
                            (ULONG_PTR)OemCaption,
                            (ULONG_PTR)OemMessage);

    }
    else {

        KeBugCheckEx (FATAL_UNHANDLED_HARD_ERROR,
                      (ULONG)ErrorStatus,
                      (ULONG_PTR)&(ParameterVector[0]),
                      (ULONG_PTR)OemCaption,
                      (ULONG_PTR)OemMessage);
    }
}

#ifdef _X86_
#pragma optimize("", on)
#endif

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    PTEB Teb;
    PETHREAD Thread;
    PEPROCESS Process;
    ULONG_PTR MessageBuffer[PORT_TOTAL_MAXIMUM_MESSAGE_LENGTH/sizeof(ULONG_PTR)];
    PHARDERROR_MSG m;
    NTSTATUS Status;
    HANDLE ErrorPort;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN DoingShutdown;

    PAGED_CODE();

    m = (PHARDERROR_MSG)&MessageBuffer[0];
    PreviousMode = KeGetPreviousMode();

    DoingShutdown = FALSE;

    if (ValidResponseOptions == OptionShutdownSystem) {

        //
        // Check to see if the caller has the privilege to make this call.
        //

        if (!SeSinglePrivilegeCheck (SeShutdownPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        ExReadyForErrors = FALSE;
        HardErrorState = SHUTDOWN;
        DoingShutdown = TRUE;
    }

    Thread = PsGetCurrentThread();
    Process = PsGetCurrentProcess();

    //
    // If the default handler is not installed, then
    // call the fatal hard error handler if the error
    // status is error
    //
    // Let GDI override this since it does not want to crash the machine
    // when a bad driver was loaded via MmLoadSystemImage.
    //

    if ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0) {

        if (NT_ERROR(ErrorStatus) && (HardErrorState == STARTING || DoingShutdown)) {

            ExpSystemErrorHandler (
                ErrorStatus,
                NumberOfParameters,
                UnicodeStringParameterMask,
                Parameters,
                (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
    }

    //
    // If the process has an error port, then if it wants default
    // handling, use its port. If it disabled default handling, then
    // return the error to the caller. If the process does not
    // have a port, then use the registered default handler.
    //

    ErrorPort = NULL;

    if (Process->ExceptionPort) {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = Process->ExceptionPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = Process->ExceptionPort;
            }
        }
    } else {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = ExpDefaultErrorPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = ExpDefaultErrorPort;
            }
        }
    }

    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) {
        ErrorPort = NULL;
    }

    if ((ErrorPort != NULL) && (!IS_SYSTEM_THREAD(Thread))) {
        Teb = (PTEB)PsGetCurrentThread()->Tcb.Teb;
        try {
            if (Teb->HardErrorMode & RTL_ERRORMODE_FAILCRITICALERRORS) {
                ErrorPort = NULL;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    if (ErrorPort == NULL) {
        *Response = (ULONG)ResponseReturnToCaller;
        return STATUS_SUCCESS;
    }

    if (Process == ExpDefaultErrorPortProcess) {
        if (NT_ERROR(ErrorStatus)) {
            ExpSystemErrorHandler (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
        *Response = (ULONG)ResponseReturnToCaller;
        Status = STATUS_SUCCESS;
        return Status;
    }

    m->h.u1.Length = HARDERROR_API_MSG_LENGTH;
    m->h.u2.ZeroInit = LPC_ERROR_EVENT;
    m->Status = ErrorStatus & ~HARDERROR_OVERRIDE_ERRORMODE;
    m->ValidResponseOptions = ValidResponseOptions;
    m->UnicodeStringParameterMask = UnicodeStringParameterMask;
    m->NumberOfParameters = NumberOfParameters;

    if (Parameters != NULL) {
        try {
            RtlCopyMemory (&m->Parameters,
                           Parameters,
                           sizeof(ULONG_PTR)*NumberOfParameters);
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    KeQuerySystemTime(&m->ErrorTime);

    Status = LpcRequestWaitReplyPortEx (ErrorPort,
                                        (PPORT_MESSAGE) m,
                                        (PPORT_MESSAGE) m);

    if (NT_SUCCESS(Status)) {
        switch (m->Response) {
            case ResponseReturnToCaller :
            case ResponseNotHandled :
            case ResponseAbort :
            case ResponseCancel :
            case ResponseIgnore :
            case ResponseNo :
            case ResponseOk :
            case ResponseRetry :
            case ResponseYes :
            case ResponseTryAgain :
            case ResponseContinue :
                break;
            default:
                m->Response = (ULONG)ResponseReturnToCaller;
                break;
        }
        *Response = m->Response;
    }

    return Status;
}

NTSTATUS
NtRaiseHardError (
    __in NTSTATUS ErrorStatus,
    __in ULONG NumberOfParameters,
    __in ULONG UnicodeStringParameterMask,
    __in_ecount(NumberOfParameters) PULONG_PTR Parameters,
    __in ULONG ValidResponseOptions,
    __out PULONG Response
    )
{
    NTSTATUS Status;
    ULONG_PTR CapturedParameters[MAXIMUM_HARDERROR_PARAMETERS];
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalResponse;
    UNICODE_STRING CapturedString;
    ULONG Counter;

    PAGED_CODE();

    if (NumberOfParameters > MAXIMUM_HARDERROR_PARAMETERS) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (ARGUMENT_PRESENT(Parameters) && NumberOfParameters == 0) {
        return STATUS_INVALID_PARAMETER_2;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        switch (ValidResponseOptions) {
            case OptionAbortRetryIgnore :
            case OptionOk :
            case OptionOkCancel :
            case OptionRetryCancel :
            case OptionYesNo :
            case OptionYesNoCancel :
            case OptionShutdownSystem :
            case OptionOkNoWait :
            case OptionCancelTryContinue:
                break;
            default :
                return STATUS_INVALID_PARAMETER_4;
        }

        try {
            ProbeForWriteUlong(Response);

            if (ARGUMENT_PRESENT(Parameters)) {
                ProbeForRead (Parameters,
                              sizeof(ULONG_PTR)*NumberOfParameters,
                              sizeof(ULONG_PTR));

                RtlCopyMemory (CapturedParameters,
                               Parameters,
                               sizeof(ULONG_PTR)*NumberOfParameters);

                //
                // Probe all strings.
                //

                if (UnicodeStringParameterMask) {

                    for (Counter = 0;Counter < NumberOfParameters; Counter += 1) {

                        //
                        // if there is a string in this position,
                        // then probe and capture the string
                        //

                        if (UnicodeStringParameterMask & (1<<Counter)) {

                            ProbeForReadSmallStructure ((PVOID)CapturedParameters[Counter],
                                                        sizeof(UNICODE_STRING),
                                                        sizeof(ULONG_PTR));

                            RtlCopyMemory (&CapturedString,
                                           (PVOID)CapturedParameters[Counter],
                                           sizeof(UNICODE_STRING));

                            //
                            // Now probe the string
                            //

                            ProbeForRead (CapturedString.Buffer,
                                          CapturedString.MaximumLength,
                                          sizeof(UCHAR));
                        }
                    }
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if ((ErrorStatus == STATUS_SYSTEM_IMAGE_BAD_SIGNATURE) &&
            (KdDebuggerEnabled)) {

            if ((NumberOfParameters != 0) && (ARGUMENT_PRESENT(Parameters))) {
                DbgPrint("****************************************************************\n");
                DbgPrint("* The system detected a bad signature on file %wZ\n",(PUNICODE_STRING)CapturedParameters[0]);
                DbgPrint("****************************************************************\n");
            }
            return STATUS_SUCCESS;
        }

        //
        // Call ExpRaiseHardError. All parameters are probed and everything
        // should be user-mode.
        // ExRaiseHardError will squirt all strings into user-mode
        // without any probing
        //

        Status = ExpRaiseHardError (ErrorStatus,
                                    NumberOfParameters,
                                    UnicodeStringParameterMask,
                                    CapturedParameters,
                                    ValidResponseOptions,
                                    &LocalResponse);

        try {
            *Response = LocalResponse;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        Status = ExRaiseHardError (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   ValidResponseOptions,
                                   &LocalResponse);

        *Response = LocalResponse;
    }

    return Status;
}

NTSTATUS
ExRaiseHardError (
    __in NTSTATUS ErrorStatus,
    __in ULONG NumberOfParameters,
    __in ULONG UnicodeStringParameterMask,
    __in_ecount(NumberOfParameters) PULONG_PTR Parameters,
    __in ULONG ValidResponseOptions,
    __out PULONG Response
    )
{
    NTSTATUS Status;
    PULONG_PTR ParameterBlock;
    PULONG_PTR UserModeParameterBase;
    PUNICODE_STRING UserModeStringsBase;
    PUCHAR UserModeStringDataBase;
    UNICODE_STRING CapturedStrings[MAXIMUM_HARDERROR_PARAMETERS];
    ULONG LocalResponse;
    ULONG Counter;
    SIZE_T UserModeSize;

    PAGED_CODE();

    //
    // If we are in the process of shutting down the system, do not allow
    // hard errors.
    //

    if (ExpTooLateForErrors) {

        *Response = ResponseNotHandled;

        return STATUS_SUCCESS;
    }

    ParameterBlock = NULL;

    //
    // If the parameters contain strings, we need to capture
    // the strings and the string descriptors and push them into
    // user-mode.
    //

    if (ARGUMENT_PRESENT(Parameters)) {
        if (UnicodeStringParameterMask) {

            //
            // We have strings - push them into usermode.
            //

            UserModeSize = (sizeof(ULONG_PTR)+sizeof(UNICODE_STRING))*MAXIMUM_HARDERROR_PARAMETERS;
            UserModeSize += sizeof(UNICODE_STRING);

            for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                //
                // If there is a string in this position,
                // then probe and capture the string.
                //

                if (UnicodeStringParameterMask & 1<<Counter) {

                    RtlCopyMemory (&CapturedStrings[Counter],
                                   (PVOID)Parameters[Counter],
                                   sizeof(UNICODE_STRING));

                    UserModeSize += CapturedStrings[Counter].MaximumLength;
                }
            }

            //
            // Now we have the user-mode size all figured out.
            // Allocate some memory and point to it with the
            // parameter block. Then go through and copy all
            // of the parameters, string descriptors, and
            // string data into the memory.
            //

            Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
                                              (PVOID *)&ParameterBlock,
                                              0,
                                              &UserModeSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            UserModeParameterBase = ParameterBlock;
            UserModeStringsBase = (PUNICODE_STRING)((PUCHAR)ParameterBlock + sizeof(ULONG_PTR)*MAXIMUM_HARDERROR_PARAMETERS);
            UserModeStringDataBase = (PUCHAR)UserModeStringsBase + sizeof(UNICODE_STRING)*MAXIMUM_HARDERROR_PARAMETERS;
            try {

                for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                    //
                    // Copy parameters to user-mode portion of the address space.
                    //

                    if (UnicodeStringParameterMask & 1<<Counter) {

                        //
                        // Fix the parameter to point at the string descriptor slot
                        // in the user-mode buffer.
                        //

                        UserModeParameterBase[Counter] = (ULONG_PTR)&UserModeStringsBase[Counter];

                        //
                        // Copy the string data to user-mode.
                        //

                        RtlCopyMemory (UserModeStringDataBase,
                                       CapturedStrings[Counter].Buffer,
                                       CapturedStrings[Counter].MaximumLength);

                        CapturedStrings[Counter].Buffer = (PWSTR)UserModeStringDataBase;

                        //
                        // Copy the string descriptor.
                        //

                        RtlCopyMemory (&UserModeStringsBase[Counter],
                                       &CapturedStrings[Counter],
                                       sizeof(UNICODE_STRING));

                        //
                        // Adjust the string data base.
                        //

                        UserModeStringDataBase += CapturedStrings[Counter].MaximumLength;
                    }
                    else {
                        UserModeParameterBase[Counter] = Parameters[Counter];
                    }
                } 
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }
        else {
            ParameterBlock = Parameters;
        }
    }

    //
    // Call the hard error sender.
    //

    Status = ExpRaiseHardError (ErrorStatus,
                                NumberOfParameters,
                                UnicodeStringParameterMask,
                                ParameterBlock,
                                ValidResponseOptions,
                                &LocalResponse);

    //
    // If the parameter block was allocated, it needs to be freed.
    //

    if (ParameterBlock && ParameterBlock != Parameters) {
        UserModeSize = 0;
        ZwFreeVirtualMemory (NtCurrentProcess(),
                             (PVOID *)&ParameterBlock,
                             &UserModeSize,
                             MEM_RELEASE);
    }
    *Response = LocalResponse;

    return Status;
}

NTSTATUS
NtSetDefaultHardErrorPort (
    __in HANDLE DefaultHardErrorPort
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, KeGetPreviousMode())) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    if (HardErrorState == STARTED) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ObReferenceObjectByHandle (DefaultHardErrorPort,
                                        0,
                                        LpcPortObjectType,
                                        KeGetPreviousMode(),
                                        (PVOID *)&ExpDefaultErrorPort,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ExReadyForErrors = TRUE;
    HardErrorState = STARTED;
    ExpDefaultErrorPortProcess = PsGetCurrentProcess();
    ObReferenceObject (ExpDefaultErrorPortProcess);

    return STATUS_SUCCESS;
}

VOID
__cdecl
_purecall()
{
    ASSERTMSG("_purecall() was called", FALSE);
    ExRaiseStatus(STATUS_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\fmutexc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    fmutexc.c

Abstract:

    This module implements the code necessary to acquire and release fast
    mutexes.

--*/

#include "exp.h"

#undef ExAcquireFastMutex

VOID
FASTCALL
ExAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex and raises IRQL to
    APC Level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxAcquireFastMutex(FastMutex);
    return;
}

#undef ExReleaseFastMutex

VOID
FASTCALL
ExReleaseFastMutex (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex and lowers IRQL to
    its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxReleaseFastMutex(FastMutex);
    return;
}

#undef ExTryToAcquireFastMutex

BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function attempts to acquire ownership of a fast mutex, and if
    successful, raises IRQL to APC level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    If the fast mutex was successfully acquired, then a value of TRUE
    is returned as the function value. Otherwise, a value of FALSE is
    returned.

--*/

{

    return xxTryToAcquireFastMutex(FastMutex);
}

#undef ExAcquireFastMutexUnsafe

VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex, but does not raise
    IRQL to APC Level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxAcquireFastMutexUnsafe(FastMutex);
    return;
}

VOID
FASTCALL
ExEnterCriticalRegionAndAcquireFastMutexUnsafe (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function enters a critical region, acquires ownership of a fast
    mutex, but does not raise IRQL to APC Level.

    N.B. This is a win32 accelerator routine.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    KeEnterCriticalRegion();
    xxAcquireFastMutexUnsafe(FastMutex);
    return;
}

#undef ExReleaseFastMutexUnsafe

VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex, and does not restore
    IRQL to its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxReleaseFastMutexUnsafe(FastMutex);
    return;
}

VOID
FASTCALL
ExReleaseFastMutexUnsafeAndLeaveCriticalRegion (
    __inout PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex, does not restore IRQL
    to its previous level, and leaves a critical region.

    N.B. This is a win32 accelerator routine.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxReleaseFastMutexUnsafe(FastMutex);
    KeLeaveCriticalRegion();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\lookasid.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lookasid.c

Abstract:

    This module implements lookaside list functions.

--*/

#include "exp.h"

#pragma alloc_text(PAGE, ExInitializePagedLookasideList)

//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25

//
// Define forward referenced function prototypes.
//

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    );

VOID
ExpScanSystemLookasideList (
    VOID
    );

//
// Define the global nonpaged and paged lookaside list data.
//

LIST_ENTRY ExNPagedLookasideListHead;
KSPIN_LOCK ExNPagedLookasideLock;
LIST_ENTRY ExPagedLookasideListHead;
KSPIN_LOCK ExPagedLookasideLock;
LIST_ENTRY ExPoolLookasideListHead;
LIST_ENTRY ExSystemLookasideListHead;

//
// Define lookaside list dynamic adjustment data.
//

ULONG ExpPoolScanCount = 0;
ULONG ExpScanCount = 0;

//
// Lookasides are disabled (via the variable below) when the verifier is on.
//

USHORT ExMinimumLookasideDepth = MINIMUM_LOOKASIDE_DEPTH;

VOID
ExAdjustLookasideDepth (
    VOID
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    all lookaside lists.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Switch on the current scan count.
    //

    switch (ExpScanCount) {

        //
        // Scan the general nonpaged lookaside lists.
        //

    case 0:
        ExpScanGeneralLookasideList(&ExNPagedLookasideListHead,
                                    &ExNPagedLookasideLock);

        break;

        //
        // Scan the general paged lookaside lists.
        //

    case 1:
        ExpScanGeneralLookasideList(&ExPagedLookasideListHead,
                                    &ExPagedLookasideLock);

        break;

        //
        // Scan the pool paged and nonpaged lookaside lists.
        //
        // N.B. Only one set of pool paged and nonpaged lookaside lists
        //      are scanned each scan period.
        //

    case 2:
        ExpScanSystemLookasideList();
        break;
    }

    //
    // Increment the scan count. If a complete cycle has been completed,
    // then zero the scan count and check if any changes occurred during
    // the complete scan.
    //

    ExpScanCount += 1;
    if (ExpScanCount == 3) {
        ExpScanCount = 0;
    }

    return;
}

FORCEINLINE
VOID
ExpComputeLookasideDepth (
    IN PGENERAL_LOOKASIDE Lookaside,
    IN ULONG Misses,
    IN ULONG ScanPeriod
    )

/*++

Routine Description:

    This function computes the target depth of a lookaside list given the
    total allocations and misses during the last scan period and the current
    depth.

Arguments:

    Lookaside - Supplies a pointer to a lookaside list descriptor.

    Misses - Supplies the total number of allocate misses.

    ScanPeriod - Supplies the scan period in seconds.

Return Value:

    None.

--*/

{

    ULONG Allocates;
    ULONG Delta;
    USHORT MaximumDepth;
    ULONG Ratio;
    LONG Target;

    //
    // Compute the total number of allocations and misses per second for
    // this scan period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;

    //
    // If the verifier is enabled, disable lookasides so driver problems can
    // be isolated. Otherwise, compute the target lookaside list depth.
    //

    if (ExMinimumLookasideDepth == 0) {
        Target = 0;

    } else {
    
        //
        // If the allocate rate is less than the minimum threshold, then lower
        // the maximum depth of the lookaside list. Otherwise, if the miss rate
        // is less than .5%, then lower the maximum depth. Otherwise, raise the
        // maximum depth based on the miss rate.
        //
    
        MaximumDepth = Lookaside->MaximumDepth;
        Target = Lookaside->Depth;
        if (Allocates < (ScanPeriod * MINIMUM_ALLOCATION_THRESHOLD)) {
            if ((Target -= 10) < MINIMUM_LOOKASIDE_DEPTH) {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }
    
        } else {
    
            //
            // N.B. The number of allocates is guaranteed to be greater than
            //      zero because of the above test. 
            //
            // N.B. It is possible that the number of misses are greater than the
            //      number of allocates, but this won't cause the an incorrect
            //      computation of the depth adjustment.
            //      
    
            Ratio = (Misses * 1000) / Allocates;
            if (Ratio < 5) {
                if ((Target -= 1) < MINIMUM_LOOKASIDE_DEPTH) {
                    Target = MINIMUM_LOOKASIDE_DEPTH;
                }
        
            } else {
                if ((Delta = ((Ratio * (MaximumDepth - Target)) / (1000 * 2)) + 5) > 30) {
                    Delta = 30;
                }
        
                if ((Target += Delta) > MaximumDepth) {
                    Target = MaximumDepth;
                }
            }
        }
    }

    Lookaside->Depth = (USHORT)Target;
    return;
}

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function scans the specified list of general lookaside descriptors
    and adjusts the maximum depth as necessary.

Arguments:

    ListHead - Supplies the address of the listhead for a list of lookaside
        descriptors.

    SpinLock - Supplies the address of the spinlock to be used to synchronize
        access to the list of lookaside descriptors.

Return Value:

    None.

--*/

{

    PLIST_ENTRY Entry;
    PPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Misses;
    KIRQL OldIrql;

#ifdef NT_UP

    UNREFERENCED_PARAMETER (SpinLock);

#endif

    //
    // Raise IRQL and acquire the specified spinlock.
    //

    ExAcquireSpinLock(SpinLock, &OldIrql);

    //
    // Scan the specified list of lookaside descriptors and adjust the
    // maximum depth as necessary.
    //
    // N.B. All lookaside list descriptors are treated as if they were
    //      paged descriptors even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    Entry = ListHead->Flink;
    while (Entry != ListHead) {
        Lookaside = CONTAINING_RECORD(Entry,
                                      PAGED_LOOKASIDE_LIST,
                                      L.ListEntry);

        //
        // Compute target depth of lookaside list.
        //

        Misses = Lookaside->L.AllocateMisses - Lookaside->L.LastAllocateMisses;
        Lookaside->L.LastAllocateMisses = Lookaside->L.AllocateMisses;
        ExpComputeLookasideDepth(&Lookaside->L, Misses, 3);
        Entry = Entry->Flink;
    }

    //
    // Release spinlock, lower IRQL, and return function value.
    //

    ExReleaseSpinLock(SpinLock, OldIrql);
    return;
}

VOID
ExpScanSystemLookasideList (
    VOID
    )

/*++

Routine Description:

    This function scans the current set of paged and nonpaged pool lookaside
    descriptors and adjusts the maximum depth as necessary.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the maximum depth of any lookaside list
    is changed. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Hits;
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    ULONG Misses;
    PKPRCB Prcb;
    ULONG ScanPeriod;

    //
    // Scan the current set of lookaside descriptors and adjust the maximum
    // depth as necessary. Either a set of per processor small pool lookaside
    // lists or the global small pool lookaside lists are scanned during a
    // scan period.
    // 
    // N.B. All lookaside list descriptors are treated as if they were
    //      paged descriptors even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    ScanPeriod = (1 + 1 + 1) * KeNumberProcessors;
    if (ExpPoolScanCount == (ULONG)KeNumberProcessors) {

        //
        // Adjust the maximum depth for the global set of system lookaside
        // descriptors.
        //

        Prcb = KeGetCurrentPrcb();
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].L;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for the global set of small pool lookaside
        // descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = &ExpSmallPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }

    } else {

        //
        // Adjust the maximum depth for the global set of per processor
        // system lookaside descriptors.
        //

        Prcb = KiProcessorBlock[ExpPoolScanCount];
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].P;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for a set of per processor small pool
        // lookaside descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = Prcb->PPNPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = Prcb->PPPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }
    }

    ExpPoolScanCount += 1;
    if (ExpPoolScanCount > (ULONG)KeNumberProcessors) {
        ExpPoolScanCount = 0;
    }

    return;
}

VOID
ExInitializeNPagedLookasideList (
    __out PNPAGED_LOOKASIDE_LIST Lookaside,
    __in_opt PALLOCATE_FUNCTION Allocate,
    __in_opt PFREE_FUNCTION Free,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    )

/*++

Routine Description:

    This function initializes a nonpaged lookaside list structure and inserts
    the structure in the system nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (Depth);

    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = ExMinimumLookasideDepth;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = NonPagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;
    
    //
    // Insert the lookaside list structure in the system nonpaged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExNPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExNPagedLookasideLock);
    return;
}

VOID
ExDeleteNPagedLookasideList (
    __inout PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a nonpaged lookaside structure from the system
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the nonpaged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExNPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExNPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromNPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

VOID
ExInitializePagedLookasideList (
    __out PPAGED_LOOKASIDE_LIST Lookaside,
    __in_opt PALLOCATE_FUNCTION Allocate,
    __in_opt PFREE_FUNCTION Free,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    )

/*++

Routine Description:

    This function initializes a paged lookaside list structure and inserts
    the structure in the system paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER (Depth);

    PAGED_CODE();

    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = ExMinimumLookasideDepth;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = PagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;

    //
    // Insert the lookaside list structure in the system paged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExPagedLookasideLock);
    return;
}

VOID
ExDeletePagedLookasideList (
    __inout PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a paged lookaside structure from the system
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the paged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function is a dummy allocation routine which is used to empty
    a lookaside list.

Arguments:

    PoolType - Supplies the type of pool to allocate.

    NumberOfBytes - supplies the number of bytes to allocate.

    Tag - supplies the pool tag.

Return Value:

    NULL is returned as the function value.

--*/

{

    UNREFERENCED_PARAMETER (PoolType);
    UNREFERENCED_PARAMETER (NumberOfBytes);
    UNREFERENCED_PARAMETER (Tag);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\luid.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    luid.c

Abstract:

    This module implements the NT locally unique identifier services.

--*/

#include "exp.h"

//
//  Global variables needed to support locally unique IDs.
//
// The first 1000 values are reserved for static definition. This
// value can be increased with later releases with no adverse impact.
//
// N.B. The LUID source always refers to the "next" allocatable LUID.
//

LARGE_INTEGER ExpLuid = {1001,0};
const LARGE_INTEGER ExpLuidIncrement = {1,0};

#pragma alloc_text(INIT, ExLuidInitialization)
#pragma alloc_text(PAGE, NtAllocateLocallyUniqueId)

BOOLEAN
ExLuidInitialization (
    VOID
    )

/*++

Routine Description:

    This function initializes the locally unique identifier allocation.

    NOTE:  THE LUID ALLOCATION SERVICES ARE NEEDED BY SECURITY IN PHASE 0
           SYSTEM INITIALIZATION.  FOR THIS REASON, LUID INITIALIZATION IS
           PERFORMED AS PART OF PHASE 0 SECURITY INITIALIZATION.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is successfully
    completed.  Otherwise, a value of FALSE is returned.

--*/

{
    return TRUE;
}

NTSTATUS
NtAllocateLocallyUniqueId (
    __out PLUID Luid
    )

/*++

Routine Description:

    This function returns an LUID value that is unique since the system
    was last rebooted.  It is unique on the system it is generated on
    only (not network wide).

    There are no restrictions on who can allocate LUIDs.  The LUID space
    is large enough that this will never present a problem.  If one LUID
    is allocated every 100ns, they will not be exhausted for roughly
    15,000 years (100ns * 2^63).

Arguments:

    Luid - Supplies the address of a variable that will receive the
        new LUID.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        LUID cannot be written.

--*/

{

    KPROCESSOR_MODE PreviousMode;

    //
    // Get previous processor mode and probe argument if necessary.
    //

    try {
        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure((PVOID)Luid, sizeof(LUID), sizeof(ULONG));
        }

        //
        // Allocate and store a locally unique Id.
        //

        ExAllocateLocallyUniqueId(Luid);

    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\nbqueue.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    nbqueue.c

Abstract:

   This module implements non-blocking fifo queue.

--*/

#include "exp.h"

//
// Define queue pointer structure - this is platform target specific.
//

#if defined(_AMD64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 48;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_X86_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG Count;
        LONG Node;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#else

#error "no target architecture"

#endif

//
// Define queue node structure.
//

typedef struct _NBQUEUE_NODE {
    NBQUEUE_POINTER Next;
    ULONG64 Value;
} NBQUEUE_NODE, *PNBQUEUE_NODE;

//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure.
//

#if defined(_AMD64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)((LONG64)(Entry->Node));
}

#elif defined(_X86_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)(Entry->Node);
}

#else

#error "no target architecture"

#endif

//
// Define queue descriptor structure.
//

typedef struct _NBQUEUE_HEADER {
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    PSLIST_HEADER SlistHead;
} NBQUEUE_HEADER, *PNBQUEUE_HEADER;

#pragma alloc_text(PAGE, ExInitializeNBQueueHead)

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    )

/*++

Routine Description:

    This function initializes a non-blocking queue header.

    N.B. It is assumed that the specified SLIST has been populated with
         non-blocking queue nodes prior to calling this routine.

Arguments:

    SlistHead - Supplies a pointer to an SLIST header.

Return Value:

    If the non-blocking queue is successfully initialized, then the
    address of the queue header is returned as the function value.
    Otherwise, NULL is returned as the function value.

--*/

{

    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;

    //
    // Attempt to allocate the queue header. If the allocation fails, then
    // return NULL.
    //

    QueueHead = (PNBQUEUE_HEADER)ExAllocatePoolWithTag(NonPagedPool,
                                                       sizeof(NBQUEUE_HEADER),
                                                       'hqBN');

    if (QueueHead == NULL) {
        return NULL;
    }

    //
    // Attempt to allocate a queue node from the specified SLIST. If a node
    // can be allocated, then initialize the non-blocking queue header and
    // return the address of the queue header. Otherwise, free the queue
    // header and return NULL.
    //

    QueueHead->SlistHead = SlistHead;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);
    if (QueueNode != NULL) {

        //
        // Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = 0;

        //
        // Initialize the head and tail pointers in the queue header.
        //

        PackNBQPointer(&QueueHead->Head, QueueNode);
        QueueHead->Head.Count = 0;
        PackNBQPointer(&QueueHead->Tail, QueueNode);
        QueueHead->Tail.Count = 0;
        return QueueHead;

    } else {
        ExFreePool(QueueHead);
        return NULL;
    }
}

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    )

/*++

Routine Description:

    This function inserts the specific data value at the tail of the
    specified non-blocking queue.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to an opaque data value.

Return Value:

    If the specified opaque data value is successfully inserted at the tail
    of the specified non-blocking queue, then a value of TRUE is returned as
    the function value. Otherwise, a value of FALSE is returned.

    N.B. FALSE is returned if a queue node cannot be allocated from the
         associated SLIST.

--*/

{

    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // Attempt to allocate a queue node from the SLIST associated with
    // the specified non-blocking queue. If a node can be allocated, then
    // the node is inserted at the tail of the specified non-blocking
    // queue, and TRUE is returned as the function value. Otherwise, FALSE
    // is returned.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);
    if (QueueNode != NULL) {

        //
        //  Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = Value;

        //
        // The following loop is executed until the specified entry can
        // be safely inserted at the tail of the specified non-blocking
        // queue.
        //

        do {

            //
            // Read the tail queue pointer and the next queue pointer of
            // the tail queue pointer making sure the two pointers are
            // coherent.
            //

            Tail.Data = ReadForWriteAccess((volatile LONG64 *)(&QueueHead->Tail.Data));
            TailNode = UnpackNBQPointer(&Tail);
            Next.Data = *((volatile LONG64 *)(&TailNode->Next.Data));
            QueueNode->Next.Count = Tail.Count + 1;
            if (Tail.Data == *((volatile LONG64 *)(&QueueHead->Tail.Data))) {

                //
                // If the tail is pointing to the last node in the list,
                // then attempt to insert the new node at the end of the
                // list. Otherwise, the tail is not pointing to the last
                // node in the list and an attempt is made to move the
                // tail pointer to the next node.
                //

                NextNode = UnpackNBQPointer(&Next);
                if (NextNode == NULL) {
                    PackNBQPointer(&Insert, QueueNode);
                    Insert.Count = Next.Count + 1;
                    if (InterlockedCompareExchange64(&TailNode->Next.Data,
                                                     Insert.Data,
                                                     Next.Data) == Next.Data) {
                        break;
                    }

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }
            }

        } while (TRUE);

        //
        // Attempt to move the tail to the new tail node.
        //

        PackNBQPointer(&Insert, QueueNode);
        Insert.Count = Tail.Count + 1;
        InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                     Insert.Data,
                                     Tail.Data);

        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    )

/*++

Routine Description:

    This function removes a queue entry from the head of the specified
    non-blocking queue and returns the associated data value.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to a variable that receives the queue
        element value.

Return Value:

    If an entry is removed from the specified non-blocking queue, then
    TRUE is returned as the function value. Otherwise, FALSE is returned.

--*/

{

    NBQUEUE_POINTER Head;
    PNBQUEUE_NODE HeadNode;
    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // The following loop is executed until an entry can be removed from
    // the specified non-blocking queue or until it can be determined that
    // the queue is empty.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    do {

        //
        // Read the head queue pointer, the tail queue pointer, and the
        // next queue pointer of the head queue pointer making sure the
        // three pointers are coherent.
        //

        Head.Data = ReadForWriteAccess((volatile LONG64 *)(&QueueHead->Head.Data));
        Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
        HeadNode = UnpackNBQPointer(&Head);
        Next.Data = *((volatile LONG64 *)(&HeadNode->Next.Data));
        if (Head.Data == *((volatile LONG64 *)(&QueueHead->Head.Data))) {

            //
            // If the queue header node is equal to the queue tail node,
            // then either the queue is empty or the tail pointer is falling
            // behind. Otherwise, there is an entry in the queue that can
            // be removed.
            //

            NextNode = UnpackNBQPointer(&Next);
            TailNode = UnpackNBQPointer(&Tail);
            if (HeadNode == TailNode) {

                //
                // If the next node of head pointer is NULL, then the queue
                // is empty. Otherwise, attempt to move the tail forward.
                //

                if (NextNode == NULL) {
                    return FALSE;

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }

            } else {

                //
                // There is an entry in the queue that can be removed.
                //

                *Value = NextNode->Value;
                PackNBQPointer(&Insert, NextNode);
                Insert.Count = Head.Count + 1;
                if (InterlockedCompareExchange64(&QueueHead->Head.Data,
                                                 Insert.Data,
                                                 Head.Data) == Head.Data) {

                    break;
                }
            }
        }

    } while (TRUE);

    //
    // Free the node that was removed for the list by inserting the node
    // in the associated SLIST.
    //

    InterlockedPushEntrySList(QueueHead->SlistHead,
                              (PSLIST_ENTRY)HeadNode);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\pushlock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pushlock.c

Abstract:

    This module houses routines that do push locking.

    Push locks are capable of being acquired in both shared and exclusive mode.

    Properties include:

    They cannot be acquired recursively.
    They are small (the size of a pointer) and can be used when embedded in pageable data.
    Acquire and release is done lock free. On lock contention the waiters are chained
    through the lock and local stack space.

    This is the structure of a push lock:

    
    L  == Lock bit, This bit is set when the lock is held exclusive or shared
    W  == Waiters present
    K  == Waking threads or optimizing chains. This bit can't be set unless the waiters bit is set.
    M  == Multiple shared owners present. When they release these threads must walk the waitblock list
    SC == Share count
    P  == Pointer to wait block

    +--------------+---+---+---+---+
    |      SC      | M | K | W | L | L, W, K and M are single bits W == 0
    +--------------+---+---+---+---+

    +--------------+---+---+---+---+
    |      P       | M | K | W | L | W == 1. Pointer is the address of a chain of stack local wait blocks
    +--------------+---+---+---+---+

    The non-contented acquires and releases are trivial. Interlocked operations make the following
    transformations.

    Uncontended exclusive acquire. Notice that we can acquire even if there are waiters.

    (SC=0,L=0,W=w,K=k,M=0) === Exclusive acquire ===> (SC=0,L=1,W=w,K=k,M=0)

    There are two cases for shared acquire. Notice that we can only acquire
    in the absence of waiters. The first and later acquires:

    (SC=0,L=0,W=0,K=0,M=0) === First shared acquire ===> (SC=1,  L=1,W=0,K=0,M=0)
    (SC=n,L=1,W=0,K=0,M=0) === later shared acquire ===> (SC=n+1,L=1,W=0,K=0,M=0)

    Uncontended exclusive release:

    (SC=0,L=1,W=0,K=0,M=0) === Exclusive release ===> (SC=0,L=0,W=0,K=0,M=0)

    There are two cases for uncontended shared release. Last and non-last:

    (SC=n,L=1,W=0,K=0,M=0) === Non-last Shared release ===> (SC=n-1,L=1,W=0,K=0,M=0) n > 0
    (SC=1,L=1,W=0,K=0,M=0) ===   last Shared release   ===> (SC=0,  L=0,W=0,K=0,M=0)

    Contention causes the acquiring thread to produce a local stack based wait block and to
    enqueue it to the front of the list.

    Notice that after a contended acquire takes place the K bit is always set.
    It was either set by another thread or this thread. The thread that sets this bit has
    the right to walk the waiters chain and optimize it (place pointers to ending blocks etc).

    Owners of the K bit must either clear the K bit if the lock is still locked or clear the K bit and
    wake at least one thread (if the lock is not locked).

    (SC=n,L=1,W=0,K=0,M=0) === Exclusive acquire ===> (P=LWB(SSC=n,E=e),W=1,K=1,M=m)
        LWB = local wait block,
        SSC = Saved share count,
        E   = Exclusive waiter flag
        m   = Multiple shared owners. m=(n>1)?1:0

    (SC=0,L=1,W=0,K=0,M=0) === Shared acquire    ===> (P=LWB(SSC=0,E=0),W=1,K=1,M=0)
        LWB = local wait block,
        SSC = Saved share count.
        E   = Exclusive waiter flag

    After contention has caused one or more threads to queue up wait blocks releases are more
    complicated. The K bit arbitrates who is allowed to manipulate the waiters list but it does
    not guaranteed complete freedom. The following are the rights to manipulate the list:

    1) New waiters at any time may push themselves onto the list. If they are not the first
       waiter they will also attempt to set the K bit to perform list optimization.
    2) Shared releasers are allowed to walk the list (hopefully optimized by the waiters) to
       find the end of the chain where the share count lives. If they decrement the shared count
       to zero they behave like exclusive releasers and try to set the K bit.
    3) K bit owners, either waiters that pend and manage to set the bit or releasers who manage
       to set the bit have the right to walk the chain and break it and wake. They can't reorder
       without excluding shared walkers (we don't attempt to reorder just put in end pointers).

    The K bit is not a lock in the sense that we don't need to spin on it. Only one owner is needed
    at any time and failure to obtain K bit ownership means some other thread will wake etc.

    The M bit is needed for lock releasers who don't know if they own the lock shared. It also has the
    benefit that only when there are more than one shared owner do we need to traverse the wait list.


Revision History:

    Shifted to not pass on ownership in contended cases to reduce lock hold times.

--*/

#include "exp.h"

#pragma hdrstop

VOID
ExpInitializePushLocks (
    VOID
    );

#ifdef ALLOC_PRAGMA

//
// Since pushlocks are used as the working set synchronization by
// memory management, these routines cannot be pageable.
//
//#pragma alloc_text(PAGE, ExBlockPushLock)
//#pragma alloc_text(PAGE, ExfAcquirePushLockExclusive)
//#pragma alloc_text(PAGE, ExfAcquirePushLockShared)
//#pragma alloc_text(PAGE, ExAllocateCacheAwarePushLock)
//#pragma alloc_text(PAGE, ExFreeCacheAwarePushLock)
//#pragma alloc_text(PAGE, ExAcquireCacheAwarePushLockExclusive)
//#pragma alloc_text(PAGE, ExReleaseCacheAwarePushLockExclusive)

#pragma alloc_text(INIT, ExpInitializePushLocks)

#endif

#if defined (NT_UP)
const ULONG ExPushLockSpinCount = 0;
#else
ULONG ExPushLockSpinCount = 0;
#endif

#if !defined (NT_UP)
#define USE_EXP_BACKOFF
#endif

VOID
ExpInitializePushLocks (
    VOID
    )
/*++

Routine Description:

    Calculates the value of the pushlock spin count

Arguments:

    None

Return Value:

    None

--*/
{

#if defined(_AMD64_)
    EX_PUSH_LOCK ScratchPushLock;
#endif

#if !NT_UP
    if (KeNumberProcessors > 1) {
        ExPushLockSpinCount = 1024;
    } else {
        ExPushLockSpinCount = 0;
    }
#endif

    //
    // Exercise the following routines early, in order to patch any
    // prefetchw instructions therein.
    // 

#if defined(_AMD64_)

    ExInitializePushLock( &ScratchPushLock );

    ExfAcquirePushLockShared( &ScratchPushLock );
    ExfReleasePushLock( &ScratchPushLock );

    ExfAcquirePushLockShared( &ScratchPushLock );
    ExfReleasePushLockShared( &ScratchPushLock );

    ExfAcquirePushLockExclusive( &ScratchPushLock );
    ExfReleasePushLockExclusive( &ScratchPushLock );

#endif
}



NTKERNELAPI
VOID
FASTCALL
ExfWakePushLock (
    IN PEX_PUSH_LOCK PushLock,
    IN EX_PUSH_LOCK TopValue
    )
/*++

Routine Description:

    Walks the pushlock waiting list and wakes waiters if the lock is still unacquired.

Arguments:

    PushLock - Push lock to be walked

    TopValue - Start of the chain (*PushLock)

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock, FirstWaitBlock, PreviousWaitBlock;
    KIRQL OldIrql;

    OldValue = TopValue;

    while (1) {

        //
        // Nobody should be walking the list while we manipulate it.
        //

        ASSERT (!OldValue.MultipleShared);

        //
        // No point waking somebody to find a locked lock. Just clear the waking bit
        //

        while (OldValue.Locked) {
            NewValue.Value = OldValue.Value - EX_PUSH_LOCK_WAKING;
            ASSERT (!NewValue.Waking);
            ASSERT (NewValue.Locked);
            ASSERT (NewValue.Waiting);
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                return;
            }
            OldValue = NewValue;
        }

        WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK)
           (OldValue.Value & ~(ULONG_PTR)EX_PUSH_LOCK_PTR_BITS);

        FirstWaitBlock = WaitBlock;

        while (1) {

            NextWaitBlock = WaitBlock->Last;
            if (NextWaitBlock != NULL) {
                WaitBlock = NextWaitBlock;
                break;
            }

            PreviousWaitBlock = WaitBlock;
            WaitBlock = WaitBlock->Next;
            WaitBlock->Previous = PreviousWaitBlock;
        }

        if (WaitBlock->Flags&EX_PUSH_LOCK_FLAGS_EXCLUSIVE &&
            (PreviousWaitBlock = WaitBlock->Previous) != NULL) {

            FirstWaitBlock->Last = PreviousWaitBlock;

            WaitBlock->Previous = NULL;

            ASSERT (FirstWaitBlock != WaitBlock);

            ASSERT (PushLock->Waiting);

#if defined (_WIN64)
            InterlockedAnd64 ((LONG64 *)&PushLock->Value, ~EX_PUSH_LOCK_WAKING);
#else
            InterlockedAnd ((LONG *)&PushLock->Value, ~EX_PUSH_LOCK_WAKING);
#endif

            break;
        } else {
            NewValue.Value = 0;
            ASSERT (!NewValue.Waking);
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                break;
            }
            OldValue = NewValue;
        }
    }

    //
    // If we are waking more than one thread then raise to DPC level to prevent us
    // getting rescheduled part way through the operation
    //

    OldIrql = DISPATCH_LEVEL;
    if (WaitBlock->Previous != NULL) {
        KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    }

    while (1) {

        NextWaitBlock = WaitBlock->Previous;
#if DBG
        ASSERT (!WaitBlock->Signaled);
        WaitBlock->Signaled = TRUE;
#endif

        if (!InterlockedBitTestAndReset (&WaitBlock->Flags, EX_PUSH_LOCK_FLAGS_SPINNING_V)) {
            KeSignalGateBoostPriority (&WaitBlock->WakeGate);
        }

        WaitBlock = NextWaitBlock;
        if (WaitBlock == NULL) {
            break;
        }
    }

    if (OldIrql != DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
FASTCALL
ExfTryToWakePushLock (
    __inout PEX_PUSH_LOCK PushLock
    )
/*++

Routine Description:

    Tries to set the wake bit and wake the pushlock

Arguments:

    PushLock - Push lock to be woken

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;

    if (OldValue.Waking || OldValue.Locked || !OldValue.Waiting) {
        return;
    }

    NewValue.Value = OldValue.Value + EX_PUSH_LOCK_WAKING;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) == OldValue.Ptr) {
        ExfWakePushLock (PushLock, NewValue);
    }
}



VOID
FASTCALL
ExpOptimizePushLockList (
    IN PEX_PUSH_LOCK PushLock,
    IN EX_PUSH_LOCK TopValue
    )
/*++

Routine Description:

    Walks the pushlock waiting list during contention and optimizes it

Arguments:

    PushLock - Push lock to be walked

    TopValue - Start of the chain (*PushLock)

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, PreviousWaitBlock, FirstWaitBlock, NextWaitBlock;

    OldValue = TopValue;
    while (1) {
        if (!OldValue.Locked) {
            ExfWakePushLock (PushLock, OldValue);
            break;
        }

        WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK)(OldValue.Value & ~(EX_PUSH_LOCK_PTR_BITS));

        FirstWaitBlock = WaitBlock;

        while (1) {

            NextWaitBlock = WaitBlock->Last;
            if (NextWaitBlock != NULL) {
                FirstWaitBlock->Last = NextWaitBlock;
                break;
            }

            PreviousWaitBlock = WaitBlock;
            WaitBlock = WaitBlock->Next;
            WaitBlock->Previous = PreviousWaitBlock;
        }

        NewValue.Value = OldValue.Value - EX_PUSH_LOCK_WAKING;
        ASSERT (NewValue.Locked);
        ASSERT (!NewValue.Waking);
        if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                               NewValue.Ptr,
                                                               OldValue.Ptr)) == OldValue.Ptr) {
            break;
        }
        OldValue = NewValue;
    }
}


NTKERNELAPI
VOID
DECLSPEC_NOINLINE
FASTCALL
ExfAcquirePushLockExclusive (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue, TopValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
    BOOLEAN Optimize;
#if defined (USE_EXP_BACKOFF)
    RTL_BACKOFF Backoff = {0};
#endif

    OldValue = ReadForWriteAccess (PushLock);

    while (1) {
        //
        // If the lock is already held exclusively/shared or there are waiters then
        // we need to wait.
        //
        if ((OldValue.Value&EX_PUSH_LOCK_LOCK) == 0) {
            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_LOCK;

            ASSERT (NewValue.Locked);

            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }

#if defined (USE_EXP_BACKOFF)

            //
            // Use backof to limit memory bandwidth
            //
            RtlBackoff (&Backoff);

            NewValue = *PushLock;

#endif
        } else {
            WaitBlock.Flags = EX_PUSH_LOCK_FLAGS_EXCLUSIVE | EX_PUSH_LOCK_FLAGS_SPINNING;
            WaitBlock.Previous = NULL;
            Optimize = FALSE;
 
            //
            // Move the sharecount to our wait block if need be.
            //
            if (OldValue.Waiting) {
                WaitBlock.Last = NULL;
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value & ~EX_PUSH_LOCK_PTR_BITS);
                WaitBlock.ShareCount = 0;
                NewValue.Ptr = (PVOID)(((ULONG_PTR) &WaitBlock) |
                                    (OldValue.Value & EX_PUSH_LOCK_PTR_BITS) |
                                    EX_PUSH_LOCK_WAITING | EX_PUSH_LOCK_WAKING |
                                    EX_PUSH_LOCK_LOCK);
                if (!OldValue.Waking) {
                    Optimize = TRUE;
                }
            } else {
                WaitBlock.Last = &WaitBlock;
                WaitBlock.ShareCount = (ULONG) OldValue.Shared;
                if (WaitBlock.ShareCount > 1) {
                    NewValue.Ptr = (PVOID)(((ULONG_PTR) &WaitBlock) | EX_PUSH_LOCK_WAITING |
                                                                      EX_PUSH_LOCK_LOCK |
                                                                      EX_PUSH_LOCK_MULTIPLE_SHARED);
                } else {
                    WaitBlock.ShareCount = 0;
                    NewValue.Ptr = (PVOID)(((ULONG_PTR) &WaitBlock) | EX_PUSH_LOCK_WAITING |
                                                                      EX_PUSH_LOCK_LOCK);
                }
            }
             
#if DBG
            WaitBlock.Signaled = FALSE;
            WaitBlock.OldValue = OldValue.Ptr;
            WaitBlock.NewValue = NewValue.Ptr;
            WaitBlock.PushLock = PushLock;
#endif
            ASSERT (NewValue.Waiting);
            ASSERT (OldValue.Locked);
            ASSERT (NewValue.Locked);

            TopValue = NewValue;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                ULONG i;

                //
                // If we set the waiting bit then optimize the list
                //
                if (Optimize) {
                    ExpOptimizePushLockList (PushLock, TopValue);
                }

                KeInitializeGate (&WaitBlock.WakeGate);

                for (i = ExPushLockSpinCount; i > 0; i--) {
                    if (((*(volatile LONG *)&WaitBlock.Flags)&EX_PUSH_LOCK_FLAGS_SPINNING) == 0) {
                        break;
                    }
                    KeYieldProcessor ();
                }

                if (InterlockedBitTestAndReset (&WaitBlock.Flags, EX_PUSH_LOCK_FLAGS_SPINNING_V)) {

                    KeWaitForGate (&WaitBlock.WakeGate, WrPushLock, KernelMode);
#if DBG
                    ASSERT (WaitBlock.Signaled);
#endif

                }
                ASSERT ((WaitBlock.ShareCount == 0));
            } else {

#if defined (USE_EXP_BACKOFF)
                //
                // Use backof to limit memory bandwidth
                //
                RtlBackoff (&Backoff);

                NewValue = *PushLock;
#endif
            }
        }
        OldValue = NewValue;
    }

}

NTKERNELAPI
VOID
DECLSPEC_NOINLINE
FASTCALL
ExfAcquirePushLockShared (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue, TopValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
    BOOLEAN Optimize;
#if defined (USE_EXP_BACKOFF)
    RTL_BACKOFF Backoff = {0};
#endif

    OldValue = ReadForWriteAccess (PushLock);

    while (1) {
        //
        // If the lock is already held we need to wait if its not held shared
        //
        if (!OldValue.Locked || (!OldValue.Waiting && OldValue.Shared > 0)) {

            if (OldValue.Waiting) {
                NewValue.Value = OldValue.Value + EX_PUSH_LOCK_LOCK;
            } else {
                NewValue.Value = (OldValue.Value + EX_PUSH_LOCK_SHARE_INC) | EX_PUSH_LOCK_LOCK;
            }
            ASSERT (NewValue.Locked);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }

#if defined (USE_EXP_BACKOFF)

            //
            // Use backof to limit memory bandwidth
            //
            RtlBackoff (&Backoff);

            NewValue = *PushLock;

#endif

        } else {
            WaitBlock.Flags = EX_PUSH_LOCK_FLAGS_SPINNING;
            WaitBlock.ShareCount = 0;
            Optimize = FALSE;
            WaitBlock.Previous = NULL;
 
            //
            // Move the sharecount to our wait block if need be.
            //
            if (OldValue.Waiting) {
                WaitBlock.Last = NULL;
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value & ~EX_PUSH_LOCK_PTR_BITS);
                NewValue.Ptr = (PVOID)(((ULONG_PTR) &WaitBlock) |
                                    (OldValue.Value & (EX_PUSH_LOCK_LOCK | EX_PUSH_LOCK_MULTIPLE_SHARED)) |
                                    EX_PUSH_LOCK_WAITING | EX_PUSH_LOCK_WAKING);
                if (!OldValue.Waking) {
                    Optimize = TRUE;
                }
            } else {
                WaitBlock.Last = &WaitBlock;
                NewValue.Ptr = (PVOID)(((ULONG_PTR) &WaitBlock) |
                                    (OldValue.Value & EX_PUSH_LOCK_PTR_BITS) |
                                    EX_PUSH_LOCK_WAITING);
            }
             
            ASSERT (NewValue.Waiting);

#if DBG
            WaitBlock.Signaled = FALSE;
            WaitBlock.OldValue = OldValue.Ptr;
            WaitBlock.NewValue = NewValue.Ptr;
            WaitBlock.PushLock = PushLock;
#endif
            TopValue = NewValue;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);

            if (NewValue.Ptr == OldValue.Ptr) {
                ULONG i;

                //
                // If we set the waiting bit then optimize the list
                //
                if (Optimize) {
                    ExpOptimizePushLockList (PushLock, TopValue);
                }

                //
                // It is safe to initialize the gate here, as the interlocked operation below forces 
                // a gate signal to always follow gate initialization.
                //
                KeInitializeGate (&WaitBlock.WakeGate);

                for (i = ExPushLockSpinCount; i > 0; i--) {
                    if (((*(volatile LONG *)&WaitBlock.Flags)&EX_PUSH_LOCK_FLAGS_SPINNING) == 0) {
                        break;
                    }
                    KeYieldProcessor ();
                }

                if (InterlockedBitTestAndReset ((LONG*)&WaitBlock.Flags, EX_PUSH_LOCK_FLAGS_SPINNING_V)) {

                    KeWaitForGate (&WaitBlock.WakeGate, WrPushLock, KernelMode);
#if DBG
                    ASSERT (WaitBlock.Signaled);
#endif

                }

            } else {

#if defined (USE_EXP_BACKOFF)

                //
                // Use backof to limit memory bandwidth
                //
                RtlBackoff (&Backoff);

                NewValue = *PushLock;
#endif
            }

        }
        OldValue = NewValue;
    }

}

NTKERNELAPI
BOOLEAN
FASTCALL
ExfTryAcquirePushLockShared (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Try to acquire a push lock shared without blocking

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE, The lock was acquired, FALSE otherwise

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = ReadForWriteAccess (PushLock);

    while (1) {
        //
        // If the lock is already held we need to wait if its not held shared
        //
        if (!OldValue.Locked || (!OldValue.Waiting && OldValue.Shared > 0)) {

            if (OldValue.Waiting) {
                NewValue.Value = OldValue.Value + EX_PUSH_LOCK_LOCK;
            } else {
                NewValue.Value = (OldValue.Value + EX_PUSH_LOCK_SHARE_INC) | EX_PUSH_LOCK_LOCK;
            }
            ASSERT (NewValue.Locked);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                return TRUE;
            }
        } else {
            return FALSE;
        }
        OldValue = NewValue;
    }

}

NTKERNELAPI
VOID
DECLSPEC_NOINLINE
FASTCALL
ExfReleasePushLockShared (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue, TopValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock;

    OldValue = ReadForWriteAccess (PushLock);

    while (!OldValue.Waiting) {

        if (OldValue.Shared > 1) {
            NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;
        } else {
            NewValue.Value = 0;
        }

        if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                               NewValue.Ptr,
                                                               OldValue.Ptr)) == OldValue.Ptr) {
            return;
        }
        OldValue = NewValue;
    }

    if (OldValue.MultipleShared) {
        WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK) (OldValue.Value & ~(ULONG_PTR)EX_PUSH_LOCK_PTR_BITS);

        while (1) {

            NextWaitBlock = WaitBlock->Last;
            if (NextWaitBlock != NULL) {
                WaitBlock = NextWaitBlock;
                break;
            }

            WaitBlock = WaitBlock->Next;
        }

        ASSERT (WaitBlock->ShareCount > 0);
        ASSERT (WaitBlock->Flags&EX_PUSH_LOCK_FLAGS_EXCLUSIVE);

        if (InterlockedDecrement (&WaitBlock->ShareCount) > 0) {
            return;
        }
    }

    while (1) {

        if (OldValue.Waking) {
            NewValue.Value = OldValue.Value & ~(EX_PUSH_LOCK_LOCK|EX_PUSH_LOCK_MULTIPLE_SHARED);
            ASSERT (NewValue.Waking && !NewValue.Locked && !NewValue.MultipleShared);
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                return;
            }
        } else {
            NewValue.Value = (OldValue.Value & ~(EX_PUSH_LOCK_LOCK |
                                                 EX_PUSH_LOCK_MULTIPLE_SHARED)) |
                                      EX_PUSH_LOCK_WAKING;
            ASSERT (NewValue.Waking && !NewValue.Locked && !NewValue.MultipleShared);
            TopValue = NewValue;
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                ExfWakePushLock (PushLock, TopValue);
                return;
            }
        }

        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
DECLSPEC_NOINLINE
FASTCALL
ExfReleasePushLockExclusive (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusive

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue, TopValue;

    OldValue = ReadForWriteAccess (PushLock);

    while (1) {

        ASSERT (OldValue.Locked);
        ASSERT (OldValue.Waiting || OldValue.Shared == 0);

        if (OldValue.Waiting && !OldValue.Waking) {
            NewValue.Value = OldValue.Value - EX_PUSH_LOCK_LOCK + EX_PUSH_LOCK_WAKING;
            ASSERT (NewValue.Waking && !NewValue.Locked);
            TopValue = NewValue;
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                ExfWakePushLock (PushLock, TopValue);
                break;
            }
        } else {
            NewValue.Value = OldValue.Value - EX_PUSH_LOCK_LOCK;
            ASSERT (NewValue.Waking || !NewValue.Waiting);
            if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                   NewValue.Ptr,
                                                                   OldValue.Ptr)) == OldValue.Ptr) {
                break;
            }
        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
DECLSPEC_NOINLINE
FASTCALL
ExfReleasePushLock (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue, TopValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock;

    OldValue = ReadForWriteAccess (PushLock);

    ASSERT (OldValue.Locked);

    while (1) {

        if (!OldValue.Waiting) {

            if (OldValue.Shared > 1) {
                NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;
            } else {
                NewValue.Value = 0;
            }

            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                return;
            }
            OldValue = NewValue;
        } else {

            //
            // See if we need to walk the list to find the share count
            //

            if (OldValue.MultipleShared) {
                WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK) (OldValue.Value & ~(ULONG_PTR)EX_PUSH_LOCK_PTR_BITS);

                while (1) {

                    NextWaitBlock = WaitBlock->Last;

                    if (NextWaitBlock != NULL) {
                        WaitBlock = NextWaitBlock;
                        break;
                    }

                    WaitBlock = WaitBlock->Next;
                }

                if (WaitBlock->ShareCount > 0) {
                    ASSERT (WaitBlock->Flags&EX_PUSH_LOCK_FLAGS_EXCLUSIVE);

                    if (InterlockedDecrement (&WaitBlock->ShareCount) > 0) {
                        return;
                    }
                }
            }

            while (1) {
                if (OldValue.Waking) {
                    NewValue.Value = OldValue.Value & ~(EX_PUSH_LOCK_LOCK |
                                                        EX_PUSH_LOCK_MULTIPLE_SHARED);
                    ASSERT (NewValue.Waking && !NewValue.Locked && !NewValue.MultipleShared);
                    if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                           NewValue.Ptr,
                                                                           OldValue.Ptr)) == OldValue.Ptr) {
                        return;
                    }
                } else {
                    NewValue.Value = (OldValue.Value & ~(EX_PUSH_LOCK_LOCK |
                                                         EX_PUSH_LOCK_MULTIPLE_SHARED)) |
                                           EX_PUSH_LOCK_WAKING;
                    ASSERT (NewValue.Waking && !NewValue.Locked && !NewValue.MultipleShared);
                    TopValue = NewValue;
                    if ((NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                           NewValue.Ptr,
                                                                           OldValue.Ptr)) == OldValue.Ptr) {
                        ExfWakePushLock (PushLock, TopValue);
                        return;
                    }
                }
                OldValue = NewValue;
            }
        }
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfConvertPushLockExclusiveToShared (
     __inout PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Attempts to convert an exclusive acquire to shared. If other shared waiters 
    are present at the end of the waiters chain they are released.

Arguments:

    PushLock - Push lock to be converted

Return Value:

    None.

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = ReadForWriteAccess (PushLock);

    while (1) {
        ASSERT (OldValue.Locked);
        ASSERT (OldValue.Waiting || OldValue.Shared == 0);

        if (!OldValue.Waiting) {

            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                               (PVOID) (EX_PUSH_LOCK_LOCK|EX_PUSH_LOCK_SHARE_INC),
                                               OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                return;
            }

            OldValue = NewValue;
        } else {
            return;
        }
    }
}

NTKERNELAPI
VOID
FASTCALL
ExBlockPushLock (
     __inout PEX_PUSH_LOCK PushLock,
     __inout PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     )
/*++

Routine Description:

    Block on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block to queue for waiting

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    //
    // Mark the wait block as not waiting yet
    //

    WaitBlock->Flags = EX_PUSH_LOCK_FLAGS_SPINNING;

    //
    // Push the wait block on the list. 
    //

    OldValue = ReadForWriteAccess (PushLock);
    while (1) {
        //
        // Chain the next block to us if there is one.
        //
        WaitBlock->Next = OldValue.Ptr;
        NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                          WaitBlock,
                                                          OldValue.Ptr);
        if (NewValue.Ptr == OldValue.Ptr) {
            return;
        }
        OldValue = NewValue;
    }
}


NTKERNELAPI
VOID
FASTCALL
ExWaitForUnblockPushLock (
     __inout PEX_PUSH_LOCK PushLock,
     __inout PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     )
{
    ExTimedWaitForUnblockPushLock (PushLock,
                                   WaitBlock,
                                   NULL);
}

NTKERNELAPI
NTSTATUS
FASTCALL
ExTimedWaitForUnblockPushLock (
     __inout PEX_PUSH_LOCK PushLock,
     __inout PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock,
     __in_opt PLARGE_INTEGER Timeout
     )
{
    ULONG i;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER (PushLock);

    KeInitializeEvent (&WaitBlock->WakeEvent, SynchronizationEvent, FALSE);

    for (i = ExPushLockSpinCount; i > 0; i--) {
        if (((*(volatile LONG *)&WaitBlock->Flags)&EX_PUSH_LOCK_FLAGS_SPINNING) == 0) {
            return STATUS_SUCCESS;
        }
        KeYieldProcessor ();
    }


    if (InterlockedBitTestAndReset (&WaitBlock->Flags, EX_PUSH_LOCK_FLAGS_SPINNING_V)) {
        Status = KeWaitForSingleObject (&WaitBlock->WakeEvent,
                                        WrPushLock,
                                        KernelMode,
                                        FALSE,
                                        Timeout);
        if (Status != STATUS_SUCCESS) {
            ExfUnblockPushLock (PushLock,
                                WaitBlock);
        }
    } else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     __inout PEX_PUSH_LOCK PushLock,
     __inout_opt PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     )
/*++

Routine Description:

    Unblock on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block previously queued for waiting or NULL if there wasn't one

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue;
    PEX_PUSH_LOCK_WAIT_BLOCK tWaitBlock;
    KIRQL OldIrql;

    //
    // Pop the entire chain and wake them all up.
    //
    OldValue.Ptr = InterlockedExchangePointer (&PushLock->Ptr,
                                               NULL);

    tWaitBlock = OldValue.Ptr;

    //
    // If it looks like we will wake more than one thread then raise IRQL to prevent
    // rescheduling during the operation.
    //
    OldIrql = DISPATCH_LEVEL;
    if (tWaitBlock != NULL && tWaitBlock->Next != NULL) {
        KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    }

    while (tWaitBlock != NULL) {
        OldValue.Ptr = tWaitBlock->Next;

        if (!InterlockedBitTestAndReset (&tWaitBlock->Flags, EX_PUSH_LOCK_FLAGS_SPINNING_V)) {
            KeSetEventBoostPriority (&tWaitBlock->WakeEvent, NULL);
        }

        tWaitBlock = OldValue.Ptr;
    }

    if (OldIrql != DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }

    if (WaitBlock != NULL && (WaitBlock->Flags&EX_PUSH_LOCK_FLAGS_SPINNING) != 0) {
        ExWaitForUnblockPushLock (PushLock, WaitBlock);
    }
}

NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     VOID
     )
/*++

Routine Description:

    Allocate a cache aware (cache friendly) push lock

Arguments:

    None

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK_CACHE_AWARE PushLockCacheAware;
    PEX_PUSH_LOCK_CACHE_AWARE_PADDED PaddedPushLock;
    ULONG i, j, MaxLine;

    PushLockCacheAware = ExAllocatePoolWithTag (PagedPool,
                                                sizeof (EX_PUSH_LOCK_CACHE_AWARE),
                                                'pclP');
    if (PushLockCacheAware != NULL) {
        //
        // If we are a non-numa machine then allocate the padded push locks as a single block
        //
        if (KeNumberNodes == 1) {
            PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                    sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED)*
                                                       EX_PUSH_LOCK_FANNED_COUNT,
                                                    'lclP');
            if (PaddedPushLock == NULL) {
                ExFreePool (PushLockCacheAware);
                return NULL;
            }
            for (i = 0; i < EX_PUSH_LOCK_FANNED_COUNT; i++) {
                PaddedPushLock->Single = TRUE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
                PaddedPushLock++;
            }
        } else {
            //
            // Allocate a different block for each lock and set affinity
            // so the allocation comes from that node's memory.
            //
            MaxLine = KeNumberProcessors;
            if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
                MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
            }

            for (i = 0; i < MaxLine; i++) {
                KeSetSystemAffinityThread (AFFINITY_MASK (i));
                PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                        sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED),
                                                        'lclP');
                if (PaddedPushLock == NULL) {
                    for (j = 0; j < i; j++) {
                        ExFreePool (PushLockCacheAware->Locks[j]);
                    }
                    KeRevertToUserAffinityThread ();

                    ExFreePool (PushLockCacheAware);
                    return NULL;
                }
                PaddedPushLock->Single = FALSE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
            }
            KeRevertToUserAffinityThread ();
        }
        
    }
    return PushLockCacheAware;
}

NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     __inout PEX_PUSH_LOCK_CACHE_AWARE PushLock     
     )
/*++

Routine Description:

    Frees a cache aware (cache friendly) push lock

Arguments:

    PushLock - Cache aware push lock to be freed

Return Value:

    None

--*/
{
    ULONG i;
    ULONG MaxLine;

    if (!CONTAINING_RECORD (PushLock->Locks[0], EX_PUSH_LOCK_CACHE_AWARE_PADDED, Lock)->Single) {
        MaxLine = KeNumberProcessors;
        if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
            MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
        }

        for (i = 0; i < MaxLine; i++) {
            ExFreePool (PushLock->Locks[i]);
        }
    } else {
        ExFreePool (PushLock->Locks[0]);
    }
    ExFreePool (PushLock);
}


NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
     __inout PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;
    ULONG MaxLine;

    //
    // Exclusive acquires must obtain all the slots exclusive.
    // Take the first slot exclusive and then we can take the
    // rest of the slots in any order we want.
    // There is no deadlock here. A->B->C does not deadlock with A->C->B.
    //
    Start = &PushLock->Locks[1];
    MaxLine = KeNumberProcessors;
    if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
        MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
    }
    End   = &PushLock->Locks[MaxLine - 1];

    ExAcquirePushLockExclusive (PushLock->Locks[0]);

    while (Start <= End) {
        if (ExTryAcquirePushLockExclusive (*Start)) {
            Start++;
        } else {
            ExAcquirePushLockExclusive (*End);
            End--;
        }
    }
}

NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
     __inout PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Release a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be released

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;
    ULONG MaxLine;

    //
    // Release the locks in order
    //

    MaxLine = KeNumberProcessors;
    if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
        MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
    }
    End   = &PushLock->Locks[MaxLine];
    for (Start = &PushLock->Locks[0];
         Start < End;
         Start++) {
        ExReleasePushLockExclusive (*Start);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\profile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    profile.c

Abstract:

   This module implements the executive profile object. Functions are provided
   to create, start, stop, and query profile objects.

--*/

#include "exp.h"

//
// Executive profile object.
//

typedef struct _EPROFILE {
    PKPROCESS Process;
    PVOID RangeBase;
    SIZE_T RangeSize;
    PVOID Buffer;
    ULONG BufferSize;
    ULONG BucketSize;
    PKPROFILE ProfileObject;
    PVOID LockedBufferAddress;
    PMDL Mdl;
    ULONG Segment;
    KPROFILE_SOURCE ProfileSource;
    KAFFINITY Affinity;
} EPROFILE, *PEPROFILE;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExProfileObjectType;

KMUTEX ExpProfileStateMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const ULONG ExpCurrentProfileUsage = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpProfileMapping = {
    STANDARD_RIGHTS_READ | PROFILE_CONTROL,
    STANDARD_RIGHTS_WRITE | PROFILE_CONTROL,
    STANDARD_RIGHTS_EXECUTE | PROFILE_CONTROL,
    PROFILE_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#define ACTIVE_PROFILE_LIMIT 8

#pragma alloc_text(INIT, ExpProfileInitialization)
#pragma alloc_text(PAGE, ExpProfileDelete)
#pragma alloc_text(PAGE, NtCreateProfile)
#pragma alloc_text(PAGE, NtStartProfile)
#pragma alloc_text(PAGE, NtStopProfile)
#pragma alloc_text(PAGE, NtSetIntervalProfile)
#pragma alloc_text(PAGE, NtQueryIntervalProfile)
#pragma alloc_text(PAGE, NtQueryPerformanceCounter)

BOOLEAN
ExpProfileInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the profile object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the profile object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize mutex for synchronizing start and stop operations.
    //

    KeInitializeMutex (&ExpProfileStateMutex, MUTEX_LEVEL_EX_PROFILE);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Profile");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer,sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EPROFILE);
    ObjectTypeInitializer.ValidAccessMask = PROFILE_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpProfileDelete;
    ObjectTypeInitializer.GenericMapping = ExpProfileMapping;

    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExProfileObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
ExpProfileDelete (
    IN PVOID Object
    )

/*++

Routine Description:


    This routine is called by the object management procedures whenever
    the last reference to a profile object has been removed.  This routine
    stops profiling, returns locked buffers and pages, dereferences the
    specified process and returns.

Arguments:

    Object - a pointer to the body of the profile object.

Return Value:

    None.

--*/

{
    PEPROFILE Profile;
    BOOLEAN   State;
    PEPROCESS ProcessAddress;

    Profile = (PEPROFILE)Object;

    if (Profile->LockedBufferAddress != NULL) {

        //
        // Stop profiling and unlock the buffers and deallocate pool.
        //

        State = KeStopProfile (Profile->ProfileObject);
        ASSERT (State != FALSE);

        MmUnmapLockedPages (Profile->LockedBufferAddress, Profile->Mdl);
        MmUnlockPages (Profile->Mdl);
        ExFreePool (Profile->ProfileObject);
    }

    if (Profile->Process != NULL) {
        ProcessAddress = CONTAINING_RECORD(Profile->Process, EPROCESS, Pcb);
        ObDereferenceObject ((PVOID)ProcessAddress);
    }

    return;
}

NTSTATUS
NtCreateProfile (
    __out PHANDLE ProfileHandle,
    __in HANDLE Process OPTIONAL,
    __in PVOID RangeBase,
    __in SIZE_T RangeSize,
    __in ULONG BucketSize,
    __in PULONG Buffer,
    __in ULONG BufferSize,
    __in KPROFILE_SOURCE ProfileSource,
    __in KAFFINITY Affinity
    )

/*++

Routine Description:

    This function creates a profile object.

Arguments:

    ProfileHandle - Supplies a pointer to a variable that will receive
                    the profile object handle.

    Process - Optionally, supplies the handle to the process whose
              address space to profile.  If the value is NULL (0), then
              all address spaces are included in the profile.

    RangeBase - Supplies the address of the first byte of the address
                  space for which profiling information is to be collected.


    RangeSize - Supplies the size of the range to profile in the
                address space.  RangeBase and RangeSize are interpreted
                such that RangeBase <= address < RangeBase+RangeSize
                will generate a profile hit.

    BucketSize - Supplies the LOG base 2 of the size of the profiling
                 bucket.  Thus, BucketSize = 2 yields four-byte
                 buckets, BucketSize = 7 yields 128-byte buckets.
                 All profile hits in a given bucket will increment
                 the corresponding counter in Buffer.  Buckets
                 cannot be smaller than a ULONG.  The acceptable range
                 of this value is 2 to 30 inclusive.

    Buffer - Supplies an array of ULONGs.  Each ULONG is a hit counter,
             which records the number of hits of the corresponding
             bucket.

    BufferSize - Size in bytes of Buffer.

    ProfileSource - Supplies the source for the profile interrupt

    Affinity - Supplies the processor set for the profile interrupt

--*/

{

    PEPROFILE Profile;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS ProcessAddress;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN HasPrivilege = FALSE;
    ULONG Segment = FALSE;
#ifdef i386
    USHORT PowerOf2;
#endif

    //
    // Verify that the base and size arguments are reasonable.
    //

    if (BufferSize == 0) {
        return STATUS_INVALID_PARAMETER_7;
    }

    //
    //        Improper use of bucket size.  If bucket size is zero, and
    //        RangeBase < 64K, then create a profile object to attach
    //        to a non-flat code segment.  In this case, RangeBase is
    //        the non-flat CS for this profile object.
    //

#ifdef i386

    if ((BucketSize == 0) && (RangeBase < (PVOID)(64 * 1024))) {

        if (BufferSize < sizeof(ULONG)) {
            return STATUS_INVALID_PARAMETER_7;
        }

        Segment = (ULONG)RangeBase;
        RangeBase = 0;
        BucketSize = RangeSize / (BufferSize / sizeof(ULONG));

        //
        // Convert Bucket size of log2(BucketSize)
        //
        PowerOf2 = 0;
        BucketSize = BucketSize - 1;
        while (BucketSize >>= 1) {
            PowerOf2++;
        }

        BucketSize = PowerOf2 + 1;

        if (BucketSize < 2) {
            BucketSize = 2;
        }
    }

#endif

    if ((BucketSize > 31) || (BucketSize < 2)) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((RangeSize >> (BucketSize - 2)) > BufferSize) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (((ULONG_PTR)RangeBase + RangeSize) < RangeSize) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a profile object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {
        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode ();

        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(ProfileHandle);

            ProbeForWrite(Buffer,
                          BufferSize,
                          sizeof(ULONG));
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    if (!ARGUMENT_PRESENT(Process)) {

        //
        // Don't attach segmented profile objects to all processes
        //

        if (Segment) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Profile all processes. Make sure that the specified
        // address range is in system space, unless SeSystemProfilePrivilege.
        //

        if (RangeBase <= MM_HIGHEST_USER_ADDRESS) {

            //
            // Check for privilege before allowing a user to profile
            // all processes and USER addresses.
            //

            if (PreviousMode != KernelMode) {
                HasPrivilege =  SeSinglePrivilegeCheck(
                                    SeSystemProfilePrivilege,
                                    PreviousMode
                                    );

                if (!HasPrivilege) {
#if DBG
                    DbgPrint("SeSystemProfilePrivilege needed to profile all USER addresses.\n");
#endif //DBG
                    return( STATUS_PRIVILEGE_NOT_HELD );
                }

            }
        }

        ProcessAddress = NULL;


    } else {

        //
        // Reference the specified process.
        //

        Status = ObReferenceObjectByHandle ( Process,
                                             PROCESS_QUERY_INFORMATION,
                                             PsProcessType,
                                             PreviousMode,
                                             (PVOID *)&ProcessAddress,
                                             NULL );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_EXCLUSIVE,
                                NULL,
                                NULL );

    Status = ObCreateObject( KernelMode,
                             ExProfileObjectType,
                             &ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof(EPROFILE),
                             0,
                             sizeof(EPROFILE) + sizeof(KPROFILE),
                             (PVOID *)&Profile);

    //
    // If the profile object was successfully allocated, initialize
    // the profile object.
    //
    if (NT_SUCCESS(Status)) {


        if (ProcessAddress != NULL) {
            Profile->Process = &ProcessAddress->Pcb;
        } else {
            Profile->Process = NULL;
        }

        Profile->RangeBase = RangeBase;
        Profile->RangeSize = RangeSize;
        Profile->Buffer = Buffer;
        Profile->BufferSize = BufferSize;
        Profile->BucketSize = BucketSize;
        Profile->LockedBufferAddress = NULL;
        Profile->Segment = Segment;
        Profile->ProfileSource = ProfileSource;
        Profile->Affinity = Affinity;

        Status = ObInsertObject(Profile,
                                NULL,
                                PROFILE_CONTROL,
                                0,
                                (PVOID *)NULL,
                                &Handle);
        //
        // If the profile object was successfully inserted in the current
        // process' handle table, then attempt to write the profile object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //
        if (NT_SUCCESS(Status)) {
            try {
                *ProfileHandle = Handle;
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }
    } else {
        //
        // We failed, remove our reference to the process object.
        //

        if (ProcessAddress != NULL) {
            ObDereferenceObject (ProcessAddress);
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtStartProfile (
    __in HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStartProfile routine starts the collecting data for the
    specified profile object.  This involved allocating nonpaged
    pool to lock the specified buffer in memory, creating a kernel
    profile object and starting collecting on that profile object.

Arguments:

    ProfileHandle - Supplies the profile handle to start profiling on.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROFILE Profile;
    PKPROFILE ProfileObject;
    PVOID LockedVa;
    BOOLEAN State;
    PMDL Mdl;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        &Profile,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Acquire the profile state mutex so two threads can't
    // operate on the same profile object simultaneously.
    //

    KeWaitForSingleObject (&ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Make sure profiling is not already enabled.
    //

    if (Profile->LockedBufferAddress != NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_NOT_STOPPED;
    }

    if (ExpCurrentProfileUsage == ACTIVE_PROFILE_LIMIT) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_AT_LIMIT;
    }

    ProfileObject = ExAllocatePoolWithTag (NonPagedPool,
                                    MmSizeOfMdl(Profile->Buffer,
                                                Profile->BufferSize) +
                                        sizeof(KPROFILE),
                                        'forP');

    if (ProfileObject == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Mdl = (PMDL)(ProfileObject + 1);
    Profile->Mdl = Mdl;
    Profile->ProfileObject = ProfileObject;

    //
    // Probe and lock the specified buffer.
    //

    MmInitializeMdl(Mdl, Profile->Buffer, Profile->BufferSize);

    LockedVa = NULL;

    try {

        MmProbeAndLockPages (Mdl,
                             PreviousMode,
                             IoWriteAccess );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ExFreePool (ProfileObject);
        ObDereferenceObject (Profile);
        return GetExceptionCode();
    }

    //
    // Since kernel space is specified below, this call cannot raise
    // an exception.
    //

    LockedVa = MmMapLockedPagesSpecifyCache (Profile->Mdl,
                                             KernelMode,
                                             MmCached,
                                             NULL,
                                             FALSE,
                                             NormalPagePriority);

    if (LockedVa == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);

        MmUnlockPages (Mdl);
        ExFreePool (ProfileObject);
        ObDereferenceObject (Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the profile object.
    //

    KeInitializeProfile (ProfileObject,
                         Profile->Process,
                         Profile->RangeBase,
                         Profile->RangeSize,
                         Profile->BucketSize,
                         Profile->Segment,
                         Profile->ProfileSource,
                         Profile->Affinity);

    State = KeStartProfile (ProfileObject, LockedVa);
    ASSERT (State != FALSE);

    Profile->LockedBufferAddress = LockedVa;

    KeReleaseMutex (&ExpProfileStateMutex, FALSE);
    ObDereferenceObject (Profile);

    return STATUS_SUCCESS;
}

NTSTATUS
NtStopProfile (
    __in HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStopProfile routine stops collecting data for the
    specified profile object.  This involves stopping the data
    collection on the profile object, unlocking the locked buffers,
    and deallocating the pool for the MDL and profile object.

Arguments:

    ProfileHandle - Supplies a the profile handle to stop profiling.

--*/

{

    PEPROFILE Profile;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    BOOLEAN State;
    PKPROFILE ProfileObject;
    PMDL Mdl;
    PVOID LockedBufferAddress;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle( ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        (PVOID *)&Profile,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeWaitForSingleObject( &ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Check to see if profiling is not active.
    //

    if (Profile->LockedBufferAddress == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_NOT_STARTED;
    }

    //
    // Stop profiling and unlock the buffer.
    //

    State = KeStopProfile (Profile->ProfileObject);
    ASSERT (State != FALSE);

    LockedBufferAddress = Profile->LockedBufferAddress;
    Profile->LockedBufferAddress = NULL;
    Mdl = Profile->Mdl;
    ProfileObject = Profile->ProfileObject;
    KeReleaseMutex (&ExpProfileStateMutex, FALSE);

    MmUnmapLockedPages (LockedBufferAddress, Mdl);
    MmUnlockPages (Mdl);
    ExFreePool (ProfileObject);
    ObDereferenceObject (Profile);
    return STATUS_SUCCESS;
}

NTSTATUS
NtSetIntervalProfile (
    __in ULONG Interval,
    __in KPROFILE_SOURCE Source
    )

/*++

Routine Description:

    This routine allows the system-wide interval (and thus the profiling
    rate) for profiling to be set.

Arguments:

    Interval - Supplies the sampling interval in 100ns units.

    Source - Specifies the profile source to be set.

--*/

{

    KeSetIntervalProfile (Interval, Source);
    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryIntervalProfile (
    __in KPROFILE_SOURCE ProfileSource,
    __out PULONG Interval
    )

/*++

Routine Description:

    This routine queries the system-wide interval (and thus the profiling
    rate) for profiling.

Arguments:

    Source - Specifies the profile source to be queried.

    Interval - Returns the sampling interval in 100ns units.

--*/

{
    ULONG CapturedInterval;
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = KeGetPreviousMode ();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteUlong (Interval);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }
    }

    CapturedInterval = KeQueryIntervalProfile (ProfileSource);

    if (PreviousMode != KernelMode) {
        try {
            *Interval = CapturedInterval;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        *Interval = CapturedInterval;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryPerformanceCounter (
    __out PLARGE_INTEGER PerformanceCounter,
    __out_opt PLARGE_INTEGER PerformanceFrequency
    )

/*++

Routine Description:

    This function returns current value of performance counter and,
    optionally, the frequency of the performance counter.

    Performance frequency is the frequency of the performance counter
    in Hertz, i.e., counts/second.  Note that this value is implementation
    dependent.  If the implementation does not have hardware to support
    performance timing, the value returned is 0.

Arguments:

    PerformanceCounter - supplies the address of a variable to receive
        the current Performance Counter value.

    PerformanceFrequency - Optionally, supplies the address of a
        variable to receive the performance counter frequency.

Return Value:

    STATUS_ACCESS_VIOLATION or STATUS_SUCCESS.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    LARGE_INTEGER KernelPerformanceFrequency;

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteSmallStructure (PerformanceCounter,
                                         sizeof (LARGE_INTEGER),
                                         sizeof (ULONG));

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                ProbeForWriteSmallStructure (PerformanceFrequency,
                                             sizeof (LARGE_INTEGER),
                                             sizeof (ULONG));
            }

            *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                *PerformanceFrequency = KernelPerformanceFrequency;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }

    } else {
        *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);
        if (ARGUMENT_PRESENT(PerformanceFrequency)) {
            *PerformanceFrequency = KernelPerformanceFrequency;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\pool.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pool.c

Abstract:

    This module implements the NT executive pool allocator.

--*/

#include "exp.h"

#pragma hdrstop

#undef ExAllocatePoolWithTag
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag
#undef ExFreePool
#undef ExFreePoolWithTag

//
// These bitfield definitions are based on EX_POOL_PRIORITY in inc\ex.h.
//

#define POOL_SPECIAL_POOL_BIT               0x8
#define POOL_SPECIAL_POOL_UNDERRUN_BIT      0x1

//
// Define forward referenced function prototypes.
//

#ifdef ALLOC_PRAGMA
PVOID
ExpAllocateStringRoutine (
    IN SIZE_T NumberOfBytes
    );

VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     );

VOID
ExpSeedHotTags (
    VOID
    );

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    );

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

#pragma alloc_text(PAGE, ExpAllocateStringRoutine)
#pragma alloc_text(INIT, InitializePool)
#pragma alloc_text(INIT, ExpSeedHotTags)
#pragma alloc_text(PAGE, ExInitializePoolDescriptor)
#pragma alloc_text(PAGE, ExDrainPoolLookasideList)
#pragma alloc_text(PAGE, ExCreatePoolTagTable)
#pragma alloc_text(PAGE, ExGetSessionPoolTagInfo)
#pragma alloc_text(PAGE, ExGetPoolTagInfo)
#pragma alloc_text(PAGEVRFY, ExAllocatePoolSanityChecks)
#pragma alloc_text(PAGEVRFY, ExFreePoolSanityChecks)
#pragma alloc_text(POOLCODE, ExAllocatePoolWithTag)
#pragma alloc_text(POOLCODE, ExFreePool)
#pragma alloc_text(POOLCODE, ExFreePoolWithTag)
#pragma alloc_text(POOLCODE, ExDeferredFreePool)
#endif

#if defined (NT_UP)
#define USING_HOT_COLD_METRICS (ExpPoolFlags & EX_SEPARATE_HOT_PAGES_DURING_BOOT)
#else
#define USING_HOT_COLD_METRICS 0
#endif

#define EXP_MAXIMUM_POOL_FREES_PENDING 32

PPOOL_DESCRIPTOR ExpSessionPoolDescriptor;
PGENERAL_LOOKASIDE ExpSessionPoolLookaside;
PPOOL_TRACKER_TABLE ExpSessionPoolTrackTable;
SIZE_T ExpSessionPoolTrackTableSize;
SIZE_T ExpSessionPoolTrackTableMask;
PPOOL_TRACKER_BIG_PAGES ExpSessionPoolBigPageTable;
SIZE_T ExpSessionPoolBigPageTableSize;
SIZE_T ExpSessionPoolBigPageTableHash;
ULONG ExpSessionPoolSmallLists;

#if DBG
ULONG ExpLargeSessionPoolUnTracked;
#endif
ULONG ExpBigTableExpansionFailed;
LONG ExpPoolBigEntriesInUse;

extern SIZE_T MmSizeOfNonPagedPoolInBytes;

#if defined (NT_UP)
KDPC ExpBootFinishedTimerDpc;
KTIMER ExpBootFinishedTimer;

VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#else

#if defined (_WIN64)
#define MAXIMUM_PROCESSOR_TAG_TABLES    64      // Must be a power of 2.
#else
#define MAXIMUM_PROCESSOR_TAG_TABLES    32      // Must be a power of 2.
#endif

PPOOL_TRACKER_TABLE ExPoolTagTables[MAXIMUM_PROCESSOR_TAG_TABLES];

#endif

#define DEFAULT_TRACKER_TABLE 2048

PPOOL_TRACKER_TABLE PoolTrackTable;

//
// Registry-overridable, but must be a power of 2.
//

SIZE_T PoolTrackTableSize;

SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_TABLE PoolTrackTableExpansion;
SIZE_T PoolTrackTableExpansionSize;
SIZE_T PoolTrackTableExpansionPages;

#define DEFAULT_BIGPAGE_TABLE 4096

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;

//
// Registry-overridable, but must be a power of 2.
//

SIZE_T PoolBigPageTableSize;   // Must be a power of 2.

SIZE_T PoolBigPageTableHash;

#define POOL_BIG_TABLE_ENTRY_FREE   0x1     // Must be the low bit since InterlockedAdd is used also to set/clear this.

ULONG PoolHitTag = 0xffffff0f;

FORCEINLINE
ULONG
POOLTAG_HASH (
    IN ULONG Key,
    IN SIZE_T Mask
    )

/*++

Routine Description:

    This function builds a hash table index based on the supplied pool
    tag.

Arguments:

    Key - Supplies the key value to hash.

    Mask - Supplies the mask value to apply to the resultant key to generate
           a valid hash table index.
           PoolDescriptor - Supplies a pointer to the pool descriptor.

Return Value:

    None.

--*/
{
    ULONG64 hash;

    hash = (ULONG64)Key * 40543;
    hash ^= hash >> 32;
    return (ULONG)(hash & Mask);
}

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpInsertPoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpRemovePoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages,
    IN POOL_TYPE PoolType
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    OUT PULONG BigPages,
    IN POOL_TYPE PoolType
    );

PVOID
ExpAllocateStringRoutine (
    IN SIZE_T NumberOfBytes
    )
{
    return ExAllocatePoolWithTag (PagedPool,NumberOfBytes,'grtS');
}

BOOLEAN
ExOkayToLockRoutine (
    IN PVOID Lock
    )
{
    UNREFERENCED_PARAMETER (Lock);

    if (KeIsExecutingDpc()) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = ExpAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = (PRTL_FREE_STRING_ROUTINE)ExFreePool;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

ULONG ExPoolFailures;

//
// Define macros to pack and unpack a pool index.
//

#define ENCODE_POOL_INDEX(POOLHEADER,INDEX) {(POOLHEADER)->PoolIndex = ((UCHAR)(INDEX));}
#define DECODE_POOL_INDEX(POOLHEADER)       ((ULONG)((POOLHEADER)->PoolIndex))

//
// The allocated bit carefully overlays the unused cachealign bit in the type.
//

#define POOL_IN_USE_MASK                            0x4

#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolType &= ~POOL_IN_USE_MASK;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolType & POOL_IN_USE_MASK)

//
// The hotpage bit carefully overlays the raise bit in the type.
//

#define POOL_HOTPAGE_MASK   POOL_RAISE_IF_ALLOCATION_FAILURE

//
// Define the number of paged pools. This value may be overridden at boot
// time.
//

ULONG ExpNumberOfPagedPools = NUMBER_OF_PAGED_POOLS;

ULONG ExpNumberOfNonPagedPools = 1;

//
// The pool descriptor for nonpaged pool is static.
// The pool descriptors for paged pool are dynamically allocated
// since there can be more than one paged pool. There is always one more
// paged pool descriptor than there are paged pools. This descriptor is
// used when a page allocation is done for a paged pool and is the first
// descriptor in the paged pool descriptor array.
//

POOL_DESCRIPTOR NonPagedPoolDescriptor;

#define EXP_MAXIMUM_POOL_NODES 16

PPOOL_DESCRIPTOR ExpNonPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES];

//
// The pool vector contains an array of pointers to pool descriptors. For
// nonpaged pool this is just a pointer to the nonpaged pool descriptor.
// For paged pool, this is a pointer to an array of pool descriptors.
// The pointer to the paged pool descriptor is duplicated so
// it can be found easily by the kernel debugger.
//

PPOOL_DESCRIPTOR PoolVector[NUMBER_OF_POOLS];
PPOOL_DESCRIPTOR ExpPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES + 1];
PKGUARDED_MUTEX ExpPagedPoolMutex;

volatile ULONG ExpPoolIndex = 1;
KSPIN_LOCK ExpTaggedPoolLock;

EX_SPIN_LOCK ExpLargePoolTableLock;

#if DBG

LONG ExConcurrentQuotaPool;
LONG ExConcurrentQuotaPoolMax;

PSZ PoolTypeNames[MaxPoolType] = {
    "NonPaged",
    "Paged",
    "NonPagedMustSucceed",
    "NotUsed",
    "NonPagedCacheAligned",
    "PagedCacheAligned",
    "NonPagedCacheAlignedMustS"
    };

#endif //DBG


//
// Define paged and nonpaged pool lookaside descriptors.
//

GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];



#define LOCK_POOL(PoolDesc, LockHandle) {                                   \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            LockHandle.OldIrql = KeAcquireQueuedSpinLock(LockQueueNonPagedPoolLock); \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeAcquireInStackQueuedSpinLock (PoolDesc->LockAddress, &LockHandle); \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        KeAcquireGuardedMutex ((PKGUARDED_MUTEX)PoolDesc->LockAddress);     \
    }                                                                       \
}



#define UNLOCK_POOL(PoolDesc, LockHandle) {                                 \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            KeReleaseQueuedSpinLock(LockQueueNonPagedPoolLock, LockHandle.OldIrql); \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeReleaseInStackQueuedSpinLock (&LockHandle);                   \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        KeReleaseGuardedMutex ((PKGUARDED_MUTEX)PoolDesc->LockAddress);     \
    }                                                                       \
}

#ifndef NO_POOL_CHECKS


//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define CHECK_LIST(LIST)                                                    \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

VOID
FORCEINLINE
ExCheckPoolHeader (
    IN PPOOL_HEADER Entry
    )
{
    PPOOL_HEADER PreviousEntry;
    PPOOL_HEADER NextEntry;

    if (Entry->PreviousSize != 0) {

        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (PAGE_ALIGN (Entry) != PAGE_ALIGN (PreviousEntry)) {
            KeBugCheckEx (BAD_POOL_HEADER,
                          6,
                          (ULONG_PTR) PreviousEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }

        if ((PreviousEntry->BlockSize != Entry->PreviousSize) ||
            (DECODE_POOL_INDEX(PreviousEntry) != DECODE_POOL_INDEX(Entry))) {

            KeBugCheckEx (BAD_POOL_HEADER,
                          5,
                          (ULONG_PTR) PreviousEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }
    }
    else if (!PAGE_ALIGNED (Entry)) {
        KeBugCheckEx (BAD_POOL_HEADER,
                      7,
                      0,
                      __LINE__,
                      (ULONG_PTR)Entry);
    }

    if (Entry->BlockSize == 0) {
        KeBugCheckEx (BAD_POOL_HEADER,
                      8,
                      0,
                      __LINE__,
                      (ULONG_PTR)Entry);
    }

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);

    if (!PAGE_END(NextEntry)) {

        if (PAGE_ALIGN (Entry) != PAGE_ALIGN (NextEntry)) {
            KeBugCheckEx (BAD_POOL_HEADER,
                          9,
                          (ULONG_PTR) NextEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }

        if ((NextEntry->PreviousSize != (Entry)->BlockSize) ||
            (DECODE_POOL_INDEX(NextEntry) != DECODE_POOL_INDEX(Entry))) {

            KeBugCheckEx (BAD_POOL_HEADER,
                          5,
                          (ULONG_PTR) NextEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }
    }
}

#define CHECK_POOL_HEADER(ENTRY) ExCheckPoolHeader(ENTRY)

#define ASSERT_ALLOCATE_IRQL(_PoolType, _NumberOfBytes)                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }

#define ASSERT_FREE_IRQL(_PoolType, _P)                                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)_P);                                                            \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)P);                                                             \
        }                                                               \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)PAGE_ALIGN(PAGE);                      \
        ULONG SIZE = 0;                                                       \
        LOGICAL FOUND=FALSE;                                                  \
        ASSERT (P->PreviousSize == 0);                                        \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            CHECK_POOL_HEADER(P);                                             \
            SIZE += P->BlockSize;                                             \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + P->BlockSize);                \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            KeBugCheckEx (BAD_POOL_HEADER, 0xA, (ULONG_PTR) PAGE, __LINE__, (ULONG_PTR) P); \
        }                                                                     \
    }

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_PoolType, _P) {NOTHING;}
#define ASSERT_FREE_IRQL(_PoolType, _P)     {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceding and succeeding pool headers.
//

#define CHECK_LIST(LIST)                        {NOTHING;}
#define CHECK_POOL_HEADER(ENTRY)                {NOTHING;}

#define CHECK_POOL_PAGE(PAGE)                   {NOTHING;}

#endif

#define EX_FREE_POOL_BACKTRACE_LENGTH 8

typedef struct _EX_FREE_POOL_TRACES {

    PETHREAD Thread;
    PVOID PoolAddress;
    POOL_HEADER PoolHeader;
    PVOID StackTrace [EX_FREE_POOL_BACKTRACE_LENGTH];

} EX_FREE_POOL_TRACES, *PEX_FREE_POOL_TRACES;

LONG ExFreePoolIndex;
LONG ExFreePoolMask = 0x4000 - 1;

PEX_FREE_POOL_TRACES ExFreePoolTraces;


VOID
ExInitializePoolDescriptor (
    IN PPOOL_DESCRIPTOR PoolDescriptor,
    IN POOL_TYPE PoolType,
    IN ULONG PoolIndex,
    IN ULONG Threshold,
    IN PVOID PoolLock
    )

/*++

Routine Description:

    This function initializes a pool descriptor.

    Note that this routine is called directly by the memory manager.

Arguments:

    PoolDescriptor - Supplies a pointer to the pool descriptor.

    PoolType - Supplies the type of the pool.

    PoolIndex - Supplies the pool descriptor index.

    Threshold - Supplies the threshold value for the specified pool.

    PoolLock - Supplies a pointer to the lock for the specified pool.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY LastListEntry;
    PPOOL_TRACKER_BIG_PAGES p;
    PPOOL_TRACKER_BIG_PAGES pend;

    //
    // Initialize statistics fields, the pool type, the threshold value,
    // and the lock address.
    //

    PoolDescriptor->PoolType = PoolType;
    PoolDescriptor->PoolIndex = PoolIndex;
    PoolDescriptor->RunningAllocs = 0;
    PoolDescriptor->RunningDeAllocs = 0;
    PoolDescriptor->TotalPages = 0;
    PoolDescriptor->TotalBytes = 0;
    PoolDescriptor->TotalBigPages = 0;
    PoolDescriptor->Threshold = Threshold;
    PoolDescriptor->LockAddress = PoolLock;

    PoolDescriptor->PendingFrees = NULL;
    PoolDescriptor->PendingFreeDepth = 0;

    //
    // Initialize the allocation listheads.
    //

    ListEntry = PoolDescriptor->ListHeads;
    LastListEntry = ListEntry + POOL_LIST_HEADS;

    while (ListEntry < LastListEntry) {
        PrivateInitializeListHead (ListEntry);
        ListEntry += 1;
    }

    if (PoolType == PagedPoolSession) {
            
        if (ExpSessionPoolDescriptor == NULL) {
            ExpSessionPoolDescriptor = (PPOOL_DESCRIPTOR) MiSessionPoolVector ();
            ExpSessionPoolLookaside = MiSessionPoolLookaside ();

            ExpSessionPoolTrackTable = (PPOOL_TRACKER_TABLE) MiSessionPoolTrackTable ();
            ExpSessionPoolTrackTableSize = MiSessionPoolTrackTableSize ();
            ExpSessionPoolTrackTableMask = ExpSessionPoolTrackTableSize - 1;

            ExpSessionPoolBigPageTable = (PPOOL_TRACKER_BIG_PAGES) MiSessionPoolBigPageTable ();
            ExpSessionPoolBigPageTableSize = MiSessionPoolBigPageTableSize ();
            ExpSessionPoolBigPageTableHash = ExpSessionPoolBigPageTableSize - 1;
            ExpSessionPoolSmallLists = MiSessionPoolSmallLists ();
        }

        p = &ExpSessionPoolBigPageTable[0];
        pend = p + ExpSessionPoolBigPageTableSize;

        while (p < pend) {
            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
            p += 1;
        }
    }

    return;
}

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
ExDrainPoolLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function drains the entries from the specified lookaside list.

    This is needed before deleting a pool lookaside list because the
    entries on the lookaside are already marked as free (by ExFreePoolWithTag)
    and so the normal lookaside deletion macros would hit false double free
    bugchecks if the list is not empty when the macros are called.

Arguments:

    Lookaside - Supplies a pointer to a lookaside list structure.

Return Value:

    None.

--*/

{
    PVOID Entry;
    PPOOL_HEADER PoolHeader;

    //
    // Remove all pool entries from the specified lookaside structure,
    // mark them as active, then free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;

    while ((Entry = ExAllocateFromPagedLookasideList(Lookaside)) != NULL) {

        PoolHeader = (PPOOL_HEADER)Entry - 1;

        PoolHeader->PoolType = (USHORT)(Lookaside->L.Type + 1);
        PoolHeader->PoolType |= POOL_IN_USE_MASK;

        ExpInsertPoolTracker (PoolHeader->PoolTag,
                              PoolHeader->BlockSize << POOL_BLOCK_SHIFT,
                              Lookaside->L.Type);

        //
        // Set the depth to zero every time as a periodic scan may set it
        // nonzero.  This isn't worth interlocking as the list will absolutely
        // deplete regardless in this fashion anyway.
        //

        Lookaside->L.Depth = 0;

        (Lookaside->L.Free)(Entry);
    }

    return;
}

//
// FREE_CHECK_ERESOURCE - If enabled causes each free pool to verify
// no active ERESOURCEs are in the pool block being freed.
//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

//
// Checking for resources in pool being freed is expensive as there can
// easily be thousands of resources, so don't do it by default but do
// leave the capability for individual systems to enable it.
//

//
// Runtime modifications to these flags must use interlocked sequences.
//

#if DBG
ULONG ExpPoolFlags = EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS | \
                     EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS;
#else
ULONG ExpPoolFlags = 0;
#endif

#define FREE_CHECK_ERESOURCE(Va, NumberOfBytes)                             \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES) {  \
                ExpCheckForResource(Va, NumberOfBytes);                     \
            }

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS) {     \
                KeCheckForTimer(Va, NumberOfBytes);                         \
            }

#define FREE_CHECK_WORKER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS) {    \
                ExpCheckForWorker(Va, NumberOfBytes);                       \
            }


VOID
ExSetPoolFlags (
    IN ULONG PoolFlag
    )

/*++

Routine Description:

    This procedure enables the specified pool flag(s).

Arguments:

    PoolFlag - Supplies the pool flag(s) to enable.

Return Value:

    None.

--*/
{
    RtlInterlockedSetBits (&ExpPoolFlags, PoolFlag);
}


VOID
InitializePool (
    IN POOL_TYPE PoolType,
    IN ULONG Threshold
    )

/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    PoolType - Supplies the type of pool being initialized (e.g.
               nonpaged pool, paged pool...).

    Threshold - Supplies the threshold value for the specified pool.

Return Value:

    None.

--*/

{
    ULONG i;
    PKSPIN_LOCK SpinLock;
    PPOOL_TRACKER_BIG_PAGES p;
    PPOOL_DESCRIPTOR Descriptor;
    ULONG Index;
    PKGUARDED_MUTEX GuardedMutex;
    SIZE_T NumberOfBytes;

    ASSERT((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0);

    if (PoolType == NonPagedPool) {

        //
        // Initialize nonpaged pools.
        //
        // Ensure PoolTrackTableSize is a power of 2, then add 1 to it.
        //
        // Ensure PoolBigPageTableSize is a power of 2.
        //

        NumberOfBytes = PoolTrackTableSize;
        if (NumberOfBytes > MmSizeOfNonPagedPoolInBytes >> 8) {
            NumberOfBytes = MmSizeOfNonPagedPoolInBytes >> 8;
        }

        for (i = 0; i < 32; i += 1) {
            if (NumberOfBytes & 0x1) {
                ASSERT ((NumberOfBytes & ~0x1) == 0);
                if ((NumberOfBytes & ~0x1) == 0) {
                    break;
                }
            }
            NumberOfBytes >>= 1;
        }

        if (i == 32) {
            PoolTrackTableSize = DEFAULT_TRACKER_TABLE;
        }
        else {
            PoolTrackTableSize = ((SIZE_T)1) << i;
            if (PoolTrackTableSize < 64) {
                PoolTrackTableSize = 64;
            }
        }

        do {
            if (PoolTrackTableSize + 1 > (MAXULONG_PTR / sizeof(POOL_TRACKER_TABLE))) {
                PoolTrackTableSize >>= 1;
                continue;
            }

            PoolTrackTable = MiAllocatePoolPages (NonPagedPool,
                                                  (PoolTrackTableSize + 1) *
                                                    sizeof(POOL_TRACKER_TABLE));

            if (PoolTrackTable != NULL) {
                break;
            }

            if (PoolTrackTableSize == 1) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            PoolTrackTableSize >>= 1;

        } while (TRUE);

        PoolTrackTableSize += 1;
        PoolTrackTableMask = PoolTrackTableSize - 2;

#if !defined (NT_UP)
        ExPoolTagTables[0] = PoolTrackTable;
#endif

        RtlZeroMemory (PoolTrackTable,
                       PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        ExpSeedHotTags ();

        //
        // Initialize the large allocation tag table.
        //

        NumberOfBytes = PoolBigPageTableSize;
        if (NumberOfBytes > MmSizeOfNonPagedPoolInBytes >> 8) {
            NumberOfBytes = MmSizeOfNonPagedPoolInBytes >> 8;
        }

        for (i = 0; i < 32; i += 1) {
            if (NumberOfBytes & 0x1) {
                ASSERT ((NumberOfBytes & ~0x1) == 0);
                if ((NumberOfBytes & ~0x1) == 0) {
                    break;
                }
            }
            NumberOfBytes >>= 1;
        }

        if (i == 32) {
            PoolBigPageTableSize = DEFAULT_BIGPAGE_TABLE;
        }
        else {
            PoolBigPageTableSize = ((SIZE_T)1) << i;
            if (PoolBigPageTableSize < 64) {
                PoolBigPageTableSize = 64;
            }
        }

        do {
            if (PoolBigPageTableSize > (MAXULONG_PTR / sizeof(POOL_TRACKER_BIG_PAGES))) {
                PoolBigPageTableSize >>= 1;
                continue;
            }

            PoolBigPageTable = MiAllocatePoolPages (NonPagedPool,
                                                PoolBigPageTableSize *
                                                sizeof(POOL_TRACKER_BIG_PAGES));

            if (PoolBigPageTable != NULL) {
                break;
            }

            if (PoolBigPageTableSize == 1) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            PoolBigPageTableSize >>= 1;

        } while (TRUE);

        PoolBigPageTableHash = PoolBigPageTableSize - 1;

        RtlZeroMemory (PoolBigPageTable,
                       PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));

        p = &PoolBigPageTable[0];
        for (i = 0; i < PoolBigPageTableSize; i += 1, p += 1) {
            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
        }

        ExpInsertPoolTracker ('looP',
                              ROUND_TO_PAGES(PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES)),
                              NonPagedPool);

        if (KeNumberNodes > 1) {

            ExpNumberOfNonPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfNonPagedPools > 127) {
                ExpNumberOfNonPagedPools = 127;
            }

            //
            // Further limit the number of pools by our array of pointers.
            //

            if (ExpNumberOfNonPagedPools > EXP_MAXIMUM_POOL_NODES) {
                ExpNumberOfNonPagedPools = EXP_MAXIMUM_POOL_NODES;
            }

            NumberOfBytes = sizeof(POOL_DESCRIPTOR) + sizeof(KLOCK_QUEUE_HANDLE);

            for (Index = 0; Index < ExpNumberOfNonPagedPools; Index += 1) {

                //
                // Here's a thorny problem.  We'd like to use
                // MmAllocateIndependentPages but can't because we'd need
                // system PTEs to map the pages with and PTEs are not
                // available until nonpaged pool exists.  So just use
                // regular pool pages to hold the descriptors and spinlocks
                // and hope they either a) happen to fall onto the right node 
                // or b) that these lines live in the local processor cache
                // all the time anyway due to frequent usage.
                //

                Descriptor = (PPOOL_DESCRIPTOR) MiAllocatePoolPages (
                                                         NonPagedPool,
                                                         NumberOfBytes);

                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  NumberOfBytes,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }

                ExpNonPagedPoolDescriptor[Index] = Descriptor;

                SpinLock = (PKSPIN_LOCK)(Descriptor + 1);

                KeInitializeSpinLock (SpinLock);

                ExInitializePoolDescriptor (Descriptor,
                                            NonPagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID)SpinLock);
            }
        }

        //
        // Initialize the spinlocks for nonpaged pool.
        //

        KeInitializeSpinLock (&ExpTaggedPoolLock);

        //
        // Initialize the nonpaged pool descriptor.
        //

        PoolVector[NonPagedPool] = &NonPagedPoolDescriptor;
        ExInitializePoolDescriptor (&NonPagedPoolDescriptor,
                                    NonPagedPool,
                                    0,
                                    Threshold,
                                    NULL);
    }
    else {

        //
        // Allocate memory for the paged pool descriptors and fast mutexes.
        //

        if (KeNumberNodes > 1) {

            ExpNumberOfPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfPagedPools > 127) {
                ExpNumberOfPagedPools = 127;
            }
        }

        //
        // Further limit the number of pools by our array of pointers.
        //

        if (ExpNumberOfPagedPools > EXP_MAXIMUM_POOL_NODES) {
            ExpNumberOfPagedPools = EXP_MAXIMUM_POOL_NODES;
        }

        //
        // For NUMA systems, allocate both the pool descriptor and the
        // associated lock from the local node for performance (even though
        // it costs a little more memory).
        //
        // For non-NUMA systems, allocate everything together in one chunk
        // to reduce memory consumption as there is no performance cost
        // for doing it this way.
        //

        if (KeNumberNodes > 1) {

            NumberOfBytes = sizeof(KGUARDED_MUTEX) + sizeof(POOL_DESCRIPTOR);

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {

                ULONG Node;

                if (Index == 0) {
                    Node = 0;
                }
                else {
                    Node = Index - 1;
                }

                Descriptor = (PPOOL_DESCRIPTOR) MmAllocateIndependentPages (
                                                                      NumberOfBytes,
                                                                      Node);
                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  NumberOfBytes,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }
                ExpPagedPoolDescriptor[Index] = Descriptor;

                GuardedMutex = (PKGUARDED_MUTEX)(Descriptor + 1);

                if (Index == 0) {
                    PoolVector[PagedPool] = Descriptor;
                    ExpPagedPoolMutex = GuardedMutex;
                }

                KeInitializeGuardedMutex (GuardedMutex);

                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID) GuardedMutex);
            }
        }
        else {

            NumberOfBytes = (ExpNumberOfPagedPools + 1) * (sizeof(KGUARDED_MUTEX) + sizeof(POOL_DESCRIPTOR));

            Descriptor = (PPOOL_DESCRIPTOR)ExAllocatePoolWithTag (NonPagedPool,
                                                                  NumberOfBytes,
                                                                  'looP');
            if (Descriptor == NULL) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            GuardedMutex = (PKGUARDED_MUTEX)(Descriptor + ExpNumberOfPagedPools + 1);

            PoolVector[PagedPool] = Descriptor;
            ExpPagedPoolMutex = GuardedMutex;

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
                KeInitializeGuardedMutex (GuardedMutex);
                ExpPagedPoolDescriptor[Index] = Descriptor;
                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID) GuardedMutex);

                Descriptor += 1;
                GuardedMutex += 1;
            }
        }

        ExpInsertPoolTracker('looP',
                              ROUND_TO_PAGES(PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE)),
                             NonPagedPool);

#if defined (NT_UP)
        if (MmNumberOfPhysicalPages < 32 * 1024) {

            LARGE_INTEGER TwoMinutes;

            //
            // Set the flag to disable lookasides and use hot/cold page
            // separation during bootup.
            //

            ExSetPoolFlags (EX_SEPARATE_HOT_PAGES_DURING_BOOT);

            //
            // Start a timer so the above behavior is disabled once bootup
            // has finished.
            //

            KeInitializeTimer (&ExpBootFinishedTimer);

            KeInitializeDpc (&ExpBootFinishedTimerDpc,
                             (PKDEFERRED_ROUTINE) ExpBootFinishedDispatch,
                             NULL);

            TwoMinutes.QuadPart = Int32x32To64 (120, -10000000);

            KeSetTimer (&ExpBootFinishedTimer,
                        TwoMinutes,
                        &ExpBootFinishedTimerDpc);
        }
#endif
        if ((MmNumberOfPhysicalPages >= 127 * 1024) &&
            ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) == 0) &&
            (!NT_SUCCESS (MmIsVerifierEnabled (&i)))) {

            ExSetPoolFlags (EX_DELAY_POOL_FREES);
        }

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) ||
            (NT_SUCCESS (MmIsVerifierEnabled (&i)))) {

#if DBG

            //
            // Ensure ExFreePoolMask is a power of 2 minus 1 (or zero).
            //

            if (ExFreePoolMask != 0) {

                NumberOfBytes = ExFreePoolMask + 1;
                ASSERT (NumberOfBytes != 0);

                for (i = 0; i < 32; i += 1) {
                    if (NumberOfBytes & 0x1) {
                        ASSERT ((NumberOfBytes & ~0x1) == 0);
                        break;
                    }
                    NumberOfBytes >>= 1;
                }
            }

#endif

            ExFreePoolTraces = MiAllocatePoolPages (NonPagedPool,
                                                (ExFreePoolMask + 1) *
                                                sizeof (EX_FREE_POOL_TRACES));

            if (ExFreePoolTraces != NULL) {
                RtlZeroMemory (ExFreePoolTraces,
                           (ExFreePoolMask + 1) * sizeof (EX_FREE_POOL_TRACES));
            }
        }
    }
}

#if DBG
ULONG ExStopBadTags;
#endif


FORCEINLINE
VOID
ExpInsertPoolTrackerInline (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table, increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held except during the rare case of expansion table growth.
    so pool may be freely allocated here as needed.  In expansion table growth,
    the tagged spinlock is held on entry, but we are guaranteed to find an
    entry in the builtin table so a recursive acquire cannot occur.

--*/

{
    ULONG Hash;
    ULONG Index;
    LONG OriginalKey;
    KIRQL OldIrql;
    PPOOL_TRACKER_TABLE TrackTable;
    PPOOL_TRACKER_TABLE TrackTableEntry;
    SIZE_T TrackTableMask;
    SIZE_T TrackTableSize;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // Strip the protected pool bit.
    //

    Key &= ~PROTECTED_POOL;

    if (Key == PoolHitTag) {
        DbgBreakPoint();
    }

#if DBG
    if (ExStopBadTags) {
        ASSERT (Key & 0xFFFFFF00);
    }
#endif

    //
    // Compute the hash index and search (lock-free) for the pool tag
    // in the builtin table.
    //

    if (PoolType & SESSION_POOL_MASK) {
        TrackTable = ExpSessionPoolTrackTable;
        TrackTableMask = ExpSessionPoolTrackTableMask;
        TrackTableSize = ExpSessionPoolTrackTableSize;
    }
    else {

#if !defined (NT_UP)

        //
        // Use the current processor to pick a pool tag table to use.  Note that
        // in rare cases, this thread may context switch to another processor
        // but the algorithms below will still be correct.
        //

        Processor = KeGetCurrentProcessorNumber ();

        ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

        TrackTable = ExPoolTagTables[Processor];

#else

        TrackTable = PoolTrackTable;

#endif

        TrackTableMask = PoolTrackTableMask;
        TrackTableSize = PoolTrackTableSize;
    }

    Hash = POOLTAG_HASH (Key, TrackTableMask);

    Index = Hash;

    do {

        TrackTableEntry = &TrackTable[Hash];

        if (TrackTableEntry->Key == Key) {

            //
            // Update the fields with interlocked operations as other
            // threads may also have begun doing so by this point.
            //

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                InterlockedIncrement ((PLONG) &TrackTableEntry->PagedAllocs);
                InterlockedExchangeAddSizeT (&TrackTableEntry->PagedBytes,
                                             NumberOfBytes);
            }
            else {
                InterlockedIncrement ((PLONG) &TrackTableEntry->NonPagedAllocs);
                InterlockedExchangeAddSizeT (&TrackTableEntry->NonPagedBytes,
                                             NumberOfBytes);

            }

            return;
        }

        if (TrackTableEntry->Key == 0) {

            if (PoolType & SESSION_POOL_MASK) {

                if (Hash == TrackTableSize - 1) {
                    Hash = 0;
                    if (Hash == Index) {
                        break;
                    }
                }
                else {

                    OriginalKey = InterlockedCompareExchange ((PLONG)&TrackTable[Hash].Key,
                                                              (LONG)Key,
                                                              0);
                }

                //
                // Either this thread has won the race and the requested tag
                // is now in or some other thread won the race and took this
                // slot (using this tag or a different one).
                //
                // Just fall through to common checks starting at this slot
                // for both cases.
                //

                continue;
            }

#if !defined (NT_UP)

            if (PoolTrackTable[Hash].Key != 0) {
                TrackTableEntry->Key = PoolTrackTable[Hash].Key;
                continue;
            }

#endif

            if (Hash != PoolTrackTableSize - 1) {

                //
                // New entries cannot be created with an interlocked compare
                // exchange because any new entry must reside at the same index
                // in each processor's private PoolTrackTable.  This is to make
                // ExGetPoolTagInfo statistics gathering much simpler (faster).
                //

                ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

                if (PoolTrackTable[Hash].Key == 0) {

                    ASSERT (TrackTable[Hash].Key == 0);

                    PoolTrackTable[Hash].Key = Key;
                    TrackTableEntry->Key = Key;
                }

                ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

                //
                // Either this thread has won the race and the requested tag
                // is now in or some other thread won the race and took this
                // slot (using this tag or a different one).
                //
                // Just fall through to common checks starting at this slot
                // for both cases.
                //

                continue;
            }
        }

        Hash = (Hash + 1) & (ULONG)TrackTableMask;

        if (Hash == Index) {
            break;
        }

    } while (TRUE);

    //
    // No matching entry and no free entry was found.
    //
    // Use the expansion table instead.
    //

    ExpInsertPoolTrackerExpansion (Key, NumberOfBytes, PoolType);
}

FORCEINLINE
VOID
ExpRemovePoolTrackerInline (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

--*/

{
    ULONG Hash;
    ULONG Index;
    PPOOL_TRACKER_TABLE TrackTable;
    PPOOL_TRACKER_TABLE TrackTableEntry;
    SIZE_T TrackTableMask;
    SIZE_T TrackTableSize;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // Strip protected pool bit.
    //

    Key &= ~PROTECTED_POOL;
    if (Key == PoolHitTag) {
        DbgBreakPoint ();
    }

    //
    // Compute the hash index and search (lock-free) for the pool tag
    // in the builtin table.
    //

    if (PoolType & SESSION_POOL_MASK) {
        TrackTable = ExpSessionPoolTrackTable;
        TrackTableMask = ExpSessionPoolTrackTableMask;
        TrackTableSize = ExpSessionPoolTrackTableSize;
    }
    else {

#if !defined (NT_UP)

        //
        // Use the current processor to pick a pool tag table to use.  Note that
        // in rare cases, this thread may context switch to another processor
        // but the algorithms below will still be correct.
        //

        Processor = KeGetCurrentProcessorNumber ();

        ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

        TrackTable = ExPoolTagTables[Processor];

#else

        TrackTable = PoolTrackTable;

#endif

        TrackTableMask = PoolTrackTableMask;
        TrackTableSize = PoolTrackTableSize;
    }

    Hash = POOLTAG_HASH (Key, TrackTableMask);

    Index = Hash;

    do {
        TrackTableEntry = &TrackTable[Hash];

        if (TrackTableEntry->Key == Key) {

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                InterlockedIncrement ((PLONG) &TrackTableEntry->PagedFrees);
                InterlockedExchangeAddSizeT (&TrackTableEntry->PagedBytes,
                                             0 - NumberOfBytes);
            }
            else {
                InterlockedIncrement ((PLONG) &TrackTableEntry->NonPagedFrees);
                InterlockedExchangeAddSizeT (&TrackTableEntry->NonPagedBytes,
                                             0 - NumberOfBytes);
            }
            return;
        }

        //
        // Since each processor's table is lazy updated, handle the case
        // here where this processor's table still has no entry for the tag
        // being freed because the allocation happened on a different
        // processor.
        //

        if (TrackTableEntry->Key == 0) {

#if !defined (NT_UP)

            if (((PoolType & SESSION_POOL_MASK) == 0) &&
                (PoolTrackTable[Hash].Key != 0)) {

                TrackTableEntry->Key = PoolTrackTable[Hash].Key;
                continue;
            }

#endif

            ASSERT (Hash == TrackTableMask);
        }

        Hash = (Hash + 1) & (ULONG)TrackTableMask;

        if (Hash == Index) {
            break;
        }

    } while (TRUE);

    //
    // No matching entry and no free entry was found.
    //
    // Linear search through the expansion table.  This is ok because
    // the existence of an expansion table at all is extremely rare.
    //

    ExpRemovePoolTrackerExpansion (Key, NumberOfBytes, PoolType);
}
PVOID
VeAllocatePoolWithTagPriority (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority,
    IN PVOID CallingAddress
    );


__bcount(NumberOfBytes) 
PVOID
ExAllocatePoolWithTag (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    PoolType - Supplies the type of pool to allocate. If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustSucceed

    Tag - Supplies the caller's identifying tag.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    PKGUARDED_MUTEX Lock;
    PVOID Block;
    PPOOL_HEADER Entry;
    PGENERAL_LOOKASIDE LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_DESCRIPTOR PoolDesc;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    ULONG PoolIndex;
    POOL_TYPE CheckType;
    POOL_TYPE RequestType;
    PLIST_ENTRY ListHead;
    POOL_TYPE NewPoolType;
    PKPRCB Prcb;
    ULONG NumberOfPages;
    ULONG RetryCount;
    PVOID CallingAddress;
#if defined (_X86_)
    PVOID CallersCaller;
#endif

#define CacheOverhead POOL_OVERHEAD

    PERFINFO_EXALLOCATEPOOLWITHTAG_DECL();

    ASSERT (Tag != 0);
    ASSERT (Tag != ' GIB');
    ASSERT (NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL (PoolType, NumberOfBytes);

    if (ExpPoolFlags & (EX_KERNEL_VERIFIER_ENABLED | EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_KERNEL_VERIFIER_ENABLED) {

            if ((PoolType & POOL_DRIVER_MASK) == 0) {

                //
                // Use the Driver Verifier pool framework.  Note this will
                // result in a recursive callback to this routine.
                //

#if defined (_X86_)
                RtlGetCallersAddress (&CallingAddress, &CallersCaller);
#else
                CallingAddress = (PVOID)_ReturnAddress();
#endif

                return VeAllocatePoolWithTagPriority (PoolType | POOL_DRIVER_MASK,
                                                  NumberOfBytes,
                                                  Tag,
                                                  HighPoolPriority,
                                                  CallingAddress);
            }
            PoolType &= ~POOL_DRIVER_MASK;
        }

        //
        // Use special pool if there is a tag or size match.
        //

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmUseSpecialPool (NumberOfBytes, Tag))) {

            Entry = MmAllocateSpecialPool (NumberOfBytes,
                                           Tag,
                                           PoolType,
                                           2);
            if (Entry != NULL) {
                return (PVOID)Entry;
            }
        }
    }

    //
    // Isolate the base pool type and select a pool from which to allocate
    // the specified block size.
    //

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    if ((PoolType & SESSION_POOL_MASK) == 0) {
        PoolDesc = PoolVector[CheckType];
    }
    else {
        PoolDesc = ExpSessionPoolDescriptor;
    }

    ASSERT (PoolDesc != NULL);

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        RequestType = (PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK));

        Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType,
                                                    NumberOfBytes);

        if (Entry == NULL) {

            //
            // If there are deferred free blocks, free them now and retry.
            //

            if (ExpPoolFlags & EX_DELAY_POOL_FREES) {

                ExDeferredFreePool (PoolDesc);

                Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType,
                                                            NumberOfBytes);
            }
        }

        if (Entry == NULL) {

            if (PoolType & MUST_SUCCEED_POOL_TYPE_MASK) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              NonPagedPoolDescriptor.TotalPages,
                              NonPagedPoolDescriptor.TotalBigPages,
                              0);
            }

            ExPoolFailures += 1;

            if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
                KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                    NumberOfBytes,
                    PoolType));
                if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                    DbgBreakPoint ();
                }
            }

            if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            return NULL;
        }

        NumberOfPages = (ULONG) BYTES_TO_PAGES (NumberOfBytes);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalBigPages,
                                (LONG)NumberOfPages);

        InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                                     (SIZE_T)NumberOfPages << PAGE_SHIFT);

        InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

        //
        // Mark the allocation as session-based so that when it is freed
        // we can detect that the session pool descriptor is the one to
        // be credited (not the global nonpaged descriptor).
        //

        if ((PoolType & SESSION_POOL_MASK) && (CheckType == NonPagedPool)) {
            MiMarkPoolLargeSession (Entry);
        }

        //
        // Note nonpaged session allocations get turned into global
        // session allocations internally, so they must be added to the
        // global tag tables.  Paged session allocations go into their
        // own tables.
        //

        if (ExpAddTagForBigPages ((PVOID)Entry,
                                  Tag,
                                  NumberOfPages,
                                  PoolType) == FALSE) {

            //
            // Note that not being able to add the tag entry above
            // implies 2 things: The allocation must now be tagged
            // as BIG because the subsequent free also won't find it
            // in the big page tag table and so it must use BIG when
            // removing it from the PoolTrackTable.  Also that the free
            // must get the size from MiFreePoolPages since the
            // big page tag table won't have the size in this case.
            //

            Tag = ' GIB';
        }

        ExpInsertPoolTracker (Tag,
                              ROUND_TO_PAGES(NumberOfBytes),
                              PoolType);

        PERFINFO_BIGPOOLALLOC (PoolType, Tag, NumberOfBytes, Entry);

        return Entry;
    }

    if (NumberOfBytes == 0) {

        //
        // Besides fragmenting pool, zero byte requests would not be handled
        // in cases where the minimum pool block size is the same as the 
        // pool header size (no room for flink/blinks, etc).
        //

#if DBG
        KeBugCheckEx (BAD_POOL_CALLER, 0, 0, PoolType, Tag);
#else
        NumberOfBytes = 1;
#endif
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    PERFINFO_POOLALLOC (PoolType, Tag, NumberOfBytes);

    //
    // Compute the index of the listhead for blocks of the requested size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    if (CheckType == PagedPool) {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //
        // Also note that if hot/cold separation is enabled, allocations are
        // not satisfied from lookaside lists as these are either :
        //
        // 1. cold references
        //
        // or
        //
        // 2. we are still booting on a small machine, thus keeping pool
        //    locality dense (to reduce the working set footprint thereby
        //    reducing page stealing) is a bigger win in terms of overall
        //    speed than trying to satisfy individual requests more quickly.
        //

        if ((PoolType & SESSION_POOL_MASK) == 0) {

            //
            // Check for prototype pool - always allocate it from its own
            // pages as the sharecounts applied on these allocations by
            // memory management make it more difficult to trim these pages.
            // This is an optimization so that other pageable allocation pages
            // (which are much easier to trim because their sharecount is
            // almost always only 1) don't end up being mostly resident because
            // of a single prototype pool allocation within in.  Note this
            // also makes it easier to remove specific pages for hot remove
            // or callers that need contiguous physical memory.
            //

            if (PoolType & POOL_MM_ALLOCATION) {
                PoolIndex = 0;
                ASSERT (PoolDesc->PoolIndex == 0);
                goto restart1;
            }

            if ((NeededSize <= POOL_SMALL_LISTS) &&
                (USING_HOT_COLD_METRICS == 0)) {

                Prcb = KeGetCurrentPrcb ();
                LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].P;
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                    InterlockedPopEntrySList (&LookasideList->ListHead);

                if (Entry == NULL) {
                    LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].L;
                    LookasideList->TotalAllocates += 1;

                    Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);
                }

                if (Entry != NULL) {

                    Entry -= 1;
                    LookasideList->AllocateHits += 1;
                    NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                    NewPoolType |= POOL_IN_USE_MASK;

                    Entry->PoolType = (UCHAR)NewPoolType;

                    Entry->PoolTag = Tag;

                    ExpInsertPoolTrackerInline (Tag,
                                                Entry->BlockSize << POOL_BLOCK_SHIFT,
                                                PoolType);

                    //
                    // Zero out any back pointer to our internal structures
                    // to stop someone from corrupting us via an
                    // uninitialized pointer.
                    //

                    ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                    PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                    return (PUCHAR)Entry + CacheOverhead;
                }
            }

            //
            // If there is more than one paged pool, then attempt to find
            // one that can be immediately locked.
            //
            //
            // N.B. The paged pool is selected in a round robin fashion using a
            //      simple counter.  Note that the counter is incremented using
            //      a a noninterlocked sequence, but the pool index is never
            //      allowed to get out of range.
            //

            if (USING_HOT_COLD_METRICS)  {

                if ((PoolType & POOL_COLD_ALLOCATION) == 0) {

                    //
                    // Hot allocations come from the first paged pool.
                    //

                    PoolIndex = 1;
                }
                else {

                    //
                    // Force cold allocations to come from
                    // the last paged pool.
                    //

                    PoolIndex = ExpNumberOfPagedPools;
                }
            }
            else {

                if (KeNumberNodes > 1) {

                    //
                    // Use the pool descriptor which contains memory
                    // local to the current processor even if we have to
                    // wait for it.  While it is possible that the
                    // paged pool addresses in the local descriptor
                    // have been paged out, on large memory
                    // NUMA machines this should be less common.
                    //

                    Prcb = KeGetCurrentPrcb ();

                    PoolIndex = Prcb->ParentNode->Color;

                    if (PoolIndex < ExpNumberOfPagedPools) {
                        PoolIndex += 1;
                        PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
                        RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
                        RetryCount = 0;
                        goto restart2;
                    }
                }

                PoolIndex = 1;
                if (ExpNumberOfPagedPools != PoolIndex) {
                    ExpPoolIndex += 1;
                    PoolIndex = ExpPoolIndex;
                    if (PoolIndex > ExpNumberOfPagedPools) {
                        PoolIndex = 1;
                        ExpPoolIndex = 1;
                    }

                    Index = PoolIndex;
                    do {
                        Lock = (PKGUARDED_MUTEX) ExpPagedPoolDescriptor[PoolIndex]->LockAddress;

                        if (KeGetOwnerGuardedMutex (Lock) == NULL) {
                            break;
                        }

                        PoolIndex += 1;
                        if (PoolIndex > ExpNumberOfPagedPools) {
                            PoolIndex = 1;
                        }

                    } while (PoolIndex != Index);
                }
            }

            PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
        }
        else {

            if (NeededSize <= ExpSessionPoolSmallLists) {

                LookasideList = (PGENERAL_LOOKASIDE)(ULONG_PTR)(ExpSessionPoolLookaside + NeededSize - 1);
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                    InterlockedPopEntrySList (&LookasideList->ListHead);

                if (Entry != NULL) {

                    Entry -= 1;
                    LookasideList->AllocateHits += 1;
                    NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                    NewPoolType |= POOL_IN_USE_MASK;

                    Entry->PoolType = (UCHAR)NewPoolType;

                    Entry->PoolTag = Tag;

                    ExpInsertPoolTrackerInline (Tag,
                                                Entry->BlockSize << POOL_BLOCK_SHIFT,
                                                PoolType);

                    //
                    // Zero out any back pointer to our internal structures
                    // to stop someone from corrupting us via an
                    // uninitialized pointer.
                    //

                    ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                    PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                    return (PUCHAR)Entry + CacheOverhead;
                }
            }

            //
            // Only one paged pool is available per session.
            //

            PoolIndex = 0;
            ASSERT (PoolDesc == ExpSessionPoolDescriptor);
            ASSERT (PoolDesc->PoolIndex == 0);
        }
    }
    else {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //
        // Only session paged pool allocations come from the per session pools.
        // Nonpaged session pool allocations still come from global pool.
        //

        if (NeededSize <= POOL_SMALL_LISTS) {

            Prcb = KeGetCurrentPrcb ();
            LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].P;
            LookasideList->TotalAllocates += 1;

            Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);

            if (Entry == NULL) {
                LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].L;
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);
            }

            if (Entry != NULL) {

                Entry -= 1;
                LookasideList->AllocateHits += 1;
                NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                NewPoolType |= POOL_IN_USE_MASK;

                Entry->PoolType = (UCHAR)NewPoolType;

                Entry->PoolTag = Tag;

                ExpInsertPoolTrackerInline (Tag,
                                            Entry->BlockSize << POOL_BLOCK_SHIFT,
                                            PoolType);

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                return (PUCHAR)Entry + CacheOverhead;
            }
        }

        if (PoolType & SESSION_POOL_MASK) {
            PoolDesc = PoolVector[CheckType];
        }

        if (ExpNumberOfNonPagedPools <= 1) {
            PoolIndex = 0;
        }
        else {

            //
            // Use the pool descriptor which contains memory local to
            // the current processor even if we have to contend for its lock.
            //

            Prcb = KeGetCurrentPrcb ();

            PoolIndex = Prcb->ParentNode->Color;

            if (PoolIndex >= ExpNumberOfNonPagedPools) {
                PoolIndex = ExpNumberOfNonPagedPools - 1;
            }

            PoolDesc = ExpNonPagedPoolDescriptor[PoolIndex];
        }

        ASSERT(PoolIndex == PoolDesc->PoolIndex);
    }

restart1:

    RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
    RetryCount = 0;

restart2:

    ListHead = &PoolDesc->ListHeads[ListNumber];

    //
    // Walk the listheads looking for a free block.
    //

    do {

        //
        // If the list is not empty, then allocate a block from the
        // selected list.
        //

        if (PrivateIsListEmpty (ListHead) == FALSE) {

            LOCK_POOL (PoolDesc, LockHandle);

            if (PrivateIsListEmpty (ListHead)) {

                //
                // The block is no longer available, march on.
                //

                UNLOCK_POOL (PoolDesc, LockHandle);
                ListHead += 1;
                continue;
            }

            CHECK_LIST (ListHead);
            Block = PrivateRemoveHeadList (ListHead);
            CHECK_LIST (ListHead);
            Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

            CHECK_POOL_PAGE (Entry);

            ASSERT(Entry->BlockSize >= NeededSize);

            ASSERT(DECODE_POOL_INDEX(Entry) == PoolIndex);

            ASSERT(Entry->PoolType == 0);

            if (Entry->BlockSize != NeededSize) {

                //
                // The selected block is larger than the allocation
                // request. Split the block and insert the remaining
                // fragment in the appropriate list.
                //
                // If the entry is at the start of a page, then take
                // the allocation from the front of the block so as
                // to minimize fragmentation. Otherwise, take the
                // allocation from the end of the block which may
                // also reduce fragmentation if the block is at the
                // end of a page.
                //

                if (Entry->PreviousSize == 0) {

                    //
                    // The entry is at the start of a page.
                    //

                    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    SplitEntry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    SplitEntry->PreviousSize = (USHORT) NeededSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = SplitEntry->BlockSize;
                    }

                }
                else {

                    //
                    // The entry is not at the start of a page.
                    //

                    SplitEntry = Entry;
                    Entry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                    Entry->PreviousSize = SplitEntry->BlockSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) NeededSize;
                    }
                }

                //
                // Set the size of the allocated entry, clear the pool
                // type of the split entry, set the index of the split
                // entry, and insert the split entry in the appropriate
                // free list.
                //

                Entry->BlockSize = (USHORT) NeededSize;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                SplitEntry->PoolType = 0;
                ENCODE_POOL_INDEX(SplitEntry, PoolIndex);
                Index = SplitEntry->BlockSize;

                CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

                //
                // Only insert split pool blocks which contain more than just
                // a header as only those have room for a flink/blink !
                // Note if the minimum pool block size is bigger than the
                // header then there can be no blocks like this.
                //

                if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                    (SplitEntry->BlockSize != 1)) {

                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

                    CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                }
            }

            Entry->PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);

            CHECK_POOL_PAGE (Entry);

            UNLOCK_POOL(PoolDesc, LockHandle);

            InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

            InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                                         Entry->BlockSize << POOL_BLOCK_SHIFT);

            Entry->PoolTag = Tag;

            ExpInsertPoolTrackerInline (Tag,
                                        Entry->BlockSize << POOL_BLOCK_SHIFT,
                                        PoolType);

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONGLONG)((PCHAR)Entry + CacheOverhead))[0] = 0;

            PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);
            return (PCHAR)Entry + CacheOverhead;
        }

        ListHead += 1;

    } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

    //
    // A block of the desired size does not exist and there are
    // no large blocks that can be split to satisfy the allocation.
    // Attempt to expand the pool by allocating another page and
    // adding it to the pool.
    //

    Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType, PAGE_SIZE);

    if (Entry == NULL) {

        //
        // If there are deferred free blocks, free them now and retry.
        //

        RetryCount += 1;

        if ((RetryCount == 1) && (ExpPoolFlags & EX_DELAY_POOL_FREES)) {
            ExDeferredFreePool (PoolDesc);
            goto restart2;
        }

        if ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) != 0) {

            //
            // Must succeed pool was requested so bugcheck.
            //

            KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                          PAGE_SIZE,
                          NonPagedPoolDescriptor.TotalPages,
                          NonPagedPoolDescriptor.TotalBigPages,
                          0);
        }

        //
        // No more pool of the specified type is available.
        //

        ExPoolFailures += 1;

        if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
            KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                NumberOfBytes,
                PoolType));
            if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                DbgBreakPoint ();
            }
        }

        if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        PERFINFO_POOLALLOC_ADDR (NULL);
        return NULL;
    }

    //
    // Initialize the pool header for the new allocation.
    //

    Entry->Ulong1 = 0;
    Entry->PoolIndex = (UCHAR) PoolIndex;
    Entry->BlockSize = (USHORT) NeededSize;

    Entry->PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);


    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);

    SplitEntry->Ulong1 = 0;

    Index = (PAGE_SIZE / sizeof(POOL_BLOCK)) - NeededSize;

    SplitEntry->BlockSize = (USHORT) Index;
    SplitEntry->PreviousSize = (USHORT) NeededSize;
    SplitEntry->PoolIndex = (UCHAR) PoolIndex;

    //
    // Split the allocated page and insert the remaining
    // fragment in the appropriate listhead.
    //
    // Set the size of the allocated entry, clear the pool
    // type of the split entry, set the index of the split
    // entry, and insert the split entry in the appropriate
    // free list.
    //

    //
    // Note that if the request was for nonpaged session pool, we are
    // not updating the session pool descriptor for this.  Instead we
    // are deliberately updating the global nonpaged pool descriptor
    // because the rest of the fragment goes into global nonpaged pool.
    // This is ok because the session pool descriptor TotalPages count
    // is not relied upon.
    //
    // The individual pool tracking by tag, however, is critical and
    // is properly maintained below (ie: session allocations are charged
    // to the session tracking table and regular nonpaged allocations are
    // charged to the global nonpaged tracking table).
    //

    InterlockedIncrement ((PLONG)&PoolDesc->TotalPages);

    NeededSize <<= POOL_BLOCK_SHIFT;

    InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, NeededSize);

    PERFINFO_ADDPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

    //
    // Only insert split pool blocks which contain more than just
    // a header as only those have room for a flink/blink !
    // Note if the minimum pool block size is bigger than the
    // header then there can be no blocks like this.
    //

    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
        (SplitEntry->BlockSize != 1)) {

        //
        // Now lock the pool and insert the fragment.
        //

        LOCK_POOL (PoolDesc, LockHandle);

        CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

        PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

        CHECK_POOL_PAGE (Entry);

        UNLOCK_POOL (PoolDesc, LockHandle);
    }
    else {
        CHECK_POOL_PAGE (Entry);
    }

    InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

    Block = (PVOID) ((PCHAR)Entry + CacheOverhead);

    Entry->PoolTag = Tag;

    ExpInsertPoolTrackerInline (Tag, NeededSize, PoolType);

    PERFINFO_POOLALLOC_ADDR (Block);

    return Block;
}


__bcount(NumberOfBytes) 
PVOID
ExAllocatePool (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    return ExAllocatePoolWithTag (PoolType,
                                  NumberOfBytes,
                                  'enoN');
}


__bcount(NumberOfBytes) 
PVOID
ExAllocatePoolWithTagPriority (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag,
    __in EX_POOL_PRIORITY Priority
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

    Priority - Supplies an indication as to how important it is that this
               request succeed under low available pool conditions.  This
               can also be used to specify special pool.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    ULONG i;
    ULONG Ratio;
    PVOID Entry;
    SIZE_T TotalBytes;
    SIZE_T TotalFullPages;
    POOL_TYPE CheckType;
    PPOOL_DESCRIPTOR PoolDesc;

    if ((Priority & POOL_SPECIAL_POOL_BIT) && (NumberOfBytes <= POOL_BUDDY_MAX)) {
        Entry = MmAllocateSpecialPool (NumberOfBytes,
                                       Tag,
                                       PoolType,
                                       (Priority & POOL_SPECIAL_POOL_UNDERRUN_BIT) ? 1 : 0);

        if (Entry != NULL) {
            return Entry;
        }
        Priority &= ~(POOL_SPECIAL_POOL_BIT | POOL_SPECIAL_POOL_UNDERRUN_BIT);
    }

    //
    // Pool and other resources can be allocated directly through the Mm
    // without the pool code knowing - so always call the Mm for the
    // up-to-date counters.
    //

    if ((Priority != HighPoolPriority) &&
        ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0)) {

        if (MmResourcesAvailable (PoolType, NumberOfBytes, Priority) == FALSE) {

            //
            // The Mm does not have very many full pages left.  Leave those
            // for true high priority callers.  But first see if this request
            // is small, and if so, if there is a lot of fragmentation, then
            // it is likely the request can be satisfied from pre-existing
            // fragments.
            //

            if (NumberOfBytes > POOL_BUDDY_MAX) {
                return NULL;
            }

            //
            // Sum the pool descriptors.
            //

            CheckType = PoolType & BASE_POOL_TYPE_MASK;

            if ((CheckType == NonPagedPool) ||
                ((PoolType & SESSION_POOL_MASK) == 0)) {

                PoolDesc = PoolVector[CheckType];

                TotalBytes = 0;
                TotalFullPages = 0;

                if (CheckType == PagedPool) {

                    if (KeNumberNodes > 1) {
                        for (i = 0; i <= ExpNumberOfPagedPools; i += 1) {
                            PoolDesc = ExpPagedPoolDescriptor[i];
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                        }
                    }
                    else {
                        for (i = 0; i <= ExpNumberOfPagedPools; i += 1) {
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                            PoolDesc += 1;
                        }
                    }
                }
                else {
                    if (ExpNumberOfNonPagedPools == 1) {
                        TotalFullPages += PoolDesc->TotalPages;
                        TotalFullPages += PoolDesc->TotalBigPages;
                        TotalBytes += PoolDesc->TotalBytes;
                    }
                    else {
                        for (i = 0; i < ExpNumberOfNonPagedPools; i += 1) {
                            PoolDesc = ExpNonPagedPoolDescriptor[i];
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                        }
                    }
                }
            }
            else {
                PoolDesc = ExpSessionPoolDescriptor;
                TotalFullPages = PoolDesc->TotalPages;
                TotalFullPages += PoolDesc->TotalBigPages;
                TotalBytes = PoolDesc->TotalBytes;
            }

            //
            // If the pages are more than 80% populated then don't assume
            // we're going to be able to satisfy ths request via a fragment.
            //

            TotalFullPages |= 1;        // Ensure we never divide by zero.
            TotalBytes >>= PAGE_SHIFT;

            //
            // The additions above were performed lock free so we must handle
            // slicing which can cause nonexact sums.
            //

            if (TotalBytes > TotalFullPages) {
                TotalBytes = TotalFullPages;
            }

            Ratio = (ULONG)((TotalBytes * 100) / TotalFullPages);

            if (Ratio >= 80) {
                return NULL;
            }
        }
    }

    //
    // There is a window between determining whether to proceed and actually
    // doing the allocation.  In this window the pool may deplete.  This is not
    // worth closing at this time.
    //

    return ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);
}


__bcount(NumberOfBytes) 
PVOID
ExAllocatePoolWithQuota (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    return ExAllocatePoolWithQuotaTag (PoolType, NumberOfBytes, 'enoN');
}

FORCEINLINE
PEPROCESS
ExpGetBilledProcess (
    IN PPOOL_HEADER Entry
    )
{
    PEPROCESS ProcessBilled;

    if ((Entry->PoolType & POOL_QUOTA_MASK) == 0) {
        return NULL;
    }

#if defined(_WIN64)
    ProcessBilled = Entry->ProcessBilled;
#else
    ProcessBilled =  * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID));
#endif

    if (ProcessBilled != NULL) {
        if (((PKPROCESS)(ProcessBilled))->Header.Type != ProcessObject) {
            KeBugCheckEx (BAD_POOL_CALLER,
                          0xD,
                          (ULONG_PTR)(Entry + 1),
                          Entry->PoolTag,
                          (ULONG_PTR)ProcessBilled);
        }
    }

    return ProcessBilled;
}

__bcount(NumberOfBytes) 
PVOID
ExAllocatePoolWithQuotaTag (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    PVOID p;
    PEPROCESS Process;
    PPOOL_HEADER Entry;
    LOGICAL RaiseOnQuotaFailure;
    NTSTATUS Status;
#if DBG
    LONG ConcurrentQuotaPool;
#endif

    RaiseOnQuotaFailure = TRUE;

    if (PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) {
        RaiseOnQuotaFailure = FALSE;
        PoolType &= ~POOL_QUOTA_FAIL_INSTEAD_OF_RAISE;
    }

    PoolType = (POOL_TYPE)((UCHAR)PoolType + POOL_QUOTA_MASK);

    Process = PsGetCurrentProcess ();

#if !defined(_WIN64)

    //
    // Add in room for the quota pointer at the end of the caller's allocation.
    // Note for NT64, there is room in the pool header for both the tag and
    // the quota pointer so no extra space is needed at the end.
    //
    // Only add in the quota pointer if doing so won't cause us to spill the
    // allocation into a full page.
    //

    ASSERT (NumberOfBytes != 0);

    if (NumberOfBytes <= PAGE_SIZE - POOL_OVERHEAD - sizeof (PVOID)) {
        if (Process != PsInitialSystemProcess) {
            NumberOfBytes += sizeof (PVOID);
        }
        else {
            PoolType = (POOL_TYPE)((UCHAR)PoolType - POOL_QUOTA_MASK);
        }
    }
    else {

        //
        // Turn off the quota bit prior to allocating if we're not charging
        // as there's no room to put (or subsequently query for) a quota
        // pointer.
        //

        PoolType = (POOL_TYPE)((UCHAR)PoolType - POOL_QUOTA_MASK);
    }

#endif

    p = ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);

    //
    // Note - NULL is page aligned.
    //

    if (!PAGE_ALIGNED(p)) {

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmIsSpecialPoolAddress (p))) {
            return p;
        }

        Entry = (PPOOL_HEADER)((PCH)p - POOL_OVERHEAD);

#if defined(_WIN64)
        Entry->ProcessBilled = NULL;
#else
        if ((PoolType & POOL_QUOTA_MASK) == 0) {
            return p;
        }
#endif

        if (Process != PsInitialSystemProcess) {

            Status = PsChargeProcessPoolQuota (Process,
                                 PoolType & BASE_POOL_TYPE_MASK,
                                 (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));


            if (!NT_SUCCESS(Status)) {

                //
                // Back out the allocation.
                //

#if !defined(_WIN64)
                //
                // The quota flag cannot be blindly cleared in NT32 because
                // it's used to denote the allocation is larger (and the
                // verifier finds its own header based on this).
                //
                // Instead of clearing the flag above, instead zero the quota
                // pointer.
                //

                * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = NULL;
#endif

                ExFreePoolWithTag (p, Tag);

                if (RaiseOnQuotaFailure) {
                    ExRaiseStatus (Status);
                }
                return NULL;
            }

#if DBG
            ConcurrentQuotaPool = InterlockedIncrement (&ExConcurrentQuotaPool);
            if (ConcurrentQuotaPool > ExConcurrentQuotaPoolMax) {
                ExConcurrentQuotaPoolMax = ConcurrentQuotaPool;
            }
#endif

#if defined(_WIN64)
            Entry->ProcessBilled = Process;
#else

            * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = Process;

#endif

            ObReferenceObject (Process);
        }
    }
    else {
        if ((p == NULL) && (RaiseOnQuotaFailure)) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return p;
}

VOID
ExInsertPoolTag (
    ULONG Tag,
    PVOID Va,
    SIZE_T NumberOfBytes,
    POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

    This function also inserts the pool tag in the big page tag table.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Tag - Supplies the tag used to insert an entry in the tag table.

    Va - Supplies the allocated virtual address.

    NumberOfBytes - Supplies the allocation size in bytes.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG NumberOfPages;

#if !DBG
    UNREFERENCED_PARAMETER (PoolType);
#endif

    ASSERT ((PoolType & SESSION_POOL_MASK) == 0);

    if (NumberOfBytes >= PAGE_SIZE) {

        NumberOfPages = (ULONG) BYTES_TO_PAGES (NumberOfBytes);

        if (ExpAddTagForBigPages((PVOID)Va, Tag, NumberOfPages, PoolType) == FALSE) {
            Tag = ' GIB';
        }
    }

    ExpInsertPoolTracker (Tag, NumberOfBytes, NonPagedPool);
}

VOID
ExpSeedHotTags (
    VOID
    )

/*++

Routine Description:

    This function seeds well-known hot tags into the pool tag tracking table
    when the table is first created.  The goal is to increase the likelihood
    that the hash generated for these tags always gets a direct hit.

Arguments:

    None.

Return Value:

    None.

Environment:

    INIT time, no locks held.

--*/

{
    ULONG i;
    ULONG Key;
    ULONG Hash;
    ULONG Index;
    PPOOL_TRACKER_TABLE TrackTable;

    ULONG KeyList[] = {
            '  oI',
            ' laH',
            'PldM',
            'LooP',
            'tSbO',
            ' prI',
            'bdDN',
            'LprI',
            'pOoI',
            ' ldM',
            'eliF',
            'aVMC',
            'dSeS',
            'CFtN',
            'looP',
            'rPCT',
            'bNMC',
            'dTeS',
            'sFtN',
            'TPCT',
            'CPCT',
            ' yeK',
            'qSbO',
            'mNoI',
            'aEoI',
            'cPCT',
            'aFtN',
            '0ftN',
            'tceS',
            'SprI',
            'ekoT',
            '  eS',
            'lCbO',
            'cScC',
            'lFtN',
            'cAeS',
            'mfSF',
            'kWcC',
            'miSF',
            'CdfA',
            'EdfA',
            'orSF',
            'nftN',
            'PRIU',

            'rFpN',
            'RFpN',
            'aPeS',
            'sUeS',
            'FpcA',
            'MpcA',
            'cSeS',
            'mNbO',
            'sFpN',
            'uLeS',
            'DPcS',
            'nevE',
            'vrqR',
            'ldaV',
            '  pP',
            'SdaV',
            ' daV',
            'LdaV',
            'FdaV',

            //
            // BIG is preseeded not because it is hot, but because allocations
            // with this tag must be inserted successfully (ie: cannot be
            // retagged into the Ovfl bucket) because we need a tag to account
            // for them in the PoolTrackTable counting when freeing the pool.
            //

            ' GIB',
    };

    TrackTable = PoolTrackTable;

    for (i = 0; i < sizeof (KeyList) / sizeof (ULONG); i += 1) {

        Key = KeyList[i];

        Hash = POOLTAG_HASH(Key,PoolTrackTableMask);

        Index = Hash;

        do {

            ASSERT (TrackTable[Hash].Key != Key);

            if ((TrackTable[Hash].Key == 0) &&
                (Hash != PoolTrackTableSize - 1)) {

                TrackTable[Hash].Key = Key;
                break;
            }

            ASSERT (TrackTable[Hash].Key != Key);

            Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;

            if (Hash == Index) {
                break;
            }

        } while (TRUE);
    }
}


VOID
ExpInsertPoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the expansion tag table (taking a
    spinlock to do so), increments the number of allocates and updates
    the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

    This routine is only called if ExpInsertPoolTracker encounters a full
    builtin list.

--*/

{
    ULONG Hash;
    KIRQL OldIrql;
    ULONG BigPages;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

    //
    // The protected pool bit has already been stripped.
    //

    ASSERT ((Key & PROTECTED_POOL) == 0);

    if (PoolType & SESSION_POOL_MASK) {

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        NewTable = ExpSessionPoolTrackTable + ExpSessionPoolTrackTableSize - 1;

        ASSERT ((NewTable->Key == 0) || (NewTable->Key == 'lfvO'));

        NewTable->Key = 'lfvO';

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &NewTable->PagedAllocs);
            InterlockedExchangeAddSizeT (&NewTable->PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &NewTable->NonPagedAllocs);
            InterlockedExchangeAddSizeT (&NewTable->NonPagedBytes,
                                         NumberOfBytes);
        }
        return;
    }

    //
    // Linear search through the expansion table.  This is ok because
    // the case of no free entries in the built-in table is extremely rare.
    //

    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

    for (Hash = 0; Hash < PoolTrackTableExpansionSize; Hash += 1) {

        if (PoolTrackTableExpansion[Hash].Key == Key) {
            break;
        }

        if (PoolTrackTableExpansion[Hash].Key == 0) {
            ASSERT (PoolTrackTable[PoolTrackTableSize - 1].Key == 0);
            PoolTrackTableExpansion[Hash].Key = Key;
            break;
        }
    }

    if (Hash != PoolTrackTableExpansionSize) {

        //
        // The entry was found (or created).  Update the other fields now.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            PoolTrackTableExpansion[Hash].PagedAllocs += 1;
            PoolTrackTableExpansion[Hash].PagedBytes += NumberOfBytes;
        }
        else {
            PoolTrackTableExpansion[Hash].NonPagedAllocs += 1;
            PoolTrackTableExpansion[Hash].NonPagedBytes += NumberOfBytes;
        }

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
        return;
    }

    //
    // The entry was not found and the expansion table is full (or nonexistent).
    // Try to allocate a larger expansion table now.
    //

    if (PoolTrackTable[PoolTrackTableSize - 1].Key != 0) {

        //
        // The overflow bucket has been used so expansion of the tracker table
        // is not allowed because a subsequent free of a tag can go negative
        // as the original allocation is in overflow and a newer allocation
        // may be distinct.
        //

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        Hash = (ULONG)PoolTrackTableSize - 1;

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].PagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].NonPagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].NonPagedBytes,
                                         NumberOfBytes);

        }

        return;
    }

    SizeInBytes = PoolTrackTableExpansionSize * sizeof(POOL_TRACKER_TABLE);

    //
    // Use as much of the slush in the final page as possible.
    //

    NewSizeInBytes = (PoolTrackTableExpansionPages + 1) << PAGE_SHIFT;
    NewSize = NewSizeInBytes / sizeof (POOL_TRACKER_TABLE);
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    NewTable = MiAllocatePoolPages (NonPagedPool, NewSizeInBytes);

    if (NewTable != NULL) {

        if (PoolTrackTableExpansion != NULL) {

            //
            // Copy all the existing entries into the new table.
            //

            RtlCopyMemory (NewTable,
                           PoolTrackTableExpansion,
                           SizeInBytes);
        }

        RtlZeroMemory ((PVOID)(NewTable + PoolTrackTableExpansionSize),
                       NewSizeInBytes - SizeInBytes);

        OldTable = PoolTrackTableExpansion;

        PoolTrackTableExpansion = NewTable;
        PoolTrackTableExpansionSize = NewSize;
        PoolTrackTableExpansionPages += 1;

        //
        // Recursively call ourself to insert the new table entry.  This entry
        // must be inserted before releasing the tagged spinlock because
        // another thread may be further growing the table and as soon as we
        // release the spinlock, that thread may grow and try to free our
        // new table !
        //

        ExpInsertPoolTracker ('looP',
                              PoolTrackTableExpansionPages << PAGE_SHIFT,
                              NonPagedPool);

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        //
        // Free the old table if there was one.
        //

        if (OldTable != NULL) {

            BigPages = MiFreePoolPages (OldTable);

            ExpRemovePoolTracker ('looP',
                                  (SIZE_T) BigPages * PAGE_SIZE,
                                  NonPagedPool);
        }

        //
        // Finally insert the caller's original allocation.
        //

        ExpInsertPoolTrackerExpansion (Key, NumberOfBytes, PoolType);
    }
    else {

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        Hash = (ULONG)PoolTrackTableSize - 1;

        ASSERT (PoolTrackTable[Hash].Key == 0);

        PoolTrackTable[Hash].Key = 'lfvO';

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].PagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].NonPagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].NonPagedBytes,
                                         NumberOfBytes);
        }
    }

    return;
}
VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )
{
    ExpInsertPoolTrackerInline (Key, NumberOfBytes, PoolType);
}


VOID
ExpRemovePoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size in the expansion table.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

--*/

{
    ULONG Hash;
    KIRQL OldIrql;
    PPOOL_TRACKER_TABLE TrackTable;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // The protected pool bit has already been stripped.
    //

    ASSERT ((Key & PROTECTED_POOL) == 0);

    if (PoolType & SESSION_POOL_MASK) {

        //
        // This entry must have been charged to the overflow bucket.
        // Update the pool tracker table entry for it.
        //

        Hash = (ULONG)ExpSessionPoolTrackTableSize - 1;
        TrackTable = ExpSessionPoolTrackTable;
        goto OverflowEntry;
    }

    //
    // Linear search through the expansion table.  This is ok because
    // the existence of an expansion table at all is extremely rare.
    //

    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

    for (Hash = 0; Hash < PoolTrackTableExpansionSize; Hash += 1) {

        if (PoolTrackTableExpansion[Hash].Key == Key) {

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                ASSERT (PoolTrackTableExpansion[Hash].PagedAllocs != 0);
                ASSERT (PoolTrackTableExpansion[Hash].PagedAllocs >=
                        PoolTrackTableExpansion[Hash].PagedFrees);
                ASSERT (PoolTrackTableExpansion[Hash].PagedBytes >= NumberOfBytes);
                PoolTrackTableExpansion[Hash].PagedFrees += 1;
                PoolTrackTableExpansion[Hash].PagedBytes -= NumberOfBytes;
            }
            else {
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedAllocs != 0);
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedAllocs >=
                        PoolTrackTableExpansion[Hash].NonPagedFrees);
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedBytes >= NumberOfBytes);
                PoolTrackTableExpansion[Hash].NonPagedFrees += 1;
                PoolTrackTableExpansion[Hash].NonPagedBytes -= NumberOfBytes;
            }

            ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
            return;
        }
        if (PoolTrackTableExpansion[Hash].Key == 0) {
            break;
        }
    }

    ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

    //
    // This entry must have been charged to the overflow bucket.
    // Update the pool tracker table entry for it.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

#if !defined (NT_UP)

    //
    // Use the current processor to pick a pool tag table to use.  Note that
    // in rare cases, this thread may context switch to another processor but
    // the algorithms below will still be correct.
    //

    Processor = KeGetCurrentProcessorNumber ();

    ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

    TrackTable = ExPoolTagTables[Processor];

#else

    TrackTable = PoolTrackTable;

#endif

OverflowEntry:

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
#if defined (NT_UP)
        ASSERT (TrackTable[Hash].PagedAllocs != 0);
        ASSERT (TrackTable[Hash].PagedBytes >= NumberOfBytes);
#endif
        InterlockedIncrement ((PLONG) &TrackTable[Hash].PagedFrees);
        InterlockedExchangeAddSizeT (&TrackTable[Hash].PagedBytes,
                                     0 - NumberOfBytes);
    }
    else {
#if defined (NT_UP)
        ASSERT (TrackTable[Hash].NonPagedAllocs != 0);
        ASSERT (TrackTable[Hash].NonPagedBytes >= NumberOfBytes);
#endif
        InterlockedIncrement ((PLONG) &TrackTable[Hash].NonPagedFrees);
        InterlockedExchangeAddSizeT (&TrackTable[Hash].NonPagedBytes,
                                     0 - NumberOfBytes);
    }
    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )
{
    ExpRemovePoolTrackerInline (Key, NumberOfBytes, PoolType);
}


LOGICAL
ExpExpandBigPageTable (
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function expands the big page tracking table and rehashes all the
    old entries into the new table at the same time.

Arguments:

    OldIrql - Supplies the IRQL the pool track table spinlock was acquired at.

Return Value:

    TRUE if the table was expanded, FALSE if not.

Environment:

    Pool track table executive spinlock held exclusive at DISPATCH_LEVEL.

    The spinlock is released here (and IRQL lowered) prior to returning !!!

--*/
{
    ULONG Hash;
    ULONG NewHash;
    ULONG BigPages;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    SIZE_T TableSize;
    PPOOL_TRACKER_BIG_PAGES Table;
    PPOOL_TRACKER_BIG_PAGES TableEnd;
    PPOOL_TRACKER_BIG_PAGES NewTable;

    //
    // Try to expand the tracker table.
    //

    TableSize = PoolBigPageTableSize;

    SizeInBytes = TableSize * sizeof(POOL_TRACKER_BIG_PAGES);

    NewSizeInBytes = (SizeInBytes << 1);

    if (NewSizeInBytes <= SizeInBytes) {
        ExReleaseSpinLockExclusive (&ExpLargePoolTableLock, OldIrql);
        return FALSE;
    }

    NewTable = MiAllocatePoolPages (NonPagedPool, NewSizeInBytes);

    if (NewTable == NULL) {
        ExReleaseSpinLockExclusive (&ExpLargePoolTableLock, OldIrql);
        return FALSE;
    }

    //
    // Initialize the new table, marking all the new entries as free.
    // Note this loop uses the fact that the table size always doubles.
    //

    RtlZeroMemory (NewTable, NewSizeInBytes);

    Table = NewTable;
    TableEnd = NewTable + (TableSize << 1);

    do {
        Table->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
        Table += 1;
    } while (Table != TableEnd);

    //
    // Rehash the valid tables in the old table
    // into their new locations in the new table.
    //

    Table = PoolBigPageTable;
    TableEnd = Table + TableSize;

    NewHash = (ULONG) ((TableSize << 1) - 1);

    do {

        if (((ULONG_PTR)Table->Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {

            Hash = (ULONG)(((ULONG_PTR)Table->Va) >> PAGE_SHIFT);
            Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ Hash);

            Hash &= NewHash;

            while (((ULONG_PTR)NewTable[Hash].Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {
                Hash += 1;
                if (Hash > NewHash) {
                    Hash = 0;
                }
            }

            * (&NewTable[Hash]) = *Table;
        }

        Table += 1;

    } while (Table != TableEnd);

    Table = PoolBigPageTable;
    PoolBigPageTable = NewTable;
    PoolBigPageTableSize = (TableSize << 1);
    PoolBigPageTableHash = NewHash;

    ExReleaseSpinLockExclusive (&ExpLargePoolTableLock, OldIrql);

    //
    // The table growth has completed, release the spinlock.
    //

    BigPages = MiFreePoolPages (Table);

    ExpRemovePoolTracker ('looP',
                          (SIZE_T) BigPages * PAGE_SIZE,
                          NonPagedPool);

    ExpInsertPoolTracker ('looP',
                          ROUND_TO_PAGES (NewSizeInBytes),
                          NonPagedPool);

    return TRUE;
}


LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

    PoolType - Supplies the type of the pool.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG Hash;
    ULONG IterationCount;
    PVOID OldVa;
    KIRQL OldIrql;
    SIZE_T TableSize;
    PPOOL_TRACKER_BIG_PAGES Entry;
    PPOOL_TRACKER_BIG_PAGES EntryEnd;
    PPOOL_TRACKER_BIG_PAGES EntryStart;

    //
    // The low bit of the address is set to indicate a free entry.  The high
    // bit cannot be used because in some configurations the high bit is not
    // set for all kernelmode addresses.
    //

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    if (PoolType & SESSION_POOL_MASK) {
        Hash = (ULONG)(((ULONG_PTR)Va) >> PAGE_SHIFT);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ Hash);
        Hash &= ExpSessionPoolBigPageTableHash;

        TableSize = ExpSessionPoolBigPageTableSize;

        Entry = &ExpSessionPoolBigPageTable[Hash];
        EntryStart = Entry;
        EntryEnd = &ExpSessionPoolBigPageTable[TableSize];

        do {

            OldVa = Entry->Va;

            if (((ULONG_PTR)OldVa & POOL_BIG_TABLE_ENTRY_FREE) &&
                (InterlockedCompareExchangePointer (&Entry->Va,
                                                    Va,
                                                    OldVa) == OldVa)) {

                Entry->Key = Key;
                Entry->NumberOfPages = NumberOfPages;

                return TRUE;
            }

            Entry += 1;
            if (Entry >= EntryEnd) {
                Entry = &ExpSessionPoolBigPageTable[0];
            }
        } while (Entry != EntryStart);

#if DBG
        ExpLargeSessionPoolUnTracked += 1;
#endif
        return FALSE;
    }

    IterationCount = 0;

    do {

        Hash = (ULONG)(((ULONG_PTR)Va) >> PAGE_SHIFT);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ Hash);

        OldIrql = ExAcquireSpinLockShared (&ExpLargePoolTableLock);
    
        Hash &= PoolBigPageTableHash;

        TableSize = PoolBigPageTableSize;
    
        Entry = &PoolBigPageTable[Hash];
        EntryStart = Entry;
        EntryEnd = &PoolBigPageTable[TableSize];
    
        do {
    
            OldVa = Entry->Va;
    
            if (((ULONG_PTR)OldVa & POOL_BIG_TABLE_ENTRY_FREE) &&
                (InterlockedCompareExchangePointer (&Entry->Va,
                                                    Va,
                                                    OldVa) == OldVa)) {
    
                Entry->Key = Key;
                Entry->NumberOfPages = NumberOfPages;

                InterlockedIncrement (&ExpPoolBigEntriesInUse);

                if ((IterationCount >= 16) &&
                    ((ULONG) ExpPoolBigEntriesInUse > (ULONG) (TableSize / 4))) {

                    if (ExTryAcquireSpinLockExclusive (&ExpLargePoolTableLock) == TRUE) {
                        ASSERT (TableSize == PoolBigPageTableSize);
                
                        //
                        // The expansion function always releases the lock.
                        //

                        ExpExpandBigPageTable (OldIrql);
                    }
                    else {
                        ExReleaseSpinLockShared (&ExpLargePoolTableLock, OldIrql);
                    }
                }
                else {
                    ExReleaseSpinLockShared (&ExpLargePoolTableLock, OldIrql);
                }

                return TRUE;
            }
    
            IterationCount += 1;
            Entry += 1;
            if (Entry >= EntryEnd) {
                Entry = &PoolBigPageTable[0];
            }
        } while (Entry != EntryStart);
    
        //
        // Try to expand the tracker table.
        //
        // Since this involves copying the existing entries over and deleting
        // the old table, first acquire the lock exclusive.
        //
    
        if (ExTryAcquireSpinLockExclusive (&ExpLargePoolTableLock) == FALSE) {
            ExReleaseSpinLockShared (&ExpLargePoolTableLock, OldIrql);
            continue;
        }
    
        //
        // No thread could have grown this during the contention above, so
        // ASSERT that this is the case.
        //
    
        ASSERT (TableSize == PoolBigPageTableSize);
    
        //
        // The expansion function always releases the lock.
        //

        if (ExpExpandBigPageTable (OldIrql) == FALSE) {
            ExpBigTableExpansionFailed += 1;
            return FALSE;
        }

    } while (TRUE);
}


ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    OUT PULONG BigPages,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function removes a pool tag from the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    BigPages - Returns the number of pages that were allocated.

    PoolType - Supplies the type of the pool.

Return Value:

    TRUE if an entry was found and removed, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/

{   ULONG Hash;
    LOGICAL Inserted;
    SIZE_T TableSize;
    KIRQL OldIrql;
    ULONG ReturnKey;
    PPOOL_TRACKER_BIG_PAGES Entry;

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    if (PoolType & SESSION_POOL_MASK) {
        Hash = (ULONG)(((ULONG_PTR)Va) >> PAGE_SHIFT);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ Hash);
        Hash &= ExpSessionPoolBigPageTableHash;

        ReturnKey = Hash;

        do {
            if (ExpSessionPoolBigPageTable[Hash].Va == Va) {

                *BigPages = ExpSessionPoolBigPageTable[Hash].NumberOfPages;
                ReturnKey = ExpSessionPoolBigPageTable[Hash].Key;

                InterlockedOr ((PLONG) &ExpSessionPoolBigPageTable[Hash].Va,
                               POOL_BIG_TABLE_ENTRY_FREE);

                return ReturnKey;
            }

            Hash += 1;
            if (Hash >= ExpSessionPoolBigPageTableSize) {
                Hash = 0;
            }
        } while (Hash != ReturnKey);

        *BigPages = 0;
        return ' GIB';
    }

    Inserted = TRUE;

    Hash = (ULONG)(((ULONG_PTR)Va) >> PAGE_SHIFT);
    Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ Hash);

    OldIrql = ExAcquireSpinLockShared (&ExpLargePoolTableLock);

    Hash &= PoolBigPageTableHash;

    TableSize = PoolBigPageTableSize;

    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= TableSize) {

            if (!Inserted) {

                ExReleaseSpinLockShared (&ExpLargePoolTableLock, OldIrql);

                *BigPages = 0;
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    Entry = &PoolBigPageTable[Hash];

    *BigPages = Entry->NumberOfPages;
    ReturnKey = Entry->Key;

    InterlockedDecrement (&ExpPoolBigEntriesInUse);

#if defined(_WIN64)
    InterlockedIncrement64 ((PLONGLONG) &Entry->Va);
#else
    InterlockedIncrement ((PLONG) &Entry->Va);
#endif

    ExReleaseSpinLockShared (&ExpLargePoolTableLock, OldIrql);

    return ReturnKey;
}


VOID
ExFreePoolWithTag (
    __in PVOID P,
    __in ULONG TagToFree
    )

/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

    TagToFree - Supplies the tag of the block being freed.

Return Value:

    None.

--*/

{
    PVOID OldValue;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG BlockSize;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_HEADER NextEntry;
    POOL_TYPE PoolType;
    POOL_TYPE EntryPoolType;
    PPOOL_DESCRIPTOR PoolDesc;
    PEPROCESS ProcessBilled;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG BigPages2;
    SIZE_T NumberOfBytes;
    ULONG Tag;
    PKPRCB Prcb;
    PGENERAL_LOOKASIDE LookasideList;

    PERFINFO_FREEPOOL(P);

    UNREFERENCED_PARAMETER (TagToFree);

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                        EX_KERNEL_VERIFIER_ENABLED |
                        EX_VERIFIER_DEADLOCK_DETECTION_ENABLED |
                        EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) {

            //
            // Log all pool frees in this mode.
            //

            ULONG Hash;
            ULONG Index;
            LOGICAL SpecialPool;
            PEX_FREE_POOL_TRACES Information;

            SpecialPool = MmIsSpecialPoolAddress (P);

            if (ExFreePoolTraces != NULL) {

                Index = InterlockedIncrement (&ExFreePoolIndex);
                Index &= ExFreePoolMask;
                Information = &ExFreePoolTraces[Index];

                Information->Thread = PsGetCurrentThread ();
                Information->PoolAddress = P;
                if (SpecialPool == TRUE) {
                    Information->PoolHeader = *(PPOOL_HEADER) PAGE_ALIGN (P);
                }
                else if (!PAGE_ALIGNED(P)) {
                    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);
                    Information->PoolHeader = *Entry;
                }
                else {
                    RtlZeroMemory (&Information->PoolHeader,
                                   sizeof (POOL_HEADER));
                    Information->PoolHeader.Ulong1 = MmGetSizeOfBigPoolAllocation (P);
                }

                RtlZeroMemory (&Information->StackTrace[0],
                               EX_FREE_POOL_BACKTRACE_LENGTH * sizeof(PVOID)); 

                RtlCaptureStackBackTrace (1,
                                          EX_FREE_POOL_BACKTRACE_LENGTH,
                                          Information->StackTrace,
                                          &Hash);
            }

            if (SpecialPool == TRUE) {

                if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                    VerifierDeadlockFreePool (P, PAGE_SIZE);
                }

                MmFreeSpecialPool (P);

                return;
            }
        }

        if (!PAGE_ALIGNED(P)) {

            Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

            ASSERT_POOL_NOT_FREE(Entry);

            PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

            CheckType = PoolType & BASE_POOL_TYPE_MASK;

            ASSERT_FREE_IRQL(PoolType, P);

            ASSERT_POOL_TYPE_NOT_ZERO(Entry);

            if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              7,
                              __LINE__,
                              (ULONG_PTR)Entry->Ulong1,
                              (ULONG_PTR)P);
            }

            //
            // Make sure the next pool header is consistent with respect to
            // the one being freed to ensure we at least catch pool corruptors
            // at the time of the free.
            //
            // It would be nice to also check the previous pool header as
            // if this is not consistent, it's likely the previous
            // allocation's owner is the corruptor and it's also likely he
            // has not yet freed the block either.  However, this cannot
            // be done safely with mutex or lock synchronization
            // and this would be too high a performance penalty to pay.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);

            if ((PAGE_END(NextEntry) == FALSE) &&
                (Entry->BlockSize != NextEntry->PreviousSize)) {

                KeBugCheckEx (BAD_POOL_HEADER,
                              0x20,
                              (ULONG_PTR) Entry,
                              (ULONG_PTR) NextEntry,
                              Entry->Ulong1);
            }

            NumberOfBytes = (SIZE_T)Entry->BlockSize << POOL_BLOCK_SHIFT;

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes - POOL_OVERHEAD);
            }

            if (Entry->PoolType & POOL_VERIFIER_MASK) {
                VerifierFreeTrackedPool (P,
                                         NumberOfBytes,
                                         CheckType,
                                         FALSE);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (Entry, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (Entry, NumberOfBytes);

            //
            // Look for work items still queued.
            //

            FREE_CHECK_WORKER (Entry, NumberOfBytes);
        }
    }

    //
    // If the entry is page aligned, then free the block to the page aligned
    // pool.  Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        PoolType = MmDeterminePoolType (P);

        ASSERT_FREE_IRQL(PoolType, P);

        CheckType = PoolType & BASE_POOL_TYPE_MASK;

        if (PoolType == PagedPoolSession) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else {

            PoolDesc = PoolVector[PoolType];

            if (CheckType == NonPagedPool) {
                if (MiIsPoolLargeSession (P) == TRUE) {
                    PoolDesc = ExpSessionPoolDescriptor;
                    PoolType = NonPagedPoolSession;
                }
            }
        }

        Tag = ExpFindAndRemoveTagBigPages (P, &BigPages, PoolType);

        if (BigPages == 0) {

            //
            // This means the allocator wasn't able to insert this
            // entry into the big page tag table.  This allocation must
            // have been re-tagged as BIG at the time, our problem here
            // is that we don't know the size (or the real original tag).
            //
            // Ask Mm directly for the size.
            //

            BigPages = MmGetSizeOfBigPoolAllocation (P);

            ASSERT (BigPages != 0);

            ASSERT (Tag == ' GIB');
        }
        else if (Tag & PROTECTED_POOL) {

            Tag &= ~PROTECTED_POOL;
        }

        NumberOfBytes = (SIZE_T)BigPages << PAGE_SHIFT;

        ExpRemovePoolTracker (Tag, NumberOfBytes, PoolType);

        if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                            EX_VERIFIER_DEADLOCK_DETECTION_ENABLED)) {

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (P, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (P, NumberOfBytes);

            //
            // Search worker queues for work items still queued.
            //

            FREE_CHECK_WORKER (P, NumberOfBytes);
        }

        InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

        InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, 0 - NumberOfBytes);

        BigPages2 = MiFreePoolPages (P);

        ASSERT (BigPages == BigPages2);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalBigPages, (LONG)(0 - BigPages2));

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    BlockSize = Entry->BlockSize;

    EntryPoolType = Entry->PoolType;

    PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    ASSERT_POOL_NOT_FREE (Entry);

    ASSERT_FREE_IRQL (PoolType, P);

    ASSERT_POOL_TYPE_NOT_ZERO (Entry);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER,
                      7,
                      __LINE__,
                      (ULONG_PTR)Entry->Ulong1,
                      (ULONG_PTR)P);
    }

    Tag = Entry->PoolTag;
    if (Tag & PROTECTED_POOL) {
        Tag &= ~PROTECTED_POOL;
    }

    //
    // Make sure the next pool header is consistent with respect to the
    // one being freed to ensure we at least catch pool corruptors at the
    // time of the free.
    //
    // It would be nice to also check the previous pool header as if this
    // is not consistent, it's likely the previous allocation's owner is the
    // corruptor and it's also likely he has not yet freed the block either.
    // However, this cannot be done safely with mutex or lock synchronization
    // and this would be too high a performance penalty to pay.
    //

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);

    if ((PAGE_END(NextEntry) == FALSE) &&
        (BlockSize != NextEntry->PreviousSize)) {

        KeBugCheckEx (BAD_POOL_HEADER,
                      0x20,
                      (ULONG_PTR) Entry,
                      (ULONG_PTR) NextEntry,
                      Entry->Ulong1);
    }

    PoolDesc = PoolVector[CheckType];

    MARK_POOL_HEADER_FREED (Entry);

    if (EntryPoolType & SESSION_POOL_MASK) {

        if (CheckType == PagedPool) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else if (ExpNumberOfNonPagedPools > 1) {
            PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }

        //
        // All session space allocations have an index of 0 unless there
        // are multiple nonpaged (session) pools.
        //

        ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));
    }
    else {

        if (CheckType == PagedPool) {
            ASSERT (DECODE_POOL_INDEX(Entry) <= ExpNumberOfPagedPools);
            PoolDesc = ExpPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }
        else {
            ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));
            if (ExpNumberOfNonPagedPools > 1) {
                PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
            }
        }
    }

    //
    // Update the pool tracking database.
    //

    ExpRemovePoolTrackerInline (Tag,
                                BlockSize << POOL_BLOCK_SHIFT,
                                EntryPoolType - 1);

    //
    // If quota was charged when the pool was allocated, release it now.
    //

    if (EntryPoolType & POOL_QUOTA_MASK) {
        ProcessBilled = ExpGetBilledProcess (Entry);
        if (ProcessBilled != NULL) {
            PsReturnPoolQuota (ProcessBilled,
                               PoolType & BASE_POOL_TYPE_MASK,
                               BlockSize << POOL_BLOCK_SHIFT);

            ObDereferenceObject (ProcessBilled);
#if DBG
            InterlockedDecrement (&ExConcurrentQuotaPool);
#endif
        }
    }

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    if (((EntryPoolType & SESSION_POOL_MASK) == 0) ||
        (CheckType == NonPagedPool)) {

        if ((BlockSize <= POOL_SMALL_LISTS) && (USING_HOT_COLD_METRICS == 0)) {

            //
            // Try to free the small block to a per processor lookaside list.
            //

            Prcb = KeGetCurrentPrcb ();

            if (CheckType == PagedPool) {

                //
                // Prototype pool is never put on general lookaside lists
                // due to the sharecounts applied on these allocations when
                // they are in use (ie: the rest of this page is comprised of
                // prototype allocations even though this allocation is being
                // freed).  Pages containing prototype allocations are much
                // more difficult for memory management to trim (unlike the
                // rest of paged pool) due to the sharecounts generally applied.
                //

                if (PoolDesc->PoolIndex == 0) {
                    goto NoLookaside;
                }

                //
                // Only free the small block to the current processor's
                // lookaside list if the block is local to this node.
                //

                if (KeNumberNodes > 1) {
                    if (Prcb->ParentNode->Color != PoolDesc->PoolIndex - 1) {
                        goto NoLookaside;
                    }
                }

                LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].P;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }

                LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].L;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }

            }
            else {

                //
                // Only free the small block to the current processor's
                // lookaside list if the block is local to this node.
                //

                if (KeNumberNodes > 1) {
                    if (Prcb->ParentNode->Color != PoolDesc->PoolIndex) {
                        goto NoLookaside;
                    }
                }

                LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].P;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;

                }

                LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].L;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }
            }
        }
    }
    else {

        if (BlockSize <= ExpSessionPoolSmallLists) {

            //
            // Attempt to free the small block to the session lookaside list.
            //

            LookasideList = (PGENERAL_LOOKASIDE)(ULONG_PTR)(ExpSessionPoolLookaside + BlockSize - 1);

            LookasideList->TotalFrees += 1;

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSLIST_ENTRY)P);

                return;
            }
        }
    }

NoLookaside:

    //
    // If the pool block release can be queued so the pool mutex/spinlock
    // acquisition/release can be amortized then do so.  Note "hot" blocks
    // are generally in the lookasides above to provide fast reuse to take
    // advantage of hardware caching.
    //

    if (ExpPoolFlags & EX_DELAY_POOL_FREES) {

        if (PoolDesc->PendingFreeDepth >= EXP_MAXIMUM_POOL_FREES_PENDING) {
            ExDeferredFreePool (PoolDesc);
        }

        //
        // Push this entry on the deferred list.
        //

        do {

            OldValue = ReadForWriteAccess (&PoolDesc->PendingFrees);
            ((PSINGLE_LIST_ENTRY)P)->Next = OldValue;

        } while (InterlockedCompareExchangePointer (
                        &PoolDesc->PendingFrees,
                        P,
                        OldValue) != OldValue);

        InterlockedIncrement (&PoolDesc->PendingFreeDepth);

        return;
    }

    Combined = FALSE;

    ASSERT (BlockSize == Entry->BlockSize);

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);

    InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

    InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, 0 - ((SIZE_T)BlockSize << POOL_BLOCK_SHIFT));

    LOCK_POOL (PoolDesc, LockHandle);

    CHECK_POOL_PAGE (Entry);

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        UNLOCK_POOL (PoolDesc, LockHandle);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalPages, (LONG)-1);

        PERFINFO_FREEPOOLPAGE(CheckType, Entry->PoolIndex, Entry, PoolDesc);

        MiFreePoolPages (Entry);
    }
    else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        BlockSize = Entry->BlockSize;

        ASSERT (BlockSize != 1);

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = (USHORT) BlockSize;
            }
        }

        //
        // Always insert at the head in hopes of reusing cache lines.
        //

        PrivateInsertHeadList (&PoolDesc->ListHeads[BlockSize - 1],
                               ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        UNLOCK_POOL(PoolDesc, LockHandle);
    }
}

VOID
ExFreePool (
    __in PVOID P
    )
{
    ExFreePoolWithTag (P, 0);
    return;
}


VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     )

/*++

Routine Description:

    This routine frees a number of pool allocations at once to amortize the
    synchronization overhead cost.

Arguments:

    PoolDesc - Supplies the relevant pool descriptor.

Return Value:

    None.

Environment:

    Kernel mode.  May be as high as APC_LEVEL for paged pool or DISPATCH_LEVEL
    for nonpaged pool.

--*/

{
    LONG ListCount;
    KLOCK_QUEUE_HANDLE LockHandle;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG Index;
    ULONG WholePageCount;
    PPOOL_HEADER NextEntry;
    ULONG PoolIndex;
    LOGICAL Combined;
    PSINGLE_LIST_ENTRY SingleListEntry;
    PSINGLE_LIST_ENTRY NextSingleListEntry;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY LastEntry;
    PSINGLE_LIST_ENTRY WholePages;

    CheckType = PoolDesc->PoolType & BASE_POOL_TYPE_MASK;

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    ListCount = 0;
    WholePages = NULL;
    WholePageCount = 0;
    LastEntry = NULL;

    LOCK_POOL (PoolDesc, LockHandle);

    if (PoolDesc->PendingFrees == NULL) {
        UNLOCK_POOL (PoolDesc, LockHandle);
        return;
    }

    //
    // Free each deferred pool entry until they're all done.
    //

    do {

        SingleListEntry = PoolDesc->PendingFrees;

        FirstEntry = SingleListEntry;

        do {

            NextSingleListEntry = SingleListEntry->Next;

            //
            // Process the deferred entry.
            //

            ListCount += 1;

            Entry = (PPOOL_HEADER)((PCHAR)SingleListEntry - POOL_OVERHEAD);

            PoolIndex = DECODE_POOL_INDEX(Entry);

            //
            // Process the block.
            //

            Combined = FALSE;

            CHECK_POOL_PAGE (Entry);

            InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

            InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                            0 - ((SIZE_T)Entry->BlockSize << POOL_BLOCK_SHIFT));

            //
            // Free the specified pool block.
            //
            // Check to see if the next entry is free.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {

                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
                }
            }

            //
            // Check to see if the previous entry is free.
            //

            if (Entry->PreviousSize != 0) {
                NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
                    Entry = NextEntry;
                }
            }

            //
            // If the block being freed has been combined into a full page,
            // then return the free page to memory management.
            //

            if (PAGE_ALIGNED(Entry) &&
                (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

                ((PSINGLE_LIST_ENTRY)Entry)->Next = WholePages;
                WholePages = (PSINGLE_LIST_ENTRY) Entry;
                WholePageCount += 1;
            }
            else {

                //
                // Insert this element into the list.
                //

                Entry->PoolType = 0;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                Index = Entry->BlockSize;

                ASSERT (Index != 1);

                //
                // If the freed block was combined with any other block, then
                // adjust the size of the next block if necessary.
                //

                if (Combined != FALSE) {

                    //
                    // The size of this entry has changed, if this entry is
                    // not the last one in the page, update the pool block
                    // after this block to have a new previous allocation size.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Index);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) Index;
                    }
                }

                //
                // Always insert at the head in hopes of reusing cache lines.
                //

                PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            }

            //
            // March on to the next entry if there is one.
            //

            if (NextSingleListEntry == LastEntry) {
                break;
            }

            SingleListEntry = NextSingleListEntry;

        } while (TRUE);

        if (InterlockedCompareExchangePointer (&PoolDesc->PendingFrees,
                                               NULL,
                                               FirstEntry) == FirstEntry) {
            break;
        }
        LastEntry = FirstEntry;

    } while (TRUE);

    UNLOCK_POOL (PoolDesc, LockHandle);

    if (WholePages != NULL) {

        //
        // If the pool type is paged pool, then the global paged pool mutex
        // must be held during the free of the pool pages.  Hence any
        // full pages were batched up and are now dealt with in one go.
        //

        Entry = (PPOOL_HEADER) WholePages;

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalPages, 0 - WholePageCount);
        do {

            NextEntry = (PPOOL_HEADER) (((PSINGLE_LIST_ENTRY)Entry)->Next);

            PERFINFO_FREEPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

            MiFreePoolPages (Entry);

            Entry = NextEntry;

        } while (Entry != NULL);
    }

    InterlockedExchangeAdd (&PoolDesc->PendingFreeDepth, (0 - ListCount));

    return;
}

SIZE_T
ExQueryPoolBlockSize (
    __in PVOID PoolBlock,
    __out PBOOLEAN QuotaCharged
    )

/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

    QuotaCharged - Supplies a BOOLEAN variable to receive whether or not the
        pool block had quota charged.

    NOTE: If the entry is bigger than a page, the value PAGE_SIZE is returned
          rather than the correct number of bytes.

Return Value:

    Size of pool block.

--*/

{
    PPOOL_HEADER Entry;
    SIZE_T size;

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (PoolBlock))) {
        *QuotaCharged = FALSE;
        return MmQuerySpecialPoolBlockSize (PoolBlock);
    }

    if (PAGE_ALIGNED(PoolBlock)) {
        *QuotaCharged = FALSE;
        return PAGE_SIZE;
    }

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    if (ExpGetBilledProcess (Entry)) {
        *QuotaCharged = TRUE;
    }
    else {
        *QuotaCharged = FALSE;
    }

    return size;
}

VOID
ExQueryPoolUsage (
    __out PULONG PagedPoolPages,
    __out PULONG NonPagedPoolPages,
    __out PULONG PagedPoolAllocs,
    __out PULONG PagedPoolFrees,
    __out PULONG PagedPoolLookasideHits,
    __out PULONG NonPagedPoolAllocs,
    __out PULONG NonPagedPoolFrees,
    __out PULONG NonPagedPoolLookasideHits
    )

{
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    PLIST_ENTRY NextEntry;
    PPOOL_DESCRIPTOR pd;

    //
    // Sum all the paged pool usage.
    //

    *PagedPoolPages = 0;
    *PagedPoolAllocs = 0;
    *PagedPoolFrees = 0;

    for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
        pd = ExpPagedPoolDescriptor[Index];
        *PagedPoolPages += pd->TotalPages + pd->TotalBigPages;
        *PagedPoolAllocs += pd->RunningAllocs;
        *PagedPoolFrees += pd->RunningDeAllocs;
    }

    //
    // Sum all the nonpaged pool usage.
    //

    pd = &NonPagedPoolDescriptor;
    *NonPagedPoolPages = pd->TotalPages + pd->TotalBigPages;
    *NonPagedPoolAllocs = pd->RunningAllocs;
    *NonPagedPoolFrees = pd->RunningDeAllocs;

    if (ExpNumberOfNonPagedPools > 1) {
        for (Index = 0; Index < ExpNumberOfNonPagedPools; Index += 1) {
            pd = ExpNonPagedPoolDescriptor[Index];
            *NonPagedPoolPages += pd->TotalPages + pd->TotalBigPages;
            *NonPagedPoolAllocs += pd->RunningAllocs;
            *NonPagedPoolFrees += pd->RunningDeAllocs;
        }
    }

    //
    // Sum all the lookaside hits for paged and nonpaged pool.
    //

    NextEntry = ExPoolLookasideListHead.Flink;
    while (NextEntry != &ExPoolLookasideListHead) {
        Lookaside = CONTAINING_RECORD(NextEntry,
                                      GENERAL_LOOKASIDE,
                                      ListEntry);

        if (Lookaside->Type == NonPagedPool) {
            *NonPagedPoolLookasideHits += Lookaside->AllocateHits;

        }
        else {
            *PagedPoolLookasideHits += Lookaside->AllocateHits;
        }

        NextEntry = NextEntry->Flink;
    }

    return;
}


VOID
ExReturnPoolQuota (
    IN PVOID P
    )

/*++

Routine Description:

    This function returns quota charged to a subject process when the
    specified pool block was allocated.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/

{

    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PEPROCESS ProcessBilled;

    //
    // Do nothing for special pool. No quota was charged.
    //

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {
        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    //
    // If quota was charged, then return the appropriate quota to the
    // subject process.
    //

    if (Entry->PoolType & POOL_QUOTA_MASK) {

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        ProcessBilled = ExpGetBilledProcess (Entry);

        if (ProcessBilled == NULL) {
            return;
        }

#if defined (_WIN64)

        //
        // This flag cannot be cleared in NT32 because it's used to denote the
        // allocation is larger (and the verifier finds its own header
        // based on this).
        //

        Entry->PoolType &= ~POOL_QUOTA_MASK;

#else

        //
        // Instead of clearing the flag above, zero the quota pointer.
        //

        * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = NULL;

#endif

        PsReturnPoolQuota (ProcessBilled,
                           PoolType & BASE_POOL_TYPE_MASK,
                           (ULONG)Entry->BlockSize << POOL_BLOCK_SHIFT);

        ObDereferenceObject (ProcessBilled);
#if DBG
        InterlockedDecrement (&ExConcurrentQuotaPool);
#endif
    }

    return;
}

#if !defined (NT_UP)

PVOID
ExCreatePoolTagTable (
    IN ULONG NewProcessorNumber,
    IN UCHAR NodeNumber
    )
{
    SIZE_T NumberOfBytes;
    PPOOL_TRACKER_TABLE NewTagTable;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    ASSERT (NewProcessorNumber < MAXIMUM_PROCESSOR_TAG_TABLES);
    ASSERT (ExPoolTagTables[NewProcessorNumber] == NULL);

    NumberOfBytes = (PoolTrackTableSize + 1) * sizeof(POOL_TRACKER_TABLE);

    NewTagTable = MmAllocateIndependentPages (NumberOfBytes, NodeNumber);

    if (NewTagTable != NULL) {

        //
        // Just zero the table here, the tags are lazy filled as various pool
        // allocations and frees occur.  Note no memory barrier is needed
        // because only this processor will read it except when an
        // ExGetPoolTagInfo call occurs, and in that case, explicit memory
        // barriers are used as needed.
        //

        RtlZeroMemory (NewTagTable,
                       PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        ExPoolTagTables[NewProcessorNumber] = NewTagTable;
    }

    return (PVOID) NewTagTable;
}

VOID
ExDeletePoolTagTable (
    IN ULONG NewProcessorNumber
    )

/*++

Routine Description:

    This function deletes the tag table for the specified processor
    number because the processor did not boot.

Arguments:

    NewProcessorNumber - Supplies the processor number that did not boot.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    ASSERT (NewProcessorNumber < MAXIMUM_PROCESSOR_TAG_TABLES);
    ASSERT (ExPoolTagTables[NewProcessorNumber] != NULL);

    NumberOfBytes = (PoolTrackTableSize + 1) * sizeof(POOL_TRACKER_TABLE);

    VirtualAddress = ExPoolTagTables[NewProcessorNumber];

    //
    // Raise to DISPATCH to prevent a race when attempting to hot-add a
    // processor while a pool-usage query is active.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

    ExPoolTagTables[NewProcessorNumber] = NULL;

    KeLowerIrql (OldIrql);

    MmFreeIndependentPages (VirtualAddress, NumberOfBytes);

    return;
}
#endif

typedef struct _POOL_DPC_CONTEXT {

    PPOOL_TRACKER_TABLE PoolTrackTable;
    SIZE_T PoolTrackTableSize;

    PPOOL_TRACKER_TABLE PoolTrackTableExpansion;
    SIZE_T PoolTrackTableSizeExpansion;

} POOL_DPC_CONTEXT, *PPOOL_DPC_CONTEXT;

VOID
ExpGetPoolTagInfoTarget (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

    Called by all processors during a pool tag table query.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Deferred context.

    SystemArgument1 - Used to signal completion of this call.

    SystemArgument2 - Used for internal lockstepping during this call.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL since this is called from a DPC.

--*/
{
    PPOOL_DPC_CONTEXT Context;
#if !defined (NT_UP)
    ULONG i;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;
    PPOOL_TRACKER_TABLE TargetTrackerEntry;
#endif

    UNREFERENCED_PARAMETER (Dpc);

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    Context = DeferredContext;

    //
    // Make sure all DPCs are running (ie: spinning at DISPATCH_LEVEL)
    // to prevent any pool allocations or frees from happening until
    // all the counters are snapped.  Otherwise the counters could
    // be misleading (ie: more frees than allocs, etc).
    //

    if (KeSignalCallDpcSynchronize (SystemArgument2)) {

        //
        // This processor (could be the caller or a target) is the final
        // processor to enter the DPC spinloop.  Snap the data now.
        //

#if defined (NT_UP)

        RtlCopyMemory ((PVOID)Context->PoolTrackTable,
                       (PVOID)PoolTrackTable,
                       Context->PoolTrackTableSize * sizeof (POOL_TRACKER_TABLE));

#else

        RtlCopyMemory ((PVOID)Context->PoolTrackTable,
                       (PVOID)ExPoolTagTables[0],
                       Context->PoolTrackTableSize * sizeof (POOL_TRACKER_TABLE));

        LastTrackerEntry = Context->PoolTrackTable + Context->PoolTrackTableSize;

        for (i = 1; i < MAXIMUM_PROCESSOR_TAG_TABLES; i += 1) {

            TargetTrackerEntry = ExPoolTagTables[i];

            if (TargetTrackerEntry == NULL) {
                continue;
            }

            TrackerEntry = Context->PoolTrackTable;

            while (TrackerEntry != LastTrackerEntry) {

                if (TargetTrackerEntry->Key != 0) {

                    ASSERT (TargetTrackerEntry->Key == TrackerEntry->Key);

                    TrackerEntry->NonPagedAllocs += TargetTrackerEntry->NonPagedAllocs;
                    TrackerEntry->NonPagedFrees += TargetTrackerEntry->NonPagedFrees;
                    TrackerEntry->NonPagedBytes += TargetTrackerEntry->NonPagedBytes;
                    TrackerEntry->PagedAllocs += TargetTrackerEntry->PagedAllocs;
                    TrackerEntry->PagedFrees += TargetTrackerEntry->PagedFrees;
                    TrackerEntry->PagedBytes += TargetTrackerEntry->PagedBytes;
                }
                TrackerEntry += 1;
                TargetTrackerEntry += 1;
            }
        }

#endif

        if (Context->PoolTrackTableSizeExpansion != 0) {
            RtlCopyMemory ((PVOID)(Context->PoolTrackTableExpansion),
                           (PVOID)PoolTrackTableExpansion,
                           Context->PoolTrackTableSizeExpansion * sizeof (POOL_TRACKER_TABLE));
        }
    }

    //
    // Wait until everyone has got to this point before continuing.
    //

    KeSignalCallDpcSynchronize (SystemArgument2);

    //
    // Signal that all processing has been done.
    //

    KeSignalCallDpcDone (SystemArgument1);

    return;
}

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function copies the system pool tag information to the supplied
    USER space buffer.  Note that the caller has already probed the USER
    address and wrapped this routine inside a try-except.

Arguments:

    SystemInformation - Supplies a user space buffer to copy the data to.

    SystemInformationLength - Supplies the length of the user buffer.

    ReturnLength - Receives the actual length of the data returned.

Return Value:

    Various NTSTATUS codes.

--*/

{
    SIZE_T NumberOfBytes;
    SIZE_T NumberOfExpansionTableBytes;
    ULONG totalBytes;
    NTSTATUS status;
    PSYSTEM_POOLTAG_INFORMATION taginfo;
    PSYSTEM_POOLTAG poolTag;
    PPOOL_TRACKER_TABLE PoolTrackInfo;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;
    POOL_DPC_CONTEXT Context;
    SIZE_T LocalTrackTableSize;
    SIZE_T LocalTrackTableSizeExpansion;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    totalBytes = 0;
    status = STATUS_SUCCESS;

    taginfo = (PSYSTEM_POOLTAG_INFORMATION)SystemInformation;
    poolTag = &taginfo->TagInfo[0];
    totalBytes = FIELD_OFFSET(SYSTEM_POOLTAG_INFORMATION, TagInfo);
    taginfo->Count = 0;

    LocalTrackTableSize = PoolTrackTableSize;
    LocalTrackTableSizeExpansion = PoolTrackTableExpansionSize;

    NumberOfBytes = LocalTrackTableSize * sizeof(POOL_TRACKER_TABLE);
    NumberOfExpansionTableBytes = LocalTrackTableSizeExpansion * sizeof (POOL_TRACKER_TABLE);

    PoolTrackInfo = (PPOOL_TRACKER_TABLE) ExAllocatePoolWithTag (
                                    NonPagedPool,
                                    NumberOfBytes + NumberOfExpansionTableBytes,
                                    'ofnI');

    if (PoolTrackInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Context.PoolTrackTable = PoolTrackInfo;
    Context.PoolTrackTableSize = PoolTrackTableSize;

    Context.PoolTrackTableExpansion = (PoolTrackInfo + PoolTrackTableSize);
    Context.PoolTrackTableSizeExpansion = PoolTrackTableExpansionSize;

    KeGenericCallDpc (ExpGetPoolTagInfoTarget, &Context);

    TrackerEntry = PoolTrackInfo;
    LastTrackerEntry = PoolTrackInfo + (LocalTrackTableSize + LocalTrackTableSizeExpansion);

    //
    // Wrap the user space accesses with an exception handler so we can free the
    // pool track info allocation if the user address was bogus.
    //

    try {
        while (TrackerEntry < LastTrackerEntry) {
            if (TrackerEntry->Key != 0) {
                taginfo->Count += 1;
                totalBytes += sizeof (SYSTEM_POOLTAG);
                if (SystemInformationLength < totalBytes) {
                    status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    ASSERT (TrackerEntry->PagedAllocs >= TrackerEntry->PagedFrees);
                    ASSERT (TrackerEntry->NonPagedAllocs >= TrackerEntry->NonPagedFrees);

                    poolTag->TagUlong = TrackerEntry->Key;
                    poolTag->PagedAllocs = TrackerEntry->PagedAllocs;
                    poolTag->PagedFrees = TrackerEntry->PagedFrees;
                    poolTag->PagedUsed = TrackerEntry->PagedBytes;
                    poolTag->NonPagedAllocs = TrackerEntry->NonPagedAllocs;
                    poolTag->NonPagedFrees = TrackerEntry->NonPagedFrees;
                    poolTag->NonPagedUsed = TrackerEntry->NonPagedBytes;
                    poolTag += 1;
                }
            }
            TrackerEntry += 1;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
    }

    ExFreePool (PoolTrackInfo);

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = totalBytes;
    }

    return status;
}

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    )

/*++

Routine Description:

    This function copies the current session's pool tag information to the
    supplied system-mapped buffer.

Arguments:

    SystemInformation - Supplies a system mapped buffer to copy the data to.

    SystemInformationLength - Supplies the length of the buffer.

    ReturnedEntries - Receives the actual number of entries returned.

    ActualEntries - Receives the total number of entries.
                    This can be more than ReturnedEntries if the caller's
                    buffer is not large enough to hold all the data.

Return Value:

    Various NTSTATUS codes.

--*/

{
    ULONG totalBytes;
    ULONG ActualCount;
    ULONG ReturnedCount;
    NTSTATUS status;
    PSYSTEM_POOLTAG poolTag;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    totalBytes = 0;
    ActualCount = 0;
    ReturnedCount = 0;
    status = STATUS_SUCCESS;

    poolTag = (PSYSTEM_POOLTAG) SystemInformation;

    //
    // Capture the current session's pool information.
    //

    TrackerEntry = ExpSessionPoolTrackTable;
    LastTrackerEntry = TrackerEntry + ExpSessionPoolTrackTableSize;

    while (TrackerEntry < LastTrackerEntry) {
        if (TrackerEntry->Key != 0) {
            ActualCount += 1;
            totalBytes += sizeof (SYSTEM_POOLTAG);

            if (totalBytes > SystemInformationLength) {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                ReturnedCount += 1;

                poolTag->TagUlong = TrackerEntry->Key;
                poolTag->PagedAllocs = TrackerEntry->PagedAllocs;
                poolTag->PagedFrees = TrackerEntry->PagedFrees;
                poolTag->PagedUsed = TrackerEntry->PagedBytes;
                poolTag->NonPagedAllocs = TrackerEntry->NonPagedAllocs;
                poolTag->NonPagedFrees = TrackerEntry->NonPagedFrees;
                poolTag->NonPagedUsed = TrackerEntry->NonPagedBytes;

                //
                // Session pool tag entries are updated with interlocked
                // sequences so it is possible here that we can read one
                // that is in the middle of being updated.  Sanitize the
                // data here so callers don't have to.
                //

                ASSERT ((SSIZE_T)poolTag->PagedUsed >= 0);
                ASSERT ((SSIZE_T)poolTag->NonPagedUsed >= 0);

                if (poolTag->PagedAllocs < poolTag->PagedFrees) {
                    poolTag->PagedAllocs = poolTag->PagedFrees;
                }

                if (poolTag->NonPagedAllocs < poolTag->NonPagedFrees) {
                    poolTag->NonPagedAllocs = poolTag->NonPagedFrees;
                }

                poolTag += 1;
            }
        }
        TrackerEntry += 1;
    }

    *ReturnedEntries = ReturnedCount;
    *ActualEntries = ActualCount;

    return status;
}

NTSTATUS
ExGetBigPoolInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function copies the system big pool entry information to the supplied
    USER space buffer.  Note that the caller has already probed the USER
    address and wrapped this routine inside a try-except.

    PAGELK was not used for this function so that calling it causes minimal
    disruption to actual memory usage.

Arguments:

    SystemInformation - Supplies a user space buffer to copy the data to.

    SystemInformationLength - Supplies the length of the user buffer.

    ReturnLength - Supplies the actual length of the data returned.

Return Value:

    Various NTSTATUS codes.

--*/

{
    ULONG TotalBytes;
    KIRQL OldIrql;
    NTSTATUS Status;
    PVOID NewTable;
    PPOOL_TRACKER_BIG_PAGES SystemPoolEntry;
    PPOOL_TRACKER_BIG_PAGES SystemPoolEntryEnd;
    SIZE_T SnappedBigTableSize;
    SIZE_T SnappedBigTableSizeInBytes;

    PSYSTEM_BIGPOOL_ENTRY UserPoolEntry;
    PSYSTEM_BIGPOOL_INFORMATION UserPoolInfo;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    NewTable = NULL;
    Status = STATUS_SUCCESS;

    UserPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)SystemInformation;
    UserPoolEntry = &UserPoolInfo->AllocatedInfo[0];
    TotalBytes = FIELD_OFFSET(SYSTEM_BIGPOOL_INFORMATION, AllocatedInfo);
    UserPoolInfo->Count = 0;

    do {

        SnappedBigTableSize = PoolBigPageTableSize;
        SnappedBigTableSizeInBytes =
                    SnappedBigTableSize * sizeof (POOL_TRACKER_BIG_PAGES);

        if (NewTable != NULL) {
            MiFreePoolPages (NewTable);
        }

        //
        // Use MiAllocatePoolPages for the temporary buffer so we won't have
        // to filter it out of the results before handing them back.
        //

        NewTable = MiAllocatePoolPages (NonPagedPool,
                                        SnappedBigTableSizeInBytes);

        if (NewTable == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        OldIrql = ExAcquireSpinLockExclusive (&ExpLargePoolTableLock);

        if (SnappedBigTableSize >= PoolBigPageTableSize) {

            //
            // Success - our table is big enough to hold everything.
            //

            break;
        }

        ExReleaseSpinLockExclusive (&ExpLargePoolTableLock, OldIrql);

    } while (TRUE);

    RtlCopyMemory (NewTable,
                   PoolBigPageTable,
                   PoolBigPageTableSize * sizeof (POOL_TRACKER_BIG_PAGES));

    SnappedBigTableSize = PoolBigPageTableSize;

    ExReleaseSpinLockExclusive (&ExpLargePoolTableLock, OldIrql);

    SystemPoolEntry = NewTable;
    SystemPoolEntryEnd = SystemPoolEntry + SnappedBigTableSize;

    //
    // Wrap the user space accesses with an exception handler so we can
    // free the temp buffer if the user address was bogus.
    //

    try {
        while (SystemPoolEntry < SystemPoolEntryEnd) {

            if (((ULONG_PTR)SystemPoolEntry->Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {

                //
                // This entry is in use so capture it.
                //

                UserPoolInfo->Count += 1;
                TotalBytes += sizeof (SYSTEM_BIGPOOL_ENTRY);

                if (SystemInformationLength < TotalBytes) {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    UserPoolEntry->VirtualAddress = SystemPoolEntry->Va;
                    
                    if (MmDeterminePoolType (SystemPoolEntry->Va) == NonPagedPool) {
                        UserPoolEntry->NonPaged = 1;
                    }

                    UserPoolEntry->TagUlong = SystemPoolEntry->Key & ~PROTECTED_POOL;
                    UserPoolEntry->SizeInBytes = SystemPoolEntry->NumberOfPages << PAGE_SHIFT;
                    UserPoolEntry += 1;
                }
            }
            SystemPoolEntry += 1;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
    }

    MiFreePoolPages (NewTable);

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = TotalBytes;
    }

    return Status;
}

VOID
ExAllocatePoolSanityChecks (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    if (NumberOfBytes == 0) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x0,
                      KeGetCurrentIrql(),
                      PoolType,
                      NumberOfBytes);
    }

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {

        if (KeGetCurrentIrql() > APC_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x1,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
    else {
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x2,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
}

VOID
ExFreePoolSanityChecks (
    IN PVOID P
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PVOID StillQueued;

    if (P <= (PVOID)(MM_HIGHEST_USER_ADDRESS)) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x10,
                      (ULONG_PTR)P,
                      0,
                      0);
    }

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {

        KeCheckForTimer (P, PAGE_SIZE - BYTE_OFFSET (P));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE - BYTE_OFFSET (P));
        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          (ULONG_PTR)-1,
                          (ULONG_PTR)P);
        }

        ExpCheckForWorker (P, PAGE_SIZE - BYTE_OFFSET (P)); // bugchecks inside
        return;
    }

    if (PAGE_ALIGNED(P)) {
        PoolType = MmDeterminePoolType(P);

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        //
        // Just check the first page.
        //

        KeCheckForTimer(P, PAGE_SIZE);

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE);

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
    else {

        if (((ULONG_PTR)P & (POOL_OVERHEAD - 1)) != 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x16,
                          __LINE__,
                          (ULONG_PTR)P,
                          0);
        }

        Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

        if ((Entry->PoolType & POOL_TYPE_MASK) == 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x13,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          Entry->Ulong1);
        }

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x14,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          0);
        }

        KeCheckForTimer(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
}

#if defined (NT_UP)
VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the system has booted into a shell.

    It's job is to disable various pool optimizations that are enabled to
    speed up booting and reduce the memory footprint on small machines.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL since this is called from a timer expiration.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Pretty much all pages are "hot" after bootup.  Since bootup has finished,
    // use lookaside lists and stop trying to separate regular allocations
    // as well.
    //

    RtlInterlockedAndBitsDiscardReturn (&ExpPoolFlags, (ULONG)~EX_SEPARATE_HOT_PAGES_DURING_BOOT);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\mutant.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mutant.c

Abstract:

   This module implements the executive mutant object. Functions are
   provided to create, open, release, and query mutant objects.

--*/

#include "exp.h"

//
// Address of mutant object type descriptor.
//

POBJECT_TYPE ExMutantObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for mutant objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpMutantMapping = {
    STANDARD_RIGHTS_READ | MUTANT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    MUTANT_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#pragma alloc_text(INIT, ExpMutantInitialization)
#pragma alloc_text(PAGE, NtCreateMutant)
#pragma alloc_text(PAGE, NtOpenMutant)
#pragma alloc_text(PAGE, NtQueryMutant)
#pragma alloc_text(PAGE, NtReleaseMutant)

VOID
ExpDeleteMutant (
    IN PVOID Mutant
    )

/*++

Routine Description:

    This function is called when an executive mutant object is about to
    be deleted. The mutant object is released with an abandoned status to
    ensure that it is removed from the owner thread's mutant list if the
    mutant object is currently owned by a thread.

Arguments:

    Mutant - Supplies a pointer to an executive mutant object.

Return Value:

    None.

--*/

{
    //
    // Release the mutant object with an abandoned status to ensure that it
    // is removed from the owner thread's mutant list if the mutant is
    // currently owned by a thread.
    //

    KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, TRUE, FALSE);
    return;
}

BOOLEAN
ExpMutantInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the mutant object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the mutant object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Mutant");

    //
    // Create mutant object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    RtlZeroMemory(&PsGetCurrentProcess()->Pcb.DirectoryTableBase[0], KdDumpEnableOffset);
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpMutantMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KMUTANT);
    ObjectTypeInitializer.ValidAccessMask = MUTANT_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteMutant;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExMutantObjectType);

    //
    // If the mutant object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateMutant (
    __out PHANDLE MutantHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function creates a mutant object, sets its initial count to one
    (signaled), and opens a handle to the object with the specified desired
    access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialOwner - Supplies a boolean value that determines whether the
        creator of the object desires immediate ownership of the object.

--*/

{

    HANDLE Handle;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Allocate mutant object.
        //

        Status = ObCreateObject(PreviousMode,
                                ExMutantObjectType,
                                ObjectAttributes,
                                PreviousMode,
                                NULL,
                                sizeof(KMUTANT),
                                0,
                                0,
                                &Mutant);

        //
        // If the mutant object was successfully allocated, then initialize
        // the mutant object and attempt to insert the mutant object in the
        // current process' handle table.
        //

        if (NT_SUCCESS(Status)) {
            KeInitializeMutant((PKMUTANT)Mutant, InitialOwner);
            Status = ObInsertObject(Mutant,
                                    NULL,
                                    DesiredAccess,
                                    0,
                                    NULL,
                                    &Handle);

            //
            // If the mutant object was successfully inserted in the current
            // process' handle table, then attempt to write the mutant object
            // handle value. If the write attempt fails, then do not report
            // an error. When the caller attempts to access the handle value,
            // an access violation will occur.
            //

            if (NT_SUCCESS(Status)) {
                try {
                    *MutantHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                }
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenMutant (
    __out PHANDLE MutantHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a mutant object with the specified
    desired access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;


    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Open handle to the mutant object with the specified desired access.
        //

        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExMutantObjectType,
                                    PreviousMode,
                                    NULL,
                                    DesiredAccess,
                                    NULL,
                                    &Handle);

        //
        // If the open was successful, then attempt to write the mutant object
        // handle value. If the write attempt fails, then do not report an
        // error. When the caller attempts to access the handle value, an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                *MutantHandle = Handle;

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryMutant (
    __in HANDLE MutantHandle,
    __in MUTANT_INFORMATION_CLASS MutantInformationClass,
    __out_bcount(MutantInformationLength) PVOID MutantInformation,
    __in ULONG MutantInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the state of a mutant object and returns the
    requested information in the specified record structure.

Arguments:

    MutantHandle - Supplies a handle to a mutant object.

    MutantInformationClass - Supplies the class of information being
        requested.

    MutantInformation - Supplies a pointer to a record that is to receive
        the requested information.

    MutantInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

--*/

{

    BOOLEAN Abandoned;
    BOOLEAN OwnedByCaller;
    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the mutant object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    try {

        //
        // Get previous processor mode and probe output arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure(MutantInformation,
                                        sizeof(MUTANT_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        //
        // Check argument validity.
        //

        if (MutantInformationClass != MutantBasicInformation) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (MutantInformationLength != sizeof(MUTANT_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Reference mutant object by handle.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           MUTANT_QUERY_STATE,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then read the current state and
        // abandoned status of the mutant object, dereference mutant object,
        // fill in the information structure, and return the length of the
        // information structure if specified. If the write of the mutant
        // information or the return length fails, then do not report an error.
        // When the caller accesses the information structure or length an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            Count = KeReadStateMutant((PKMUTANT)Mutant);
            Abandoned = ((PKMUTANT)Mutant)->Abandoned;
            OwnedByCaller = (BOOLEAN)((((PKMUTANT)Mutant)->OwnerThread ==
                                                         KeGetCurrentThread()));

            ObDereferenceObject(Mutant);
            try {
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->CurrentCount = Count;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->OwnedByCaller = OwnedByCaller;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->AbandonedState = Abandoned;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(MUTANT_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output arguments, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseMutant (
    __in HANDLE MutantHandle,
    __out_opt PLONG PreviousCount
    )

/*++

Routine Description:

    This function releases a mutant object.

Arguments:

    Mutant - Supplies a handle to a mutant object.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous mutant count.

--*/

{

    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous count address if
    // specified, reference the mutant object, and release the mutant object.
    // If the probe fails, then return the exception code as the service
    // status. Otherwise return the status value returned by the reference
    // object by handle routine.
    //

    try {

        //
        // Get previous processor mode and probe previous count address
        // if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if ((PreviousMode != KernelMode) && (ARGUMENT_PRESENT(PreviousCount))) {
            ProbeForWriteLong(PreviousCount);
        }

        //
        // Reference mutant object by handle.
        //
        // Note that the desired access is specified as zero since only the
        // owner can release a mutant object.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           0,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then release the mutant object. If
        // an exception occurs because the caller is not the owner of the mutant
        // object, then dereference mutant object and return the exception code
        // as the service status. Otherise write the previous count value if
        // specified. If the write of the previous count fails, then do not
        // report an error. When the caller attempts to access the previous
        // count value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                PERFINFO_DECLARE_OBJECT(Mutant);
                Count = KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, FALSE, FALSE);
                ObDereferenceObject(Mutant);
                if (ARGUMENT_PRESENT(PreviousCount)) {
                    try {
                        *PreviousCount = Count;

                    } except(ExSystemExceptionFilter()) {
                    }
                }

            //
            // If an exception occurs because the caller is not the owner of
            // the mutant object, then always handle the exception, dereference
            // the mutant object, and return the exception code as the status
            // value.
            //

            } except(ExSystemExceptionFilter()) {
                ObDereferenceObject(Mutant);
                return GetExceptionCode();
            }
        }

    //
    // If an exception occurs during the probe of the previous count, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\raise.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    raise.c

Abstract:

    This module implements routines to raise datatype misalignment and
    access violation for probe code.

    N.B. These routines are provided as function to save space in the
        probe macros.

    N.B. Since these routines are *only* called from the probe macros,
        it is assumed that the calling code is pageable.

--*/

#include "exp.h"

//
// Define function sections.
//

#pragma alloc_text(PAGE, ExRaiseAccessViolation)
#pragma alloc_text(PAGE, ExRaiseDatatypeMisalignment)

DECLSPEC_NOINLINE
VOID
ExRaiseAccessViolation (
    VOID
    )

/*++

Routine Description:

    This function raises an access violation exception.

    N.B. There is not return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_ACCESS_VIOLATION);
}

DECLSPEC_NOINLINE
VOID
ExRaiseDatatypeMisalignment (
    VOID
    )

/*++

Routine Description:

    This function raises a datatype misalignment exception.

    N.B. There is not return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\probe.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    probe.c

Abstract:

    This module implements the probe for write function.

--*/

#include "exp.h"

#if defined(_WIN64)

#include <wow64t.h>

#endif

#undef ProbeForRead

VOID
ProbeForRead (
    __in CONST VOID *Address,
    __in SIZE_T Length,
    __in ULONG Alignment
    );

#pragma alloc_text(PAGE, ProbeForWrite)
#pragma alloc_text(PAGE, ProbeForRead)

VOID
ProbeForWrite (
    __inout_bcount(Length) PVOID Address,
    __in SIZE_T Length,
    __in ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for write accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{

    ULONG_PTR EndAddress;
    ULONG_PTR StartAddress;

#define PageSize PAGE_SIZE

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8) ||
               (Alignment == 16));

        StartAddress = (ULONG_PTR)Address;
        if ((StartAddress & (Alignment - 1)) == 0) {

            //
            // Compute the ending address of the structure and probe for
            // write accessibility.
            //

            EndAddress = StartAddress + Length - 1;
            if ((StartAddress <= EndAddress) &&
                (EndAddress < MM_USER_PROBE_ADDRESS)) {

                //
                // N.B. Only the contents of the buffer may be probed.
                //      Therefore the starting byte is probed for the
                //      first page, and then the first byte in the page
                //      for each succeeding page.
                //
                // If this is a Wow64 process, then the native page is 4K, which
                // could be smaller than the native page size/
                //

                EndAddress = (EndAddress & ~(PageSize - 1)) + PageSize;
                do {
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                    StartAddress = (StartAddress & ~(PageSize - 1)) + PageSize;
                } while (StartAddress != EndAddress);

                return;

            } else {
                ExRaiseAccessViolation();
            }

        } else {
            ExRaiseDatatypeMisalignment();
        }
    }

    return;
}

VOID
ProbeForRead(
    __in_bcount(Length) VOID *Address,
    __in SIZE_T Length,
    __in ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{

    PAGED_CODE();

    ASSERT((Alignment == 1) || (Alignment == 2) ||
           (Alignment == 4) || (Alignment == 8) ||
           (Alignment == 16));

    if (Length != 0) {
        if (((ULONG_PTR)Address & (Alignment - 1)) != 0) {
            ExRaiseDatatypeMisalignment();

        } else if ((((ULONG_PTR)Address + Length) > (ULONG_PTR)MM_USER_PROBE_ADDRESS) ||
                   (((ULONG_PTR)Address + Length) < (ULONG_PTR)Address)) {

            *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\rundown.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    rundown.c

Abstract:

    This module houses routine that do safe rundown of data structures.

    The basic principle of these routines is to allow fast protection of a data structure that is torn down
    by a single thread. Threads wishing to access the data structure attempt to obtain rundown protection via
    calling ExAcquireRundownProtection. If this function returns TRUE then accesses are safe until the protected
    thread calls ExReleaseRundownProtection. The single teardown thread calls ExWaitForRundownProtectionRelease
    to mark the rundown structure as being run down and the call will return once all protected threads have
    released their protection references.

    Rundown protection is not a lock. Multiple threads may gain rundown protection at the same time.

    The rundown structure has the following format:

    Bottom bit set   : This is a pointer to a rundown wait block (aligned on at least a word boundary)
    Bottom bit clear : This is a count of the total number of accessors multiplied by 2 granted rundown protection.

Revision History:

    Add per-processor cache-aware rundown protection APIs

--*/

#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
//  These routines are now marked as NONPAGED because they are being used
//  in the paging path by file system filters.
//#pragma alloc_text(PAGE, ExfAcquireRundownProtection)
//#pragma alloc_text(PAGE, ExfReleaseRundownProtection)
//#pragma alloc_text(PAGE, ExAcquireRundownProtectionEx)
//#pragma alloc_text(PAGE, ExReleaseRundownProtectionEx)

#pragma alloc_text(PAGE, ExfWaitForRundownProtectionRelease)
#pragma alloc_text(PAGE, ExfReInitializeRundownProtection)
#pragma alloc_text(PAGE, ExfInitializeRundownProtection)
#pragma alloc_text(PAGE, ExfRundownCompleted)
#pragma alloc_text(PAGE, ExAllocateCacheAwareRundownProtection)
#pragma alloc_text(PAGE, ExSizeOfRundownProtectionCacheAware)
#pragma alloc_text(PAGE, ExInitializeRundownProtectionCacheAware)
#pragma alloc_text(PAGE, ExFreeCacheAwareRundownProtection)

//
// FtDisk will deadlock if this incurs a pagefault.
// #pragma alloc_text(PAGE, ExWaitForRundownProtectionReleaseCacheAware)

//
// This needs to be NONPAGED because FTDISK calls it with spinlock held
// 

// #pragma alloc_text(PAGE, ExReInitializeRundownProtectionCacheAware)
// #pragma alloc_text(PAGE, ExRundownCompletedCacheAware)

#endif                      


//
//  This macro takes a length & rounds it up to a multiple of the alignment
//  Alignment is given as a power of 2
// 
#define EXP_ALIGN_UP_PTR_ON_BOUNDARY(_length, _alignment)                      \
          (PVOID) ((((ULONG_PTR) (_length)) + ((_alignment)-1)) &              \
                              ~(ULONG_PTR)((_alignment) - 1))
            
//
//  Checks if 1st argument is aligned on given power of 2 boundary specified
//  by 2nd argument
//
#define EXP_IS_ALIGNED_ON_BOUNDARY(_pointer, _alignment)                       \
        ((((ULONG_PTR) (_pointer)) & ((_alignment) - 1)) == 0)

//
// This is a block held on the local stack of the rundown thread.
//
typedef struct _EX_RUNDOWN_WAIT_BLOCK {
    ULONG_PTR Count;
    KEVENT WakeEvent;
} EX_RUNDOWN_WAIT_BLOCK, *PEX_RUNDOWN_WAIT_BLOCK;


NTKERNELAPI
VOID
FASTCALL
ExfInitializeRundownProtection (
     __out PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Initialize rundown protection structure

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    RunRef->Count = 0;
}

NTKERNELAPI
VOID
FASTCALL
ExfReInitializeRundownProtection (
     __out PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reinitialize rundown protection structure after its been rundown

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, NULL);
}

NTKERNELAPI
VOID
FASTCALL
ExfRundownCompleted (
     __out PEX_RUNDOWN_REF RunRef
     )
/*++
Routine Description:

    Mark rundown block has having completed rundown so we can wait again safely.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None
--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, (PVOID) EX_RUNDOWN_ACTIVE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExfAcquireRundownProtection (
     __inout PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occurring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     __inout PEX_RUNDOWN_REF RunRef,
     __in ULONG Count
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occurring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to be referenced
    Count  - Number of references to add

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC * Count;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}


NTKERNELAPI
VOID
FASTCALL
ExfReleaseRundownProtection (
     __inout PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to have its reference released

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            //
            //  For cache-aware rundown protection, it's possible that the count
            //  in the waitblock is zero. We assert weakly on the uniproc case alone
            //
            ASSERT ((WaitBlock->Count > 0) || (KeNumberProcessors > 1));

#if defined(_WIN64)
            if (InterlockedDecrement64 ((PLONGLONG)&WaitBlock->Count) == 0) {
#else 
            if (InterlockedDecrement ((PLONG)&WaitBlock->Count) == 0) {
#endif                
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            // For cache-aware rundown-protection it is possible that Value is  <= zero
            //

            ASSERT ((Value >= EX_RUNDOWN_COUNT_INC) || (KeNumberProcessors > 1));

            NewValue = Value - EX_RUNDOWN_COUNT_INC;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     __inout PEX_RUNDOWN_REF RunRef,
     __in ULONG Count
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to have its reference released
    Count  - Number of reference to remove

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            //
            // For cache-aware rundown protection, it's possible the count in the waitblock
            // is actually zero at this point, so this assert is not applicable. We assert weakly
            // only for uni-proc. 
            //
            ASSERT ((WaitBlock->Count >= Count) || (KeNumberProcessors > 1));

#if defined (_WIN64) 
            if (InterlockedExchangeAdd64((PLONGLONG)&WaitBlock->Count, -(LONGLONG)Count) == (LONGLONG) Count) {
#else 
            if (InterlockedExchangeAdd((PLONG)&WaitBlock->Count, -(LONG)Count) == (LONG) Count) {
#endif
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            //

            //
            // For cache-aware rundown protection, it's possible that the value on this processor
            // is actually 0 or some integer less than count, so this assert is not applicable.
            // 
            ASSERT ((Value >= EX_RUNDOWN_COUNT_INC * Count) || (KeNumberProcessors > 1));

            NewValue = Value - EX_RUNDOWN_COUNT_INC * Count;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExfWaitForRundownProtectionRelease (
     __inout PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRef - Pointer to a rundown structure

Return Value:

    None

--*/
{
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    PKEVENT Event;
    ULONG_PTR Value, NewValue;
    ULONG_PTR WaitCount;

    PAGED_CODE ();

    //
    // Fast path. this should be the normal case. If Value is zero then there are no current accessors and we have
    // marked the rundown structure as rundown. If the value is EX_RUNDOWN_ACTIVE then the structure has already
    // been rundown and ExRundownCompleted. This second case allows for callers that might initiate rundown
    // multiple times (like handle table rundown) to have subsequent rundowns become noops.
    //

    Value = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                           (PVOID) EX_RUNDOWN_ACTIVE,
                                                           (PVOID) 0);
    if (Value == 0 || Value == EX_RUNDOWN_ACTIVE) {
        return;
    }

    //
    // Slow path
    //
    Event = NULL;
    do {

        //
        // Extract total number of waiters. Its biased by 2 so we can hanve the rundown active bit.
        //
        WaitCount = (Value >> EX_RUNDOWN_COUNT_SHIFT);

        //
        // If there are some accessors present then initialize an event (once only).
        //
        if (WaitCount > 0 && Event == NULL) {
            Event = &WaitBlock.WakeEvent;
            KeInitializeEvent (Event, SynchronizationEvent, FALSE);
        }
        //
        // Store the wait count in the wait block. Waiting threads will start to decrement this as they exit
        // if our exchange succeeds. Its possible for accessors to come and go between our initial fetch and
        // the interlocked swap. This doesn't matter so long as there is the same number of outstanding accessors
        // to wait for.
        //
        WaitBlock.Count = WaitCount;

        NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            if (WaitCount > 0) {
                KeWaitForSingleObject (Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ASSERT (WaitBlock.Count == 0);

            }
            return;
        }
        Value = NewValue;

        ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);
    } while (TRUE);
}

PEX_RUNDOWN_REF
FORCEINLINE
EXP_GET_CURRENT_RUNDOWN_REF(
    IN PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    )
/*++

Routine Description

    Returns the per-processor cache-aligned rundown ref structure for
    the current processor

Arguments

    RunRefCacheAware - Pointer to cache-aware rundown ref structure

Return Value:

    Pointer to a per-processor rundown ref
--*/
{
    return ((PEX_RUNDOWN_REF) (((PUCHAR) RunRefCacheAware->RunRefs) +
                               (KeGetCurrentProcessorNumber() % RunRefCacheAware->Number) * RunRefCacheAware->RunRefSize));
}

PEX_RUNDOWN_REF
FORCEINLINE
EXP_GET_PROCESSOR_RUNDOWN_REF(
    IN PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    IN ULONG Index
    )
/*++

Routine Description

    Returns the per-processor cache-aligned rundown ref structure for given processor

Arguments

    RunRefCacheAware - Pointer to cache-aware rundown ref structure
    Index - Index of the processor

Return Value:

    Pointer to a per-processor rundown ref
--*/
{
    return ((PEX_RUNDOWN_REF) (((PUCHAR) RunRefCacheAware->RunRefs) +
                                (Index % RunRefCacheAware->Number) * RunRefCacheAware->RunRefSize));
}

NTKERNELAPI
PEX_RUNDOWN_REF_CACHE_AWARE
ExAllocateCacheAwareRundownProtection(
    __in POOL_TYPE PoolType,
    __in ULONG PoolTag
    )
/*++

Routine Description:

    Allocate a cache-friendly rundown ref structure for MP scenarios

Arguments

    PoolType - Type of pool to allocate from
    PoolTag -  Tag used for the pool allocation

Return Value

    Pointer to cache-aware rundown ref structure

    NULL if out of memory
--*/
{

    PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware;
    PEX_RUNDOWN_REF RunRefPool;
    PEX_RUNDOWN_REF CurrentRunRef;
    ULONG PaddedSize;
    ULONG Index;

    PAGED_CODE();

    RunRefCacheAware = ExAllocatePoolWithTag (PoolType,
                                              sizeof( EX_RUNDOWN_REF_CACHE_AWARE ),
                                              PoolTag
                                              );

    if (NULL != RunRefCacheAware) {

        //
        // Capture number of processors: this will be the # of rundown counts we use
        //
        RunRefCacheAware->Number = KeNumberProcessors;

        //
        // Determine size of each ref structure
        //
        if (RunRefCacheAware->Number > 1) {
            PaddedSize = KeGetRecommendedSharedDataAlignment ();
            ASSERT ((PaddedSize & (PaddedSize - 1)) == 0);
        } else {
            PaddedSize = sizeof (EX_RUNDOWN_REF);
        }

        ASSERT (sizeof (EX_RUNDOWN_REF) <= PaddedSize);

        //
        //  Remember the size
        //
        RunRefCacheAware->RunRefSize = PaddedSize;

        RunRefPool = ExAllocatePoolWithTag (PoolType,
                                            PaddedSize * RunRefCacheAware->Number,
                                            PoolTag);

        if (RunRefPool == NULL) {
            ExFreePool (RunRefCacheAware);
            return NULL;
        }

        //
        // Check if pool is aligned if this is a multi-proc
        //
        if ((RunRefCacheAware->Number > 1) && 
            !EXP_IS_ALIGNED_ON_BOUNDARY (RunRefPool, PaddedSize)) {

            //
            //  We will allocate a padded size, free the old pool
            //
            ExFreePool (RunRefPool);

            //
            //  Allocate enough padding so we can start the refs on an aligned boundary
            //
            RunRefPool = ExAllocatePoolWithTag (PoolType,
                                                PaddedSize * RunRefCacheAware->Number + PaddedSize,
                                                PoolTag);

            if (RunRefPool == NULL) {
                ExFreePool (RunRefCacheAware);
                return NULL;
            }

            CurrentRunRef = EXP_ALIGN_UP_PTR_ON_BOUNDARY (RunRefPool, PaddedSize);

        } else {

            //
            //  Already aligned pool
            //
            CurrentRunRef = RunRefPool;
        }

        //
        //  Remember the pool block to free
        //
        RunRefCacheAware->PoolToFree = RunRefPool;
        RunRefCacheAware->RunRefs = CurrentRunRef;

        for (Index = 0; Index < RunRefCacheAware->Number; Index++) {
            CurrentRunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);
            ExInitializeRundownProtection (CurrentRunRef);
        }
    }

    return RunRefCacheAware;
}

NTKERNELAPI
SIZE_T
ExSizeOfRundownProtectionCacheAware(
    VOID
    )
/*++

Routine Description:

    Returns recommended size for a cache-friendly rundown structure

Arguments

    None

Return Value

    Recommended size in bytes
--*/
{
    SIZE_T RundownSize;
    ULONG PaddedSize;
    ULONG Number;

    PAGED_CODE();

    RundownSize = sizeof (EX_RUNDOWN_REF_CACHE_AWARE);

    //
    // Determine size of each ref structure
    //

    Number = KeNumberProcessors;

    if (Number > 1) {

       //
       // Allocate more to account for alignment (pessimistic size)
       //

       PaddedSize= KeGetRecommendedSharedDataAlignment () * (Number+1);


    } else {
        PaddedSize = sizeof (EX_RUNDOWN_REF);
    }

    RundownSize += PaddedSize;

    return RundownSize;
}

NTKERNELAPI
VOID
ExInitializeRundownProtectionCacheAware(
    __out PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
    __in SIZE_T RunRefSize
    )
/*++

Routine Description:

    Initializes an embedded cache aware rundown structure.
    This is for drivers who like to allocate this structure as part of their 
    device extension. Callers of this routine must have obtained the required size
    via a call to ExSizeOfCacheAwareRundownProtection and passed a pointer to that 
    structure. 
   
    NOTE:  
    This structure should NOT be freed via ExFreeCacheAwareRundownProtection().

Arguments

    RunRefCacheAware    - Pointer to structure to be initialized allocated in non-paged memory
    RunRefSize          - Size returned by call to ExSizeOfCacheAwareRundownProtection

Return Value

    None
--*/
{
    PEX_RUNDOWN_REF CurrentRunRef;
    ULONG PaddedSize;
    LONG Number;
    ULONG Index;
    ULONG ArraySize;

    PAGED_CODE();

    //
    //  Reverse engineer the size of each rundown structure based on the size
    //  that is passed in
    //

    CurrentRunRef = (PEX_RUNDOWN_REF) (((ULONG_PTR) RunRefCacheAware) + sizeof (EX_RUNDOWN_REF_CACHE_AWARE));

    ArraySize = (ULONG) (RunRefSize - sizeof( EX_RUNDOWN_REF_CACHE_AWARE )); 
    
    if (ArraySize == sizeof (EX_RUNDOWN_REF)) {
        Number = 1;
        PaddedSize = ArraySize;
    } else {

        PaddedSize = KeGetRecommendedSharedDataAlignment();

        Number =  ArraySize / PaddedSize - 1;

        CurrentRunRef = EXP_ALIGN_UP_PTR_ON_BOUNDARY (CurrentRunRef , PaddedSize);
    }

    RunRefCacheAware->RunRefs = CurrentRunRef;
    RunRefCacheAware->RunRefSize = PaddedSize;
    RunRefCacheAware->Number = Number;

    //
    //  This signature will signify that this structure should not be freed
    //  via ExFreeCacheAwareRundownProtection: if there's a bugcheck with an attempt
    //  to access this address & ExFreeCacheAwareRundownProtection on the stack,
    //  the caller of ExFree* is at fault.
    //

    RunRefCacheAware->PoolToFree = UintToPtr (0x0BADCA11);

    for (Index = 0; Index < RunRefCacheAware->Number; Index++) {
        CurrentRunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);
        ExInitializeRundownProtection (CurrentRunRef);
    }
}

NTKERNELAPI
VOID
ExFreeCacheAwareRundownProtection(
    __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
    )
/*++

Routine Description:

    Free a cache-friendly rundown ref structure

Arguments

    RunRef - pointer to cache-aware rundown ref structure

Return Value

    None

--*/
{
    PAGED_CODE ();

    ASSERT (RunRefCacheAware->PoolToFree != UintToPtr (0x0BADCA11));

    ExFreePool (RunRefCacheAware->PoolToFree);
    ExFreePool (RunRefCacheAware);
}


NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occurring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRefCacheAware - Rundown block to be referenced

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
   return ExAcquireRundownProtection (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware));
}

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRefCacheAware - Cache aware rundown block to have its reference released

Return Value:

    None

--*/
{
    ExReleaseRundownProtection (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware));
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionCacheAwareEx (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
     __in ULONG Count
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occurring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRefCacheAware - Rundown block to be referenced
    Count  - Number of references to add

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
   return ExAcquireRundownProtectionEx (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware), Count);
}

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionCacheAwareEx (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware,
     __in ULONG Count
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Cache aware rundown block to have its reference released
    Count  - Number of reference to remove

Return Value:

    None

--*/
{
    ExReleaseRundownProtectionEx (EXP_GET_CURRENT_RUNDOWN_REF (RunRefCacheAware), Count);
}

NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionReleaseCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRefCacheAware -  Pointer to a rundown structure

Return Value:

    None

--*/
{
    PEX_RUNDOWN_REF RunRef;
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    ULONG_PTR Value, NewValue;
    ULONG_PTR TotalCount;
    ULONG Index;


    //
    // Obtain the outstanding references by totalling up all the
    // counts for all the RunRef structures.
    //
    TotalCount = 0;
    WaitBlock.Count = 0;

    for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {

        RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);

        //
        //  Extract current count &  mark rundown active atomically
        //
        Value = RunRef->Count;

        do {
            
            ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);

            //
            //  Indicate that the on-stack count should be used for callers of release rundown protection
            //

            NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {

                //
                //  Succeeded in making rundown active
                //

                break;
            }

            Value = NewValue;

        } while (TRUE);

        //
        // Add outstanding references on this processor to the total
        // Ignore overflow: note the rundown active bit will be zero for Value
        // so we will not add up those bits
        //
        TotalCount +=  Value;
    }

    //
    // If total count was zero there are no outstanding references
    // active at this point - since no refs can creep in after we have
    // set the rundown flag on each processor
    //
    ASSERT ((LONG_PTR) TotalCount >= 0);

    //
    //  If total count was zero there are no outstanding references
    //  active at this point - since no refs can creep in after we have
    //  set the rundown flag on each processor
    //
    if (TotalCount != 0) {

        //
        //  Extract actual number of waiters - count is biased by 2
        //
        TotalCount >>= EX_RUNDOWN_COUNT_SHIFT;

        //
        //  Initialize the gate - since the dereferencer can decrement the count as soon
        //  as we add the per-processor count to the on-stack count
        //
        KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);

        //
        //  Add the total count to the on-stack count. If the result is zero,
        //  there are no more outstanding references. Otherwise wait to be signaled
        //
#if defined(_WIN64)
        if (InterlockedExchangeAdd64 ((PLONGLONG) &WaitBlock.Count,
                                       (LONGLONG) TotalCount)  != (-(LONGLONG) TotalCount)) {
#else
        if (InterlockedExchangeAdd ((PLONG) &WaitBlock.Count,
                                    (LONG) TotalCount)  != (-(LONG)TotalCount)) {
#endif
            KeWaitForSingleObject (&WaitBlock.WakeEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

        }
    }

    return;
}

NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtectionCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     )
/*++

Routine Description:

    Reinitialize rundown protection structure after its been rundown

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    PEX_RUNDOWN_REF RunRef;
    ULONG Index;


    for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {
        RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);
        ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
        InterlockedExchangePointer (&RunRef->Ptr, NULL);
    }
}

NTKERNELAPI
VOID
FASTCALL
ExRundownCompletedCacheAware (
     __inout PEX_RUNDOWN_REF_CACHE_AWARE RunRefCacheAware
     )
/*++
Routine Description:

    Mark rundown block has having completed rundown so we can wait again safely.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None
--*/
{
    PEX_RUNDOWN_REF RunRef;
    ULONG Index;

    for ( Index = 0; Index < RunRefCacheAware->Number; Index++) {
        RunRef = EXP_GET_PROCESSOR_RUNDOWN_REF (RunRefCacheAware, Index);
        ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
        InterlockedExchangePointer (&RunRef->Ptr, (PVOID) EX_RUNDOWN_ACTIVE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\sysinfo.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    sysinfo.c

Abstract:

    This module implements the NT set and query system information services.

--*/

#include "exp.h"
#pragma hdrstop

#include "stdlib.h"
#include "string.h"
#include "vdmntos.h"
#include <nturtl.h>
#include "pool.h"
#include "stktrace.h"
#include "align.h"

#if defined(_WIN64)

#include <wow64t.h>

#endif

#define COMPLUS_PACKAGE_KEYPATH      L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\.NETFramework"
#define COMPLUS_PACKAGE_ENABLE64BIT  L"Enable64Bit"
#define COMPLUS_PACKAGE_INVALID      (ULONG)-1


NTSTATUS
ExpReadComPlusPackage (
    VOID
    );

NTSTATUS
ExpUpdateComPlusPackage (
    IN ULONG ComPlusPackageStatus
    );


extern ULONG MmSystemCodePage;
extern ULONG MmSystemCachePage;
extern ULONG MmPagedPoolPage;
extern ULONG MmSystemDriverPage;
extern ULONG MmTotalSystemCodePages;
extern LONG MmTotalSystemDriverPages;
extern RTL_TIME_ZONE_INFORMATION ExpTimeZoneInformation;

//
// For SystemDpcBehaviorInformation
//

extern LIST_ENTRY MmLoadedUserImageList;

extern MMSUPPORT MmSystemCacheWs;
extern PFN_NUMBER MmTransitionSharedPages;
extern PFN_NUMBER MmTransitionSharedPagesPeak;

#define ROUND_UP(VALUE,ROUND) ((ULONG)(((ULONG)VALUE + \
                               ((ULONG)ROUND - 1L)) & (~((ULONG)ROUND - 1L))))
                               
//
// For referencing a user-supplied event handle
//

extern POBJECT_TYPE ExEventObjectType;

//
// Watchdog Handler
//

PWD_HANDLER ExpWdHandler = NULL;
PVOID ExpWdHandlerContext = NULL;

//
// COM+ Package Install Status
//

const static UNICODE_STRING KeyName = RTL_CONSTANT_STRING(COMPLUS_PACKAGE_KEYPATH);
static UNICODE_STRING KeyValueName = RTL_CONSTANT_STRING(COMPLUS_PACKAGE_ENABLE64BIT);

//
// Define Win32k full path.
//

#define WIN32K_FILE_PATH L"\\SystemRoot\\System32\\win32k.sys"
#define WIN32K_PATH_SIZE (sizeof(WIN32K_FILE_PATH) - sizeof(WCHAR))

WCHAR Win32kFullPath[] = WIN32K_FILE_PATH;

//
// Firmware Table handler list
//

LIST_ENTRY  ExpFirmwareTableProviderListHead;

//
// Firmware Table ERESOURCE
//

ERESOURCE  ExpFirmwareTableResource;

//
// Firmware Table handler node
//

typedef struct _SYSTEM_FIRMWARE_TABLE_HANDLER_NODE {
    SYSTEM_FIRMWARE_TABLE_HANDLER SystemFWHandler;  
    LIST_ENTRY FirmwareTableProviderList;
} SYSTEM_FIRMWARE_TABLE_HANDLER_NODE, *PSYSTEM_FIRMWARE_TABLE_HANDLER_NODE;

NTSTATUS
ExpValidateLocale (
    IN LCID LocaleId
    );

BOOLEAN
ExpIsValidUILanguage (
    IN WCHAR *pLangId
    );

NTSTATUS
ExpGetCurrentUserUILanguage (
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId,
    IN BOOLEAN bCheckGP
    );

NTSTATUS
ExpSetCurrentUserUILanguage (
    IN WCHAR *ValueName,
    IN LANGID DefaultUILanguageId
    );

NTSTATUS
ExpGetUILanguagePolicy (
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    );

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length OPTIONAL,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    );

NTSTATUS
ExGetSessionPoolTagInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId
    );

NTSTATUS
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

NTSTATUS
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    );

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    );

#if i386

NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

#endif // i386

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformationEx (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetObjectInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetInstemulInformation (
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    );

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    );

NTSTATUS
ExGetBigPoolInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryModuleInformation (
    IN PLIST_ENTRY LoadOrderListHead,
    IN PLIST_ENTRY UserModeLoadOrderListHead,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryLegacyDriverInformation (
    IN PSYSTEM_LEGACY_DRIVER_INFORMATION LegacyInfo,
    IN PULONG Length
    );

NTSTATUS
ExpQueryNumaProcessorMap (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

NTSTATUS
ExpQueryNumaAvailableMemory (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

NTSTATUS
ExpGetSystemFirmwareTableInformation (
    IN OUT PVOID SystemFirmwareTableInformation,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpRegisterFirmwareTableInformationHandler (
    IN OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    );

#pragma alloc_text(PAGE, NtQueryDefaultLocale)
#pragma alloc_text(PAGE, NtSetDefaultLocale)
#pragma alloc_text(PAGE, NtQueryInstallUILanguage)
#pragma alloc_text(PAGE, NtQueryDefaultUILanguage)
#pragma alloc_text(PAGE, ExpGetCurrentUserUILanguage)
#pragma alloc_text(PAGE, NtSetDefaultUILanguage)
#pragma alloc_text(PAGE, ExpSetCurrentUserUILanguage)
#pragma alloc_text(PAGE, ExpValidateLocale)
#pragma alloc_text(PAGE, ExpGetUILanguagePolicy)
#pragma alloc_text(PAGE, NtQuerySystemInformation)
#pragma alloc_text(PAGE, NtSetSystemInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformationEx)
#pragma alloc_text(PAGE, ExpGetObjectInformation)
#pragma alloc_text(PAGE, ExpQueryModuleInformation)
#pragma alloc_text(PAGE, ExpCopyProcessInfo)
#pragma alloc_text(PAGE, ExpQueryLegacyDriverInformation)
#pragma alloc_text(PAGE, ExLockUserBuffer)
#pragma alloc_text(PAGE, ExpQueryNumaAvailableMemory)
#pragma alloc_text(PAGE, ExpQueryNumaProcessorMap)
#pragma alloc_text(PAGE, ExpReadComPlusPackage)
#pragma alloc_text(PAGE, ExpUpdateComPlusPackage)
#pragma alloc_text(PAGE, ExGetSessionPoolTagInformation)
#pragma alloc_text(PAGELK, ExpGetLockInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorPowerInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorIdleInformation)
#pragma alloc_text(PAGE, ExpIsValidUILanguage)
#pragma alloc_text(PAGE, ExpGetSystemFirmwareTableInformation)
#pragma alloc_text(PAGE, ExpRegisterFirmwareTableInformationHandler)

NTSTATUS
ExpReadComPlusPackage (
    VOID
    )

/*++

Routine Description:

    This function reads the status of the 64-bit COM+ package from the registry
    and stick it inside the shared page.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    static OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    HANDLE Key;


    Status = ZwOpenKey (&Key,
                        GENERIC_READ,
                        &ObjectAttributes);

    if (NT_SUCCESS (Status)) {

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
        Status = ZwQueryValueKey (Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof (KeyValueBuffer),
                                  &ResultLength);

        if (NT_SUCCESS (Status)) {

            if ((KeyValueInformation->Type == REG_DWORD) &&
                (KeyValueInformation->DataLength == sizeof(ULONG))) {
                SharedUserData->ComPlusPackage = *(PULONG)KeyValueInformation->Data;
            }
        }

        ZwClose (Key);
    }

    return Status;
}

NTSTATUS
ExpUpdateComPlusPackage (
    IN ULONG ComPlusPackageStatus
    )

/*++

Routine Description:

    This function updates the COM+ runtime package status on the system.
    The package status indicates whether the 64-bit or the 32-bit runtime
    should be used when executing IL_ONLY COM+ images.

Arguments:

    ComPlusPackageStatus - COM+ Runtime package status on the system


Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    static OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK);
    ULONG Disposition;
    HANDLE Key;


    Status = ZwOpenKey (&Key,
                        GENERIC_WRITE,
                        &ObjectAttributes
                        );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        Status = ZwCreateKey (&Key,
                              GENERIC_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              &Disposition
                            );
    }

    if (NT_SUCCESS (Status)) {

        Status = ZwSetValueKey (Key,
                                &KeyValueName,
                                0,
                                REG_DWORD,
                                &ComPlusPackageStatus,
                                sizeof(ULONG));
        ZwClose (Key);
    }

    return Status;
}

NTSTATUS
NtQueryDefaultLocale (
    __in BOOLEAN UserProfile,
    __out PLCID DefaultLocaleId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUlong ((PULONG)DefaultLocaleId);
        }

        if (UserProfile) {
            *DefaultLocaleId = MmGetSessionLocaleId ();
        }
        else {
            *DefaultLocaleId = PsDefaultSystemLocaleId;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NtSetDefaultLocale (
    __in BOOLEAN UserProfile,
    __in LCID DefaultLocaleId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey = NULL, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PWSTR s;
    ULONG n, i, Digit;
    WCHAR c;
    ULONG Flags;

    PAGED_CODE();

    if (DefaultLocaleId & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    if (UserProfile) {
        Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        RtlInitUnicodeString( &KeyValueName, L"Locale" );
        RtlInitUnicodeString( &KeyPath, L"Control Panel\\International" );
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK;
    }
    else {
        RtlInitUnicodeString( &KeyValueName, L"Default" );
        RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language" );
        CurrentUserKey = NULL;
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                Flags,
                                CurrentUserKey,
                                NULL);

    if (DefaultLocaleId == 0) {

        Status = ZwOpenKey (&Key, GENERIC_READ, &ObjectAttributes);

        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {
                if (KeyValueInformation->Type == REG_SZ) {
                    s = (PWSTR)KeyValueInformation->Data;
                    for (i=0; i<KeyValueInformation->DataLength; i += sizeof( WCHAR )) {
                        c = *s++;
                        if (c >= L'0' && c <= L'9') {
                            Digit = c - L'0';
                        }
                        else if (c >= L'A' && c <= L'F') {
                            Digit = c - L'A' + 10;
                        }
                        else if (c >= L'a' && c <= L'f') {
                            Digit = c - L'a' + 10;
                        }
                        else {
                            break;
                        }

                        if (Digit >= 16) {
                            break;
                        }

                        DefaultLocaleId = (DefaultLocaleId << 4) | Digit;
                    }
                }
                else {
                    if (KeyValueInformation->Type == REG_DWORD &&
                        KeyValueInformation->DataLength == sizeof( ULONG )) {

                        DefaultLocaleId = *(PLCID)KeyValueInformation->Data;
                    }
                    else {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }

            ZwClose( Key );
        }
    }
    else {

        Status = ExpValidateLocale( DefaultLocaleId );

        if (NT_SUCCESS(Status)) {

            Status = ZwOpenKey( &Key,
                                GENERIC_WRITE,
                                &ObjectAttributes
                              );

            if (NT_SUCCESS( Status )) {
                if (UserProfile) {
                    n = 8;
                }
                else {
                    n = 4;
                }

                s = &KeyValueBuffer[ n ];
                *s-- = UNICODE_NULL;
                i = (ULONG)DefaultLocaleId;

                while (s >= KeyValueBuffer) {
                    Digit = i & 0x0000000F;
                    if (Digit <= 9) {
                        *s-- = (WCHAR)(Digit + L'0');
                    }
                    else {
                        *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                    i = i >> 4;
                }

                Status = ZwSetValueKey( Key,
                                        &KeyValueName,
                                        0,
                                        REG_SZ,
                                        KeyValueBuffer,
                                        (n+1) * sizeof( WCHAR )
                                      );
                ZwClose( Key );
            }
        }
    }

    if( CurrentUserKey ) {
        ZwClose( CurrentUserKey );
    }

    if (NT_SUCCESS( Status )) {
        if (UserProfile) {
            MmSetSessionLocaleId (DefaultLocaleId);
        }
        else {
            PsDefaultSystemLocaleId = DefaultLocaleId;
        }
    }

    return Status;
}

NTSTATUS
NtQueryInstallUILanguage (
    __out LANGID *InstallUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)InstallUILanguageId );
            }

        *InstallUILanguageId = PsInstallUILanguageId;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
NtQueryDefaultUILanguage (
    __out LANGID *DefaultUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)DefaultUILanguageId );
            }

        //
        // Read the UI language from the current security context.
        //
        if (!NT_SUCCESS(ExpGetCurrentUserUILanguage( L"MultiUILanguageId",
                                                     DefaultUILanguageId,
                                                     TRUE))) {
            *DefaultUILanguageId = PsInstallUILanguageId;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
ExpGetUILanguagePolicy (
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Language;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    RtlInitUnicodeString( &KeyValueName, L"MultiUILanguageId" );
    RtlInitUnicodeString( &KeyPath, L"Software\\Policies\\Microsoft\\Control Panel\\Desktop" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Check if there is a Policy key
    //
    Status = ZwOpenKey( &Key,
                        GENERIC_READ,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS( Status )) {

        Status = ZwQueryValueKey( Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( KeyValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS( Status )) {
            if ((KeyValueInformation->DataLength > 2) &&
                (KeyValueInformation->Type == REG_SZ) &&
                ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );
                Status = RtlUnicodeStringToInteger( &KeyValueName,
                                                    (ULONG)16,
                                                    &Language
                                                  );
                //
                // Final check to make sure this is an MUI system
                //
                if (NT_SUCCESS( Status )) {
                    *PolicyUILanguageId = (LANGID)Language;
                    }
                }
            else {
                Status = STATUS_UNSUCCESSFUL;
                }
            }
            ZwClose( Key );
        }

    return Status;
}

NTSTATUS
ExpSetCurrentUserUILanguage (
    IN WCHAR *ValueName,
    IN LANGID CurrentUserUILanguage
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PWSTR s;
    ULONG i, Digit;

    PAGED_CODE();

    if (CurrentUserUILanguage & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
        }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );


    Status = ExpValidateLocale( MAKELCID( CurrentUserUILanguage, SORT_DEFAULT ) );

    if (NT_SUCCESS(Status)) {

        Status = ZwOpenKey( &Key,
                            GENERIC_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {

            s = &KeyValueBuffer[ 8 ];
            *s-- = UNICODE_NULL;
            i = (ULONG)CurrentUserUILanguage;

            while (s >= KeyValueBuffer) {
                Digit = i & 0x0000000F;
                if (Digit <= 9) {
                    *s-- = (WCHAR)(Digit + L'0');
                    }
                else {
                    *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                i = i >> 4;
                }

            Status = ZwSetValueKey( Key,
                                    &KeyValueName,
                                    0,
                                    REG_SZ,
                                    KeyValueBuffer,
                                    9 * sizeof( WCHAR )
                                  );
            ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}

NTSTATUS
ExpGetCurrentUserUILanguage (
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId,
    IN BOOLEAN bCheckGP
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName, UILanguage;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Digit;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }
    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Let's check if there is a policy installed for the UI language,
    // and if so, let's use it.
    //
    if (!bCheckGP || !NT_SUCCESS( ExpGetUILanguagePolicy( CurrentUserKey, CurrentUserUILanguageId ))) {
        Status = ZwOpenKey( &Key,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {

                if (KeyValueInformation->Type == REG_SZ &&
                    ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                    RtlInitUnicodeString( &UILanguage, (PWSTR) KeyValueInformation->Data);
                    Status = RtlUnicodeStringToInteger( &UILanguage,
                                                        (ULONG) 16,
                                                        &Digit
                                                      );
                    if (NT_SUCCESS( Status )) {
                        *CurrentUserUILanguageId = (LANGID) Digit;
                        }
                    }
                else {
                    Status = STATUS_UNSUCCESSFUL;
                    }
                }
                ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}

NTSTATUS
NtSetDefaultUILanguage (
    __in LANGID DefaultUILanguageId
    )
{
    NTSTATUS Status;
    LANGID LangId;

    //
    //  if this is called during user logon, then we need to update the user's registry.
    //
    if (DefaultUILanguageId == 0) {
          Status = ExpGetCurrentUserUILanguage( L"MUILanguagePending" ,
                                                &LangId,
                                                FALSE
                                                );
          if (NT_SUCCESS( Status )) {
            Status = ExpSetCurrentUserUILanguage( L"MultiUILanguageId" ,
                                                  LangId
                                                );
            }
          return Status;
        }

    return ExpSetCurrentUserUILanguage( L"MUILanguagePending", DefaultUILanguageId );
}

NTSTATUS
ExpValidateLocale (
    IN LCID LocaleId
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER, ReturnStatus;
    UNICODE_STRING LocaleName, KeyValueName;
    UNICODE_STRING NlsLocaleKeyPath, NlsSortKeyPath, NlsLangGroupKeyPath;
    WCHAR LocaleNameBuffer[ 32 ];
    WCHAR KeyValueNameBuffer[ 32 ];
    WCHAR KeyValueBuffer[ 128 ];
    WCHAR *Ptr;
    HANDLE LocaleKey, SortKey, LangGroupKey;
    OBJECT_ATTRIBUTES NlsLocaleObjA, NlsSortObjA, NlsLangGroupObjA;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG i, ResultLength;

    //
    //  Convert the LCID to the form %08x (e.g. 00000409)
    //
    LocaleName.Length = sizeof( LocaleNameBuffer ) / sizeof( WCHAR );
    LocaleName.MaximumLength = LocaleName.Length;
    LocaleName.Buffer = LocaleNameBuffer;

    //
    //  Convert LCID to a string
    //
    ReturnStatus = RtlIntegerToUnicodeString( LocaleId, 16, &LocaleName );
    if (!NT_SUCCESS(ReturnStatus))
        goto Failed1;

    Ptr = KeyValueNameBuffer;
    for (i = ((LocaleName.Length)/sizeof(WCHAR));
         i < 8;
         i++, Ptr++) {
        *Ptr = L'0';
        }
    *Ptr = UNICODE_NULL;

    RtlInitUnicodeString(&KeyValueName, KeyValueNameBuffer);
    KeyValueName.MaximumLength = sizeof( KeyValueNameBuffer ) / sizeof( WCHAR );
    RtlAppendUnicodeToString(&KeyValueName, LocaleName.Buffer);


    //
    // Open Registry Keys : Locale, Sort and LanguageGroup
    //
    RtlInitUnicodeString(&NlsLocaleKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale");

    InitializeObjectAttributes( &NlsLocaleObjA,
                                &NlsLocaleKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &LocaleKey,
                              GENERIC_READ,
                              &NlsLocaleObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed1;

    RtlInitUnicodeString(&NlsSortKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale\\Alternate Sorts");

    InitializeObjectAttributes( &NlsSortObjA,
                                &NlsSortKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &SortKey,
                              GENERIC_READ,
                              &NlsSortObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed2;

    RtlInitUnicodeString(&NlsLangGroupKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language Groups");

    InitializeObjectAttributes( &NlsLangGroupObjA,
                                &NlsLangGroupKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );


    ReturnStatus = ZwOpenKey( &LangGroupKey,
                              GENERIC_READ,
                              &NlsLangGroupObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed3;

    //
    // Validate Locale : Lookup the Locale's Language group, and make sure it is there.
    //
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) KeyValueBuffer;
    ReturnStatus = ZwQueryValueKey( LocaleKey,
                                    &KeyValueName,
                                    KeyValuePartialInformation,
                                    KeyValueInformation,
                                    sizeof( KeyValueBuffer ),
                                    &ResultLength
                                  );

    if (!NT_SUCCESS(ReturnStatus)) {
        ReturnStatus = ZwQueryValueKey( SortKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        }

    if ((NT_SUCCESS(ReturnStatus)) &&
        (KeyValueInformation->DataLength > 2)
       ) {

        RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );

        ReturnStatus = ZwQueryValueKey( LangGroupKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        if ((NT_SUCCESS(ReturnStatus)) &&
            (KeyValueInformation->Type == REG_SZ) &&
            (KeyValueInformation->DataLength > 2)
           ) {
            Ptr = (PWSTR) KeyValueInformation->Data;
            if (Ptr[0] == L'1' && Ptr[1] == UNICODE_NULL) {
                Status = STATUS_SUCCESS;
                }
            }
        }

    //
    // Close opened keys
    //

    ZwClose( LangGroupKey );

Failed3:
    ZwClose( SortKey );

Failed2:
    ZwClose( LocaleKey );

Failed1:

    //
    // If an error happens, let's record it.
    //
    if (!NT_SUCCESS(ReturnStatus)) {
        Status = ReturnStatus;
        }

    return Status;
}

NTSTATUS
ExpQueryNumaProcessorMap (
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;
#if !defined(NT_UP)
    ULONG i;
#endif

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          ActiveProcessorsAffinityMask);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->ActiveProcessorsAffinityMask[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   ActiveProcessorsAffinityMask[ReturnCount]);

#if !defined(NT_UP)

    for (i = 0; i < ReturnCount; i++) {
        Map->ActiveProcessorsAffinityMask[i] = KeNodeBlock[i]->ProcessorMask;
    }

#else

    if (ReturnCount) {
        Map->ActiveProcessorsAffinityMask[0] = 1;
    }

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExpQueryNumaAvailableMemory (
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          AvailableMemory);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->AvailableMemory[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   AvailableMemory[ReturnCount]);

    //
    // Return the approximate number of free bytes at this time.
    // (It's approximate because no lock is taken and with respect
    // to any user mode application its only a sample.
    //

#if !defined(NT_UP)

    if (KeNumberNodes > 1) {

        ULONG i;

        for (i = 0; i < ReturnCount; i++) {
            Map->AvailableMemory[i] =
                ((ULONGLONG)KeNodeBlock[i]->FreeCount[ZeroedPageList] +
                 (ULONGLONG)KeNodeBlock[i]->FreeCount[FreePageList])
                    << PAGE_SHIFT;
        }
    } else

#endif

    if (ReturnCount) {
        Map->AvailableMemory[0] = ((ULONGLONG)MmAvailablePages) << PAGE_SHIFT;
    }


    return STATUS_SUCCESS;
}

NTSTATUS
ExpGetSystemBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors = KeNumberProcessors;
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)KeActiveProcessors;
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = MmNumberOfPhysicalPages;
        BasicInfo->LowestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = (ULONG_PTR)MM_LOWEST_USER_ADDRESS;
        BasicInfo->MaximumUserModeAddress = (ULONG_PTR)MM_HIGHEST_USER_ADDRESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}

NTSTATUS
ExpGetSystemProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        ProcessorInformation->ProcessorArchitecture = KeProcessorArchitecture;
        ProcessorInformation->ProcessorLevel = KeProcessorLevel;
        ProcessorInformation->ProcessorRevision = KeProcessorRevision;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}

#if defined(_WIN64)

NTSTATUS
ExpGetSystemEmulationBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors =  min(32, KeNumberProcessors);
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)
            ((KeActiveProcessors & 0xFFFFFFFF) | ((KeActiveProcessors & (((ULONG_PTR)0xFFFFFFFF) << 32) ) >> 32));
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = (MmNumberOfPhysicalPages * (PAGE_SIZE >> PAGE_SHIFT_X86NT));
        BasicInfo->LowestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE_X86NT;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = 0x00000000000010000UI64;
        
        //
        // NOTE: MmGetMaxWowAddress return the highest usermode address boundary,
        // thus we are subtracting one to get the maximum accessible usermode address        
        //

        BasicInfo->MaximumUserModeAddress = ((ULONG_PTR)MmGetMaxWowAddress () - 1);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}

#endif

NTSTATUS
NtQuerySystemInformation (
    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,
    __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,
    __in ULONG SystemInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries information about the system.

Arguments:

    SystemInformationClass - The system information class about which
        to retrieve information.

    SystemInformation - A pointer to a buffer which receives the specified
        information.  The format and content of the buffer depend on the
        specified system information class.

        SystemInformation Format by Information Class:

        SystemBasicInformation - Data type is SYSTEM_BASIC_INFORMATION

            SYSTEM_BASIC_INFORMATION Structure

                ULONG Reserved - Always zero.

                ULONG TimerResolutionInMicroSeconds - The resolution of
                    the hardware time.  All time values in NT are
                    specified as 64-bit LARGE_INTEGER values in units of
                    100 nanoseconds.  This field allows an application to
                    understand how many of the low order bits of a system
                    time value are insignificant.

                ULONG PageSize - The physical page size for virtual memory
                    objects.  Physical memory is committed in PageSize
                    chunks.

                ULONG AllocationGranularity - The logical page size for
                    virtual memory objects.  Allocating 1 byte of virtual
                    memory will actually allocate AllocationGranularity
                    bytes of virtual memory.  Storing into that byte will
                    commit the first physical page of the virtual memory.

                ULONG MinimumUserModeAddress - The smallest valid user mode
                    address.  The first AllocationGranularity bytes of
                    the virtual address space are reserved.  This forces
                    access violations for code the dereferences a zero
                    pointer.

                ULONG MaximumUserModeAddress -  The largest valid user mode
                    address.  The next AllocationGranularity bytes of
                    the virtual address space are reserved.  This allows
                    system service routines to validate user mode pointer
                    parameters quickly.

                KAFFINITY ActiveProcessorsAffinityMask - The affinity mask
                    for the current hardware configuration.

                CCHAR NumberOfProcessors - The number of processors
                    in the current hardware configuration.

        SystemProcessorInformation - Data type is SYSTEM_PROCESSOR_INFORMATION

            SYSTEM_PROCESSOR_INFORMATION Structure

                USHORT ProcessorArchitecture - The processor architecture:
                    PROCESSOR_ARCHITECTURE_INTEL
                    PROCESSOR_ARCHITECTURE_IA64
                    PROCESSOR_ARCHITECTURE_MIPS
                    PROCESSOR_ARCHITECTURE_ALPHA
                    PROCESSOR_ARCHITECTURE_PPC

                USHORT ProcessorLevel - architecture dependent processor level.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        3 - 386
                        4 - 486
                        5 - 586 or Pentium

                    For PROCESSOR_ARCHITECTURE_IA64:
                        7  - Itanium
                        31 - Itanium 2

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx - where xx is 8-bit implementation number (bits 8-15 of
                            PRId register.
                        0004 - R4000

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxxx - where xxxx is 16-bit processor version number (low
                            order 16 bits of processor version number from firmware)

                        21064 - 21064
                        21066 - 21066
                        21164 - 21164

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxxx - where xxxx is 16-bit processor version number (high
                            order 16 bits of Processor Version Register).
                        1 - 601
                        3 - 603
                        4 - 604
                        6 - 603+
                        9 - 604+
                        20 - 620

                USHORT ProcessorRevision - architecture dependent processor revision.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        For Old Intel 386 or 486:
                            FFxx - where xx is displayed as a hexadecimal CPU stepping
                            (e.g. FFD0 is D0 stepping)

                        For Intel Pentium or Cyrix/NexGen 486
                            xxyy - where xx is model number and yy is stepping, so
                            0201 is Model 2, Stepping 1

                    For PROCESSOR_ARCHITECTURE_IA64:
                        xxyy - where xx is model number and yy is stepping, so
                            0201 is Model 2, Stepping 1

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx is 8-bit revision number of processor (low order 8 bits
                            of PRId Register

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of processor revision number from firmware).
                            Displayed as Model 'A'+xx, Pass yy

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of Processor Version Register).  Displayed
                            as a fixed point number xx.yy

                USHORT Reserved - Always zero.

                ULONG ProcessorFeatureBits - architecture dependent processor feature bits.
                    This is the least common denominator for an MP system.

        SystemPerformanceInformation - Data type is SYSTEM_PERFORMANCE_INFORMATION

            SYSTEM_PERFORMANCE_INFORMATION Structure

                LARGE_INTEGER IdleProcessTime - Returns the kernel time of the idle
                    process.

            LARGE_INTEGER IoReadTransferCount;
            LARGE_INTEGER IoWriteTransferCount;
            LARGE_INTEGER IoOtherTransferCount;
            LARGE_INTEGER KernelTime;
            LARGE_INTEGER UserTime;
            ULONG IoReadOperationCount;
            ULONG IoWriteOperationCount;
            ULONG IoOtherOperationCount;
            ULONG AvailablePages;
            ULONG CommittedPages;
            ULONG PageFaultCount;
            ULONG CopyOnWriteCount;
            ULONG TransitionCount;
            ULONG CacheTransitionCount;
            ULONG DemandZeroCount;
            ULONG PageReadCount;
            ULONG PageReadIoCount;
            ULONG CacheReadCount;
            ULONG CacheIoCount;
            ULONG DirtyPagesWriteCount;
            ULONG DirtyWriteIoCount;
            ULONG MappedPagesWriteCount;
            ULONG MappedWriteIoCount;
            ULONG PagedPoolPages;
            ULONG NonPagedPoolPages;
            ULONG PagedPoolAllocs;
            ULONG PagedPoolFrees;
            ULONG NonPagedPoolAllocs;
            ULONG NonPagedPoolFrees;
            ULONG LpcThreadsWaitingInReceive;
            ULONG LpcThreadsWaitingForReply;

        SystemProcessInformation - Data type is SYSTEM_PROCESS_INFORMATION

            SYSTEM_PROCESS_INFORMATION Structure

        SystemDockInformation - Data type is SYSTEM_DOCK_INFORMATION

             SYSTEM_DOCK_INFORMATION Structure

                 SYSTEM_DOCKED_STATE DockState - Ordinal specifying the current docking state. Possible values:
                     SystemDockStateUnknown - The docking state of the system could not be determined.
                     SystemUndocked - The system is undocked.
                     SystemDocked - The system is docked.

                 ULONG DockIdLength - Specifies the length in characters of the Dock ID string
                                      (not including terminating NULL).

                 ULONG SerialNumberOffset - Specifies the character offset of the Serial Number within
                                            the DockId buffer.

                 ULONG SerialNumberLength - Specifies the length in characters of the Serial Number
                                            string (not including terminating NULL).

                 WCHAR DockId - Character buffer containing two null-terminated strings.  The first
                                string is a character representation of the dock ID number, starting
                                at the beginning of the buffer.  The second string is a character
                                representation of the machine's serial number, starting at character
                                offset SerialNumberOffset in the buffer.


        SystemPowerSettings - Data type is SYSTEM_POWER_SETTINGS
            SYSTEM_POWER_INFORMATION Structure
                BOOLEAN SystemSuspendSupported - Supplies a BOOLEAN as to
                    whether the system suspend is enabled or not.
                BOOLEAN SystemHibernateSupported - Supplies a BOOLEAN as to
                    whether the system hibernate is enabled or not.
                BOOLEAN ResumeTimerSupportsSuspend - Supplies a BOOLEAN as to
                    whether the resuming from an external programmed timer
                    from within a system suspend is enabled or not.
                BOOLEAN ResumeTimerSupportsHibernate - Supplies a BOOLEAN as to
                    whether or resuming from an external programmed timer
                    from within a system hibernate is enabled or not.
                BOOLEAN LidSupported - Supplies a BOOLEAN as to whether or not
                    the suspending and resuming by Lid are enabled or not.
                BOOLEAN TurboSettingSupported - Supplies a BOOLEAN as to whether
                    or not the system supports a turbo mode setting.
                BOOLEAN TurboMode - Supplies a BOOLEAN as to whether or not
                    the system is in turbo mode.
                BOOLEAN SystemAcOrDc - Supplies a BOOLEAN as to whether or not
                    the system is in AC mode.
                BOOLEAN DisablePowerDown - If TRUE, signifies that all requests to
                    PoRequestPowerChange for a SET_POWER-PowerDown irp are to
                    be ignored.
                LARGE_INTEGER SpindownDrives - If non-zero, signifies to the
                    cache manager (or the IO subsystem) to optimize drive
                    accesses based upon power saves, are that drives are to
                    be spun down as appropriate. The value represents to user's
                    requested disk spin down timeout.

        SystemProcessorSpeedInformation - Data type is SYSTEM_PROCESSOR_SPEED_INFORMATION
            SYSTEM_PROCESSOR_SPEED_INFORMATION Structure (same as HalProcessorSpeedInformation)
                ULONG MaximumProcessorSpeed - The maximum hertz the processor is
                    capable of. This information is used by the UI to draw the
                    appropriate scale. This field is read-only and cannot be
                    set.
                ULONG CurrentAvailableSpeed - The hertz for which the processor
                    runs at when not idle. This field is read-only and cannot
                    be set.
                ULONG ConfiguredSpeedLimit - The hertz for which the processor
                    is limited to due to the current configuration.
                UCHAR PowerState
                    0 - Normal
                    1 - The processor speed is being limited due to available
                    power restrictions. This field id read-only by the system.
                UCHAR ThermalState
                    0 - Normal
                    1 - The processors speed is being limited due to thermal
                    restrictions. This field is read-only by the system.
                UCHAR TurboState
                    0 - Normal
                    1 - The processors speed is being limited by the fact that
                    the system turbo mode is currently disabled which is
                    requested to obtain more processor speed.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    ReturnLength - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the ReturnLength pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    SYSTEM_PERFORMANCE_INFORMATION LocalPerformanceInfo;
    PSYSTEM_PERFORMANCE_INFORMATION PerformanceInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorPerformanceInfo;
    PSYSTEM_CALL_COUNT_INFORMATION CallCountInformation;
    PSYSTEM_DEVICE_INFORMATION DeviceInformation;
    PCONFIGURATION_INFORMATION ConfigInfo;
    PSYSTEM_EXCEPTION_INFORMATION ExceptionInformation;
    PSYSTEM_FILECACHE_INFORMATION FileCache;
    PSYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    PSYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInformation;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitchInformation;
    PSYSTEM_INTERRUPT_INFORMATION InterruptInformation;
    PSYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInformation;
    PVOID ProcessInformation;
    ULONG ProcessInformationLength;
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPoolTagInformation;
    PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION SessionMappedViewInformation;
    ULONG SessionPoolTagInformationLength;

    NTSTATUS Status;
    PKPRCB Prcb;
    ULONG Length = 0;
    ULONG i;
    ULONG ContextSwitches;
    PULONG TableLimit, TableCounts;
    PKSERVICE_TABLE_DESCRIPTOR Table;
    ULONG SessionId;
    ULONG Alignment;

    PAGED_CODE();

    //
    // Assume successful completion.
    //

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            Alignment = sizeof(ULONG);

            if (SystemInformationClass == SystemKernelDebuggerInformation) {
                Alignment = sizeof(BOOLEAN);
            } else if (SystemInformationClass == SystemLocksInformation) {
                Alignment = sizeof(PVOID);
            }

            ProbeForWrite(SystemInformation,
                          SystemInformationLength,
                          Alignment);

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (SystemInformationClass) {

        case SystemBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemEmulationBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemProcessorInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemEmulationProcessorInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemPerformanceInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            PerformanceInfo = (PSYSTEM_PERFORMANCE_INFORMATION)SystemInformation;

            //
            // Io information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {

                ULONG OtherOperationCount;
                LARGE_INTEGER OtherTransferCount;
                ULONG ReadOperationCount;
                LARGE_INTEGER ReadTransferCount;
                ULONG WriteOperationCount;
                LARGE_INTEGER WriteTransferCount;

                OtherOperationCount = IoOtherOperationCount;
                OtherTransferCount.QuadPart = IoOtherTransferCount.QuadPart;
                ReadOperationCount = IoReadOperationCount;
                ReadTransferCount.QuadPart = IoReadTransferCount.QuadPart;
                WriteOperationCount = IoWriteOperationCount;
                WriteTransferCount.QuadPart = IoWriteTransferCount.QuadPart;
                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        OtherOperationCount += Prcb->IoOtherOperationCount;
                        OtherTransferCount.QuadPart += Prcb->IoOtherTransferCount.QuadPart;
                        ReadOperationCount += Prcb->IoReadOperationCount;
                        ReadTransferCount.QuadPart += Prcb->IoReadTransferCount.QuadPart;
                        WriteOperationCount += Prcb->IoWriteOperationCount;
                        WriteTransferCount.QuadPart += Prcb->IoWriteTransferCount.QuadPart;
                    }
                }

                LocalPerformanceInfo.IoReadTransferCount = ReadTransferCount;
                LocalPerformanceInfo.IoWriteTransferCount = WriteTransferCount;
                LocalPerformanceInfo.IoOtherTransferCount = OtherTransferCount;
                LocalPerformanceInfo.IoReadOperationCount = ReadOperationCount;
                LocalPerformanceInfo.IoWriteOperationCount = WriteOperationCount;
                LocalPerformanceInfo.IoOtherOperationCount = OtherOperationCount;
            }

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG FirstLevelTbFills = 0;
                ULONG SecondLevelTbFills = 0;
                ULONG SystemCalls = 0;

                ContextSwitches = 0;
                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        ContextSwitches += KeGetContextSwitches(Prcb);
                        FirstLevelTbFills += Prcb->KeFirstLevelTbFills;
                        SecondLevelTbFills += Prcb->KeSecondLevelTbFills;
                        SystemCalls += Prcb->KeSystemCalls;
                    }
                }

                LocalPerformanceInfo.ContextSwitches = ContextSwitches;
                LocalPerformanceInfo.FirstLevelTbFills = FirstLevelTbFills;
                LocalPerformanceInfo.SecondLevelTbFills = SecondLevelTbFills;
                LocalPerformanceInfo.SystemCalls = SystemCalls;
            }

            //
            // Mm information.
            //
            // some of these counters are kept on a per processor basis and
            // must be totaled.
            //

            LocalPerformanceInfo.AvailablePages = (ULONG)MmAvailablePages;
            LocalPerformanceInfo.CommittedPages = (SYSINF_PAGE_COUNT)MmTotalCommittedPages;
            LocalPerformanceInfo.CommitLimit = (SYSINF_PAGE_COUNT)MmTotalCommitLimit;
            LocalPerformanceInfo.PeakCommitment = (SYSINF_PAGE_COUNT)MmPeakCommitment;

            {

                ULONG PageFaultCount = 0;
                ULONG CopyOnWriteCount = 0;
                ULONG TransitionCount = 0;
                ULONG CacheTransitionCount = 0;
                ULONG DemandZeroCount = 0;
                ULONG PageReadCount = 0;
                ULONG PageReadIoCount = 0;
                ULONG CacheReadCount = 0;
                ULONG CacheIoCount = 0;
                ULONG DirtyPagesWriteCount = 0;
                ULONG DirtyWriteIoCount = 0;
                ULONG MappedPagesWriteCount = 0;
                ULONG MappedWriteIoCount = 0;

                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        PageFaultCount += Prcb->MmPageFaultCount;
                        CopyOnWriteCount += Prcb->MmCopyOnWriteCount;
                        TransitionCount += Prcb->MmTransitionCount;
                        CacheTransitionCount += Prcb->MmCacheTransitionCount;
                        DemandZeroCount += Prcb->MmDemandZeroCount;
                        PageReadCount += Prcb->MmPageReadCount;
                        PageReadIoCount += Prcb->MmPageReadIoCount;
                        CacheReadCount += Prcb->MmCacheReadCount;
                        CacheIoCount += Prcb->MmCacheIoCount;
                        DirtyPagesWriteCount += Prcb->MmDirtyPagesWriteCount;
                        DirtyWriteIoCount += Prcb->MmDirtyWriteIoCount;
                        MappedPagesWriteCount += Prcb->MmMappedPagesWriteCount;
                        MappedWriteIoCount += Prcb->MmMappedWriteIoCount;
                    }
                }

                LocalPerformanceInfo.PageFaultCount = PageFaultCount;
                LocalPerformanceInfo.CopyOnWriteCount = CopyOnWriteCount;
                LocalPerformanceInfo.TransitionCount = TransitionCount;
                LocalPerformanceInfo.CacheTransitionCount = CacheTransitionCount;
                LocalPerformanceInfo.DemandZeroCount = DemandZeroCount;
                LocalPerformanceInfo.PageReadCount = PageReadCount;
                LocalPerformanceInfo.PageReadIoCount = PageReadIoCount;
                LocalPerformanceInfo.CacheReadCount = CacheReadCount;
                LocalPerformanceInfo.CacheIoCount = CacheIoCount;
                LocalPerformanceInfo.DirtyPagesWriteCount = DirtyPagesWriteCount;
                LocalPerformanceInfo.DirtyWriteIoCount = DirtyWriteIoCount;
                LocalPerformanceInfo.MappedPagesWriteCount = MappedPagesWriteCount;
                LocalPerformanceInfo.MappedWriteIoCount = MappedWriteIoCount;
            }

            LocalPerformanceInfo.FreeSystemPtes = MmGetNumberOfFreeSystemPtes ();
            LocalPerformanceInfo.ResidentSystemCodePage = MmSystemCodePage;
            LocalPerformanceInfo.ResidentSystemCachePage = MmSystemCachePage;
            LocalPerformanceInfo.ResidentPagedPoolPage = MmPagedPoolPage;
            LocalPerformanceInfo.ResidentSystemDriverPage = MmSystemDriverPage;
            LocalPerformanceInfo.TotalSystemCodePages = MmTotalSystemCodePages;
            LocalPerformanceInfo.TotalSystemDriverPages = MmTotalSystemDriverPages;
            LocalPerformanceInfo.AvailablePagedPoolPages = (ULONG)MmAvailablePoolInPages (PagedPool);

            //
            // Idle process information.
            //

            {
                ULONG TotalKernel;
                ULONG TotalUser;

                TotalKernel = KeQueryRuntimeProcess(&PsIdleProcess->Pcb,
                                                    &TotalUser);

                LocalPerformanceInfo.IdleProcessTime.QuadPart =
                                UInt32x32To64(TotalKernel, KeMaximumIncrement);
            }

            //
            // Pool information.
            //

            LocalPerformanceInfo.PagedPoolPages = 0;
            LocalPerformanceInfo.NonPagedPoolPages = 0;
            LocalPerformanceInfo.PagedPoolAllocs = 0;
            LocalPerformanceInfo.PagedPoolFrees = 0;
            LocalPerformanceInfo.PagedPoolLookasideHits = 0;
            LocalPerformanceInfo.NonPagedPoolAllocs = 0;
            LocalPerformanceInfo.NonPagedPoolFrees = 0;
            LocalPerformanceInfo.NonPagedPoolLookasideHits = 0;
            ExQueryPoolUsage( &LocalPerformanceInfo.PagedPoolPages,
                              &LocalPerformanceInfo.NonPagedPoolPages,
                              &LocalPerformanceInfo.PagedPoolAllocs,
                              &LocalPerformanceInfo.PagedPoolFrees,
                              &LocalPerformanceInfo.PagedPoolLookasideHits,
                              &LocalPerformanceInfo.NonPagedPoolAllocs,
                              &LocalPerformanceInfo.NonPagedPoolFrees,
                              &LocalPerformanceInfo.NonPagedPoolLookasideHits
                            );

            //
            // Cache Manager information.
            //

            LocalPerformanceInfo.CcFastReadNoWait = CcFastReadNoWait;
            LocalPerformanceInfo.CcFastReadWait = CcFastReadWait;
            LocalPerformanceInfo.CcFastReadResourceMiss = CcFastReadResourceMiss;
            LocalPerformanceInfo.CcFastReadNotPossible = CcFastReadNotPossible;
            LocalPerformanceInfo.CcFastMdlReadNoWait = CcFastMdlReadNoWait;
            LocalPerformanceInfo.CcFastMdlReadWait = CcFastMdlReadWait;
            LocalPerformanceInfo.CcFastMdlReadResourceMiss = CcFastMdlReadResourceMiss;
            LocalPerformanceInfo.CcFastMdlReadNotPossible = CcFastMdlReadNotPossible;
            LocalPerformanceInfo.CcMapDataNoWait = CcMapDataNoWait;
            LocalPerformanceInfo.CcMapDataWait = CcMapDataWait;
            LocalPerformanceInfo.CcMapDataNoWaitMiss = CcMapDataNoWaitMiss;
            LocalPerformanceInfo.CcMapDataWaitMiss = CcMapDataWaitMiss;
            LocalPerformanceInfo.CcPinMappedDataCount = CcPinMappedDataCount;
            LocalPerformanceInfo.CcPinReadNoWait = CcPinReadNoWait;
            LocalPerformanceInfo.CcPinReadWait = CcPinReadWait;
            LocalPerformanceInfo.CcPinReadNoWaitMiss = CcPinReadNoWaitMiss;
            LocalPerformanceInfo.CcPinReadWaitMiss = CcPinReadWaitMiss;
            LocalPerformanceInfo.CcCopyReadNoWait = CcCopyReadNoWait;
            LocalPerformanceInfo.CcCopyReadWait = CcCopyReadWait;
            LocalPerformanceInfo.CcCopyReadNoWaitMiss = CcCopyReadNoWaitMiss;
            LocalPerformanceInfo.CcCopyReadWaitMiss = CcCopyReadWaitMiss;
            LocalPerformanceInfo.CcMdlReadNoWait = CcMdlReadNoWait;
            LocalPerformanceInfo.CcMdlReadWait = CcMdlReadWait;
            LocalPerformanceInfo.CcMdlReadNoWaitMiss = CcMdlReadNoWaitMiss;
            LocalPerformanceInfo.CcMdlReadWaitMiss = CcMdlReadWaitMiss;
            LocalPerformanceInfo.CcReadAheadIos = CcReadAheadIos;
            LocalPerformanceInfo.CcLazyWriteIos = CcLazyWriteIos;
            LocalPerformanceInfo.CcLazyWritePages = CcLazyWritePages;
            LocalPerformanceInfo.CcDataFlushes = CcDataFlushes;
            LocalPerformanceInfo.CcDataPages = CcDataPages;

#if !defined(NT_UP)
            //
            // On an MP machines go sum up some other 'hot' cache manager
            // statistics.
            //

            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];

                LocalPerformanceInfo.CcFastReadNoWait += Prcb->CcFastReadNoWait;
                LocalPerformanceInfo.CcFastReadWait += Prcb->CcFastReadWait;
                LocalPerformanceInfo.CcFastReadNotPossible += Prcb->CcFastReadNotPossible;
                LocalPerformanceInfo.CcCopyReadNoWait += Prcb->CcCopyReadNoWait;
                LocalPerformanceInfo.CcCopyReadWait += Prcb->CcCopyReadWait;
                LocalPerformanceInfo.CcCopyReadNoWaitMiss += Prcb->CcCopyReadNoWaitMiss;
            }
#endif
            *PerformanceInfo = LocalPerformanceInfo;
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(LocalPerformanceInfo);
            }

            break;

        case SystemProcessorPerformanceInformation:
            if (SystemInformationLength <
                sizeof( SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ProcessorPerformanceInfo =
                (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) SystemInformation;

            Length = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    if (SystemInformationLength < Length + sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION))
                        break;

                    Length += sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

                    ProcessorPerformanceInfo->UserTime.QuadPart =
                                                UInt32x32To64(Prcb->UserTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->KernelTime.QuadPart =
                                                UInt32x32To64(Prcb->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->DpcTime.QuadPart =
                                                UInt32x32To64(Prcb->DpcTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptTime.QuadPart =
                                                UInt32x32To64(Prcb->InterruptTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->IdleTime.QuadPart =
                                                UInt32x32To64(Prcb->IdleThread->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptCount = Prcb->InterruptCount;

                    ProcessorPerformanceInfo++;
                }
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemProcessorPowerInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_POWER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetProcessorPowerInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemProcessorIdleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_IDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetProcessorIdleInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemTimeOfDayInformation:
            if (SystemInformationLength > sizeof (SYSTEM_TIMEOFDAY_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlZeroMemory (&LocalTimeOfDayInfo, sizeof(LocalTimeOfDayInfo));
            KeQuerySystemTime(&LocalTimeOfDayInfo.CurrentTime);
            LocalTimeOfDayInfo.BootTime = KeBootTime;
            LocalTimeOfDayInfo.TimeZoneBias = ExpTimeZoneBias;
            LocalTimeOfDayInfo.TimeZoneId = ExpCurrentTimeZoneId;
            LocalTimeOfDayInfo.BootTimeBias = KeBootTimeBias;
            LocalTimeOfDayInfo.SleepTimeBias = KeInterruptTimeBias;

            try {
                RtlCopyMemory (
                    SystemInformation,
                    &LocalTimeOfDayInfo,
                    SystemInformationLength
                    );

                if (ARGUMENT_PRESENT(ReturnLength) ) {
                    *ReturnLength = SystemInformationLength;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }

            break;

            //
            // Query system time adjustment information.
            //

        case SystemTimeAdjustmentInformation:
            if (SystemInformationLength != sizeof( SYSTEM_QUERY_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TimeAdjustmentInformation =
                    (PSYSTEM_QUERY_TIME_ADJUST_INFORMATION)SystemInformation;

            TimeAdjustmentInformation->TimeAdjustment = KeTimeAdjustment;
            TimeAdjustmentInformation->TimeIncrement = KeMaximumIncrement;
            TimeAdjustmentInformation->Enable = KeTimeSynchronization;
            break;

        case SystemSummaryMemoryInformation:
        case SystemFullMemoryInformation:

            if (SystemInformationLength < sizeof( SYSTEM_MEMORY_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmMemoryUsage (SystemInformation,
                                    SystemInformationLength,
             (SystemInformationClass == SystemFullMemoryInformation) ? 0 : 1,
                                    &Length);

            if (NT_SUCCESS(Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPathInformation:
#if DBG
            DbgPrint( "EX: SystemPathInformation now available via SharedUserData\n" );
            DbgBreakPoint();
#endif
            return STATUS_NOT_IMPLEMENTED;
            break;

        case SystemProcessInformation:
        case SystemExtendedProcessInformation:
            {
                BOOLEAN ExtendedInformation;

                if (SystemInformationClass == SystemProcessInformation ) {
                    ExtendedInformation = FALSE;
                } else {
                    ExtendedInformation = TRUE;
                }

                Status = ExpGetProcessInformation (SystemInformation,
                                               SystemInformationLength,
                                               ReturnLength,
                                               NULL,
                                               ExtendedInformation);
            }

            break;

        case SystemSessionProcessInformation:


            SessionProcessInformation =
                        (PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_PROCESS_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            //
            // The lower level locks the buffer specified below into memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //
            SessionId = SessionProcessInformation->SessionId;
            ProcessInformation = SessionProcessInformation->Buffer;
            ProcessInformationLength = SessionProcessInformation->SizeOfBuf;

            if (!POINTER_IS_ALIGNED (ProcessInformation, sizeof (ULONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetProcessInformation (ProcessInformation,
                                               ProcessInformationLength,
                                               ReturnLength,
                                               &SessionId,
                                               FALSE);
            break;

        case SystemCallCountInformation:

            Length = sizeof(SYSTEM_CALL_COUNT_INFORMATION) +
                        (NUMBER_SERVICE_TABLES * sizeof(ULONG));

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit != 0) && (Table->Count != NULL)) {
                    Length += Table->Limit * sizeof(ULONG);
                }
                Table += 1;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            if (SystemInformationLength < Length) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            CallCountInformation = (PSYSTEM_CALL_COUNT_INFORMATION)SystemInformation;
            CallCountInformation->Length = Length;
            CallCountInformation->NumberOfTables = NUMBER_SERVICE_TABLES;

            TableLimit = (PULONG)(CallCountInformation + 1);
            TableCounts = TableLimit + NUMBER_SERVICE_TABLES;

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit == 0) || (Table->Count == NULL)) {
                    *TableLimit++ = 0;
                } else {
                    *TableLimit++ = Table->Limit;
                    RtlCopyMemory((PVOID)TableCounts,
                                  (PVOID)Table->Count,
                                  Table->Limit * sizeof(ULONG));
                    TableCounts += Table->Limit;
                }
                Table += 1;
            }

            break;

        case SystemDeviceInformation:
            if (SystemInformationLength != sizeof( SYSTEM_DEVICE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ConfigInfo = IoGetConfigurationInformation();
            DeviceInformation = (PSYSTEM_DEVICE_INFORMATION)SystemInformation;
            DeviceInformation->NumberOfDisks = ConfigInfo->DiskCount;
            DeviceInformation->NumberOfFloppies = ConfigInfo->FloppyCount;
            DeviceInformation->NumberOfCdRoms = ConfigInfo->CdRomCount;
            DeviceInformation->NumberOfTapes = ConfigInfo->TapeCount;
            DeviceInformation->NumberOfSerialPorts = ConfigInfo->SerialCount;
            DeviceInformation->NumberOfParallelPorts = ConfigInfo->ParallelCount;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_DEVICE_INFORMATION );
            }
            break;

        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_FLAGS_INFORMATION );
            }
            break;

        case SystemCallTimeInformation:
            return STATUS_NOT_IMPLEMENTED;

        case SystemModuleInformation:
            KeEnterCriticalRegion();
            ExAcquireResourceExclusiveLite( &PsLoadedModuleResource, TRUE );
            try {
                Status = ExpQueryModuleInformation( &PsLoadedModuleList,
                                                    &MmLoadedUserImageList,
                                                    (PRTL_PROCESS_MODULES)SystemInformation,
                                                    SystemInformationLength,
                                                    ReturnLength
                                                );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
            ExReleaseResourceLite (&PsLoadedModuleResource);
            KeLeaveCriticalRegion();
            break;

        case SystemLocksInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_LOCKS )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetLockInformation (SystemInformation,
                                            SystemInformationLength,
                                            &Length);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemStackTraceInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_BACKTRACES )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if i386
            Status = ExpGetStackTraceInformation (SystemInformation,
                                                  SystemInformationLength,
                                                  &Length);
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif // i386

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemPagedPoolInformation:

            Status = STATUS_NOT_IMPLEMENTED;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = 0;
            }
            break;

        case SystemNonPagedPoolInformation:

            Status = STATUS_NOT_IMPLEMENTED;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = 0;
            }
            break;

        case SystemHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemExtendedHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION_EX )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION_EX))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformationEx( SystemInformation,
                                                SystemInformationLength,
                                                &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemObjectInformation:
            if (SystemInformationLength < sizeof( SYSTEM_OBJECTTYPE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetObjectInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPageFileInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PAGEFILE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetPageFileInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;


        case SystemFileCacheInformation:
        case SystemFileCacheInformationEx:

            {

            SYSTEM_FILECACHE_INFORMATION CapturedFileCacheInformation;

            //
            // This structure was extended in NT 4.0 from 12 bytes.
            // Use the previous size of 12 bytes for versioning info.
            //

            if (SystemInformationLength < 12) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            MmQuerySystemCacheWorkingSetInformation (&CapturedFileCacheInformation);

            FileCache = (PSYSTEM_FILECACHE_INFORMATION)SystemInformation;
            FileCache->CurrentSize = CapturedFileCacheInformation.CurrentSize;
            FileCache->PeakSize = CapturedFileCacheInformation.PeakSize;
            FileCache->PageFaultCount = CapturedFileCacheInformation.PageFaultCount;

            i = 12;

            if (SystemInformationLength >= sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                i = sizeof (SYSTEM_FILECACHE_INFORMATION);
                FileCache->MinimumWorkingSet =
                            CapturedFileCacheInformation.MinimumWorkingSet;
                FileCache->MaximumWorkingSet =
                            CapturedFileCacheInformation.MaximumWorkingSet;
                FileCache->CurrentSizeIncludingTransitionInPages =
                    CapturedFileCacheInformation.CurrentSizeIncludingTransitionInPages;
                FileCache->PeakSizeIncludingTransitionInPages =
                    CapturedFileCacheInformation.PeakSizeIncludingTransitionInPages;
                FileCache->TransitionRePurposeCount =
                    CapturedFileCacheInformation.TransitionRePurposeCount;

                FileCache->Flags = CapturedFileCacheInformation.Flags;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = i;
            }
            break;

            }

        case SystemSessionPoolTagInformation:

            SessionProcessInformation =
                        (PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_PROCESS_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // The lower level locks the buffer specified below into
            // memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //

            SessionId = SessionProcessInformation->SessionId;
            SessionPoolTagInformation = SessionProcessInformation->Buffer;
            SessionPoolTagInformationLength = SessionProcessInformation->SizeOfBuf;

            if (!POINTER_IS_ALIGNED (SessionPoolTagInformation, sizeof (ULONGLONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExGetSessionPoolTagInformation (
                                            SessionPoolTagInformation,
                                            SessionPoolTagInformationLength,
                                            &Length,
                                            &SessionId);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemPoolTagInformation:

            if (SystemInformationLength < sizeof( SYSTEM_POOLTAG_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExGetPoolTagInfo (SystemInformation,
                                       SystemInformationLength,
                                       ReturnLength);

            break;

        case SystemBigPoolInformation:

            if (SystemInformationLength < sizeof( SYSTEM_BIGPOOL_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExGetBigPoolInfo (SystemInformation,
                                       SystemInformationLength,
                                       ReturnLength);

            break;

        case SystemSessionMappedViewInformation:

            SessionMappedViewInformation =
                        (PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_MAPPED_VIEW_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // The lower level locks the buffer specified below into
            // memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //

            SessionId = SessionMappedViewInformation->SessionId;

            if (!POINTER_IS_ALIGNED (SessionMappedViewInformation, sizeof (ULONGLONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = MmGetSessionMappedViewInformation (
                                            SessionMappedViewInformation,
                                            SystemInformationLength,
                                            &Length,
                                            &SessionId);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemVdmInstemulInformation:
#ifdef i386
            if (SystemInformationLength < sizeof( SYSTEM_VDM_INSTEMUL_INFO )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetInstemulInformation(
                                            (PSYSTEM_VDM_INSTEMUL_INFO)SystemInformation
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_VDM_INSTEMUL_INFO);
            }
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif
            break;

            //
            // Get system exception information which includes the number
            // of exceptions that have dispatched, the number of alignment
            // fixups, and the number of floating emulations that have been
            // performed.
            //

        case SystemExceptionInformation:
            if (SystemInformationLength < sizeof( SYSTEM_EXCEPTION_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_EXCEPTION_INFORMATION);
            }

            ExceptionInformation = (PSYSTEM_EXCEPTION_INFORMATION)SystemInformation;

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG AlignmentFixupCount = 0;
                ULONG ExceptionDispatchCount = 0;
                ULONG FloatingEmulationCount = 0;
                ULONG ByteWordEmulationCount = 0;

                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        AlignmentFixupCount += Prcb->KeAlignmentFixupCount;
                        ExceptionDispatchCount += Prcb->KeExceptionDispatchCount;
                        FloatingEmulationCount += Prcb->KeFloatingEmulationCount;
                    }
                }

                ExceptionInformation->AlignmentFixupCount = AlignmentFixupCount;
                ExceptionInformation->ExceptionDispatchCount = ExceptionDispatchCount;
                ExceptionInformation->FloatingEmulationCount = FloatingEmulationCount;
                ExceptionInformation->ByteWordEmulationCount = ByteWordEmulationCount;
            }

            break;

        case SystemKernelDebuggerInformation:

            if (SystemInformationLength < sizeof( SYSTEM_KERNEL_DEBUGGER_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KernelDebuggerInformation =
                (PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation;
            KernelDebuggerInformation->KernelDebuggerEnabled = KdDebuggerEnabled;
            KernelDebuggerInformation->KernelDebuggerNotPresent = KdDebuggerNotPresent;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION);
            }

            break;

        case SystemContextSwitchInformation:

            if (SystemInformationLength < sizeof( SYSTEM_CONTEXT_SWITCH_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ContextSwitchInformation =
                (PSYSTEM_CONTEXT_SWITCH_INFORMATION)SystemInformation;

            //
            // Compute the total number of context switches and fill in the
            // remainder of the context switch information.
            //

            ContextSwitches = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    ContextSwitches += KeGetContextSwitches(Prcb);
                }

            }

            ContextSwitchInformation->ContextSwitches = ContextSwitches;
            ContextSwitchInformation->FindAny = KeThreadSwitchCounters.FindAny;
            ContextSwitchInformation->FindLast = KeThreadSwitchCounters.FindLast;
            ContextSwitchInformation->FindIdeal = KeThreadSwitchCounters.FindIdeal;
            ContextSwitchInformation->IdleAny = KeThreadSwitchCounters.IdleAny;
            ContextSwitchInformation->IdleCurrent = KeThreadSwitchCounters.IdleCurrent;
            ContextSwitchInformation->IdleLast = KeThreadSwitchCounters.IdleLast;
            ContextSwitchInformation->IdleIdeal = KeThreadSwitchCounters.IdleIdeal;
            ContextSwitchInformation->PreemptAny = KeThreadSwitchCounters.PreemptAny;
            ContextSwitchInformation->PreemptCurrent = KeThreadSwitchCounters.PreemptCurrent;
            ContextSwitchInformation->PreemptLast = KeThreadSwitchCounters.PreemptLast;
            ContextSwitchInformation->SwitchToIdle = KeThreadSwitchCounters.SwitchToIdle;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION);
            }

            break;

        case SystemRegistryQuotaInformation:

            if (SystemInformationLength < sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            CmQueryRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_REGISTRY_QUOTA_INFORMATION);
            }
            break;

        case SystemDpcBehaviorInformation:
            {
                PSYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                DpcInfo = (PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Exception handler for this routine will return the correct
                // error if any of these accesses fail.
                //
                //
                // Return the current DPC behavior variables
                //
                DpcInfo->DpcQueueDepth = KiMaximumDpcQueueDepth;
                DpcInfo->MinimumDpcRate = KiMinimumDpcRate;
                DpcInfo->AdjustDpcThreshold = KiAdjustDpcThreshold;
                DpcInfo->IdealDpcRate = KiIdealDpcRate;
            }
            break;

        case SystemInterruptInformation:

            if (SystemInformationLength < (sizeof(SYSTEM_INTERRUPT_INFORMATION) * KeNumberProcessors)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            InterruptInformation = (PSYSTEM_INTERRUPT_INFORMATION)SystemInformation;
            for (i=0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                InterruptInformation->ContextSwitches = KeGetContextSwitches(Prcb);
                InterruptInformation->DpcCount = Prcb->DpcData[DPC_NORMAL].DpcCount;
                InterruptInformation->DpcRate = Prcb->DpcRequestRate;
                InterruptInformation->TimeIncrement = KeTimeIncrement;
                InterruptInformation->DpcBypassCount = 0;
                InterruptInformation->ApcBypassCount = 0;

                ++InterruptInformation;
            }

            break;

        case SystemCurrentTimeZoneInformation:
            if (SystemInformationLength < sizeof( RTL_TIME_ZONE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlCopyMemory(SystemInformation,&ExpTimeZoneInformation,sizeof(ExpTimeZoneInformation));
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( RTL_TIME_ZONE_INFORMATION );
            }

            Status = STATUS_SUCCESS;
            break;

            //
            // Query pool lookaside list and general lookaside list
            // information.
            //

        case SystemLookasideInformation:
            Status = ExpGetLookasideInformation(SystemInformation,
                                                SystemInformationLength,
                                                &Length);

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemRangeStartInformation:

            if ( SystemInformationLength != sizeof(ULONG_PTR) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PULONG_PTR)SystemInformation = (ULONG_PTR)MmSystemRangeStart;

            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(ULONG_PTR);
            }

            break;

        case SystemVerifierInformation:

            if (SystemInformationLength < sizeof( SYSTEM_VERIFIER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetVerifierInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemLegacyDriverInformation:
            if (SystemInformationLength < sizeof(SYSTEM_LEGACY_DRIVER_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            Length = SystemInformationLength;
            Status = ExpQueryLegacyDriverInformation((PSYSTEM_LEGACY_DRIVER_INFORMATION)SystemInformation, &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemPerformanceTraceInformation:
            Status = STATUS_INVALID_INFO_CLASS;
            break;

        case SystemPrefetcherInformation:

            Status = CcPfQueryPrefetcherInformation(SystemInformationClass,
                                                    SystemInformation,
                                                    SystemInformationLength,
                                                    PreviousMode,
                                                    &Length
                                                    );

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemNumaProcessorMap:

            Status = ExpQueryNumaProcessorMap(SystemInformation,
                                              SystemInformationLength,
                                              &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemNumaAvailableMemory:

            Status = ExpQueryNumaAvailableMemory(SystemInformation,
                                                 SystemInformationLength,
                                                 &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemRecommendedSharedDataAlignment:
            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            //
            // Alignment is guaranteed by the ProbeForWrite above
            // so just store the value as a ULONG.
            //

            *(PULONG)SystemInformation = KeGetRecommendedSharedDataAlignment();
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemComPlusPackage:
            if (SystemInformationLength != sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            if (SharedUserData->ComPlusPackage == COMPLUS_PACKAGE_INVALID) {

                //
                // The initialization happens one time.
                //
                SharedUserData->ComPlusPackage = 0;

                ExpReadComPlusPackage ();
            }

            *(PULONG)SystemInformation = SharedUserData->ComPlusPackage;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemLostDelayedWriteInformation:

            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            *(PULONG)SystemInformation = CcLostDelayedWrites;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemObjectSecurityMode:

            if (SystemInformationLength != sizeof (ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PULONG)SystemInformation = ObGetSecurityMode ();

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }

            break;

        case SystemWatchdogTimerInformation:

            {
                PSYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                if (ExpWdHandler == NULL) {

                    Status = STATUS_NOT_IMPLEMENTED;

                } else {

                    switch (WdTimerInfo->WdInfoClass) {
                        case WdInfoTimeoutValue:
                            Status = ExpWdHandler( WdActionQueryTimeoutValue, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoTriggerAction:
                            Status = ExpWdHandler( WdActionQueryTriggerAction, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoState:
                            Status = ExpWdHandler( WdActionQueryState, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        default:
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                    }
                }
            }

            break;

        case SystemLogicalProcessorInformation:

            Status = KeQueryLogicalProcessorInformation(
                         SystemInformation,
                         SystemInformationLength,
                         &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemFirmwareTableInformation:
 
            if (SystemInformationLength < sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION)) {

                return STATUS_INFO_LENGTH_MISMATCH;
            }
           
            Status = ExpGetSystemFirmwareTableInformation(SystemInformation,
                                                          PreviousMode, 
                                                          ReturnLength);

            break;

        default:

            //
            // Invalid argument.
            //

            return STATUS_INVALID_INFO_CLASS;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NTAPI
NtSetSystemInformation (
    __in SYSTEM_INFORMATION_CLASS SystemInformationClass,
    __in_bcount_opt(SystemInformationLength) PVOID SystemInformation,
    __in ULONG SystemInformationLength
    )

/*++

Routine Description:

    This function set information about the system.

Arguments:

    SystemInformationClass - The system information class which is to
        be modified.

    SystemInformation - A pointer to a buffer which contains the specified
        information. The format and content of the buffer depend on the
        specified system information class.


    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The specified system information buffer
            is not accessible.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
            privilege to set the system time.

--*/

{

    BOOLEAN Enable;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG TimeAdjustment;
    PSYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    HANDLE EventHandle;
    PVOID Event;
    ULONG LoadFlags = MM_LOAD_IMAGE_IN_SESSION;

    PAGED_CODE();

    //
    // Establish an exception handle in case the system information buffer
    // is not accessible.
    //

    Status = STATUS_SUCCESS;

    try {

        //
        // Get the previous processor mode and probe the input buffer for
        // read access if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForRead((PVOID)SystemInformation,
                         SystemInformationLength,
                         sizeof(ULONG));
        }

        //
        // Dispatch on the system information class.
        //

        switch (SystemInformationClass) {
        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }
            else {
                ULONG Flags;

                Flags = ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags &
                         ~(FLG_KERNELMODE_VALID_BITS | FLG_BOOTONLY_VALID_BITS);
                Flags |= NtGlobalFlag & (FLG_KERNELMODE_VALID_BITS | FLG_BOOTONLY_VALID_BITS);
                NtGlobalFlag = Flags;
                ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;
            }
            break;

            //
            // Set system time adjustment information.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //

        case SystemTimeAdjustmentInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_SET_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set system time adjustment parameters.
            //

            TimeAdjustmentInformation =
                    (PSYSTEM_SET_TIME_ADJUST_INFORMATION)SystemInformation;

            Enable = TimeAdjustmentInformation->Enable;
            TimeAdjustment = TimeAdjustmentInformation->TimeAdjustment;

            if (Enable == TRUE) {
                KeTimeAdjustment = KeMaximumIncrement;
            } else {
                if (TimeAdjustment == 0) {
                    return STATUS_INVALID_PARAMETER_2;
                }
                KeTimeAdjustment = TimeAdjustment;
            }

            KeTimeSynchronization = Enable;
            break;

            //
            // Set an event to signal when the clock interrupt has been
            // masked for too long, causing the time to slip.
            // The event will be referenced to prevent it from being
            // deleted.  If the new event handle is valid or NULL, the
            // old event will be dereferenced and forgotten.  If the
            // event handle is non-NULL but invalid, the old event will
            // be remembered and a failure status will be returned.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //
        case SystemTimeSlipNotification:

            if (SystemInformationLength != sizeof(HANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            EventHandle = *(PHANDLE)SystemInformation;

            if (EventHandle == NULL) {

                //
                // Dereference the old event and don't signal anything
                // for time slips.
                //

                Event = NULL;
                Status = STATUS_SUCCESS;

            } else {

                Status = ObReferenceObjectByHandle(EventHandle,
                                                   EVENT_MODIFY_STATE,
                                                   ExEventObjectType,
                                                   PreviousMode,
                                                   &Event,
                                                   NULL);
            }

            if (NT_SUCCESS(Status)) {
                KdUpdateTimeSlipEvent(Event);
            }

            break;

            //
            // Set registry quota limit.
            //
            // N.B. The caller must have SeIncreaseQuotaPrivilege
            //
        case SystemRegistryQuotaInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to create
            // a pagefile, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeIncreaseQuotaPrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set registry quota parameters.
            //
            CmSetRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            break;

        case SystemPrioritySeperation:
            {
                ULONG PrioritySeparation;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof (ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                try {
                    PrioritySeparation = *(PULONG)SystemInformation;
                }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    return GetExceptionCode();
                }

                PsChangeQuantumTable (TRUE, PrioritySeparation);
                Status = STATUS_SUCCESS;
            }
            break;

            //
            // N.B. If this function is called from user mode it can only be
            //      used to load the win32k subsystem. The calling process
            //      must be smss, the subsystem to be loaded must be win32k,
            //      and the caller must have the privilege to load drivers.
            //      If this function is called from kernel mode it can be
            //      used to load any driver.
            //

        case SystemExtendServiceTableInformation:
            {

                ULONG_PTR EntryPoint;
                UNICODE_STRING Image;
                PVOID ImageBaseAddress;
                PDRIVER_INITIALIZE InitRoutine;
                PIMAGE_NT_HEADERS NtHeaders;
                PVOID SectionPointer;
                DRIVER_OBJECT Win32KDevice;

                //
                // Check if the system information buffer is the correct
                // length.
                //

                if (SystemInformationLength != sizeof(UNICODE_STRING)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                //
                // If the previous mode is not kernel, then verify that the
                // caller can load the win32k subsystem.
                //

                if (PreviousMode != KernelMode) {

                    //
                    // Check if the caller is the session leader on the system.
                    //

                    if (MmIsSessionLeaderProcess(PsGetCurrentProcess()) == FALSE) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    //
                    // Check if the caller has the privilege to load drivers.
                    //

                    if (SeSinglePrivilegeCheck(SeLoadDriverPrivilege, UserMode) == FALSE) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    //
                    // Check if the win32k susbsystem is being loaded.
                    //

                    try {

                        //
                        // Probe and read the unicode string descriptor.
                        //

                        ProbeAndReadUnicodeStringEx(&Image,
                                                    (PUNICODE_STRING)SystemInformation);

                        //
                        // Check if the unicode string is the correct length.
                        //

                        if (Image.Length != WIN32K_PATH_SIZE) {
                            return STATUS_PRIVILEGE_NOT_HELD;
                        }

                        //
                        // Probe the unicode string buffer and check the path
                        // name.
                        //

                        ProbeForReadSmallStructure(Image.Buffer,
                                                   WIN32K_PATH_SIZE,
                                                   sizeof(UCHAR));

                        if (memcmp(Image.Buffer, &Win32kFullPath[0], WIN32K_PATH_SIZE) != 0) {
                            return STATUS_PRIVILEGE_NOT_HELD;
                        }
    
                        //
                        // Initialize string descriptor for win32k full
                        // path name.
                        //

                        Image.Buffer = &Win32kFullPath[0];
                        Image.MaximumLength = WIN32K_PATH_SIZE;

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }

                    //
                    // Recursively call this kernel service forcing previous
                    // mode to kernel.
                    //

                    Status = ZwSetSystemInformation(SystemExtendServiceTableInformation,
                                                    (PVOID)&Image,
                                                    sizeof(Image));

                    return Status;
                }

                //
                // The previous mode is kernel - load the specified driver.
                //

                Image = *(PUNICODE_STRING)SystemInformation;
                Status = MmLoadSystemImage(&Image,
                                           NULL,
                                           NULL,
                                           MM_LOAD_IMAGE_IN_SESSION,
                                           &SectionPointer,
                                           (PVOID *)&ImageBaseAddress);

                if (NT_SUCCESS(Status) == FALSE) {
                    return Status;
                }

                //
                // Get the image base address.
                //

                NtHeaders = RtlImageNtHeader(ImageBaseAddress);
                if (NtHeaders == NULL) {
                    MmUnloadSystemImage(SectionPointer);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }

                //
                // Extract the initialization routine address and call the
                // driver initialization routine.
                //

                EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                EntryPoint += (ULONG_PTR)ImageBaseAddress;
                InitRoutine = (PDRIVER_INITIALIZE)EntryPoint;
                RtlZeroMemory(&Win32KDevice, sizeof(Win32KDevice));

                ASSERT(KeGetCurrentIrql() == 0);

                Win32KDevice.DriverStart = (PVOID)ImageBaseAddress;
                Status = (InitRoutine)(&Win32KDevice, NULL);

                ASSERT(KeGetCurrentIrql() == 0);

                //
                // If the image initialization was unsuccessful, then unload
                // the system image. Otherwise, set the system image unload
                // address so the session can be unloaded cleanly.
                //

                if (NT_SUCCESS(Status) == FALSE) {
                    MmUnloadSystemImage(SectionPointer);

                } else {
                    MmSessionSetUnloadAddress(&Win32KDevice);
                }
            }

            break;

        case SystemUnloadGdiDriverInformation:
            {

                if (SystemInformationLength != sizeof( PVOID ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;

                }

                MmUnloadSystemImage( *((PVOID *)SystemInformation) );

                Status = STATUS_SUCCESS;

            }
            break;

        case SystemLoadGdiDriverInSystemSpace:
            {
                LoadFlags &= ~MM_LOAD_IMAGE_IN_SESSION;
                //
                // Fall through
                //
            }

        case SystemLoadGdiDriverInformation:
            {

                UNICODE_STRING Image;
                PVOID ImageBaseAddress;
                ULONG_PTR EntryPoint;
                PVOID SectionPointer;

                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( SYSTEM_GDI_DRIVER_INFORMATION ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                Image = ((PSYSTEM_GDI_DRIVER_INFORMATION)SystemInformation)->DriverName;

                Status = MmLoadSystemImage (&Image,
                                            NULL,
                                            NULL,
                                            LoadFlags,
                                            &SectionPointer,
                                            (PVOID *) &ImageBaseAddress);


                if ((NT_SUCCESS( Status ))) {

                    PSYSTEM_GDI_DRIVER_INFORMATION GdiDriverInfo =
                        (PSYSTEM_GDI_DRIVER_INFORMATION) SystemInformation;

                    ULONG Size;

                    GdiDriverInfo->ExportSectionPointer =
                        RtlImageDirectoryEntryToData(ImageBaseAddress,
                                                     TRUE,
                                                     IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                     &Size);

                    //
                    // Capture the entry point.
                    //

                    NtHeaders = RtlImageNtHeader( ImageBaseAddress );
                    EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                    EntryPoint += (ULONG_PTR) ImageBaseAddress;

                    GdiDriverInfo->ImageAddress = (PVOID) ImageBaseAddress;
                    GdiDriverInfo->SectionPointer = SectionPointer;
                    GdiDriverInfo->EntryPoint = (PVOID) EntryPoint;
                    GdiDriverInfo->ImageLength = NtHeaders->OptionalHeader.SizeOfImage;
                }
            }
            break;


        case SystemFileCacheInformation:
        case SystemFileCacheInformationEx:

            {

            BOOLEAN IncreasePerformed;
            ULONG Flags;

            if (SystemInformationLength < sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (SystemInformationClass == SystemFileCacheInformation) {
                Flags = 0;
            }
            else {

                //
                // Obtain the callers flags and validate it - don't allow
                // any reserved bits to be set or any conflicting bits to
                // be set.
                //

                Flags = ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->Flags;
                if (Flags & ~(MM_WORKING_SET_MAX_HARD_ENABLE |
                              MM_WORKING_SET_MAX_HARD_DISABLE |
                              MM_WORKING_SET_MIN_HARD_ENABLE |
                              MM_WORKING_SET_MIN_HARD_DISABLE)) {

                    return STATUS_INVALID_PARAMETER_2;
                }

                if ((Flags & (MM_WORKING_SET_MIN_HARD_ENABLE | MM_WORKING_SET_MIN_HARD_DISABLE)) == (MM_WORKING_SET_MIN_HARD_ENABLE | MM_WORKING_SET_MIN_HARD_DISABLE)) {
                    return STATUS_INVALID_PARAMETER_2;
                }

                if ((Flags & (MM_WORKING_SET_MAX_HARD_ENABLE | MM_WORKING_SET_MAX_HARD_DISABLE)) == (MM_WORKING_SET_MAX_HARD_ENABLE | MM_WORKING_SET_MAX_HARD_DISABLE)) {
                    return STATUS_INVALID_PARAMETER_2;
                }
            }

            if (!SeSinglePrivilegeCheck( SeIncreaseQuotaPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }

            return MmAdjustWorkingSetSizeEx (
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MinimumWorkingSet,
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MaximumWorkingSet,
                        TRUE,
                        TRUE,
                        Flags,
                        &IncreasePerformed);

            break;

            }

        case SystemDpcBehaviorInformation:
            {
                SYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {
                    //
                    // The caller's access mode is not kernel so check to ensure that
                    // the caller has the privilege to load a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }
                }

                //
                // Exception handler for this routine will return the correct
                // error if this access fails.
                //
                DpcInfo = *(PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Set the new DPC behavior variables
                //
                KiMaximumDpcQueueDepth = DpcInfo.DpcQueueDepth;
                KiMinimumDpcRate = DpcInfo.MinimumDpcRate;
                KiAdjustDpcThreshold = DpcInfo.AdjustDpcThreshold;
                KiIdealDpcRate = DpcInfo.IdealDpcRate;
            }
            break;

        case SystemSessionCreate:
            {

                //
                // Creation of a session space.
                //

                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck (SeLoadDriverPrivilege, PreviousMode)) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForWriteUlong((PULONG)SystemInformation);
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }

                //
                // Create a session space in the current process.
                //

                Status = MmSessionCreate (&SessionId);

                if (NT_SUCCESS(Status)) {
                    if (PreviousMode != KernelMode) {
                        try {
                            *(PULONG)SystemInformation = SessionId;
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            return GetExceptionCode();
                        }
                    }
                    else {
                        *(PULONG)SystemInformation = SessionId;
                    }
                }

                return Status;
            }
            break;

        case SystemSessionDetach:
            {
                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForRead ((PVOID)SystemInformation,
                                      sizeof(ULONG),
                                      sizeof(ULONG));

                        SessionId = *(PULONG)SystemInformation;
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }
                else {
                    SessionId = *(PULONG)SystemInformation;
                }

                //
                // Detach the current process from a session space
                // if it has one.
                //

                Status = MmSessionDelete (SessionId);

                return Status;
            }
            break;

        case SystemCrashDumpStateInformation:

            //
            // All this system information does when you set it is trigger a
            // reconfigurating of the current crashdump state based on the
            // registry.
            //
            Status = IoConfigureCrashDump(CrashDumpReconfigure);

            break;

        case SystemPerformanceTraceInformation:
            Status = STATUS_INVALID_INFO_CLASS;
            break;

        case SystemVerifierThunkExtend:

            if (PreviousMode != KernelMode) {

                //
                // The caller's access mode is not kernel so fail.
                // Only device drivers can call this.
                //

                return STATUS_PRIVILEGE_NOT_HELD;
            }

            Status = MmAddVerifierThunks (SystemInformation,
                                          SystemInformationLength);

            break;

        case SystemVerifierInformation:

            if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
                return STATUS_ACCESS_DENIED;
            }

            Status = MmSetVerifierInformation (SystemInformation,
                                               SystemInformationLength);

            break;

        case SystemVerifierAddDriverInformation:
        case SystemVerifierRemoveDriverInformation:

            {
                UNICODE_STRING Image;
                PUNICODE_STRING ImagePointer;
                PWSTR Buffer;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( UNICODE_STRING ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                Buffer = NULL;

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to ensure
                    // the caller has the privilege to add a verifier entry.
                    //

                    if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        Image = *(PUNICODE_STRING)SystemInformation;

                        //
                        // Guard against overflow.
                        //

                        if (Image.Length > Image.MaximumLength) {
                            Image.Length = Image.MaximumLength;
                        }
                        if (Image.Length == 0) {
                            return STATUS_NO_MEMORY;
                        }

                        ProbeForRead(Image.Buffer, Image.Length, sizeof(UCHAR));

                        Buffer = ExAllocatePoolWithTag(PagedPool, Image.Length, 'ofnI');
                        if ( !Buffer ) {
                            return STATUS_NO_MEMORY;
                        }

                        RtlCopyMemory(Buffer, Image.Buffer, Image.Length);
                        Image.Buffer = Buffer;
                        Image.MaximumLength = Image.Length;
                    }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        if ( Buffer ) {
                            ExFreePool(Buffer);
                        }
                        return GetExceptionCode();
                    }
                    ImagePointer = &Image;
                }
                else {
                    ImagePointer = (PUNICODE_STRING)SystemInformation;
                }

                switch (SystemInformationClass) {
                    case SystemVerifierAddDriverInformation:
                        Status = MmAddVerifierEntry (ImagePointer);
                        break;
                    case SystemVerifierRemoveDriverInformation:
                        Status = MmRemoveVerifierEntry (ImagePointer);
                        break;
                    default:
                        Status = STATUS_INVALID_INFO_CLASS;
                        break;
                }

                if (Buffer) {
                    ExFreePool(Buffer);
                }
            }

            break;

        case SystemMirrorMemoryInformation:
            Status = MmCreateMirror ();
            break;

        case SystemPrefetcherInformation:

            Status = CcPfSetPrefetcherInformation(SystemInformationClass,
                                                  SystemInformation,
                                                  SystemInformationLength,
                                                  PreviousMode
                                                  );
            break;

        case SystemComPlusPackage:

            if (SystemInformationLength != sizeof( ULONG ) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpUpdateComPlusPackage (*(PULONG)SystemInformation);
            if (NT_SUCCESS (Status)) {
                SharedUserData->ComPlusPackage = *(PULONG)SystemInformation;
            }

            break;

        case SystemHotpatchInformation:
            Status = ExApplyCodePatch( SystemInformation,
                                       SystemInformationLength
                                       );
            break;

        case SystemWow64SharedInformation:
            
            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

#if defined(_WIN64)

            if (SystemInformationLength != sizeof (SharedUserData->Wow64SharedInformation)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (PreviousMode != KernelMode) {

                //
                // The caller's access mode is not kernel so check to 
                // ensure that the caller has the privilege to load
                // a driver.
                //

                if (!SeSinglePrivilegeCheck (SeLoadDriverPrivilege, PreviousMode)) {
                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                try {
                    ProbeForRead (SystemInformation, 
                                  SystemInformationLength, 
                                  sizeof (UCHAR));

                    if (SharedUserData->Wow64SharedInformation[0] == 0) {
                        RtlCopyMemory (&SharedUserData->Wow64SharedInformation[0],
                                       SystemInformation,
                                       SystemInformationLength);

                        KeUserPopEntrySListEndWow64 =
                            UlongToPtr (SharedUserData->Wow64SharedInformation[SharedNtdll32ExpInterlockedPopEntrySListEnd]);

                        KeUserPopEntrySListFaultWow64 =
                            UlongToPtr (SharedUserData->Wow64SharedInformation[SharedNtdll32ExpInterlockedPopEntrySListFault]);

                        KeUserPopEntrySListResumeWow64 =
                            UlongToPtr (SharedUserData->Wow64SharedInformation[SharedNtdll32ExpInterlockedPopEntrySListResume]);
                    }

                } except (EXCEPTION_EXECUTE_HANDLER) {
                    return GetExceptionCode();
                }
            }

#else

            return STATUS_NOT_IMPLEMENTED;

#endif

            break;

        case SystemWatchdogTimerHandler:

            {
                PSYSTEM_WATCHDOG_HANDLER_INFORMATION WdHandlerInfo = (PSYSTEM_WATCHDOG_HANDLER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_HANDLER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                ExpWdHandler = WdHandlerInfo->WdHandler;
                ExpWdHandlerContext = WdHandlerInfo->Context;
            }

            break;

        case SystemWatchdogTimerInformation:

            {
                PSYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                if (ExpWdHandler == NULL) {

                    Status = STATUS_NOT_IMPLEMENTED;

                } else {

                    switch (WdTimerInfo->WdInfoClass) {
                        case WdInfoTimeoutValue:
                            Status = ExpWdHandler( WdActionSetTimeoutValue, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoResetTimer:
                            Status = ExpWdHandler( WdActionResetTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoStopTimer:
                            Status = ExpWdHandler( WdActionStopTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoStartTimer:
                            Status = ExpWdHandler( WdActionStartTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoTriggerAction:
                            Status = ExpWdHandler( WdActionSetTriggerAction, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        default:
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                    }
                }
            }

            break;

        case SystemRegisterFirmwareTableInformationHandler:

            Status = ExpRegisterFirmwareTableInformationHandler(SystemInformation,
                                                                SystemInformationLength,
                                                                PreviousMode);
            break;

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
ExLockUserBuffer (
    __inout_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in KPROCESSOR_MODE ProbeMode,
    __in LOCK_OPERATION LockMode,
    __deref_out PVOID *LockedBuffer,
    __deref_out PVOID *LockVariable
    )

/*++

Routine Description:

    Wrapper for MmProbeAndLockPages.  Creates an MDL and locks the
    specified buffer with that MDL.        

Arguments:

    Buffer - pointer to the buffer to be locked.
    Length - size of the buffer to be locked.
    ProbeMode - processor mode for doing the probe in MmProbeAndLockPages.
    LockMode - the mode the pages should be locked for.
    LockedBuffer - returns a pointer to the locked buffer for use by the 
                   caller.
    LockVariable - returns a context pointer.  This must be passed into
                   ExUnlockUserBuffer when complete so the MDL can be freed.                   

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The buffer is not accessible with the 
                 specified LockMode.
                 
        STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the MDL.                                           
                 

--*/

{
    PMDL Mdl;
    SIZE_T MdlSize;

    //
    // It is the caller's responsibility to ensure zero cannot be passed in.
    //

    ASSERT (Length != 0);

    *LockedBuffer = NULL;
    *LockVariable = NULL;

    //
    // Allocate an MDL to map the request.
    //

    MdlSize = MmSizeOfMdl( Buffer, Length );
    Mdl = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                      MdlSize,
                                      'ofnI');
    if (Mdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize MDL for request.
    //

    MmInitializeMdl(Mdl, Buffer, Length);

    try {

        MmProbeAndLockPages (Mdl, ProbeMode, LockMode);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ExFreePool (Mdl);

        return GetExceptionCode();
    }

    Mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    *LockedBuffer = MmGetSystemAddressForMdl (Mdl);
    if (*LockedBuffer == NULL) {
        ExUnlockUserBuffer (Mdl);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *LockVariable = Mdl;
    return STATUS_SUCCESS;
}

VOID
ExUnlockUserBuffer (
    __inout PVOID LockVariable
    )

{
    MmUnlockPages ((PMDL)LockVariable);
    ExFreePool ((PMDL)LockVariable);
    return;
}

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length OPTIONAL,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    )

/*++

Routine Description:

    This function returns information about all the processes and
    threads in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

    SessionId - Session Id.

    ExtendedInformation - TRUE if extended information (e.g., Process PDE) is needed.

Environment:

    Kernel mode.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PEPROCESS Process = NULL;
    PETHREAD Thread;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PVOID ThreadInfo;
    ULONG ThreadInfoSize;
    PLIST_ENTRY NextThread;
    PVOID MappedAddress;
    PVOID LockVariable;
    ULONG ProcessSessionId;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PUCHAR Src;
    PWCHAR SrcW;
    PWSTR Dst;
    ULONG n, nc;
    NTSTATUS status = STATUS_SUCCESS, status1;
    PUNICODE_STRING pImageFileName;

    if (ARGUMENT_PRESENT(Length)) {
        *Length = 0;
    }

    if (SystemInformationLength > 0) {
        status1 = ExLockUserBuffer (SystemInformation,
                                    SystemInformationLength,
                                    KeGetPreviousMode(),
                                    IoWriteAccess,
                                    &MappedAddress,
                                    &LockVariable);

        if (!NT_SUCCESS(status1)) {
            return status1;
        }

    } else {

        //
        // This indicates the caller just wants to know the size of the
        // buffer to allocate but is not prepared to accept any data content
        // in this instance.
        //

        MappedAddress = NULL;
        LockVariable = NULL;
    }

    if (ExtendedInformation) {
        ThreadInfoSize = sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION);

    } else {
        ThreadInfoSize = sizeof(SYSTEM_THREAD_INFORMATION);
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) MappedAddress;

    try {

        //
        // Do the idle process first then all the other processes.
        //

        for  (Process = PsIdleProcess;
              Process != NULL;
              Process = PsGetNextProcess ((Process == PsIdleProcess) ? NULL : Process)) {

            //
            // If the process is marked as exiting, the executive process has
            // no active threads, the kernel process has no threads, and the
            // kernel process has been signaled, then skip the process.
            //
            // N.B. It is safe to examine the kernel thread list without a
            //      lock since no list pointers are dereferenced.
            //

            if (((Process->Flags & PS_PROCESS_FLAGS_PROCESS_EXITING) != 0) &&
                (Process->Pcb.Header.SignalState != 0) &&
                (Process->ActiveThreads == 0) &&
                (IsListEmpty(&Process->Pcb.ThreadListHead) == TRUE)) {

                continue;
            }

            if (ARGUMENT_PRESENT(SessionId) && (Process == PsIdleProcess)) {
                continue;
            }

            ProcessSessionId = MmGetSessionId (Process);
            if ((ARGUMENT_PRESENT(SessionId)) &&
                (ProcessSessionId != *SessionId)) {
                continue;
            }

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            ((PUCHAR)MappedAddress + TotalSize);

            NextEntryOffset = sizeof(SYSTEM_PROCESS_INFORMATION);
            TotalSize += sizeof(SYSTEM_PROCESS_INFORMATION);
            if (TotalSize > SystemInformationLength) {
                status = STATUS_INFO_LENGTH_MISMATCH;
                if (ARGUMENT_PRESENT(Length) == FALSE) {
                    leave;
                }

            } else {

                //
                // Get information for each process.
                //

                ExpCopyProcessInfo (ProcessInfo, Process, ExtendedInformation);
                ProcessInfo->NumberOfThreads = 0;
                ProcessInfo->NextEntryOffset = 0;

                //
                // Store the Remote Terminal SessionId
                //

                ProcessInfo->SessionId = ProcessSessionId;
                ProcessInfo->ImageName.Buffer = NULL;
                ProcessInfo->ImageName.Length = 0;
                ProcessInfo->ImageName.MaximumLength = 0;
                if (Process == PsIdleProcess) {

                    //
                    // Since Idle process and system process share the same
                    // object table, zero out idle processes handle count to
                    // reduce confusion
                    //
                    // Idle Process always has SessionId 0
                    //

                    ProcessInfo->HandleCount = 0;
                    ProcessInfo->SessionId = 0;
                }
            }

            //
            // Raise IRQL to SYNCH_LEVEL, acquire the kernel process lock, and
            // get information for each thread.
            //

            ThreadInfo = (PVOID)(ProcessInfo + 1);
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->Pcb.ProcessLock,
                                                       &LockHandle);

            NextThread = Process->Pcb.ThreadListHead.Flink;
            while (NextThread != &Process->Pcb.ThreadListHead) {
                NextEntryOffset += ThreadInfoSize;
                TotalSize += ThreadInfoSize;

                if (TotalSize > SystemInformationLength) {
                    status = STATUS_INFO_LENGTH_MISMATCH;
                    if (ARGUMENT_PRESENT(Length) == FALSE) {
                        KeReleaseInStackQueuedSpinLock(&LockHandle);
                        leave;
                    }

                } else {
                    Thread = (PETHREAD)(CONTAINING_RECORD(NextThread,
                                                          KTHREAD,
                                                          ThreadListEntry));

                    //
                    // Lock dispatcher database to get atomic view of thread
                    // attributes.
                    //

                    KiLockDispatcherDatabaseAtSynchLevel();
                    ExpCopyThreadInfo (ThreadInfo, Thread, ExtendedInformation);
                    KiUnlockDispatcherDatabaseFromSynchLevel();
                    ProcessInfo->NumberOfThreads += 1;
                    ThreadInfo = (PCHAR) ThreadInfo + ThreadInfoSize;
                }

                NextThread = NextThread->Flink;
            }

            //
            // Unlock kernel process lock and lower IRQL to its previous value.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);

            //
            // Get the image name.
            //

            if (Process != PsIdleProcess) {

                //
                // Try to use the real image name if we can that not limited to 16 characters
                //

                Dst = (PWSTR)(ThreadInfo);
                status1 = SeLocateProcessImageName (Process, &pImageFileName);
                if (NT_SUCCESS (status1)) {
                    n = pImageFileName->Length;
                    if (n == 0) {
                        ExFreePool (pImageFileName);
                    }

                } else {
                    n = 0;
                }

                if (n) {
                    SrcW = pImageFileName->Buffer + n / sizeof (WCHAR);
                    while (SrcW != pImageFileName->Buffer) {
                        if (*--SrcW == L'\\') {
                            SrcW = SrcW + 1;
                            break;
                        }
                    }

                    nc = n - (ULONG)(SrcW -  pImageFileName->Buffer) * sizeof (WCHAR);
                    n = ROUND_UP (nc + 1, sizeof(LARGE_INTEGER));
                    TotalSize += n;
                    NextEntryOffset += n;
                    if (TotalSize > SystemInformationLength) {
                        status = STATUS_INFO_LENGTH_MISMATCH;
                        if (ARGUMENT_PRESENT(Length) == FALSE) {
                            ExFreePool (pImageFileName);
                            leave;
                        }
                    } else {
                        RtlCopyMemory (Dst, SrcW, nc);
                        Dst += nc / sizeof (WCHAR);
                        *Dst++ = L'\0';
                    }

                    ExFreePool (pImageFileName);

                } else {
                    Src = Process->ImageFileName;
                    n = (ULONG) strlen ((PCHAR)Src);
                    if (n != 0) {
                        n = ROUND_UP( ((n + 1) * sizeof( WCHAR )), sizeof(LARGE_INTEGER) );
                        TotalSize += n;
                        NextEntryOffset += n;
                        if (TotalSize > SystemInformationLength) {
                            status = STATUS_INFO_LENGTH_MISMATCH;
                            if (ARGUMENT_PRESENT(Length) == FALSE) {
                                leave;
                            }

                        } else {
                            WCHAR c;

                            while (1) {
                                c = (WCHAR)*Src++;
                                *Dst++ =  c;
                                if (c == L'\0') {
                                    break;
                                }
                            }
                        }
                    }
                }

                if (NT_SUCCESS (status)) {
                    ProcessInfo->ImageName.Length = (USHORT)((PCHAR)Dst -
                                                             (PCHAR)ThreadInfo - sizeof( UNICODE_NULL ));

                    ProcessInfo->ImageName.MaximumLength = (USHORT)n;

                    //
                    // Set the image name to point into the user's memory.
                    //

                    ProcessInfo->ImageName.Buffer = (PWSTR)
                                ((PCHAR)SystemInformation +
                                 ((PCHAR)(ThreadInfo) - (PCHAR)MappedAddress));
                }
            }

            //
            // Point to next process.
            //

            if (NT_SUCCESS (status)) {
                ProcessInfo->NextEntryOffset = NextEntryOffset;
            }
        }

        if (NT_SUCCESS(status)) {
            ProcessInfo->NextEntryOffset = 0;
        }

        if (ARGUMENT_PRESENT(Length)) {
            *Length = TotalSize;
        }

    } finally {

        if ((Process != NULL) && (Process != PsIdleProcess)) {
            PsQuitNextProcess (Process);
        }

        if (MappedAddress != NULL) {
            ExUnlockUserBuffer (LockVariable);
        }
    }

    return status;
}

NTSTATUS
ExGetSessionPoolTagInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL
    )

/*++

Routine Description:

    This function returns information about all the per-session pool tag
    information in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
                        information.

    SystemInformationLength - Specifies the length in bytes of the system
                              information buffer.

    Length - Receives the number of bytes placed (or would have been placed)
             in the system information buffer.

    SessionId - Session Id (-1 indicates enumerate all sessions).

Environment:

    Kernel mode.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    KAPC_STATE ApcState;
    PVOID MappedAddress;
    PVOID OpaqueSession;
    PVOID LockVariable;
    ULONG TotalSize;
    ULONG NextEntryOffset;
    ULONG CurrentSessionId;
    ULONG Count;
    ULONG AbsoluteCount;
    NTSTATUS status;
    NTSTATUS status1;
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPoolTagInfo;

    *Length = 0;
    TotalSize = 0;
    NextEntryOffset = 0;
    status = STATUS_SUCCESS;
    SessionPoolTagInfo = NULL;

    if (SystemInformationLength > 0) {

        status1 = ExLockUserBuffer (SystemInformation,
                                    SystemInformationLength,
                                    KeGetPreviousMode(),
                                    IoWriteAccess,
                                    &MappedAddress,
                                    &LockVariable);

        if (!NT_SUCCESS(status1)) {
            return status1;
        }

    }
    else {

        //
        // This indicates the caller just wants to know the size of the
        // buffer to allocate but is not prepared to accept any data content
        // in this instance.
        //

        MappedAddress = NULL;
        LockVariable = NULL;
    }

    for (OpaqueSession = MmGetNextSession (NULL);
         OpaqueSession != NULL;
         OpaqueSession = MmGetNextSession (OpaqueSession)) {

        SessionPoolTagInfo = (PSYSTEM_SESSION_POOLTAG_INFORMATION)
                                ((PUCHAR)MappedAddress + TotalSize);

        //
        // If a specific session was requested, only extract that one.
        //

        CurrentSessionId = MmGetSessionId (OpaqueSession);

        if ((*SessionId == 0xFFFFFFFF) || (CurrentSessionId == *SessionId)) {

            //
            // Attach to session now to perform operations...
            //

            if (NT_SUCCESS (MmAttachSession (OpaqueSession, &ApcState))) {

                //
                // Session is still alive so include it.
                //

                NextEntryOffset = sizeof (SYSTEM_SESSION_POOLTAG_INFORMATION);
                TotalSize += sizeof (SYSTEM_SESSION_POOLTAG_INFORMATION);

                if (TotalSize > SystemInformationLength) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                    //
                    // Get absolute size for this session, ignore status as
                    // we must return the one above.
                    //

                    ExGetSessionPoolTagInfo (NULL,
                                             0,
                                             &Count,
                                             &AbsoluteCount);
                }
                else {

                    //
                    // Get pool tagging information for each session.
                    //

                    status = ExGetSessionPoolTagInfo (
                                    SessionPoolTagInfo->TagInfo,
                                    SystemInformationLength - TotalSize + sizeof (SYSTEM_POOLTAG),
                                    &Count,
                                    &AbsoluteCount);

                    SessionPoolTagInfo->SessionId = CurrentSessionId;
                    SessionPoolTagInfo->Count = Count;

                    //
                    // Point to next session.
                    //

                    if (NT_SUCCESS (status)) {
                        NextEntryOffset += ((Count - 1) * sizeof (SYSTEM_POOLTAG));
                        SessionPoolTagInfo->NextEntryOffset = NextEntryOffset;
                    }
                }

                TotalSize += ((AbsoluteCount - 1) * sizeof (SYSTEM_POOLTAG));

                //
                // Detach from session.
                //

                MmDetachSession (OpaqueSession, &ApcState);
            }

            //
            // Bail if only this session was of interest.
            //

            if (*SessionId != 0xFFFFFFFF) {
                MmQuitNextSession (OpaqueSession);
                break;
            }
        }
    }

    if ((NT_SUCCESS (status)) && (SessionPoolTagInfo != NULL)) {
        SessionPoolTagInfo->NextEntryOffset = 0;
    }

    if (MappedAddress != NULL) {
        ExUnlockUserBuffer (LockVariable);
    }

    *Length = TotalSize;

    return status;
}

NTSTATUS
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PPROCESSOR_PERF_STATE               PerfStates;
    PSYSTEM_PROCESSOR_POWER_INFORMATION CallerPowerInfo;
    SYSTEM_PROCESSOR_POWER_INFORMATION  ProcessorPowerInfo;
    NTSTATUS Status;

    //
    // We will walk this pointer to store the user data...
    //
    CallerPowerInfo = (PSYSTEM_PROCESSOR_POWER_INFORMATION) SystemInformation;

    //
    // Check to see if we have the space for this
    //

    *Length = sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION) * KeNumberProcessors;

    if (SystemInformationLength < sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION) * KeNumberProcessors) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Lock everything down
    //
    MmLockPageableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {


        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;


        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

        PerfStates = PState->PerfStates;

        //
        // Grab the data that we care about
        //
        ProcessorPowerInfo.CurrentFrequency            = PState->CurrentThrottle;
        ProcessorPowerInfo.LastBusyFrequency           = PState->LastBusyPercentage;
        ProcessorPowerInfo.LastAdjustedBusyFrequency   = PState->LastAdjustedBusyPercentage;
        ProcessorPowerInfo.LastC3Frequency             = PState->LastC3Percentage;
        ProcessorPowerInfo.ProcessorMinThrottle        = PState->ProcessorMinThrottle;
        ProcessorPowerInfo.ProcessorMaxThrottle        = PState->ProcessorMaxThrottle;
        ProcessorPowerInfo.ErrorCount                  = PState->ErrorCount;
        ProcessorPowerInfo.RetryCount                  = PState->RetryCount;

        //
        // Do we have any kind of PerfStates?
        //
        if (PerfStates) {

            ProcessorPowerInfo.ThermalLimitFrequency       = PerfStates[PState->ThermalThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.ConstantThrottleFrequency   = PerfStates[PState->KneeThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.DegradedThrottleFrequency   = PerfStates[PState->ThrottleLimitIndex].PercentFrequency;

        } else {

            ProcessorPowerInfo.ThermalLimitFrequency       = 0;
            ProcessorPowerInfo.ConstantThrottleFrequency   = 0;
            ProcessorPowerInfo.DegradedThrottleFrequency   = 0;

        }

        ProcessorPowerInfo.CurrentFrequencyTime        =
            UInt32x32To64(
                (Prcb->KernelTime + Prcb->UserTime - PState->PerfTickCount),
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorTime        =
            UInt32x32To64(
                Prcb->KernelTime + Prcb->UserTime,
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorIdleTime    =
            UInt32x32To64( Prcb->IdleThread->KernelTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorTime           =
            UInt32x32To64( PState->LastKernelUserTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorIdleTime       =
            UInt32x32To64( PState->PerfIdleTime, KeMaximumIncrement );

        ProcessorPowerInfo.PromotionCount              = PState->PromotionCount;
        ProcessorPowerInfo.DemotionCount               = PState->DemotionCount;
        ProcessorPowerInfo.NumberOfFrequencies         = PState->PerfStatesCount;

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql (oldIrql);

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerPowerInfo,
                &ProcessorPowerInfo,
                sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
            goto exit_revert_and_unlock;
        }

        //
        // Point to the next structure element
        //
        CallerPowerInfo++;

    }

    Status = STATUS_SUCCESS;

exit_revert_and_unlock:

    //
    // Revert to the original affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Unlock everything

    MmUnlockPageableImageSection(ExPageLockHandle);

    return Status;
}

NTSTATUS
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    LARGE_INTEGER                       PerfFrequency;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PSYSTEM_PROCESSOR_IDLE_INFORMATION  CallerIdleInfo;
    SYSTEM_PROCESSOR_IDLE_INFORMATION   ProcessorIdleInfo;
    NTSTATUS Status;

    //
    // We will walk this pointer to store the user data...
    //
    CallerIdleInfo = (PSYSTEM_PROCESSOR_IDLE_INFORMATION) SystemInformation;

    *Length = sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION) * KeNumberProcessors;

    //
    // Check to see if we have the space for this
    //
    if (SystemInformationLength < sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION) * KeNumberProcessors) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // We need to know what frequency the perf counters are running at
    //
    KeQueryPerformanceCounter(&PerfFrequency);

    //
    // Lock everything down
    //
    MmLockPageableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);


        //
        // Grab the data that we care about
        //
        ProcessorIdleInfo.IdleTime = UInt32x32To64(Prcb->IdleThread->KernelTime,KeMaximumIncrement);

        //
        // The Cx times are kept in units of the same frequency as KeQueryPerformanceCounter
        // This needs to be converted to standard 100ns units.
        //
        ProcessorIdleInfo.C1Time =  (PState->TotalIdleStateTime[0]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C2Time =  (PState->TotalIdleStateTime[1]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C3Time =  (PState->TotalIdleStateTime[2]*1000)/(PerfFrequency.QuadPart/10000);

        ProcessorIdleInfo.C1Transitions = PState->TotalIdleTransitions[0];
        ProcessorIdleInfo.C2Transitions = PState->TotalIdleTransitions[1];
        ProcessorIdleInfo.C3Transitions = PState->TotalIdleTransitions[2];

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql (oldIrql);

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerIdleInfo,
                &ProcessorIdleInfo,
                sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode ();
            goto exit_revert_and_unlock;
        }

        //
        // Point to the next structure element
        //
        CallerIdleInfo++;
    }

    Status = STATUS_SUCCESS;

exit_revert_and_unlock:

    //
    // Revert to the original affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Unlock everything
    //
    MmUnlockPageableImageSection(ExPageLockHandle);

    return Status;
}

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    )

{

    KPROCESS_VALUES Values;

    PAGED_CODE();

    ProcessInfo->HandleCount = ObGetProcessHandleCount (Process);
    ProcessInfo->CreateTime = Process->CreateTime;
    ProcessInfo->BasePriority = Process->Pcb.BasePriority;
    ProcessInfo->UniqueProcessId = Process->UniqueProcessId;
    ProcessInfo->InheritedFromUniqueProcessId = Process->InheritedFromUniqueProcessId;
    ProcessInfo->PeakVirtualSize = Process->PeakVirtualSize;
    ProcessInfo->VirtualSize = Process->VirtualSize;
    ProcessInfo->PageFaultCount = Process->Vm.PageFaultCount;
    ProcessInfo->PeakWorkingSetSize = ((SIZE_T)Process->Vm.PeakWorkingSetSize) << PAGE_SHIFT;
    ProcessInfo->WorkingSetSize = ((SIZE_T)Process->Vm.WorkingSetSize) << PAGE_SHIFT;
    ProcessInfo->QuotaPeakPagedPoolUsage =
                            Process->QuotaPeak[PsPagedPool];

    ProcessInfo->QuotaPagedPoolUsage = Process->QuotaUsage[PsPagedPool];
    ProcessInfo->QuotaPeakNonPagedPoolUsage =
                            Process->QuotaPeak[PsNonPagedPool];

    ProcessInfo->QuotaNonPagedPoolUsage =
                            Process->QuotaUsage[PsNonPagedPool];

    ProcessInfo->PagefileUsage = Process->QuotaUsage[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PeakPagefileUsage = Process->QuotaPeak[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PrivatePageCount = Process->CommitCharge << PAGE_SHIFT;

    //
    // Query the process kernel runtime, user runtime, and I/O statistics.
    //

    KeQueryValuesProcess(&Process->Pcb, &Values);
    ProcessInfo->UserTime.QuadPart = Values.UserTime;
    ProcessInfo->KernelTime.QuadPart = Values.KernelTime;
    ProcessInfo->ReadOperationCount.QuadPart = Values.ReadOperationCount;
    ProcessInfo->WriteOperationCount.QuadPart = Values.WriteOperationCount;
    ProcessInfo->OtherOperationCount.QuadPart = Values.OtherOperationCount;
    ProcessInfo->ReadTransferCount.QuadPart = Values.ReadTransferCount;
    ProcessInfo->WriteTransferCount.QuadPart = Values.WriteTransferCount;
    ProcessInfo->OtherTransferCount.QuadPart = Values.OtherTransferCount;
    if (ExtendedInformation) {
        ProcessInfo->PageDirectoryBase = MmGetDirectoryFrameFromProcess(Process);
    }
}

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    )

/*++

Routine Description:

    This function returns information about the specified thread.

Arguments:

    ThreadInfoBuffer - A pointer to a buffer which receives the specified
        information.

    Thread - Supplies a pointer to the desired thread.

    ExtendedInformation - TRUE if extended thread information is needed.

Environment:

    Kernel mode.  The dispatcher lock is held.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    None.

--*/

{
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) ThreadInfoBuffer;

    ThreadInfo->KernelTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
                                                    KeMaximumIncrement);

    ThreadInfo->UserTime.QuadPart = UInt32x32To64(Thread->Tcb.UserTime,
                                                  KeMaximumIncrement);

    ThreadInfo->CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
    ThreadInfo->WaitTime = Thread->Tcb.WaitTime;
    ThreadInfo->ClientId = Thread->Cid;
    ThreadInfo->ThreadState = Thread->Tcb.State;
    ThreadInfo->WaitReason = Thread->Tcb.WaitReason;
    ThreadInfo->Priority = Thread->Tcb.Priority;
    ThreadInfo->BasePriority = Thread->Tcb.BasePriority;
    ThreadInfo->ContextSwitches = Thread->Tcb.ContextSwitches;
    ThreadInfo->StartAddress = Thread->StartAddress;

    if (ExtendedInformation) {
        PSYSTEM_EXTENDED_THREAD_INFORMATION ExtendedThreadInfo;

        ExtendedThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) ThreadInfo;

        ExtendedThreadInfo->StackBase = Thread->Tcb.StackBase;
        ExtendedThreadInfo->StackLimit = Thread->Tcb.StackLimit;
        if (Thread->LpcReceivedMsgIdValid) {
            ExtendedThreadInfo->Win32StartAddress = 0;
        } else {
            ExtendedThreadInfo->Win32StartAddress = Thread->Win32StartAddress;
        }
        ExtendedThreadInfo->Reserved1 = 0;
        ExtendedThreadInfo->Reserved2 = 0;
        ExtendedThreadInfo->Reserved3 = 0;
        ExtendedThreadInfo->Reserved4 = 0;
    }

}

#if defined(_X86_)

extern ULONG ExVdmOpcodeDispatchCounts[256];
extern ULONG VdmBopCount;
extern ULONG ExVdmSegmentNotPresent;

#pragma alloc_text(PAGE, ExpGetInstemulInformation)

NTSTATUS
ExpGetInstemulInformation (
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    )
{
    SYSTEM_VDM_INSTEMUL_INFO LocalInfo;

    LocalInfo.VdmOpcode0F       = ExVdmOpcodeDispatchCounts[VDM_INDEX_0F];
    LocalInfo.OpcodeESPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_ESPrefix];
    LocalInfo.OpcodeCSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_CSPrefix];
    LocalInfo.OpcodeSSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_SSPrefix];
    LocalInfo.OpcodeDSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_DSPrefix];
    LocalInfo.OpcodeFSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_FSPrefix];
    LocalInfo.OpcodeGSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_GSPrefix];
    LocalInfo.OpcodeOPER32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_OPER32Prefix];
    LocalInfo.OpcodeADDR32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_ADDR32Prefix];
    LocalInfo.OpcodeINSB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSB];
    LocalInfo.OpcodeINSW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSW];
    LocalInfo.OpcodeOUTSB       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSB];
    LocalInfo.OpcodeOUTSW       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSW];
    LocalInfo.OpcodePUSHF       = ExVdmOpcodeDispatchCounts[VDM_INDEX_PUSHF];
    LocalInfo.OpcodePOPF        = ExVdmOpcodeDispatchCounts[VDM_INDEX_POPF];
    LocalInfo.OpcodeINTnn       = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTnn];
    LocalInfo.OpcodeINTO        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTO];
    LocalInfo.OpcodeIRET        = ExVdmOpcodeDispatchCounts[VDM_INDEX_IRET];
    LocalInfo.OpcodeINBimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INBimm];
    LocalInfo.OpcodeINWimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INWimm];
    LocalInfo.OpcodeOUTBimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTBimm];
    LocalInfo.OpcodeOUTWimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTWimm];
    LocalInfo.OpcodeINB         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INB];
    LocalInfo.OpcodeINW         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INW];
    LocalInfo.OpcodeOUTB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTB];
    LocalInfo.OpcodeOUTW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTW];
    LocalInfo.OpcodeLOCKPrefix  = ExVdmOpcodeDispatchCounts[VDM_INDEX_LOCKPrefix];
    LocalInfo.OpcodeREPNEPrefix = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPNEPrefix];
    LocalInfo.OpcodeREPPrefix   = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPPrefix];
    LocalInfo.OpcodeHLT         = ExVdmOpcodeDispatchCounts[VDM_INDEX_HLT];
    LocalInfo.OpcodeCLI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_CLI];
    LocalInfo.OpcodeSTI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_STI];
    LocalInfo.BopCount          = VdmBopCount;
    LocalInfo.SegmentNotPresent = ExVdmSegmentNotPresent;

    RtlCopyMemory(Info,&LocalInfo,sizeof(LocalInfo));

    return STATUS_SUCCESS;
}

#endif

#if i386

NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_PROCESS_BACKTRACES BackTraceInformation;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG RequiredLength, n;

    DataBase = RtlpAcquireStackTraceDataBase();

    if (DataBase == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    DataBase->DumpInProgress = TRUE;

    RtlpReleaseStackTraceDataBase();

    n = 0;
    RequiredLength = 0;
    Status = STATUS_INFO_LENGTH_MISMATCH;
    BackTraceInformation = (PRTL_PROCESS_BACKTRACES) SystemInformation;

    RequiredLength = FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces );

    try {
        if (SystemInformationLength >= RequiredLength) {
            BackTraceInformation->CommittedMemory =
                (ULONG)DataBase->CurrentUpperCommitLimit - (ULONG)DataBase->CommitBase;
            BackTraceInformation->ReservedMemory =
                (ULONG)DataBase->EntryIndexArray - (ULONG)DataBase->CommitBase;
            BackTraceInformation->NumberOfBackTraceLookups = DataBase->NumberOfEntriesLookedUp;
            n = DataBase->NumberOfEntriesAdded;
            BackTraceInformation->NumberOfBackTraces = n;
        }

        RequiredLength += (sizeof( *BackTraceInfo ) * n);
        if (SystemInformationLength >= RequiredLength) {
            Status = STATUS_SUCCESS;
            BackTraceInfo = &BackTraceInformation->BackTraces[ 0 ];
            pp = DataBase->EntryIndexArray;
            while (n--) {
                p = *--pp;
                BackTraceInfo->SymbolicBackTrace = NULL;
                BackTraceInfo->TraceCount = p->TraceCount;
                BackTraceInfo->Index = p->Index;
                BackTraceInfo->Depth = p->Depth;
                RtlCopyMemory( BackTraceInfo->BackTrace,
                               p->BackTrace,
                               p->Depth * sizeof( PVOID )
                             );
                BackTraceInfo += 1;
            }
        }
    }
    finally {
        DataBase->DumpInProgress = FALSE;
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }
    return Status;
}

#endif // i386

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns information about all the ERESOURCE locks
    in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PRTL_PROCESS_LOCKS LockInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &LockInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    MmLockPageableSectionByHandle (ExPageLockHandle);
    try {

        Status = ExQuerySystemLockInformation( LockInfo,
                                               SystemInformationLength,
                                               Length
                                             );
    }
    finally {
        ExUnlockUserBuffer( LockVariable );
        MmUnlockPageableImageSection(ExPageLockHandle);
    }

    return Status;
}

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns pool lookaside list and general lookaside
    list information.

Arguments:

    Buffer - Supplies a pointer to the buffer which receives the lookaside
        list information.

    BufferLength - Supplies the length of the information buffer in bytes.

    Length - Supplies a pointer to a variable that receives the length of
        lookaside information returned.

Environment:

    Kernel mode.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The buffer could not be locked in memory.

--*/

{

    PVOID BufferLock;
    PLIST_ENTRY Entry;
    KIRQL OldIrql;
    ULONG Limit;
    PSYSTEM_LOOKASIDE_INFORMATION Lookaside;
    ULONG Number;
    PNPAGED_LOOKASIDE_LIST NPagedLookaside;
    PPAGED_LOOKASIDE_LIST PagedLookaside;
    PGENERAL_LOOKASIDE PoolLookaside;
    PGENERAL_LOOKASIDE SystemLookaside;
    PKSPIN_LOCK SpinLock;
    NTSTATUS Status;

    //
    // Compute the number of lookaside entries and set the return status to
    // success.
    //

    Limit = BufferLength / sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    Number = 0;
    Status = STATUS_SUCCESS;

    //
    // If the number of lookaside entries to return is not zero, then collect
    // the lookaside information.
    //

    if (Limit != 0) {
        Status = ExLockUserBuffer(Buffer,
                                  BufferLength,
                                  KeGetPreviousMode(),
                                  IoWriteAccess,
                                  &Lookaside,
                                  &BufferLock);
        if (NT_SUCCESS(Status)) {

            Status = STATUS_SUCCESS;

            //
            // Copy nonpaged and paged pool lookaside information to
            // information buffer.
            //

            Entry = ExPoolLookasideListHead.Flink;
            while (Entry != &ExPoolLookasideListHead) {
                PoolLookaside = CONTAINING_RECORD(Entry,
                                                  GENERAL_LOOKASIDE,
                                                  ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PoolLookaside->ListHead);
                Lookaside->MaximumDepth = PoolLookaside->Depth;
                Lookaside->TotalAllocates = PoolLookaside->TotalAllocates;
                Lookaside->AllocateMisses =
                        PoolLookaside->TotalAllocates - PoolLookaside->AllocateHits;

                Lookaside->TotalFrees = PoolLookaside->TotalFrees;
                Lookaside->FreeMisses =
                        PoolLookaside->TotalFrees - PoolLookaside->FreeHits;

                Lookaside->Type = PoolLookaside->Type;
                Lookaside->Tag = PoolLookaside->Tag;
                Lookaside->Size = PoolLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged and paged system lookaside information to
            // information buffer.
            //

            Entry = ExSystemLookasideListHead.Flink;
            while (Entry != &ExSystemLookasideListHead) {
                SystemLookaside = CONTAINING_RECORD(Entry,
                                                    GENERAL_LOOKASIDE,
                                                    ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&SystemLookaside->ListHead);
                Lookaside->MaximumDepth = SystemLookaside->Depth;
                Lookaside->TotalAllocates = SystemLookaside->TotalAllocates;
                Lookaside->AllocateMisses = SystemLookaside->AllocateMisses;
                Lookaside->TotalFrees = SystemLookaside->TotalFrees;
                Lookaside->FreeMisses = SystemLookaside->FreeMisses;
                Lookaside->Type = SystemLookaside->Type;
                Lookaside->Tag = SystemLookaside->Tag;
                Lookaside->Size = SystemLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged general lookaside information to buffer.
            //

            SpinLock = &ExNPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExNPagedLookasideListHead.Flink;
            while (Entry != &ExNPagedLookasideListHead) {
                NPagedLookaside = CONTAINING_RECORD(Entry,
                                                    NPAGED_LOOKASIDE_LIST,
                                                    L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&NPagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = NPagedLookaside->L.Depth;
                Lookaside->TotalAllocates = NPagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = NPagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = NPagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = NPagedLookaside->L.FreeMisses;
                Lookaside->Type = 0;
                Lookaside->Tag = NPagedLookaside->L.Tag;
                Lookaside->Size = NPagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            ExReleaseSpinLock(SpinLock, OldIrql);

            //
            // Copy paged general lookaside information to buffer.
            //

            SpinLock = &ExPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExPagedLookasideListHead.Flink;
            while (Entry != &ExPagedLookasideListHead) {
                PagedLookaside = CONTAINING_RECORD(Entry,
                                                   PAGED_LOOKASIDE_LIST,
                                                   L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = PagedLookaside->L.Depth;
                Lookaside->TotalAllocates = PagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = PagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = PagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = PagedLookaside->L.FreeMisses;
                Lookaside->Type = 1;
                Lookaside->Tag = PagedLookaside->L.Tag;
                Lookaside->Size = PagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

Finish1:
            ExReleaseSpinLock(SpinLock, OldIrql);

Finish2:
            //
            // Unlock user buffer.
            //

            ExUnlockUserBuffer(BufferLock);
        }
    }

    *Length = Number * sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    return Status;
}

NTSTATUS
ExpGetHandleInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns information about the open handles in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_HANDLE_INFORMATION HandleInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &HandleInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetHandleInformation( HandleInfo,
                                         SystemInformationLength,
                                         Length
                                       );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpGetHandleInformationEx (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns information about the open handles in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_HANDLE_INFORMATION_EX HandleInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &HandleInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetHandleInformationEx( HandleInfo,
                                           SystemInformationLength,
                                           Length
                                         );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpGetObjectInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns information about the objects in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_OBJECTTYPE_INFORMATION ObjectInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &ObjectInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetObjectInformation( SystemInformation,
                                         ObjectInfo,
                                         SystemInformationLength,
                                         Length
                                       );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpQueryModuleInformation (
    IN PLIST_ENTRY LoadOrderListHead,
    IN PLIST_ENTRY UserModeLoadOrderListHead,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    ULONG RequiredLength;
    PLIST_ENTRY Next;
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    PKLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    ANSI_STRING AnsiString;
    PCHAR s;
    ULONG NumberOfModules;

    NumberOfModules = 0;
    Status = STATUS_SUCCESS;
    RequiredLength = FIELD_OFFSET( RTL_PROCESS_MODULES, Modules );
    ModuleInfo = &ModuleInformation->Modules[ 0 ];

    Next = LoadOrderListHead->Flink;
    while ( Next != LoadOrderListHead ) {
        LdrDataTableEntry = CONTAINING_RECORD( Next,
                                               KLDR_DATA_TABLE_ENTRY,
                                               InLoadOrderLinks
                                             );

        RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );
        if (ModuleInformationLength < RequiredLength) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
        }
        else {

            ModuleInfo->MappedBase = NULL;
            ModuleInfo->ImageBase = LdrDataTableEntry->DllBase;
            ModuleInfo->ImageSize = LdrDataTableEntry->SizeOfImage;
            ModuleInfo->Flags = LdrDataTableEntry->Flags;
            ModuleInfo->LoadCount = LdrDataTableEntry->LoadCount;
            
            ModuleInfo->LoadOrderIndex = (USHORT)(NumberOfModules);
            
            ModuleInfo->InitOrderIndex = 0;
                
            AnsiString.Buffer = (PCHAR) ModuleInfo->FullPathName;
            AnsiString.Length = 0;
            AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );
            Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                          &LdrDataTableEntry->FullDllName,
                                          FALSE
                                        );

            if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {
                s = AnsiString.Buffer + AnsiString.Length;
                while (s > AnsiString.Buffer && *--s) {
                    if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
                        s += 1;
                        break;
                    }
                }
                ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);
            } else {
                ModuleInfo->FullPathName[0] = '\0';
                ModuleInfo->OffsetToFileName = 0;
            }
            
            ModuleInfo += 1;
        }

        NumberOfModules += 1;
        Next = Next->Flink;
    }

    if (ARGUMENT_PRESENT( UserModeLoadOrderListHead )) {
        Next = UserModeLoadOrderListHead->Flink;
        while ( Next != UserModeLoadOrderListHead ) {
            LdrDataTableEntry = CONTAINING_RECORD( Next,
                                                   KLDR_DATA_TABLE_ENTRY,
                                                   InLoadOrderLinks
                                                 );

            RequiredLength += sizeof( RTL_PROCESS_MODULE_INFORMATION );
            if (ModuleInformationLength < RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                ModuleInfo->MappedBase = NULL;
                ModuleInfo->ImageBase = LdrDataTableEntry->DllBase;
                ModuleInfo->ImageSize = LdrDataTableEntry->SizeOfImage;
                ModuleInfo->Flags = LdrDataTableEntry->Flags;
                ModuleInfo->LoadCount = LdrDataTableEntry->LoadCount;

                ModuleInfo->LoadOrderIndex = (USHORT)(NumberOfModules);

                ModuleInfo->InitOrderIndex = ModuleInfo->LoadOrderIndex;
                    
                AnsiString.Buffer = (PCHAR) ModuleInfo->FullPathName;
                AnsiString.Length = 0;
                AnsiString.MaximumLength = sizeof( ModuleInfo->FullPathName );
                Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                              &LdrDataTableEntry->FullDllName,
                                              FALSE
                                            );

                if (NT_SUCCESS (Status) || (Status == STATUS_BUFFER_OVERFLOW)) {
                    s = AnsiString.Buffer + AnsiString.Length;
                    while (s > AnsiString.Buffer && *--s) {
                        if (*s == (UCHAR)OBJ_NAME_PATH_SEPARATOR) {
                            s += 1;
                            break;
                        }
                    }
                    ModuleInfo->OffsetToFileName = (USHORT)(s - AnsiString.Buffer);
                } else {
                    ModuleInfo->FullPathName[0] = '\0';
                    ModuleInfo->OffsetToFileName = 0;
                }

                ModuleInfo += 1;
            }

            NumberOfModules += 1;
            Next = Next->Flink;
        }
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }
    if (ModuleInformationLength >= FIELD_OFFSET( RTL_PROCESS_MODULES, Modules )) {
        ModuleInformation->NumberOfModules = NumberOfModules;
    } else {
        Status = STATUS_INFO_LENGTH_MISMATCH;
    }
    return Status;
}

BOOLEAN
ExIsProcessorFeaturePresent (
    __in ULONG ProcessorFeature
    )

{

    BOOLEAN rv;

    //
    // On AMD64 systems legacy floating point, MMX, and 3D-Now are not
    // supported for 64-bit applications (i.e., the legacy floating
    // point state is not saved and restored). Therefore, FALSE is always
    // returned for these features.
    //

#if defined(_AMD64_)

    if ((ProcessorFeature == PF_MMX_INSTRUCTIONS_AVAILABLE) ||
        (ProcessorFeature == PF_3DNOW_INSTRUCTIONS_AVAILABLE)) {

        return FALSE;
    }

#endif

    if (ProcessorFeature < PROCESSOR_FEATURE_MAX) {
        rv = SharedUserData->ProcessorFeatures[ProcessorFeature];

    } else {
        rv = FALSE;
    }

    return rv;
}

NTSTATUS
ExpQueryLegacyDriverInformation (
    IN PSYSTEM_LEGACY_DRIVER_INFORMATION LegacyInfo,
    IN PULONG Length
    )

/*++

Routine Description:

    Returns legacy driver information for figuring out why PNP/Power functionality
    is disabled.

Arguments:

    LegacyInfo - Returns the legacy driver information

    Length - Supplies the length of the LegacyInfo buffer
             Returns the amount of data written

Return Value:

    NTSTATUS

--*/

{
    PNP_VETO_TYPE VetoType;
    PWSTR VetoList = NULL;
    NTSTATUS Status;
    UNICODE_STRING String;
    ULONG ReturnLength;

    Status = IoGetLegacyVetoList(&VetoList, &VetoType);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    RtlInitUnicodeString(&String, VetoList);
    ReturnLength = sizeof(SYSTEM_LEGACY_DRIVER_INFORMATION) + String.Length;
    try {
        if (ReturnLength > *Length) {
            Status = STATUS_BUFFER_OVERFLOW;
        } else {
            LegacyInfo->VetoType = VetoType;
            LegacyInfo->VetoList.Length = String.Length;
            LegacyInfo->VetoList.Buffer = (PWSTR)(LegacyInfo+1);
            RtlCopyMemory(LegacyInfo+1, String.Buffer, String.Length);
        }
    } finally {
        if (VetoList) {
            ExFreePool(VetoList);
        }
    }

    *Length = ReturnLength;
    return(Status);
}

VOID
ExGetCurrentProcessorCpuUsage (
    __out PULONG CpuUsage
    )

/*++

Routine Description:

    Returns an estimation of current cpu usage in percent.

Arguments:

    CpuUsage - Returns the current cpu usage in percent.

Return Value:

    Nothing

--*/
{
    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    *CpuUsage = 100 - (ULONG)(UInt32x32To64(Prcb->IdleThread->KernelTime, 100) /
                               (ULONGLONG)(Prcb->KernelTime + Prcb->UserTime));
}

VOID
ExGetCurrentProcessorCounts (
    __out PULONG IdleCount,
    __out PULONG KernelAndUser,
    __out PULONG Index
    )

/*++

Routine Description:

    Returns information regarding idle time and kernel + user time for
    the current processor.

Arguments:

    IdleCount - Returns the kernel time of the idle thread on the current
                processor.

    KernelAndUser - Returns the kernel pluse user on the current processor.

    Index - Returns the number identifying the current processor.

Return Value:

    Nothing

--*/
{
    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    *IdleCount = Prcb->IdleThread->KernelTime;
    *KernelAndUser = Prcb->KernelTime + Prcb->UserTime;
    *Index = (ULONG)Prcb->Number;
}

BOOLEAN
ExpIsValidUILanguage (
    IN WCHAR * pLangId
    )

/*++
Routine Description:

    Check if specified language ID is valid.

Arguments:

    pLangId - language ID hex string.

Return Value:

    TRUE: Valid
    FALSE: Invalid

--*/

{
    NTSTATUS Status;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE hKey;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG ResultLength;
    BOOLEAN bRet = FALSE;
    int iLen = 0;


    RtlInitUnicodeString(&KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\MUILanguages");
    //
    // pLangId is passed in as DWORD or WORD hex string
    // LangId string in MUILanguages is set as WORD hex string
    //
    while (pLangId[iLen])
    {
      iLen++;
    }
    //
    // We need to validate both 4 digits and 8 digits LangId
    //
    RtlInitUnicodeString(&KeyValueName, iLen < 8? pLangId : &pLangId[4]);

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    if (NT_SUCCESS(ZwOpenKey( &hKey,  GENERIC_READ, &ObjectAttributes)))
    {
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

        Status = ZwQueryValueKey( hKey,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( KeyValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS(Status))
        {
            if (KeyValueInformation->Type == REG_SZ && *((PWSTR)(KeyValueInformation->Data)) == L'1')
            {
                bRet = TRUE;
            }
        }

        ZwClose(hKey);
    }

    return bRet;
}

NTSTATUS
ExpGetSystemFirmwareTableInformation(
    IN OUT PVOID SystemFirmwareTableInformation,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Description:

    Look for the requested Firmware Table provider. if it exists, pass the 
    request on to it and return the result.

Parameters:

    SystemFirmwareTableInformation  - points to the SYSTEM_FIRMWARE_TABLE_INFORMATION 
                                      structure.
        
    ReturnLength                    - returns the bufferlength if present.

Return Value:

    STATUS_SUCCESS          - on success.
    STATUS_NOT_IMPLEMENTED  - on Failure.

--*/

{
    ULONG                               BufferLength = 0;
    PSYSTEM_FIRMWARE_TABLE_HANDLER_NODE HandlerCurrent;
    NTSTATUS                            Status = STATUS_NOT_IMPLEMENTED;
    PSYSTEM_FIRMWARE_TABLE_INFORMATION  TableInfo = NULL;
    PSYSTEM_FIRMWARE_TABLE_INFORMATION  TableInfoLocal = NULL;
    ULONG                               TotalStructSize = 0;
    
    PAGED_CODE();

    //
    // Point the incoming SystemFirmwareTableInformation to TableInfo. If this
    // is a usermode call, we will copy all the usermode data into local buffers
    // before calling the table provider.
    //
    
    TableInfo = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)SystemFirmwareTableInformation;

    if (PreviousMode != KernelMode) {

        try {

            ProbeForRead(&(TableInfo->TableBufferLength),
                         sizeof(ULONG),
                         sizeof(ULONG));

            //
            // Save a copy of the TableBufferLength as this value may be changed 
            // by the table providers handler.
            //
            
            BufferLength = TableInfo->TableBufferLength;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            
            return GetExceptionCode();        
        }

        TotalStructSize = sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION) + BufferLength;
        
        //
        // Allocate a local buffer. This way we always pass trusted memory to the
        // firmware table providers.
        //
        
        TableInfoLocal = ExAllocatePoolWithQuotaTag(PagedPool, 
                                                    TotalStructSize,
                                                    'TFRA');

        if (!TableInfoLocal) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(TableInfoLocal, TotalStructSize);
        
        try {

            //
            // Verify and copy the data to trusted memory.
            //
            
            ProbeForRead(TableInfo, 
                         sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION),
                         sizeof(ULONG));
            
            RtlCopyMemory(TableInfoLocal, 
                          TableInfo, 
                          sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            
            return GetExceptionCode();        
        }

        //
        // Now save a pointer to our copy of TableInfoLocal into Tableinfo. This
        // will improve code readability because all the shared code between user   
        // mode and kernel mode will use the same variable name.
        //

        TableInfo = TableInfoLocal;
    }

    //
    // Grab the resource as shared.
    //

    KeEnterCriticalRegion();

    ExAcquireResourceSharedLite(&ExpFirmwareTableResource, TRUE);
    
    //
    // Check if the required table provider is available.
    //

    EX_FOR_EACH_IN_LIST(SYSTEM_FIRMWARE_TABLE_HANDLER_NODE,
                        FirmwareTableProviderList,
                        &ExpFirmwareTableProviderListHead,
                        HandlerCurrent) {

        if (HandlerCurrent->SystemFWHandler.ProviderSignature == TableInfo->ProviderSignature) {

            //
            // Call the providers handler.
            //
            
            Status = (*(HandlerCurrent->SystemFWHandler.FirmwareTableHandler))(TableInfo);

            if (PreviousMode != KernelMode) {

                //
                // Copy the returned data to the callers buffer.
                //

                try {

                    //
                    // Point Tableinfo back to the original usermode buffer. Our
                    // new data is safe in TableInfoLocal.
                    //

                    TableInfo = (PSYSTEM_FIRMWARE_TABLE_INFORMATION)
                                    SystemFirmwareTableInformation;
                    
                    
                    if (NT_SUCCESS(Status)) {
                
                        //
                        // The usermode buffer (stored in TableInfo) in untrusted. 
                        // It's content could have changed. Use the cached value 
                        // in BufferLength to do the probe and make sure the 
                        // buffer is still valid.
                        
                        //
                        // Probe the Table buffer for writing.
                        //
                        
                        ProbeForWrite(TableInfo->TableBuffer, 
                                      BufferLength, 
                                      sizeof(UCHAR));

                        //
                        // Copy over the returned buffer to the user mode buffer.
                        //

                        RtlCopyMemory(TableInfo->TableBuffer, 
                                      TableInfoLocal->TableBuffer, 
                                      TableInfoLocal->TableBufferLength);
                    }

                    //
                    // Always update the returned buffer length.
                    //
                    
                    //
                    // Probe the structure for writing.
                    //

                    ProbeForWrite(&(TableInfo->TableBufferLength), 
                                  sizeof(ULONG), 
                                  sizeof(ULONG));

                    //
                    // Copy over the number of bytes written or required.
                    //

                    RtlCopyMemory(&(TableInfo->TableBufferLength), 
                                  &(TableInfoLocal->TableBufferLength), 
                                  sizeof(ULONG));        
                 
                    TableInfo = TableInfoLocal;

                    //
                    // Fill in ReturnLength.
                    //

                    if (ReturnLength) {

                        ProbeForWrite(ReturnLength, 
                                      sizeof(ULONG), 
                                      sizeof(ULONG));

                        *ReturnLength = TableInfo->TableBufferLength +
                                        sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION);
                    }
                
                    
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();        
                }
                
            } else {

                 //
                 // Fill in ReturnLength.
                 //
                 if (ReturnLength) {

                    *ReturnLength = TableInfo->TableBufferLength +
                                    sizeof(SYSTEM_FIRMWARE_TABLE_INFORMATION);
                 }
            }
            
            break;
        }
    }

    if (TableInfoLocal) {

        ExFreePoolWithTag(TableInfoLocal, 'TFRA');
    }
    
    ExReleaseResourceLite(&ExpFirmwareTableResource);

    KeLeaveCriticalRegion();
    
    return Status;
}


NTSTATUS
ExpRegisterFirmwareTableInformationHandler(
    IN OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Description:

    This routine registers and unregisters firmware table providers.

Parameters:

    SystemInformation       - points to the SYSTEM_FIRMWARE_TABLE_HANDLER 
                              structure.

    SystemInformationLength - returns the number of bytes written on success. if
                              the provided buffer was too small, it returns the 
                              required size.

    PreviousMode            - Previous mode (Kernel / User).

Return Value:

    STATUS_SUCCESS                  - On success.
    STATUS_PRIVILEGE_NOT_HELD       - If caller is from User mode.
    STATUS_INFO_LENGTH_MISMATCH     - Buffer too small.
    STATUS_INSUFFICIENT_RESOURCES   - On failure to allocate resources.
    STATUS_OBJECT_NAME_EXISTS       - Table already registered.
    STATUS_INVALID_PARAMETER        - Table not found / invalid request.

--*/

{
    
    BOOLEAN                             HandlerFound = FALSE;
    PSYSTEM_FIRMWARE_TABLE_HANDLER_NODE HandlerListCurrent = NULL;
    PSYSTEM_FIRMWARE_TABLE_HANDLER_NODE HandlerListNew = NULL;
    NTSTATUS                            Status = STATUS_SUCCESS;
    PSYSTEM_FIRMWARE_TABLE_HANDLER      SystemTableHandler = NULL;

    PAGED_CODE();

    if (PreviousMode != KernelMode) {

            Status = STATUS_PRIVILEGE_NOT_HELD;
    } else {

        if ((!SystemInformation) || 
           (SystemInformationLength < sizeof(SYSTEM_FIRMWARE_TABLE_HANDLER))) {

            Status = STATUS_INFO_LENGTH_MISMATCH;
        } else {

            //
            // Grab the resource to prevent state change via reentry.
            //

            KeEnterCriticalRegion();
            
            ExAcquireResourceExclusiveLite(&ExpFirmwareTableResource, 
                                           TRUE);
            
            SystemTableHandler = (PSYSTEM_FIRMWARE_TABLE_HANDLER)SystemInformation;
            
            EX_FOR_EACH_IN_LIST(SYSTEM_FIRMWARE_TABLE_HANDLER_NODE,
                                FirmwareTableProviderList,
                                &ExpFirmwareTableProviderListHead,
                                HandlerListCurrent) {

                if (HandlerListCurrent->SystemFWHandler.ProviderSignature == SystemTableHandler->ProviderSignature) {

                    HandlerFound = TRUE;
                    break;
                }
            }

            //
            // Handler was not found and this is a register request, so
            // allocate a new node and insert it into the list.
            //
            
            if ((!HandlerFound) && (SystemTableHandler->Register)) {

                //
                // This is a new Firmware table handler, allocate 
                // the space and add it to the list.
                //

                HandlerListNew = ExAllocatePoolWithTag(PagedPool, 
                                                       sizeof(SYSTEM_FIRMWARE_TABLE_HANDLER_NODE),
                                                       'TFRA');
                
                if (HandlerListNew) {

                    //
                    // Populate the new node.
                    //

                    HandlerListNew->SystemFWHandler.ProviderSignature = SystemTableHandler->ProviderSignature;

                    HandlerListNew->SystemFWHandler.FirmwareTableHandler = SystemTableHandler->FirmwareTableHandler;

                    HandlerListNew->SystemFWHandler.DriverObject = SystemTableHandler->DriverObject;

                    InitializeListHead(&HandlerListNew->FirmwareTableProviderList);
                    
                    //
                    // Grab a reference to the providers driverobject so that the
                    // driver does not get unloaded without our knowledge. The 
                    // handler must first be unregistered before unloading. 
                    //

                    ObReferenceObject((PVOID)HandlerListNew->SystemFWHandler.DriverObject);

                    //
                    // Update the LinkList.
                    //

                    InsertTailList(&ExpFirmwareTableProviderListHead, 
                                   &HandlerListNew->FirmwareTableProviderList);
                } else {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
                
            } else if ((HandlerFound) && (!(SystemTableHandler->Register))) {

            
                //
                // Check to make sure that a matching driver object was sent in.
                //

                if (HandlerListCurrent->SystemFWHandler.DriverObject == SystemTableHandler->DriverObject) {

                    //
                    // Remove the entry from the list.
                    //

                    RemoveEntryList(&HandlerListCurrent->FirmwareTableProviderList);
                    
                    //
                    // Deref the device object.
                    //

                    ObDereferenceObject((PVOID)HandlerListCurrent->SystemFWHandler.DriverObject);

                    //
                    // Free the unregistered list element.
                    //

                    ExFreePoolWithTag(HandlerListCurrent, 'TFRA');
                } else {

                    Status = STATUS_INVALID_PARAMETER;

                }
            } else if ((HandlerFound) && (SystemTableHandler->Register)) {

                //
                // A handler for this table has already been registered. return 
                // error.
                //

                Status = STATUS_OBJECT_NAME_EXISTS;
            } else {

                Status = STATUS_INVALID_PARAMETER;
            }
                
            ExReleaseResourceLite(&ExpFirmwareTableResource);

            KeLeaveCriticalRegion();
        }
    }
  
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\timer.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    timer.c

Abstract:

   This module implements the executive timer object. Functions are provided
   to create, open, cancel, set, and query timer objects.

--*/

#include "exp.h"

//
// Executive timer object structure definition.
//

typedef struct _ETIMER {
    KTIMER KeTimer;
    KAPC TimerApc;
    KDPC TimerDpc;
    LIST_ENTRY ActiveTimerListEntry;
    KSPIN_LOCK Lock;
    LONG Period;
    BOOLEAN ApcAssociated;
    BOOLEAN WakeTimer;
    LIST_ENTRY WakeTimerListEntry;
} ETIMER, *PETIMER;

//
// List of all timers which are set to wake.
//

KSPIN_LOCK ExpWakeTimerListLock;
LIST_ENTRY ExpWakeTimerList;

//
// Address of timer object type descriptor.
//

POBJECT_TYPE ExTimerObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for timer objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpTimerMapping = {
    STANDARD_RIGHTS_READ | TIMER_QUERY_STATE,
    STANDARD_RIGHTS_WRITE | TIMER_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    TIMER_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#pragma alloc_text(INIT, ExpTimerInitialization)
#pragma alloc_text(PAGE, NtCreateTimer)
#pragma alloc_text(PAGE, NtOpenTimer)
#pragma alloc_text(PAGE, NtQueryTimer)
#pragma alloc_text(PAGELK, ExGetNextWakeTime)

VOID
ExpTimerApcRoutine (
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the special APC routine that is called to remove
    a timer from the current thread's active timer list.

Arguments:

    Apc - Supplies a pointer to the APC object used to invoke this routine.

    NormalRoutine - Supplies a pointer to a pointer to the normal routine
        function that was specified when the APC was initialized.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

--*/

{

    ULONG DereferenceCount;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql1;

    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // Get address of executive timer object and the current thread object.
    //

    ExThread = PsGetCurrentThread();
    ExTimer = CONTAINING_RECORD(Apc, ETIMER, TimerApc);

    //
    // If the timer is still in the current thread's active timer list, then
    // remove it if it is not a periodic timer and set APC associated FALSE.
    // It is possible for the timer not to be in the current thread's active
    // timer list since the APC could have been delivered, and then another
    // thread could have set the timer again with another APC. This would
    // have caused the timer to be removed from the current thread's active
    // timer list.
    //
    // N. B. The spin locks for the timer and the active timer list must be
    //  acquired in the order: 1) timer lock, 2) thread list lock.
    //

    DereferenceCount = 1;
    ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
    ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
    if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
        if (ExTimer->Period == 0) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            DereferenceCount += 1;
        }

    } else {
        *NormalRoutine = (PKNORMAL_ROUTINE)NULL;
    }

    ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
    ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);
    ObDereferenceObjectEx(ExTimer, DereferenceCount);
    return;
}

VOID
ExpTimerDpcRoutine (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the DPC routine that is called when a timer expires that
    has an associated APC routine. Its function is to insert the associated
    APC into the target thread's APC queue.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Supplies a pointer to the executive timer that contains
        the DPC that caused this routine to be executed.

    SystemArgument1, SystemArgument2 - Supplies values that are not used by
        this routine.

Return Value:

    None.

--*/

{

    PETIMER ExTimer;
    BOOLEAN Inserted;
    PKTIMER KeTimer;

    //
    // Reference the timer so the APC is free to manipulate it.
    //
    // If the object is being deleted the delete routine will flush all
    // pending DPC's so the object won't be completely deleted until after
    // the following code completes.
    //

    ExTimer = (PETIMER)DeferredContext;

#if defined(_AMD64_)

    try {

#else

        UNREFERENCED_PARAMETER(Dpc);

#endif

        if (ObReferenceObjectSafe(ExTimer) == FALSE) {
            return;
        }

#if defined(_AMD64_)

        } except(KiKernelDpcFilter(Dpc, GetExceptionInformation())) {
            return;
        }

#endif

    //
    // If there is still an APC associated with the timer, then insert the APC
    // in target thread's APC queue. It is possible that the timer does not
    // have an associated APC. This can happen when the timer is set to expire
    // by a thread running on another processor just after the DPC has been
    // removed from the DPC queue, but before it has acquired the timer related
    // spin lock.
    //

    KeTimer = &ExTimer->KeTimer;
    Inserted = FALSE;
    ExAcquireSpinLockAtDpcLevel(&ExTimer->Lock);
    if (ExTimer->ApcAssociated) {
        Inserted = KeInsertQueueApc(&ExTimer->TimerApc,
                                    SystemArgument1,
                                    SystemArgument2,
                                    TIMER_APC_INCREMENT);
    }

    ExReleaseSpinLockFromDpcLevel(&ExTimer->Lock);

    //
    // If the timer APC wasn't inserted in the APC list, then release the
    // reference associated with it.
    //

    if (Inserted == FALSE) {
        ObDereferenceObject(ExTimer);
    }

    return;
}

VOID
ExpDeleteTimer (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for timer objects. Its function is
    to cancel the timer and free the spin lock associated with a timer.

Arguments:

    Object - Supplies a pointer to an executive timer object.

Return Value:

    None.

--*/

{

    PETIMER ExTimer;
    KIRQL OldIrql;

    //
    // Remove from wake list.
    //

    ExTimer = (PETIMER)Object;
    if (ExTimer->WakeTimerListEntry.Flink) {
        ExAcquireSpinLock(&ExpWakeTimerListLock, &OldIrql);
        if (ExTimer->WakeTimerListEntry.Flink) {
            RemoveEntryList(&ExTimer->WakeTimerListEntry);
            ExTimer->WakeTimerListEntry.Flink = NULL;
        }

        ExReleaseSpinLock(&ExpWakeTimerListLock, OldIrql);
    }

    //
    // Cancel the timer and free the spin lock associated with the timer.
    //

    KeCancelTimer(&ExTimer->KeTimer);

    //
    // Make sure there are no running DPC's associated with this timer
    // before it can get deleted completely.
    //

    KeFlushQueuedDpcs();
    return;
}

BOOLEAN
ExpTimerInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the timer object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the timer object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize the wake timer listhead and spinlock.
    //

    KeInitializeSpinLock(&ExpWakeTimerListLock);
    InitializeListHead(&ExpWakeTimerList);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Timer");

    //
    // Create timer object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpTimerMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(ETIMER);
    ObjectTypeInitializer.ValidAccessMask = TIMER_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteTimer;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExTimerObjectType);

    //
    // If the time object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
ExTimerRundown (
    VOID
    )

/*++

Routine Description:

    This function is called when a thread is about to be terminated to
    process the active timer list. It is assumed that APC's have been
    disabled for the subject thread, thus this code cannot be interrupted
    to execute an APC for the current thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LONG DereferenceCount;
    PETHREAD ExThread;
    PETIMER ExTimer;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;

    //
    // Process each entry in the active timer list.
    //

    ExThread = PsGetCurrentThread();
    ExAcquireSpinLock(&ExThread->ActiveTimerListLock, &OldIrql1);
    NextEntry = ExThread->ActiveTimerListHead.Flink;
    while (NextEntry != &ExThread->ActiveTimerListHead) {
        ExTimer = CONTAINING_RECORD(NextEntry, ETIMER, ActiveTimerListEntry);

        //
        // Increment the reference count on the object so that it cannot be
        // deleted, and then drop the active timer list lock.
        //
        // N. B. The object reference cannot fail and will acquire no mutexes.
        //

        ObReferenceObject(ExTimer);
        ExReleaseSpinLock(&ExThread->ActiveTimerListLock, OldIrql1);
        DereferenceCount = 1;

        //
        // Acquire the timer spin lock and reacquire the active time list spin
        // lock. If the timer is still in the current thread's active timer
        // list, then cancel the timer, remove the timer's DPC from the DPC
        // queue, remove the timer's APC from the APC queue, remove the timer
        // from the thread's active timer list, and set the associate APC
        // flag FALSE.
        //
        // N. B. The spin locks for the timer and the active timer list must be
        //       acquired in the order: 1) timer lock, 2) thread list lock.
        //

        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
        ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
        if ((ExTimer->ApcAssociated) && (&ExThread->Tcb == ExTimer->TimerApc.Thread)) {
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            if (KeRemoveQueueApc(&ExTimer->TimerApc)) {
                DereferenceCount += 1;
            }

            DereferenceCount += 1;
        }

        ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);
        ObDereferenceObjectEx(ExTimer, DereferenceCount);

        //
        // Raise IRQL to DISPATCH_LEVEL and reacquire active timer list
        // spin lock.
        //

        ExAcquireSpinLock(&ExThread->ActiveTimerListLock, &OldIrql1);
        NextEntry = ExThread->ActiveTimerListHead.Flink;
    }

    ExReleaseSpinLock(&ExThread->ActiveTimerListLock, OldIrql1);
    return;
}

NTSTATUS
NtCreateTimer (
    __out PHANDLE TimerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in TIMER_TYPE TimerType
    )

/*++

Routine Description:

    This function creates an timer object and opens a handle to the object with
    the specified desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    DesiredAccess - Supplies the desired types of access for the timer object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    TimerType - Supplies the type of the timer which can be synchronization
        or notification. 

Return Value:

    NTSTATUS.

--*/

{

    PETIMER ExTimer;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if ((TimerType != NotificationTimer) &&
        (TimerType != SynchronizationTimer)) {

        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(TimerHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Allocate timer object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExTimerObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(ETIMER),
                            0,
                            0,
                            &ExTimer);

    //
    // If the timer object was successfully allocated, then initialize the
    // timer object and attempt to insert the time object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeDpc(&ExTimer->TimerDpc,
                        ExpTimerDpcRoutine,
                        (PVOID)ExTimer);

        KeInitializeTimerEx(&ExTimer->KeTimer, TimerType);
        KeInitializeSpinLock(&ExTimer->Lock);
        ExTimer->ApcAssociated = FALSE;
        ExTimer->WakeTimer = FALSE;
        ExTimer->WakeTimerListEntry.Flink = NULL;
        Status = ObInsertObject((PVOID)ExTimer,
                                NULL,
                                DesiredAccess,
                                0,
                                NULL,
                                &Handle);

        //
        // If the timer object was successfully inserted in the current
        // process' handle table, then attempt to write the timer object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *TimerHandle = Handle;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *TimerHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenTimer (
    __out PHANDLE TimerHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an timer object with the specified
    desired access.

Arguments:

    TimerHandle - Supplies a pointer to a variable that will receive the
        timer object handle.

    DesiredAccess - Supplies the desired types of access for the timer object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(TimerHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the timer object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExTimerObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the timer object
    // handle value. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *TimerHandle = Handle;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            *TimerHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCancelTimer (
    __in HANDLE TimerHandle,
    __out_opt PBOOLEAN CurrentState
    )

/*++

Routine Description:

    This function cancels a timer object.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    CurrentState - Supplies an optional pointer to a variable that will
        receive the current state of the timer object.

Return Value:

    NTSTATUS.

--*/

{

    ULONG DereferenceCount;
    PETHREAD ExThread;
    PETIMER ExTimer;
    KIRQL OldIrql1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe current state address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (ARGUMENT_PRESENT(CurrentState) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteBoolean(CurrentState);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_MODIFY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       &ExTimer,
                                       NULL);

    //
    // If the reference was successful, then cancel the timer object,
    // dereference the timer object, and write the current state value
    // if specified. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the current state value,
    // an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        DereferenceCount = 1;
        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            if (KeRemoveQueueApc(&ExTimer->TimerApc)) {
                DereferenceCount += 1;
            }

            DereferenceCount += 1;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
        }

        if (ExTimer->WakeTimerListEntry.Flink) {
            ExAcquireSpinLockAtDpcLevel(&ExpWakeTimerListLock);

            //
            // Check again since wait next time might have removed the timer.
            //

            if (ExTimer->WakeTimerListEntry.Flink) {
                RemoveEntryList(&ExTimer->WakeTimerListEntry);
                ExTimer->WakeTimerListEntry.Flink = NULL;
            }

            ExReleaseSpinLockFromDpcLevel(&ExpWakeTimerListLock);
        }

        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);

        //
        // Read current state of timer, dereference timer object, and set
        // current state.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);
        ObDereferenceObjectEx(ExTimer, DereferenceCount);
        if (ARGUMENT_PRESENT(CurrentState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *CurrentState = State;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *CurrentState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryTimer (
    __in HANDLE TimerHandle,
    __in TIMER_INFORMATION_CLASS TimerInformationClass,
    __out_bcount(TimerInformationLength) PVOID TimerInformation,
    __in ULONG TimerInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the state of an timer object and returns the
    requested information in the specified record structure.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    TimerInformationClass - Supplies the class of information being requested.

    TimerInformation - Supplies a pointer to a record that is to receive the
        requested information.

    TimerInformationLength - Supplies the length of the record that is to
        receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PETIMER ExTimer;
    PTIMER_BASIC_INFORMATION Information;
    PKTIMER KeTimer;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;
    LARGE_INTEGER TimeToGo;

    //
    // Check argument validity.
    //

    if (TimerInformationClass != TimerBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (TimerInformationLength != sizeof(TIMER_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteSmallStructure(TimerInformation,
                                        sizeof(TIMER_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_QUERY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       &ExTimer,
                                       NULL);

    //
    // If the reference was successful, then read the current state,
    // compute the time remaining, dereference the timer object, fill in
    // the information structure, and return the length of the information
    // structure if specified. If the write of the time information or the
    // return length fails, then do not report an error. When the caller
    // accesses the information structure or the length, an violation will
    // occur.
    //

    if (NT_SUCCESS(Status)) {
        Information = TimerInformation;
        KeTimer = &ExTimer->KeTimer;
        State = KeReadStateTimer(KeTimer);
        KiQueryInterruptTime(&TimeToGo);
        TimeToGo.QuadPart = KeTimer->DueTime.QuadPart - TimeToGo.QuadPart;
        ObDereferenceObject(ExTimer);
        if (PreviousMode != KernelMode) {
            try {
                Information->TimerState = State;
                Information->RemainingTime = TimeToGo;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(TIMER_BASIC_INFORMATION);
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            Information->TimerState = State;
            Information->RemainingTime = TimeToGo;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(TIMER_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetTimer (
    __in HANDLE TimerHandle,
    __in PLARGE_INTEGER DueTime,
    __in_opt PTIMER_APC_ROUTINE TimerApcRoutine,
    __in_opt PVOID TimerContext,
    __in BOOLEAN WakeTimer,
    __in_opt LONG Period,
    __out_opt PBOOLEAN PreviousState
    )

/*++

Routine Description:

    This function sets an timer object to a Not-Signaled state and sets the timer
    to expire at the specified time.

Arguments:

    TimerHandle - Supplies a handle to an timer object.

    DueTime - Supplies a pointer to absolute of relative time at which the
        timer is to expire.

    TimerApcRoutine - Supplies an optional pointer to a function which is to
        be executed when the timer expires. If this parameter is not specified,
        then the TimerContext parameter is ignored.

    TimerContext - Supplies an optional pointer to an arbitrary data structure
        that will be passed to the function specified by the TimerApcRoutine
        parameter. This parameter is ignored if the TimerApcRoutine parameter
        is not specified.

    WakeTimer - Supplies a boolean value that specifies whether the timer
        wakes computer operation if sleeping.

    Period - Supplies an optional repetitive period for the timer.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the timer object.

Return Value:

    NTSTATUS.

--*/

{

    ULONG DereferenceCount;
    PETHREAD ExThread;
    PETIMER ExTimer;
    LARGE_INTEGER ExpirationTime;
    KIRQL OldIrql1;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN State;
    NTSTATUS Status;

    //
    // Check argument validity.
    //

    if (Period < 0) {
        return STATUS_INVALID_PARAMETER_6;
    }

    //
    // Get previous processor mode and probe previous state address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            if (ARGUMENT_PRESENT(PreviousState)) {
                ProbeForWriteBoolean(PreviousState);
            }

            ProbeForReadSmallStructure(DueTime, sizeof(LARGE_INTEGER), sizeof(ULONG));
            ExpirationTime = *DueTime;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

    } else {
        ExpirationTime = *DueTime;
    }

    //
    // Reference timer object by handle.
    //

    Status = ObReferenceObjectByHandle(TimerHandle,
                                       TIMER_MODIFY_STATE,
                                       ExTimerObjectType,
                                       PreviousMode,
                                       &ExTimer,
                                       NULL);

    //
    // If the wake timer flag is set, return the appropriate informational
    // success status code.
    //

    if (NT_SUCCESS(Status) && WakeTimer && !PoWakeTimerSupported()) {
        Status = STATUS_TIMER_RESUME_IGNORED;
    }

    //
    // If the reference was successful, then cancel the timer object, set
    // the timer object, dereference time object, and write the previous
    // state value if specified. If the write of the previous state value
    // fails, then do not report an error. When the caller attempts to
    // access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        DereferenceCount = 1;
        ExAcquireSpinLock(&ExTimer->Lock, &OldIrql1);
        if (ExTimer->ApcAssociated) {
            ExThread = CONTAINING_RECORD(ExTimer->TimerApc.Thread, ETHREAD, Tcb);
            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            RemoveEntryList(&ExTimer->ActiveTimerListEntry);
            ExTimer->ApcAssociated = FALSE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
            KeCancelTimer(&ExTimer->KeTimer);
            KeRemoveQueueDpc(&ExTimer->TimerDpc);
            if (KeRemoveQueueApc(&ExTimer->TimerApc)) {
                DereferenceCount += 1;
            }

            DereferenceCount += 1;

        } else {
            KeCancelTimer(&ExTimer->KeTimer);
        }

        //
        // Read the current state of the timer.
        //

        State = KeReadStateTimer(&ExTimer->KeTimer);

        //
        // If this is a wake timer ensure it's on the wake timer list.
        //

        ExTimer->WakeTimer = WakeTimer;
        ExAcquireSpinLockAtDpcLevel(&ExpWakeTimerListLock);
        if (WakeTimer) {
            if (!ExTimer->WakeTimerListEntry.Flink) {
                InsertTailList(&ExpWakeTimerList, &ExTimer->WakeTimerListEntry);
            }

        } else {
            if (ExTimer->WakeTimerListEntry.Flink) {
                RemoveEntryList(&ExTimer->WakeTimerListEntry);
                ExTimer->WakeTimerListEntry.Flink = NULL;
            }
        }

        ExReleaseSpinLockFromDpcLevel(&ExpWakeTimerListLock);

        //
        // If an APC routine is specified, then initialize the APC, acquire the
        // thread's active time list lock, insert the timer in the thread's
        // active timer list, set the timer with an associated DPC, and set the
        // associated APC flag TRUE. Otherwise set the timer without an
        // associated DPC, and set the associated APC flag FALSE.
        //

        ExTimer->Period = Period;
        if (ARGUMENT_PRESENT(TimerApcRoutine)) {
            ExThread = PsGetCurrentThread();
            KeInitializeApc(&ExTimer->TimerApc,
                            &ExThread->Tcb,
                            CurrentApcEnvironment,
                            ExpTimerApcRoutine,
                            (PKRUNDOWN_ROUTINE)NULL,
                            (PKNORMAL_ROUTINE)TimerApcRoutine,
                            PreviousMode,
                            TimerContext);

            ExAcquireSpinLockAtDpcLevel(&ExThread->ActiveTimerListLock);
            InsertTailList(&ExThread->ActiveTimerListHead,
                           &ExTimer->ActiveTimerListEntry);

            ExTimer->ApcAssociated = TRUE;
            ExReleaseSpinLockFromDpcLevel(&ExThread->ActiveTimerListLock);
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         &ExTimer->TimerDpc);

            DereferenceCount -= 1;

        } else {
            KeSetTimerEx(&ExTimer->KeTimer,
                         ExpirationTime,
                         Period,
                         NULL);
        }

        ExReleaseSpinLock(&ExTimer->Lock, OldIrql1);

        //
        // Dereference the object as appropriate.
        //

        if (DereferenceCount > 0) {
            ObDereferenceObjectEx(ExTimer, DereferenceCount);
        }

        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

VOID
ExGetNextWakeTime (
    OUT PULONGLONG DueTime,
    OUT PTIME_FIELDS TimeFields,
    OUT PVOID *TimerObject
    )

{

    ULONGLONG BestDueTime;
    LARGE_INTEGER CmosTime;
    PETIMER BestTimer;
    PETIMER ExTimer;
    ULONGLONG InterruptTime;
    PLIST_ENTRY Link;
    KIRQL OldIrql;
    LARGE_INTEGER SystemTime;
    ULONGLONG TimerDueTime;

    ExAcquireSpinLock(&ExpWakeTimerListLock, &OldIrql);
    BestDueTime = 0;
    BestTimer = NULL;
    Link = ExpWakeTimerList.Flink;
    while (Link != &ExpWakeTimerList) {
        ExTimer = CONTAINING_RECORD(Link, ETIMER, WakeTimerListEntry);
        Link = Link->Flink;
        if (ExTimer->WakeTimer) {
            TimerDueTime = KeQueryTimerDueTime(&ExTimer->KeTimer);
            TimerDueTime = 0 - TimerDueTime;

            //
            // Is this timers due time closer?
            //

            if (TimerDueTime > BestDueTime) {
                BestDueTime = TimerDueTime;
                BestTimer = ExTimer;
            }

        } else {

            //
            // Timer is not an active wake timer, remove it
            //

            RemoveEntryList(&ExTimer->WakeTimerListEntry);
            ExTimer->WakeTimerListEntry.Flink = NULL;
        }
    }

    ExReleaseSpinLock(&ExpWakeTimerListLock, OldIrql);
    if (BestDueTime) {

        //
        // Convert time to time fields.
        //

        KeQuerySystemTime (&SystemTime);
        InterruptTime = KeQueryInterruptTime ();
        BestDueTime = 0 - BestDueTime;
        SystemTime.QuadPart += BestDueTime - InterruptTime;

        //
        // Many system alarms are only good to 1 second resolution.
        // Add one sceond to the target time so that the timer is really
        // elasped if this is the wake event.
        //

        SystemTime.QuadPart += 10000000;
        ExSystemTimeToLocalTime(&SystemTime,&CmosTime);
        RtlTimeToTimeFields(&CmosTime, TimeFields);
    }

    *DueTime = BestDueTime;
    *TimerObject = BestTimer;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\resource.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.


Environment:

    Substantially rewritten to make fastlock optimizations portable
    across all platforms and to improve the algorithms used to be
    perfectly synchronized.

--*/

#include "exp.h"
#pragma hdrstop
#include "nturtl.h"

//
// Define local macros to test resource state.
//

#define IsExclusiveWaiting(a) ((a)->NumberOfExclusiveWaiters != 0)
#define IsSharedWaiting(a) ((a)->NumberOfSharedWaiters != 0)
#define IsOwnedExclusive(a) (((a)->Flag & ResourceOwnedExclusive) != 0)
#define IsBoostAllowed(a) (((a)->Flag & DisablePriorityBoost) == 0)

//
// Define priority boost flags.
//

#define DisablePriorityBoost 0x08

LARGE_INTEGER ExShortTime = {(ULONG)(-10 * 1000 * 10), -1}; // 10 milliseconds

#define EX_RESOURCE_CHECK_FREES   0x1
#define EX_RESOURCE_CHECK_ORPHANS 0x2

ULONG ExResourceCheckFlags = EX_RESOURCE_CHECK_FREES|EX_RESOURCE_CHECK_ORPHANS;


//
// Define resource assertion macro.
//

#if DBG

VOID
ExpAssertResource(
    IN PERESOURCE Resource
    );

#define ASSERT_RESOURCE(_Resource) ExpAssertResource(_Resource)

#else

#define ASSERT_RESOURCE(_Resource)

#endif

//
// Define locking primitives. 
// On UP systems, fastlocks are used.
// On MP systems, a queued spinlock is used.
//

#if defined(NT_UP)
#define EXP_LOCK_HANDLE KIRQL
#define PEXP_LOCK_HANDLE PKIRQL
#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_)  UNREFERENCED_PARAMETER(_plockhandle_); ExAcquireFastLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) ExReleaseFastLock(&(_resource_)->SpinLock, *(_plockhandle_))
#define EXP_LOCK_RESOURCE_RAISE   EXP_LOCK_RESOURCE
#define EXP_UNLOCK_RESOURCE_RAISE EXP_UNLOCK_RESOURCE
#else

#define EXP_LOCK_HANDLE KLOCK_QUEUE_HANDLE
#define PEXP_LOCK_HANDLE PKLOCK_QUEUE_HANDLE

#if defined(_AMD64_)

FORCEINLINE
VOID
EXP_LOCK_RESOURCE (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )
{

#if DBG
    LockHandle->OldIrql = DISPATCH_LEVEL;
#else
    UNREFERENCED_PARAMETER(LockHandle);
#endif

    do {
        _disable();
        if (InterlockedBitTestAndSet64((LONG64 *)&Resource->SpinLock,0) == FALSE) {
            PrefetchForWrite(&Resource->ActiveCount);
            break;
        }
        _enable();
        while (*(LONG64 volatile *)&Resource->SpinLock != 0) {
            KeYieldProcessor();
        }
    } while (1);
}

FORCEINLINE
EXP_UNLOCK_RESOURCE (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )
{
    UNREFERENCED_PARAMETER(LockHandle);

    InterlockedAnd64((LONG64 *)&Resource->SpinLock,0);
    _enable();
}

FORCEINLINE
VOID
EXP_LOCK_RESOURCE_RAISE (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )
{
    LockHandle->OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    while (InterlockedBitTestAndSet64((LONG64 *)&Resource->SpinLock,0) != FALSE) {
        while (*(LONG64 volatile *)&Resource->SpinLock != 0) {
            KeYieldProcessor();
        }
    }
}

FORCEINLINE
EXP_UNLOCK_RESOURCE_RAISE (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )
{
    InterlockedAnd64((LONG64 *)&Resource->SpinLock,0);
    KeLowerIrql(LockHandle->OldIrql);
}

#else

#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_) KeAcquireInStackQueuedSpinLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) KeReleaseInStackQueuedSpinLock(_plockhandle_)

#define EXP_LOCK_RESOURCE_RAISE   EXP_LOCK_RESOURCE
#define EXP_UNLOCK_RESOURCE_RAISE EXP_UNLOCK_RESOURCE

#endif
#endif

//
// Define private function prototypes.
//

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    );

VOID
ExpExpandResourceOwnerTable (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    );

POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    );

POWNER_ENTRY
FASTCALL
ExpFindEmptyEntry(
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    );



//
// Resource wait time out value.
//

LARGE_INTEGER ExpTimeout;

//
// Consecutive time outs before message.  Note this is registry-settable.
//

ULONG ExResourceTimeoutCount = 648000;

//
// Global spinlock to guard access to resource lists.
//

extern ALIGNED_SPINLOCK ExpResourceSpinLock;

//
// Resource list used to record all resources in the system.
//

LIST_ENTRY ExpSystemResourcesList;

#define ExpIncrementCounter(Member)



#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpResourceInitialization)
#pragma alloc_text(PAGELK, ExQuerySystemLockInformation)
#endif

//
// Resource strict verification (checked builds only)
//
// When acquiring a resource while running in a thread that is not a system
// thread and runs at passive level we need to disable kernel APCs first
// (KeEnterCriticalRegion()). Otherwise any user mode code can call
// NtSuspendThread() which is implemented using kernel APCs and can
// suspend the thread while having a resource acquired.
// This will potentially deadlock the whole system.
//

#if DBG

ULONG ExResourceStrict = 1;

VOID
ExCheckIfKernelApcsShouldBeDisabled (
    IN KIRQL Irql,
    IN PVOID Resource,
    IN PKTHREAD Thread)
{
    if ((ExResourceStrict == 0) ||
        (Irql >= APC_LEVEL) ||
        (IS_SYSTEM_THREAD((PETHREAD)Thread)) ||
        (Thread->CombinedApcDisable != 0)) {

        return;
    }

    DbgPrint ("EX: resource: APCs still enabled before resource %p acquire !!!\n", Resource);
    DbgBreakPoint ();
}

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread) \
            ExCheckIfKernelApcsShouldBeDisabled (Irql, Resource, Thread);

#else

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread)

#endif // DBG


BOOLEAN
ExpResourceInitialization(
    VOID
    )

/*++

Routine Description:

    This function initializes global data during system initialization.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE

--*/

{
    //
    // Initialize resource timeout value, the system resource listhead,
    // and the resource spinlock.
    //

    ExpTimeout.QuadPart = Int32x32To64(4 * 1000, -10000);
    InitializeListHead(&ExpSystemResourcesList);
    KeInitializeSpinLock(&ExpResourceSpinLock);

    return TRUE;
}

VOID
ExpAllocateExclusiveWaiterEvent (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the exclusive waiter event
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKEVENT Event;

    //
    // Allocate an exclusive wait event and retry the acquire operation.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Event = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(KEVENT),
                                      'vEeR');

        if (Event != NULL) {
            KeInitializeEvent(Event, SynchronizationEvent, FALSE);
            if (InterlockedCompareExchangePointer(&Resource->ExclusiveWaiters,
                                                  Event,
                                                  NULL) != NULL) {

                ExFreePool(Event);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

VOID
ExpAllocateSharedWaiterSemaphore (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the shared waiter semaphore
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKSEMAPHORE Semaphore;

    //
    // Allocate and initialize a shared wait semaphore for the specified
    // resource.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Semaphore = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(KSEMAPHORE),
                                          'eSeR');

        if (Semaphore != NULL) {
            KeInitializeSemaphore(Semaphore, 0, MAXLONG);
            if (InterlockedCompareExchangePointer(&Resource->SharedWaiters,
                                                  Semaphore,
                                                  NULL) != NULL) {
                ExFreePool(Semaphore);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

NTSTATUS
ExInitializeResourceLite(
    __out PERESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // Initialize the specified resource.
    //
    // N.B. All fields are initialized to zero (NULL pointers) except
    //      the list entry and spinlock.
    //

    RtlZeroMemory(Resource, sizeof(ERESOURCE));
    KeInitializeSpinLock(&Resource->SpinLock);

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {
        Resource->CreatorBackTraceIndex = RtlLogStackBackTrace();
    }else {
        Resource->CreatorBackTraceIndex = 0;
    }

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    InsertTailList (&ExpSystemResourcesList, &Resource->SystemResourcesList);

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return STATUS_SUCCESS;
}

NTSTATUS
ExReinitializeResourceLite(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine reinitializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{

    PKEVENT Event;
    ULONG Index;
    POWNER_ENTRY OwnerTable;
    PKSEMAPHORE Semaphore;
    ULONG TableSize;

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // If the resource has an owner table, then zero the owner table.
    //

    OwnerTable = Resource->OwnerTable;
    if (OwnerTable != NULL) {
        TableSize = OwnerTable->TableSize;
        for (Index = 1; Index < TableSize; Index += 1) {
            OwnerTable[Index].OwnerThread = 0;
            OwnerTable[Index].OwnerCount = 0;
        }
    }

    //
    // Set the active count and flags to zero.
    //

    Resource->ActiveCount = 0;
    Resource->Flag = 0;

    //
    // If the resource has a shared waiter semaphore, then reinitialize
    // it.
    //

    Semaphore = Resource->SharedWaiters;
    if (Semaphore != NULL) {
        KeInitializeSemaphore(Semaphore, 0, MAXLONG);
    }

    //
    // If the resource has a exclusive waiter event, then reinitialize
    // it.
    //

    Event = Resource->ExclusiveWaiters;
    if (Event != NULL) {
        KeInitializeEvent(Event, SynchronizationEvent, FALSE);
    }

    //
    // Initialize the builtin owner table.
    //

    Resource->OwnerThreads[0].OwnerThread = 0;
    Resource->OwnerThreads[0].OwnerCount = 0;
    Resource->OwnerThreads[1].OwnerThread = 0;
    Resource->OwnerThreads[1].OwnerCount = 0;

    //
    // Set the contention count, number of shared waiters, and number
    // of exclusive waiters to zero.
    //

    Resource->ContentionCount = 0;
    Resource->NumberOfSharedWaiters = 0;
    Resource->NumberOfExclusiveWaiters = 0;

    return STATUS_SUCCESS;
}

VOID
ExDisableResourceBoostLite(
    __in PERESOURCE Resource
    )

/*++

Routine Description:

    This routine disables priority inversion boosting for the specified
    resource.

Arguments:

    Resource - Supplies a pointer to the resource for which priority
        boosting is disabled.

Return Value:

    None.

--*/

{

    EXP_LOCK_HANDLE LockHandle;

    ASSERT_RESOURCE(Resource);

    //
    // Disable priority boosts for the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    Resource->Flag |= DisablePriorityBoost;

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

BOOLEAN
ExAcquireResourceExclusiveLite(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for exclusive access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(ExclusiveAcquire);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, there is either a shared owner or
    // an exclusive owner.
    //

retry:
    if (Resource->ActiveCount != 0) {

        //
        // The resource is either owned exclusive or shared.
        //
        // If the resource is owned exclusive and the current thread is the
        // owner, then increment the recursion count.
        //

        if (IsOwnedExclusive(Resource) &&
            (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            Result = TRUE;

        } else {

            //
            // The resource is either owned exclusive by some other thread,
            // or owned shared.
            //
            // If wait is not specified, then return that the resource was
            // not acquired. Otherwise, wait for exclusive access to the
            // resource to be granted.
            //

            if (Wait == FALSE) {
                Result = FALSE;

            } else {

                //
                // If the exclusive wait event has not yet been allocated,
                // then the long path code must be taken.
                //

                if (Resource->ExclusiveWaiters == NULL) {
                    ExpAllocateExclusiveWaiterEvent(Resource, &LockHandle);
                    goto retry;
                }

                //
                // Wait for exclusive access to the resource to be granted
                // and set the owner thread.
                //

                Resource->NumberOfExclusiveWaiters += 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                ExpWaitForResource(Resource, Resource->ExclusiveWaiters);

                //
                // N.B. It is "safe" to store the owner thread without
                //      obtaining any locks since the thread has already
                //      been granted exclusive ownership.
                //

                Resource->OwnerThreads[0].OwnerThread = (ERESOURCE_THREAD)PsGetCurrentThread();
                return TRUE;
            }
        }

    } else {

        //
        // The resource is not owned.
        //

        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

PVOID
ExEnterCriticalRegionAndAcquireResourceExclusive(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    The routine enters a critical region and acquires the specified resource
    for exclusive access.

    N.B. This is a win32k accelerator routine.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired for
        exclusive access.

Return Value:

    The address of the current win32 thread is returned as the function value.

--*/

{
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(Resource, TRUE);
    return _PsGetCurrentThread()->Tcb.Win32Thread;
}

BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    The routine attempts to acquire the specified resource for exclusive
    access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Attempt to acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, if the resource is owned exclusive
    // and the current thread is the owner, then access to the resource can
    // be immediately granted. Otherwise, access cannot be granted.
    //

    Result = FALSE;
    if (Resource->ActiveCount == 0) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;

    } else if (IsOwnedExclusive(Resource) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->OwnerThreads[0].OwnerCount += 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

BOOLEAN
ExAcquireResourceSharedLite(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for shared access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(SharedFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindEmptyEntry(Resource, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access if there are no exclusive waiters.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // If there are no exclusive waiters, then grant shared access
        // to the resource. Otherwise, wait for the resource to become
        // available.
        //

        if (IsExclusiveWaiting(Resource) == FALSE) {
            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is either owned exclusive by some other thread, or
    // owned shared by some other threads, but there is an exclusive
    // waiter and the current thread does not already have shared access
    // to the resource.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

PVOID
ExEnterCriticalRegionAndAcquireResourceShared(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine enters a critical region and acquires the specified resource
    for shared access.

     N.B. This is a win32k accelerator routine.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired for shared
        access.

Return Value:

    The address of the current win32 thread is returned as the function value.

--*/

{

    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(Resource, TRUE);
    return _PsGetCurrentThread()->Tcb.Win32Thread;
}

BOOLEAN
ExAcquireSharedStarveExclusive(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    )
/*++

Routine Description:

    This routine acquires the specified resource for shared access and
    does not wait for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ExpIncrementCounter(StarveFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindEmptyEntry(Resource, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access to the current thread.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Grant the current thread shared access to the resource.
        //

        OwnerEntry->OwnerThread = CurrentThread;
        OwnerEntry->OwnerCount = 1;
        Resource->ActiveCount += 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

BOOLEAN
ExAcquireSharedWaitForExclusive(
    __inout PERESOURCE Resource,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This routine acquires the specified resource for shared access, but
    waits for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    ExpIncrementCounter(WaitForExclusive);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindEmptyEntry(Resource, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If there is an exclusive waiter, then wait for the exclusive
        // waiter to gain access to the resource, then acquire the resource
        // shared without regard to exclusive waiters. Otherwise, if the
        // current thread already has acquired the resource for shared access,
        // then increment the recursion count. Otherwise grant shared access
        // to the current thread.
        //

        if (IsExclusiveWaiting(Resource)) {

            //
            // The resource is shared, but there is an exclusive waiter.
            //
            // It doesn't matter if this thread is already one of the shared
            // owner(s) - if TRUE is specified, this thread must block - an APC
            // will release the resource to unjam things and callers count on
            // this behavior.
            //

            //
            // If wait is not specified, then return that the resource was
            // not acquired.
            //

            if (Wait == FALSE) {
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return FALSE;
            }

            //
            // If the shared wait semaphore has not yet been allocated, then
            // allocate and initialize it.
            //

            if (Resource->SharedWaiters == NULL) {
                ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
                goto retry;
            }

            //
            // Increment the number of shared waiters and wait for shared
            // access to the resource to be granted to some other set of
            // threads, and then acquire the resource shared without regard
            // to exclusive access.
            //
            // N.B. The resource is left in a state such that the calling
            //      thread does not have a reference in the owner table
            //      for the requested access even though the active count
            //      is incremented when control is returned. However, the
            //      resource is owned shared at this point, so an owner
            //      entry can simply be allocated and the owner count set
            //      to one.
            //

            Resource->NumberOfSharedWaiters += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            ExpWaitForResource(Resource, Resource->SharedWaiters);

            //
            // Reacquire the resource spin lock, allocate an owner entry,
            // and initialize the owner count to one. The active count
            // was already incremented when shared access was granted.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            do {
            } while ((OwnerEntry = ExpFindCurrentThread(Resource,
                                                        CurrentThread,
                                                        &LockHandle)) == NULL);

            ASSERT(IsOwnedExclusive(Resource) == FALSE);
            ASSERT(Resource->ActiveCount > 0);
            ASSERT(OwnerEntry->OwnerThread != CurrentThread);

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;

        } else {
            OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
            if (OwnerEntry == NULL) {
                goto retry;
            }

            if (OwnerEntry->OwnerThread == CurrentThread) {
                OwnerEntry->OwnerCount += 1;

                ASSERT(OwnerEntry->OwnerCount != 0);

                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return TRUE;
            }

            //
            // Grant the current thread shared access to the resource.
            //

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then allocate
    // and initialize it.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

PVOID
ExEnterCriticalRegionAndAcquireSharedWaitForExclusive(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine acquires the specified resource for shared access, but
    waits for any pending exclusive owners.

    N.B. This is a win32k accelerator routine.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    The address of the current win32 thread is returned as the function value..

--*/

{

    KeEnterCriticalRegion();
    ExAcquireSharedWaitForExclusive(Resource, TRUE);
    return _PsGetCurrentThread()->Tcb.Win32Thread;
}

VOID
FASTCALL
ExReleaseResourceLite(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine releases the specified resource for the current thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

#if DBG
        //
        // This can only be enabled in checked builds because this (unusual)
        // behavior might have worked in earlier releases of NT.  However,
        // in the checked builds, this can be enabled because callers really
        // should convert to using ExReleaseResourceForThreadLite instead.
        //

        if (Resource->OwnerThreads[0].OwnerThread != CurrentThread) {
            KeBugCheckEx(RESOURCE_NOT_OWNED,
                         (ULONG_PTR)Resource,
                         (ULONG_PTR)CurrentThread,
                         (ULONG_PTR)Resource->OwnerTable,
                         0x1);
        }
#endif

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);
                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            OwnerEntry = Resource->OwnerTable;

            if (OwnerEntry == NULL) {
                KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x2);
            }

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
FASTCALL
ExReleaseResourceAndLeaveCriticalRegion(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine releases the specified resource for the current thread,
    decrements the recursion count, and leave a critical region.. If the
    count reaches zero, then the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

Return Value:

    None.

--*/

{
    ExReleaseResourceLite(Resource);
    KeLeaveCriticalRegion();
    return;
}

VOID
ExReleaseResourceForThreadLite(
    __inout PERESOURCE Resource,
    __in ERESOURCE_THREAD CurrentThread
    )

/*++

Routine Description:

    This routine release the specified resource for the specified thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    Thread - Supplies the thread that originally acquired the resource.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    ASSERT(CurrentThread != 0);

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {

            //
            // If the specified current thread is an owner address (low
            // bits are nonzero), then set the hint index to the first
            // entry. Otherwise, set the hint index from the owner thread.
            //

            Index = 1;
            if (((ULONG)CurrentThread & 3) == 0) {
                Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            }

            OwnerEntry = Resource->OwnerTable;

            ASSERT(OwnerEntry != NULL);

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExSetResourceOwnerPointer(
    __inout PERESOURCE Resource,
    __in PVOID OwnerPointer
    )

/*++

Routine Description:

    This routine locates the owner entry for the current thread and stores
    the specified owner address as the owner thread. Subsequent to calling
    this routine, the only routine which may be called for this resource is
    ExReleaseResourceForThreadLite, supplying the owner address as the "thread".

    Owner addresses must obey the following rules:

        They must be a unique pointer to a structure allocated in system space,
        and they must point to a structure which remains allocated until after
        the call to ExReleaseResourceForThreadLite. This is to eliminate aliasing
        with a thread or other owner address.

        The low order two bits of the owner address must be set by the caller,
        so that other routines in the resource package can distinguish owner
        address from thread addresses.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    OwnerPointer - Supplies a pointer to an allocated structure with the low
        order two bits set.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, ExistingOwnerEntry;

    ASSERT((OwnerPointer != 0) && (((ULONG_PTR)OwnerPointer & 3) == 3));

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // If the resource is exclusively owned, then it is the first owner entry.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Set the owner address.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        Resource->OwnerThreads[0].OwnerThread = (ULONG_PTR)OwnerPointer;

    //
    //  For shared access we have to search for the current thread to set
    //  the owner address.
    //

    } else {

        ExistingOwnerEntry = ExpFindCurrentThread(Resource, (ERESOURCE_THREAD)OwnerPointer, NULL);

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, NULL);

        if (OwnerEntry == NULL) {
            KeBugCheckEx(RESOURCE_NOT_OWNED,
                         (ULONG_PTR)Resource,
                         (ULONG_PTR)CurrentThread,
                         (ULONG_PTR)Resource->OwnerTable,
                         0x3);
        }

        if (ExistingOwnerEntry != NULL) {
            ExistingOwnerEntry->OwnerCount += OwnerEntry->OwnerCount;
            OwnerEntry->OwnerCount = 0;
            OwnerEntry->OwnerThread = 0;
            ASSERT (Resource->ActiveCount >= 2);
            Resource->ActiveCount -= 1;
        } else {
            OwnerEntry->OwnerThread = (ERESOURCE_THREAD)OwnerPointer;
        }

    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExConvertExclusiveToSharedLite(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine converts the specified resource from acquired for exclusive
    access to acquired for shared access.

Arguments:

    Resource - Supplies a pointer to the resource to acquire for shared access. it

Return Value:

    None.

--*/

{

    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    ASSERT(IsOwnedExclusive(Resource));
    ASSERT(Resource->OwnerThreads[0].OwnerThread == (ERESOURCE_THREAD)PsGetCurrentThread());

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Convert the granted access from exclusive to shared.
    //

    Resource->Flag &= ~ResourceOwnedExclusive;

    //
    // If there are any shared waiters, then grant them shared access.
    //

    if (IsSharedWaiting(Resource)) {
        Number = Resource->NumberOfSharedWaiters;
        Resource->ActiveCount = (SHORT)(Resource->ActiveCount + Number);
        Resource->NumberOfSharedWaiters = 0;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
        return;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

NTSTATUS
ExDeleteResourceLite(
    __inout PERESOURCE Resource
    )

/*++

Routine Description:

    This routine deallocates any pool allocated to support the specified
    resource.


Arguments:

    Resource - Supplies a pointer to the resource whose allocated pool
        is freed.

Return Value:

    STATUS_SUCCESS.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(IsSharedWaiting(Resource) == FALSE);
    ASSERT(IsExclusiveWaiting(Resource) == FALSE);
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    //
    // Acquire the executive resource spinlock and remove the resource from
    // the system resource list.
    //

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    RemoveEntryList(&Resource->SystemResourcesList);

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    //
    // If an owner table was allocated, then free it to pool.
    //

    if (Resource->OwnerTable != NULL) {
        ExFreePool(Resource->OwnerTable);
    }

    //
    // If a semaphore was allocated, then free it to pool.
    //

    if (Resource->SharedWaiters) {
        ExFreePool(Resource->SharedWaiters);
    }

    //
    // If an event was allocated, then free it to pool.
    //

    if (Resource->ExclusiveWaiters) {
        ExFreePool(Resource->ExclusiveWaiters);
    }

    return STATUS_SUCCESS;
}

ULONG
ExGetExclusiveWaiterCount(
    __in PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the exclusive waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of exclusive waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfExclusiveWaiters;
}

ULONG
ExGetSharedWaiterCount(
    __in PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the shared waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of shared waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfSharedWaiters;
}



BOOLEAN
ExIsResourceAcquiredExclusiveLite(
    __in PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired exclusive by the
    calling thread.

Arguments:

    Resource - Supplies a pointer the resource to query.

Return Value:

    If the current thread has acquired the resource exclusive, a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    BOOLEAN Result;

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then set the return value of TRUE. Otherwise, set the return
    // value to FALSE.
    //

    Result = FALSE;
    if ((IsOwnedExclusive(Resource)) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        Result = TRUE;
    }

    return Result;
}



ULONG
ExIsResourceAcquiredSharedLite(
    __in PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired either shared or
    exclusive by the calling thread.

Arguments:

    Resource - Supplies a pointer to the resource to query.

Return Value:

    If the current thread has not acquired the resource a value of zero
    is returned. Otherwise, the thread's acquire count is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    ULONG Result;
    EXP_LOCK_HANDLE LockHandle;

    ASSERT_RESOURCE(Resource);


    //
    // If nobody owns this resource then exit early.
    //
    if (Resource->ActiveCount == 0) {
        return 0;
    }

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    //
    // Find the current thread in the thread array and return the count.
    //
    // N.B. If the thread is not found a value of zero will be returned.
    //


    if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
        Result = Resource->OwnerThreads[0].OwnerCount;

    } else {
        //
        // If we are not in the first slot and the resource is owned exclusive
        // then we can't own it at all
        //
        if (IsOwnedExclusive(Resource)) {
            return 0;
        }

        //
        // Check slot 2 and other slots in the owner table
        //
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            Result = Resource->OwnerThreads[1].OwnerCount;
        } else {

            Result = 0;
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;

            EXP_LOCK_RESOURCE(Resource, &LockHandle);

            //
            // If the resource hint is not within range or the resource table
            // entry does not match the current thread, then search the owner
            // table for a match.
            //

            OwnerEntry = Resource->OwnerTable;
            if (OwnerEntry != NULL) {
                Number = OwnerEntry->TableSize;
                if ((Index >= Number) ||
                    (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                    for (Index = 1; Index < Number; Index += 1) {
                        OwnerEntry += 1;
                        if (OwnerEntry->OwnerThread == CurrentThread) {
                            Result = OwnerEntry->OwnerCount;
                            break;
                        }
                    }

                } else {
                    Result = OwnerEntry[Index].OwnerCount;
                }
            }

            //
            // Release exclusive access to the specified resource.
            //

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        }
    }

    return Result;
}

NTSTATUS
ExQuerySystemLockInformation(
    __out_bcount(LockInformationLength) PRTL_PROCESS_LOCKS LockInformation,
    __in ULONG LockInformationLength,
    __out_opt PULONG ReturnLength
    )

{

    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG RequiredLength;
    PLIST_ENTRY Head, Next;
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PERESOURCE Resource;
    PETHREAD OwningThread;

    RequiredLength = FIELD_OFFSET(RTL_PROCESS_LOCKS, Locks);
    if (LockInformationLength < RequiredLength) {
        Status = STATUS_INFO_LENGTH_MISMATCH;

    } else {
        Status = STATUS_SUCCESS;

        LockInformation->NumberOfLocks = 0;
        LockInfo = &LockInformation->Locks[0];
        Head = &ExpSystemResourcesList;

        KeAcquireInStackQueuedSpinLock(&ExpResourceSpinLock, &LockHandle);

        Next = Head->Flink;
        while (Next != Head) {
            Resource = CONTAINING_RECORD(Next,
                                         ERESOURCE,
                                         SystemResourcesList);

            LockInformation->NumberOfLocks += 1;
            RequiredLength += sizeof(RTL_PROCESS_LOCK_INFORMATION);

            if (LockInformationLength < RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;

            } else {
                LockInfo->Address = Resource;
                LockInfo->Type = RTL_RESOURCE_TYPE;
                LockInfo->CreatorBackTraceIndex = 0;
#if i386 && !FPO
                LockInfo->CreatorBackTraceIndex = (USHORT)Resource->CreatorBackTraceIndex;
#endif // i386 && !FPO

                 if ((Resource->OwnerThreads[0].OwnerThread != 0) &&
                    ((Resource->OwnerThreads[0].OwnerThread & 3) == 0)) {
                    OwningThread = (PETHREAD)(Resource->OwnerThreads[0].OwnerThread);
                    LockInfo->OwningThread = OwningThread->Cid.UniqueThread;

                } else {
                    LockInfo->OwningThread = 0;
                }

                LockInfo->LockCount = Resource->ActiveCount;
                LockInfo->ContentionCount = Resource->ContentionCount;
                LockInfo->NumberOfWaitingShared = Resource->NumberOfSharedWaiters;
                LockInfo->NumberOfWaitingExclusive = Resource->NumberOfExclusiveWaiters;
                LockInfo += 1;
            }
            Next = Next->Flink;
        }

        KeReleaseInStackQueuedSpinLock(&LockHandle);
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }

    return Status;
}

VOID
FASTCALL
ExpBoostOwnerThread (
    IN PKTHREAD CurrentThread,
    IN PKTHREAD OwnerThread
    )
/*++

Routine Description:

    This function boots the priority of the specified owner thread iff
    its priority is less than that of the current thread and is also
    less than fourteen.

    N.B. this function is called with the dispatcher database lock held.

Arguments:

    CurrentThread - Supplies a pointer to the current thread object.

    OwnerThread - Supplies a pointer to the owner thread object.

Return Value:

    None.

--*/

{

    //
    // If the owner thread is lower priority than the current thread, the
    // current thread is running at a priority less than 14, then boost the
    // priority of the owner thread for a quantum.
    //
    // N.B. A thread that has already been boosted may be reboosted to allow
    //      it to execute and release resources. When the boost is removed,
    //      the thread will return to its priority before any boosting.
    //

    if (((ULONG_PTR)OwnerThread & 0x3) == 0) {
        if ((OwnerThread->Priority < CurrentThread->Priority) &&
            (OwnerThread->Priority < 14)) {

            KiAcquireThreadLock(OwnerThread);
            OwnerThread->PriorityDecrement += 14 - OwnerThread->Priority;
            OwnerThread->Quantum = OwnerThread->QuantumReset;
            KiSetPriorityThread(OwnerThread, 14);
            KiReleaseThreadLock(OwnerThread);
        }
    }

    return;
}

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    )
/*++

Routine Description:

    The routine waits for the specified resource object to be set. If the
    wait is too long the priority of the current owners of the resource
    are boosted.

Arguments:

    Resource - Supplies a pointer to the resource to wait for.

    Object - Supplies a pointer to an event (exclusive) or semaphore
       (shared) to wait for.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    PKTHREAD OwnerThread;
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    LARGE_INTEGER Timeout;
#if DBG
    EXP_LOCK_HANDLE LockHandle;
#endif

    //
    // Increment the contention count for the resource, set the initial
    // timeout value, and wait for the specified object to be signaled
    // or a timeout to occur.
    //

    Limit = 0;
    Resource->ContentionCount += 1;
    Timeout.QuadPart = 500 * -10000;
    do {
        Status = KeWaitForSingleObject (
                        Object,
                        WrResource,
                        KernelMode,
                        FALSE,
                        &Timeout );

        if (Status != STATUS_TIMEOUT) {
            break;
        }

        //
        // The limit has been exceeded, then output status information.
        //

        Limit += 1;
        Timeout = ExpTimeout;
        if (Limit > ExResourceTimeoutCount) {
            Limit = 0;

#if DBG
            //
            // Output information for the specified resource.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            DbgPrint("Resource @ %p\n", Resource);
            DbgPrint(" ActiveCount = %04lx  Flags = %s%s%s\n",
                     Resource->ActiveCount,
                     IsOwnedExclusive(Resource) ? "IsOwnedExclusive " : "",
                     IsSharedWaiting(Resource) ? "SharedWaiter "     : "",
                     IsExclusiveWaiting(Resource) ? "ExclusiveWaiter "  : "");

            DbgPrint(" NumberOfExclusiveWaiters = %04lx\n", Resource->NumberOfExclusiveWaiters);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[0].OwnerThread,
                     Resource->OwnerThreads[0].OwnerCount);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[1].OwnerThread,
                     Resource->OwnerThreads[1].OwnerCount);

            OwnerEntry = Resource->OwnerTable;
            if (OwnerEntry != NULL) {
                Number = OwnerEntry->TableSize;
                for(Index = 1; Index < Number; Index += 1) {
                    OwnerEntry += 1;
                    DbgPrint("  Thread = %p, Count = %02x\n",
                             OwnerEntry->OwnerThread,
                             OwnerEntry->OwnerCount);
                }
            }

            DbgBreakPoint();
            DbgPrint("EX - Rewaiting\n");
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
#endif
        }

        //
        // If priority boosts are allowed, then attempt to boost the priority
        // of owner threads.
        //

        if (IsBoostAllowed(Resource)) {

            //
            // Get the current thread address, lock the dispatcher database,
            // and set wait next in the current thread so the dispatcher
            // database lock does not need to be released before waiting
            // for the resource.
            //
            // N.B. Since the dispatcher database lock instead of the resource
            //      lock is being used to synchronize access to the resource,
            //      it is possible for the information being read from the
            //      resource to be stale. However, the important thing that
            //      cannot change is a valid thread address. Thus a thread
            //      could possibly get boosted that actually has dropped its
            //      access to the resource, but it guaranteed that the thread
            //      cannot be terminated or otherwise deleted.
            //
            // N.B. The dispatcher lock is released by the wait at the top of
            //      loop.
            //

            CurrentThread = KeGetCurrentThread();

            KiLockDispatcherDatabase(&CurrentThread->WaitIrql);
            CurrentThread->WaitNext = TRUE;

            //
            // Attempt to boost the one owner that can be shared or exclusive.
            //

            OwnerThread = (PKTHREAD)Resource->OwnerThreads[0].OwnerThread;
            if (OwnerThread != NULL) {
                ExpBoostOwnerThread(CurrentThread, OwnerThread);
            }

            //
            // If the specified resource is not owned exclusive, then attempt
            // to boost all the owning shared threads priority.
            //

            if (!IsOwnedExclusive(Resource)) {
                OwnerThread = (PKTHREAD)Resource->OwnerThreads[1].OwnerThread;
                if (OwnerThread != NULL) {
                    ExpBoostOwnerThread(CurrentThread, OwnerThread);
                }

                OwnerEntry = Resource->OwnerTable;
                if (OwnerEntry != NULL) {
                    Number = OwnerEntry->TableSize;
                    for(Index = 1; Index < Number; Index += 1) {
                        OwnerEntry += 1;
                        OwnerThread = (PKTHREAD)OwnerEntry->OwnerThread;
                        if (OwnerThread != NULL) {
                            ExpBoostOwnerThread(CurrentThread, OwnerThread);
                        }
                    }
                }
            }
        }

    } while (TRUE);

    return;
}


POWNER_ENTRY
FASTCALL
ExpFindEmptyEntry(
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function searches for a free entry in the resource thread array.

    N.B. This routine is entered with the resource lock held and returns
         with the resource lock held. If the resource lock is released
         to expand the owner table, then the return value will be NULL.
         This is a signal to the caller that the complete operation must
         be repeated. This is done to avoid holding the resource lock
         while memory is allocated and freed.

Arguments:

    Resource - Supplies a pointer to the resource for which the search
        is performed.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    A pointer to an owner entry is returned or NULL if one could not be
    allocated.

--*/

{

    POWNER_ENTRY OwnerBound;
    POWNER_ENTRY OwnerEntry;

    //
    // Search the owner threads for a free entry.
    //

    ASSERT(LockHandle != NULL);
    ASSERT(Resource->OwnerThreads[0].OwnerThread != 0);

    if (Resource->OwnerThreads[1].OwnerThread == 0) {
        return &Resource->OwnerThreads[1];
    }

    OwnerEntry = Resource->OwnerTable;
    if (OwnerEntry != NULL) {

        OwnerBound = &OwnerEntry[OwnerEntry->TableSize];
        OwnerEntry += 1;

        do {
            if (OwnerEntry->OwnerThread == 0) {
                KeGetCurrentThread()->ResourceIndex = (UCHAR)(OwnerEntry - Resource->OwnerTable);
                return OwnerEntry;
            }

            OwnerEntry += 1;
        } while (OwnerEntry != OwnerBound);
    }

    ExpExpandResourceOwnerTable(Resource,LockHandle);
    return NULL;
}


POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    )

/*++

Routine Description:

    This function searches for the specified thread in the resource
    thread array. If the thread is located, then a pointer to the
    array entry is returned as the function value. Otherwise, a pointer
    to a free entry is returned.

    N.B. This routine is entered with the resource lock held and returns
         with the resource lock held. If the resource lock is released
         to expand the owner table, then the return value will be NULL.
         This is a signal to the caller that the complete operation must
         be repeated. This is done to avoid holding the resource lock
         while memory is allocated and freed.

Arguments:

    Resource - Supplies a pointer to the resource for which the search
        is performed.

    CurrentThread - Supplies the identification of the thread to search
        for.

    LockHandle - Supplies a pointer to a lock handle.  If NULL, then the
        caller just wants to know if the requested thread is an owner of
        this resource.  No free entry index is returned and no table
        expansion is performed.  Instead NULL is returned if the requested
        thread cannot be found in the table.

Return Value:

    A pointer to an owner entry is returned or NULL if one could not be
    allocated.

--*/

{

    POWNER_ENTRY FreeEntry;
    POWNER_ENTRY OwnerBound;
    POWNER_ENTRY OwnerEntry;

    //
    // Search the owner threads for the specified thread and return either
    // a pointer to the found thread or a pointer to a free thread table
    // entry.
    //

    OwnerEntry = &Resource->OwnerThreads[0];
    if (OwnerEntry->OwnerThread == CurrentThread) {
        return OwnerEntry;
    }

    OwnerEntry += 1;
    if (OwnerEntry->OwnerThread == CurrentThread) {
        return OwnerEntry;
    }

    if (OwnerEntry->OwnerThread == 0) {
        FreeEntry = OwnerEntry;
    } else {
        FreeEntry = NULL;
    }

    OwnerEntry = Resource->OwnerTable;
    if (OwnerEntry != NULL) {
        OwnerBound = &OwnerEntry[OwnerEntry->TableSize];
        OwnerEntry += 1;
        do {
            if (OwnerEntry->OwnerThread == CurrentThread) {
                KeGetCurrentThread()->ResourceIndex = (UCHAR)(OwnerEntry - Resource->OwnerTable);
                return OwnerEntry;
            }

            if ((FreeEntry == NULL) &&
                (OwnerEntry->OwnerThread == 0)) {
                FreeEntry = OwnerEntry;
            }

            OwnerEntry += 1;
        } while (OwnerEntry != OwnerBound);
    }

    if (!ARGUMENT_PRESENT(LockHandle)) {

        //
        // No argument indicates the caller does not want a free entry or
        // automatic table expansion.  The caller just wants to know if the
        // requested thread is a resource owner.  And clearly the answer is
        // NO at this point.
        //

        return NULL;
    }

    //
    // If a free entry was found in the table, then return the address of the
    // free entry. Otherwise, expand the size of the owner thread table.
    //

    if (FreeEntry != NULL) {
        KeGetCurrentThread()->ResourceIndex = (UCHAR)(FreeEntry - Resource->OwnerTable);
        return FreeEntry;
    }

    ExpExpandResourceOwnerTable(Resource,LockHandle);
    return NULL;
}



VOID
ExpExpandResourceOwnerTable (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function expands the owner table associated with a resource.  It
    is entered and exited with the resource lock held, however it will
    release the resource lock while performing the memory allocation.

Arguments:

    Resource - Supplies a pointer to the resource to wait for.

    Object - Supplies a pointer to an event (exclusive) or semaphore
       (shared) to wait for.

Return Value:

    None.

--*/

{
    ULONG NewSize;
    KIRQL OldIrql;
    ULONG OldSize;
    POWNER_ENTRY OldTable;
    POWNER_ENTRY OwnerTable;

    //
    // Save previous owner table address and allocate an expanded owner table.
    //

    ExpIncrementCounter(OwnerTableExpands);

    OldTable = Resource->OwnerTable;
    if (OldTable == NULL) {
        OldSize = 0;
        NewSize = 3;
    } else {
        OldSize = OldTable->TableSize;
        NewSize = OldSize + 4;
    }

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);

    OwnerTable = ExAllocatePoolWithTag(NonPagedPool,
                                       NewSize * sizeof(OWNER_ENTRY),
                                       'aTeR');

    if (OwnerTable == NULL) {
        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } else {

        //
        // Zero the expansion area of the new owner table.
        //

        RtlZeroMemory(OwnerTable + OldSize,
                      (NewSize - OldSize) * sizeof(OWNER_ENTRY));

        //
        // Acquire the resource lock and determine if the owner table
        // has been expanded by another thread while the new owner table
        // was being allocated. If the owner table has been expanded by
        // another thread, then release the new owner table. Otherwise,
        // copy the owner table to the new owner table and establish the
        // new owner table as the owner table.
        //

        EXP_LOCK_RESOURCE_RAISE(Resource, LockHandle);
        if ((OldTable != Resource->OwnerTable) ||
            ((OldTable != NULL) && (OldSize != OldTable->TableSize))) {
            EXP_UNLOCK_RESOURCE_RAISE(Resource, LockHandle);
            ExFreePool(OwnerTable);

        } else {
            RtlCopyMemory(OwnerTable,
                          OldTable,
                          OldSize * sizeof(OWNER_ENTRY));

            //
            // Swapping of the owner table must be done while owning the
            // dispatcher lock to prevent a priority boost scan from occurring
            // while the table is being changed. The priority boost scan is
            // done when a time out occurs on a specific resource.
            //

            KiLockDispatcherDatabase(&OldIrql);
            OwnerTable->TableSize = NewSize;
            Resource->OwnerTable = OwnerTable;
            KiUnlockDispatcherDatabase(OldIrql);

            ASSERT_RESOURCE(Resource);

            //
            // Release the resource lock and free the old owner table.
            //

            EXP_UNLOCK_RESOURCE_RAISE(Resource, LockHandle);
            if (OldTable != NULL) {
                ExFreePool(OldTable);
            }

            if (OldSize == 0) {
                OldSize = 1;
            }
        }
    }

    //
    // Set the hint index, acquire the resource lock, and return NULL
    // as the function value. This will force a reevaluation of the
    // calling resource function.
    //

    KeGetCurrentThread()->ResourceIndex = (CCHAR)OldSize;
    EXP_LOCK_RESOURCE(Resource, LockHandle);
}


#if DBG

VOID
ExpAssertResource (
    IN PERESOURCE Resource
    )

{
    //
    //  Assert that resource structure is correct.
    //
    // N.B. This routine is called with the resource lock held.
    //

    //
    // Check resource is aligned naturally.
    //

    ASSERT((((ULONG_PTR)Resource) & (sizeof(ULONG_PTR) - 1)) == 0);

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Type == SemaphoreObject);

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Size == (sizeof(KSEMAPHORE) / sizeof(ULONG)));

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Type == SynchronizationEvent);

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Size == (sizeof(KEVENT) / sizeof(ULONG)));
}

#endif

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    )

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY Head, Next;
    volatile PLIST_ENTRY Last=NULL, Last1=NULL;
    PERESOURCE Resource;
    PCHAR BeginBlock;
    PCHAR EndBlock;

    //
    // This can cause a deadlock on MP machines.
    //

    if (KeNumberProcessors > 1) {
        return NULL;
    }

    if ((ExResourceCheckFlags&EX_RESOURCE_CHECK_FREES) == 0) {
        return NULL;
    }


    BeginBlock = (PCHAR)p;
    EndBlock = (PCHAR)p + Size;

    Head = &ExpSystemResourcesList;

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);
    Next = Head->Flink;
    while (Next != Head) {
        Resource = CONTAINING_RECORD(Next,
                                     ERESOURCE,
                                     SystemResourcesList);

        if ((PCHAR)Resource >= BeginBlock && (PCHAR)Resource < EndBlock) {
            DbgPrint("EX: ExFreePool( %p, %lx ) contains an ERESOURCE structure that has not been ExDeleteResourced\n",
                     p,
                     Size);

            DbgBreakPoint ();

            KeReleaseInStackQueuedSpinLock (&LockHandle);
            return (PVOID)Resource;
        }

        //
        //  Save the last ptr in a volatile variable for debugging when a flink is bad
        //  

        Last1 = Last;
        Last = Next;
        Next = Next->Flink;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return NULL;
}

#if DBG

VOID
ExCheckIfResourceOwned (
    VOID
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY Head, Next;
    volatile PLIST_ENTRY Last=NULL, Last1=NULL;
    PERESOURCE Resource;

    if ((ExResourceCheckFlags&EX_RESOURCE_CHECK_ORPHANS) == 0) {
        return;
    }

    Head = &ExpSystemResourcesList;

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    Next = Head->Flink;
    while (Next != Head) {
        Resource = CONTAINING_RECORD(Next,
                                     ERESOURCE,
                                     SystemResourcesList);

        if (ExIsResourceAcquiredSharedLite (Resource) != 0) {
            DbgPrint("EX: Resource %p held in a position where all resources acquires should have been released\n",
                     Resource);

            DbgBreakPoint ();

            KeReleaseInStackQueuedSpinLock (&LockHandle);
            return;
        }

        //
        //  Save the last ptr in a volatile variable for debugging when a flink is bad
        //  

        Last1 = Last;
        Last = Next;
        Next = Next->Flink;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
    return;    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\uuid.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    uuid.c

Abstract:

    This module implements the core time and sequence number allocation
    for UUIDs (exposed to user mode), as well as complete UUID
    creation (exposed to kernel mode only).

              (e.g. RPC Runtime)                (e.g. NTFS)
                      |                              |
                      V                              V
                NtAllocateUuids                 ExUuidCreate
                      |                              |
                      V                              V
                      |                         ExpUuidGetValues
                      |                              |
                      |                              |
                      +------> ExpAllocateUuids <----+

--*/

#include "exp.h"

//
// Well known values
//

// Registry info for the sequence number
#define RPC_SEQUENCE_NUMBER_PATH L"\\Registry\\Machine\\Software\\Microsoft\\Rpc"
#define RPC_SEQUENCE_NUMBER_NAME L"UuidSequenceNumber"

// Masks and constants to interpret the UUID
#define UUID_TIME_HIGH_MASK    0x0FFF
#define UUID_VERSION           0x1000
#define UUID_RESERVED          0x80
#define UUID_CLOCK_SEQ_HI_MASK 0x3F

// Values for ExpUuidCacheValid
#define CACHE_LOCAL_ONLY 0
#define CACHE_VALID      1

//
// Custom types
//

// An alternative data-template for a UUID, useful during generation.
typedef struct _UUID_GENERATE {
    ULONG   TimeLow;
    USHORT  TimeMid;
    USHORT  TimeHiAndVersion;
    UCHAR   ClockSeqHiAndReserved;
    UCHAR   ClockSeqLow;
    UCHAR   NodeId[6];
} UUID_GENERATE;

// A cache of allocated UUIDs
typedef struct _UUID_CACHED_VALUES_STRUCT {
    ULONGLONG           Time;           // End time of allocation
    LONG                AllocatedCount; // Number of UUIDs allocated
    UCHAR               ClockSeqHiAndReserved;
    UCHAR               ClockSeqLow;
    UCHAR               NodeId[6];
} UUID_CACHED_VALUES_STRUCT;


//
//  Global variables
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
// UUID cache information
LARGE_INTEGER               ExpUuidLastTimeAllocated = {0,0};
BOOLEAN                     ExpUuidCacheValid = CACHE_LOCAL_ONLY;

// Make cache allocate UUIDs on first call.
// Time = 0. Allocated = -1, ..., multicast bit set in node id
UUID_CACHED_VALUES_STRUCT   ExpUuidCachedValues = { 0, -1, 0, 0, { 0x80, 'n', 'o', 'n', 'i', 'c' }};

// UUID Sequence number information
ULONG                       ExpUuidSequenceNumber = 0;
BOOLEAN                     ExpUuidSequenceNumberValid = FALSE;
BOOLEAN                     ExpUuidSequenceNumberNotSaved = FALSE;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

// A lock to protect all of the above global data.
FAST_MUTEX                  ExpUuidLock;

//
// Code section allocations
//

NTSTATUS
ExpUuidLoadSequenceNumber (
    OUT PULONG
    );

NTSTATUS
ExpUuidSaveSequenceNumber (
    IN ULONG
    );

NTSTATUS
ExpUuidSaveSequenceNumberIf (
    VOID
    );

NTSTATUS
ExpUuidGetValues (
    OUT UUID_CACHED_VALUES_STRUCT *Values
    );

NTSTATUS
ExpAllocateUuids (
    OUT PLARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence
    );

#pragma alloc_text(PAGE, ExpUuidLoadSequenceNumber)
#pragma alloc_text(PAGE, ExpUuidSaveSequenceNumber)
#pragma alloc_text(PAGE, ExpUuidSaveSequenceNumberIf)
#pragma alloc_text(INIT, ExpUuidInitialization)
#pragma alloc_text(PAGE, ExpAllocateUuids)
#pragma alloc_text(PAGE, NtAllocateUuids)
#pragma alloc_text(PAGE, NtSetUuidSeed)
#pragma alloc_text(PAGE, ExpUuidGetValues)
#pragma alloc_text(PAGE, ExUuidCreate)

NTSTATUS
ExpUuidLoadSequenceNumber (
    OUT PULONG Sequence
    )

/*++

Routine Description:

    This function loads the saved sequence number from the registry.
    This function is called only during system startup.

Arguments:

    Sequence - Pointer to storage for the sequence number.

Return Value:

    STATUS_SUCCESS when the sequence number is successfully read from the
        registry.

    STATUS_UNSUCCESSFUL when the sequence number is not correctly stored
        in the registry.

    Failure codes from ZwOpenKey() and ZwQueryValueKey() maybe returned.

--*/

{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyName;
    HANDLE Key;
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    RtlInitUnicodeString(&KeyPath, RPC_SEQUENCE_NUMBER_PATH);
    RtlInitUnicodeString(&KeyName, RPC_SEQUENCE_NUMBER_NAME);

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status =
    ZwOpenKey( &Key,
               GENERIC_READ,
               &ObjectAttributes
             );

    if (NT_SUCCESS(Status)) {
        Status =
        ZwQueryValueKey( Key,
                         &KeyName,
                         KeyValuePartialInformation,
                         KeyValueInformation,
                         sizeof(KeyValueBuffer),
                         &ResultLength
                       );

        ZwClose( Key );
        }

    if (NT_SUCCESS(Status)) {
        if ( KeyValueInformation->Type == REG_DWORD &&
             KeyValueInformation->DataLength == sizeof(ULONG)
           ) {
            *Sequence = *(PULONG)KeyValueInformation->Data;
            }
        else {
            Status = STATUS_UNSUCCESSFUL;
            }
        }

    return(Status);
}

NTSTATUS
ExpUuidSaveSequenceNumber (
    IN ULONG Sequence
    )

/*++

Routine Description:

    This function saves the uuid sequence number in the registry.  This
    value will be read by ExpUuidLoadSequenceNumber during the next boot.

    This routine assumes that the current thread has exclusive access
    to the the ExpUuid* values.

Arguments:

    Sequence - The sequence number to save.

Return Value:

    STATUS_SUCCESS

    Failure codes from ZwOpenKey() and ZwSetValueKey() maybe returned.

--*/

{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyName;
    HANDLE Key;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyPath, RPC_SEQUENCE_NUMBER_PATH);
    RtlInitUnicodeString(&KeyName, RPC_SEQUENCE_NUMBER_NAME);

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status =
    ZwOpenKey( &Key,
               GENERIC_READ | GENERIC_WRITE,
               &ObjectAttributes
             );

    if (NT_SUCCESS(Status)) {
        Status =
        ZwSetValueKey( Key,
                       &KeyName,
                       0,
                       REG_DWORD,
                       &Sequence,
                       sizeof(ULONG)
                     );

        ZwClose( Key );
        }

    return(Status);
}

NTSTATUS
ExpUuidSaveSequenceNumberIf (
    VOID
    )

/*++

Routine Description:

    This function saves the ExpUuidSequenceNumber, but only
    if necessary (as determined by the ExpUuidSequenceNumberNotSaved
    flag).

    This routine assumes that the current thread has exclusive access
    to the ExpUuid* values.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the operation was successful.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Does the sequence number need to be saved?
    if (ExpUuidSequenceNumberNotSaved == TRUE) {

        // Print this message just to make sure we aren't hitting the
        // registry too much under normal usage.

        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "Uuid: Saving new sequence number.\n"));

        // Save the sequence number

        Status = ExpUuidSaveSequenceNumber(ExpUuidSequenceNumber);

        // Indicate that it's now been saved.
        if (NT_SUCCESS(Status)) {
            ExpUuidSequenceNumberNotSaved = FALSE;
            }
        }

    return( Status );
}

BOOLEAN
ExpUuidInitialization (
    VOID
    )
/*++

Routine Description:

    This function initializes the UUID allocation.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is successfully
    completed.  Otherwise, a value of FALSE is returned.

--*/

{

    PAGED_CODE();

    ExInitializeFastMutex(&ExpUuidLock);

    ExpUuidSequenceNumberValid = FALSE;

    // We can use the current time since we'll be changing the sequence number.

    KeQuerySystemTime(&ExpUuidLastTimeAllocated);

    return TRUE;
}

NTSTATUS
ExpAllocateUuids (
    OUT PLARGE_INTEGER Time,
    OUT PULONG Range,
    OUT PULONG Sequence
    )

/*++

Routine Description:

    Allocates a sequence number and a range of times for a set of UUIDs.
    The caller can use this together with the network address to
    generate complete UUIDs.

    This routine assumes that the current thread has exclusive access
    to the ExpUuid* values.

Arguments:

    Time - Supplies the address of a variable that will receive the
        start time (SYSTEMTIME format) of the range of time reserved.

    Range - Supplies the address of a variable that will receive the
        number of ticks (100ns) reserved after the value in Time.
        The range reserved is *Time to (*Time+*Range-1).

    Sequence - Supplies the address of a variable that will receive
        the time sequence number.  This value is used with the associated
        range of time to prevent problems with clocks going backwards.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_UNSUCCESSFUL is returned if some other service reports
        an error, most likly the registry.

--*/

{

    NTSTATUS Status;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER AvailableTime;

    PAGED_CODE();

    //
    // Make sure we have a valid sequence number.  If not, make one up.
    //

    if (ExpUuidSequenceNumberValid == FALSE) {

        Status = ExpUuidLoadSequenceNumber(&ExpUuidSequenceNumber);

        if (!NT_SUCCESS(Status)) {
            // Unable read the sequence number, this means we should make one up.

            LARGE_INTEGER PerfCounter;
            LARGE_INTEGER PerfFrequency;

            // This should only happen when we're called
            // for the first time on a given machine. (machine, not boot)

            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "Uuid: Generating first sequence number.\n"));

            PerfCounter = KeQueryPerformanceCounter(&PerfFrequency);

            ExpUuidSequenceNumber ^= (ULONG)((ULONG_PTR)&Status) ^ PerfCounter.LowPart ^
                PerfCounter.HighPart ^ (ULONG)((ULONG_PTR)Sequence);
            }
        else {
            // We increment the sequence number on every boot.
            ExpUuidSequenceNumber++;
            }

        ExpUuidSequenceNumberValid = TRUE;
        ExpUuidSequenceNumberNotSaved = TRUE;

        }

    //
    // Get the current time, usually we will have plenty of available
    // to give the caller.  But we may need to deal with time going
    // backwards and really fast machines.
    //

    KeQuerySystemTime(&CurrentTime);

    AvailableTime.QuadPart = CurrentTime.QuadPart - ExpUuidLastTimeAllocated.QuadPart;

    if (AvailableTime.QuadPart < 0) {

        // Time has been set time backwards. This means that we must make sure
        // that somebody increments the sequence number and saves the new
        // sequence number in the registry.

        ExpUuidSequenceNumberNotSaved = TRUE;
        ExpUuidSequenceNumber++;

        // The sequence number has been changed, so it's now okay to set time
        // backwards.  Since time is going backwards anyway, it's okay to set
        // it back an extra millisecond or two.

        ExpUuidLastTimeAllocated.QuadPart = CurrentTime.QuadPart - 20000;
        AvailableTime.QuadPart = 20000;
        }

    if (AvailableTime.QuadPart == 0) {
        // System time hasn't moved.  The caller should yield the CPU and retry.
        return(STATUS_RETRY);
        }

    //
    // Common case, time has moved forward.
    //

    if (AvailableTime.QuadPart > 10*1000*1000) {
        // We never want to give out really old (> 1 second) Uuids.
        AvailableTime.QuadPart = 10*1000*1000;
        }

    if (AvailableTime.QuadPart > 10*1000) {
        // We've got over a millisecond to give out.  We'll save some time for
        // another caller so that we can avoid returning STATUS_RETRY very often.
        *Range = 10*1000;
        AvailableTime.QuadPart -= 10*1000;
        }
    else {
        // Not much time avaiable, give it all away.
        *Range = (ULONG)AvailableTime.QuadPart;
        AvailableTime.QuadPart = 0;
        }

    Time->QuadPart = CurrentTime.QuadPart - (*Range + AvailableTime.QuadPart);

    ExpUuidLastTimeAllocated.QuadPart = Time->QuadPart + *Range;

    // Last time allocated is just after the range we hand back to the caller
    // this may be almost a second behind the true system time.

    *Sequence = ExpUuidSequenceNumber;


    return(STATUS_SUCCESS);
}

#define SEED_SIZE 6 * sizeof(CHAR)

NTSTATUS
NtSetUuidSeed (
    __in PCHAR Seed
    )

/*++

Routine Description:

    This routine is used to set the seed used for UUID generation. The seed
    will be set by RPCSS at startup and each time a card is replaced.

Arguments:

    Seed - Pointer to a six byte buffer

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_DENIED If caller doesn't have the permissions to make this call.
    You need to be logged on as Local System in order to call this API.

    STATUS_ACCESS_VIOLATION is returned if the Seed could not be read.

--*/

{

    NTSTATUS Status;
    LUID AuthenticationId;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    LUID SystemLuid = SYSTEM_LUID;
    BOOLEAN CapturedSubjectContext = FALSE;

    PAGED_CODE();

    ASSERT(KeGetPreviousMode() != KernelMode);

    try {
        //
        // Check if the caller has the appropriate permission
        //
        SeCaptureSubjectContext(&SubjectContext);
        CapturedSubjectContext = TRUE;

        Status = SeQueryAuthenticationIdToken(
                             SeQuerySubjectContextToken(&SubjectContext),
                             &AuthenticationId);
        if (!NT_SUCCESS(Status)) {
            ExRaiseStatus(Status);
            }

        if (RtlCompareMemory(&AuthenticationId, &SystemLuid, sizeof(LUID)) != sizeof(LUID)) {
            ExRaiseStatus(STATUS_ACCESS_DENIED);
            }

        //
        // Store the UUID seed
        //
        ProbeForReadSmallStructure(Seed, SEED_SIZE, sizeof(CHAR));
        RtlCopyMemory(&ExpUuidCachedValues.NodeId[0], Seed, SEED_SIZE);

        if ((Seed[0] & 0x80) == 0)
            {
            // If the high bit is not set the NodeId is a valid IEEE 802
            // address and should be globally unique.
            ExpUuidCacheValid = CACHE_VALID;
            }
        else
            {
            ExpUuidCacheValid = CACHE_LOCAL_ONLY;
            }

        Status = STATUS_SUCCESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (CapturedSubjectContext) {
        SeReleaseSubjectContext( &SubjectContext );
        }

    return Status;
}

NTSTATUS
NtAllocateUuids (
    __out PULARGE_INTEGER Time,
    __out PULONG Range,
    __out PULONG Sequence,
    __out PCHAR Seed
    )

/*++

Routine Description:

    This function reserves a range of time for the caller(s) to use for
    handing out Uuids.  As far a possible the same range of time and
    sequence number will never be given out.

    (It's possible to reboot 2^14-1 times and set the clock backwards and then
    call this allocator and get a duplicate.  Since only the low 14bits of the
    sequence number are used in a real uuid.)

Arguments:

    Time - Supplies the address of a variable that will receive the
        start time (SYSTEMTIME format) of the range of time reserved.

    Range - Supplies the address of a variable that will receive the
        number of ticks (100ns) reserved after the value in Time.
        The range reserved is *Time to (*Time + *Range - 1).

    Sequence - Supplies the address of a variable that will receive
        the time sequence number.  This value is used with the associated
        range of time to prevent problems with clocks going backwards.

    Seed - Pointer to a 6 byte buffer. The current seed is written into this buffer.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This may (?) occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        UUID cannot be written.

    STATUS_UNSUCCESSFUL is returned if some other service reports
        an error, most likly the registry.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    LARGE_INTEGER OutputTime;
    ULONG OutputRange;
    ULONG OutputSequence;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    //
    // Establish an exception handler and attempt to write the output
    // arguments. If the write attempt fails, then return
    // the exception code as the service status. Otherwise return success
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure((PVOID)Time, sizeof(LARGE_INTEGER), sizeof(ULONG));
            ProbeForWriteUlongAligned32(Range);
            ProbeForWriteUlongAligned32(Sequence);
            ProbeForWriteSmallStructure((PVOID)Seed, SEED_SIZE, sizeof(CHAR));
            }
    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    // Take the lock, because we're about to update the UUID cache.
    CurrentThread = KeGetCurrentThread ();
    KeEnterCriticalRegionThread(CurrentThread);
    ExAcquireFastMutexUnsafe(&ExpUuidLock);

    // Get the sequence number and a range of times that can
    // be used in UUID-generation.

    Status = ExpAllocateUuids( &OutputTime, &OutputRange, &OutputSequence );

    if( !NT_SUCCESS(Status) ) {
        ExReleaseFastMutexUnsafe(&ExpUuidLock);
        KeLeaveCriticalRegionThread(CurrentThread);
        return( Status );
    }

    // If necessary, save the sequence number.  If there's an error,
    // we'll just leave it marked as dirty, and retry on some future call.

    ExpUuidSaveSequenceNumberIf();

    // Release the lock
    ExReleaseFastMutexUnsafe(&ExpUuidLock);
    KeLeaveCriticalRegionThread(CurrentThread);

    //
    // Attempt to store the result of this call into the output parameters.
    // This is done within an exception handler in case output parameters
    // are now invalid.
    //

    try {
        Time->QuadPart = OutputTime.QuadPart;
        *Range = OutputRange;
        *Sequence = OutputSequence;
        RtlCopyMemory((PVOID) Seed, &ExpUuidCachedValues.NodeId[0], SEED_SIZE);
    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
ExpUuidGetValues (
    OUT UUID_CACHED_VALUES_STRUCT *Values
    )

/*++

Routine Description:

    This routine allocates a block of UUIDs and stores them in
    the caller-provided cached-values structure.

    This routine assumes that the current thread has exclusive
    access to the ExpUuid* values.

    Note that the Time value in this cache is different than the
    Time value returned by NtAllocateUuids (and ExpAllocateUuids).
    As a result, the cache must be interpreted differently in
    order to determine the valid range.  The valid range from
    these two routines is:

        NtAllocateUuids:  [ Time, Time+Range )
        ExpUuidGetValues: ( Values.Time-Values.Range, Values.Time ]

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

    STATUS_NO_MEMORY is returned if we're unable to reserve a range
        of UUIDs, for some reason other than the clock not advancing.

--*/

{

    NTSTATUS Status;
    LARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;

    PAGED_CODE();

    // Allocate a range of times for use in UUIDs.

    Status = ExpAllocateUuids(&Time, &Range, &Sequence);

    if (STATUS_RETRY == Status) {
        return(Status);
        }

    else if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_MEMORY);
        }

    // ExpAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (ULONGLONG) (1000*1000*10)       // seconds
                     * (ULONGLONG) (60 * 60 * 24)       // days
                     * (ULONGLONG) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        UUID_RESERVED | (((UCHAR) (Sequence >> 8))
        & (UCHAR) UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (UCHAR) (Sequence & 0x00FF);


    // We'll modify the Time value so that it indicates the
    // end of the range rather than the beginning of it.

    // The order of these assignments is important

    Values->Time = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    return(STATUS_SUCCESS);
}

NTSTATUS
ExUuidCreate (
    __out UUID *Uuid
    )

/*++

Routine Description:

    This routine creates a DCE UUID and returns it in the caller's
    buffer.

Arguments:

    Uuid - will receive the UUID.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_RETRY is returned if we're unable to reserve a range of
        UUIDs.  This will occur if system clock hasn't advanced
        and the allocator is out of cached values.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    UUID_GENERATE  *UuidGen = (UUID_GENERATE *) Uuid;
    ULONGLONG       Time;
    LONG            Delta;
    PKTHREAD        CurrentThread;

    PAGED_CODE();

    //
    // Get a value from the cache.  If the cache is empty, we'll fill
    // it and retry.  The first time cache will be empty.
    //

    CurrentThread = KeGetCurrentThread ();
    for(;;) {

        // Get the highest value in the cache (though it may not
        // be available).
        Time = ExpUuidCachedValues.Time;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(PULONG)&UuidGen->ClockSeqHiAndReserved =
            *(PULONG)&ExpUuidCachedValues.ClockSeqHiAndReserved;
        *(PULONG)&UuidGen->NodeId[2] =
            *(PULONG)&ExpUuidCachedValues.NodeId[2];

        // See what we need to subtract from Time to get a valid GUID.
        Delta = InterlockedDecrement(&ExpUuidCachedValues.AllocatedCount);

        if (Time != ExpUuidCachedValues.Time) {

            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
        }

        // If the cache hadn't already run dry, we can break out of this retry
        // loop.
        if (Delta >= 0) {
            break;
        }

        //
        // Allocate a new block of Uuids.
        //

        // Take the cache lock
        KeEnterCriticalRegionThread(CurrentThread);
        ExAcquireFastMutexUnsafe(&ExpUuidLock);

        // If the cache has already been updated, try again.
        if (Time != ExpUuidCachedValues.Time) {
            // Release the lock
            ExReleaseFastMutexUnsafe(&ExpUuidLock);
            KeLeaveCriticalRegionThread(CurrentThread);
            continue;
        }

        // Update the cache.
        Status = ExpUuidGetValues( &ExpUuidCachedValues );

        if (Status != STATUS_SUCCESS) {
            // Release the lock
            ExReleaseFastMutexUnsafe(&ExpUuidLock);
            KeLeaveCriticalRegionThread(CurrentThread);
            return(Status);
        }

        // The sequence number may have been dirtied, see if it needs
        // to be saved.  If there's an error, we'll ignore it and
        // retry on a future call.

        ExpUuidSaveSequenceNumberIf();

        // Release the lock
        ExReleaseFastMutexUnsafe(&ExpUuidLock);
        KeLeaveCriticalRegionThread(CurrentThread);

    // Loop
    }

    // Adjust the time to that of the next available UUID.
    Time -= Delta;

    // Finish filling in the UUID.

    UuidGen->TimeLow = (ULONG) Time;
    UuidGen->TimeMid = (USHORT) (Time >> 32);
    UuidGen->TimeHiAndVersion = (USHORT)
        (( (USHORT)(Time >> (32+16))
        & UUID_TIME_HIGH_MASK) | UUID_VERSION);

    ASSERT(Status == STATUS_SUCCESS);

    if (ExpUuidCacheValid == CACHE_LOCAL_ONLY) {
        Status = RPC_NT_UUID_LOCAL_ONLY;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\semphore.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    semphore.c

Abstract:

   This module implements the executive semaphore object. Functions are
   provided to create, open, release, and query semaphore objects.

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpSemaphoreBoost = SEMAPHORE_INCREMENT;

//
// Address of semaphore object type descriptor.
//

POBJECT_TYPE ExSemaphoreObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for semaphore objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const GENERIC_MAPPING ExpSemaphoreMapping = {
    STANDARD_RIGHTS_READ | SEMAPHORE_QUERY_STATE,
    STANDARD_RIGHTS_WRITE | SEMAPHORE_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    SEMAPHORE_ALL_ACCESS
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#pragma alloc_text(INIT, ExpSemaphoreInitialization)
#pragma alloc_text(PAGE, NtCreateSemaphore)
#pragma alloc_text(PAGE, NtOpenSemaphore)
#pragma alloc_text(PAGE, NtQuerySemaphore)
#pragma alloc_text(PAGE, NtReleaseSemaphore)

BOOLEAN
ExpSemaphoreInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the semaphore object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the semaphore object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Semaphore");

    //
    // Create semaphore object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpSemaphoreMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KSEMAPHORE);
    ObjectTypeInitializer.ValidAccessMask = SEMAPHORE_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExSemaphoreObjectType);

    //
    // If the semaphore object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateSemaphore (
    __out PHANDLE SemaphoreHandle,
    __in ACCESS_MASK DesiredAccess,
    __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
    __in LONG InitialCount,
    __in LONG MaximumCount
    )

/*++

Routine Description:

    This function creates a semaphore object, sets its initial count to the
    specified value, sets its maximum count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialCount - Supplies the initial count of the semaphore object.

    MaximumCount - Supplies the maximum count of the semaphore object.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((MaximumCount <= 0) || (InitialCount < 0) ||
       (InitialCount > MaximumCount)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate semaphore object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExSemaphoreObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KSEMAPHORE),
                            0,
                            0,
                            &Semaphore);

    //
    // If the semaphore object was successfully allocated, then initialize
    // the semaphore object and attempt to insert the semaphore object in
    // the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeSemaphore((PKSEMAPHORE)Semaphore,
                              InitialCount,
                              MaximumCount);

        Status = ObInsertObject(Semaphore,
                                NULL,
                                DesiredAccess,
                                0,
                                NULL,
                                &Handle);

        //
        // If the semaphore object was successfully inserted in the current
        // process' handle table, then attempt to write the semaphore handle
        // value. If the write attempt fails, then do not report an error.
        // When the caller attempts to access the handle value, an access
        // violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *SemaphoreHandle = Handle;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *SemaphoreHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenSemaphore (
    __out PHANDLE SemaphoreHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a semaphore object with the specified
    desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the semaphore object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExSemaphoreObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the semaphore
    // object handle value. If the write attempt fails, then do not report
    // an error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *SemaphoreHandle = Handle;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            *SemaphoreHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQuerySemaphore (
    __in HANDLE SemaphoreHandle,
    __in SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    __out_bcount(SemaphoreInformationLength) PVOID SemaphoreInformation,
    __in ULONG SemaphoreInformationLength,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This function queries the state of a semaphore object and returns the
    requested information in the specified record structure.

Arguments:

    SemaphoreHandle - Supplies a handle to a semaphore object.

    SemaphoreInformationClass - Supplies the class of information being
        requested.

    SemaphoreInformation - Supplies a pointer to a record that is to receive
        the requested information.

    SemaphoreInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    LONG Count;
    PSEMAPHORE_BASIC_INFORMATION Information;
    LONG Maximum;
    KPROCESSOR_MODE PreviousMode;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteSmallStructure (SemaphoreInformation,
                                         sizeof(SEMAPHORE_BASIC_INFORMATION),
                                         sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (SemaphoreInformationClass != SemaphoreBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (SemaphoreInformationLength != sizeof(SEMAPHORE_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_QUERY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then read the current state and
    // maximum count of the semaphore object, dereference semaphore object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the semaphore
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateSemaphore((PKSEMAPHORE)Semaphore);
        Information = SemaphoreInformation;
        Maximum = ((PKSEMAPHORE)Semaphore)->Limit;
        ObDereferenceObject(Semaphore);
        if (PreviousMode != KernelMode) {
            try {
                Information->CurrentCount = Count;
                Information->MaximumCount = Maximum;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }

        } else {
            Information->CurrentCount = Count;
            Information->MaximumCount = Maximum;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseSemaphore (
    __in HANDLE SemaphoreHandle,
    __in LONG ReleaseCount,
    __out_opt PLONG PreviousCount
    )

/*++

Routine Description:

    This function releases a semaphore object by adding the specified release
    count to the current value.

Arguments:

    Semaphore - Supplies a handle to a semaphore object.

    ReleaseCount - Supplies the release count that is to be added to the
        current semaphore count.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous semaphore count.

Return Value:

    NTSTATUS.

--*/

{

    LONG Count;
    PVOID Semaphore;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe previous count address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (ARGUMENT_PRESENT(PreviousCount) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousCount);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (ReleaseCount <= 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_MODIFY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then release the semaphore object.
    // If an exception occurs because the maximum count of the semaphore
    // has been exceeded, then dereference the semaphore object and return
    // the exception code as the service status. Otherwise write the previous
    // count value if specified. If the write of the previous count fails,
    // then do not report an error. When the caller attempts to access the
    // previous count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = 0;
        try {
            PERFINFO_DECLARE_OBJECT(Semaphore);
            Count = KeReleaseSemaphore((PKSEMAPHORE)Semaphore,
                                       ExpSemaphoreBoost,
                                       ReleaseCount,
                                       FALSE);

        } except(ExSystemExceptionFilter()) {
            Status = GetExceptionCode();
        }

        ObDereferenceObject(Semaphore);
        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(PreviousCount)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousCount = Count;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NOTHING;
                }

            } else {
                *PreviousCount = Count;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\win32.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    win32.c

Abstract:

   This module implements the definition of the executive Win32 objects.
   Functions to manage these objects are implemented in win32k.sys.

--*/

#include "exp.h"

//
// Address of windowstation and desktop object type descriptors.
//

POBJECT_TYPE ExWindowStationObjectType;
POBJECT_TYPE ExDesktopObjectType;

PKWIN32_CLOSEMETHOD_CALLOUT ExDesktopCloseProcedureCallout;
PKWIN32_CLOSEMETHOD_CALLOUT ExWindowStationCloseProcedureCallout;
PKWIN32_OPENMETHOD_CALLOUT ExDesktopOpenProcedureCallout;
PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExDesktopOkToCloseProcedureCallout;
PKWIN32_OKTOCLOSEMETHOD_CALLOUT ExWindowStationOkToCloseProcedureCallout;
PKWIN32_DELETEMETHOD_CALLOUT ExDesktopDeleteProcedureCallout;
PKWIN32_DELETEMETHOD_CALLOUT ExWindowStationDeleteProcedureCallout;
PKWIN32_PARSEMETHOD_CALLOUT ExWindowStationParseProcedureCallout;
PKWIN32_OPENMETHOD_CALLOUT ExWindowStationOpenProcedureCallout;

//
// common types for above win32 callouts and parameters
//

typedef PVOID PKWIN32_CALLOUT_PARAMETERS;

typedef
NTSTATUS
(*PKWIN32_CALLOUT) (
    IN PKWIN32_CALLOUT_PARAMETERS
    );

NTSTATUS
ExpWin32SessionCallout(
    IN  PKWIN32_CALLOUT CalloutRoutine,
    IN  PKWIN32_CALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId,
    OUT PNTSTATUS CalloutStatus  OPTIONAL
    );

VOID
ExpWin32CloseProcedure(
   IN PEPROCESS Process OPTIONAL,
   IN PVOID Object,
   IN ACCESS_MASK GrantedAccess,
   IN ULONG_PTR ProcessHandleCount,
   IN ULONG_PTR SystemHandleCount );

BOOLEAN
ExpWin32OkayToCloseProcedure(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
ExpWin32DeleteProcedure(
    IN PVOID    Object
    );

NTSTATUS
ExpWin32ParseProcedure (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
ExpWin32OpenProcedure(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, ExpWin32Initialization)
#pragma alloc_text (PAGE, ExpWin32CloseProcedure)
#pragma alloc_text (PAGE, ExpWin32OkayToCloseProcedure)
#pragma alloc_text (PAGE, ExpWin32DeleteProcedure)
#pragma alloc_text (PAGE, ExpWin32OpenProcedure)
#pragma alloc_text (PAGE, ExpWin32ParseProcedure)
#pragma alloc_text (PAGE, ExpWin32SessionCallout)
#endif


/*
 * windowstation generic mapping
 */
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpWindowStationMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_REQUIRED
};

/*
 * desktop generic mapping
 */
const GENERIC_MAPPING ExpDesktopMapping = {
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_REQUIRED
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

/*++

Routine Description:

    Close Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_CLOSE_METHOD

Return Value:


--*/
VOID ExpWin32CloseProcedure(
   IN PEPROCESS Process OPTIONAL,
   IN PVOID Object,
   IN ACCESS_MASK GrantedAccess,
   IN ULONG_PTR ProcessHandleCount,
   IN ULONG_PTR SystemHandleCount )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_CLOSEMETHOD_PARAMETERS CloseParams;
   NTSTATUS Status;

   CloseParams.Process = Process;
   CloseParams.Object  =  Object;
   CloseParams.GrantedAccess = GrantedAccess;
   CloseParams.ProcessHandleCount = (ULONG)ProcessHandleCount;
   CloseParams.SystemHandleCount =  (ULONG)SystemHandleCount;

   if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&CloseParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&CloseParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType || (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType));

   }


}

/*++

Routine Description:

    OkayToClose Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_OKAYTOCLOSE_METHOD


Return Value:


--*/
BOOLEAN ExpWin32OkayToCloseProcedure(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    )
{
   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_OKAYTOCLOSEMETHOD_PARAMETERS OKToCloseParams;
   NTSTATUS Status, CallStatus = STATUS_UNSUCCESSFUL;

   OKToCloseParams.Process      = Process;
   OKToCloseParams.Object       = Object;
   OKToCloseParams.Handle       = Handle;
   OKToCloseParams.PreviousMode = PreviousMode;

   if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopOkToCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OKToCloseParams,
                                       SessionId,
                                       &CallStatus);
       ASSERT(NT_SUCCESS(Status));

   } else if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationOkToCloseProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OKToCloseParams,
                                       SessionId,
                                       &CallStatus);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT(OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType ||
             OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType);

   }

   return (BOOLEAN)(NT_SUCCESS(CallStatus));

}


/*++

Routine Description:

    Delete Procedure for Win32k windostation and desktop objects

Arguments:
    Defined by OB_DELETE_METHOD


Return Value:


--*/
VOID ExpWin32DeleteProcedure(
    IN PVOID    Object
    )
{
   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_DELETEMETHOD_PARAMETERS DeleteParams;
   NTSTATUS Status;

   DeleteParams.Object  =  Object;


   if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopDeleteProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&DeleteParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else if (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationDeleteProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&DeleteParams,
                                       SessionId,
                                       NULL);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT(OBJECT_TO_OBJECT_HEADER(Object)->Type == ExDesktopObjectType ||
             OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType);

   }


}

/*++

Routine Description:

    Open Procedure for Win32k desktop objects

Arguments:
    Defined by OB_OPEN_METHOD

Return Value:


--*/


NTSTATUS
ExpWin32OpenProcedure(
    IN OB_OPEN_REASON OpenReason,
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG HandleCount
    )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)Object);
   WIN32_OPENMETHOD_PARAMETERS OpenParams;
   NTSTATUS Status, CallStatus = STATUS_UNSUCCESSFUL;

   OpenParams.OpenReason = OpenReason;
   OpenParams.Process  =  Process;
   OpenParams.Object = Object;
   OpenParams.GrantedAccess = GrantedAccess;
   OpenParams.HandleCount =  HandleCount;

   
   if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExDesktopOpenProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OpenParams,
                                       SessionId,
                                       &CallStatus);

       ASSERT(NT_SUCCESS(Status));

   } else if ((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExWindowStationObjectType) {

       Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationOpenProcedureCallout,
                                       (PKWIN32_CALLOUT_PARAMETERS)&OpenParams,
                                       SessionId,
                                       &CallStatus);
       ASSERT(NT_SUCCESS(Status));

   } else {
      ASSERT((OBJECT_TO_OBJECT_HEADER(Object)->Type) == ExDesktopObjectType || (OBJECT_TO_OBJECT_HEADER(Object)->Type == ExWindowStationObjectType));

   }
   
   return CallStatus;
}

/*++

Routine Description:

    Parse Procedure for Win32k windostation objects

Arguments:
    Defined by OB_PARSE_METHOD


Return Value:


--*/

NTSTATUS ExpWin32ParseProcedure (
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )
{

   //
   // SessionId is the first field in the Win32k Object structure
   //
   ULONG SessionId = *((PULONG)ParseObject);
   WIN32_PARSEMETHOD_PARAMETERS ParseParams;
   NTSTATUS Status, CallStatus = STATUS_UNSUCCESSFUL;

   ParseParams.ParseObject = ParseObject;
   ParseParams.ObjectType  =  ObjectType;
   ParseParams.AccessState = AccessState;
   ParseParams.AccessMode = AccessMode;
   ParseParams.Attributes = Attributes;
   ParseParams.CompleteName = CompleteName;
   ParseParams.RemainingName = RemainingName;
   ParseParams.Context = Context;
   ParseParams.SecurityQos = SecurityQos;
   ParseParams.Object = Object;

   //
   // Parse Procedure is only provided for WindowStation objects
   //
   Status = ExpWin32SessionCallout((PKWIN32_CALLOUT)ExWindowStationParseProcedureCallout,
                                   (PKWIN32_CALLOUT_PARAMETERS)&ParseParams,
                                   SessionId,
                                   &CallStatus);
   ASSERT(NT_SUCCESS(Status));

   return CallStatus;

}


BOOLEAN
ExpWin32Initialization (
    )

/*++

Routine Description:

    This function creates the Win32 object type descriptors at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the Win32 object type descriptors are
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"WindowStation");

    //
    // Create windowstation object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.GenericMapping = ExpWindowStationMapping;
    ObjectTypeInitializer.SecurityRequired = TRUE;
    ObjectTypeInitializer.PoolType = NonPagedPool;

    ObjectTypeInitializer.CloseProcedure  = ExpWin32CloseProcedure;
    ObjectTypeInitializer.DeleteProcedure = ExpWin32DeleteProcedure;
    ObjectTypeInitializer.OkayToCloseProcedure = ExpWin32OkayToCloseProcedure;

    ObjectTypeInitializer.ParseProcedure  = ExpWin32ParseProcedure;
    ObjectTypeInitializer.OpenProcedure   = ExpWin32OpenProcedure;

    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK |
                                              OBJ_PERMANENT |
                                              OBJ_EXCLUSIVE;
    ObjectTypeInitializer.ValidAccessMask = STANDARD_RIGHTS_REQUIRED;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExWindowStationObjectType);

    //
    // If the windowstation object type descriptor was not successfully
    // created, then return a value of FALSE.
    //

    if (!NT_SUCCESS(Status))
        return FALSE;



    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Desktop");

    ObjectTypeInitializer.ParseProcedure       = NULL; //Desktop has no Parse Procedure

    //
    // Create windowstation object type descriptor.
    //

    ObjectTypeInitializer.GenericMapping = ExpDesktopMapping;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExDesktopObjectType);


    //
    // If the desktop object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}



NTSTATUS
ExpWin32SessionCallout(
    IN  PKWIN32_CALLOUT CalloutRoutine,
    IN  PKWIN32_CALLOUT_PARAMETERS Parameters,
    IN  ULONG SessionId,
    OUT PNTSTATUS CalloutStatus  OPTIONAL
    )
/*++

Routine Description:

    This routine calls the specified callout routine in session space, for the
    specified session.

Parameters:

    CalloutRoutine - Callout routine in session space.

    Parameters     - Parameters to pass the callout routine.

    SessionId      - Specifies the ID of the session in which the specified
                     callout routine is to be called.

    CalloutStatus  - Optionally, supplies the address of a variable to receive
                     the NTSTATUS code returned by the callout routine.

Return Value:

    Status code that indicates whether or not the function was successful.

Notes:

    Returns STATUS_NOT_FOUND if the specified session was not found.

--*/
{
    NTSTATUS Status, CallStatus;
    PVOID OpaqueSession;
    KAPC_STATE ApcState;

    PAGED_CODE();

    //
    // Make sure we have all the information we need to deliver notification.
    //
    if (CalloutRoutine == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the callout routine in session space.
    //
    ASSERT(MmIsSessionAddress((PVOID)CalloutRoutine));

    if ((PsGetCurrentProcess()->Flags & PS_PROCESS_FLAGS_IN_SESSION) &&
        (SessionId == PsGetCurrentProcessSessionId())) {
        //
        // If the call is from a user mode process, and we are asked to call the
        // current session, call directly.
        //
        CallStatus = (CalloutRoutine)(Parameters);

        //
        // Return the callout status.
        //
        if (ARGUMENT_PRESENT(CalloutStatus)) {
            *CalloutStatus = CallStatus;
        }

        Status = STATUS_SUCCESS;

    } else {
        //
        // Reference the session object for the specified session.
        //
        OpaqueSession = MmGetSessionById(SessionId);
        if (OpaqueSession == NULL) {
            return STATUS_NOT_FOUND;
        }

        //
        // Attach to the specified session.
        //
        Status = MmAttachSession(OpaqueSession, &ApcState);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL,
                       "ExpWin32SessionCallout: "
                       "could not attach to 0x%p, session %d for registered notification callout @ 0x%p\n",
                       OpaqueSession,
                       SessionId,
                       CalloutRoutine));
            MmQuitNextSession(OpaqueSession);
            return Status;
        }

        //
        // Dispatch notification to the callout routine.
        //
        CallStatus = (CalloutRoutine)(Parameters);

        //
        // Return the callout status.
        //
        if (ARGUMENT_PRESENT(CalloutStatus)) {
            *CalloutStatus = CallStatus;
        }

        //
        // Detach from the session.
        //
        Status = MmDetachSession(OpaqueSession, &ApcState);
        ASSERT(NT_SUCCESS(Status));

        //
        // Dereference the session object.
        //
        Status = MmQuitNextSession(OpaqueSession);
        ASSERT(NT_SUCCESS(Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\worker.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    worker.c

Abstract:

    This module implements a worker thread and a set of functions for
    passing work to it.

--*/

#include "exp.h"

//
// Define balance set wait object types.
//

typedef enum _BALANCE_OBJECT {
    TimerExpiration,
    ThreadSetManagerEvent,
    ShutdownEvent,
    MaximumBalanceObject
} BALANCE_OBJECT;

//
// If this assertion fails then we must supply our own array of wait blocks.
//

C_ASSERT(MaximumBalanceObject <= THREAD_WAIT_OBJECTS);

//
// This is the structure passed around during shutdown
//

typedef struct {
    WORK_QUEUE_ITEM WorkItem;
    WORK_QUEUE_TYPE QueueType;
    PETHREAD        PrevThread;
} SHUTDOWN_WORK_ITEM, *PSHUTDOWN_WORK_ITEM;

//
// Used for disabling stack swapping
//

typedef struct _EXP_WORKER_LINK {
    LIST_ENTRY List;
    PETHREAD   Thread;
    struct _EXP_WORKER_LINK **StackRef;
} EXP_WORKER_LINK, *PEXP_WORKER_LINK;

//
// Define priorities for delayed and critical worker threads.
// Note that these do not run at realtime.
//
// They run at csrss and below csrss to avoid pre-empting the
// user interface under heavy load.
//

#define DELAYED_WORK_QUEUE_PRIORITY         (12 - NORMAL_BASE_PRIORITY)
#define CRITICAL_WORK_QUEUE_PRIORITY        (13 - NORMAL_BASE_PRIORITY)
#define HYPER_CRITICAL_WORK_QUEUE_PRIORITY  (15 - NORMAL_BASE_PRIORITY)

//
// Number of worker threads to create for each type of system.
//

#define MAX_ADDITIONAL_THREADS 16
#define MAX_ADDITIONAL_DYNAMIC_THREADS 16

#define SMALL_NUMBER_OF_THREADS 2
#define MEDIUM_NUMBER_OF_THREADS 3
#define LARGE_NUMBER_OF_THREADS 5

//
// 10-minute timeout used for terminating dynamic work item worker threads.
//

#define DYNAMIC_THREAD_TIMEOUT ((LONGLONG)10 * 60 * 1000 * 1000 * 10)

//
// 1-second timeout used for waking up the worker thread set manager.
//

#define THREAD_SET_INTERVAL (1 * 1000 * 1000 * 10)

//
// Flag to pass in to the worker thread, indicating whether it is dynamic
// or not.
//

#define DYNAMIC_WORKER_THREAD 0x80000000

//
// Per-queue dynamic thread state.
//

EX_WORK_QUEUE ExWorkerQueue[MaximumWorkQueue];

//
// Additional worker threads... Controlled using registry settings
//

ULONG ExpAdditionalCriticalWorkerThreads;
ULONG ExpAdditionalDelayedWorkerThreads;

ULONG ExCriticalWorkerThreads;
ULONG ExDelayedWorkerThreads;

//
// Global events to wake up the thread set manager.
//

KEVENT ExpThreadSetManagerEvent;
KEVENT ExpThreadSetManagerShutdownEvent;

//
// A reference to the balance manager thread, so that shutdown can
// wait for it to terminate.
//

PETHREAD ExpWorkerThreadBalanceManagerPtr;

//
// A pointer to the last worker thread to exit (so the balance manager
// can wait for it before exiting).
//

PETHREAD ExpLastWorkerThread;

//
// These are used to keep track of the set of workers, and whether or
// not we're allowing them to be paged.  Note that we can't use this
// list for shutdown (sadly), as we can't just terminate the threads,
// we need to flush their queues.
//

FAST_MUTEX ExpWorkerSwapinMutex;
LIST_ENTRY ExpWorkerListHead;
BOOLEAN    ExpWorkersCanSwap;

//
// Worker queue item that can be filled in by the kernel debugger
// to get code to run on the system.
//

WORK_QUEUE_ITEM ExpDebuggerWorkItem;
PVOID ExpDebuggerProcessKill;
PVOID ExpDebuggerProcessAttach;
PVOID ExpDebuggerPageIn;
ULONG ExpDebuggerWork;

VOID
ExpCheckDynamicThreadCount (
    VOID
    );

NTSTATUS
ExpCreateWorkerThread (
    WORK_QUEUE_TYPE QueueType,
    BOOLEAN Dynamic
    );

VOID
ExpDetectWorkerThreadDeadlock (
    VOID
    );

VOID
ExpWorkerThreadBalanceManager (
    IN PVOID StartContext
    );

VOID
ExpSetSwappingKernelApc (
    IN PKAPC Apc,
    OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

//
// Procedure prototypes for the worker threads.
//

VOID
ExpWorkerThread (
    IN PVOID StartContext
    );

LOGICAL
ExpCheckQueueShutdown (
    IN WORK_QUEUE_TYPE QueueType,
    IN PSHUTDOWN_WORK_ITEM ShutdownItem
    );

VOID
ExpShutdownWorker (
    IN PVOID Parameter
    );

VOID
ExpDebuggerWorker(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpWorkerInitialization)
#pragma alloc_text(PAGE, ExpCheckDynamicThreadCount)
#pragma alloc_text(PAGE, ExpCreateWorkerThread)
#pragma alloc_text(PAGE, ExpDetectWorkerThreadDeadlock)
#pragma alloc_text(PAGE, ExpWorkerThreadBalanceManager)
#pragma alloc_text(PAGE, ExSwapinWorkerThreads)
#pragma alloc_text(PAGEKD, ExpDebuggerWorker)
#pragma alloc_text(PAGELK, ExpSetSwappingKernelApc)
#pragma alloc_text(PAGELK, ExpCheckQueueShutdown)
#pragma alloc_text(PAGELK, ExpShutdownWorker)
#pragma alloc_text(PAGELK, ExpShutdownWorkerThreads)
#endif

LOGICAL
__forceinline
ExpNewThreadNecessary (
    IN PEX_WORK_QUEUE Queue
    )

/*++

Routine Description:

    This function checks the supplied worker queue and determines whether
    it is appropriate to spin up a dynamic worker thread for that queue.

Arguments:

    Queue - Supplies the queue that should be examined.

Return Value:

    TRUE if the given work queue would benefit from the creation of an
    additional thread, FALSE if not.

--*/
{
    if ((Queue->Info.MakeThreadsAsNecessary == 1) &&
        (IsListEmpty (&Queue->WorkerQueue.EntryListHead) == FALSE) &&
        (Queue->WorkerQueue.CurrentCount < Queue->WorkerQueue.MaximumCount) &&
        (Queue->DynamicThreadCount < MAX_ADDITIONAL_DYNAMIC_THREADS)) {

        //
        // We know these things:
        //
        // - This queue is eligible for dynamic creation of threads to try
        //   to keep the CPUs busy,
        //
        // - There are work items waiting in the queue,
        //
        // - The number of runable worker threads for this queue is less than
        //   the number of processors on this system, and
        //
        // - We haven't reached the maximum dynamic thread count.
        //
        // An additional worker thread at this point will help clear the
        // backlog.
        //

        return TRUE;
    }

    //
    // One of the above conditions is false.
    //

    return FALSE;
}

NTSTATUS
ExpWorkerInitialization (
    VOID
    )
{
    ULONG Index;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG NumberOfDelayedThreads;
    ULONG NumberOfCriticalThreads;
    ULONG NumberOfThreads;
    NTSTATUS Status;
    HANDLE Thread;
    BOOLEAN NtAs;
    WORK_QUEUE_TYPE WorkQueueType;

    ExInitializeFastMutex (&ExpWorkerSwapinMutex);
    InitializeListHead (&ExpWorkerListHead);
    ExpWorkersCanSwap = TRUE;

    //
    // Set the number of worker threads based on the system size.
    //

    NtAs = MmIsThisAnNtAsSystem();

    NumberOfCriticalThreads = MEDIUM_NUMBER_OF_THREADS;

    //
    // Incremented boot time number of delayed threads.
    // We did this in Windows XP, because 3COM NICs would take a long
    // time with the network stack tying up the delayed worker threads.
    // When Mm would need a worker thread to load a driver on the critical
    // path of boot, it would also get stuck for a few seconds and hurt
    // boot times. Ideally we'd spawn new delayed threads as necessary as
    // well to prevent such contention from hurting boot and resume.
    //

    NumberOfDelayedThreads = MEDIUM_NUMBER_OF_THREADS + 4;

    switch (MmQuerySystemSize()) {

        case MmSmallSystem:
            break;

        case MmMediumSystem:
            if (NtAs) {
                NumberOfCriticalThreads += MEDIUM_NUMBER_OF_THREADS;
            }
            break;

        case MmLargeSystem:
            NumberOfCriticalThreads = LARGE_NUMBER_OF_THREADS;
            if (NtAs) {
                NumberOfCriticalThreads += LARGE_NUMBER_OF_THREADS;
            }
            break;

        default:
            break;
    }

    //
    // Initialize the work Queue objects.
    //

    if (ExpAdditionalCriticalWorkerThreads > MAX_ADDITIONAL_THREADS) {
        ExpAdditionalCriticalWorkerThreads = MAX_ADDITIONAL_THREADS;
    }

    if (ExpAdditionalDelayedWorkerThreads > MAX_ADDITIONAL_THREADS) {
        ExpAdditionalDelayedWorkerThreads = MAX_ADDITIONAL_THREADS;
    }

    //
    // Initialize the ExWorkerQueue[] array.
    //

    RtlZeroMemory (&ExWorkerQueue[0], MaximumWorkQueue * sizeof(EX_WORK_QUEUE));

    for (WorkQueueType = 0; WorkQueueType < MaximumWorkQueue; WorkQueueType += 1) {

        KeInitializeQueue (&ExWorkerQueue[WorkQueueType].WorkerQueue, 0);
        ExWorkerQueue[WorkQueueType].Info.WaitMode = UserMode;
    }

    //
    // Always make stack for this thread resident
    // so that worker pool deadlock magic can run
    // even when what we are trying to do is inpage
    // the hyper critical worker thread's stack.
    // Without this fix, we hold the process lock
    // but this thread's stack can't come in, and
    // the deadlock detection cannot create new threads
    // to break the system deadlock.
    //

    ExWorkerQueue[HyperCriticalWorkQueue].Info.WaitMode = KernelMode;

    if (NtAs) {
        ExWorkerQueue[CriticalWorkQueue].Info.WaitMode = KernelMode;
    }

    //
    // We only create dynamic threads for the critical work queue (note
    // this doesn't apply to dynamic threads created to break deadlocks.)
    //
    // The rationale is this: folks who use the delayed work queue are
    // not time critical, and the hypercritical queue is used rarely
    // by folks who are non-blocking.
    //

    ExWorkerQueue[CriticalWorkQueue].Info.MakeThreadsAsNecessary = 1;

    //
    // Initialize the global thread set manager events
    //

    KeInitializeEvent (&ExpThreadSetManagerEvent,
                       SynchronizationEvent,
                       FALSE);

    KeInitializeEvent (&ExpThreadSetManagerShutdownEvent,
                       SynchronizationEvent,
                       FALSE);

    //
    // Create the desired number of executive worker threads for each
    // of the work queues.
    //

    //
    // Create the builtin critical worker threads.
    //

    NumberOfThreads = NumberOfCriticalThreads + ExpAdditionalCriticalWorkerThreads;
    for (Index = 0; Index < NumberOfThreads; Index += 1) {

        //
        // Create a worker thread to service the critical work queue.
        //

        Status = ExpCreateWorkerThread (CriticalWorkQueue, FALSE);

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    ExCriticalWorkerThreads += Index;

    //
    // Create the delayed worker threads.
    //

    NumberOfThreads = NumberOfDelayedThreads + ExpAdditionalDelayedWorkerThreads;
    for (Index = 0; Index < NumberOfThreads; Index += 1) {

        //
        // Create a worker thread to service the delayed work queue.
        //

        Status = ExpCreateWorkerThread (DelayedWorkQueue, FALSE);

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    ExDelayedWorkerThreads += Index;

    //
    // Create the hypercritical worker thread.
    //

    Status = ExpCreateWorkerThread (HyperCriticalWorkQueue, FALSE);

    //
    // Create the worker thread set manager thread.
    //

    InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);

    Status = PsCreateSystemThread (&Thread,
                                   THREAD_ALL_ACCESS,
                                   &ObjectAttributes,
                                   0,
                                   NULL,
                                   ExpWorkerThreadBalanceManager,
                                   NULL);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle (Thread,
                                            SYNCHRONIZE,
                                            NULL,
                                            KernelMode,
                                            &ExpWorkerThreadBalanceManagerPtr,
                                            NULL);
        ZwClose (Thread);
    }

    return Status;
}

VOID
ExQueueWorkItem (
    __inout PWORK_QUEUE_ITEM WorkItem,
    __in WORK_QUEUE_TYPE QueueType
    )

/*++

Routine Description:

    This function inserts a work item into a work queue that is processed
    by a worker thread of the corresponding type.

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must be located in NonPagedPool. The work item
        structure contains a doubly linked list entry, the address of a
        routine to call and a parameter to pass to that routine.

    QueueType - Specifies the type of work queue that the work item
        should be placed in.

Return Value:

    None.

--*/

{
    PEX_WORK_QUEUE Queue;

    ASSERT (QueueType < MaximumWorkQueue);
    ASSERT (WorkItem->List.Flink == NULL);

    //
    // Perform a rudimentary validation on the worker routine.
    //

    if ((ULONG64)WorkItem->WorkerRoutine <= MmUserProbeAddress) {

        KeBugCheckEx (WORKER_INVALID,
                      0x1,
                      (ULONG_PTR)WorkItem,
                      (ULONG_PTR)WorkItem->WorkerRoutine,
                      0);
    }

    Queue = &ExWorkerQueue[QueueType];

    //
    // Insert the work item in the appropriate queue object.
    //

    KeInsertQueue (&Queue->WorkerQueue, &WorkItem->List);

    //
    // We check the queue's shutdown state after we insert the work
    // item to avoid the race condition when the queue's marked
    // between checking the queue and inserting the item.  It's
    // possible for the queue to be marked for shutdown between the
    // insert and this assert (so the insert would've barely sneaked
    // in), but it's not worth guarding against this -- barely
    // sneaking in is not a good design strategy, and at this point in
    // the shutdown sequence, the caller simply should not be trying
    // to insert new queue items.
    //

    ASSERT (!Queue->Info.QueueDisabled);

    //
    // Determine whether another thread should be created, and signal the
    // thread set balance manager if so.
    //

    if (ExpNewThreadNecessary (Queue) != FALSE) {
        KeSetEvent (&ExpThreadSetManagerEvent, 0, FALSE);
    }

    return;
}

VOID
ExpWorkerThreadBalanceManager (
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is the startup code for the worker thread manager thread.
    The worker thread manager thread is created during system initialization
    and begins execution in this function.

    This thread is responsible for detecting and breaking circular deadlocks
    in the system worker thread queues.  It will also create and destroy
    additional worker threads as needed based on loading.

Arguments:

    Context - Supplies a pointer to an arbitrary data structure (NULL).

Return Value:

    None.

--*/
{
    KTIMER PeriodTimer;
    LARGE_INTEGER DueTime;
    PVOID WaitObjects[MaximumBalanceObject];
    NTSTATUS Status;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (StartContext);

    //
    // Raise the thread priority to just higher than the priority of the
    // critical work queue.
    //

    KeSetBasePriorityThread (KeGetCurrentThread(),
                             CRITICAL_WORK_QUEUE_PRIORITY + 1);

    //
    // Initialize the periodic timer and set the manager period.
    //

    KeInitializeTimer (&PeriodTimer);
    DueTime.QuadPart = - THREAD_SET_INTERVAL;

    //
    // Initialize the wait object array.
    //

    WaitObjects[TimerExpiration] = (PVOID)&PeriodTimer;
    WaitObjects[ThreadSetManagerEvent] = (PVOID)&ExpThreadSetManagerEvent;
    WaitObjects[ShutdownEvent] = (PVOID)&ExpThreadSetManagerShutdownEvent;

    //
    // Loop forever processing events.
    //

    while (TRUE) {

        //
        // Set the timer to expire at the next periodic interval.
        //

        KeSetTimer (&PeriodTimer, DueTime, NULL);

        //
        // Wake up when the timer expires or the set manager event is
        // signaled.
        //

        Status = KeWaitForMultipleObjects (MaximumBalanceObject,
                                           WaitObjects,
                                           WaitAny,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL,
                                           NULL);

        switch (Status) {

            case TimerExpiration:

                //
                // Periodic timer expiration - go see if any work queues
                // are deadlocked.
                //

                ExpDetectWorkerThreadDeadlock ();
                break;

            case ThreadSetManagerEvent:

                //
                // Someone has asked us to check some metrics to determine
                // whether we should create another worker thread.
                //

                ExpCheckDynamicThreadCount ();
                break;

            case ShutdownEvent:

                //
                // Time to exit...
                //

                KeCancelTimer (&PeriodTimer);

                ASSERT (ExpLastWorkerThread);

                //
                // Wait for the last worker thread to terminate
                //

                KeWaitForSingleObject (ExpLastWorkerThread,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ObDereferenceObject (ExpLastWorkerThread);

                PsTerminateSystemThread(STATUS_SYSTEM_SHUTDOWN);

                break;
        }

        //
        // Special debugger support.
        //
        // This checks if special debugging routines need to be run on the
        // behalf of the debugger.
        //

        if (ExpDebuggerWork == 1) {

             ExInitializeWorkItem(&ExpDebuggerWorkItem, ExpDebuggerWorker, NULL);
             ExpDebuggerWork = 2;
             ExQueueWorkItem(&ExpDebuggerWorkItem, DelayedWorkQueue);
        }
    }
}

VOID
ExpCheckDynamicThreadCount (
    VOID
    )

/*++

Routine Description:

    This routine is called when there is reason to believe that a work queue
    might benefit from the creation of an additional worker thread.

    This routine checks each queue to determine whether it would benefit from
    an additional worker thread (see ExpNewThreadNecessary()), and creates
    one if so.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PEX_WORK_QUEUE Queue;
    WORK_QUEUE_TYPE QueueType;

    PAGED_CODE();

    //
    // Check each worker queue.
    //

    Queue = &ExWorkerQueue[0];

    for (QueueType = 0; QueueType < MaximumWorkQueue; Queue += 1, QueueType += 1) {

        if (ExpNewThreadNecessary (Queue)) {

            //
            // Create a new thread for this queue.  We explicitly ignore
            // an error from ExpCreateDynamicThread(): there's nothing
            // we can or should do in the event of a failure.
            //

            ExpCreateWorkerThread (QueueType, TRUE);
        }
    }
}

VOID
ExpDetectWorkerThreadDeadlock (
    VOID
    )

/*++

Routine Description:

    This function creates new work item threads if a possible deadlock is
    detected.

Arguments:

    None.

Return Value:

    None

--*/

{
    ULONG Index;
    PEX_WORK_QUEUE Queue;

    PAGED_CODE();

    //
    // Process each queue type.
    //

    for (Index = 0; Index < MaximumWorkQueue; Index += 1) {

        Queue = &ExWorkerQueue[Index];

        ASSERT( Queue->DynamicThreadCount <= MAX_ADDITIONAL_DYNAMIC_THREADS );

        if ((Queue->QueueDepthLastPass > 0) &&
            (Queue->WorkItemsProcessed == Queue->WorkItemsProcessedLastPass) &&
            (Queue->DynamicThreadCount < MAX_ADDITIONAL_DYNAMIC_THREADS)) {

            //
            // These things are known:
            //
            // - There were work items waiting in the queue at the last pass.
            // - No work items have been processed since the last pass.
            // - We haven't yet created the maximum number of dynamic threads.
            //
            // Things look like they're stuck, create a new thread for this
            // queue.
            //
            // We explicitly ignore an error from ExpCreateDynamicThread():
            // we'll try again in another detection period if the queue looks
            // like it's still stuck.
            //

            ExpCreateWorkerThread (Index, TRUE);
        }

        //
        // Update some bookkeeping.
        //
        // Note that WorkItemsProcessed and the queue depth must be recorded
        // in that order to avoid getting a false deadlock indication.
        //

        Queue->WorkItemsProcessedLastPass = Queue->WorkItemsProcessed;
        Queue->QueueDepthLastPass = KeReadStateQueue (&Queue->WorkerQueue);
    }
}

NTSTATUS
ExpCreateWorkerThread (
    IN WORK_QUEUE_TYPE QueueType,
    IN BOOLEAN Dynamic
    )

/*++

Routine Description:

    This function creates a single new static or dynamic worker thread for
    the given queue type.

Arguments:

    QueueType - Supplies the type of the queue for which the worker thread
                should be created.

    Dynamic - If TRUE, the worker thread is created as a dynamic thread that
              will terminate after a sufficient period of inactivity.  If FALSE,
              the worker thread will never terminate.


Return Value:

    The final status of the operation.

Notes:

    This routine is only called from the worker thread set balance thread,
    therefore it will not be reentered.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    ULONG Context;
    ULONG BasePriority;
    PETHREAD Thread;

    InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);

    Context = QueueType;
    if (Dynamic != FALSE) {
        Context |= DYNAMIC_WORKER_THREAD;
    }

    Status = PsCreateSystemThread (&ThreadHandle,
                                   THREAD_ALL_ACCESS,
                                   &ObjectAttributes,
                                   0L,
                                   NULL,
                                   ExpWorkerThread,
                                   (PVOID)(ULONG_PTR)Context);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (Dynamic != FALSE) {
        InterlockedIncrement ((PLONG)&ExWorkerQueue[QueueType].DynamicThreadCount);
    }

    //
    // Set the priority according to the type of worker thread.
    //

    switch (QueueType) {

        case HyperCriticalWorkQueue:
            BasePriority = HYPER_CRITICAL_WORK_QUEUE_PRIORITY;
            break;

        case CriticalWorkQueue:
            BasePriority = CRITICAL_WORK_QUEUE_PRIORITY;
            break;

        case DelayedWorkQueue:
        default:

            BasePriority = DELAYED_WORK_QUEUE_PRIORITY;
            break;
    }

    //
    // Set the base priority of the just-created thread.
    //

    Status = ObReferenceObjectByHandle (ThreadHandle,
                                        THREAD_SET_INFORMATION,
                                        PsThreadType,
                                        KernelMode,
                                        (PVOID *)&Thread,
                                        NULL);

    if (NT_SUCCESS(Status)) {
        KeSetBasePriorityThread (&Thread->Tcb, BasePriority);
        ObDereferenceObject (Thread);
    }

    ZwClose (ThreadHandle);

    return Status;
}

VOID
ExpCheckForWorker (
    IN PVOID p,
    IN SIZE_T Size
    )

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PCHAR BeginBlock;
    PCHAR EndBlock;
    WORK_QUEUE_TYPE wqt;

    BeginBlock = (PCHAR)p;
    EndBlock = (PCHAR)p + Size;

    KiLockDispatcherDatabase (&OldIrql);

    for (wqt = CriticalWorkQueue; wqt < MaximumWorkQueue; wqt += 1) {
        for (Entry = (PLIST_ENTRY) ExWorkerQueue[wqt].WorkerQueue.EntryListHead.Flink;
             Entry && (Entry != (PLIST_ENTRY) &ExWorkerQueue[wqt].WorkerQueue.EntryListHead);
             Entry = Entry->Flink) {
           if (((PCHAR) Entry >= BeginBlock) && ((PCHAR) Entry < EndBlock)) {
              KeBugCheckEx(WORKER_INVALID,
                           0x0,
                           (ULONG_PTR)Entry,
                           (ULONG_PTR)BeginBlock,
                           (ULONG_PTR)EndBlock);

           }
        }
    }
    KiUnlockDispatcherDatabase (OldIrql);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const char ExpWorkerApcDisabledMessage[] =
    "EXWORKER: worker exit with APCs disabled, worker routine %x, parameter %x, item %x\n";
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

VOID
ExpWorkerThread (
    IN PVOID StartContext
    )
{
    PLIST_ENTRY Entry;
    WORK_QUEUE_TYPE QueueType;
    PWORK_QUEUE_ITEM WorkItem;
    KPROCESSOR_MODE WaitMode;
    LARGE_INTEGER TimeoutValue;
    PLARGE_INTEGER Timeout;
    PETHREAD Thread;
    PEX_WORK_QUEUE WorkerQueue;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
    EX_QUEUE_WORKER_INFO OldWorkerInfo;
    EX_QUEUE_WORKER_INFO NewWorkerInfo;
    ULONG CountForQueueEmpty;

    //
    // Set timeout value etc according to whether we are static or dynamic.
    //

    if (((ULONG_PTR)StartContext & DYNAMIC_WORKER_THREAD) == 0) {

        //
        // We are being created as a static thread.  As such it will not
        // terminate, so there is no point in timing out waiting for a work
        // item.
        //

        Timeout = NULL;
    }
    else {

        //
        // This is a dynamic worker thread.  It has a non-infinite timeout
        // so that it can eventually terminate.
        //

        TimeoutValue.QuadPart = -DYNAMIC_THREAD_TIMEOUT;
        Timeout = &TimeoutValue;
    }

    Thread = PsGetCurrentThread ();

    //
    // If the thread is a critical worker thread, then set the thread
    // priority to the lowest realtime level. Otherwise, set the base
    // thread priority to time critical.
    //

    QueueType = (WORK_QUEUE_TYPE)
                ((ULONG_PTR)StartContext & ~DYNAMIC_WORKER_THREAD);

    WorkerQueue = &ExWorkerQueue[QueueType];

    WaitMode = (KPROCESSOR_MODE) WorkerQueue->Info.WaitMode;

    ASSERT (Thread->ExWorkerCanWaitUser == 0);

    if (WaitMode == UserMode) {
        Thread->ExWorkerCanWaitUser = 1;
    }

#if defined(REMOTE_BOOT)
    //
    // In diskless NT scenarios ensure that the kernel stack of the worker
    // threads will not be swapped out.
    //

    if (IoRemoteBootClient) {
        KeSetKernelStackSwapEnable (FALSE);
    }
#endif // defined(REMOTE_BOOT)

    //
    // Register as a worker, exiting if the queue's going down and
    // there aren't any workers in the queue to hand us the shutdown
    // work item if we enter the queue (we want to be able to enter a
    // queue even if the queue's shutting down, in case there's a
    // backlog of work items that the balance manager thread's decided
    // we should be helping to process).
    //

    if (PO_SHUTDOWN_QUEUE == QueueType) {
        CountForQueueEmpty = 1;
    }
    else {
        CountForQueueEmpty = 0;
    }

    if (ExpWorkersCanSwap == FALSE) {
        KeSetKernelStackSwapEnable (FALSE);
    }

    do {

        OldWorkerInfo.QueueWorkerInfo = ReadForWriteAccess (&WorkerQueue->Info.QueueWorkerInfo);

        if (OldWorkerInfo.QueueDisabled &&
            OldWorkerInfo.WorkerCount <= CountForQueueEmpty) {

            //
            // The queue is disabled and empty so just exit.
            //

            KeSetKernelStackSwapEnable (TRUE);
            PsTerminateSystemThread (STATUS_SYSTEM_SHUTDOWN);
        }

        NewWorkerInfo.QueueWorkerInfo = OldWorkerInfo.QueueWorkerInfo;
        NewWorkerInfo.WorkerCount += 1;

    } while (OldWorkerInfo.QueueWorkerInfo !=

        InterlockedCompareExchange (&WorkerQueue->Info.QueueWorkerInfo,
                                    NewWorkerInfo.QueueWorkerInfo,
                                    OldWorkerInfo.QueueWorkerInfo));

    //
    // As of this point, we must only exit if we decrement the worker
    // count without the queue disabled flag being set.  (Unless we
    // exit due to the shutdown work item, which also decrements the
    // worker count).
    //

    Thread->ActiveExWorker = 1;

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue or until we time out.
        //
        // By specifying a wait mode of UserMode, the thread's kernel
        // stack is swappable.
        //

        Entry = KeRemoveQueue (&WorkerQueue->WorkerQueue,
                               WaitMode,
                               Timeout);

        if ((ULONG_PTR)Entry != STATUS_TIMEOUT) {

            //
            // This is a real work item, process it.
            //
            // Update the total number of work items processed.
            //

            InterlockedIncrement ((PLONG)&WorkerQueue->WorkItemsProcessed);

            WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);
            WorkerRoutine = WorkItem->WorkerRoutine;
            Parameter = WorkItem->Parameter;

            //
            // Catch worker routines referencing a user mode address.
            //

            ASSERT ((ULONG_PTR)WorkerRoutine > MmUserProbeAddress);

            //
            // Execute the specified routine.
            //

            ((PWORKER_THREAD_ROUTINE)WorkerRoutine) (Parameter);

#if DBG
            if (IsListEmpty (&Thread->IrpList)) {
                //
                // See if a worker just returned while holding a resource
                //
                ExCheckIfResourceOwned ();
            }
#endif
            //
            // Catch worker routines that forget to leave a critial/guarded
            // region. In the debug case execute a breakpoint. In the free
            // case zero the flag so that  APCs can continue to fire to this
            // thread.
            //

            if (Thread->Tcb.CombinedApcDisable != 0) {
                DbgPrint ((char*)ExpWorkerApcDisabledMessage,
                          WorkerRoutine,
                          Parameter,
                          WorkItem);

                ASSERT (FALSE);

                Thread->Tcb.CombinedApcDisable = 0;
            }

            if (KeGetCurrentIrql () != PASSIVE_LEVEL) {
                KeBugCheckEx (WORKER_THREAD_RETURNED_AT_BAD_IRQL,
                              (ULONG_PTR)WorkerRoutine,
                              (ULONG_PTR)KeGetCurrentIrql(),
                              (ULONG_PTR)Parameter,
                              (ULONG_PTR)WorkItem);
            }

            if (PS_IS_THREAD_IMPERSONATING (Thread)) {
                KeBugCheckEx (IMPERSONATING_WORKER_THREAD,
                              (ULONG_PTR)WorkerRoutine,
                              (ULONG_PTR)Parameter,
                              (ULONG_PTR)WorkItem,
                              0);
            }

            continue;
        }

        //
        // These things are known:
        //
        // - Static worker threads do not time out, so this is a dynamic
        //   worker thread.
        //
        // - This thread has been waiting for a long time with nothing
        //   to do.
        //

        if (IsListEmpty (&Thread->IrpList) == FALSE) {

            //
            // There is still I/O pending, can't terminate yet.
            //

            continue;
        }

        //
        // Get out of the queue, if we can
        //

        do {
            OldWorkerInfo.QueueWorkerInfo = ReadForWriteAccess (&WorkerQueue->Info.QueueWorkerInfo);

            if (OldWorkerInfo.QueueDisabled) {

                //
                // We're exiting via the queue disable work item;
                // there's no point in expiring here.
                //

                break;
            }

            NewWorkerInfo.QueueWorkerInfo = OldWorkerInfo.QueueWorkerInfo;
            NewWorkerInfo.WorkerCount -= 1;

        } while (OldWorkerInfo.QueueWorkerInfo
                 != InterlockedCompareExchange(&WorkerQueue->Info.QueueWorkerInfo,
                                               NewWorkerInfo.QueueWorkerInfo,
                                               OldWorkerInfo.QueueWorkerInfo));

        if (OldWorkerInfo.QueueDisabled) {

            //
            // We're exiting via the queue disable work item
            //

            continue;
        }

        //
        // This dynamic thread can be terminated.
        //

        break;

    } while (TRUE);

    //
    // Terminate this dynamic thread.
    //

    InterlockedDecrement ((PLONG)&WorkerQueue->DynamicThreadCount);

    //
    // Carefully clear this before marking the thread stack as swap enabled
    // so that an incoming APC won't inadvertently disable the stack swap
    // afterwards.
    //

    Thread->ActiveExWorker = 0;

    //
    // We will bugcheck if we terminate a thread with stack swapping
    // disabled.
    //

    KeSetKernelStackSwapEnable (TRUE);

    return;
}

VOID
ExpSetSwappingKernelApc (
    IN PKAPC Apc,
    OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )
{
    PBOOLEAN AllowSwap;
    PKEVENT SwapSetEvent;

    UNREFERENCED_PARAMETER (Apc);
    UNREFERENCED_PARAMETER (NormalRoutine);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // SystemArgument1 is a pointer to the event to signal once this
    // thread has finished servicing the request.
    //

    SwapSetEvent = (PKEVENT) *SystemArgument1;

    //
    // Don't disable stack swapping if the thread is exiting because
    // it cannot exit this way without bugchecking.  Skip it on enables
    // too since the thread is bailing anyway.
    //

    if (PsGetCurrentThread()->ActiveExWorker != 0) {
        AllowSwap = NormalContext;
        KeSetKernelStackSwapEnable (*AllowSwap);
    }

    KeSetEvent (SwapSetEvent, 0, FALSE);
}

VOID
ExSwapinWorkerThreads (
    IN BOOLEAN AllowSwap
    )

/*++

Routine Description:

    Sets the kernel stacks of the delayed worker threads to be swappable
    or pins them into memory.

Arguments:

    AllowSwap - Supplies TRUE if worker kernel stacks should be swappable,
                FALSE if not.

Return Value:

    None.

--*/

{
    PETHREAD         Thread;
    PETHREAD         CurrentThread;
    PEPROCESS        Process;
    KAPC             Apc;
    KEVENT           SwapSetEvent;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    KeInitializeEvent (&SwapSetEvent,
                       NotificationEvent,
                       FALSE);

    Process = PsInitialSystemProcess;

    //
    // Serialize callers.
    //

    ExAcquireFastMutex (&ExpWorkerSwapinMutex);

    //
    // Stop new threads from swapping.
    //

    ExpWorkersCanSwap = AllowSwap;

    //
    // Stop existing worker threads from swapping.
    //

    for (Thread = PsGetNextProcessThread (Process, NULL);
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        //
        // Skip threads that are not worker threads or worker threads that
        // were permanently marked noswap at creation time.
        //

        if (Thread->ExWorkerCanWaitUser == 0) {
            continue;
        }

        if (Thread == CurrentThread) {

            //
            // No need to use an APC on the current thread.
            //

            KeSetKernelStackSwapEnable (AllowSwap);
        }
        else {

            //
            // Queue an APC to the thread, and wait for it to fire:
            //

            KeInitializeApc (&Apc,
                             &Thread->Tcb,
                             InsertApcEnvironment,
                             ExpSetSwappingKernelApc,
                             NULL,
                             NULL,
                             KernelMode,
                             &AllowSwap);

            if (KeInsertQueueApc (&Apc, &SwapSetEvent, NULL, 3)) {

                KeWaitForSingleObject (&SwapSetEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                KeClearEvent(&SwapSetEvent);
            }
        }
    }

    ExReleaseFastMutex (&ExpWorkerSwapinMutex);
}

LOGICAL
ExpCheckQueueShutdown (
    IN WORK_QUEUE_TYPE QueueType,
    IN PSHUTDOWN_WORK_ITEM ShutdownItem
    )
{
    ULONG CountForQueueEmpty;

    if (PO_SHUTDOWN_QUEUE == QueueType) {
        CountForQueueEmpty = 1;
    }
    else {
        CountForQueueEmpty = 0;
    }

    //
    // Note that using interlocked sequences to increment the worker count
    // and decrement it to CountForQueueEmpty ensures that once it
    // *is* equal to CountForQueueEmpty and the disabled flag is set,
    // we won't be incrementing it any more, so we're safe making this
    // check without locks.
    //
    // See ExpWorkerThread, ExpShutdownWorker, and ExpShutdownWorkerThreads.
    //

    if (ExWorkerQueue[QueueType].Info.WorkerCount > CountForQueueEmpty) {

        //
        // There're still worker threads; send one of them the axe.
        //

        ShutdownItem->QueueType = QueueType;
        ShutdownItem->PrevThread = PsGetCurrentThread();
        ObReferenceObject (ShutdownItem->PrevThread);

        KeInsertQueue (&ExWorkerQueue[QueueType].WorkerQueue,
                       &ShutdownItem->WorkItem.List);
        return TRUE;
    }

    return FALSE;               // we did not queue a shutdown
}

VOID
ExpShutdownWorker (
    IN PVOID Parameter
    )
{
    PETHREAD CurrentThread;
    PSHUTDOWN_WORK_ITEM  ShutdownItem;

    ShutdownItem = (PSHUTDOWN_WORK_ITEM) Parameter;

    ASSERT (ShutdownItem != NULL);

    if (ShutdownItem->PrevThread != NULL) {

        //
        // Wait for the previous thread to exit -- if it's in the same
        // queue, it probably has already, but we need to make sure
        // (and if it's not, we *definitely* need to make sure).
        //

        KeWaitForSingleObject (ShutdownItem->PrevThread,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ObDereferenceObject (ShutdownItem->PrevThread);

        ShutdownItem->PrevThread = NULL;
    }

    //
    // Decrement the worker count.
    //

    InterlockedDecrement (&ExWorkerQueue[ShutdownItem->QueueType].Info.QueueWorkerInfo);

    CurrentThread = PsGetCurrentThread();

    if ((!ExpCheckQueueShutdown(DelayedWorkQueue, ShutdownItem)) &&
        (!ExpCheckQueueShutdown(CriticalWorkQueue, ShutdownItem))) {

        //
        // We're the last worker to exit
        //

        ASSERT (!ExpLastWorkerThread);
        ExpLastWorkerThread = CurrentThread;
        ObReferenceObject (ExpLastWorkerThread);
        KeSetEvent (&ExpThreadSetManagerShutdownEvent, 0, FALSE);
    }

    KeSetKernelStackSwapEnable (TRUE);
    CurrentThread->ActiveExWorker = 0;

    PsTerminateSystemThread (STATUS_SYSTEM_SHUTDOWN);
}

VOID
ExpShutdownWorkerThreads (
    VOID
    )
{
    PULONG QueueEnable;
    SHUTDOWN_WORK_ITEM ShutdownItem;

    if ((PoCleanShutdownEnabled () & PO_CLEAN_SHUTDOWN_WORKERS) == 0) {
        return;
    }

    ASSERT (KeGetCurrentThread()->Queue
           == &ExWorkerQueue[PO_SHUTDOWN_QUEUE].WorkerQueue);

    //
    // Mark the queues as terminating.
    //

    QueueEnable = (PULONG)&ExWorkerQueue[DelayedWorkQueue].Info.QueueWorkerInfo;

    RtlInterlockedSetBitsDiscardReturn (QueueEnable, EX_WORKER_QUEUE_DISABLED);

    QueueEnable = (PULONG)&ExWorkerQueue[CriticalWorkQueue].Info.QueueWorkerInfo;
    RtlInterlockedSetBitsDiscardReturn (QueueEnable, EX_WORKER_QUEUE_DISABLED);

    //
    // Queue the shutdown work item to the delayed work queue.  After
    // all currently queued work items are complete, this will fire,
    // repeatedly taking out every worker thread in every queue until
    // they're all done.
    //

    ExInitializeWorkItem (&ShutdownItem.WorkItem,
                          &ExpShutdownWorker,
                          &ShutdownItem);

    ShutdownItem.QueueType = DelayedWorkQueue;
    ShutdownItem.PrevThread = NULL;

    KeInsertQueue (&ExWorkerQueue[DelayedWorkQueue].WorkerQueue,
                   &ShutdownItem.WorkItem.List);

    //
    // Wait for all of the workers and the balancer to exit.
    //

    if (ExpWorkerThreadBalanceManagerPtr != NULL) {

        KeWaitForSingleObject(ExpWorkerThreadBalanceManagerPtr,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ASSERT(!ShutdownItem.PrevThread);

        ObDereferenceObject(ExpWorkerThreadBalanceManagerPtr);
    }
}

VOID
ExpDebuggerWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This is a worker thread for the kernel debugger that can be used to
    perform certain tasks on the target machine asynchronously.
    This is necessary when the machine needs to run at Dispatch level to
    perform certain operations, such as paging in data.

Arguments:

    Context - not used as this point.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    KAPC_STATE  ApcState;
    volatile UCHAR Data;
    PRKPROCESS  KillProcess = (PRKPROCESS) ExpDebuggerProcessKill;
    PRKPROCESS  AttachProcess = (PRKPROCESS) ExpDebuggerProcessAttach;
    PUCHAR PageIn = (PUCHAR) ExpDebuggerPageIn;
    PEPROCESS Process;

    ExpDebuggerProcessKill = 0;
    ExpDebuggerProcessAttach = 0;
    ExpDebuggerPageIn = 0;

    UNREFERENCED_PARAMETER (Context);

#if DBG
    if (ExpDebuggerWork != 2)
    {
        DbgPrint("ExpDebuggerWorker being entered with state != 2\n");
    }
#endif

    ExpDebuggerWork = 0;


    Process = NULL;
    if (AttachProcess || KillProcess) {
        for (Process =  PsGetNextProcess (NULL);
             Process != NULL;
             Process =  PsGetNextProcess (Process)) {
            if (&Process->Pcb ==  AttachProcess) {
                KeStackAttachProcess (AttachProcess, &ApcState);
                break;
            }
            if (&Process->Pcb ==  KillProcess) {
                PsTerminateProcess(Process, DBG_TERMINATE_PROCESS);
                PsQuitNextProcess (Process);
                return;
            }
        }
    }

    if (PageIn) {
        try {
            Data = ProbeAndReadUchar (PageIn);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }
    }

    DbgBreakPointWithStatus(DBG_STATUS_WORKER);

    if (Process != NULL) {
        KeUnstackDetachProcess (&ApcState);
        PsQuitNextProcess (Process);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\amd64\wowinfo.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    wowinfo.c

Abstract:

    This module implements the routines to returns processor-specific information
    about the x86 emulation capability.

--*/

#include "exp.h"

NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )

/*++

Routine Description:

    Retrieves the processor information of the emulation hardware.

Arguments:

    ProcessorInformation - Pointer to receive the processor's emulation information.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    //  Return INTEL processor architecture for compatibility.
    //  Use the native values for processor revision and level.
    //

    try {

        ProcessorInformation->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        ProcessorInformation->ProcessorLevel = KeProcessorLevel;
        ProcessorInformation->ProcessorRevision = KeProcessorRevision;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        
        NtStatus = GetExceptionCode ();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\amd64\hifreqlk.asm ===
title "Global SpinLock declerations"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   hifreqlk.asm
;
; Abstract:
;
;   High frequency system spin locks are declared in this module. Each spin
;   lock is placed in its own cache line on MP systems.
;
;--

include ksamd64.inc

ifdef NT_UP

ALIGN_VALUE equ 16

else

ALIGN_VALUE equ 64

endif

_DATA$00 SEGMENT PAGE 'DATA'

;
; The Initial PCR must be the first allocation in the section so it will be
; page aligned.
;

        public  KiInitialPCR
KiInitialPCR    db ProcessorControlRegisterLength dup (0)

;
; These values are referenced together so they are defined in a single cache
; line. They are never modified after they are initialized on during boot.
;
; pIofCallDriver - This is a pointer to the function to call a driver.
;

        align   ALIGN_VALUE

        public  pIofCallDriver
pIofCallDriver  dq 0

;
; pIofCompleteRequest - This is a pointer to the function to call to complete
;      an I/O request.
;

        public  pIofCompleteRequest
pIofCompleteRequest dq 0

;
; pIoAllocateIrp - This is pointer to the function to call to allocate an IRP.
;

        public  pIoAllocateIrp
pIoAllocateIrp  dq 0

;
; pIoFreeIrp - This is a pointer to a function to call to free an IRP.
;

        public  pIoFreeIrp
pIoFreeIrp      dq 0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiIdleSummary - This is the set of processors which are idle.  It is
;      used by the ready thread code to speed up the search for a thread
;      to preempt when a thread becomes runnable.
;

        align   ALIGN_VALUE

        public  KiIdleSummary
KiIdleSummary   dq 0

;
; KiIdleSMTSummary - This is the set of multithreaded processors whose physical
;       processors are totally idle.
;

        public  KiIdleSMTSummary
KiIdleSMTSummary dq 0

;
; KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  KiTbFlushTimeStamp
KiTbFlushTimeStamp dd 0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiTimeIncrementReciprocal - This is the reciprocal fraction of the time
;      increment value that is specified by the HAL when the system is
;      booted.
;

        align   ALIGN_VALUE

        public KiTimeIncrementReciprocal
KiTimeIncrementReciprocal dq 0

;
; KiTimeIncrement - This is the time increment value of the last clock
;      interrupt. This value is stored by update system time and is consumed
;      by the secondary clock interrupt routine.
;

        public  KiTimeIncrement
KiTimeIncrement dq 0

;
; KiTimeIncrementShiftCount - This is the shift count that corresponds to
;      the time increment reciprocal value.
;

        public KiTimeIncrementShiftCount
KiTimeIncrementShiftCount dd 0

;
; KeMaximumIncrement - This is the maximum time between clock interrupts
;      in 100ns units that is supported by the host HAL.
;

        public  KeMaximumIncrement
KeMaximumIncrement dd 0

;
; KeTimeAdjustment - This is the actual number of 100ns units that are to
;      be added to the system time at each interval timer interupt. This
;      value is copied from KeTimeIncrement at system start up and can be
;      later modified via the set system information service.
;      timer table entries.
;

        public  KeTimeAdjustment
KeTimeAdjustment dd 0

;
; KiTickOffset - This is the number of 100ns units remaining before a tick
;      is added to the tick count and the system time is updated.
;

        public  KiTickOffset
KiTickOffset    dd 0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
;      queued before a DPC of medium importance will trigger a dispatch
;      interrupt.
;

        align   ALIGN_VALUE

        public  KiMaximumDpcQueueDepth
KiMaximumDpcQueueDepth dd 4

;
; KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
;      must be exceeded before DPC batching of medium importance DPCs
;      will occur.
;

        public  KiMinimumDpcRate
KiMinimumDpcRate dd 3

;
; KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
;      routine to control the rate at which the processor's DPC queue depth
;      is dynamically adjusted.
;

        public  KiAdjustDpcThreshold
KiAdjustDpcThreshold dd 20

;
; KiIdealDpcRate - This is used to control the aggressiveness of the DPC
;      rate adjusting algorithm when decrementing the queue depth. As long
;      as the DPC rate for the last tick is greater than this rate, the
;      DPC queue depth will not be decremented.
;

        public  KiIdealDpcRate
KiIdealDpcRate  dd 20

;
; MmPaeMask - This is the value used to mask upper bits of a PAE PTE.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  MmPaeMask
MmPaeMask       dq 0

;
; MmHighestUserAddress - This is the highest user virtual address.
;

        public  MmHighestUserAddress
MmHighestUserAddress dq 0

;
; MmSystemRangeStart - This is the start of the system virtual address space.
;

        public  MmSystemRangeStart
MmSystemRangeStart dq 0

;
; MmUserProbeAddress - This is the address that is used to probe user buffers.
;

        public  MmUserProbeAddress
MmUserProbeAddress dq 0

;
; MmHighestPhysicalPage - This is the highest physical page number in the
;       system.
;

        public  MmHighestPhysicalPage
MmHighestPhysicalPage dq 0

;
; MmPfnDatabase - This is the base address of the PFN database.
;

        public  MmPfnDatabase
MmPfnDatabase   dq 0

;
; MmPaeErrMask - This is the PAE error mask which is used to mask the page fault
;       error code.
;

        public  MmPaeErrMask
MmPaeErrMask    dd 0

;
; MmSecondaryColors - This is the number of secondary page colors as determined
;       by the size of the second level cache.
;

        public  MmSecondaryColors
MmSecondaryColors dd 0

;
; MmSecondaryColorMask - This is the secondary color mask.
;

        public  MmSecondaryColorMask
MmSecondaryColorMask dd 0

;
; MmSecondaryColorNodeShift - This is the secondary color node shift.
;

        public  MmSecondaryColorNodeShift
MmSecondaryColorNodeShift db 0

;
; MmPfnDereferenceSListHead - This is used to store free blocks used for
;       deferred PFN reference count releasing.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  MmPfnDereferenceSListHead
MmPfnDereferenceSListHead dq 2 dup (0)

;
; MmPfnDeferredList - This is used to queue items that need reference count
;      decrement processing.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   ALIGN_VALUE

        public  MmPfnDeferredList
MmPfnDeferredList dq 0

;
; MmSystemLockPagesCount - This is the count of the number of locked pages
;       in the system.
;

        align   ALIGN_VALUE

        public  MmSystemLockPagesCount
MmSystemLockPagesCount dq 0

;
; KdDebuggerNotPresent - This marks the beginning of a kernel debugger
;       information structure so that it can be located by a debugger DLL.
;

        align   ALIGN_VALUE

        public KdDebuggerNotPresent                     
        public KiTestDividend

KiTestDividend      db  04ch
                    db  072h
                    db  053h
                    db  0A0h
                    db  0A3h
                    db  05Fh
                    db  04Bh
KdDebuggerNotPresent db 000h

_DATA$00 ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\i386\intrlfst.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    intrlfst.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
;    This module implements the fast call version of the interlocked
;    functions.
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeStatistic"
;++
;
; VOID
; FASTCALL
; ExInterlockedAddLargeStatistic (
;    IN PLARGE_INTEGER Addend,
;    IN ULONG Increment
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned large integer.
;
; Arguments:
;
;    (ecx) Addend - Supplies a pointer to the variable whose value is
;                     adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value that is added to the
;                      addend variable.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall ExInterlockedAddLargeStatistic, 2
cPublicFpo 0,0

ifdef NT_UP

        add dword ptr [ecx], edx        ; add low part of large statistic
        adc dword ptr [ecx+4], 0        ; add carry to high part

else

        lock add dword ptr [ecx], edx   ; add low part of large statistic
        jc      short Eils10            ; if c, add generated a carry
        fstRET  ExInterlockedAddLargeStatistic ; return

Eils10: lock adc dword ptr [ecx+4], 0   ; add carry to high part

endif

        fstRET  ExInterlockedAddLargeStatistic ; return

fstENDP ExInterlockedAddLargeStatistic

        page , 132
        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; FASTCALL
; ExfInterlockedAddUlong (
;    IN PULONG Addend,
;    IN ULONG Increment,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to be used to synchronize
;                   access to the addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall ExfInterlockedAddUlong, 3
cPublicFpo 1, 1

ifdef NT_UP
;
; UP version of ExInterlockedAddUlong
;

        pushfd
        cli                             ; disable interrupts

        mov     eax, [ecx]              ; (eax)= initial addend value
        add     [ecx], edx              ; [ecx]=adjusted value

        popfd                           ; restore flags including ints
        fstRET  ExfInterlockedAddUlong

else

;
; MP version of ExInterlockedAddUlong
;
        pushfd
        mov     eax, [esp+8]            ; (eax) = SpinLock
Eial10: cli                             ; disable interrupts
        ACQUIRE_SPINLOCK eax, <short Eial20>

        mov     eax, [ecx]              ; (eax)=initial addend value
        add     [ecx], edx              ; [ecx]=adjusted value

        mov     edx, [esp+8]            ; (edx) = SpinLock
        RELEASE_SPINLOCK edx
        popfd
        fstRET    ExfInterlockedAddUlong

Eial20: popfd
        pushfd
        SPIN_ON_SPINLOCK eax, <short Eial10>
endif

fstENDP ExfInterlockedAddUlong

        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExfInterlockedInsertHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) = ListHead - Supplies a pointer to the head of the doubly linked
;                       list into which an entry is to be inserted.
;
;   (edx) = ListEntry - Supplies a pointer to the entry to be inserted at the
;                       head of the list.
;
;   (esp+4)  Lock - Supplies a pointer to a spin lock to be used to synchronize
;                   access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertHeadList    , 3
cPublicFpo 1, 1

ifndef NT_UP
cPublicFpo 1, 2
        push    esi
        mov     esi, [esp+8]            ; Address of spinlock
endif
        pushfd

Eiih10: cli
        ACQUIRE_SPINLOCK    esi,<short Eiih20>

        mov     eax, LsFlink[ecx]       ; (eax)->next entry in the list
        mov     [edx]+LsFlink, eax      ; store next link in entry
        mov     [edx]+LsBlink, ecx      ; store previous link in entry
        mov     [ecx]+LsFlink, edx      ; store next link in head
        mov     [eax]+LsBlink, edx      ; store previous link in next

        RELEASE_SPINLOCK esi
        popfd
ifndef NT_UP
        pop     esi
endif
        xor     eax, ecx                ; return null if list was empty
        jz      short Eiih15
        xor     eax, ecx
Eiih15: fstRET  ExfInterlockedInsertHeadList

ifndef NT_UP
Eiih20: popfd
        pushfd
        SPIN_ON_SPINLOCK esi, <short Eiih10>
endif

fstENDP ExfInterlockedInsertHeadList

        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedInsertTailList (
;    IN PLIST_ENTRY ListHead,
;    IN PLIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;   (ecx) =  ListHead - Supplies a pointer to the head of the doubly linked
;            list into which an entry is to be inserted.
;
;   (edx) =  ListEntry - Supplies a pointer to the entry to be inserted at the
;            tail of the list.
;
;   (esp+4)  Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

cPublicFastCall ExfInterlockedInsertTailList, 3
cPublicFpo 1, 1

ifndef NT_UP
cPublicFpo 1, 2
        push    esi
        mov     esi, [esp+8]            ; Address of spinlock
endif
        pushfd

Eiit10: cli
        ACQUIRE_SPINLOCK    esi,<short Eiit20>

        mov     eax, LsBlink[ecx]       ; (eax)->prev entry in the list
        mov     [edx]+LsFlink, ecx      ; store next link in entry
        mov     [edx]+LsBlink, eax      ; store previous link in entry
        mov     [ecx]+LsBlink, edx      ; store next link in head
        mov     [eax]+LsFlink, edx      ; store previous link in next

        RELEASE_SPINLOCK esi
        popfd

ifndef NT_UP
        pop     esi
endif
        xor     eax, ecx                ; return null if list was empty
        jz      short Eiit15
        xor     eax, ecx
Eiit15: fstRET  ExfInterlockedInsertTailList

ifndef NT_UP
Eiit20: popfd
        pushfd
        SPIN_ON_SPINLOCK esi, <short Eiit10>
endif

fstENDP ExfInterlockedInsertTailList


        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; FASTCALL
; ExfInterlockedRemoveHeadList (
;    IN PLIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the doubly linked
;          list from which an entry is to be removed.
;
;    (edx) Lock - Supplies a pointer to a spin lock to be used to synchronize
;          access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedRemoveHeadList    , 2
cPublicFpo 0, 1
ifdef NT_UP
;
; UP version
;
        pushfd
        cli

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20

        mov     edx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, edx      ; store address of next in head
        mov     [edx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedRemoveHeadList

Eirh20: popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

else
;
; MP version
;

Eirh40: pushfd
        cli
        ACQUIRE_SPINLOCK edx, <short Eirh60>

        mov     eax, [ecx]+LsFlink      ; (eax)-> next entry
        cmp     eax, ecx                ; Is list empty?
        je      short Eirh50            ; if e, list is empty, go Eirh50

cPublicFpo 0,2
        push    ebx

        mov     ebx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [ecx]+LsFlink, ebx      ; store address of next in head
        mov     [ebx]+LsBlink, ecx      ; store address of previous in next
if DBG
        mov     ebx, 0badd0ffh
        mov     [eax]+LsFlink, ebx
        mov     [eax]+LsBlink, ebx
endif
        RELEASE_SPINLOCK  edx

cPublicFpo 0, 0
        pop     ebx
        popfd                           ; restore flags including interrupts
        fstRET  ExfInterlockedRemoveHeadList

Eirh50: RELEASE_SPINLOCK  edx
        popfd
        xor     eax,eax                 ; (eax) = null for empty list
        fstRET  ExfInterlockedRemoveHeadList

cPublicFpo 0, 0
Eirh60: popfd
        SPIN_ON_SPINLOCK edx, <Eirh40>
        fstRET  ExfInterlockedRemoveHeadList

endif   ; nt_up

fstENDP ExfInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; ExfInterlockedPopEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the head of the singly linked
;            list from which an entry is to be removed.
;
;    (edx) = Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall ExfInterlockedPopEntryList      , 2

ifdef NT_UP
;
; UP version
;
cPublicFpo 0,1
        pushfd
        cli                             ; disable interrupts

        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe05            ; if e, empty list, go Eipe05
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
if DBG
        mov     [eax], 0baddd0ffh
endif
cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPopEntryList    ; cReturn (eax)->removed entry

Eipe05: popfd
        xor     eax,eax
        fstRET  ExfInterlockedPopEntryList    ; cReturn (eax)=NULL

else    ; nt_up

;
; MP Version
;

cPublicFpo 0,1

Eipe10: pushfd
        cli                             ; disable interrupts

        ACQUIRE_SPINLOCK edx, <short Eipe30>

        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe20            ; if e, empty list, go Eipe20
cPublicFpo 0,2
        push    edx                     ; Save SpinLock address
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
        pop     edx                     ; Restore SpinLock address
if DBG
        mov     [eax], 0baddd0ffh
endif
        RELEASE_SPINLOCK edx

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPopEntryList

Eipe20: RELEASE_SPINLOCK edx
        popfd
        xor     eax,eax
        fstRET    ExfInterlockedPopEntryList

Eipe30: popfd
        SPIN_ON_SPINLOCK edx, Eipe10

endif   ; nt_up

fstENDP ExfInterlockedPopEntryList

        page , 132
        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; ExInterlockedPushEntryList (
;    IN PSINGLE_LIST_ENTRY ListHead,
;    IN PSINGLE_LIST_ENTRY ListEntry,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the head of the singly linked
;          list into which an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to be used to synchronize
;            access to the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall ExfInterlockedPushEntryList     , 3
ifdef NT_UP
;
; UP Version
;
cPublicFpo 0,1
        pushfd
        cli

        mov     eax, [ecx]              ; (eax)-> next entry (return value also)
        mov     [edx], eax              ; store address of next in new entry
        mov     [ecx], edx              ; set address of next in head

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPushEntryList

else
;
; MP Version
;

cPublicFpo 1,1
        pushfd
        push    edx
        mov     edx, [esp+12]           ; (edx) = SpinLock

Eipl10: cli
        ACQUIRE_SPINLOCK edx, <short Eipl20>

        pop     edx                     ; (edx)-> Entry to be pushed
        mov     eax, [ecx]              ; (eax)-> next entry (return value also)
        mov     [edx], eax              ; store address of next in new entry
        mov     [ecx], edx              ; set address of next in head

        mov     edx, [esp+8]            ; (edx) = SpinLock
        RELEASE_SPINLOCK edx

cPublicFpo 0,0
        popfd                           ; restore flags including interrupts
        fstRET    ExfInterlockedPushEntryList

cPublicFpo 1,2
Eipl20: pop     edx
        popfd                           ; Restore interrupt state

        pushfd
        push    edx
        mov     edx, [esp+12]
        SPIN_ON_SPINLOCK edx, <short Eipl10>
endif

fstENDP ExfInterlockedPushEntryList

        page , 132

        subttl  "Interlocked i386 Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   FASTCALL
;   Exfi386InterlockedIncrementLong (
;       IN PLONG Addend
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See ExInterlockedIncrementLong.  This function is the i386
;       architectural specific version of ExInterlockedIncrementLong.
;       No source directly calls this function, instead
;       ExInterlockedIncrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) Addend - Pointer to variable to increment.
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicFastCall Exfi386InterlockedIncrementLong, 1
cPublicFpo 0, 0

ifdef NT_UP
        add dword ptr [ecx],1
else
        lock add dword ptr [ecx],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        fstRET  Exfi386InterlockedIncrementLong

fstENDP Exfi386InterlockedIncrementLong


        page , 132
        subttl  "Interlocked i386 Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   FASTCALL
;   Exfi386InterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See Exi386InterlockedDecrementLong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicFastCall Exfi386InterlockedDecrementLong , 1
cPublicFpo 0, 0

ifdef NT_UP
        sub dword ptr [ecx], 1
else
        lock sub dword ptr [ecx], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        fstRET  Exfi386InterlockedDecrementLong

fstENDP Exfi386InterlockedDecrementLong

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"
;++
;
;   ULONG
;   FASTCALL
;   Exfi386InterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       (ecx) = Source - Address of ULONG to exchange
;       (edx) = Value  - New value of ULONG
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicFastCall Exfi386InterlockedExchangeUlong, 2
cPublicFpo 0,0

.486
ifndef NT_UP
        xchg    [ecx], edx                  ; make the exchange
        mov     eax, edx
else
        mov     eax, [ecx]                  ; get comperand value
Ixchg:  cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
endif
.386

        fstRET  Exfi386InterlockedExchangeUlong
fstENDP Exfi386InterlockedExchangeUlong

;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - The incremented value.
;
;--

cPublicFastCall __InterlockedIncrement,1
cPublicFpo 0,0

        mov     eax, 1                  ; set increment value

.486
ifndef NT_UP
   lock xadd    [ecx], eax              ; interlocked increment
else
        xadd    [ecx], eax              ; interlocked increment
endif
.386p
        inc     eax                     ; adjust return value

        fstRET __InterlockedIncrement

fstENDP __InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend (ecx) - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicFastCall __InterlockedDecrement,1
cPublicFpo 0,0

        mov     eax, -1                 ; set decrment value

.486
ifndef NT_UP
   lock xadd    [ecx], eax              ; interlocked decrement
else
        xadd    [ecx], eax              ; interlocked decrement
endif
.386

        dec     eax                     ; adjust return value

        fstRET __InterlockedDecrement

fstENDP __InterlockedDecrement

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   FASTCALL
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    (ecx)  Destination - Supplies a pointer to destination value.
;
;    (edx) Exchange - Supplies the exchange value.
;
;    [esp + 4] Comperand - Supplies the comperand value.
;
; Return Value:
;
;    The initial destination value is returned as the function value.
;
;--

cPublicFastCall __InterlockedCompareExchange, 3
cPublicFpo 0,0

        mov     eax, [esp + 4]          ; set comperand value
.486
ifndef NT_UP
   lock cmpxchg [ecx], edx              ; compare and exchange
else
        cmpxchg [ecx], edx              ; compare and exchange
endif
.386

        fstRET  __InterlockedCompareExchange

fstENDP __InterlockedCompareExchange

        subttl  "Interlocked Compare Exchange 64-bit - without lock"
;++
;
; LONGLONG
; FASTCALL
; ExfInterlockedCompareExchange64 (
;    IN OUT PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExfInterlockedCompareExchange64, 3

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  ExfInterlockedCompareExchange64

fstENDP ExfInterlockedCompareExchange64

        page , 132
        subttl  "Interlocked Compare Exchange 64-bits - with lock"
;++
;
; LONGLONG
; FASTCALL
; ExInterlockedCompareExchange64 (
;    IN PLONGLONG Destination,
;    IN PLONGLONG Exchange,
;    IN PLONGLONG Comperand,
;    IN PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs a compare and exchange of 64-bits.
;
;    N.B. This routine is provided for backward compatibility only. The
;         lock address is not used.
;
; Arguments:
;
;    (ecx) Destination - Supplies a pointer to the destination variable.
;
;    (edx) Exchange - Supplies a pointer to the exchange value.
;
;    (esp+4) Comperand - Supplies a pointer to the comperand value.
;
;    (esp+4) Lock - Supplies a pointer to a spin lock to use if the cmpxchg8b
;        instruction is not available on the host system.
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicFastCall ExInterlockedCompareExchange64, 4

cPublicFpo 0,2

;
; Save nonvolatile registers and read the exchange and comperand values.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; set destination address
        mov     ebx, [edx]              ; get exchange value
        mov     ecx, [edx] + 4          ;
        mov     edx, [esp] + 12         ; get comperand address
        mov     eax, [edx]              ; get comperand value
        mov     edx, [edx] + 4          ;

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr[ebp]        ; compare and exchange

endif
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    ExInterlockedCompareExchange64

fstENDP ExInterlockedCompareExchange64

        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   FASTCALL
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    (ecx)  Addend - Supplies a pointer to a variable whose value is to be
;                    adjusted by the increment value.
;
;    (edx) Increment - Supplies the increment value to be added to the
;                      addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

cPublicFastCall __InterlockedExchangeAdd, 2
cPublicFpo 0,0

.486
ifndef NT_UP
   lock xadd    [ecx], edx              ; exchange add
else
        xadd    [ecx], edx              ; exchange add
endif
.386

        mov     eax, edx                ; set initial value

        fstRET  __InterlockedExchangeAdd

fstENDP __InterlockedExchangeAdd

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\zone.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    zone.c

Abstract:

    This module implements a simple zone buffer manager.  The primary
    consumer of this module is local LPC.

    The zone package provides a fast and efficient memory allocator for
    fixed-size 64-bit aligned blocks of storage.  The zone package does
    not provide any serialization over access to the zone header and
    associated free list and segment list.  It is the responsibility of
    the caller to provide any necessary serialization.

    The zone package views a zone as a set of fixed-size blocks of
    storage.  The block size of a zone is specified during zone
    initialization.  Storage is assigned to a zone during zone
    initialization and when a zone is extended.  In both of these cases,
    a segment and length are specified.

    The zone package uses the first ZONE_SEGMENT_HEADER portion of the
    segment for zone overhead.  The remainder of the segment is carved
    up into fixed-size blocks and each block is added to the free list
    maintained in the zone header.

    As long as a block is on the free list, the first SINGLE_LIST_ENTRY
    (32 bit) sized piece of the block is used as zone overhead.  The
    rest of the block is not used by the zone package and may be used by
    applications to cache information.  When a block is not on the free
    list, its entire contents are available to the application.

--*/

#include "exp.h"

NTSTATUS
ExInitializeZone(
    __out PZONE_HEADER Zone,
    __in ULONG BlockSize,
    __inout PVOID InitialSegment,
    __in ULONG InitialSegmentSize
    )

/*++

Routine Description:

    This function initializes a zone header.  Once successfully
    initialized, blocks can be allocated and freed from the zone, and
    the zone can be extended.

Arguments:

    Zone - Supplies the address of a zone header to be initialized.

    BlockSize - Supplies the block size of the allocatable unit within
                the zone.  The size must be larger that the size of the
                initial segment, and must be 64-bit aligned.

    InitialSegment - Supplies the address of a segment of storage.  The
                     first ZONE_SEGMENT_HEADER-sized portion of the segment
                     is used by the zone allocator.  The remainder of
                     the segment is carved up into fixed size
                     (BlockSize) blocks and is made available for
                     allocation and deallocation from the zone.  The
                     address of the segment must be aligned on a 64-bit
                     boundary.

    InitialSegmentSize - Supplies the size in bytes of the InitialSegment.

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or InitialSegment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the initial segment size.

    STATUS_SUCCESS - The zone was successfully initialized.

--*/

{
    ULONG i;
    PCH p;

    if ( (BlockSize & 7) || ((ULONG_PTR)InitialSegment & 7) ||
         (BlockSize > InitialSegmentSize) ) {
#if DBG
        DbgPrint( "EX: ExInitializeZone( %x, %x, %x, %x ) - Invalid parameters.\n",
                  Zone, BlockSize, InitialSegment, InitialSegmentSize
                );
        DbgBreakPoint();
#endif
        return STATUS_INVALID_PARAMETER;
    }

    Zone->BlockSize = BlockSize;

    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->SegmentList.Next = NULL;
    ((PZONE_SEGMENT_HEADER) InitialSegment)->Reserved = NULL;

    Zone->FreeList.Next = NULL;

    p = (PCH)InitialSegment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= InitialSegmentSize - BlockSize;
         i += BlockSize
        ) {
        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += BlockSize;
    }
    Zone->TotalSegmentSize = i;

    return STATUS_SUCCESS;
}

NTSTATUS
ExExtendZone(
    __inout PZONE_HEADER Zone,
    __inout PVOID Segment,
    __in ULONG SegmentSize
    )

/*++

Routine Description:

    This function extends a zone by adding another segment's worth of
    blocks to the zone.

Arguments:

    Zone - Supplies the address of a zone header to be extended.

    Segment - Supplies the address of a segment of storage.  The first
              ZONE_SEGMENT_HEADER-sized portion of the segment is used by the
              zone allocator.  The remainder of the segment is carved up
              into fixed-size (BlockSize) blocks and is added to the
              zone.  The address of the segment must be aligned on a 64-
              bit boundary.

    SegmentSize - Supplies the size in bytes of Segment.

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or Segment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the segment size.

    STATUS_SUCCESS - The zone was successfully extended.

--*/

{
    ULONG i;
    PCH p;

    if ( ((ULONG_PTR)Segment & 7) ||
         (SegmentSize & 7) ||
         (Zone->BlockSize > SegmentSize) ) {
        return STATUS_UNSUCCESSFUL;
    }

    ((PZONE_SEGMENT_HEADER) Segment)->SegmentList.Next = Zone->SegmentList.Next;
    Zone->SegmentList.Next = &((PZONE_SEGMENT_HEADER) Segment)->SegmentList;

    p = (PCH)Segment + sizeof(ZONE_SEGMENT_HEADER);

    for (i = sizeof(ZONE_SEGMENT_HEADER);
         i <= SegmentSize - Zone->BlockSize;
         i += Zone->BlockSize
        ) {

        ((PSINGLE_LIST_ENTRY)p)->Next = Zone->FreeList.Next;
        Zone->FreeList.Next = (PSINGLE_LIST_ENTRY)p;
        p += Zone->BlockSize;
    }
    Zone->TotalSegmentSize += i;

    return STATUS_SUCCESS;
}



NTSTATUS
ExInterlockedExtendZone(
    __inout PZONE_HEADER Zone,
    __inout PVOID Segment,
    __in ULONG SegmentSize,
    __inout PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function extends a zone by adding another segment's worth of
    blocks to the zone.

Arguments:

    Zone - Supplies the address of a zone header to be extended.

    Segment - Supplies the address of a segment of storage.  The first
              ZONE_SEGMENT_HEADER-sized portion of the segment is used by the
              zone allocator.  The remainder of the segment is carved up
              into fixed-size (BlockSize) blocks and is added to the
              zone.  The address of the segment must be aligned on a 64-
              bit boundary.

    SegmentSize - Supplies the size in bytes of Segment.

    Lock - pointer to spinlock to use

Return Value:

    STATUS_UNSUCCESSFUL - BlockSize or Segment was not aligned on
                          64-bit boundaries, or BlockSize was larger than
                          the segment size.

    STATUS_SUCCESS - The zone was successfully extended.

--*/

{
    NTSTATUS Status;
    KIRQL OldIrql;

#ifdef NT_UP
    UNREFERENCED_PARAMETER (Lock);
#endif

    ExAcquireSpinLock( Lock, &OldIrql );

    Status = ExExtendZone( Zone, Segment, SegmentSize );

    ExReleaseSpinLock( Lock, OldIrql );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\amd64\hrderror.asm ===
title  "Hard Error Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   hrderror.asm
;
; Abstract:
;
;   This module implements code necessary to save processor context and 
;   state at hard error.
;
;--

include ksamd64.inc

        extern  ExpSystemErrorHandler2:proc
        extern  KiSaveProcessorControlState:proc
        extern  RtlCaptureContext:proc

        subttl  "System Error Handler"
;++
;
; VOID
; ExpSystemErrorHandler (
;     IN NTSTATUS ErrorStatus,
;     IN ULONG NumberOfParameters,
;     IN ULONG UnicodeStringParameterMask,
;     IN PULONG_PTR Parameters,
;     IN BOOLEAN CallShutdown
;     )
;
; Routine Description:
;
;   This function saves the processor context and control state at hard error. 
;
; Return Value:
;
;   None.
;
;--

EhFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
        OldIrql dq ?                    ; saved IRQL
        Flags   dq ?                    ; saved Rflags
EhFrame ends

        NESTED_ENTRY ExpSystemErrorHandler, _TEXT$00

        mov     P1Home[rsp], rcx        ; save argument registers
        mov     P2Home[rsp], rdx        ;
        mov     P3Home[rsp], r8         ;
        mov     P4Home[rsp], r9         ;

        push_eflags                     ; push processor flags
        alloc_stack (sizeof EhFrame - 8); allocate stack frame

        END_PROLOGUE

;
; Capture processor context and control state.
;

        mov     EhFrame.OldIrql[rsp], rax ; keep a copy of rax 
        mov     rcx, DISPATCH_LEVEL     ; raise to DISPATCH_LEVEL

        RaiseIrql                       ; raise IRQL

        xchg    EhFrame.OldIrql[rsp], rax ; save previous IRQL and restore rax
        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        add     rcx, PbProcessorState + PsContextFrame ; set context address
        call    RtlCaptureContext       ; capture processor context
        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        add     rcx, PbProcessorState   ; set address of processor state
        call    KiSaveProcessorControlState; save processor control state     

;
; Update captured context to the state at the entry of this function.
;

        mov     r10, gs:[PcCurrentPrcb] ; get current PRCB address
        add     r10, PbProcessorState   ; point to processor state
        mov     rax, EhFrame.OldIrql[rsp] ; get saved cr8 
        mov     PsCr8[r10], rax         ; update cr8 in processor state
        add     r10, PsContextFrame     ; point to context frame
        mov     rax, P1Home + sizeof EhFrame[rsp] ; get saved rcx
        mov     CxRcx[r10], rax         ; update rcx in context frame
        mov     rax, EhFrame.Flags[rsp] ; get saved flags
        mov     CxEFlags[r10], rax      ; update rflag in context frame
        lea     rax, sizeof EhFrame[rsp]; calculate rsp at function entry
        mov     CxRsp[r10], rax;        ; update rsp in context frame
        lea     rax, ExpSystemErrorHandler ; get the Rip at function entry
        mov     CxRip[r10], rax         ; update rip in context frame

;
; Call the system error handler.
;
        
        mov     rcx, EhFrame.OldIrql[rsp] ; get previous IRQL

        LowerIrql                       ; lower IRQL to previous level

        mov     rax, (5 * 8) + sizeof EhFrame[rsp] ; get parameter 5
        mov     EhFrame.P5Home[rsp], rax; set parameter 5
        mov     r9,  P4Home + sizeof EhFrame[rsp] ; restore parameter 4
        mov     r8,  P3Home + sizeof EhFrame[rsp] ; restore parameter 3
        mov     rdx, P2Home + sizeof EhFrame[rsp] ; restore parameter 2
        mov     rcx, P1Home + sizeof EhFrame[rsp] ; restore parameter 1
        call    ExpSystemErrorHandler2  ; call the error handler
        add     rsp, (sizeof EhFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END ExpSystemErrorHandler, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\amd64\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   intrlock.asm
;
; Abstract:
;
;   This module implements functions to support interlocked operations.
;
;--

include ksamd64.inc

        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;     __inout PLARGE_INTEGER Addend,
;     __in LARGE_INTEGER Increment,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function performs an interlocked add of an increment value to an
;   addend variable of type unsigned large integer. The initial value of
;   the addend variable is returned as the function value.
;
;   N.B. The specification of this function requires that the given lock
;        must be used to synchronize the update even though on AMD64 the
;        operation can actually be done atomically without using the lock.
;
; Arguments:
;
;   Addend (rcx) - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;   Increment (rdx) - Supplies the increment value to be added to the
;       addend variable.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;   The initial value of the addend variable is returned.
;
;--

        NESTED_ENTRY ExInterlockedAddLargeInteger, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        mov     rax, rdx                ; copy increment value

        AcquireSpinLockDisable [r8]     ; acquire spin lock, interrupts disabled

        xadd    [rcx], rax              ; compute sum of addend and increment 

        ReleaseSpinLockEnable [r8]      ; release spin lock

        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedAddLargeInteger, _TEXT$00

        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; ExInterlockedAddUlong (
;     __inout PULONG Addend,
;     __in ULONG Increment,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function performs an interlocked add of an increment value to an
;   addend variable of type unsigned long. The initial value of the addend
;   variable is returned as the function value.
;
;   N.B. The specification of this function requires that the given lock
;        must be used to synchronize the update even though on AMD64 the
;        operation can actually be done atomically without using the lock.
;
; Arguments:
;
;   Addend (rcx) - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;   Increment (edx) - Supplies the increment value to be added to the
;       addend variable.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;   The initial value of the addend variable.
;
;--

        NESTED_ENTRY ExInterlockedAddUlong, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        mov     eax, edx                ; copy increment value

        AcquireSpinLockDisable [r8]     ; acquire spin lock, ints disabled

        xadd    [rcx], eax              ; compute sum of addend and increment

        ReleaseSpinLockEnable [r8]      ; release spin lock

        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedAddUlong, _TEXT$00

        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertHeadList (
;     __inout PLIST_ENTRY ListHead,
;     __inout PLIST_ENTRY ListEntry,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Pointer to entry that was at the head of the list or NULL if the list
;   was empty.
;
;--

        NESTED_ENTRY ExInterlockedInsertHeadList, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        prefetchw [rcx]                 ; prefetch entry for write

        AcquireSpinLockDisable [r8]     ; acquire spin lock, ints disabled

        mov     rax, LsFlink[rcx]       ; get address of first entry
        mov     LsFlink[rdx], rax       ; set next link in entry
        mov     LsBlink[rdx], rcx       ; set back link in entry
        mov     LsFlink[rcx], rdx       ; set next link in head
        mov     LsBlink[rax], rdx       ; set back link in next

        ReleaseSpinLockEnable [r8]      ; release spin lock

        xor     rcx, rax                ; check if list was empty
        cmovz   rax, rcx                ; if z, list was empty
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedInsertHeadList, _TEXT$00

        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertTailList (
;     __inout PLIST_ENTRY ListHead,
;     __inout PLIST_ENTRY ListEntry,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the tail of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       tail of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Pointer to entry that was at the tail of the list or NULL if the list
;   was empty.
;
;--

        NESTED_ENTRY ExInterlockedInsertTailList, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        prefetchw [rcx]                 ; prefetch entry for write

        AcquireSpinLockDisable [r8]     ; acquire spin lock, ints disabled

        mov     rax, LsBlink[rcx]       ; get address of last entry
        mov     LsFlink[rdx], rcx       ; set next link in entry
        mov     LsBlink[rdx], rax       ; set back link in entry
        mov     LsBlink[rcx], rdx       ; set back link in head
        mov     LsFlink[rax], rdx       ; set next link in last

        ReleaseSpinLockEnable [r8]      ; release spin lock

        xor     rcx, rax                ; check if list was empty
        cmovz   rax, rcx                ; if z, list was empty
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedInsertTailList, _TEXT$00

        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedRemoveHeadList (
;     __inout PLIST_ENTRY ListHead,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function removes an entry from the head of a doubly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the doubly linked
;       list from which an entry is to be removed.
;
;   Lock (rdx) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        NESTED_ENTRY ExInterlockedRemoveHeadList, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        AcquireSpinLockDisable [rdx]    ; acquire spin lock

        mov     rax, LsFlink[rcx]       ; get address of first entry
        cmp     rax, rcx                ; check if list is empty
        je      short EiRH10            ; if e, list is empty
        mov     r8, LsFlink[rax]        ; get address of next entry
        mov     LsFlink[rcx], r8        ; set address of first entry
        mov     LsBlink[r8], rcx        ; set back in next entry

EiRH10: ReleaseSpinLockEnable [rdx]     ; release spin lock

        xor     rcx, rax                ; check if list was empty
        cmovz   rax, rcx                ; if z, list was empty
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedRemoveHeadList, _TEXT$00

        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPopEntryList (
;     __inout PSINGLE_LIST_ENTRY ListHead,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function removes an entry from the front of a singly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;   If there are no entries in the list, then a value of NULL is returned.
;   Otherwise, the address of the entry that is removed is returned as the
;   function value.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the singly linked
;       list from which an entry is to be removed.
;
;   Lock (rdx) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   The address of the entry removed from the list, or NULL if the list is
;   empty.
;
;--

        NESTED_ENTRY ExInterlockedPopEntryList, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        AcquireSpinLockDisable [rdx]    ; acquire spin lock, ints disabled

        mov     rax, [rcx]              ; get address of first entry
        test    rax, rax                ; check if list is empty
        jz      short EiPE10            ; if z, list is empty
        mov     r8, [rax]               ; get address of next entry
        mov     [rcx], r8               ; set address of first entry

EiPE10: ReleaseSpinLockEnable [rdx]     ; release spin lock

        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END ExInterlockedPopEntryList, _TEXT$00

        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPushEntryList (
;     __inout PSINGLE_LIST_ENTRY ListHead,
;     __inout PSINGLE_LIST_ENTRY ListEntry,
;     __inout PKSPIN_LOCK Lock
;     )
;
; Routine Description:
;
;   This function inserts an entry at the head of a singly linked list
;   so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;   ListHead (rcx) - Supplies a pointer to the head of the singly linked
;       list into which an entry is to be inserted.
;
;   ListEntry (rdx) - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;   Lock (r8) - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;   Previous contents of ListHead. NULL implies list went from empty to not
;   empty.
;
;--

        NESTED_ENTRY ExInterlockedPushEntryList, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        prefetchw [rcx]                 ; prefetch entry for write

        AcquireSpinLockDisable [r8]     ; acquire spin lock

        mov     rax, [rcx]              ; get address of first entry
        mov     [rdx], rax              ; set address of next entry
        mov     [rcx], rdx              ; set address of first entry

        ReleaseSpinLockEnable [r8]      ; release spin lock

        add     rsp, 8                  ; deallocate stack frame
        ret                             ;

        NESTED_END ExInterlockedPushEntryList, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\i386\splocks.asm ===
title "Global SpinLock declerations"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    splocks.asm
;
; Abstract:
;
;    All global spinlocks in the kernel image are declared in this
;    module.  This is done so that each spinlock can be spaced out
;    sufficiently to guarantee that the L2 cache does not thrash
;    by having a spinlock and another high use variable in the same
;    cache line.
;
;--

.386p
        .xlist

ifdef NT_UP

PADLOCKS equ    4

_DATA   SEGMENT PARA PUBLIC 'DATA'

else

PADLOCKS equ    128

_DATA   SEGMENT PAGE PUBLIC 'DATA'

endif

ULONG   macro   VariableName

        align   PADLOCKS

        public  VariableName
VariableName    dd      0

        endm

;
; These values are referenced together so they are defined in a single cache
; line. They are never modified after they are initialized on during boot.
;
; pIofCallDriver - This is a pointer to the function to call a driver.
;

        align   PADLOCKS

        public  _pIofCallDriver
_pIofCallDriver dd      0

;
; pIofCompleteRequest - This is a pointer to the function to call to complete
;      an I/O request.
;

        public  _pIofCompleteRequest
_pIofCompleteRequest dd 0

;
; pIoAllocateIrp - This is pointer to the function to call to allocate an IRP.
;

        public  _pIoAllocateIrp
_pIoAllocateIrp dd      0

;
; pIoFreeIrp - This is a pointer to a function to call to free an IRP.
;

        public  _pIoFreeIrp
_pIoFreeIrp     dd      0

;
; These variables are updated frequently and under control of the dispatcher
; database lock. They are defined in a single cache line to reduce false
; sharing in MP systems.
;
; KiIdleSummary - This is the set of processors which are idle.  It is
;      used by the ready thread code to speed up the search for a thread
;      to preempt when a thread becomes runnable.
;

        align   PADLOCKS

        public  _KiIdleSummary
_KiIdleSummary  dd      0

;
; KiIdleSMTSummary - In multi threaded processors, this is the set of
;      idle processors in which all the logical processors that make up a
;      physical processor are idle.   That is, this is the set of logical
;      processors in completely idle physical processors.
;

        public  _KiIdleSMTSummary
_KiIdleSMTSummary dd    0

;
; KiTbFlushTimeStamp - This is the TB flush entire time stamp counter.
;
; This variable is in it own cache line to reduce false sharing on MP systems.
;

        align   PADLOCKS

        public  _KiTbFlushTimeStamp
_KiTbFlushTimeStamp dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KeTickCount - This is the number of clock ticks that have occurred since
;      the system was booted. This count is used to compute a millisecond
;      tick counter.
;

        align   PADLOCKS

        public  _KeTickCount
_KeTickCount    dd      0, 0, 0

;
; KeMaximumIncrement - This is the maximum time between clock interrupts
;      in 100ns units that is supported by the host HAL.
;

        public  _KeMaximumIncrement
_KeMaximumIncrement dd      0

;
; KiTimeIncrementReciprocal - This is the reciprocal fraction of the time
;      increment value that is specified by the HAL when the system is
;      booted.
;

        public  _KiTimeIncrementReciprocal
_KiTimeIncrementReciprocal dq 0

;
; KeTimeAdjustment - This is the actual number of 100ns units that are to
;      be added to the system time at each interval timer interupt. This
;      value is copied from KeTimeIncrement at system start up and can be
;      later modified via the set system information service.
;      timer table entries.
;

        public  _KeTimeAdjustment
_KeTimeAdjustment dd      0

;
; KiTimeIncrementShiftCount - This is the shift count that corresponds to
;      the time increment reciprocal value.
;

        public  _KiTimeIncrementShiftCount
_KiTimeIncrementShiftCount dd 0

;
; KiTickOffset - This is the number of 100ns units remaining before a tick
;      is added to the tick count and the system time is updated.
;

        public  _KiTickOffset
_KiTickOffset   dd      0

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KiMaximumDpcQueueDepth - This is used to control how many DPCs can be
;      queued before a DPC of medium importance will trigger a dispatch
;      interrupt.
;

        align   PADLOCKS

        public  _KiMaximumDpcQueueDepth
_KiMaximumDpcQueueDepth dd      4

;
; KiMinimumDpcRate - This is the rate of DPC requests per clock tick that
;      must be exceeded before DPC batching of medium importance DPCs
;      will occur.
;

        public  _KiMinimumDpcRate
_KiMinimumDpcRate dd      3

;
; KiAdjustDpcThreshold - This is the threshold used by the clock interrupt
;      routine to control the rate at which the processor's DPC queue depth
;      is dynamically adjusted.
;

        public  _KiAdjustDpcThreshold
_KiAdjustDpcThreshold dd      20

;
; KiIdealDpcRate - This is used to control the aggressiveness of the DPC
;      rate adjusting algorithm when decrementing the queue depth. As long
;      as the DPC rate for the last tick is greater than this rate, the
;      DPC queue depth will not be decremented.
;

        public  _KiIdealDpcRate
_KiIdealDpcRate dd      20

;
; These variables are referenced together and are defined in a single cache
; line to reduce sharing on MP systems.
;
; KeErrorMask - This is the value used to mask the error code passed to
;      memory management on page faults.
;

        align   PADLOCKS

        public  _KeErrorMask
_KeErrorMask    dd      1

;
; MmPaeErrMask - This is the value used to mask upper bits of a PAE error.
;

        public  _MmPaeErrMask
_MmPaeErrMask   dd      0

;
; MmPaeMask - This is the value used to mask upper bits of a PAE PTE.
;

        public  _MmPaeMask
_MmPaeMask      dq      0

;
; MmHighestUserAddress - This is the highest user virtual address.
;

        public  _MmHighestUserAddress
_MmHighestUserAddress dd 0

;
; MmSystemRangeStart - This is the start of the system virtual address space.
;

        public  _MmSystemRangeStart
_MmSystemRangeStart dd 0

;
; MmUserProbeAddress - This is the address that is used to probe user buffers.
;

        public  _MmUserProbeAddress
_MmUserProbeAddress dd 0

;
; MmHighestPhysicalPage - This is the highest physical page number in the
;       system.
;

        public  _MmHighestPhysicalPage
_MmHighestPhysicalPage dd 0

;
; MmPfnDatabase - This is the base address of the PFN database.
;

        public  _MmPfnDatabase
_MmPfnDatabase  dd 0

;
; MmSecondaryColors - This is the number of secondary page colors as determined
;       by the size of the second level cache.
;

        public  _MmSecondaryColors
_MmSecondaryColors dd 0

;
; MmSecondaryColorMask - This is the secondary color mask.
;

        public  _MmSecondaryColorMask
_MmSecondaryColorMask dd 0

;
; MmSecondaryColorNodeShift - This is the secondary color node shift.
;

        public  _MmSecondaryColorNodeShift
_MmSecondaryColorNodeShift db 0

;
; MmPfnDereferenceSListHead - This is used to store free blocks used for
;      deferred PFN reference count releasing.
;

        align   PADLOCKS

        public  _MmPfnDereferenceSListHead
_MmPfnDereferenceSListHead  dq      0

;
; MmPfnDeferredList - This is used to queue items that need reference count
;      decrement processing.
;

        align   PADLOCKS

        public  _MmPfnDeferredList
_MmPfnDeferredList          dd      0

;
; MmSystemLockPagesCount - This is the count of the number of locked pages
;       in the system.
;

        align   PADLOCKS

        public  _MmSystemLockPagesCount
_MmSystemLockPagesCount     dd      0

        align   PADLOCKS

_DATA   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ex\i386\intrlock.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    intrlock.asm
;
; Abstract:
;
;    This module implements functions to support interlocked operations.
;    Interlocked operations can only operate on nonpaged data.
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   General Notes on Interlocked Procedures:
;
;       These procedures assume that neither their code, nor any of
;       the data they touch, will cause a page fault.
;
;       They use spinlocks to achieve MP atomicity, iff it's an MP machine.
;       (The spinlock macros generate zilch if NT_UP = 1, and
;        we if out some aux code here as well.)
;
;       They turn off interrupts so that they can be used for synchronization
;       between ISRs and driver code.  Flags are preserved so they can
;       be called in special code (Like IPC interrupt handlers) that
;       may have interrupts off.
;
;--


;;      align  512

        page ,132
        subttl  "ExInterlockedAddLargeInteger"
;++
;
; LARGE_INTEGER
; ExInterlockedAddLargeInteger (
;    __inout PLARGE_INTEGER Addend,
;    __in LARGE_INTEGER Increment,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsined large integer. The initial value of
;    the addend variable is returned as the function value.
;
; Arguments:
;
;    (TOS+4) = Addend - a pointer to the addend value
;    (TOS+8) = Increment - the increment value
;    (TOS+16) = Lock - a pointer to a pointer to a spin lock
;
; Return Value:
;
;    The initial value of the addend variable is stored in eax:edx
;
;--

EiulAddend      equ     [ebp + 8]
EiulIncrement   equ     [ebp + 12]
EiulLock        equ     [ebp + 20]
EiulRetval      equ     [ebp - 8]

cPublicProc _ExInterlockedAddLargeInteger, 4

        push    ebp
        mov     ebp,esp
        sub     esp, 8

ifndef NT_UP
        mov     eax,EiulLock            ; (eax) -> KSPIN_LOCK
endif

eiul10: pushfd
        cli                             ; disable interrupts
        ACQUIRE_SPINLOCK eax,<short eiul20>

        mov     eax,EiulAddend          ; (eax)-> addend variable
        mov     ecx,[eax]               ; (ecx)= low part of addend value
        mov     edx,[eax]+4             ; (edx)= high part of addend value
        mov     EiulRetVal,ecx               ; set low part of return value
        mov     EiulRetVal+4,edx             ; set high part of return value
        add     ecx,EiulIncrement       ; add low parts of large integer
        adc     edx,EiulIncrement+4     ; add high parts of large integer and carry
        mov     eax,EiulAddend          ; RELOAD (eax)-> addend variable
        mov     [eax],ecx               ; store low part of result
        mov     [eax]+4,edx             ; store high part of result

ifndef NT_UP
        mov     eax,EiulLock
        RELEASE_SPINLOCK   eax          ; NOTHING if NT_UP = 1
endif
        popfd                           ; restore flags including interrupts
        mov     eax, EiulRetval         ; calling convention
        mov     edx, EiulRetval+4       ; calling convention
        mov     esp, ebp
        pop     ebp
        stdRET    _ExInterlockedAddLargeInteger

ifndef NT_UP
eiul20: popfd
        SPIN_ON_SPINLOCK   eax, eiul10
endif

stdENDP _ExInterlockedAddLargeInteger

        page , 132
        subttl  "Interlocked Add Unsigned Long"
;++
;
; ULONG
; ExInterlockedAddUlong (
;    __inout PULONG Addend,
;    __in ULONG Increment,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsigned long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the addend variable.
;
; Return Value:
;
;    The initial value of the addend variable.
;
;--

EialAddend      equ     [esp + 8]
EialIncrement   equ     [esp + 12]
EialLock        equ     [esp + 16]

; end of arguments

cPublicProc _ExInterlockedAddUlong  , 3
cPublicFpo 3, 1

ifdef NT_UP
;
; UP version of ExInterlockedAddUlong
;

        pushfd
        cli                             ; disable interrupts

        mov     ecx, EialAddend         ; (ecx)->initial addend value
        mov     edx, [ecx]              ; (edx)= initial addend value
        mov     eax, edx                ; (eax)= initial addend value
        add     edx, EialIncrement      ; (edx)=adjusted value
        mov     [ecx], edx              ; [ecx]=adjusted value

        popfd                           ; restore flags including ints
        stdRET    _ExInterlockedAddUlong                             ; cRetURN

else

;
; MP version of ExInterlockedAddUlong
;
        pushfd
        mov     edx,EialLock            ; (edx)-> KSPIN_LOCK
Eial10: cli                             ; disable interrupts
        ACQUIRE_SPINLOCK edx, <short Eial20>

        mov     ecx, EialAddend         ; (ecx)->initial addend value
        mov     eax, [ecx]              ; (eax)=initial addend value
        add     eax, EialIncrement      ; (eax)=adjusted value
        mov     [ecx], eax              ; [ecx]=adjusted value
        sub     eax, EialIncrement      ; (eax)=initial addend value

        RELEASE_SPINLOCK edx
        popfd
        stdRET    _ExInterlockedAddUlong                             ; cRetURN

Eial20: popfd
        pushfd
        SPIN_ON_SPINLOCK edx, <short Eial10>
endif

stdENDP _ExInterlockedAddUlong


        page , 132
        subttl  "Interlocked Insert Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertHeadList (
;    __inout PLIST_ENTRY ListHead,
;    __inout PLIST_ENTRY ListEntry,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the head of the list or NULL if the list
;    was empty.
;
;--

EiihListHead    equ     [esp + 8]
EiihListEntry   equ     [esp + 12]
EiihLock        equ     [esp + 16]

; end arguments

cPublicProc _ExInterlockedInsertHeadList    , 3
cPublicFpo 3, 1

ifndef NT_UP
        mov     edx, EiihLock - 4       ; (edx)->KSPIN_LOCK
endif
Eiih10: pushfd
        cli
        ACQUIRE_SPINLOCK    edx,<short Eiih20>

        mov     eax, EiihListHead       ; (eax)->head of linked list
        mov     ecx, EiihListEntry      ; (ecx)->entry to be inserted
        mov     edx, LsFlink[eax]       ; (edx)->next entry in the list
        mov     [ecx]+LsFlink, edx      ; store next link in entry
        mov     [ecx]+LsBlink, eax      ; store previous link in entry
        mov     [eax]+LsFlink, ecx      ; store next link in head
        mov     [edx]+LsBlink, ecx      ; store previous link in next

ifndef NT_UP
        mov     ecx, EiihLock           ; (ecx)->KSPIN_LOCK
        RELEASE_SPINLOCK ecx
endif
cPublicFpo 3, 0
        popfd                           ; restore flags including interrupts

        xor     eax,edx                 ; return null if list was empty
        jz      short Eiih15
        mov     eax,edx                 ; otherwise return prev. entry at head
Eiih15:
        stdRET    _ExInterlockedInsertHeadList

ifndef NT_UP
align 4
Eiih20: popfd
        SPIN_ON_SPINLOCK edx, <short Eiih10>
endif

stdENDP _ExInterlockedInsertHeadList


        page , 132
        subttl  "Interlocked Insert Tail List"
;++
;
; PLIST_ENTRY
; ExInterlockedInsertTailList (
;    __inout PLIST_ENTRY ListHead,
;    __inout PLIST_ENTRY ListEntry,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the tail of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       tail of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Pointer to entry that was at the tail of the list or NULL if the list
;    was empty.
;
;--

EiitListHead    equ     [esp + 8]
EiitListEntry   equ     [esp + 12]
EiitLock        equ     [esp + 16]

; end arguments

cPublicProc _ExInterlockedInsertTailList    , 3
cPublicFpo 3, 1


ifndef NT_UP
        mov     edx,EiitLock - 4        ; (edx)->KSPIN_LOCK
endif

Eiit10: pushfd
        cli                             ; disable interrupts
        ACQUIRE_SPINLOCK edx, <short Eiit20>

        mov     eax, EiihListHead       ; (eax)->head of linked list
        mov     ecx, EiihListEntry      ; (ecx)->entry to be inserted
        mov     edx, LsBlink[eax]       ; (edx)->previous entry in the list
        mov     [ecx]+LsFlink, eax      ; store next link in entry
        mov     [ecx]+LsBlink, edx      ; store previous link in entry
        mov     [eax]+LsBlink, ecx      ; store previous link in head
        mov     [edx]+LsFlink, ecx      ; store next link in next

ifndef NT_UP
        mov     ecx,EiitLock            ; (ecx)->KSPIN_LOCK
        RELEASE_SPINLOCK ecx
endif
cPublicFpo 3,0
        popfd                           ; restore flags including interrupts

        xor     eax,edx                 ; return null if list was empty
        jz      short Eiit15
        mov     eax,edx                 ; otherwise return prev. entry at tail
Eiit15:
        stdRET    _ExInterlockedInsertTailList

ifndef NT_UP
align 4
Eiit20: popfd
        SPIN_ON_SPINLOCK edx, <short Eiit10>
endif

stdENDP _ExInterlockedInsertTailList

        page , 132
        subttl  "Interlocked Remove Head List"
;++
;
; PLIST_ENTRY
; ExInterlockedRemoveHeadList (
;    __inout PLIST_ENTRY ListHead,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the head of a doubly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
;    N.B. The pages of data which this routine operates on MUST be
;         present.  No page fault is allowed in this routine.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the doubly linked
;       list from which an entry is to be removed.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

EirhListHead    equ     [esp + 8]
EirhLock        equ     [esp + 12]

; end of arguments

cPublicProc _ExInterlockedRemoveHeadList    , 2
cPublicFpo 2, 1

ifndef NT_UP
        mov     edx, EirhLock - 4       ; (edx)-> KSPIN_LOCK
endif

Eirh10: pushfd
        cli

        ACQUIRE_SPINLOCK edx, <Eirh30>

        mov     edx, EirhListHead       ; (edx)-> head of list
        mov     eax, [edx]+LsFlink      ; (eax)-> next entry
        cmp     eax, edx                ; Is list empty?
        je      short Eirh20            ; if e, list is empty, go Eirh20
        mov     ecx, [eax]+LsFlink      ; (ecx)-> next entry(after deletion)
        mov     [edx]+LsFlink, ecx      ; store address of next in head
        mov     [ecx]+LsBlink, edx      ; store address of previous in next
if DBG
        mov     [eax]+LsFlink, 0baddd0ffh
        mov     [eax]+LsBlink, 0baddd0ffh
endif
ifndef NT_UP
        mov     edx, EirhLock           ; (edx)-> KSPIN_LOCK
        RELEASE_SPINLOCK  edx
endif
cPublicFpo 2, 0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedRemoveHeadList                             ; cReturn entry

align 4
Eirh20:
ifndef NT_UP
        mov     edx, EirhLock           ; (edx)-> KSPIN_LOCK
        RELEASE_SPINLOCK edx
endif
        popfd
        xor     eax,eax                 ; (eax) = null for empty list
        stdRET    _ExInterlockedRemoveHeadList                             ; cReturn NULL

ifndef NT_UP
align 4
Eirh30: popfd
        SPIN_ON_SPINLOCK edx, Eirh10
endif

stdENDP _ExInterlockedRemoveHeadList

        page , 132
        subttl  "Interlocked Pop Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPopEntryList (
;    __inout PSINGLE_LIST_ENTRY ListHead,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the singly linked
;       list from which an entry is to be removed.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

; end of arguments

cPublicProc _ExInterlockedPopEntryList      , 2
cPublicFpo 2,1

ifndef NT_UP
        mov     edx, [esp+8]            ; (edx)-> KSPIN_LOCK
endif

Eipe10: pushfd
        cli                             ; disable interrupts

        ACQUIRE_SPINLOCK edx, <short Eipe30>

        mov     ecx, [esp+8]            ; (ecx)-> head of list
        mov     eax, [ecx]              ; (eax)-> next entry
        or      eax, eax                ; Is it empty?
        je      short Eipe20            ; if e, empty list, go Eipe20
        mov     edx, [eax]              ; (edx)->next entry (after deletion)
        mov     [ecx], edx              ; store address of next in head
if DBG
        mov     [eax], 0baddd0ffh
endif

ifndef NT_UP
        mov     edx, [esp+12]           ; (edx)-> KSPIN_LOCK
endif

Eipe15: RELEASE_SPINLOCK edx

cPublicFpo 2,0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedPopEntryList    ; cReturn (eax)->removed entry

Eipe20: xor     eax, eax                ; return NULL for empty list
        jmp     short Eipe15            ; continue in common exit

ifndef NT_UP
Eipe30: popfd
        SPIN_ON_SPINLOCK edx, Eipe10
endif

stdENDP _ExInterlockedPopEntryList

        page , 132
        subttl  "Interlocked Push Entry List"
;++
;
; PSINGLE_LIST_ENTRY
; ExInterlockedPushEntryList (
;    __inout PSINGLE_LIST_ENTRY ListHead,
;    __inout PSINGLE_LIST_ENTRY ListEntry,
;    __inout PKSPIN_LOCK Lock
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a singly linked list
;    so that access to the list is synchronized in a multiprocessor system.
;
; Arguments:
;
;    ListHead - Supplies a pointer to the head of the singly linked
;       list into which an entry is to be inserted.
;
;    ListEntry - Supplies a pointer to the entry to be inserted at the
;       head of the list.
;
;    Lock - Supplies a pointer to a spin lock to be used to synchronize
;       access to the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

; end of arguments

cPublicProc _ExInterlockedPushEntryList     , 3
cPublicFpo 3,1

ifndef NT_UP
        mov     edx, [esp+12]           ; (edx)->KSPIN_LOCK
endif

Eipl10: pushfd
        cli

        ACQUIRE_SPINLOCK edx, <short Eipl20>

        mov     edx, [esp+8]            ; (edx)-> Head of list
        mov     eax, [edx]              ; (eax)-> next entry (return value also)
        mov     ecx, [esp+12]           ; (ecx)-> Entry to be pushed
        mov     [ecx], eax              ; store address of next in new entry
        mov     [edx], ecx              ; set address of next in head

ifndef NT_UP
        mov     edx, [esp+16]           ; (edx)->KSPIN_LOCK
        RELEASE_SPINLOCK edx
endif
cPublicFpo 3,0
        popfd                           ; restore flags including interrupts
        stdRET    _ExInterlockedPushEntryList

ifndef NT_UP
align 4
Eipl20: popfd
        SPIN_ON_SPINLOCK edx, <short Eipl10>
endif

stdENDP _ExInterlockedPushEntryList

        page , 132
        subttl  "Interlocked Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedIncrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to increment.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicProc _ExInterlockedIncrementLong , 2
cPublicFpo 2, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        add dword ptr [eax],1
else
        lock add dword ptr [eax],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        stdRET    _ExInterlockedIncrementLong

stdENDP _ExInterlockedIncrementLong


        page , 132
        subttl  "Interlocked Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicProc _ExInterlockedDecrementLong , 2
cPublicFpo 2, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        sub dword ptr [eax], 1
else
        lock sub dword ptr [eax], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        stdRET    _ExInterlockedDecrementLong

stdENDP _ExInterlockedDecrementLong

        page , 132
        subttl  "Interlocked Exchange Ulong"
;++
;
;   ULONG
;   ExInterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       This function does not necessarily synchronize with the Lock.
;
;   Arguments:
;
;       Target - Address of ULONG to exchange
;       Value  - New value of ULONG
;       Lock   - SpinLock used to implement atomicity.
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicProc _ExInterlockedExchangeUlong, 3
cPublicFpo 3,0

ifndef NT_UP
        mov     edx, [esp+4]                ; (edx) = Target
        mov     eax, [esp+8]                ; (eax) = Value

        xchg    [edx], eax                  ; make the exchange
else
        mov     edx, [esp+4]                ; (edx) = Target
        mov     ecx, [esp+8]                ; (eax) = Value

        pushfd
        cli
        mov     eax, [edx]                  ; get current value
        mov     [edx], ecx                  ; store new value
        popfd
endif

        stdRET  _ExInterlockedExchangeUlong

stdENDP _ExInterlockedExchangeUlong

        page , 132
        subttl  "Interlocked i386 Increment Long"
;++
;
;   INTERLOCKED_RESULT
;   Exi386InterlockedIncrementLong (
;       IN PLONG Addend
;       )
;
;   Routine Description:
;
;       This function atomically increments Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See ExInterlockedIncrementLong.  This function is the i386
;       architectural specific version of ExInterlockedIncrementLong.
;       No source directly calls this function, instead
;       ExInterlockedIncrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to increment.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after increment.
;       ResultZero     if Addend is = 0 after increment.
;       ResultPositive if Addend is > 0 after increment.
;
;--

cPublicProc _Exi386InterlockedIncrementLong , 1
cPublicFpo 1, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        add dword ptr [eax],1
else
        lock add dword ptr [eax],1
endif
        lahf                            ; (ah) = flags
        and     eax,EFLAG_SELECT        ; clear all but sign and zero flags
        stdRET    _Exi386InterlockedIncrementLong

stdENDP _Exi386InterlockedIncrementLong


        page , 132
        subttl  "Interlocked i386 Decrement Long"
;++
;
;   INTERLOCKED_RESULT
;   ExInterlockedDecrementLong (
;       IN PLONG Addend,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically decrements Addend, returning an ennumerated
;       type which indicates what interesting transitions in the value of
;       Addend occurred due the operation.
;
;       See Exi386InterlockedDecrementLong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       Addend (esp+4) - Pointer to variable to decrement.
;
;       Lock (esp+8) - Spinlock used to implement atomicity.
;                      (not actually used on x86)
;
;   Return Value:
;
;       An ennumerated type:
;
;       ResultNegative if Addend is < 0 after decrement.
;       ResultZero     if Addend is = 0 after decrement.
;       ResultPositive if Addend is > 0 after decrement.
;
;--

cPublicProc _Exi386InterlockedDecrementLong , 1
cPublicFpo 1, 0

        mov     eax, [esp+4]            ; (eax) -> addend
ifdef NT_UP
        sub dword ptr [eax], 1
else
        lock sub dword ptr [eax], 1
endif
        lahf                            ; (ah) = flags
        and     eax, EFLAG_SELECT       ; clear all but sign and zero flags
        stdRET    _Exi386InterlockedDecrementLong

stdENDP _Exi386InterlockedDecrementLong

        page , 132
        subttl  "Interlocked i386 Exchange Ulong"

;++
;
;   ULONG
;   Exi386InterlockedExchangeUlong (
;       IN PULONG Target,
;       IN ULONG Value,
;       IN PKSPIN_LOCK Lock
;       )
;
;   Routine Description:
;
;       This function atomically exchanges the Target and Value, returning
;       the prior contents of Target
;
;       See Exi386InterlockedExchangeUlong.  This function is the i386
;       architectural specific version of ExInterlockedDecrementLong.
;       No source directly calls this function, instead
;       ExInterlockedDecrementLong is called and when built on x86 these
;       calls are macro-ed to the i386 optimized version.
;
;   Arguments:
;
;       Source - Address of ULONG to exchange
;       Value  - New value of ULONG
;       Lock   - SpinLock used to implement atomicity.
;
;   Return Value:
;
;       The prior value of Source
;--

cPublicProc _Exi386InterlockedExchangeUlong, 2
cPublicFpo 2,0

ifndef NT_UP
        mov     edx, [esp+4]                ; (edx) = Target
        mov     eax, [esp+8]                ; (eax) = Value

        xchg    [edx], eax                  ; make the exchange
else
        mov     edx, [esp+4]                ; (edx) = Target
        mov     ecx, [esp+8]                ; (eax) = Value

        pushfd
        cli
        mov     eax, [edx]                  ; get current value
        mov     [edx], ecx                  ; store new value
        popfd
endif

        stdRET  _Exi386InterlockedExchangeUlong

stdENDP _Exi386InterlockedExchangeUlong

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\fastio.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FastIo.c

Abstract:

    The Fast I/O path is used to avoid calling the file systems directly to
    do a cached read.  This module is only used if the file object indicates
    that caching is enabled (i.e., the private cache map is not null).

--*/

#include "FsRtlP.h"

#if DBG

typedef struct _FS_RTL_DEBUG_COUNTERS {

    ULONG AcquireFileExclusiveEx_Succeed;
    ULONG AcquireFileExclusiveEx_Fail;
    ULONG ReleaseFile;

    ULONG AcquireFileForModWriteEx_Succeed;
    ULONG AcquireFileForModWriteEx_Fail;
    ULONG ReleaseFileForModWrite;

    ULONG AcquireFileForCcFlushEx_Succeed;
    ULONG AcquireFileForCcFlushEx_Fail;
    ULONG ReleaseFileForCcFlush;

} FS_RTL_DEBUG_COUNTERS, *PFS_RTL_DEBUG_COUNTERS;

FS_RTL_DEBUG_COUNTERS gCounter = { 0, 0, 0,
                                   0, 0, 0,
                                   0, 0, 0 };

#endif

//
//  Trace level for the module
//

#define Dbg                              (0x04000000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlCopyRead)
#pragma alloc_text(PAGE, FsRtlCopyWrite)
#pragma alloc_text(PAGE, FsRtlMdlRead)
#pragma alloc_text(PAGE, FsRtlMdlReadDev)
#pragma alloc_text(PAGE, FsRtlPrepareMdlWrite)
#pragma alloc_text(PAGE, FsRtlPrepareMdlWriteDev)
#pragma alloc_text(PAGE, FsRtlMdlWriteComplete)
#pragma alloc_text(PAGE, FsRtlMdlWriteCompleteDev)
#pragma alloc_text(PAGE, FsRtlAcquireFileForCcFlush)
#pragma alloc_text(PAGE, FsRtlAcquireFileForCcFlushEx)
#pragma alloc_text(PAGE, FsRtlReleaseFileForCcFlush)
#pragma alloc_text(PAGE, FsRtlAcquireFileExclusive)
#pragma alloc_text(PAGE, FsRtlAcquireToCreateMappedSection)
#pragma alloc_text(PAGE, FsRtlAcquireFileExclusiveCommon)
#pragma alloc_text(PAGE, FsRtlReleaseFile)
#pragma alloc_text(PAGE, FsRtlGetFileSize)
#pragma alloc_text(PAGE, FsRtlSetFileSize)
#pragma alloc_text(PAGE, FsRtlIncrementCcFastReadNotPossible )
#pragma alloc_text(PAGE, FsRtlIncrementCcFastReadWait )

#endif


BOOLEAN
FsRtlCopyRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES( FileOffset->QuadPart, Length );
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Check for overflow. Returning false here will re-route this request through the
        //  IRP based path, but this isn't performance critical.
        //

        if (MAXLONGLONG - FileOffset->QuadPart < (LONGLONG)Length) {

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            IoStatus->Information = 0;

            return FALSE;
        }

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Increment performance counters and get the resource
        //

        if (Wait) {

            HOT_STATISTIC(CcFastReadWait) += 1;

            //
            //  Acquired shared on the common fcb header
            //

            (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

        } else {

            HOT_STATISTIC(CcFastReadNoWait) += 1;

            //
            //  Acquired shared on the common fcb header, and return if we
            //  don't get it
            //

            if (!ExAcquireResourceSharedLite( Header->Resource, FALSE )) {

                FsRtlExitFileSystem();

                CcFastReadResourceMiss += 1;

                return FALSE;
            }
        }

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            HOT_STATISTIC(CcFastReadNotPossible) += 1;

            return FALSE;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            ASSERT(!KeIsExecutingDpc());

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                HOT_STATISTIC(CcFastReadNotPossible) += 1;

                return FALSE;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                return TRUE;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

        try {

            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                CcFastCopyRead( FileObject,
                                FileOffset->LowPart,
                                Length,
                                PageCount,
                                Buffer,
                                IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

            } else {

                Status = CcCopyRead( FileObject,
                                     FileOffset,
                                     Length,
                                     Wait,
                                     Buffer,
                                     IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( !Status || (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((LONGLONG)(FileOffset->QuadPart + IoStatus->Information) <= Header->FileSize.QuadPart));
            }

            if (Status) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            Status = FALSE;
        }

        PsGetCurrentThread()->TopLevelIrp = 0;

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();
        return Status;

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }
}


BOOLEAN
FsRtlCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __in_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN Status = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes made to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                ULONG Offset, NewFileSize;
                ULONG OldFileSize = 0;
                ULONG OldValidDataLength = 0;
                LOGICAL Wrapped;

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.  Note that we do not check FileOffset->HighPart
                //  until below.
                //

                NewFileSize = FileOffset->LowPart + Length;

                if (WriteToEndOfFile || (NewFileSize > Header->ValidDataLength.LowPart)) {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                } else {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceSharedLite( Header->Resource, TRUE );

                    AcquiredShared = TRUE;
                }

                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize.LowPart;
                    NewFileSize = Header->FileSize.LowPart + Length;
                    Wrapped = NewFileSize < Header->FileSize.LowPart;

                } else {

                    Offset = FileOffset->LowPart;
                    NewFileSize = FileOffset->LowPart + Length;
                    Wrapped = (NewFileSize < FileOffset->LowPart) || (FileOffset->HighPart != 0);
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have too much to zero.  This case is not important
                //  for performance, and a file system supporting sparseness may have
                //  a way to do this more efficiently.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                    (NewFileSize > Header->AllocationSize.LowPart) ||
                    (Offset >= (Header->ValidDataLength.LowPart + 0x2000)) ||
                    (Header->AllocationSize.HighPart != 0) || Wrapped) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && (NewFileSize > Header->ValidDataLength.LowPart)) {

                    ExReleaseResourceLite( Header->Resource );

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize.LowPart;
                        NewFileSize = Header->FileSize.LowPart + Length;
                        Wrapped = NewFileSize < Header->FileSize.LowPart;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        (NewFileSize > Header->AllocationSize.LowPart) ||
                        (Header->AllocationSize.HighPart != 0) || Wrapped) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if (NewFileSize > Header->FileSize.LowPart) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize.LowPart;
                    OldValidDataLength = Header->ValidDataLength.LowPart;
                    Header->FileSize.LowPart = NewFileSize;
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if (Offset > Header->ValidDataLength.LowPart) {

                        LARGE_INTEGER ZeroEnd;

                        ZeroEnd.LowPart = Offset;
                        ZeroEnd.HighPart = 0;

                        CcZeroData( FileObject,
                                    &Header->ValidDataLength,
                                    &ZeroEnd,
                                    TRUE );
                    }

                    CcFastCopyWrite( FileObject,
                                     Offset,
                                     Length,
                                     Buffer );

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if (NewFileSize > Header->ValidDataLength.LowPart) {

                        Header->ValidDataLength.LowPart = NewFileSize;
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        CcGetFileSizePointer(FileObject)->LowPart = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the file position pointer
                    //

                    FileObject->CurrentByteOffset.LowPart = Offset + Length;
                    FileObject->CurrentByteOffset.HighPart = 0;

                //
                //  If we did not succeed, then we must restore the original
                //  FileSize while holding the PagingIoResource exclusive if
                //  it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                    }
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                LARGE_INTEGER Offset, NewFileSize;
                LARGE_INTEGER OldFileSize = {0};
                LARGE_INTEGER OldValidDataLength = {0};

                ASSERT(!KeIsExecutingDpc());

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.
                //

                NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

                if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                } else {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceSharedLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    AcquiredShared = TRUE;
                }


                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize;
                    NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

                } else {

                    Offset = *FileOffset;
                    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we are about to zero too much as well, as commented above.
                //  Likewise, for NewFileSizes that exceed MAXLONGLONG.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                      (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000)) ||
                      (MAXLONGLONG - Offset.QuadPart < (LONGLONG)Length) ||
                      (NewFileSize.QuadPart > Header->AllocationSize.QuadPart) ) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

                    ExReleaseResourceLite( Header->Resource );

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize;
                        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize;
                    OldValidDataLength = Header->ValidDataLength;

                    //
                    //  Deal with an extremely rare pathological case here the
                    //  file size wraps.
                    //

                    if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
                         (Header->PagingIoResource != NULL) ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = NewFileSize;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = NewFileSize;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

                        Status = CcZeroData( FileObject,
                                             &Header->ValidDataLength,
                                             &Offset,
                                             Wait );
                    }

                    if (Status) {

                        Status = CcCopyWrite( FileObject,
                                              &Offset,
                                              Length,
                                              Wait,
                                              Buffer );
                    }

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

                        //
                        //  Deal with an extremely rare pathological case here
                        //  the ValidDataLength wraps.
                        //

                        if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                             (Header->PagingIoResource != NULL) ) {

                            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                            Header->ValidDataLength = NewFileSize;
                            ExReleaseResourceLite( Header->PagingIoResource );

                        } else {

                            Header->ValidDataLength = NewFileSize;
                        }
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        *CcGetFileSizePointer(FileObject) = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the current file position pointer
                    //

                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                //
                // If we did not succeed, then we must restore the original
                // FileSize while holding the PagingIoResource exclusive if
                // it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                    }
                }

            }

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return Status;

        } else {

            //
            //  A zero length transfer was requested.
            //

            return TRUE;
        }

    } else {

        //
        // The volume must be verified or the file is write through.
        //

        return FALSE;
    }
}


BOOLEAN
FsRtlMdlReadDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    DeviceObject - Supplies DeviceObject for callee.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    LARGE_INTEGER BeyondLastByte;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    //  Special case a read of zero length
    //

    if (Length == 0) {

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }

    //
    //  Overflows should've been handled by caller.
    //

    ASSERT(MAXLONGLONG - FileOffset->QuadPart >= (LONGLONG)Length);


    //
    //  Get a real pointer to the common fcb header
    //

    BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Enter the file system
    //

    FsRtlEnterFileSystem();

    CcFastMdlReadWait += 1;

    //
    //  Acquired shared on the common fcb header
    //

    (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

    //
    //  Now that the File is acquired shared, we can safely test if it is
    //  really cached and if we can do fast i/o and if not
    //  then release the fcb and return.
    //

    if ((FileObject->PrivateCacheMap == NULL) ||
        (Header->IsFastIoPossible == FastIoIsNotPossible)) {

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();

        CcFastMdlReadNotPossible += 1;

        return FALSE;
    }

    //
    //  Check if fast I/O is questionable and if so then go ask the file system
    //  the answer
    //

    if (Header->IsFastIoPossible == FastIoIsQuestionable) {

        PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
        PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;

        ASSERT(!KeIsExecutingDpc());

        //
        //  All file system then set "Is Questionable" had better support fast I/O
        //

        ASSERT(FastIoDispatch != NULL);
        ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

        //
        //  Call the file system to check for fast I/O.  If the answer is anything
        //  other than GoForIt then we cannot take the fast I/O path.
        //

        if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                    FileOffset,
                                                    Length,
                                                    TRUE,
                                                    LockKey,
                                                    TRUE, // read operation
                                                    IoStatus,
                                                    targetVdo )) {

            //
            //  Fast I/O is not possible so release the Fcb and return.
            //

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            CcFastMdlReadNotPossible += 1;

            return FALSE;
        }
    }

    //
    //  Check for read past file size.
    //

    if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

        if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
            IoStatus->Status = STATUS_END_OF_FILE;
            IoStatus->Information = 0;

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return TRUE;
        }

        Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
    }

    //
    //  We can do fast i/o so call the cc routine to do the work and then
    //  release the fcb when we've done.  If for whatever reason the
    //  mdl read fails, then return FALSE to our caller.
    //
    //
    //  Also mark this as the top level "Irp" so that lower file system levels
    //  will not attempt a pop-up
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

    try {

        CcMdlRead( FileObject, FileOffset, Length, MdlChain, IoStatus );

        FileObject->Flags |= FO_FILE_FAST_IO_READ;

    } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                   ? EXCEPTION_EXECUTE_HANDLER
                                   : EXCEPTION_CONTINUE_SEARCH ) {

        Status = FALSE;
    }

    PsGetCurrentThread()->TopLevelIrp = 0;

    ExReleaseResourceLite( Header->Resource );
    FsRtlExitFileSystem();

    return Status;
}


//
//  The old routine will either dispatch or call FsRtlMdlReadDev
//

BOOLEAN
FsRtlMdlRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not delivered, or if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlRead)) &&
        (FastIoDispatch->MdlRead != NULL)) {

        return FastIoDispatch->MdlRead( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlRead)) &&
            (FastIoDispatch->MdlRead != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlReadDev( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );
        }
    }
}


//
//  The old routine will either dispatch or call FsRtlMdlReadCompleteDev
//

BOOLEAN
FsRtlMdlReadComplete (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlRead.

Return Value:

    None

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete)) &&
        (FastIoDispatch->MdlReadComplete != NULL)) {

        return FastIoDispatch->MdlReadComplete( FileObject, MdlChain, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlReadComplete)) &&
            (FastIoDispatch->MdlReadComplete != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlReadCompleteDev( FileObject, MdlChain, DeviceObject );
        }
    }
}


BOOLEAN
FsRtlMdlReadCompleteDev (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlRead.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:

    None

--*/


{
    UNREFERENCED_PARAMETER (DeviceObject);

    CcMdlReadComplete2( FileObject, MdlChain );
    return TRUE;
}


BOOLEAN
FsRtlPrepareMdlWriteDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    LARGE_INTEGER Offset, NewFileSize;
    LARGE_INTEGER OldFileSize = {0};
    LARGE_INTEGER OldValidDataLength = {0};
    BOOLEAN Status = TRUE;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();

    UNREFERENCED_PARAMETER (DeviceObject);

    //
    //  Call CcCanIWrite.  Also return FALSE if FileObject is write through,
    //  the File System must do that.
    //

    if ( !CcCanIWrite( FileObject, Length, TRUE, FALSE ) ||
         FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {

        return FALSE;
    }

    //
    //  Assume our transfer will work
    //

    IoStatus->Status = STATUS_SUCCESS;

    //
    //  Special case the zero byte length
    //

    if (Length == 0) {

        return TRUE;
    }

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Enter the file system
    //

    FsRtlEnterFileSystem();

    //
    //  Make our best guess on whether we need the file exclusive or
    //  shared.
    //

    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

    if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

        //
        //  Acquired exclusive on the common fcb header, and return if we don't
        //  get it.
        //

        ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

    } else {

        //
        //  Acquired shared on the common fcb header, and return if we don't
        //  get it.
        //

        ExAcquireResourceSharedLite( Header->Resource, TRUE );

        AcquiredShared = TRUE;
    }


    //
    //  We have the fcb shared now check if we can do fast i/o  and if the file
    //  space is allocated, and if not then release the fcb and return.
    //

    if (WriteToEndOfFile) {

        Offset = Header->FileSize;
        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

    } else {

        Offset = *FileOffset;
        NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
    }

    //
    //  Now that the File is acquired shared, we can safely test if it is
    //  really cached and if we can do fast i/o and we do not have to extend.
    //  If not then release the fcb and return.
    //

    if ((FileObject->PrivateCacheMap == NULL) ||
        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
        (MAXLONGLONG - Offset.QuadPart < (LONGLONG)Length) ||
        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();

        return FALSE;
    }

    //
    //  If we will be extending ValidDataLength, we will have to get the
    //  Fcb exclusive, and make sure that FastIo is still possible.
    //

    if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

        ExReleaseResourceLite( Header->Resource );

        ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

        AcquiredShared = FALSE;

        //
        //  If writing to end of file, we must recalculate new size.
        //

        if (WriteToEndOfFile) {

            Offset = Header->FileSize;
            NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
        }

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible) ||
            ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart )) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return FALSE;
        }
    }

    //
    //  Check if fast I/O is questionable and if so then go ask the file system
    //  the answer
    //

    if (Header->IsFastIoPossible == FastIoIsQuestionable) {

        PFAST_IO_DISPATCH FastIoDispatch = IoGetRelatedDeviceObject( FileObject )->DriverObject->FastIoDispatch;

        //
        //  All file system then set "Is Questionable" had better support fast I/O
        //

        ASSERT(FastIoDispatch != NULL);
        ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

        //
        //  Call the file system to check for fast I/O.  If the answer is anything
        //  other than GoForIt then we cannot take the fast I/O path.
        //

        if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                    FileOffset,
                                                    Length,
                                                    TRUE,
                                                    LockKey,
                                                    FALSE, // write operation
                                                    IoStatus,
                                                    IoGetRelatedDeviceObject( FileObject ) )) {

            //
            //  Fast I/O is not possible so release the Fcb and return.
            //

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return FALSE;
        }
    }

    //
    // Now see if we will change FileSize.  We have to do it now so that our
    // reads are not nooped.
    //

    if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

        FileSizeChanged = TRUE;
        OldFileSize = Header->FileSize;
        OldValidDataLength = Header->ValidDataLength;

        //
        //  Deal with an extremely rare pathological case here the file
        //  size wraps.
        //

        if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
             (Header->PagingIoResource != NULL) ) {

            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
            Header->FileSize = NewFileSize;
            ExReleaseResourceLite( Header->PagingIoResource );

        } else {

            Header->FileSize = NewFileSize;
        }
    }

    //
    //  We can do fast i/o so call the cc routine to do the work and then
    //  release the fcb when we've done.  If for whatever reason the
    //  copy write fails, then return FALSE to our caller.
    //
    //
    //  Also mark this as the top level "Irp" so that lower file system levels
    //  will not attempt a pop-up
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;

    try {

        //
        //  See if we have to do some zeroing
        //

        if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

            Status = CcZeroData( FileObject,
                                 &Header->ValidDataLength,
                                 &Offset,
                                 TRUE );
        }

        if (Status) {

            CcPrepareMdlWrite( FileObject, &Offset, Length, MdlChain, IoStatus );
        }

    } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        Status = FALSE;
    }

    PsGetCurrentThread()->TopLevelIrp = 0;

    //
    //  If we succeeded, see if we have to update FileSize or ValidDataLength.
    //

    if (Status) {

        //
        // In the case of ValidDataLength, we really have to check again
        // since we did not do this when we acquired the resource exclusive.
        //

        if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

            //
            //  Deal with an extremely rare pathological case here the
            //  ValidDataLength wraps.
            //

            if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                 (Header->PagingIoResource != NULL) ) {

                (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                Header->ValidDataLength = NewFileSize;
                ExReleaseResourceLite( Header->PagingIoResource );

            } else {

                Header->ValidDataLength = NewFileSize;
            }
        }

        //
        //  Set this handle as having modified the file
        //

        FileObject->Flags |= FO_FILE_MODIFIED;

        if (FileSizeChanged) {

            *CcGetFileSizePointer(FileObject) = NewFileSize;

            FileObject->Flags |= FO_FILE_SIZE_CHANGED;
        }

    //
    //  If we did not succeed, then we must restore the original FileSize
    //  and release the resource.  In the success path, the cache manager
    //  will release the resource.
    //

    } else {

        if (FileSizeChanged) {

            if ( Header->PagingIoResource != NULL ) {

                (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                Header->FileSize = OldFileSize;
                Header->ValidDataLength = OldValidDataLength;
                ExReleaseResourceLite( Header->PagingIoResource );

            } else {

                Header->FileSize = OldFileSize;
                Header->ValidDataLength = OldValidDataLength;
            }
        }
    }

    //
    //  Now we can release the resource.
    //

    ExReleaseResourceLite( Header->Resource );

    FsRtlExitFileSystem();

    return Status;
}


//
//  The old routine will either dispatch or call FsRtlPrepareMdlWriteDev
//

BOOLEAN
FsRtlPrepareMdlWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG LockKey,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, PrepareMdlWrite)) &&
        (FastIoDispatch->PrepareMdlWrite != NULL)) {

        return FastIoDispatch->PrepareMdlWrite( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, PrepareMdlWrite)) &&
            (FastIoDispatch->PrepareMdlWrite != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlPrepareMdlWriteDev( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );
        }
    }
}


//
//  The old routine will either dispatch or call FsRtlMdlWriteCompleteDev
//

BOOLEAN
FsRtlMdlWriteComplete (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain
    )

/*++

Routine Description:

    This routine completes an Mdl write.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlPrepareMdlWrite.

Return Value:



--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
        (FastIoDispatch->MdlWriteComplete != NULL)) {

        return FastIoDispatch->MdlWriteComplete( FileObject, FileOffset, MdlChain, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
            (FastIoDispatch->MdlWriteComplete != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlWriteCompleteDev( FileObject, FileOffset, MdlChain, DeviceObject );
        }
    }
}


BOOLEAN
FsRtlMdlWriteCompleteDev (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain,
    __in PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine completes an Mdl write.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlPrepareMdlWrite.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:



--*/


{
    UNREFERENCED_PARAMETER (DeviceObject);

    //
    //  Do not support WRITE_THROUGH in the fast path call.
    //

    if (FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {
        return FALSE;
    }

    CcMdlWriteComplete2( FileObject, FileOffset, MdlChain );
    return TRUE;
}


NTKERNELAPI
NTSTATUS
FsRtlRegisterFileSystemFilterCallbacks (
    __in PDRIVER_OBJECT FilterDriverObject,
    __in PFS_FILTER_CALLBACKS Callbacks
    )

/*++

Routine Description:

    This routine registers the FilterDriverObject to receive the
    notifications specified in Callbacks at the appropriate times
    for the devices to which this driver is attached.

    This should only be called by a file system filter during
    its DriverEntry routine.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    STATUS_SUCCESS - The callbacks were successfully registered
        for this driver.

    STATUS_INSUFFICIENT_RESOURCES - There wasn't enough memory to
        store these callbacks for the driver.

    STATUS_INVALID_PARAMETER - Returned in any of the parameters
        are invalid.

--*/

{
    PDRIVER_EXTENSION DriverExt;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;

    PAGED_CODE();

    if (!(ARGUMENT_PRESENT( FilterDriverObject ) &&
          ARGUMENT_PRESENT( Callbacks ))) {

        return STATUS_INVALID_PARAMETER;
    }

    DriverExt = FilterDriverObject->DriverExtension;

    FsFilterCallbacks = ExAllocatePoolWithTag( NonPagedPool,
                                               Callbacks->SizeOfFsFilterCallbacks,
                                               FSRTL_FILTER_MEMORY_TAG );

    if (FsFilterCallbacks == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( FsFilterCallbacks,
                   Callbacks,
                   Callbacks->SizeOfFsFilterCallbacks );

    DriverExt->FsFilterCallbacks = FsFilterCallbacks;

    return STATUS_SUCCESS;
}


NTKERNELAPI
BOOLEAN
FsRtlAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    )

/*++

Routine Description:

    This routine decides which file system resource the modified page
    writer should acquire and acquires it if possible.  Wait is always
    specified as FALSE.  We pass back the resource Mm has to release
    when the write completes.

    This routine is obsolete --- should call FsRtlAcquireFileForModWriteEx
    instead.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    FALSE - The resource could not be acquired without waiting.

    TRUE - The returned resource has been acquired.

--*/

{
    NTSTATUS Status;

    //
    //  Just call the new version of this routine and process
    //  the NTSTATUS returned into TRUE for success and FALSE
    //  for failure.
    //

    Status = FsRtlAcquireFileForModWriteEx( FileObject,
                                            EndingOffset,
                                            ResourceToRelease );

    if (!NT_SUCCESS( Status )) {

        return FALSE;

    }

    return TRUE;
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForModWriteEx (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    )
/*++

Routine Description:

    This routine decides which file system resource the modified page
    writer should acquire and acquires it if possible.  Wait is always
    specified as FALSE.  We pass back the resource Mm has to release
    when the write completes.

    The operation is presented to any file system filters attached to this
    volume before and after the file system is asked to acquire this resource.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    FALSE - The resource could not be acquired without waiting.

    TRUE - The returned resource has been acquired.

--*/
{

    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CALLBACK_DATA CallbackData;
    PFSRTL_COMMON_FCB_HEADER Header;
    PERESOURCE ResourceAcquired;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN AcquireExclusive;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForModWrite ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_MOD_WRITE,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   TRUE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        // Initialize the operation-specific parameters in the callback data.
        //

        CallbackData = &(FsFilterCtrl.Data);
        CallbackData->Parameters.AcquireForModifiedPageWriter.EndingOffset = EndingOffset;
        CallbackData->Parameters.AcquireForModifiedPageWriter.ResourceToRelease = ResourceToRelease;

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           TRUE,
                                           TRUE,
                                           &BaseFsFailedOperation );
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseFsDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForModWrite )) {

                Status = FastIoDispatch->AcquireForModWrite( FileObject,
                                                             EndingOffset,
                                                             ResourceToRelease,
                                                             BaseFsDeviceObject );
            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_CANT_WAIT) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    //
    //  If the base file system didn't have an AcquireForModWrite handler
    //  or couldn't return STATUS_SUCCESS or STATUS_CANT_WAIT,
    //  we need to perform the default actions here.
    //

    if ((Status != STATUS_SUCCESS) &&
        (Status != STATUS_CANT_WAIT) &&
        BaseFsFailedOperation) {

        //
        //  We follow the following rules to determine which resource
        //  to acquire.  We use the flags in the common header.  These
        //  flags can't change once we have acquired any resource.
        //  This means we can do an unsafe test and optimistically
        //  acquire a resource.  At that point we can test the bits
        //  to see if we have what we want.
        //
        //  0 - If there is no main resource, acquire nothing.
        //
        //  1 - Acquire the main resource exclusively if the
        //      ACQUIRE_MAIN_RSRC_EX flag is set or we are extending
        //      valid data.
        //
        //  2 - Acquire the main resource shared if there is
        //      no paging io resource or the
        //      ACQUIRE_MAIN_RSRC_SH flag is set.
        //
        //  3 - Otherwise acquire the paging io resource shared.
        //

        Header = (PFSRTL_COMMON_FCB_HEADER) FileObject->FsContext;

        if (Header->Resource == NULL) {

            *ResourceToRelease = NULL;

            Status = STATUS_SUCCESS;
            goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
        }

        if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX ) ||
            (EndingOffset->QuadPart > Header->ValidDataLength.QuadPart &&
             Header->ValidDataLength.QuadPart != Header->FileSize.QuadPart)) {

            ResourceAcquired = Header->Resource;
            AcquireExclusive = TRUE;

        } else if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH ) ||
                   Header->PagingIoResource == NULL) {

            ResourceAcquired = Header->Resource;
            AcquireExclusive = FALSE;

        } else {

            ResourceAcquired = Header->PagingIoResource;
            AcquireExclusive = FALSE;
        }

        //
        //  Perform the following in a loop in case we need to back and
        //  check the state of the resource acquisition.  In most cases
        //  the initial checks will succeed and we can proceed immediately.
        //  We have to worry about the two FsRtl bits changing but
        //  if there is no paging io resource before there won't ever be
        //  one.
        //

        while (TRUE) {

            //
            //  Now acquire the desired resource.
            //

            if (AcquireExclusive) {

                if (!ExAcquireResourceExclusiveLite( ResourceAcquired, FALSE )) {

                    Status = STATUS_CANT_WAIT;
                    goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
                }

            } else if (!ExAcquireSharedWaitForExclusive( ResourceAcquired, FALSE )) {

                Status = STATUS_CANT_WAIT;
                goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
            }

            //
            //  If the valid data length is changing or the exclusive bit is
            //  set and we don't have the main resource exclusive then
            //  release the current resource and acquire the main resource
            //  exclusively and move to the top of the loop.
            //
            //  We must get it exclusive in all cases where the ending offset
            //  is beyond vdl.  It used to be allowed shared if vdl == fs, but
            //  this neglected the possibility that the file could be extended
            //  under our shared (pagingio) access.
            //

            if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX ) ||
                EndingOffset->QuadPart > Header->ValidDataLength.QuadPart) {

                //
                //  If we don't have the main resource exclusively then
                //  release the current resource and attempt to acquire
                //  the main resource exclusively.
                //

                if (!AcquireExclusive) {

                    ExReleaseResourceLite( ResourceAcquired );
                    AcquireExclusive = TRUE;
                    ResourceAcquired = Header->Resource;
                    continue;
                }

                //
                //  We have the correct resource.  Exit the loop.
                //

            //
            //  If we should be acquiring the main resource shared then move
            //  to acquire the correct resource and proceed to the top of the loop.
            //

            } else if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH )) {

                //
                //  If we have the main resource exclusively then downgrade to
                //  shared and exit the loop.
                //

                if (AcquireExclusive) {

                    ExConvertExclusiveToSharedLite( ResourceAcquired );

                //
                //  If we have the paging io resource then give up this resource
                //  and acquire the main resource exclusively.  This is going
                //  at it with a large hammer but is guaranteed to be resolved
                //  in the next pass through the loop.
                //

                } else if (ResourceAcquired != Header->Resource) {

                    ExReleaseResourceLite( ResourceAcquired );
                    ResourceAcquired = Header->Resource;
                    AcquireExclusive = TRUE;
                    continue;
                }

                //
                //  We have the correct resource.  Exit the loop.
                //

            //
            //  At this point we should have the paging Io resource shared
            //  if it exists.  If not then acquire it shared and release the
            //  other resource and exit the loop.
            //

            } else if (Header->PagingIoResource != NULL
                       && ResourceAcquired != Header->PagingIoResource) {

                ResourceAcquired = NULL;

                if (ExAcquireSharedWaitForExclusive( Header->PagingIoResource, FALSE )) {

                    ResourceAcquired = Header->PagingIoResource;
                }

                ExReleaseResourceLite( Header->Resource );

                if (ResourceAcquired == NULL) {

                    Status = STATUS_CANT_WAIT;
                    goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
                }

                //
                //  We now have the correct resource.  Exit the loop.
                //

            //
            //  We should have the main resource shared.  If we don't then
            //  degrade our lock to shared access.
            //

            } else if (AcquireExclusive) {

                ExConvertExclusiveToSharedLite( ResourceAcquired );

                //
                //  We now have the correct resource.  Exit the loop.
                //
            }

            //
            //  We have the correct resource.  Exit the loop.
            //

            break;
        }

        *ResourceToRelease = ResourceAcquired;

        Status = STATUS_SUCCESS;
    }

FsRtlAcquireFileForModWrite_CallCompletionCallbacks:

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }

#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileForModWriteEx_Succeed ++;

    } else {

        gCounter.AcquireFileForModWriteEx_Fail ++;
    }

#endif

    return Status;
}


NTKERNELAPI
VOID
FsRtlReleaseFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PERESOURCE ResourceToRelease
    )

/*++

Routine Description:

    This routine releases a file system resource previously acquired for
    the modified page writer.

Arguments:

    FileObject - Pointer to the file object being written.

    ResourceToRelease - Supplies the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CALLBACK_DATA CallbackData;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

#if DBG
    gCounter.ReleaseFileForModWrite ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForModWrite ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_MOD_WRITE,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        // Initialize the operation-specific parameters in the callback data.
        //

        CallbackData = &(FsFilterCtrl.Data);
        CallbackData->Parameters.ReleaseForModifiedPageWriter.ResourceToRelease = ResourceToRelease;

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           FALSE,
                                           TRUE,
                                           &BaseFsFailedOperation );
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForModWrite )) {

                Status = FastIoDispatch->ReleaseForModWrite( FileObject,
                                                             ResourceToRelease,
                                                             BaseFsDeviceObject );

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    //
    //  We expect STATUS_SUCCESS to be returned if the operation was completely 
    //  processed by the ReleaseForModWrite handler or 
    //  STATUS_INVALID_DEVICE_REQUEST if the default processing is being 
    //  requested.  To protect against incorrect driver implementation, we will 
    //  do the default logic on any non-success status code if we think the
    //  base file system has failed the release operation.
    //

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    //
    //  If the base file system doesn't provide a handler for this
    //  operation or the handler couldn't release the lock, perform the
    //  default action, which is releasing the ResourceToRelease.
    //

    if (!NT_SUCCESS( Status ) &&
        BaseFsFailedOperation) {

        ExReleaseResourceLite( ResourceToRelease );
        Status = STATUS_SUCCESS;
    }

    //
    //  Again, we only want to try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }
}


NTKERNELAPI
VOID
FsRtlAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine acquires a file system resource prior to a call to CcFlush.

    This routine is obsolete --- FsRtlAcquireFileForCcFlushEx should
    be used instead.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Just call the new version of this routine and ignore
    //  the return value.  In the debug version, we will assert
    //  if we see a failure here to encourage people to call the
    //  FsRtlAcquireFileForCcFlushEx.
    //

    Status = FsRtlAcquireFileForCcFlushEx( FileObject );

    ASSERT( NT_SUCCESS( Status ) );
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForCcFlushEx (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine acquires a file system resource prior to a call to CcFlush.
    This operation is presented to all the file system filters in the
    filter stack for this volume.  If all filters success the operation,
    the base file system is requested to acquire the file system resource
    for CcFlush.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{

    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForCcFlush ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_CC_FLUSH,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   TRUE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  There are no operation specific parameters for this
        //  operation, so just perform the pre-callbacks.
        //

        FsRtlEnterFileSystem();

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           TRUE,
                                           TRUE,
                                           &BaseFsFailedOperation );

    } else {

        //
        //  We don't have any filters to call, but we still need
        //  to disable APCs.
        //

        FsRtlEnterFileSystem();
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseFsDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForCcFlush )) {

                Status = FastIoDispatch->AcquireForCcFlush( FileObject,
                                                            BaseFsDeviceObject );

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    //
    //  If the file system doesn't have a dispatch handler or failed this
    //  this operation, try to acquire the appropriate resources ourself.
    //

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  If not already owned get the main resource exclusive because we may
        //  extend ValidDataLength.  Otherwise acquire it one more time recursively.
        //

        if (Header->Resource != NULL) {

            if (!ExIsResourceAcquiredSharedLite( Header->Resource )) {

                ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

            } else {

                ExAcquireResourceSharedLite( Header->Resource, TRUE );
            }
        }

        //
        //  Also get the paging I/O resource ahead of any MM resources.
        //

        if (Header->PagingIoResource != NULL) {

            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
        }

        Status = STATUS_SUCCESS;
    }

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }

    //
    //  If this lock was not successfully acquired, then the lock
    //  will not need to be released.  Therefore, we need to call
    //  FsRtlExitFileSystem now.
    //

    if (!NT_SUCCESS( Status )) {

        FsRtlExitFileSystem();
    }

#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileForCcFlushEx_Succeed ++;

    } else {

        gCounter.AcquireFileForCcFlushEx_Fail ++;
    }

#endif

    return Status;
}


NTKERNELAPI
VOID
FsRtlReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine releases a file system resource previously acquired for
    the CcFlush.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

#if DBG
    gCounter.ReleaseFileForCcFlush ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForCcFlush ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //


        CallFilters = NULL;
    }

    if (CallFilters) {

        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_CC_FLUSH,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        //  There are no operation-specific parameters to initialize,
        //  so perform the pre-operation callbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           FALSE,
                                           TRUE,
                                           &BaseFsFailedOperation );
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseFsDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForCcFlush )) {

                Status = FastIoDispatch->ReleaseForCcFlush( FileObject, BaseFsDeviceObject );

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  The base file system doesn't provide a handler for this
        //  operation, so perform the default actions.
        //

        //
        //  Free whatever we could have acquired.
        //

        if (Header->PagingIoResource != NULL) {

            ExReleaseResourceLite( Header->PagingIoResource );
        }

        if (Header->Resource != NULL) {

            ExReleaseResourceLite( Header->Resource );
        }

        Status = STATUS_SUCCESS;
    }

    ASSERT( Status == STATUS_SUCCESS );

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }

    FsRtlExitFileSystem();
}


NTKERNELAPI
VOID
FsRtlAcquireFileExclusive (
    __in PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is used by NtCreateSection to pre-acquire file system
    resources in order to avoid deadlocks.  If there is a FastIo entry
    for AcquireFileForNtCreateSection then that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    FALSE.  In the cases that we acquire a resource, we also set the
    TopLevelIrp field in the thread local storage to indicate to file
    systems beneath us that we have acquired file system resources.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    NONE

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Just call the common version of this function,
    //  FsRtlAcquireFileExclusiveCommon.
    //

    Status = FsRtlAcquireFileExclusiveCommon( FileObject, SyncTypeOther, 0 );

    //
    //  This should always be STATUS_SUCCESS since we are not
    //  allowing failures and the file system cannot fail
    //  this operation...
    //

    ASSERT( NT_SUCCESS( Status ) );
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireToCreateMappedSection (
    IN PFILE_OBJECT FileObject,
    IN ULONG SectionPageProtection
    )

/*++

Routine Description:

    This routine is meant to replace FsRtlAcquireFileExclusive for
    the memory manager.  Mm calls this routine to synchronize
    for a mapped section create, but filters are allowed
    to fail this operation.  Other components that want to
    synchronize with section creation should call
    FsRtlAcquireFileExclusive.

    This routine calls FsRtlAcquireFileExclusiveCommon to do
    all the work.

    This routine is used by NtCreateSection to pre-acquire file system
    resources in order to avoid deadlocks.  If there is a FastIo entry
    for AcquireFileForNtCreateSection then that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    FALSE.  In the cases that we acquire a resource, we also set the
    TopLevelIrp field in the thread local storage to indicate to file
    systems beneath us that we have acquired file system resources.

Arguments:

    FileObject - Pointer to the file object being written.
    SectionPageProtection - The access requested for the section being
        created.

Return Value:

    The status of the operation.

--*/

{

    PAGED_CODE();

    return FsRtlAcquireFileExclusiveCommon( FileObject, SyncTypeCreateSection, SectionPageProtection );

}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileExclusiveCommon (
    IN PFILE_OBJECT FileObject,
    IN FS_FILTER_SECTION_SYNC_TYPE SyncType,
    IN ULONG SectionPageProtection
    )

/*++

Routine Description:

    This routine is used to pre-acquire file system resources in order
    to avoid deadlocks.  The file system filters for this volume
    will be notified about this operation, then, if there is a FastIo
    entry for AcquireFileForNtCreateSection, that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    STATUS_SUCCESS.  Finally, the file system filters will be notified
    whether or not this resource has been acquired.

Arguments:

    FileObject - Pointer to the file object being written.
    CreatingMappedSection - TRUE if this lock is being acquired so that
        a mapped section can be created.  Filters are allowed
        to fail this operation.  FALSE otherwise.

Return Value:

    NONE

--*/

{

    PDEVICE_OBJECT DeviceObject, BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AllowFilterToFailOperation;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireFileForNtCreateSection ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        //
        //  Initialize operation specific parameters for this
        //  operation.
        //

        FsFilterCtrl.Data.Parameters.AcquireForSectionSynchronization.SyncType =
            SyncType;
        FsFilterCtrl.Data.Parameters.AcquireForSectionSynchronization.PageProtection =
            SectionPageProtection;

        switch (SyncType) {
        case SyncTypeCreateSection:
            AllowFilterToFailOperation = TRUE;
            break;

        case SyncTypeOther:
        default:
            AllowFilterToFailOperation = FALSE;
        }

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   AllowFilterToFailOperation );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  There are no operation specific parameters for this
        //  operation, so just perform the pre-callbacks.
        //

        FsRtlEnterFileSystem();

        //
        //  Note: If the filter is allowed to fail the operation, so is the
        //  base file system, so we will just use that variable for both
        //  parameters to FsFilterPerformCallbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           AllowFilterToFailOperation,
                                           AllowFilterToFailOperation,
                                           &BaseFsFailedOperation );

    } else {

        //
        //  We don't have any filters to call, but we still need
        //  to disable APCs.
        //

        FsRtlEnterFileSystem();
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseFsDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireFileForNtCreateSection )) {

                FastIoDispatch->AcquireFileForNtCreateSection( FileObject );

                //
                //  The status should already be STATUS_SUCCESS if we come down
                //  this path.  Since the FastIo handler doesn't return a value
                //  the status should remain STATUS_SUCCESS.
                //

                //  Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header;

        //
        //  The file system doesn't have a dispatch handler for this
        //  operation, so try to acquire the appropriate resources
        //  ourself.
        //

        //
        //  If there is a main file resource, acquire that.
        //

        Header = FileObject->FsContext;

        if ((Header != NULL) &&
            (Header->Resource != NULL)) {

            ExAcquireResourceExclusiveLite( Header->Resource, TRUE );
        }

        Status = STATUS_SUCCESS;
    }

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }

    //
    //  If this lock was not successfully acquired, then the lock
    //  will not need to be released.  Therefore, we need to call
    //  FsRtlExitFileSystem now.
    //

    if (!NT_SUCCESS( Status )) {

        FsRtlExitFileSystem();
    }

#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileExclusiveEx_Succeed ++;

    } else {

        gCounter.AcquireFileExclusiveEx_Fail ++;
    }

#endif

    return Status;
}


NTKERNELAPI
VOID
FsRtlReleaseFile (
    __in PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine releases resources acquired by FsRtlAcquireFileExclusive.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

#if DBG
    gCounter.ReleaseFile ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseFileForNtCreateSection ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //


        CallFilters = NULL;
    }

    if (CallFilters) {

        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        //  There are no operation-specific parameters to initialize,
        //  so perform the pre-operation callbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           FALSE,
                                           FALSE,
                                           &BaseFsFailedOperation );
    }

    if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

        //
        //  The filter/file system completed the operation, therefore we just need to
        //  call the completion callbacks for this operation.  There is no need to try
        //  to call the base file system.
        //

        Status = STATUS_SUCCESS;

    } else if (NT_SUCCESS( Status )) {

        if (CallFilters) {

            //
            // Always copy out file object
            //

            FileObject = FsFilterCtrl.Data.FileObject;

            if (FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

                BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
                ReleaseBaseFsDeviceReference = TRUE;
                FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
                FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            }
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch,
                                                ReleaseFileForNtCreateSection )) {

                FastIoDispatch->ReleaseFileForNtCreateSection( FileObject );

                //
                //  The status should already be STATUS_SUCCESS if we come down
                //  this path.  Since the FastIo handler doesn't return a value
                //  the status should remain STATUS_SUCCESS.
                //

                //  Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //

            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) ||
            (Status == STATUS_INVALID_DEVICE_REQUEST ) );

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  The base file system doesn't provide a handler for this
        //  operation, so perform the default actions.
        //

        //
        //  If there is a main file resource, release that.
        //

        if ((Header != NULL) && (Header->Resource != NULL)) {

            ExReleaseResourceLite( Header->Resource );
        }

        Status = STATUS_SUCCESS;
    }

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //

    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }

        FsFilterCtrlFree( &FsFilterCtrl );
    }

    FsRtlExitFileSystem();

    return;
}


NTSTATUS
FsRtlGetFileSize(
    __in PFILE_OBJECT FileObject,
    __inout PLARGE_INTEGER FileSize
    )

/*++

Routine Description:

    This routine is used to call the File System to get the FileSize
    for a file.

    It does this without acquiring the file object lock on synchronous file
    objects.  This routine is therefore safe to call if you already own
    file system resources, while IoQueryFileInformation could (and does)
    lead to deadlocks.

Arguments:

    FileObject - The file to query
    FileSize - Receives the file size.

Return Value:

    NTSTATUS - The final I/O status of the operation.  If the FileObject
        refers to a directory, STATUS_FILE_IS_A_DIRECTORY is returned.

--*/
{
    IO_STATUS_BLOCK IoStatus;
    PDEVICE_OBJECT DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;
    FILE_STANDARD_INFORMATION FileInformation;

    PAGED_CODE();

    //
    // Get the address of the target device object.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Try the fast query call if it exists.
    //

    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    if (FastIoDispatch &&
        FastIoDispatch->FastIoQueryStandardInfo &&
        FastIoDispatch->FastIoQueryStandardInfo( FileObject,
                                                 TRUE,
                                                 &FileInformation,
                                                 &IoStatus,
                                                 DeviceObject )) {
        //
        //  Cool, it worked.
        //

    } else {

        //
        //  Life's tough, take the long path.
        //

        PIRP Irp;
        KEVENT Event;
        NTSTATUS Status;
        PIO_STACK_LOCATION IrpSp;
        BOOLEAN HardErrorState;

        //
        //  Initialize the event.
        //

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  Allocate an I/O Request Packet (IRP) for this in-page operation.
        //

        Irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
        if (Irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Disable hard errors over this call. Caller owns resources, is in a critical
        //  region and cannot complete hard error APCs.
        //

        HardErrorState = IoSetThreadHardErrorMode( FALSE );

        //
        //  Get a pointer to the first stack location in the packet.  This location
        //  will be used to pass the function codes and parameters to the first
        //  driver.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Fill in the IRP according to this request, setting the flags to
        //  just cause IO to set the event and deallocate the Irp.
        //

        Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
        Irp->RequestorMode = KernelMode;
        Irp->UserIosb = &IoStatus;
        Irp->UserEvent = &Event;
        Irp->Tail.Overlay.OriginalFileObject = FileObject;
        Irp->Tail.Overlay.Thread = PsGetCurrentThread();
        Irp->AssociatedIrp.SystemBuffer = &FileInformation;

        //
        //  Fill in the normal query parameters.
        //

        IrpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
        IrpSp->FileObject = FileObject;
        IrpSp->DeviceObject = DeviceObject;
        IrpSp->Parameters.SetFile.Length = sizeof(FILE_STANDARD_INFORMATION);
        IrpSp->Parameters.SetFile.FileInformationClass = FileStandardInformation;

        //
        //  Queue the packet to the appropriate driver based.  This routine
        //  should not raise.
        //

        Status = IoCallDriver( DeviceObject, Irp );

        //
        //  If pending is returned (which is a successful status),
        //  we must wait for the request to complete.
        //

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER)NULL);
        }

        //
        //  If we got an error back in Status, then the Iosb
        //  was not written, so we will just copy the status
        //  there, then test the final status after that.
        //

        if (!NT_SUCCESS(Status)) {
            IoStatus.Status = Status;
        }

        //
        //  Reset the hard error state.
        //

        IoSetThreadHardErrorMode( HardErrorState );
    }

    //
    //  If the call worked, check to make sure it wasn't a directory and
    //  if not, fill in the FileSize parameter.
    //

    if (NT_SUCCESS(IoStatus.Status)) {

        if (FileInformation.Directory) {

            //
            // Can't get file size for a directory. Return error.
            //

            IoStatus.Status = STATUS_FILE_IS_A_DIRECTORY;

        } else {

            *FileSize = FileInformation.EndOfFile;
        }
    }

    return IoStatus.Status;
}


NTSTATUS
FsRtlSetFileSize(
    IN PFILE_OBJECT FileObject,
    IN OUT PLARGE_INTEGER FileSize
    )

/*++

Routine Description:

    This routine is used to call the File System to update FileSize
    for a file.

    It does this without acquiring the file object lock on synchronous file
    objects.  This routine is therefore safe to call if you already own
    file system resources, while IoSetInformation could (and does) lead
    to deadlocks.

Arguments:

    FileObject - A pointer to a referenced file object.

    ValidDataLength - Pointer to new FileSize.

Return Value:

    Status of operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    FILE_END_OF_FILE_INFORMATION Buffer;
    IO_STATUS_BLOCK IoStatus;
    KEVENT Event;
    PIRP Irp;
    BOOLEAN HardErrorState;

    PAGED_CODE();

    //
    //  Copy FileSize to our buffer.
    //

    Buffer.EndOfFile = *FileSize;

    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Begin by getting a pointer to the device object that the file resides
    //  on.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    //  Allocate an I/O Request Packet (IRP) for this in-page operation.
    //

    Irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Disable hard errors over this call. Caller owns resources, is in a critical
    //  region and cannot complete hard error APCs.
    //

    HardErrorState = IoSetThreadHardErrorMode( FALSE );

    //
    //  Get a pointer to the first stack location in the packet.  This location
    //  will be used to pass the function codes and parameters to the first
    //  driver.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Fill in the IRP according to this request, setting the flags to
    //  just cause IO to set the event and deallocate the Irp.
    //

    Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
    Irp->RequestorMode = KernelMode;
    Irp->UserIosb = &IoStatus;
    Irp->UserEvent = &Event;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->AssociatedIrp.SystemBuffer = &Buffer;

    //
    //  Fill in the normal set file parameters.
    //

    IrpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    IrpSp->FileObject = FileObject;
    IrpSp->DeviceObject = DeviceObject;
    IrpSp->Parameters.SetFile.Length = sizeof(FILE_END_OF_FILE_INFORMATION);
    IrpSp->Parameters.SetFile.FileInformationClass = FileEndOfFileInformation;

    //
    //  Queue the packet to the appropriate driver based on whether or not there
    //  is a VPB associated with the device.  This routine should not raise.
    //

    Status = IoCallDriver( DeviceObject, Irp );

    //
    //  If pending is returned (which is a successful status),
    //  we must wait for the request to complete.
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }

    //
    //  If we got an error back in Status, then the Iosb
    //  was not written, so we will just copy the status
    //  there, then test the final status after that.
    //

    if (!NT_SUCCESS(Status)) {
        IoStatus.Status = Status;
    }

    //
    //  Reset the hard error state.
    //

    IoSetThreadHardErrorMode( HardErrorState );

    return IoStatus.Status;
}


VOID
FsRtlIncrementCcFastReadNotPossible( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadNotPossible counter in the PRCB

Arguments:

Return Value:

--*/

{
    HOT_STATISTIC( CcFastReadNotPossible ) += 1;
}


VOID
FsRtlIncrementCcFastReadWait( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadWait counter in the PRCB

Arguments:

Return Value:

--*/

{

    HOT_STATISTIC(CcFastReadWait) += 1;
}


VOID
FsRtlIncrementCcFastReadNoWait( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadNoWait counter in the PRCB

Arguments:

Return Value:

--*/

{

    HOT_STATISTIC(CcFastReadNoWait) += 1;
}


VOID
FsRtlIncrementCcFastReadResourceMiss( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadResourceMiss

Arguments:

Return Value:

--*/

{

    CcFastReadResourceMiss += 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\faulttol.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FaultTol.c

Abstract:

    The routines in this module help the file systems perform fault
    tolerance operation to the FT device drivers.

--*/

#include "FsRtlP.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlBalanceReads)
#pragma alloc_text(PAGE, FsRtlSyncVolumes)
#endif


NTSTATUS
FsRtlBalanceReads (
    __in PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine signals a device driver that it is now OK to start
    balancing reads from a mirrored drive.  This is typically called
    after the file system determines that a volume is clean.

Arguments:

    TargetDevice - Supplies the device to start balanced read from.

Return Value:

    NTSTATUS - The result of the operation.  This will be
        STATUS_INVALID_DEVICE_REQUEST if the volume is not a mirror.

--*/

{
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( FT_BALANCED_READ_MODE,
                                         TargetDevice,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoCallDriver( TargetDevice, Irp );


    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        ASSERT( Status == STATUS_SUCCESS );

        Status = Iosb.Status;
    }

    return Status;
}

NTSTATUS
FsRtlSyncVolumes (
    __in PDEVICE_OBJECT TargetDevice,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER ByteCount
    )

/*++

Routine Description:

    This routine signals a device driver that it must sync redundant
    members of a mirror from the primary member.  This is typically
    called after the file system determines that a volume is dirty.

Arguments:

    TargetDevice - Supplies the device to sync.

    ByteOffset - If specified, gives the location to start syncing

    ByteCount - Gives the byte count to sync.  Ignored if StartingOffset
        not specified.

Return Value:

    NTSTATUS - The result of the operation.  This will be
        STATUS_INVALID_DEVICE_REQUEST if the volume is not a mirror.

--*/

{
    UNREFERENCED_PARAMETER (TargetDevice);
    UNREFERENCED_PARAMETER (ByteOffset);
    UNREFERENCED_PARAMETER (ByteCount);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\dbcsname.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    DbcsName.c

Abstract:

    The name support package is for manipulating DBCS strings.  The routines
    allow the caller to dissect and compare strings.

    The following routines are provided by this package:

      o  FsRtlIsFatDbcsLegal - This routine takes an input dbcs
         string and determines if it describes a legal name or path.

      o  FsRtlIsHpfsDbcsLegal - This routine takes an input dbcs
         string and determines if it describes a legal name or path.

      o  FsRtlDissectDbcs - This routine takes a path name string and
         breaks into two parts.  The first name in the string and the
         remainder.

      o  FsRtlDoesDbcsContainWildCards - This routines tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsDbcsInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('drSF')

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlDissectDbcs)
#pragma alloc_text(PAGE, FsRtlDoesDbcsContainWildCards)
#pragma alloc_text(PAGE, FsRtlIsDbcsInExpression)
#pragma alloc_text(PAGE, FsRtlIsFatDbcsLegal)
#pragma alloc_text(PAGE, FsRtlIsHpfsDbcsLegal)
#endif


BOOLEAN
FsRtlIsFatDbcsLegal (
    __in ANSI_STRING DbcsName,
    __in BOOLEAN WildCardsPermissible,
    __in BOOLEAN PathNamePermissible,
    __in BOOLEAN LeadingBackslashPermissible
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal file names.  This routine
    will check the single name, or if PathNamePermissible is specified as
    TRUE, whether the whole path is a legal name.

    For FAT, the following rules apply:

    A. A Fat file name may not contain any of the following characters:

       0x00-0x1F " / : | + , ; = [ ]

    B. A Fat file name is either of the form N.E or just N, where N is a
       string of 1-8 bytes and E is a string of 1-3 bytes conformant to
       rule A above. In addition, neither N nor E may contain a period
       character or end with a space character.

       Incidentally, N corresponds to name and E to extension.

    Case: Lower case characters are taken as valid, but are up-shifted upon
          receipt, ie. Fat only deals with upper case file names.

    For example, the files ".foo", "foo.", and "foo .b" are illegal, while
    "foo. b" and " bar" are legal.

Arguments:

    DbcsName - Supplies the name/path to check.

    WildCardsPermissible - Specifies if Nt wild card characters are to be
        considered considered legal.

    PathNamePermissible - Spcifes if Name may be a path name separated by
        backslash characters, or just a simple file name.

    LeadingBackSlashPermissible - Specifies if a single leading backslash
        is permissible in the file/path name.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/
{
    BOOLEAN ExtensionPresent = FALSE;

    ULONG Index;

    UCHAR Char = 0;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( DbcsName.Length == 0 ) { return FALSE; }

    //
    //  If Wild Cards are OK, then for directory enumeration to work
    //  correctly we have to accept . and ..
    //

    if ( WildCardsPermissible &&
         ( ( (DbcsName.Length == 1) &&
             ((DbcsName.Buffer[0] == '.') ||
              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
           ||
           ( (DbcsName.Length == 2) &&
             ( ((DbcsName.Buffer[0] == '.') &&
                (DbcsName.Buffer[1] == '.')) ||
               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &&
                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {

        return TRUE;
    }

    //
    //  If a leading \ is OK, skip over it (if there's more)
    //

    if ( DbcsName.Buffer[0] == '\\' ) {

        if ( LeadingBackslashPermissible ) {

            if ( (DbcsName.Length > 1) ) {

                DbcsName.Buffer += 1;
                DbcsName.Length -= 1;

            } else { return TRUE; }

        } else { return FALSE; }
    }

    //
    //  If we got a path name, check each component.
    //

    if ( PathNamePermissible ) {

        ANSI_STRING FirstName;
        ANSI_STRING RemainingName;

        RemainingName = DbcsName;

        while ( RemainingName.Length != 0 ) {

            //
            //  This will catch the case of an illegal double backslash.
            //

            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }

            FsRtlDissectDbcs(RemainingName, &FirstName, &RemainingName);

            if ( !FsRtlIsFatDbcsLegal( FirstName,
                                       WildCardsPermissible,
                                       FALSE,
                                       FALSE) ) {

                return FALSE;
            }
        }

        //
        //  All the components were OK, so the path is OK.
        //

        return TRUE;
    }

    //
    //  If this name contains wild cards, just check for invalid characters.
    //

    if ( WildCardsPermissible && FsRtlDoesDbcsContainWildCards(&DbcsName) ) {

        for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

            Char = DbcsName.Buffer[ Index ];

            //
            //  Skip over any Dbcs characters
            //

            if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

                ASSERT( Index != (ULONG)(DbcsName.Length - 1) );
                Index += 1;
                continue;
            }

            //
            //  Make sure this character is legal, and if a wild card, that
            //  wild cards are permissible.
            //

            if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {
                return FALSE;
            }
        }

        return TRUE;
    }


    //
    //  At this point we should only have a single name, which can't have
    //  more than 12 characters (including a single period)
    //

    if ( DbcsName.Length > 12 ) { return FALSE; }

    for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

        Char = DbcsName.Buffer[ Index ];

        //
        //  Skip over and Dbcs characters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            //
            //  FsRtlIsFatDbcsLegal(): fat name part and extension part dbcs check
            //
            //  1) if we're looking at base part ( !ExtensionPresent ) and the 8th byte
            //     is in the dbcs leading byte range, it's error ( Index == 7 ). If the
            //     length of base part is more than 8 ( Index > 7 ), it's definitely error.
            //
            //  2) if the last byte ( Index == DbcsName.Length - 1 ) is in the dbcs leading
            //     byte range, it's error
            //

            if ( (!ExtensionPresent && (Index >= 7)) ||
                 ( Index == (ULONG)(DbcsName.Length - 1) ) ) {
                return FALSE;
            }

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, WildCardsPermissible) ) {

            return FALSE;
        }

        if ( (Char == '.') || (Char == ANSI_DOS_DOT) ) {

            //
            //  We stepped onto a period.  We require the following things:
            //
            //      - It can't be the first character
            //      - There can only be one
            //      - There can't be more than three characters following
            //      - The previous character can't be a space.
            //

            if ( (Index == 0) ||
                 ExtensionPresent ||
                 (DbcsName.Length - (Index + 1) > 3) ||
                 (DbcsName.Buffer[Index - 1] == ' ') ) {

                return FALSE;
            }

            ExtensionPresent = TRUE;
        }

        //
        //  The base part of the name can't be more than 8 characters long.
        //

        if ( (Index >= 8) && !ExtensionPresent ) { return FALSE; }
    }

    //
    //  The name cannot end in a space or a period.
    //

    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT)) { return FALSE; }

    return TRUE;
}

BOOLEAN
FsRtlIsHpfsDbcsLegal (
    __in ANSI_STRING DbcsName,
    __in BOOLEAN WildCardsPermissible,
    __in BOOLEAN PathNamePermissible,
    __in BOOLEAN LeadingBackslashPermissible
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal file names.  This routine
    will check the single name, or if PathNamePermissible is specified as
    TRUE, whether the whole path is a legal name.

    For HPFS, the following rules apply:

    A. An HPFS file name may not contain any of the following characters:

       0x0000 - 0x001F  " / : < > ? | *

    B. An HPFS file name may not end in a period or a space.

    C. An HPFS file name must contain no more than 255 bytes.

    Case: HPFS is case preserving, but not case sensitive.  Case is
          preserved on creates, but not checked for on file name compares.

    For example, the files "foo " and "foo." are illegal, while ".foo",
    " foo" and "foo.bar.foo" are legal.

Arguments:

    DbcsName - Supplies the name/path to check.

    WildCardsPermissible - Specifies if Nt wild card characters are to be
        considered considered legal.

    PathNamePermissible - Spcifes if Name may be a path name separated by
        backslash characters, or just a simple file name.

    LeadingBackSlashPermissible - Specifies if a single leading backslash
        is permissible in the file/path name.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/
{
    ULONG Index;

    UCHAR Char = 0;

    PAGED_CODE();

    //
    //  Empty names are not valid.
    //

    if ( DbcsName.Length == 0 ) { return FALSE; }

    //
    //  If Wild Cards are OK, then for directory enumeration to work
    //  correctly we have to accept . and ..
    //

    if ( WildCardsPermissible &&
         ( ( (DbcsName.Length == 1) &&
             ((DbcsName.Buffer[0] == '.') ||
              (DbcsName.Buffer[0] == ANSI_DOS_DOT)) )
           ||
           ( (DbcsName.Length == 2) &&
             ( ((DbcsName.Buffer[0] == '.') &&
                (DbcsName.Buffer[1] == '.')) ||
               ((DbcsName.Buffer[0] == ANSI_DOS_DOT) &&
                (DbcsName.Buffer[1] == ANSI_DOS_DOT)) ) ) ) ) {

        return TRUE;
    }

    //
    //  If a leading \ is OK, skip over it (if there's more)
    //

    if ( DbcsName.Buffer[0] == '\\' ) {

        if ( LeadingBackslashPermissible ) {

            if ( (DbcsName.Length > 1) ) {

                DbcsName.Buffer += 1;
                DbcsName.Length -= 1;

            } else { return TRUE; }

        } else { return FALSE; }
    }

    //
    //  If we got a path name, check each component.
    //

    if ( PathNamePermissible ) {

        ANSI_STRING FirstName;
        ANSI_STRING RemainingName;

        RemainingName = DbcsName;

        while ( RemainingName.Length != 0 ) {

            //
            //  This will catch the case of an illegal double backslash.
            //

            if ( RemainingName.Buffer[0] == '\\' ) { return FALSE; }

            FsRtlDissectDbcs(RemainingName, &FirstName, &RemainingName);

            if ( !FsRtlIsHpfsDbcsLegal( FirstName,
                                       WildCardsPermissible,
                                       FALSE,
                                       FALSE) ) {

                return FALSE;
            }
        }

        //
        //  All the components were OK, so the path is OK.
        //

        return TRUE;
    }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 255 characters
    //

    if ( DbcsName.Length > 255 ) { return FALSE; }

    for ( Index = 0; Index < DbcsName.Length; Index += 1 ) {

        Char = DbcsName.Buffer[ Index ];

        //
        //  Skip over and Dbcs characters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            //
            //  FsRtlIsHpfsDbcsLegal () hpfs dbcs check
            //
            //  If the last byte ( Index == DbcsName.Length - 1 ) is in the
            //  dbcs leading byte range, it's error.
            //

            if ( Index == (ULONG)(DbcsName.Length - 1) ) {

                return FALSE;
            }

            Index += 1;
            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalHpfs(Char, WildCardsPermissible) ) {

            return FALSE;
        }
    }

    //
    //  The name cannot end in a space or a period.
    //

    if ( (Char == ' ') || (Char == '.') || (Char == ANSI_DOS_DOT) ) {

        return FALSE;
    }

    return TRUE;
}


VOID
FsRtlDissectDbcs (
    __in ANSI_STRING Path,
    __out PANSI_STRING FirstName,
    __out PANSI_STRING RemainingName
    )

/*++

Routine Description:

    This routine takes an input Dbcs string and dissects it into two
    substrings.  The first output string contains the name that appears at
    the beginning of the input string, the second output string contains the
    remainder of the input string.

    In the input string backslashes are used to separate names.  The input
    string must not start with a backslash.  Both output strings will not
    begin with a backslash.

    If the input string does not contain any names then both output strings
    are empty.  If the input string contains only one name then the first
    output string contains the name and the second string is empty.

    Note that both output strings use the same string buffer memory of the
    input string.

    Example of its results are:

//. .     InputString    FirstPart    RemainingPart
//
//. .     empty          empty        empty
//
//. .     A              A            empty
//
//. .     A\B\C\D\E      A            B\C\D\E
//
//. .     *A?            *A?          empty
//
//. .     \A             A            empty
//
//. .     A[,]           A[,]         empty
//
//. .     A\\B+;\C       A            \B+;\C

Arguments:

    InputName - Supplies the input string being dissected

    Is8dot3 - Indicates if the first part of the input name must be 8.3
        or can be long file name.

    FirstPart - Receives the first name in the input string

    RemainingPart - Receives the remaining part of the input string

Return Value:

    NONE

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    PAGED_CODE();

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length;

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == '\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != '\\');
          i += 1 ) {

        //
        //  If this is the first byte of a Dbcs character, skip over the
        //  next byte as well.
        //

        if ( FsRtlIsLeadDbcsCharacter( Path.Buffer[i] ) ) {

            i += 1;
        }
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)(i - FirstNameStart);
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)(PathLength - (i + 1));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
FsRtlDoesDbcsContainWildCards (
    __in PANSI_STRING Name
    )

/*++

Routine Description:

    This routine checks if the input Dbcs name contains any wild card
    characters (i.e., *, ?, ANSI_DOS_STAR, or ANSI_DOS_QM).

Arguments:

    Name - Supplies the name to examine

Return Value:

    BOOLEAN - TRUE if the input name contains any wildcard characters and
        FALSE otherwise.

--*/

{
    CLONG i;

    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character
    //

    for (i = 0; i < Name->Length; i += 1) {

        //
        //  check for dbcs character because we'll just skip over those
        //

        if (FsRtlIsLeadDbcsCharacter( Name->Buffer[i] )) {

            i += 1;

        //
        //  else check for a wild card character
        //

        } else if (FsRtlIsAnsiCharacterWild( Name->Buffer[i] )) {

            //
            //  Tell caller that this name contains wild cards
            //

            return TRUE;
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}

#define GetDbcs(BUF,OFFSET,DBCS_CHAR,LENGTH) {               \
    if (FsRtlIsLeadDbcsCharacter( (BUF)[(OFFSET)] )) {       \
        *(DBCS_CHAR) = (WCHAR)((BUF)[(OFFSET)] +             \
                               0x100 * (BUF)[(OFFSET) + 1]); \
        *(LENGTH) = 2;                                       \
    } else {                                                 \
        *(DBCS_CHAR) = (WCHAR)(BUF)[(OFFSET)];               \
        *(LENGTH) = 1;                                       \
    }                                                        \
}

#define MATCHES_ARRAY_SIZE 16

BOOLEAN
FsRtlIsDbcsInExpression (
    __in PANSI_STRING Expression,
    __in PANSI_STRING Name
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against

    Name - Supplies the input name to check for.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;
    USHORT Length;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar = 0, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlIsDbcsInExpression\n", 0);
    DebugTrace( 0, Dbg, " Expression      = %Z\n", Expression );
    DebugTrace( 0, Dbg, " Name            = %Z\n", Name );

    ASSERT( Name->Length != 0 );
    ASSERT( Expression->Length != 0 );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 1) && (Expression->Buffer[0] == '*')) {

        return TRUE;
    }

    ASSERT( FsRtlDoesDbcsContainWildCards( Expression ) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == '*') {

        ANSI_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 1;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesDbcsContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - 1)) {

                return FALSE;
            }

            StartingNameOffset = Name->Length - LocalExpression.Length;

            //
            //  StatingNameOffset must not bisect DBCS characters.
            //

            if (NlsMbOemCodePageTag) {

                ULONG i = 0;

                while ( i < StartingNameOffset ) {

                    i += FsRtlIsLeadDbcsCharacter( Name->Buffer[i] ) ? 2 : 1;
                }

                if ( i > StartingNameOffset ) {

                    return FALSE;
                }
            }

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                             Name->Buffer + StartingNameOffset,
                                             LocalExpression.Length );
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhausted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            GetDbcs( Name->Buffer, NameOffset, &NameChar, &Length );
            NameOffset = (USHORT)(NameOffset + Length);

        } else {

            NameFinished = TRUE;

            //
            //  If we have already exhausted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);

            Length = 0;


            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset = (USHORT)(ExprOffset + Length);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                GetDbcs(Expression->Buffer, ExprOffset, &ExprChar, &Length);

                ASSERT( !((ExprChar >= 'a') && (ExprChar <= 'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    AuxBuffer = FsRtlpAllocatePool( PagedPool,
                                                    (Expression->Length+1) *
                                                    sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (Expression->Length+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (Expression->Length+1)*2;

                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == '*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 1;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == ANSI_DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        WCHAR NameChar;
                        USHORT Offset;
                        USHORT Length;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset = (USHORT)(Offset + Length) ) {

                            GetDbcs( Name->Buffer, Offset, &NameChar, &Length );

                            if (NameChar == '.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != '.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 1;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 1;
                        continue;
                    }
                }

                //
                //  The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState = (USHORT)(CurrentState + (Length * 2));

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == '.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == '?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == NameChar) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is monotonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarantees non-duplication in the dest. array.
            //

            while ((SrcCount < MatchesCount) &&
                   (PreviousDestCount < DestCount)) {

                while ((SrcCount < MatchesCount) &&
                       (PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount])) {

                    SrcCount += 1;
                }

                PreviousDestCount += 1;
            }
        }

        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {


            if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\fsfilter.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FsFilter.c

Abstract:

    This file contains the routines that show certain file system operations
    to file system filters.  File system filters were initially bypassed
    for these operations.

--*/

#include "FsRtlP.h"

#define FS_FILTER_MAX_COMPLETION_STACK_SIZE    30

typedef struct _FS_FILTER_RESERVE {

    //
    //  The thread that currently owns the memory.
    //

    PETHREAD Owner;

    //
    //  A stack of completion node bigger than anyone should ever need.
    //

    FS_FILTER_COMPLETION_NODE Stack [FS_FILTER_MAX_COMPLETION_STACK_SIZE];

} FS_FILTER_RESERVE, *PFS_FILTER_RESERVE;

//
//  Note: Events are used to synchronize access to the reserved pool here
//  because using a faster synchronization mechanism (like a FAST_MUTEX)
//  would cause us to raise IRQL to APC_LEVEL while we hold the lock.  This is
//  not acceptable because we call out to the filters while holding this lock
//  and we wouldn't want to be at APC_LEVEL during these calls.
//

KEVENT AcquireOpsEvent;
PFS_FILTER_RESERVE AcquireOpsReservePool;

KEVENT ReleaseOpsEvent;
PFS_FILTER_RESERVE ReleaseOpsReservePool;

NTSTATUS
FsFilterInit(
    )

/*++

Routine Description:

    This routine initializes the reserve pool the FsFilter routine need to use
    when the system is in low memory conditions.

Arguments:

    None.

Return Value:

    Returns STATUS_SUCCESS if the initialization was successful, or
    STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    AcquireOpsReservePool = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( FS_FILTER_RESERVE ),
                                                   FSRTL_FILTER_MEMORY_TAG );

    if (AcquireOpsReservePool == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ReleaseOpsReservePool = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( FS_FILTER_RESERVE ),
                                                   FSRTL_FILTER_MEMORY_TAG );

    if (ReleaseOpsReservePool == NULL) {

        ExFreePoolWithTag( AcquireOpsReservePool,
                           FSRTL_FILTER_MEMORY_TAG );
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    KeInitializeEvent( &AcquireOpsEvent, SynchronizationEvent, TRUE );
    KeInitializeEvent( &ReleaseOpsEvent, SynchronizationEvent, TRUE );

    return Status;
}

NTSTATUS
FsFilterAllocateCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN CanFail,
    OUT PULONG AllocationSize
    )

/*++

Routine Description:

    This routine allocates a completion stack for the given FsFilterCtrl.  If
    this allocation cannot fail, then this routine will wait to allocation
    the memory from the FsFilter reserved pool.

    This routine initialized the appropriate CompletionStack parameters and
    FsFilterCtrl flags to reflect the allocation made.

Arguments:

    FsFilterCtrl - The FsFilterCtrl structure for which the completion stack
        must be allocated.
    CanFail - TRUE if the allocation is allowed to fail, FALSE otherwise.
    AllocationSize - Set to the nuber of bytes of memory allocated for the
        completion stack for this FsFilterCtrl.

Return Value:

    Returns STATUS_SUCCESS if the memory was successfully allocated for the
    completion stack, or STATUS_INSUFFICIENT_RESOURCES otherwise.

--*/

{
    PFS_FILTER_COMPLETION_NODE Stack = NULL;
    PFS_FILTER_RESERVE ReserveBlock = NULL;
    PKEVENT Event = NULL;

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( AllocationSize != NULL );

    *AllocationSize = FsFilterCtrl->CompletionStack.StackLength *
                      sizeof( FS_FILTER_COMPLETION_NODE );

    Stack = ExAllocatePoolWithTag( NonPagedPool,
                                   *AllocationSize,
                                   FSRTL_FILTER_MEMORY_TAG );

    if (Stack == NULL) {

        if (CanFail) {

            return STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            //  This allocation cannot fail, so get the needed memory from our
            //  private stash of pool.
            //

            switch (FsFilterCtrl->Data.Operation) {

            case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

                ReserveBlock = AcquireOpsReservePool;
                Event = &AcquireOpsEvent;
                break;

            case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            case FS_FILTER_RELEASE_FOR_CC_FLUSH:

                ReserveBlock = ReleaseOpsReservePool;
                Event = &ReleaseOpsEvent;
                break;

            default:

                //
                //  This shouldn't happen since we should always cover all
                //  possible types of operations in the above cases.
                //

                ASSERTMSG( "FsFilterAllocateMemory: Unknown operation type\n",
                           FALSE );
            }

            //
            //  Wait to get on the appropriate event so that we know the reserve
            //  memory is available for use.
            //

            KeWaitForSingleObject( Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            //
            //  We've been signaled, so the reserved block is available.
            //

            ReserveBlock->Owner = PsGetCurrentThread();
            Stack = ReserveBlock->Stack;
            SetFlag( FsFilterCtrl->Flags, FS_FILTER_USED_RESERVE_POOL );
        }
    }

    ASSERT( Stack != NULL );

    //
    //  We've now got our block of memory, so initialize the completion stack.
    //

    SetFlag( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK );
    FsFilterCtrl->CompletionStack.Stack = Stack;

    return STATUS_SUCCESS;
}

VOID
FsFilterFreeCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl
    )

/*++

Routine Description:

    This routine frees the allocated completion stack in the FsFilterCtrl
    parameter.

Arguments:

    FsFilterCtrl - The FsFilterCtrl structure for which the completion stack
        must be freed.

Return Value:

    None.

--*/

{
    PKEVENT Event = NULL;
    PFS_FILTER_RESERVE ReserveBlock = NULL;

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( FlagOn( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK ) );

    if (!FlagOn( FsFilterCtrl->Flags, FS_FILTER_USED_RESERVE_POOL )) {

        //
        //  We were able to allocate this from the generate pool of memory,
        //  so just free the memory block used for the completion stack.
        //

        ExFreePoolWithTag( FsFilterCtrl->CompletionStack.Stack,
                           FSRTL_FILTER_MEMORY_TAG );

    } else {

        //
        //  This allocation from our private pool stash, so use the operation
        //  to figure out which private stash.
        //

        switch (FsFilterCtrl->Data.Operation) {
        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

            Event = &AcquireOpsEvent;
            break;

        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
        case FS_FILTER_RELEASE_FOR_CC_FLUSH:

            Event = &ReleaseOpsEvent;
            break;

        default:

            //
            //  This shouldn't happen since we should always cover all
            //  possible types of operations in the above cases.
            //

            ASSERTMSG( "FsFilterAllocateMemory: Unknown operation type\n",
                       FALSE );
        }

        ASSERT( Event != NULL );

        //
        //  Clear out the owner of the reserve block before setting the event.
        //

        ReserveBlock = CONTAINING_RECORD( FsFilterCtrl->CompletionStack.Stack,
                                          FS_FILTER_RESERVE,
                                          Stack );
        ReserveBlock->Owner = NULL;

        //
        //  Now we are ready to release the reserved block to the next thread
        //  that needs it.
        //

        KeSetEvent( Event, IO_NO_INCREMENT, FALSE );
    }
}

NTSTATUS
FsFilterCtrlInit (
    IN OUT PFS_FILTER_CTRL FsFilterCtrl,
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT BaseFsDeviceObject,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN CanFail
    )

/*++

Routine Description:

    This routine initializes the FsFilterCtrl structure used to store the
    contexts and post-operation callbacks for this operation.  If the
    default completion stack is not large enough, this routine will need to
    allocate a completion stack of sufficient size to store all the possible
    contexts and post-operation callbacks.

Arguments:

    FsFilterCtrl - The FsFilterCtrl to initialize.
    Operation - The operation this FsFilterCtrl is going to be used for.
    DeviceObject - The device object to which this operation will be targeted.
    BaseFsDeviceObject - The device object for the base file system at the
        bottom on this filter stack.
    FileObject - The file object to which this operation will be targeted.
    CanFail - TRUE if the call can deal with memory allocations failing,
        FALSE otherwise.

Return Value:

    STATUS_SUCCESS if the FsFilterCtrl structure could be initialized,
    STATUS_INSUFFICIENT_RESOURCES if the routine cannot allocate the needed
    memory to initialize this structure.

--*/

{
    PFS_FILTER_CALLBACK_DATA Data;
    ULONG AllocationSize;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( BaseFsDeviceObject );

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( DeviceObject != NULL );

    FsFilterCtrl->Flags = 0;

    Data = &(FsFilterCtrl->Data);

    Data->SizeOfFsFilterCallbackData = sizeof( FS_FILTER_CALLBACK_DATA );
    Data->Operation = Operation;
    Data->DeviceObject = DeviceObject;
    Data->FileObject = FileObject;

    //
    //  Since it is possible for a filter to redirect this operation to another
    //  stack, we must assume that the stack size of their device object is
    //  large enough to account for the large stack they would need in the
    //  redirection.  It is the stack size of the top device object that we
    //  will use to determine the size of our completion stack.
    //

    FsFilterCtrl->CompletionStack.StackLength = DeviceObject->StackSize;
    FsFilterCtrl->CompletionStack.NextStackPosition = 0;

    if (FsFilterCtrl->CompletionStack.StackLength > FS_FILTER_DEFAULT_STACK_SIZE) {

        //
        //  The stack isn't big enough, so we must dynamically allocate
        //  the completion stack.  This should happen VERY rarely.
        //

        Status = FsFilterAllocateCompletionStack( FsFilterCtrl,
                                                  CanFail,
                                                  &AllocationSize );

        //
        //  If the above allocation failed and we cannot fail this allocation,
        //  use our private pool stash.
        //

        if (!NT_SUCCESS( Status )) {

            ASSERT( CanFail );
            return Status;
        }

        ASSERT( FsFilterCtrl->CompletionStack.Stack );

    } else {

        //
        //  The default completion noded array allocated for the stack
        //  is large enough, so set Stack to point to that array.
        //

        FsFilterCtrl->CompletionStack.Stack = &(FsFilterCtrl->CompletionStack.DefaultStack[0]);
        AllocationSize = sizeof( FS_FILTER_COMPLETION_NODE ) * FS_FILTER_DEFAULT_STACK_SIZE;
        FsFilterCtrl->CompletionStack.StackLength = FS_FILTER_DEFAULT_STACK_SIZE;
    }

    RtlZeroMemory( FsFilterCtrl->CompletionStack.Stack, AllocationSize );

    return Status;
}

VOID
FsFilterCtrlFree (
    IN PFS_FILTER_CTRL FsFilterCtrl
    )

/*++

Routine Description:

    This routine frees any memory associated FsFilterCtrl.  It is possible
    that we had to allocate more memory to deal with a stack that is larger
    than the FS_FILTER_DEFAULT_STACK_SIZE.

Arguments:

    FsFilterCtrl - The FsFilterCtrl structure to free.

Return Value:

    NONE

--*/

{
    ASSERT( FsFilterCtrl != NULL );

    ASSERT( FsFilterCtrl->CompletionStack.Stack != NULL );

    if (FlagOn( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK )) {

        FsFilterFreeCompletionStack( FsFilterCtrl );
    }
}

VOID
FsFilterGetCallbacks (
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PFS_FILTER_CALLBACK *PreOperationCallback,
    OUT PFS_FILTER_COMPLETION_CALLBACK *PostOperationCallback
    )

/*++

Routine Description:

    This routine looks up the PreOperationCallback and the PostOperationCallback
    that the filter has registered for this operation if it has registered one.
Arguments:

    Operation - The current operation of interest.
    DeviceObject - The device object that the filter attached to the file system
        filter stack.
    PreOperationCallback - Set to the PreOperationCallback that the filter
        registered for this operation if one was registered.  Otherwise, this
        is set to NULL.
    PostOperationCallback - Set to the PostOperationCallback that the filter
        registered for this operation if one was registered.  Otherwise, this
        is set to NULL.

Return Value:

    NONE

--*/

{

    PFS_FILTER_CALLBACKS FsFilterCallbacks;

    //
    //  Initialize the pre and post callbacks to NULL.  If
    //  we have valid callbacks, these output parameters will
    //  get set to the appropriate function pointers.
    //

    *PreOperationCallback = NULL;
    *PostOperationCallback = NULL;

    FsFilterCallbacks =
        DeviceObject->DriverObject->DriverExtension->FsFilterCallbacks;

    if (FsFilterCallbacks == NULL) {

        //
        //  This filter didn't register any callbacks,
        //  so just return and save switch logic that follows.
        //

        return;
    }

    //
    //  This device did register at least some callbacks, so see
    //  if there are callbacks for the current operation.
    //

    switch (Operation) {

    case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForSectionSynchronization )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForSectionSynchronization;

        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForSectionSynchronization)) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForSectionSynchronization;

        }

        break;

    case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForSectionSynchronization )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForSectionSynchronization;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForSectionSynchronization )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForSectionSynchronization;
        }

        break;

    case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForModifiedPageWriter )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForModifiedPageWriter;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForModifiedPageWriter )) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForModifiedPageWriter;
        }

        break;

    case FS_FILTER_RELEASE_FOR_MOD_WRITE:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForModifiedPageWriter )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForModifiedPageWriter;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForModifiedPageWriter )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForModifiedPageWriter;
        }

        break;

    case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForCcFlush )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForCcFlush;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForCcFlush )) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForCcFlush;
        }

         break;

    case FS_FILTER_RELEASE_FOR_CC_FLUSH:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForCcFlush )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForCcFlush;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForCcFlush )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForCcFlush;
        }

        break;

    default:

        ASSERT( FALSE );
        *PreOperationCallback = NULL;
        *PostOperationCallback = NULL;
    }
}

NTSTATUS
FsFilterPerformCallbacks (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN AllowFilterToFail,
    IN BOOLEAN AllowBaseFsToFail,
    OUT BOOLEAN *BaseFsFailedOp
    )

/*++

Routine Description:

    This routine calls all the file system filters that have registered
    to see the operation described by the FsFilterCtrl.  If this
    routine returns a successful Status, the operation should be
    passed onto the base file system.  If an error Status is returned,
    the caller is responsible for call FsFilterPerformCompletionCallbacks
    to unwind any post-operations that need to be called.

Arguments:

    FsFilterCtrl - The structure describing the control information
        needed to pass this operation to each filter registered to
        see this operation.

    AllowFilterToFail - TRUE if the filter is allowed to fail this
        operation, FALSE otherwise.

    AllowBaseFsToFail - TRUE if the base file system is allowed to fail this
        operation, FALSE otherwise.

    BaseFsFailedOp - Set to TRUE if the base file system failed
        this operation, FALSE, otherwise.

Return Value:

    STATUS_SUCCESS - All filters that are interested saw the operation
        and none failed this operation.

    STATUS_INSUFFICIENT_RESOURCES - There is not enough memory
        to allocate the completion node, so this operation
        is failing.

    Other error Status - Could be returned from a filter's
        pre-operation callback if it wants to fail this operation.
*/

{
    PFS_FILTER_CALLBACK_DATA Data = &(FsFilterCtrl->Data);
    PFS_FILTER_COMPLETION_STACK CompletionStack = &(FsFilterCtrl->CompletionStack);
    PFS_FILTER_CALLBACK PreOperationCallback;
    PFS_FILTER_COMPLETION_CALLBACK PostOperationCallback;
    PFS_FILTER_COMPLETION_NODE CompletionNode;
    PDEVICE_OBJECT CurrentDeviceObject;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN isFilter = TRUE;

    //
    //  We should never be in the scenario where a filter can fail the operation
    //  but the base file system cannot.
    //

    ASSERT( !(AllowFilterToFail && !AllowBaseFsToFail) );

    //
    //  Initialize output parameters if present.
    //

    *BaseFsFailedOp = FALSE;

    //
    //  As we iterate through the device objects, we use the local
    //  CurrentDeviceObject to iterate through the list because we want
    //  Data->DeviceObject to be set to the last device object when we are
    //  finished iterating.
    //

    CurrentDeviceObject = Data->DeviceObject;

    while (CurrentDeviceObject != NULL) {

        //
        //  First remember if this device object represents a filter or a file
        //  system.
        //

        if (CurrentDeviceObject->DeviceObjectExtension->AttachedTo != NULL) {

            isFilter = TRUE;

        } else {

            isFilter = FALSE;
        }

        //
        //  Now get the callbacks for this device object
        //

        Data->DeviceObject = CurrentDeviceObject;

        FsFilterGetCallbacks( Data->Operation,
                              Data->DeviceObject,
                              &PreOperationCallback,
                              &PostOperationCallback );

        //
        //  If this device object has either a callback or completion callback
        //  for this operation, allocate a CompletionNode for it.
        //

        if ((PreOperationCallback == NULL) && (PostOperationCallback == NULL)) {

            //
            //  This device object does not have any callbacks for this operation
            //  so move onto the next device.
            //

            CurrentDeviceObject = Data->DeviceObject->DeviceObjectExtension->AttachedTo;
            CompletionNode = NULL;
            continue;

        } else if (PostOperationCallback != NULL) {

            //
            //  Since there is a PostOperationCallback, we will need to allocate
            //  a CompletionNode for this device.
            //

            CompletionNode = PUSH_COMPLETION_NODE( CompletionStack );

            if (CompletionNode == NULL) {

                //
                //  This case shouldn't happen since we should ensure
                //  that our completion stack is large enough when
                //  we first saw this operation.
                //

                if (!AllowFilterToFail) {

                    //
                    //  We cannot fail this operation, so bugcheck.
                    //

                    KeBugCheckEx( FILE_SYSTEM, 0, 0, 0, 0 );
                }

                return STATUS_INSUFFICIENT_RESOURCES;

            } else {

                CompletionNode->DeviceObject = Data->DeviceObject;
                CompletionNode->FileObject = Data->FileObject;
                CompletionNode->CompletionContext = NULL;
                CompletionNode->CompletionCallback = PostOperationCallback;
            }

        } else {

            //
            //  We just have a pre-operation, so just set the CompletionNode to
            //  NULL.
            //

            CompletionNode = NULL;
        }

        if (PreOperationCallback != NULL) {

            if (CompletionNode == NULL) {

                Status = PreOperationCallback( Data,
                                               NULL );

            } else {

                Status = PreOperationCallback( Data,
                                               &(CompletionNode->CompletionContext) );
            }

            ASSERT( Status == STATUS_SUCCESS ||
                    Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY ||
                    !NT_SUCCESS( Status ) );

            if (Status == STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY) {

                //
                //  The filter/file system completed the operation successfully, so just
                //  return the completion status.
                //

                //
                //  If we allocated a completion node for this device,
                //  pop it now since we don't want to call it when we
                //  process the completions.
                //

                if (CompletionNode != NULL) {

                    POP_COMPLETION_NODE( CompletionStack );
                }

                return Status;

            } else if (!NT_SUCCESS( Status )) {

                //
                //  We hit an error, see if it is allowable to fail.
                //

                if (!AllowFilterToFail && isFilter) {

                    //
                    //  This device object represents a filter and filters
                    //  are not allowed to fail this operation.  Mask the
                    //  error and continue processing.
                    //
                    //  In DBG builds, we will print out an error message to
                    //  notify the filter writer.
                    //

                    KdPrint(( "FS FILTER: FsFilterPerformPrecallbacks -- filter failed operation but this operation is marked to disallow failure, so ignoring.\n" ));

                    Status = STATUS_SUCCESS;

                } else if (!AllowBaseFsToFail && !isFilter) {

                    //
                    //  This device object represents a base file system and
                    //  base file systems are not allowed to fail this
                    //  operation.  Mask the error and continue processing.
                    //
                    //  In DBG builds, we will print out an error message to
                    //  notify the file system writer.
                    //

                    KdPrint(( "FS FILTER: FsFilterPerformPrecallbacks -- base file system failed operation but this operation is marked to disallow failure, so ignoring.\n" ));

                    Status = STATUS_SUCCESS;

                } else {

                    //
                    //  This device is allowed to fail this operation, therefore
                    //  return the error.
                    //

                    if (!isFilter) {

                        *BaseFsFailedOp = TRUE;

                    }

                    //
                    //  If we allocated a completion node for this device,
                    //  pop it now since we don't want to call it when we
                    //  process the completions.
                    //

                    if (CompletionNode != NULL) {

                        POP_COMPLETION_NODE( CompletionStack );
                    }

                    return Status;
                }
            }

        } else {

            //
            //  Don't have to do anything here because the completionNode
            //  is already initialize appropriately.  We will process
            //  the PostOperationCallback later in this routine.
            //

            NOTHING;
        }

        if (CurrentDeviceObject != Data->DeviceObject) {

            //
            //  We change device stacks, therefore we need to mark this FsFilterCtrl
            //  structure so that we reevaluate the base file system parameters
            //  when calling through the legacy FastIO path.
            //

            SetFlag( FsFilterCtrl->Flags, FS_FILTER_CHANGED_DEVICE_STACKS );
            CurrentDeviceObject = Data->DeviceObject;

        } else {

            //
            //  We didn't change stacks.
            //

            //
            //  See if this is the base file system.  If it is, we want to make
            //  sure that we don't call the base file system's post-operation
            //  callback because this like the base file system is completing
            //  this operation.  In this case, we will pop the completion node
            //  if one was allocated.
            //

            if (!isFilter && CompletionNode != NULL) {

                POP_COMPLETION_NODE( CompletionStack );
            }

            //
            //  Now, iterate down the device object chain.
            //

            CurrentDeviceObject = CurrentDeviceObject->DeviceObjectExtension->AttachedTo;
        }
    }

    return Status;
}

VOID
FsFilterPerformCompletionCallbacks(
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN NTSTATUS OperationStatus
    )
{
    PFS_FILTER_CALLBACK_DATA Data = &(FsFilterCtrl->Data);
    PFS_FILTER_COMPLETION_STACK CompletionStack = &(FsFilterCtrl->CompletionStack);
    PFS_FILTER_COMPLETION_NODE CompletionNode;

    while (CompletionStack->NextStackPosition > 0) {

        CompletionNode = GET_COMPLETION_NODE( CompletionStack );

        ASSERT( CompletionNode != NULL );

        //
        //  Call the completion callback that the device object registered.
        //

        Data->DeviceObject = CompletionNode->DeviceObject;
        Data->FileObject = CompletionNode->FileObject;

        (CompletionNode->CompletionCallback)( Data,
                                              OperationStatus,
                                              CompletionNode->CompletionContext );

        //
        // Move onto the next CompletionNode.
        //

        POP_COMPLETION_NODE( CompletionStack );
    }
}

const LARGE_INTEGER FsRtlHalfSecond = {(ULONG)(-5 * 100 * 1000 * 10), -1};

NTKERNELAPI
NTSTATUS
FsRtlCreateSectionForDataScan (
    OUT PHANDLE SectionHandle,
    OUT PVOID *SectionObject,
    OUT PLARGE_INTEGER SectionFileSize OPTIONAL,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine creates a section for given a file object.  It returns the
    section object, the handle which references the section object, and
    (optionally) the size of the file when it was mapped if the section was
    able to be created successfully.

    This routine functions like NtCreateSection except that it takes a
    file object as the parameter to describe which stream to use to back the
    file.  It properly synchronizes the section creation with other file system
    operations.

    NOTE: At this point, this routine can only be used to create a DATA section.
        In the future, this routine may change to support that functionality.

Arguments:

    SectionHandle - Set to the handle created to represent the section returned.

    SectionObject - Set to the section object created.

    SectionFileSize - If non-NULL, set to the file's size at the time the
        section was created.

    FileObject - The file object representing the stream to back this section.

    DesiredAccess - The desired types of access for the section.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    MaximumSize - Supplies the maximum size of the section in bytes.
                  This value is rounded up to the host page size and
                  specifies the size of the section (page file
                  backed section) or the maximum size to which a
                  file can be extended or mapped (file backed
                  section).
        NOTE: This value is ignored for now since we will be passing a file object
        to MmCreateSection (Mm will query the file system itself to find the size).

    SectionPageProtection - Supplies the protection to place on each page
                            in the section.  One of PAGE_READ, PAGE_READWRITE,
                            PAGE_EXECUTE, or PAGE_WRITECOPY and, optionally,
                            PAGE_NOCACHE or PAGE_WRITECOMBINE
                            may be specified.

    AllocationAttributes - Supplies a set of flags that describe the
                           allocation attributes of the section.
        NOTE: This routine only supports a subset of AllocationAttributes.  For
            the complete list of AllocationAttributes, see NtCreateSection.

        AllocationAttributes Flags

        SEC_COMMIT - All pages of the section are set to the commit state.

        SEC_FILE - The file specified by the file handle is a mapped
                   file.  If a file handle is supplied and neither
                   SEC_IMAGE or SEC_FILE is supplied, SEC_FILE is
                   assumed.

    Flags - Reserved for future use.

Return Value:

    Returns STATUS_SUCCESS if the section could be created, or the appropriate
    error otherwise.

    If this routine is successful, the caller must close the SectionHandle
    and dereference the SectionObject when it is done using these values.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER FileSize;
    PVOID Object = NULL;
    HANDLE Handle = NULL;
    ULONG RetryCount = 0;

    UNREFERENCED_PARAMETER( MaximumSize );
    UNREFERENCED_PARAMETER( Flags );

    //
    //  At this point, there are some options which this API does not support.
    //  If those options are passed in, FAIL the operation here.
    //
    //  For SectionPageProtection, one of these flags must be set:
    //      PAGE_READONLY
    //      PAGE_READWRITE
    //
    //  For AllocationAttributes, only these flag combinations are allowed:
    //      SEC_COMMIT must be set
    //      SEC_FILE is allowed to be set (assumed otherwise)
    //

    if (FlagOn(SectionPageProtection, ~(PAGE_READONLY | PAGE_READWRITE)) ||
        (SectionPageProtection == 0)) {

        return STATUS_INVALID_PARAMETER_8;
    }

    if ((!FlagOn( AllocationAttributes, SEC_COMMIT )) ||
        FlagOn( AllocationAttributes, ~(SEC_COMMIT | SEC_FILE) )) {

        return STATUS_INVALID_PARAMETER_9;
    }

    //
    //  We need to acquire the file exclusive to avoid deadlocks and grab its
    //  size.  Note that it can't change while we have its resource exclusive.
    //
    //  MmCreateSection() will normally take these steps, but only if a file
    //  handle is passed in, which we don't have.
    //

    ASSERT( IoGetTopLevelIrp() == NULL );

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    FsRtlEnterFileSystem();
    Status = FsRtlAcquireToCreateMappedSection( FileObject,
                                                SectionPageProtection );

    if (!NT_SUCCESS( Status )) {

        FsRtlExitFileSystem();
        IoSetTopLevelIrp( NULL );
        return Status;
    }

    //
    //  Get the file size.  Note that FsRtlGetFileSize() does *not* acquire the
    //  file object lock for synchronous file objects, which is important as
    //  we already own the file system resource, and trying now to acquire the
    //  file object lock would violate locking order and lead to deadlocks.
    //

    Status = FsRtlGetFileSize( FileObject, &FileSize );

    if (NT_SUCCESS(Status)) {

        if (FileSize.QuadPart == 0) {

            //
            //  If the file is of 0 length, we won't bother creating a section.
            //

            Status = STATUS_END_OF_FILE;

        } else {

Retry:
            //
            //  We create a section object from the now valid file object.  We
            //  need to loop here in case we hit a transient lock conflict with
            //  the file system.
            //

            Status = MmCreateSection( &Object,
                                      DesiredAccess,
                                      ObjectAttributes,
                                      &FileSize,
                                      SectionPageProtection,
                                      AllocationAttributes,
                                      NULL,
                                      FileObject );

            ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

            if ((Status == STATUS_FILE_LOCK_CONFLICT) &&
                (RetryCount < 3)) {

                //
                // The file system may have prevented this from working
                // due to log file flushing.  Delay and try again.
                //

                RetryCount += 1;

                KeDelayExecutionThread (KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER)&FsRtlHalfSecond);
                goto Retry;
            }
        }
    }

    //
    //  Now release the resource.
    //

    FsRtlReleaseFile( FileObject );
    FsRtlExitFileSystem();

    IoSetTopLevelIrp( NULL );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Zero the end of the last page and mark the stream as having a mapped
    //  section.
    //

    CcZeroEndOfLastPage( FileObject );

    //
    //  Now we insert this section in the process handle table, which will
    //  yield a section handle that is useable by the user mode service,
    //  and thus suitable for a call to MapViewOfFile().
    //
    //  Before inserting the object though, we reference it an extra time
    //  so that even a service bug cannot make SectionObject invalid by
    //  closing a random handle.
    //

    ObReferenceObject( Object );

    Status = ObInsertObject( Object,
                             NULL,
                             DesiredAccess,
                             0,
                             (PVOID *)NULL,
                             &Handle);

    if (NT_SUCCESS( Status )) {

        *SectionHandle = Handle;
        *SectionObject = Object;

        if (ARGUMENT_PRESENT( SectionFileSize )) {

            SectionFileSize->QuadPart = FileSize.QuadPart;
        }

    } else {

        //
        //  Note if the insertion fails, Ob dereferences the section object
        //  once for us, so we only need to remove the reference we added.
        //

        ObDereferenceObject( Object );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\fsrtlp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FsRtlP.h

Abstract:

    This module defines private part of the File System Rtl component

--*/

#ifndef _FSRTLP_
#define _FSRTLP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression

#include <ntos.h>
#include <FsRtl.h>
#include <NtDdFt.h>
#include <zwapi.h>

#define FsRtlAllocatePool(PoolType, NumberOfBytes )                \
    ExAllocatePoolWithTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                          NumberOfBytes,                                      \
                          'trSF')


#define FsRtlAllocatePoolWithQuota(PoolType, NumberOfBytes )           \
    ExAllocatePoolWithQuotaTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                               NumberOfBytes,                                 \
                               'trSF')

#define FsRtlpAllocatePool(a,b)  FsRtlAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)

//
//  The global FsRtl debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bugcheck)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000      NotifyChange routines
//      0x08000000      Oplock routines
//
//      0x10000000      Name routines
//      0x20000000      FileLock routines
//      0x40000000      Vmcb routines
//      0x80000000      Mcb routines
//

//
//  Debug trace support
//

#ifdef FSRTLDBG

extern LONG FsRtlDebugTraceLevel;
extern LONG FsRtlDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                        \
    LONG _i;                                                  \
    if (((LEVEL) == 0) || (FsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        if ((INDENT) < 0) {                                   \
            FsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
        if (FsRtlDebugTraceIndent < 0) {                      \
            FsRtlDebugTraceIndent = 0;                        \
        }                                                     \
        for (_i=0; _i<FsRtlDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                     \
        }                                                     \
        DbgPrint(X,Y);                                         \
        if ((INDENT) > 0) {                                   \
            FsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
    }                                                         \
}

#define DebugDump(STR,LEVEL,PTR) {                            \
    ULONG _i;                                                 \
    VOID FsRtlDump();                                         \
    if (((LEVEL) == 0) || (FsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        DbgPrint(STR);                                         \
        if (PTR != NULL) {FsRtlDump(PTR);}                    \
        DbgBreakPoint();                                      \
    }                                                         \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // FSRTLDBG


//
//  Miscellaneous support routines
//

VOID
FsRtlInitializeFileLocks (
    VOID
    );

VOID
FsRtlInitializeLargeMcbs (
    VOID
    );

VOID
FsRtlInitializeTunnels(
    VOID
    );

NTSTATUS
FsRtlInitializeWorkerThread (
    VOID
    );

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))

#define SetFlag(F,SF) { \
    (F) |= (SF);        \
}

#define ClearFlag(F,SF) { \
    (F) &= ~(SF);         \
}

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 1) & -2) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 3) & -4) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 7) & -8) \
    )

//
//  This macro takes a ulong and returns its value rounded up to a sector
//  boundary
//

#define SectorAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 511) & -512) \
    )

//
//  This macro takes a number of bytes and returns the number of sectors
//  required to contain that many bytes, i.e., it sector aligns and divides
//  by the size of a sector.
//

#define SectorsFromBytes(bytes) ( \
    ((bytes) + 511) / 512         \
    )

//
//  This macro takes a number of sectors and returns the number of bytes
//  contained in that many sectors.
//

#define BytesFromSectors(sectors) ( \
    (sectors) * 512                 \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#define GET_FAST_IO_DISPATCH(DevObj) \
    ((DevObj)->DriverObject->FastIoDispatch)

#define GET_FS_FILTER_CALLBACKS(DevObj) \
    ((DevObj)->DriverObject->DriverExtension->FsFilterCallbacks)
    
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))

#define VALID_FS_FILTER_CALLBACK_HANDLER(FsFilterCallbackPtr, FieldName) \
    (((FsFilterCallbackPtr) != NULL) && \
     (((FsFilterCallbackPtr)->SizeOfFsFilterCallbacks) >= \
      (FIELD_OFFSET(FS_FILTER_CALLBACKS, FieldName) + sizeof(VOID *))) && \
     ((FsFilterCallbackPtr)->FieldName != NULL))

#define FSRTL_FILTER_MEMORY_TAG    'gmSF'

typedef struct _FS_FILTER_COMPLETION_NODE {

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVOID CompletionContext;
    PFS_FILTER_COMPLETION_CALLBACK CompletionCallback;
    
} FS_FILTER_COMPLETION_NODE, *PFS_FILTER_COMPLETION_NODE;

#define FS_FILTER_DEFAULT_STACK_SIZE    15

typedef struct _FS_FILTER_COMPLETION_STACK {

    USHORT StackLength;
    USHORT NextStackPosition;
    PFS_FILTER_COMPLETION_NODE Stack;
    FS_FILTER_COMPLETION_NODE DefaultStack[FS_FILTER_DEFAULT_STACK_SIZE];
    
} FS_FILTER_COMPLETION_STACK, *PFS_FILTER_COMPLETION_STACK;

typedef struct _FS_FILTER_CTRL {

    FS_FILTER_CALLBACK_DATA Data;
    
    ULONG Flags;
    ULONG Reserved;
    
    FS_FILTER_COMPLETION_STACK CompletionStack;
    
} FS_FILTER_CTRL, *PFS_FILTER_CTRL;

//
//  Flag values for FS_FILTER_CTRL
//

#define FS_FILTER_ALLOCATED_COMPLETION_STACK    0x00000001
#define FS_FILTER_USED_RESERVE_POOL             0x00000002
#define FS_FILTER_CHANGED_DEVICE_STACKS         0x00000004

NTSTATUS
FsFilterInit(
    );

NTSTATUS
FsFilterAllocateCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN CanFail,
    OUT PULONG AllocationSize
    );

VOID
FsFilterFreeCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl
    );

NTSTATUS
FsFilterCtrlInit (
    IN OUT PFS_FILTER_CTRL FsFilterCtrl,
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT BaseFsDeviceObject,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN CanFail
    );

VOID
FsFilterCtrlFree (
    IN PFS_FILTER_CTRL FsFilterCtrl
    );

#define PUSH_COMPLETION_NODE( completionStack ) \
    (((completionStack)->NextStackPosition < (completionStack)->StackLength ) ? \
        &(completionStack)->Stack[(completionStack)->NextStackPosition++] : \
        (ASSERT( FALSE ), NULL) )

#define POP_COMPLETION_NODE( completionStack ) \
    (ASSERT((completionStack)->NextStackPosition > 0), \
     ((completionStack)->NextStackPosition--))

#define GET_COMPLETION_NODE( completionStack ) \
    (ASSERT((completionStack)->NextStackPosition > 0),\
     (&(completionStack)->Stack[(completionStack)->NextStackPosition-1]))

#define FS_FILTER_HAVE_COMPLETIONS( fsFilterCtrl ) \
    ((fsFilterCtrl)->CompletionStack.NextStackPosition > 0)

VOID
FsFilterGetCallbacks (
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PFS_FILTER_CALLBACK *PreOperationCallback,
    OUT PFS_FILTER_COMPLETION_CALLBACK *PostOperationCallback
    );

NTSTATUS
FsFilterPerformCallbacks (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN AllowFilterToFail,
    IN BOOLEAN AllowBaseFsToFail,
    OUT BOOLEAN *BaseFsFailedOp
    );

VOID
FsFilterPerformCompletionCallbacks(
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN NTSTATUS OperationStatus
    );

#endif // _FSRTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\filtrctx.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FiltrCtx.c

Abstract:

    This module provides three routines that allow filesystem filter drivers
    to associate state with FILE_OBJECTs -- for filesystems which support
    an extended FSRTL_COMMON_HEADER with FsContext.

    These routines depend on fields (FastMutext and FilterContexts)
    added at the end of FSRTL_COMMON_HEADER in NT 5.0.

    Filesystems should set FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS if
    these new fields are supported.  They must also initialize the mutex
    and list head.

    Filter drivers must use a common header for the context they wish to
    associate with a file object:

        FSRTL_FILTER_CONTEXT:
                LIST_ENTRY  Links;
                PVOID       OwnerId;
                PVOID       InstanceId;

    The OwnerId is a bit pattern unique to each filter driver
    (e.g. the device object).

    The InstanceId is used to specify a particular instance of the context
    data owned by a filter driver (e.g. the file object).

--*/

#include "FsRtlP.h"

#define MySearchList(pHdr, Ptr) \
    for ( Ptr = (pHdr)->Flink;  Ptr != (pHdr);  Ptr = Ptr->Flink )


//
//  The rest of the routines are not marked pageable so they can be called
//  during the paging path
//

NTKERNELAPI
VOID
FsRtlTeardownFilterContexts (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader
  );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlTeardownPerStreamContexts)
#pragma alloc_text(PAGE, FsRtlTeardownFilterContexts)
#pragma alloc_text(PAGE, FsRtlPTeardownPerFileObjectContexts)
#endif


//===========================================================================
//                  Handles Stream Contexts
//===========================================================================

NTKERNELAPI
NTSTATUS
FsRtlInsertPerStreamContext (
    __in PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
    __in PFSRTL_PER_STREAM_CONTEXT Ptr
  )
/*++

Routine Description:

    This routine associates filter driver context with a stream.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    Ptr - Pointer to the filter-specific context structure.
        The common header fields OwnerId and InstanceId should
        be filled in by the filter driver before calling.

Return Value:

    STATUS_SUCCESS - operation succeeded.

    STATUS_INVALID_DEVICE_REQUEST - underlying filesystem does not support
        filter contexts.

--*/

{
    if (!AdvFcbHeader || 
        !FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))
    {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);

    InsertHeadList(&AdvFcbHeader->FilterContexts, &Ptr->Links);

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return STATUS_SUCCESS;
}


NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlLookupPerStreamContextInternal (
    __in PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
  )
/*++

Routine Description:

    This routine lookups filter driver context associated with a stream.

    The macro FsRtlLookupFilterContext should be used instead of calling
    this routine directly.  The macro optimizes for the common case
    of an empty list.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
    filter context will be returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    ASSERT(AdvFcbHeader);
    ASSERT(FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS));

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);
    rtnCtx = NULL;

    //
    // Use different loops depending on whether we are comparing both Ids or not.
    //

    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId && ctx->InstanceId == InstanceId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&AdvFcbHeader->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_STREAM_CONTEXT)AdvFcbHeader->FilterContexts.Flink;
    }

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return rtnCtx;
}


NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlRemovePerStreamContext (
    __in PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
  )
/*++

Routine Description:

    This routine deletes filter driver context associated with a stream.

    FsRtlRemoveFilterContext functions identically to FsRtlLookupFilterContext,
    except that the returned context has been removed from the list.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is removed and returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
    filter context will be removed and returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    if (!AdvFcbHeader ||
        !FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))
    {

        return NULL;
    }

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);
    rtnCtx = NULL;

  // Use different loops depending on whether we are comparing both Ids or not.
    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId && ctx->InstanceId == InstanceId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&AdvFcbHeader->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_STREAM_CONTEXT)AdvFcbHeader->FilterContexts.Flink;
    }

    if (rtnCtx) {
        RemoveEntryList(&rtnCtx->Links);   // remove the matched entry
    }

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return rtnCtx;
}


NTKERNELAPI
VOID
FsRtlTeardownPerStreamContexts (
    __in PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader
    )
/*++

Routine Description:

    This routine is called by filesystems to free the filter contexts
    associated with an FSRTL_COMMON_FCB_HEADER by calling the FreeCallback
    routine for each FilterContext.

Arguments:

    FilterContexts - the address of the FilterContexts field within
        the FSRTL_COMMON_FCB_HEADER of the structure being torn down
        by the filesystem.

Return Value:

    None.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PLIST_ENTRY ptr;
    BOOLEAN lockHeld;

    //
    //  Acquire the lock because someone could be trying to free this
    //  entry while we are trying to free it.
    //

    ExAcquireFastMutex( AdvFcbHeader->FastMutex );
    lockHeld = TRUE;

    try {

        while (!IsListEmpty( &AdvFcbHeader->FilterContexts )) {

            //
            //  Unlink the top entry then release the lock.  We must
            //  release the lock before calling the use or their could
            //  be potential locking order deadlocks.
            //

            ptr = RemoveHeadList( &AdvFcbHeader->FilterContexts );

            ExReleaseFastMutex(AdvFcbHeader->FastMutex);
            lockHeld = FALSE;

            //
            //  Call filter to free this entry
            //

            ctx = CONTAINING_RECORD( ptr, FSRTL_PER_STREAM_CONTEXT, Links );
            ASSERT(ctx->FreeCallback);

            (*ctx->FreeCallback)( ctx );

            //
            //  re-get the lock
            //

            ExAcquireFastMutex( AdvFcbHeader->FastMutex );
            lockHeld = TRUE;
        }

    } finally {

        if (lockHeld) {

            ExReleaseFastMutex( AdvFcbHeader->FastMutex );
        }
    }
}


//===========================================================================
//                  Handles FileObject Contexts
//===========================================================================

//
//  Internal structure used to manage the Per FileObject Contexts.
//

typedef struct _PER_FILEOBJECT_CTXCTRL {

    //
    //  This is a pointer to a Fast Mutex which may be used to
    //  properly synchronize access to the FsRtl header.  The
    //  Fast Mutex must be nonpaged.
    //

    FAST_MUTEX FastMutex;

    //
    // This is a pointer to a list of context structures belonging to
    // filesystem filter drivers that are linked above the filesystem.
    // Each structure is headed by FSRTL_FILTER_CONTEXT.
    //

    LIST_ENTRY FilterContexts;

} PER_FILEOBJECT_CTXCTRL, *PPER_FILEOBJECT_CTXCTRL;


NTKERNELAPI
NTSTATUS
FsRtlInsertPerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in PFSRTL_PER_FILEOBJECT_CONTEXT Ptr
    )
/*++

Routine Description:

    This routine associates a context with a file object.

Arguments:

    FileObject - Specifies the file object of interest.

    Ptr - Pointer to the filter-specific context structure.
        The common header fields OwnerId and InstanceId should
        be filled in by the filter driver before calling.

Return Value:

    STATUS_SUCCESS - operation succeeded.

    STATUS_INVALID_DEVICE_REQUEST - underlying filesystem does not support
        filter contexts.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    NTSTATUS status;

    //
    //  Return if no file object
    //

    if (NULL == FileObject) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!FsRtlSupportsPerFileObjectContexts(FileObject)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        //
        //  There is not a control structure, allocate and initialize one
        //

        ctxCtrl = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof(PER_FILEOBJECT_CTXCTRL),
                                         'XCOF' );
        if (NULL == ctxCtrl) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ExInitializeFastMutex( &ctxCtrl->FastMutex );
        InitializeListHead( &ctxCtrl->FilterContexts );

        //
        //  Insert into the file object extension
        //

        status = IoChangeFileObjectFilterContext( FileObject,
                                                  ctxCtrl,
                                                  TRUE );

        if (!NT_SUCCESS(status)) {

            //
            //  If this operation fails it is because someone else inserted the
            //  entry at the same time.  In this case free the memory we
            //  allocated and re-get the current value.
            //

            ExFreePool( ctxCtrl );

            ctxCtrl = IoGetFileObjectFilterContext( FileObject );

            if (NULL == ctxCtrl) {

                //
                //  This should never actually happen.  If it does it means
                //  someone allocated and then freed a context very quickly.
                //

                ASSERT(!"This operation should not have failed");
                return STATUS_UNSUCCESSFUL;
            }
        }
    }

    ExAcquireFastMutex( &ctxCtrl->FastMutex );

    InsertHeadList( &ctxCtrl->FilterContexts, &Ptr->Links );

    ExReleaseFastMutex( &ctxCtrl->FastMutex );

    return STATUS_SUCCESS;
}


NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlLookupPerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
    )
/*++

Routine Description:

    This routine lookups contexts associated with a file object.

Arguments:

    FileObject - Specifies the file object of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
        filter context will be returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    PFSRTL_PER_FILEOBJECT_CONTEXT ctx;
    PFSRTL_PER_FILEOBJECT_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    //
    //  Return if no FileObjecty
    //

    if (NULL == FileObject) {

        return NULL;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        return NULL;
    }

    rtnCtx = NULL;
    ExAcquireFastMutex( &ctxCtrl->FastMutex );

    //
    //  Use different loops depending on whether we are comparing both Ids or not.
    //

    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if ((ctx->OwnerId == OwnerId) && (ctx->InstanceId == InstanceId)) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&ctxCtrl->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_FILEOBJECT_CONTEXT) ctxCtrl->FilterContexts.Flink;
    }

    ExReleaseFastMutex(&ctxCtrl->FastMutex);

    return rtnCtx;
}


NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlRemovePerFileObjectContext (
    __in PFILE_OBJECT FileObject,
    __in_opt PVOID OwnerId,
    __in_opt PVOID InstanceId
  )
/*++

Routine Description:

    This routine deletes contexts associated with a file object

    Filter drivers must explicitly remove all context they associate with
    a file object (otherwise the underlying filesystem will BugCheck at close).
    This should be done at IRP_CLOSE time.

    FsRtlRemoveFilterContext functions identically to FsRtlLookupFilterContext,
    except that the returned context has been removed from the list.

Arguments:

    FileObject - Specifies the file object of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is removed and returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
        filter context will be removed and returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    PFSRTL_PER_FILEOBJECT_CONTEXT ctx;
    PFSRTL_PER_FILEOBJECT_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    //
    //  Return if no file object
    //

    if (NULL == FileObject) {

        return NULL;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        return NULL;
    }

    rtnCtx = NULL;

    ExAcquireFastMutex( &ctxCtrl->FastMutex );

  // Use different loops depending on whether we are comparing both Ids or not.
    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if ((ctx->OwnerId == OwnerId) && (ctx->InstanceId == InstanceId)) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&ctxCtrl->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_FILEOBJECT_CONTEXT)ctxCtrl->FilterContexts.Flink;
    }

    if (rtnCtx) {

        RemoveEntryList(&rtnCtx->Links);   // remove the matched entry
    }

    ExReleaseFastMutex( &ctxCtrl->FastMutex );
    return rtnCtx;
}


VOID
FsRtlPTeardownPerFileObjectContexts (
    __in PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine is called by the IOManager when a fileObject is being 
    deleted.  This gives us a chance to delete our file object control
    structure.

Arguments:

    FileObject - The fileObject being deleted

Return Value:

    None.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    NTSTATUS status;

    ASSERT(FileObject != NULL);

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL != ctxCtrl) {

        status = IoChangeFileObjectFilterContext( FileObject,
                                                  ctxCtrl,
                                                  FALSE );

        ASSERT(STATUS_SUCCESS == status);
        ASSERT(IsListEmpty( &ctxCtrl->FilterContexts));

        ExFreePool( ctxCtrl );
    }
}


NTKERNELAPI
LOGICAL
FsRtlIsPagingFile (
    __in PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine will return TRUE if the give file object is for a
    paging file.  It returns FALSE otherwise

Arguments:

    FileObject - The file object to test

Return Value:

    TRUE - if paging file
    FALSE - if not

--*/

{
    return MmIsFileObjectAPagingFile( FileObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\filter.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Filter.c

Abstract:

    The Exception filter is used by the file system and cache manager
    to handle error recovery.  The basic idea is to have the top level
    file system entry points (i.e., the FSD entry points and FSP dispatch
    loop) have a try-except around their code, and then whenever the
    file system or cache manager reach an error case they raise an
    appropriate status.  Then the exception handler catches the exception
    and can either complete the request, send it off to the fsp, verify the
    volume, or bugcheck.  We only bugcheck if the raised exception is
    unexpected (i.e., unhandled).

    This module provides two routines for filtering out exceptions.  The
    first routine is used to normalize status values to be one of the
    value handled by the filter.  That way if we get an exception not handled
    by the filter then we know that the system is in real trouble and we
    just bugcheck the machine.  The second routine is used to ask if
    a status value is within the set of values handled by the filter.

    The value of status handled by this filter are listed in the routine
    FsRtlIsNtstatusExpected.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


NTSTATUS
FsRtlNormalizeNtstatus (
    __in NTSTATUS Exception,
    __in NTSTATUS GenericException
    )

/*++

Routine Description:

    This routine is used to normalize an NTSTATUS into a status
    that is handled by the file system's top level exception handlers.

Arguments:

    Exception - Supplies the exception being normalized

    GenericException - Supplies a second exception to translate to
        if the first exception is not within the set of exceptions
        handled by the filter

Return Value:

    NTSTATUS - Returns Exception if the value is already handled
        by the filter, and GenericException otherwise.

--*/

{
    return (FsRtlIsNtstatusExpected(Exception) ? Exception : GenericException);
}


BOOLEAN
FsRtlIsNtstatusExpected (
    __in NTSTATUS Exception
    )

/*++

Routine Description:

    This routine is used to decide if a status is within the set of values
    handled by the exception filter.

Arguments:

    Exception - Supplies the exception being queried

Return Value:

    BOOLEAN - Returns TRUE if the value is handled by the filter, and
        FALSE otherwise.

--*/

{
    switch (Exception) {

    case STATUS_DATATYPE_MISALIGNMENT:
    case STATUS_ACCESS_VIOLATION:
    case STATUS_ILLEGAL_INSTRUCTION:
    case STATUS_INSTRUCTION_MISALIGNMENT:

        return FALSE;

    default:

        return TRUE;
    }
}


#undef FsRtlAllocatePool

__bcount(NumberOfBytes)
PVOID
FsRtlAllocatePool (
    __in POOL_TYPE PoolType,
    __in ULONG NumberOfBytes
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool.  It either
    returns a non null pointer to the newly allocated pool or it raises
    a status of insufficient resources.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithTag( PoolType, NumberOfBytes, 'trSF')) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}

#undef FsRtlAllocatePoolWithQuota


__bcount(NumberOfBytes)
PVOID
FsRtlAllocatePoolWithQuota (
    __in POOL_TYPE PoolType,
    __in ULONG NumberOfBytes
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with quota.  It
    either returns a non null pointer to the newly allocated pool or it raises
    a status of insufficient resources.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithQuotaTag ( PoolType, NumberOfBytes, 'trSF')) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


#undef FsRtlAllocatePoolWithTag

__bcount(NumberOfBytes)
PVOID
FsRtlAllocatePoolWithTag (
    __in POOL_TYPE PoolType,
    __in ULONG NumberOfBytes,
    __in ULONG Tag
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with a tag.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

    Tag - Supplies the tag for the pool block

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithTag( PoolType, NumberOfBytes, Tag)) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


#undef FsRtlAllocatePoolWithQuotaTag

__bcount(NumberOfBytes)
PVOID
FsRtlAllocatePoolWithQuotaTag (
    __in POOL_TYPE PoolType,
    __in ULONG NumberOfBytes,
    __in ULONG Tag
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with a quota tag.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

    Tag - Supplies the tag for the pool block

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithQuotaTag( PoolType, NumberOfBytes, Tag)) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


BOOLEAN
FsRtlIsTotalDeviceFailure(
    __in NTSTATUS Status
    )

/*++

Routine Description:

    This routine is given an NTSTATUS value and make a determination as to
    if this value indicates that the complete device has failed and therefore
    should no longer be used, or if the failure is one that indicates that
    continued use of the device is ok (i.e. a sector failure).

Arguments:

    Status - the NTSTATUS value to test.

Return Value:

    TRUE  - The status value given is believed to be a fatal device error.
    FALSE - The status value given is believed to be a sector failure, but not
            a complete device failure.
--*/

{
    if (NT_SUCCESS(Status)) {

        //
        // All warning and informational errors will be resolved here.
        //

        return FALSE;
    }

    switch (Status) {
    case STATUS_CRC_ERROR:
    case STATUS_DEVICE_DATA_ERROR:
        return FALSE;
    default:
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\filelock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FileLock.c

Abstract:

    The file lock package provides a set of routines that allow the
    caller to handle byte range file lock requests.  A variable of
    type FILE_LOCK is needed for every file with byte range locking.
    The package provides routines to set and clear locks, and to
    test for read or write access to a file with byte range locks.

    The main idea of the package is to have the file system initialize
    a FILE_LOCK variable for every data file as its opened, and then
    to simply call a file lock processing routine to handle all IRP's
    with a major function code of LOCK_CONTROL.  The package is responsible
    for keeping track of locks and for completing the LOCK_CONTROL IRPS.
    When processing a read or write request the file system can then call
    two query routines to check for access.

    Most of the code for processing IRPS and checking for access use
    paged pool and can encounter a page fault, therefore the check routines
    cannot be called at DPC level.  To help servers that do call the file
    system to do read/write operations at DPC level there is a additional
    routine that simply checks for the existence of a lock on a file and
    can be run at DPC level.

    Concurrent access to the FILE_LOCK variable must be controlled by the
    caller.

    The functions provided in this package are as follows:

      o  FsRtlInitializeFileLock - Initialize a new FILE_LOCK structure.

      o  FsRtlUninitializeFileLock - Uninitialize an existing FILE_LOCK
         structure.

      o  FsRtlProcessFileLock - Process an IRP whose major function code
         is LOCK_CONTROL.

      o  FsRtlCheckLockForReadAccess - Check for read access to a range
         of bytes in a file given an IRP.

      o  FsRtlCheckLockForWriteAccess - Check for write access to a range
         of bytes in a file given an IRP.

      o  FsRtlAreThereCurrentFileLocks - Check if there are any locks
         currently assigned to a file.

      o  FsRtlGetNextFileLock - This procedure enumerates the current locks
         of a file lock variable.

      o  FsRtlFastCheckLockForRead - Check for read access to a range of
         bytes in a file given separate parameters.

      o  FsRtlFastCheckLockForWrite - Check for write access to a range of
         bytes in a file given separate parameters.

      o  FsRtlFastLock - A fast non-Irp based way to get a lock

      o  FsRtlFastUnlockSingle - A fast non-Irp based way to release a single
         lock

      o  FsRtlFastUnlockAll - A fast non-Irp based way to release all locks
         held by a file object.

      o  FsRtlFastUnlockAllByKey - A fast non-Irp based way to release all
         locks held by a file object that match a key.

--*/

#include "FsRtlP.h"

//
//  Local constants
//

//
//  Local debug trace level
//

#define Dbg                 (0x20000000)

//
//  YA definition of INLINE
//

#ifndef INLINE
#define INLINE __inline
#endif

#define TAG_EXCLUSIVE_LOCK  'xeLF'
#define TAG_FILE_LOCK       'lfLF'
#define TAG_LOCK_INFO       'ilLF'
#define TAG_LOCKTREE_NODE   'nlLF'
#define TAG_SHARED_LOCK     'hsLF'
#define TAG_WAITING_LOCK    'lwLF'

//
//  Globals
//

//
//  This mutex synchronizes threads competing to initialize file lock structures.
//

KGUARDED_MUTEX FsRtlCreateLockInfo;

//
//  This spinlock resolves the race between teardown of a file's lock info and
//  cancellation of waiting locks for that file.  We must always be able to save
//  a cancelled IRP for the cancelling thread.
//

KSPIN_LOCK FsRtlFileLockCancelCollideLock;

SINGLE_LIST_ENTRY FsRtlFileLockCancelCollideList;

//
//  Lookaside lists
//
//  Here is a good place to note why this is still nonpaged.  We need to be able
//  to cancel lock IRPs at DPC, and the ripple effects of this (esp. granting waiting
//  locks and synchronizing the waiting list) implies some unfortunate realities.
//
//  This should be reinvestigated post NT 5.0.
//

NPAGED_LOOKASIDE_LIST FsRtlSharedLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlExclusiveLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlWaitingLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlLockTreeNodeLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlLockInfoLookasideList;

PAGED_LOOKASIDE_LIST FsRtlFileLockLookasideList;


//
//  Local structures
//

/*++

    Some of the decisions made regarding the internal datastructures may not be clear,
    so I should discuss the evolution of this design.

    The original file lock implementation was a single linked list, extended in the MP
    case to a set of linked lists which each held locks in page-aligned segments of the
    file. If locks spilled over these page-aligned segments the code fell back to the
    UP single linked list. There are clearly performance implications with substantial
    usage of file locks, since these are mandatory locks.

    This implementation goes for O(lgn) search performance by using splay trees. In order to
    apply simple trees to this problem no node of the tree can overlap, so since shared
    locks can in fact overlap something must be done. The solution used here is to have
    a meta-structure contain all locks which do overlap and have the tree operations
    split and merge these nodes of (potentially) multiple locks. This is the LOCKTREE_NODE.
    It should be noted that the worst case add/delete lock times are still linear.

    Exclusive locks pose a problem because of an asymmetry in the semantics of applying
    locks to a file. If a process applies a shared lock to a section of a file, no application
    of an exclusive lock to bytes in that section can succeed. However, if a process
    applies an exclusive lock, that same process can get a shared lock as well. This
    behavior conflicts with the mergeable node since by applying locks in a given order
    we can get a node to have many shared locks and "rogue" exclusive locks which are
    hidden except to a linear search, which is what we're designing out. So exclusive locks
    must be separated from the shared locks. This is the reason we have two lock trees.

    Since we have two lock trees, the average case search is now O(lgm + lgn) for m exclusive
    and n shared. Also, since no exclusive locks can ever overlap each other it is now
    unreasonable to have them use LOCKTREE_NODES - this would impose a memory penalty on code
    which was weighted toward exclusive locks. This means that the exclusive locks should
    be wired into the splay tree directly. So we need an RTL_SPLAY_LINKS, but this is 64 bits
    bigger than the SINGLE_LIST_ENTRY which shared locks need (to be threaded off of a
    LOCKTREE_NODE), which dictates separate shared and exclusive lock structures to avoid
    penalizing code which was weighted toward shared locks by having that wasted 64 bits per
    lock. Hence EX_LOCK and SH_LOCK (they actually occupy different pool block sizes).

    Zero length locks are a bizarre creation, and there is some errata relating to them. It
    used to be the case that zero length locks would be granted without exception. This is
    flat out bogus, and has been changed (NT 4.0). They are now subject to failure if they
    occupy a point interior to a lock of a type that can cause an access failure. A particular
    case that was previously allowed was a zero length exclusive lock interior to another
    exclusive lock.

    Zero length locks cannot conflict with zero length locks. This is the subject of some
    special code throughout the module. Note especially that zero length exclusive locks can
    "overlap". Zero length locks also cannot conflict at the starting byte and ending byte of a
    range - they are points on the line.

--*/

typedef struct _LOCKTREE_NODE {

    //
    //  List of locks under this node
    //

    SINGLE_LIST_ENTRY Locks;

    //
    //  Flag whether this node is holey as a result of a failed allocation
    //  during a node split.  During deletion of shared locks, we may
    //  discover that the locks in the node no longer have total overlap
    //  but cannot allocate resources to create the new nodes in the tree.
    //
    //  Any insert into the region occupied by a holey node will finish by
    //  trying to split a holey node up.  Any split or access check in a
    //  holey node must completely traverse the locks at the node.
    //

    BOOLEAN HoleyNode;

    //
    //  Maximum byte offset affected by locks in this node.
    //  Note: minimum offset is the starting offset of the
    //  first lock at this node.
    //

    ULONGLONG Extent;

    //
    //  Splay tree links to parent, lock groups strictly less than
    //  and lock groups strictly greater than locks in this node.
    //

    RTL_SPLAY_LINKS Links;

    //
    //  Last lock in the list (useful for node collapse under insert)
    //

    SINGLE_LIST_ENTRY Tail;

} LOCKTREE_NODE, *PLOCKTREE_NODE;

//
//  Define the threading wrappers for lock information
//

//
//  Each shared lock record corresponds to a current granted lock and is
//  maintained in a queue off of a LOCKTREE_NODE's Locks list.  The list
//  of current locks is ordered according to the starting byte of the lock.
//

typedef struct _SH_LOCK {

    //
    //  The link structures for the list of shared locks.
    //

    SINGLE_LIST_ENTRY   Link;

    //
    //  The actual locked range
    //

    FILE_LOCK_INFO LockInfo;

} SH_LOCK, *PSH_LOCK;

//
//  Each exclusive lock record corresponds to a current granted lock and is
//  threaded into the exclusive lock tree.
//

typedef struct _EX_LOCK {

    //
    //  The link structures for the list of current locks.
    //

    RTL_SPLAY_LINKS     Links;

    //
    //  The actual locked range
    //

    FILE_LOCK_INFO LockInfo;

} EX_LOCK, *PEX_LOCK;

//
//  Each Waiting lock record corresponds to a IRP that is waiting for a
//  lock to be granted and is maintained in a queue off of the FILE_LOCK's
//  WaitingLockQueue list.
//

typedef struct _WAITING_LOCK {

    //
    //  The link structures for the list of waiting locks
    //

    SINGLE_LIST_ENTRY   Link;

    //
    //  The optional procedure to call to complete a request.  We require this
    //  in the individual waiters so that we can heal the race between cancellation
    //  and teardown of a lock structure.
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The context field to use when completing the irp via the alternate
    //  routine
    //

    PVOID Context;

    //
    //  A pointer to the IRP that is waiting for a lock
    //

    PIRP Irp;

} WAITING_LOCK, *PWAITING_LOCK;


//
//  Each lock or waiting onto some lock queue.
//

typedef struct _LOCK_QUEUE {

    //
    // Sync to guard queue access.
    //

    KSPIN_LOCK  QueueSpinLock;

    //
    //  The items contain locktrees of the current granted
    //  locks and a list of the waiting locks
    //

    PRTL_SPLAY_LINKS SharedLockTree;
    PRTL_SPLAY_LINKS ExclusiveLockTree;
    SINGLE_LIST_ENTRY WaitingLocks;
    SINGLE_LIST_ENTRY WaitingLocksTail;

} LOCK_QUEUE, *PLOCK_QUEUE;


//
//  Any file_lock which has had a lock applied gets a non-paged pool
//  structure which tracks the current locks applied to the file
//

typedef struct _LOCK_INFO {

    //
    //  LowestLockOffset retains the offset of the lowest existing
    //  lock.  This facilitates a quick check to see if a read or
    //  write can proceed without locking the lock database.  This is
    //  helpful for applications that use mirrored locks -- all locks
    //  are higher than file data.
    //
    //  If the lowest lock has an offset > 0xffffffff, LowestLockOffset
    //  is set to 0xffffffff.
    //

    ULONG LowestLockOffset;

    //
    //  The optional procedure to call to complete a request
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The optional procedure to call when unlocking a byte range
    //

    PUNLOCK_ROUTINE UnlockRoutine;

    //
    // The locked ranges
    //

    LOCK_QUEUE  LockQueue;

} LOCK_INFO, *PLOCK_INFO;

//
//  Local Macros
//

//
//  The following macros sort out the allocation of internal structures.
//

INLINE
PSH_LOCK
FsRtlAllocateSharedLock (
    VOID
    )
{
    return (PSH_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlSharedLockLookasideList );
}

INLINE
PEX_LOCK
FsRtlAllocateExclusiveLock (
    VOID
    )
{
    return (PEX_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlExclusiveLockLookasideList );
}

INLINE
PWAITING_LOCK
FsRtlAllocateWaitingLock (
    VOID
    )
{
    return (PWAITING_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlWaitingLockLookasideList );
}

INLINE
PLOCKTREE_NODE
FsRtlAllocateLockTreeNode (
    VOID
    )
{
    return (PLOCKTREE_NODE) ExAllocateFromNPagedLookasideList( &FsRtlLockTreeNodeLookasideList );
}

INLINE
PLOCK_INFO
FsRtlAllocateLockInfo (
    VOID
    )
{
    return (PLOCK_INFO) ExAllocateFromNPagedLookasideList( &FsRtlLockInfoLookasideList );
}


INLINE
VOID
FsRtlFreeSharedLock (
    IN PSH_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlSharedLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeExclusiveLock (
    IN PEX_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlExclusiveLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeWaitingLock (
    IN PWAITING_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlWaitingLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeLockTreeNode (
    IN PLOCKTREE_NODE C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlLockTreeNodeLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeLockInfo (
    IN PLOCK_INFO C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlLockInfoLookasideList, (PVOID)C );
}

#define FsRtlAcquireLockQueue(a,b)          ExAcquireSpinLock(&(a)->QueueSpinLock, b)
#define FsRtlReleaseLockQueue(a,b)          ExReleaseSpinLock(&(a)->QueueSpinLock, b)
#define FsRtlAcquireLockQueueAtDpc(a)       ExAcquireSpinLockAtDpcLevel(&(a)->QueueSpinLock)
#define FsRtlReleaseLockQueueFromDpc(a)     ExReleaseSpinLockFromDpcLevel(&(a)->QueueSpinLock)

#define FsRtlAcquireCancelCollide(a)        ExAcquireSpinLock(&FsRtlFileLockCancelCollideLock, a)
#define FsRtlReleaseCancelCollide(a)        ExReleaseSpinLock(&FsRtlFileLockCancelCollideLock, a)
#define FsRtlAcquireCancelCollideAtDpc(a)   ExAcquireSpinLockAtDpcLevel(&FsRtlFileLockCancelCollideLock)
#define FsRtlReleaseCancelCollideFromDpc(a) ExReleaseSpinLockFromDpcLevel(&FsRtlFileLockCancelCollideLock)

//
//  Generic way to complete a lock IRP.  We like to treat this as an overloaded
//  function so it can be used with LOCK_INFO, FILE_LOCK and WAITING_LOCK
//  structures, as appropriate using paged/nonpaged pool to discover the completion
//  routine.
//

#define FsRtlCompleteLockIrp( A, B, C, D, E, F )                \
        FsRtlCompleteLockIrpReal( (A)->CompleteLockIrpRoutine,  \
                                  B,                            \
                                  C,                            \
                                  D,                            \
                                  E,                            \
                                  F )

INLINE
VOID
FsRtlCompleteLockIrpReal (
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    IN PVOID Context,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN PNTSTATUS NewStatus,
    IN PFILE_OBJECT FileObject
    )
{
    //
    //  This fools the compiler into generating the Status only once
    //  if it is calculated from an expression.
    //

    NTSTATUS LocalStatus = Status;

    if (CompleteLockIrpRoutine != NULL) {

        if (FileObject != NULL) {

            FileObject->LastLock = NULL;
        }

        Irp->IoStatus.Status = LocalStatus;
        *NewStatus = CompleteLockIrpRoutine( Context, Irp );

    } else {

        FsRtlCompleteRequest( Irp, LocalStatus );
        *NewStatus = LocalStatus;
    }
}

//
//  The following routines are private to this module
//

VOID
FsRtlSplitLocks (
    IN PLOCKTREE_NODE ParentNode,
    IN PSINGLE_LIST_ENTRY *pStartLink,
    IN PLARGE_INTEGER LastShadowedByte,
    IN PLARGE_INTEGER GlueOffset
    );

PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingSharedNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    );

PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingExclusiveNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    );

PSH_LOCK
FsRtlFindFirstOverlapInNode (
    IN PLOCKTREE_NODE Node,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER EndingByte
    );

BOOLEAN
FsRtlPrivateInsertLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN PFILE_LOCK_INFO FileLockInfo
    );

BOOLEAN
FsRtlPrivateInsertSharedLock (
    IN PLOCK_QUEUE LockQueue,
    IN PSH_LOCK NewLock
    );

VOID
FsRtlPrivateInsertExclusiveLock (
    IN PLOCK_QUEUE LockQueue,
    IN PEX_LOCK NewLock
    );

VOID
FsRtlPrivateCheckWaitingLocks (
    IN PLOCK_INFO   LockInfo,
    IN PLOCK_QUEUE  LockQueue,
    IN KIRQL        OldIrql
    );

VOID
FsRtlPrivateCancelFileLockIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
FsRtlPrivateCheckForExclusiveLockAccess (
    IN PLOCK_QUEUE LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo
    );

BOOLEAN
FsRtlPrivateCheckForSharedLockAccess (
    IN PLOCK_QUEUE LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo
    );

NTSTATUS
FsRtlPrivateFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN MatchKey,
    IN PVOID Context OPTIONAL
    );

BOOLEAN
FsRtlPrivateInitializeFileLock (
    IN PFILE_LOCK   FileLock,
    IN BOOLEAN ViaFastCall
    );

VOID
FsRtlPrivateRemoveLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_LOCK_INFO,
    IN BOOLEAN CheckForWaiters
    );

BOOLEAN
FsRtlCheckNoSharedConflict (
   IN PLOCK_QUEUE LockQueue,
   IN PLARGE_INTEGER Starting,
   IN PLARGE_INTEGER Ending
   );

BOOLEAN
FsRtlCheckNoExclusiveConflict (
    IN PLOCK_QUEUE LockQueue,
    IN PLARGE_INTEGER Starting,
    IN PLARGE_INTEGER Ending,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    );

VOID
FsRtlPrivateResetLowestLockOffset (
    PLOCK_INFO LockInfo
    );

NTSTATUS
FsRtlFastUnlockSingleShared (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    );

NTSTATUS
FsRtlFastUnlockSingleExclusive (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeFileLocks)
#endif


VOID
FsRtlInitializeFileLocks (
    VOID
    )
/*++

Routine Description:

    Initializes the global portion of the filelock package.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  Build the lookaside lists for our internal structures.
    //

    ExInitializeNPagedLookasideList( &FsRtlSharedLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(SH_LOCK),
                                     TAG_SHARED_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlExclusiveLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(EX_LOCK),
                                     TAG_EXCLUSIVE_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlWaitingLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(WAITING_LOCK),
                                     TAG_WAITING_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlLockTreeNodeLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(LOCKTREE_NODE),
                                     TAG_LOCKTREE_NODE,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlLockInfoLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(LOCK_INFO),
                                     TAG_LOCK_INFO,
                                     8 );

    ExInitializePagedLookasideList( &FsRtlFileLockLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(FILE_LOCK),
                                    TAG_FILE_LOCK,
                                    8 );

    //
    //  Initialize the LockInfo creation mutex
    //

    KeInitializeGuardedMutex(&FsRtlCreateLockInfo);

    //
    //  Initialize the cancel collision lock
    //

    KeInitializeSpinLock( &FsRtlFileLockCancelCollideLock );
    FsRtlFileLockCancelCollideList.Next = NULL;
}


VOID
FsRtlInitializeFileLock (
    __in PFILE_LOCK FileLock,
    __in_opt PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    __in_opt PUNLOCK_ROUTINE UnlockRoutine
    )

/*++

Routine Description:

    This routine initializes a new FILE_LOCK structure.  The caller must
    supply the memory for the structure.  This call must precede all other
    calls that utilize the FILE_LOCK variable.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK structure to
        initialize.

    CompleteLockIrpRoutine - Optionally supplies an alternate routine to
        call for completing IRPs.  FsRtlProcessFileLock by default will
        call IoCompleteRequest to finish up an IRP; however if the caller
        want to process the completion itself then it needs to specify
        a completion routine here.  This routine will then be called in
        place of IoCompleteRequest.

    UnlockRoutine - Optionally supplies a routine to call when removing
        a lock.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlInitializeFileLock, FileLock = %08lx\n", FileLock);

    //
    // Clear non-paged pool pointer
    //

    FileLock->LockInformation = NULL;
    FileLock->CompleteLockIrpRoutine = CompleteLockIrpRoutine;
    FileLock->UnlockRoutine = UnlockRoutine;

    FileLock->FastIoIsQuestionable = FALSE;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlInitializeFileLock -> VOID\n", 0 );

    return;
}


BOOLEAN
FsRtlPrivateInitializeFileLock (
    IN PFILE_LOCK   FileLock,
    IN BOOLEAN ViaFastCall
    )
/*++

Routine Description:

    This routine initializes a new LOCK_INFO structure in non-paged
    pool for the FILE_LOCK.  This routines only occurs once for a given
    FILE_LOCK and it only occurs if any locks are applied to that file.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK structure to
        initialize.

    ViaFastCall - Indicates if we are being invoked via a fast call or
        via the slow irp based method.

Return Value:

    TRUE - If LockInfo structure was allocated and initialized

--*/
{
    PLOCK_INFO  LockInfo;
    BOOLEAN     Results = FALSE;

    KeAcquireGuardedMutex( &FsRtlCreateLockInfo );

    try {

        if (FileLock->LockInformation != NULL) {

            //
            // Structure is already allocated, just return
            //

            try_return( Results = TRUE );
        }

        //
        //  Allocate pool for lock structures.  If we fail then we will either return false or
        //  raise based on if we know the caller has an try-except to handle a raise.
        //

        LockInfo = FsRtlAllocateLockInfo();

        if (LockInfo == NULL) {

            if (ViaFastCall) {

                try_return( Results = FALSE );

            } else {

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        //
        //  Allocate and initialize the waiting lock queue
        //  spinlock, and initialize the queues
        //

        LockInfo->LowestLockOffset = 0xffffffff;

        KeInitializeSpinLock( &LockInfo->LockQueue.QueueSpinLock );
        LockInfo->LockQueue.SharedLockTree = NULL;
        LockInfo->LockQueue.ExclusiveLockTree = NULL;
        LockInfo->LockQueue.WaitingLocks.Next = NULL;
        LockInfo->LockQueue.WaitingLocksTail.Next = NULL;

        //
        // Copy Irp & Unlock routines from pageable FileLock structure
        // to non-pageable LockInfo structure
        //

        LockInfo->CompleteLockIrpRoutine = FileLock->CompleteLockIrpRoutine;
        LockInfo->UnlockRoutine = FileLock->UnlockRoutine;

        //
        // Clear continuation info for enum routine
        //

        FileLock->LastReturnedLockInfo.FileObject = NULL;
        FileLock->LastReturnedLock = NULL;

        //
        // Link LockInfo into FileLock
        //

        FileLock->LockInformation = (PVOID) LockInfo;
        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        KeReleaseGuardedMutex( &FsRtlCreateLockInfo );
    }

    return Results;
}


VOID
FsRtlUninitializeFileLock (
    __in PFILE_LOCK FileLock
    )

/*++

Routine Description:

    This routine uninitializes a FILE_LOCK structure.  After calling this
    routine the File lock must be reinitialized before being used again.

    This routine will free all files locks and completes any outstanding
    lock requests as a result of cleaning itself up.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK structure being
        decommissioned.

Return Value:

    None.

--*/

{
    PLOCK_INFO          LockInfo;
    PSH_LOCK            ShLock;
    PEX_LOCK            ExLock;
    PSINGLE_LIST_ENTRY  Link;
    PWAITING_LOCK       WaitingLock;
    PLOCKTREE_NODE      LockTreeNode;
    PIRP                Irp;
    NTSTATUS            NewStatus;
    KIRQL               OldIrql;

    DebugTrace(+1, Dbg, "FsRtlUninitializeFileLock, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        return ;
    }

    //
    //  Lock vs. cancels and lock the queue.
    //

    FsRtlAcquireCancelCollide( &OldIrql );
    FsRtlAcquireLockQueueAtDpc( &LockInfo->LockQueue );

    //
    //  Free lock trees
    //

    while (LockInfo->LockQueue.SharedLockTree != NULL) {

        LockTreeNode = CONTAINING_RECORD(LockInfo->LockQueue.SharedLockTree, LOCKTREE_NODE, Links);

        //
        //  Remove all locks associated with the root node
        //

        while (LockTreeNode->Locks.Next != NULL) {
            Link = PopEntryList (&LockTreeNode->Locks);
            ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

            FsRtlFreeSharedLock(ShLock);
        }

        //
        //  Slice off the root node of the tree
        //

        RtlDeleteNoSplay(&LockTreeNode->Links, &LockInfo->LockQueue.SharedLockTree);

        FsRtlFreeLockTreeNode(LockTreeNode);
    }

    while (LockInfo->LockQueue.ExclusiveLockTree != NULL) {

        ExLock = CONTAINING_RECORD(LockInfo->LockQueue.ExclusiveLockTree, EX_LOCK, Links);

        RtlDeleteNoSplay(&ExLock->Links, &LockInfo->LockQueue.ExclusiveLockTree);

        FsRtlFreeExclusiveLock(ExLock);
    }

    //
    //  Free WaitingLockQueue.
    //
    //  This will be incredibly rare, requiring a cancel to be pending in an async thread
    //  while cleanup/close occurs in the owning filesystem, triggering teardown.
    //

    while (LockInfo->LockQueue.WaitingLocks.Next != NULL) {

        Link = PopEntryList( &LockInfo->LockQueue.WaitingLocks );
        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        Irp = WaitingLock->Irp;

        //
        //  To complete an irp in the waiting queue we need to
        //  void the cancel routine (protected by a spinlock so
        //  we can know that we beat cancellation) before
        //  we completing the irp.
        //

        FsRtlReleaseLockQueueFromDpc( &LockInfo->LockQueue );

        IoAcquireCancelSpinLock( &Irp->CancelIrql );
        IoSetCancelRoutine( Irp, NULL );

        //
        //  If it got cancelled, the cancel routine is now waiting on the other
        //  side of the cancel collide for us to push it onto the collide list.
        //  It'll get the IRP there as opposed to the shortly-to-be-axed lock
        //  structure.
        //

        if (Irp->Cancel) {

            IoReleaseCancelSpinLock( Irp->CancelIrql );
            PushEntryList( &FsRtlFileLockCancelCollideList,
                           &WaitingLock->Link );
            Irp = NULL;

        } else {

            IoReleaseCancelSpinLock( Irp->CancelIrql );
        }

        //
        //  If we got the ownership of the IRP, release the collide and complete
        //  it, otherwise spin back around for more.
        //

        if (Irp) {

            FsRtlReleaseCancelCollide( OldIrql );

            Irp->IoStatus.Information = 0;

            FsRtlCompleteLockIrp(
                 LockInfo,
                 WaitingLock->Context,
                 Irp,
                 STATUS_RANGE_NOT_LOCKED,
                 &NewStatus,
                 NULL );

            FsRtlFreeWaitingLock( WaitingLock );

            FsRtlAcquireCancelCollide( &OldIrql );
        }

        FsRtlAcquireLockQueueAtDpc( &LockInfo->LockQueue );
    }

    //
    // Release locks and free pool used to track the lock info on this file.
    //

    FsRtlReleaseLockQueueFromDpc( &LockInfo->LockQueue );
    FsRtlReleaseCancelCollide( OldIrql );
    FsRtlFreeLockInfo( LockInfo );

    //
    // Unlink LockInfo from FileLock
    //

    FileLock->LockInformation = NULL;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlUninitializeFileLock -> VOID\n", 0 );
    return;
}


PFILE_LOCK
FsRtlAllocateFileLock (
    __in_opt PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    __in_opt PUNLOCK_ROUTINE UnlockRoutine
    )
{
    PFILE_LOCK FileLock;

    FileLock = ExAllocateFromPagedLookasideList( &FsRtlFileLockLookasideList );

    if (FileLock != NULL) {

        FsRtlInitializeFileLock( FileLock,
                                 CompleteLockIrpRoutine,
                                 UnlockRoutine );
    }

    return FileLock;
}

VOID
FsRtlFreeFileLock (
    __in PFILE_LOCK FileLock
    )
{
    FsRtlUninitializeFileLock( FileLock );

    ExFreeToPagedLookasideList( &FsRtlFileLockLookasideList, FileLock );
}


NTSTATUS
FsRtlProcessFileLock (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp,
    __in_opt PVOID Context
    )

/*++

Routine Description:

    This routine processes a file lock IRP it does either a lock request,
    or an unlock request.  It also completes the IRP.  Once called the user
    (i.e., File System) has relinquished control of the input IRP.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    FileLock - Supplies the File lock being modified/queried.

    Irp - Supplies the Irp being processed.

    Context - Optionally supplies a context to use when calling the user
        alternate IRP completion routine.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    IO_STATUS_BLOCK Iosb;
    NTSTATUS        Status;
    LARGE_INTEGER   ByteOffset;

    DebugTrace(+1, Dbg, "FsRtlProcessFileLock, FileLock = %08lx\n", FileLock);

    Iosb.Information = 0;

    //
    //  Get a pointer to the current Irp stack location and assert that
    //  the major function code is for a lock operation
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( IrpSp->MajorFunction == IRP_MJ_LOCK_CONTROL );

    //
    //  Now process the different minor lock operations
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_LOCK:

        ByteOffset = IrpSp->Parameters.LockControl.ByteOffset;

        (VOID) FsRtlPrivateLock( FileLock,
                                 IrpSp->FileObject,
                                 &ByteOffset,
                                 IrpSp->Parameters.LockControl.Length,
                                 IoGetRequestorProcess(Irp),
                                 IrpSp->Parameters.LockControl.Key,
                                 BooleanFlagOn(IrpSp->Flags, SL_FAIL_IMMEDIATELY),
                                 BooleanFlagOn(IrpSp->Flags, SL_EXCLUSIVE_LOCK),
                                 &Iosb,
                                 Irp,
                                 Context,
                                 FALSE );

        break;

    case IRP_MN_UNLOCK_SINGLE:

        ByteOffset = IrpSp->Parameters.LockControl.ByteOffset;

        Iosb.Status = FsRtlFastUnlockSingle( FileLock,
                                             IrpSp->FileObject,
                                             &ByteOffset,
                                             IrpSp->Parameters.LockControl.Length,
                                             IoGetRequestorProcess(Irp),
                                             IrpSp->Parameters.LockControl.Key,
                                             Context,
                                             FALSE );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    case IRP_MN_UNLOCK_ALL:

        Iosb.Status = FsRtlFastUnlockAll( FileLock,
                                          IrpSp->FileObject,
                                          IoGetRequestorProcess(Irp),
                                          Context );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    case IRP_MN_UNLOCK_ALL_BY_KEY:

        Iosb.Status = FsRtlFastUnlockAllByKey( FileLock,
                                               IrpSp->FileObject,
                                               IoGetRequestorProcess(Irp),
                                               IrpSp->Parameters.LockControl.Key,
                                               Context );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    default:

        //
        //  For all other minor function codes we say they're invalid and
        //  complete the request.  Note that the IRP has not been marked
        //  pending so this error will be returned directly to the caller.
        //

        DebugTrace(0, 1, "Invalid LockFile Minor Function Code %08lx\n", IrpSp->MinorFunction);


        FsRtlCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST );

        Iosb.Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlProcessFileLock -> %08lx\n", Iosb.Status);

    return Iosb.Status;
}


BOOLEAN
FsRtlCheckLockForReadAccess (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp
    )

/*++

Routine Description:

    This routine checks to see if the caller has read access to the
    range indicated in the IRP due to file locks.  This call does not
    complete the Irp it only uses it to get the lock information and read
    information.  The IRP must be for a read operation.

Arguments:

    FileLock - Supplies the File Lock to check.

    Irp - Supplies the Irp being processed.

Return Value:

    BOOLEAN - TRUE if the indicated user/request has read access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    PLOCK_INFO     LockInfo;
    LARGE_INTEGER  StartingByte;
    LARGE_INTEGER  Length;
    ULONG          Key;
    PFILE_OBJECT   FileObject;
    PVOID          ProcessId;
    LARGE_INTEGER  BeyondLastByte;

    DebugTrace(+1, Dbg, "FsRtlCheckLockForReadAccess, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (No current lock info) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Do a really fast test to see if there are any exclusive locks to start with
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (No current locks) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get the read offset and compare it to the lowest existing lock.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    StartingByte  = IrpSp->Parameters.Read.ByteOffset;
    Length.QuadPart = (ULONGLONG)IrpSp->Parameters.Read.Length;

    BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
    if ( (ULONGLONG)BeyondLastByte.QuadPart <= (ULONGLONG)LockInfo->LowestLockOffset ) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (Below lowest lock) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get remaining parameters.
    //

    Key           = IrpSp->Parameters.Read.Key;
    FileObject    = IrpSp->FileObject;
    ProcessId     = IoGetRequestorProcess( Irp );

    //
    //  Call our private work routine to do the real check
    //

    Result = FsRtlFastCheckLockForRead( FileLock,
                                        &StartingByte,
                                        &Length,
                                        Key,
                                        FileObject,
                                        ProcessId );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess -> %08lx\n", Result);

    return Result;
}


BOOLEAN
FsRtlCheckLockForWriteAccess (
    __in PFILE_LOCK FileLock,
    __in PIRP Irp
    )

/*++

Routine Description:

    This routine checks to see if the caller has write access to the
    indicated range due to file locks.  This call does not complete the
    Irp it only uses it to get the lock information and write information.
    The IRP must be for a write operation.

Arguments:

    FileLock - Supplies the File Lock to check.

    Irp - Supplies the Irp being processed.

Return Value:

    BOOLEAN - TRUE if the indicated user/request has write access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    PLOCK_INFO      LockInfo;
    LARGE_INTEGER   StartingByte;
    LARGE_INTEGER   Length;
    ULONG           Key;
    PFILE_OBJECT    FileObject;
    PVOID           ProcessId;
    LARGE_INTEGER   BeyondLastByte;

    DebugTrace(+1, Dbg, "FsRtlCheckLockForWriteAccess, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (No current lock info) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Do a really fast test to see if there are any locks to start with
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL && LockInfo->LockQueue.SharedLockTree == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (No current locks) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get the write offset and compare it to the lowest existing lock.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    StartingByte  = IrpSp->Parameters.Write.ByteOffset;
    Length.QuadPart = (ULONGLONG)IrpSp->Parameters.Write.Length;

    BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
    if ( (ULONGLONG)BeyondLastByte.QuadPart <= (ULONGLONG)LockInfo->LowestLockOffset ) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (Below lowest lock) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get remaining parameters.
    //

    Key           = IrpSp->Parameters.Write.Key;
    FileObject    = IrpSp->FileObject;
    ProcessId     = IoGetRequestorProcess( Irp );

    //
    //  Call our private work routine to do the real work
    //

    Result = FsRtlFastCheckLockForWrite( FileLock,
                                         &StartingByte,
                                         &Length,
                                         Key,
                                         FileObject,
                                         ProcessId );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess -> %08lx\n", Result);

    return Result;
}


PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingSharedNode (
    IN PRTL_SPLAY_LINKS         Tree,
    IN PLARGE_INTEGER           StartingByte,
    IN PLARGE_INTEGER           EndingByte,
    IN OUT PRTL_SPLAY_LINKS     *LastEdgeNode,
    IN OUT PBOOLEAN             GreaterThan
    )
/*++

Routine Description:

    This routine returns the first node in the shared lock tree which
    overlaps with the range given. No nodes given by RtlRealPredecessor()
    on the result overlap the range.

Arguments:

    Tree - supplies the splay links of the root node of the shared tree
        to search

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

    LastEdgeNode - optional, will be set to the last node searched in the
        not including returned node (presumably where a new node will
        be inserted if return is NULL).

    GreaterThan - optional, set according to whether LastEdgeNode is covering
        a range greater than the queried range. !GreaterThan == LessThan, since
        we would have returned this node in the "Equals" (overlap) case.

Return Value:

    The splay links of the node, if such a node exists, NULL otherwise

--*/
{
    PLOCKTREE_NODE        Node = NULL, LastOverlapNode;
    PRTL_SPLAY_LINKS      SplayLinks;
    PSH_LOCK              Lock;

    if (LastEdgeNode) *LastEdgeNode = NULL;
    if (GreaterThan) *GreaterThan = FALSE;

    LastOverlapNode = NULL;
    SplayLinks = Tree;

    while (SplayLinks) {

        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

        //
        //  Pull up the first lock on the chain at this node to check
        //  the starting byte offset of locks at this node
        //

        Lock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );

        //
        //  We may have to go right in the tree if this lock covers a range before the start of this
        //  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock
        //  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero
        //  length lock relation of End < Start does not hold.
        //

        if (Node->Extent < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                //
                //  The extent of the node is less than the starting position of the
                //  range we are checking and the first lock on this node is equal to
                //  the range, which implies that the range and the lock are zero
                //  length.
                //
                //  This is a zero length lock node and we are searching for zero
                //  length overlap. This makes multiple zero length shared locks
                //  occupy the same node, which is a win, but makes application of
                //  zero length exclusive locks check the length of the overlapping
                //  lock to see if they really conflict.
                //

                break;
            }

            //
            //  All locks at this node are strictly less than this
            //  byterange, so go right in the tree.
            //

            if (LastEdgeNode) *LastEdgeNode = SplayLinks;
            if (GreaterThan) *GreaterThan = FALSE;

            SplayLinks = RtlRightChild(SplayLinks);
            continue;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)EndingByte->QuadPart) {

            //
            //  We have an overlap, but we need to see if the byterange starts
            //  before this node so that there is the guarantee that we start
            //  the search at the correct point. There may be still be predecessor
            //  nodes covering the byterange.
            //

            if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)StartingByte->QuadPart) {

                //
                //  This node begins at a byte offset prior to the byterange we
                //  are checking, so it must be the correct starting position.
                //

                break;
            }

            //
            //  Drop a marker at this node so that we can come back if it turns out
            //  that the left subtree does not cover the range of bytes before this
            //  node in the byterange.
            //

            LastOverlapNode = Node;
        }

        //
        //  It must now be the case that all locks at this node are strictly greater
        //  than the byterange, or we have the candidate overlap case above,
        //  so go left in the tree.
        //

        if (LastEdgeNode) *LastEdgeNode = SplayLinks;
        if (GreaterThan) *GreaterThan = TRUE;

        SplayLinks = RtlLeftChild(SplayLinks);
    }

    if (SplayLinks == NULL) {

        //
        //  We hit the edge of the tree. If the LastOverlapNode is set, it means that
        //  we had kept searching left in the tree for a node that covered the starting
        //  byte of the byterange, but didn't find it. If it isn't set, we'll do the
        //  right thing anyway since Node <- NULL.
        //

        Node = LastOverlapNode;
    }

    if (Node == NULL) {

        //
        // No overlapping node existed
        //

        return NULL;
    }

    //
    // Return the splay links of the first overlapping node
    //

    return &Node->Links;
}


PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingExclusiveNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    )
/*++

Routine Description:

    This routine returns the first node in the exclusive lock tree which
    overlaps with the range given. No nodes given by RtlRealPredecessor()
    on the result overlap the range.

Arguments:

    Tree - supplies the splay links of the root node of the exclusive tree
        to search

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

    LastEdgeNode - optional, will be set to the last node searched
        not including returned node (presumably where a new node will
        be inserted if return is NULL).

    GreaterThan - optional, set according to whether LastEdgeNode is covering
        a range greater than the queried range. !GreaterThan == LessThan, since
        we would have returned this node in the "Equals" (overlap) case.

Return Value:

    The splay links of the node, if such a node exists, NULL otherwise

--*/
{
    PRTL_SPLAY_LINKS    SplayLinks;
    PEX_LOCK            Lock = NULL, LastOverlapNode;

    if (LastEdgeNode) *LastEdgeNode = NULL;
    if (GreaterThan) *GreaterThan = FALSE;

    LastOverlapNode = NULL;
    SplayLinks = Tree;

    while (SplayLinks) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        //
        //  We may have to go right in the tree if this lock covers a range before the start of this
        //  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock
        //  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero
        //  length lock relation of End < Start does not hold.
        //

        if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                //
                //  The extent of the lock is less than the starting position of the
                //  range we are checking and the lock is equal to the range, which
                //  implies that the range and the lock are zero length.
                //
                //  This is a zero length lock node and we are searching for zero
                //  length overlap. Since the exclusive tree is one lock per node,
                //  we are in the potential middle of a run of zero length locks in
                //  the tree. Go left to find the first zero length lock.
                //
                //  This is actually the same logic we'd use for equivalent locks,
                //  but the only time that can happen in this tree is for zero length
                //  locks.
                //

                LastOverlapNode = Lock;

                if (LastEdgeNode) *LastEdgeNode = SplayLinks;
                if (GreaterThan) *GreaterThan = FALSE;

                SplayLinks = RtlLeftChild(SplayLinks);
                continue;
            }

            //
            //  This lock is strictly less than this byterange, so go
            //  right in the tree.
            //

            if (LastEdgeNode) *LastEdgeNode = SplayLinks;
            if (GreaterThan) *GreaterThan = FALSE;

            SplayLinks = RtlRightChild(SplayLinks);
            continue;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)EndingByte->QuadPart) {

            //
            //  We have an overlap, but we need to see if the byterange starts
            //  before this node so that there is the guarantee that we start
            //  the search at the correct point. There may be still be predecessor
            //  nodes covering the byterange.
            //

            if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)StartingByte->QuadPart) {

                //
                //  This node begins at a byte offset prior to the byterange we
                //  are checking, so it must be the correct starting position.
                //

                break;
            }

            //
            //  Drop a marker at this node so that we can come back if it turns out
            //  that the left subtree does not cover the range of bytes before this
            //  node in the byterange.
            //

            LastOverlapNode = Lock;
        }

        //
        //  It must now be the case this lock is strictly greater than the byterange,
        //  or we have the candidate overlap case above, so go left in the tree.
        //

        if (LastEdgeNode) *LastEdgeNode = SplayLinks;
        if (GreaterThan) *GreaterThan = TRUE;

        SplayLinks = RtlLeftChild(SplayLinks);
    }

    if (SplayLinks == NULL) {

        //
        //  We hit the edge of the tree. If the LastOverlapNode is set, it means that
        //  we had kept searching left in the tree for a node that covered the starting
        //  byte of the byterange, but didn't find it. If it isn't set, we'll do the
        //  right thing anyway since Node <- NULL.
        //

        Lock = LastOverlapNode;
    }

    if (Lock == NULL) {

        //
        // No overlapping lock existed
        //

        return NULL;
    }

    //
    // Return the splay links of the first overlapping lock
    //

    return &Lock->Links;
}


PSH_LOCK
FsRtlFindFirstOverlapInNode (
    IN PLOCKTREE_NODE Node,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER EndingByte
    )

/*++

Routine Description:

    This routine examines a shared lock node, usually a node which is known to be composed
    of several non-overlapping lock segments (holey), for true overlap with the indicated
    range.  This is not handled in the normal overlap check (..FindFirstOverlappingSharedLock)
    since the needs for holey checks are rather different than the full node check.

Arguments:

    Node - the lock tree node to be examined for overlap

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

Return Value:

    PSH_LOCK - the first lock which overlaps with the specified range.

--*/
{
    PSH_LOCK Lock;
    PSINGLE_LIST_ENTRY Link;

    for (Link = Node->Locks.Next;
         Link;
         Link = Link->Next) {

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        //
        //  Logic is the same as above checkers.  If the ending byte of the lock is less than the
        //  starting byte of the range, OR we have the weird [0, 0) case, then the lock is almost
        //  certainly less than the range.
        //

        if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            //
            //  ... except if the lock and range are equivalent, in which case we have discovered
            //  zero lock/range overlap.
            //

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                return Lock;
            }

            //
            //  Look forward in the node.
            //

            continue;
        }

        //
        //  No overlap at all if the lock begins at a higher byte than the last of the range.
        //  We already covered zero length locks (where this is true, and overlap could still
        //  occur).
        //

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)EndingByte->QuadPart) {

            return NULL;
        }

        //
        //  Regular overlap has occured.  Return this lock.
        //

        return Lock;
    }

    //
    //  If we invoke this check and wander off the end of the node without determining what is
    //  going on, something is terribly wrong.
    //

    ASSERT( FALSE );

    return NULL;
}


PFILE_LOCK_INFO
FsRtlGetNextFileLock (
    __in PFILE_LOCK FileLock,
    __in BOOLEAN Restart
    )

/*++

Routine Description:

    This routine enumerates the individual file locks denoted by the input file lock
    variable. It returns a pointer to the file lock information stored for each lock.
    The caller is responsible for synchronizing call to this procedure and for not
    altering any of the data returned by this procedure. If the caller does not
    synchronize the enumeration will not be reliably complete.

    The way a programmer will use this procedure to enumerate all of the locks
    is as follows:

    for (p = FsRtlGetNextFileLock( FileLock, TRUE );
         p != NULL;
         p = FsRtlGetNextFileLock( FileLock, FALSE )) {

            // Process the lock information referenced by p
    }

    Order is *not* guaranteed.

Arguments:

    FileLock - Supplies the File Lock to enumerate.  The current
        enumeration state is stored in the file lock variable so if multiple
        threads are enumerating the lock at the same time the results will
        be unpredictable.

    Restart - Indicates if the enumeration is to start at the beginning of the
        file lock tree or if we are continuing from a previous call.

Return Value:

    PFILE_LOCK_INFO - Either it returns a pointer to the next file lock
        record for the input file lock or it returns NULL if there
        are not more locks.

--*/

{
    FILE_LOCK_INFO      FileLockInfo;
    PVOID               ContinuationPointer;
    PLOCK_INFO          LockInfo;
    PLOCKTREE_NODE      Node;
    PSINGLE_LIST_ENTRY  Link;
    PRTL_SPLAY_LINKS    SplayLinks, LastSplayLinks;
    PSH_LOCK            ShLock;
    PEX_LOCK            ExLock;
    BOOLEAN             FoundReturnable, GreaterThan;
    KIRQL               OldIrql;

    DebugTrace(+1, Dbg, "FsRtlGetNextFileLock, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        //
        //  No lock information on this FileLock
        //

        return NULL;
    }

    FoundReturnable = FALSE;

    //
    //  Before getting the spinlock, copy pageable info onto stack
    //

    FileLockInfo = FileLock->LastReturnedLockInfo;
    ContinuationPointer = FileLock->LastReturnedLock;

    FsRtlAcquireLockQueue (&LockInfo->LockQueue, &OldIrql);

    if (!Restart) {
        //
        //  Given the last returned lock, find its current successor in the tree.
        //  Previous implementations would reset the enumeration if the last returned
        //  lock had been removed from the tree but I think we can be better in that
        //  case since every other structure modifying event (add new locks, delete
        //  other locks) would *not* have caused the reset. Possible minor performance
        //  enhancement.
        //

        //
        //  Find the node which could contain the last returned lock. We enumerate the
        //  exclusive lock tree, then the shared lock tree. Find the one we're enumerating.
        //

        if (FileLockInfo.ExclusiveLock) {

            //
            //  Continue enumeration in the exclusive lock tree
            //

            ExLock = NULL;

            SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockInfo->LockQueue.ExclusiveLockTree,
                                                                 &FileLockInfo.StartingByte,
                                                                 &FileLockInfo.EndingByte,
                                                                 &LastSplayLinks,
                                                                 &GreaterThan );

            if (SplayLinks == NULL) {

                //
                //  No overlapping nodes were found, try to find successor
                //

                if (GreaterThan) {

                    //
                    //  Last node looked at was greater than the lock so it is
                    //  the place to pick up the enumeration
                    //

                    SplayLinks = LastSplayLinks;

                } else {

                    //
                    // Last node looked at was less than the lock so grab its successor
                    //

                    if (LastSplayLinks) {

                        SplayLinks = RtlRealSuccessor(LastSplayLinks);
                    }
                }

            } else {

                //
                //  Found an overlapping lock, see if it is the last returned
                //

                for (;
                    SplayLinks;
                    SplayLinks = RtlRealSuccessor(SplayLinks)) {

                    ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

                    if (ContinuationPointer == ExLock &&
                        (ULONGLONG)FileLockInfo.StartingByte.QuadPart == (ULONGLONG)ExLock->LockInfo.StartingByte.QuadPart &&
                        (ULONGLONG)FileLockInfo.Length.QuadPart == (ULONGLONG)ExLock->LockInfo.Length.QuadPart &&
                        FileLockInfo.Key == ExLock->LockInfo.Key &&
                        FileLockInfo.FileObject == ExLock->LockInfo.FileObject &&
                        FileLockInfo.ProcessId == ExLock->LockInfo.ProcessId) {

                        //
                        //  Found last returned, dig up its successor
                        //

                        SplayLinks = RtlRealSuccessor(SplayLinks);

                        //
                        //  Got the node cold, so we're done
                        //

                        break;
                    }

                    //
                    //  This lock overlapped and was not the last returned. In fact, since this lock would
                    //  have conflicted with the last returned we know it could not have been returned
                    //  before, so this should be returned to the caller.
                    //
                    //  However, if it is a zero length lock we are looking for and a zero length lock we hit,
                    //  we are at the beginning of a run we need to inspect. If we cannot find the last lock
                    //  we returned, resume the enumeration at the beginning of the run.
                    //

                    if (ExLock->LockInfo.Length.QuadPart != 0 || FileLockInfo.Length.QuadPart != 0) {

                        break;
                    }

                    //
                    //  Keep wandering down the run
                    //
                }
            }

            //
            //  Were we able to find a lock to return?
            //

            if (SplayLinks == NULL) {

                //
                //  There aren't any more exclusive locks, fall over to the shared tree
                //

                SplayLinks = LockInfo->LockQueue.SharedLockTree;

                if (SplayLinks) {

                    while (RtlLeftChild(SplayLinks)) {

                        SplayLinks = RtlLeftChild(SplayLinks);
                    }

                    Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links);
                    ShLock = CONTAINING_RECORD(Node->Locks.Next, SH_LOCK, Link);

                    FileLockInfo = ShLock->LockInfo;
                    ContinuationPointer = ShLock;
                    FoundReturnable = TRUE;
                }

            } else {

                //
                //  This is the lock to return
                //

                ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

                FileLockInfo = ExLock->LockInfo;
                ContinuationPointer = ExLock;
                FoundReturnable = TRUE;
            }

        } else {

            //
            //  Continue enumeration in the shared lock tree
            //

            Node = NULL;

            SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockInfo->LockQueue.SharedLockTree,
                                                              &FileLockInfo.StartingByte,
                                                              &FileLockInfo.EndingByte,
                                                              &LastSplayLinks,
                                                              &GreaterThan );

            if (SplayLinks == NULL) {

                //
                //  No overlapping nodes were found
                //

                if (GreaterThan) {

                    //
                    //  Last node looked at was greater than the lock so it is
                    //  the place to pick up the enumeration
                    //

                    if (LastSplayLinks) {

                        SplayLinks = LastSplayLinks;
                        Node = CONTAINING_RECORD( LastSplayLinks, LOCKTREE_NODE, Links );
                    }

                } else {

                    //
                    // Last node looked at was less than the lock so grab its successor
                    //

                    if (LastSplayLinks) {

                        SplayLinks = RtlRealSuccessor(LastSplayLinks);

                        if (SplayLinks) {

                            Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
                        }
                    }
                }

            } else {

                //
                //  Grab the node we found
                //

                Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
            }

            //
            //  If we have a node to look at, it may still not contain the the last returned lock
            //  if this isn't synchronized.
            //

            if (Node != NULL) {

                //
                //    Walk down the locks at this node looking for the last returned lock
                //

                for (Link = Node->Locks.Next;
                     Link;
                     Link = Link->Next) {

                    //
                    //  Get a pointer to the current lock record
                    //

                    ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                    //
                    // See if it's a match
                    //

                    if (ContinuationPointer == ShLock &&
                        (ULONGLONG)FileLockInfo.StartingByte.QuadPart == (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart &&
                        (ULONGLONG)FileLockInfo.Length.QuadPart == (ULONGLONG)ShLock->LockInfo.Length.QuadPart &&
                        FileLockInfo.Key == ShLock->LockInfo.Key &&
                        FileLockInfo.FileObject == ShLock->LockInfo.FileObject &&
                        FileLockInfo.ProcessId == ShLock->LockInfo.ProcessId) {

                        Link = Link->Next;
                        break;
                    }

                    //
                    // See if we passed by its slot
                    //

                    if ((ULONGLONG)FileLockInfo.StartingByte.QuadPart < (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart) {

                        break;
                    }
                }

                if (Link == NULL) {

                    //
                    //  This node doesn't contain the successor, so move
                    //  up to the successor node in the tree and return the
                    //  first lock. If we're actually at the end of the tree
                    //  we just fall off the end correctly.
                    //

                    SplayLinks = RtlRealSuccessor(SplayLinks);

                    if (SplayLinks) {

                        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

                        Link = Node->Locks.Next;
                    }
                }

                if (Link) {

                    //
                    //  Found a Lock to return, copy it to the stack
                    //

                    ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                    FileLockInfo = ShLock->LockInfo;
                    ContinuationPointer = ShLock;
                    FoundReturnable = TRUE;
                }

            }
        }

    } else {

        //
        //  Restarting the enumeration. Find leftmost node in the exclusive tree and hand back
        //  the first lock, falling over to the shared if no exclusive locks are applied
        //

        if (LockInfo->LockQueue.ExclusiveLockTree) {

            SplayLinks = LockInfo->LockQueue.ExclusiveLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

            FileLockInfo = ExLock->LockInfo;
            ContinuationPointer = ExLock;
            FoundReturnable = TRUE;

        } else {

            if (LockInfo->LockQueue.SharedLockTree) {

                SplayLinks = LockInfo->LockQueue.SharedLockTree;

                while (RtlLeftChild(SplayLinks) != NULL) {

                    SplayLinks = RtlLeftChild(SplayLinks);
                }

                Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
                ShLock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );

                FileLockInfo = ShLock->LockInfo;
                ContinuationPointer = ShLock;
                FoundReturnable = TRUE;
            }
        }
    }

    //
    //  Release all the lock queues
    //

    FsRtlReleaseLockQueue (&LockInfo->LockQueue, OldIrql);

    if (!FoundReturnable) {

        //
        //  No returnable lock was found, end of list
        //

        return NULL;
    }

    //
    // Update current enum location information
    //

    FileLock->LastReturnedLockInfo = FileLockInfo;
    FileLock->LastReturnedLock = ContinuationPointer;

    //
    // Return lock record to caller
    //

    return &FileLock->LastReturnedLockInfo;
}


BOOLEAN
FsRtlCheckNoSharedConflict (
   IN PLOCK_QUEUE LockQueue,
   IN PLARGE_INTEGER Starting,
   IN PLARGE_INTEGER Ending
   )
/*++

Routine Description:

    This routine checks to see if there is overlap in the shared locks with
    the given range. It is intended for use in the write access check path
    so that a rebalance will occur.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the key to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request doesn't conflict in
        entire specified byte range, and FALSE otherwise

--*/
{
    PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
    PLOCKTREE_NODE Node;

    SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                      Starting,
                                                      Ending,
                                                      &BeginLinks,
                                                      NULL);

    if (BeginLinks) {

        LockQueue->SharedLockTree = RtlSplay(BeginLinks);
    }

    //
    //  If this node is holey, we'll have to walk the whole thing.
    //

    if (SplayLinks) {

        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

        if (Node->HoleyNode) {

            return (BOOLEAN)(FsRtlFindFirstOverlapInNode( Node, Starting, Ending ) == NULL);
        }

        //
        //  Overlapping non-holey node, so we do have shared lock conflict.
        //

        return FALSE;
    }

    //
    //  No node overlaps.
    //

    return TRUE;
}


BOOLEAN
FsRtlCheckNoExclusiveConflict (
    IN PLOCK_QUEUE LockQueue,
    IN PLARGE_INTEGER Starting,
    IN PLARGE_INTEGER Ending,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    )
/*++

Routine Description:

    This routine checks to see if there is conflict in the exclusive locks with
    a given range and identifying tuple of key, fileobject and process. This is
    for part of the read access path.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the key to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request doesn't conflict in
        entire specified byte range, and FALSE otherwise

--*/
{
    PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
    PEX_LOCK Lock;
    BOOLEAN Status = TRUE;

    //
    //  Find the node to begin the search at and go
    //

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              Starting,
                                                              Ending,
                                                              &BeginLinks,
                                                              NULL);
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        //
        //  If the current lock is greater than the end of the range we're
        //  looking for then the the user doesn't conflict
        //
        //  if (Ending < Lock->StartingByte) ...
        //

        if ((ULONGLONG)Ending->QuadPart < (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart) {

            DebugTrace(0, Dbg, "FsRtlCheckForExclusiveConflict, Ending < Lock->StartingByte\n", 0);

            break;
        }

        //
        //  Check for any overlap with the request. The test for
        //  overlap is that starting byte is less than or equal to the locks
        //  ending byte, and the ending byte is greater than or equal to the
        //  locks starting byte.  We already tested for this latter case in
        //  the preceding statement.
        //
        //  if (Starting <= Lock->StartingByte + Lock->Length - 1) ...
        //

        if ((ULONGLONG)Starting->QuadPart <= (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            //  This request overlaps the lock. We cannot grant the request
            //  if the file object, process id, and key do not match. Otherwise
            //  we'll continue looping looking at locks
            //

            if ((Lock->LockInfo.FileObject != FileObject) ||
                (Lock->LockInfo.ProcessId != ProcessId) ||
                (Lock->LockInfo.Key != Key)) {

                DebugTrace(0, Dbg, "FsRtlCheckForExclusiveConflict, Range locked already\n", 0);

                Status = FALSE;
                break;
            }
        }
    }

    if (BeginLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(BeginLinks);
    }

    //
    //  We searched the entire range without a conflict so we'll note no conflict
    //

    return Status;
}


BOOLEAN
FsRtlFastCheckLockForRead (
    __in PFILE_LOCK FileLock,
    __in PLARGE_INTEGER StartingByte,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in PFILE_OBJECT FileObject,
    __in PVOID ProcessId
    )

/*++

Routine Description:

    This routine checks to see if the caller has read access to the
    indicated range due to file locks.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request has read access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    LARGE_INTEGER Starting;
    LARGE_INTEGER Ending;

    PLOCK_INFO            LockInfo;
    PLOCK_QUEUE           LockQueue;
    KIRQL                 OldIrql;
    PFILE_LOCK_INFO       LastLock;
    BOOLEAN               Status;

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No lock info\n", 0);
        return TRUE;
    }

    //
    // If there isn't an exclusive lock then we can immediately grant access
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL) {
        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No exlocks present\n", 0);
        return TRUE;
    }

    //
    // If length is zero then automatically give grant access
    //

    if ((ULONGLONG)Length->QuadPart == 0) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, Length == 0\n", 0);
        return TRUE;
    }

    //
    //  Get our starting and ending byte position
    //

    Starting = *StartingByte;
    Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    //
    // Now check lock queue
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  If the range ends below the lowest existing lock, this read is OK.
    //

    if ( ((ULONGLONG)Ending.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) ) {
        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead (below lowest lock)\n", 0);

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  If the caller just locked this range, he can read it.
    //

    LastLock = (PFILE_LOCK_INFO)FileObject->LastLock;
    if ((LastLock != NULL) &&
        ((ULONGLONG)Starting.QuadPart >= (ULONGLONG)LastLock->StartingByte.QuadPart) &&
        ((ULONGLONG)Ending.QuadPart <= (ULONGLONG)LastLock->EndingByte.QuadPart) &&
        (LastLock->Key == Key) &&
        (LastLock->ProcessId == ProcessId)) {

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  Check the exclusive locks for a conflict. It is impossible to have
    //  a read conflict with any shared lock.
    //

    Status = FsRtlCheckNoExclusiveConflict(LockQueue, &Starting, &Ending, Key, FileObject, ProcessId);

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return Status;
}


BOOLEAN
FsRtlFastCheckLockForWrite (
    __in PFILE_LOCK FileLock,
    __in PLARGE_INTEGER StartingByte,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in PVOID FileObject,
    __in PVOID ProcessId
    )

/*++

Routine Description:

    This routine checks to see if the caller has write access to the
    indicated range due to file locks

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request has write access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    LARGE_INTEGER Starting;
    LARGE_INTEGER Ending;

    PLOCK_INFO              LockInfo;
    PLOCK_QUEUE             LockQueue;
    KIRQL                   OldIrql;
    PFILE_LOCK_INFO         LastLock;
    BOOLEAN                 Status;

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No lock info\n", 0);
        return TRUE;
    }

    //
    //  If there isn't a lock then we can immediately grant access
    //

    if (LockInfo->LockQueue.SharedLockTree == NULL && LockInfo->LockQueue.ExclusiveLockTree == NULL) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite, No locks present\n", 0);
        return TRUE;
    }

    //
    //  If length is zero then automatically grant access
    //

    if ((ULONGLONG)Length->QuadPart == 0) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite, Length == 0\n", 0);
        return TRUE;
    }

    //
    //  Get our starting and ending byte position
    //

    Starting = *StartingByte;
    Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    //
    //  Now check lock queue
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  If the range ends below the lowest existing lock, this write is OK.
    //

    if ( ((ULONGLONG)Ending.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) ) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite (below lowest lock)\n", 0);

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  If the caller just locked this range exclusively, he can write it.
    //

    LastLock = (PFILE_LOCK_INFO)((PFILE_OBJECT)FileObject)->LastLock;
    if ((LastLock != NULL) &&
        ((ULONGLONG)Starting.QuadPart >= (ULONGLONG)LastLock->StartingByte.QuadPart) &&
        ((ULONGLONG)Ending.QuadPart <= (ULONGLONG)LastLock->EndingByte.QuadPart) &&
        (LastLock->Key == Key) &&
        (LastLock->ProcessId == ProcessId) &&
        LastLock->ExclusiveLock) {

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  Check the shared locks for overlap. Any overlap in the shared locks is fatal.
    //

    Status = FsRtlCheckNoSharedConflict(LockQueue, &Starting, &Ending);

    if (Status == TRUE) {

        //
        //  No overlap in the shared locks, so check the exclusive locks for overlap.
        //

        Status = FsRtlCheckNoExclusiveConflict(LockQueue, &Starting, &Ending, Key, FileObject, ProcessId);
    }

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return Status;
}


VOID
FsRtlSplitLocks (
    IN PLOCKTREE_NODE ParentNode,
    IN PSINGLE_LIST_ENTRY *pStartLink,
    IN PLARGE_INTEGER LastShadowedByte,
    IN PLARGE_INTEGER GlueOffset
    )

/*++

Routine Description:

    This routine examines and possibly splits off shared locks associated
    with a node into new nodes of the lock tree. Called from routines that
    have just deleted locks.

    The arguments that supply the initial conditions for the operation are
    optional if the node is known to be holey.

Arguments:

    ParentNode- Supplies the node the locks are coming from

    pStartLink - Supplies the pointer to the link address of the start of the
        range of locks in the ParentNode's locklist that need to be checked

    LastShadowedByte - Supplies the last byte offset that needs to be checked

    GlueOffset - Supplies the maximum offset affected by locks prior to this
        point in the list

Return Value:

    BOOLEAN - True if the split was successful, False otherwise.  The node will
        be marked as Holey if the split could not occur.

--*/

{
    PSH_LOCK                Lock;
    PLOCKTREE_NODE          NewNode;
    PSINGLE_LIST_ENTRY      Link, *pLink, *NextpLink;
    LARGE_INTEGER           MaxOffset = {0}, StartOffset = {0}, HaltOffset;

    LOGICAL                 ExtentValid;
    LOGICAL                 FailedHoleySplit = FALSE;

    //
    //  There are two cases: the node is holey or not.  If the node is holey, at some
    //  point we failed to get resources to complete a split, so despite our caller's
    //  good intentions we need to go over the entire node.
    //

    if (ParentNode->HoleyNode) {

        //
        //  Just move the starting link back to the front.  The maximum offset and
        //  starting offset of the node will be initialized in the loop.  We also turn
        //  off the holey flag, which will be turned on again as appropriate.
        //

        pStartLink = &ParentNode->Locks.Next;
        ParentNode->HoleyNode = FALSE;

        HaltOffset.QuadPart = ParentNode->Extent;

    } else {

        HaltOffset = *LastShadowedByte;
        MaxOffset = *GlueOffset;
        StartOffset.QuadPart = 0;

        if (!ParentNode->Locks.Next ||
            (ULONGLONG)HaltOffset.QuadPart <= (ULONGLONG)MaxOffset.QuadPart) {

            //
            //  The parent node is not there, doesn't have links associated, or the
            //  last possible byte that is affected by the operation our caller made
            //  is interior to the max extent of all locks still in this node - in
            //  which case there is nothing that needs to be done.
            //

            return;
        }
    }

    //
    //  If the extent of the node is past the last byte affected by whatever
    //  operations were done to this node, we can avoid the linear scan of
    //  the list past that last affected byte since we already know the
    //  extent of the entire list! If it is not (note that it would have to
    //  be equal - by defintion) then we need to recalculate the extents of
    //  all nodes we touch in this operation.
    //

    ExtentValid = (ParentNode->Extent > (ULONGLONG)HaltOffset.QuadPart);

    for (pLink = pStartLink;
         (Link = *pLink) != NULL;
         pLink = NextpLink) {

        NextpLink = &Link->Next;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        if (ParentNode->Locks.Next == *pLink) {

            //
            //  We're at the first lock in the node, and we know that we're going to leave
            //  at least one lock here. Skip over that lock. We also know that the max
            //  offset must be that locks's ending byte - make sure it is. Note that this
            //  code is *exactly* the same as the update MaxOffset code at the bottom of
            //  the loop.
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;

            //
            //  Set the starting offset of the node.  This is only an issue for zero length
            //  locks, so that we can figure out what is going on if we split a node and wind
            //  up with some number of "overlapped" zero length locks at the front of the new
            //  node.  We must be able to notice this case, and not think that each needs to
            //  be in a separate node.
            //

            StartOffset.QuadPart = Lock->LockInfo.StartingByte.QuadPart;

            //
            //  If extents are invalid we also need to set it in case this turns out to
            //  be the only lock at this node.
            //

            if (!ExtentValid) {

                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;
            }

            continue;
        }

        //
        //  If the lock begins at a byte offset greater than the maximum offset seen to this
        //  point, AND this is not a zero length node starting at the beginning of this node,
        //  break the node.  The second half of the test keeps co-incident zero length locks
        //  in the same node. (zero length lock ---> starting = ending + 1).
        //

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)MaxOffset.QuadPart &&
            !(Lock->LockInfo.Length.QuadPart == 0 &&
              Lock->LockInfo.StartingByte.QuadPart == StartOffset.QuadPart)) {

            //
            //  Break the node up here
            //

            NewNode = FsRtlAllocateLockTreeNode();

            if (NewNode == NULL) {

                //
                //  If we are out of resources, this node is now holey - we know that the locks at
                //  this node do not completely cover the indicated range.  Keep splitting for two
                //  reasons: more resources may become available, and we must keep updating the
                //  node's extent if it is known to be invalid.
                //

                //
                //  Now if this node was already holey it is not possible to state that, if we
                //  manage to split if further as we keep walking, that the resulting "left" node
                //  is not holey.  See below.
                //

                if (ParentNode->HoleyNode) {

                    FailedHoleySplit = TRUE;
                }

                ParentNode->HoleyNode = TRUE;

            } else {

                //
                //  Initialize the node.
                //

                RtlInitializeSplayLinks(&NewNode->Links);
                NewNode->HoleyNode = FALSE;

                //
                //  Find the spot in the tree to take the new node(s). If the current node has
                //  a free right child, we use it, else find the successor node and use its
                //  left child. One of these cases must be available since we know there are
                //  no nodes between this node and its successor.
                //

                if (RtlRightChild(&ParentNode->Links) == NULL) {

                    RtlInsertAsRightChild(&ParentNode->Links, &NewNode->Links);

                } else {

                    ASSERT(RtlLeftChild(RtlRealSuccessor(&ParentNode->Links)) == NULL);
                    RtlInsertAsLeftChild(RtlRealSuccessor(&ParentNode->Links), &NewNode->Links);
                }

                //
                //  Move the remaining locks over to the new node and fix up extents
                //

                NewNode->Locks.Next = *pLink;
                *pLink = NULL;

                NewNode->Tail.Next = ParentNode->Tail.Next;
                ParentNode->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );

                //
                //  This will cause us to fall into the first-lock clause above on the next pass
                //

                NextpLink = &NewNode->Locks.Next;

                //
                // The new node's extent is now copied from the parent. The old node's extent must be
                // the maximum offset we have seen to this point.
                //
                // Note that if ExtentValid is true, that must mean that the lock ending at that extent
                // is in the new node since if it was in the old node we wouldn't have been able to split.
                //

                NewNode->Extent = ParentNode->Extent;
                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;

                //
                //  The parent node can no longer be holey if we have not failed a split in this node.
                //

                if (!FailedHoleySplit) {

                    ParentNode->HoleyNode = FALSE;

                } else {

                    //
                    //  So reset the failure flag for the new node.
                    //

                    FailedHoleySplit = FALSE;
                }

                //
                //  Move over to the new node.
                //

                ParentNode = NewNode;

                continue;
            }
        }

        if (ExtentValid &&
            (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)HaltOffset.QuadPart) {

            //
            //  Our extents are good and this lock is past the shadow, so we can stop
            //

            return;
        }

        if ((ULONGLONG)MaxOffset.QuadPart < (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            //  Update maximum offset
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;

            if (!ExtentValid) {

                //
                //  Extents are not good so we must update the extent
                //

                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;
            }
        }
    }

    //
    //  Reached the end of the list, so update the extent (case of all subsequent locks
    //  having been interior to GlueOffset)
    //

    ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;

    return;
}


VOID
FsRtlPrivateRemoveLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    General purpose cleanup routine.  Finds the given lock structure
    and removes it from the file lock list. Differs from UnlockSingle
    only in that it disables the UnlockRoutine of the FileLock and
    optionalizes walking the waiting locks list.

Arguments:

    FileLock - Supplies the file's lock structure supposedly containing a stale lock

    FileLockInfo - Supplies file lock data being freed

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    if (FileLockInfo->ExclusiveLock) {

        //
        //  We must find it in the exclusive lock tree
        //

        Status = FsRtlFastUnlockSingleExclusive( LockInfo,

                                                 FileLockInfo->FileObject,
                                                 &FileLockInfo->StartingByte,
                                                 &FileLockInfo->Length,
                                                 FileLockInfo->ProcessId,
                                                 FileLockInfo->Key,

                                                 NULL,
                                                 TRUE,
                                                 CheckForWaiters );

        ASSERT( Status == STATUS_SUCCESS);

    } else {

        //
        //  We must find it in the shared lock tree
        //

        Status = FsRtlFastUnlockSingleShared( LockInfo,

                                              FileLockInfo->FileObject,
                                              &FileLockInfo->StartingByte,
                                              &FileLockInfo->Length,
                                              FileLockInfo->ProcessId,
                                              FileLockInfo->Key,

                                              NULL,
                                              TRUE,
                                              CheckForWaiters );

        ASSERT( Status == STATUS_SUCCESS);
    }

    return;
}


NTSTATUS
FsRtlFastUnlockSingle (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in LARGE_INTEGER UNALIGNED *FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in_opt PVOID Context,
    __in BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the current locks
    associated with the specified file lock.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    AlreadySynchronized - Indicates that the caller has already synchronized
        access to the file lock so the fields in the file lock and
        be updated without further locking, but not the queues.

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    NTSTATUS Status;

    //
    //  AlreadySynchronized is obsolete.
    //

    UNREFERENCED_PARAMETER (AlreadySynchronized);

    if (FileLock->LockInformation == NULL) {

        //
        //  Fast exit - no locks are applied
        //

        return STATUS_RANGE_NOT_LOCKED;
    }

    Status = FsRtlFastUnlockSingleExclusive( FileLock->LockInformation,
                                             FileObject,
                                             FileOffset,
                                             Length,
                                             ProcessId,
                                             Key,
                                             Context,
                                             FALSE,
                                             TRUE );

    if (Status == STATUS_SUCCESS) {

        //
        //  Found and unlocked in the exclusive tree, so we're done
        //

        return Status;
    }

    Status = FsRtlFastUnlockSingleShared( FileLock->LockInformation,
                                          FileObject,
                                          FileOffset,
                                          Length,
                                          ProcessId,
                                          Key,
                                          Context,
                                          FALSE,
                                          TRUE );

    return Status;
}


NTSTATUS
FsRtlFastUnlockSingleShared (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the current locks
    associated with the specified file lock.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    LockInfo - Supplies the lock data being operated on

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    IgnoreUnlockRoutine - indicates that the filelock's unlock routine
        should not be called on lock removal (for removal of aborted
        locks)

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    PSINGLE_LIST_ENTRY      *pLink, Link;
    KIRQL                   OldIrql;

    PLOCK_QUEUE             LockQueue;
    PRTL_SPLAY_LINKS        SplayLinks;
    LARGE_INTEGER           EndingOffset, MaxOffset;
    PLOCKTREE_NODE          Node;
    LARGE_INTEGER           AlignedFileOffset;

    //
    //  General case - search the outstanding lock queue for this lock
    //

    AlignedFileOffset = *FileOffset;

    LockQueue = &LockInfo->LockQueue;

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  Check for the no locks currently held
    //

    if (LockQueue->SharedLockTree == NULL) {

        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Find the overlapping node, if it exists, to search. Note that
    //  we don't have to go through more than one node in the tree
    //  since we are assuming this is an existing lock.
    //

    EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                      &AlignedFileOffset,
                                                      &EndingOffset,
                                                      NULL,
                                                      NULL );

    if (SplayLinks == NULL) {

        //
        //  No node in the tree overlaps this range, so we're done
        //

        FsRtlReleaseLockQueue(LockQueue, OldIrql);

        return STATUS_RANGE_NOT_LOCKED;
    }

    Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
    MaxOffset.QuadPart = 0;

    for (pLink = &Node->Locks.Next;
         (Link = *pLink) != NULL;
         pLink = &Link->Next) {

        PSH_LOCK Lock;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        DebugTrace(0, Dbg, "Sh Top of Loop, Lock = %08lx\n", Lock );

        if ((Lock->LockInfo.FileObject == FileObject) &&
            (Lock->LockInfo.ProcessId == ProcessId) &&
            (Lock->LockInfo.Key == Key) &&
            ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &&
            ((ULONGLONG)Lock->LockInfo.Length.QuadPart == (ULONGLONG)Length->QuadPart)) {

            DebugTrace(0, Dbg, "Sh Found one to unlock\n", 0);

            //
            //  We have an exact match so now is the time to delete this
            //  lock.  Remove the lock from the list, then call the
            //  optional unlock routine, then delete the lock.
            //

            if (FileObject->LastLock == &Lock->LockInfo) {

                FileObject->LastLock = NULL;
            }

            if (*pLink == Node->Tail.Next) {

                //
                //  Deleting the tail node of the list. Safe even if deleting the
                //  first node since this implies we're also deleting the last node
                //  in the node which means we'll delete the node ...
                //

                Node->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
            }

            //
            //  Snip the deleted lock
            //

            *pLink = Link->Next;

            if (pLink == &Node->Locks.Next) {

                //
                //  Deleted first lock in node
                //

                if (Node->Locks.Next == NULL) {

                    //
                    // Just deleted last lock on this node, so free it
                    //

                    LockQueue->SharedLockTree = RtlDelete(SplayLinks);

                    FsRtlFreeLockTreeNode(Node);

                    Node = NULL;
                }

                if (LockInfo->LowestLockOffset != 0xffffffff &&
                    LockInfo->LowestLockOffset == Lock->LockInfo.StartingByte.LowPart) {

                    //
                    //  This was the lowest lock in the trees, reset the lowest lock offset
                    //

                    FsRtlPrivateResetLowestLockOffset(LockInfo);
                }
            }

            //
            //  Now the fun begins. It may be the case that the lock just snipped from
            //  the chain was gluing locks at this node together, so we need to
            //  inspect the chain.
            //

            if (Node) {

                FsRtlSplitLocks(Node, pLink, &Lock->LockInfo.EndingByte, &MaxOffset);
            }

            if (!IgnoreUnlockRoutine && LockInfo->UnlockRoutine != NULL) {

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &Lock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

            }

            FsRtlFreeSharedLock( Lock );

            //
            //  See if there are additional waiting locks that we can
            //  now release.
            //

            if (CheckForWaiters && LockQueue->WaitingLocks.Next) {

                FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );
            }

            FsRtlReleaseLockQueue( LockQueue, OldIrql );

            return STATUS_SUCCESS;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)AlignedFileOffset.QuadPart) {

            //
            //  The current lock begins at a byte offset greater than the range we are seeking
            //  to unlock. This range must therefore not be locked.
            //

            break;
        }

        if ((ULONGLONG)MaxOffset.QuadPart < (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            // Maintain the maximum offset affected by locks up to this point.
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;
        }
    }

    //
    //  Lock was not found, return to our caller
    //

    FsRtlReleaseLockQueue(LockQueue, OldIrql);
    return STATUS_RANGE_NOT_LOCKED;
}


NTSTATUS
FsRtlFastUnlockSingleExclusive (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the exclusive locks
    associated with the specified lock data.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    LockInfo - Supplies the lock data being operated on

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    IgnoreUnlockRoutine - indicates that the filelock's unlock routine
        should not be called on lock removal (for removal of aborted
        locks)

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    KIRQL                   OldIrql;
    PLOCK_QUEUE             LockQueue;
    PRTL_SPLAY_LINKS        SplayLinks;
    LARGE_INTEGER           EndingOffset;
    PEX_LOCK                Lock;
    LARGE_INTEGER           AlignedFileOffset;

    //
    //  General case - search the outstanding lock queue for this lock
    //

    AlignedFileOffset = *FileOffset;

    LockQueue = &LockInfo->LockQueue;

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  Check for the no locks currently held
    //

    if (LockQueue->ExclusiveLockTree == NULL) {

        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Find the overlapping lock, if it exists. Note that this is usually
    //  the only lock we need to check since we are assuming this is an
    //  existing lock. However, if the lock is a zero length lock we will
    //  have a run of locks to check.
    //

    EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &AlignedFileOffset,
                                                              &EndingOffset,
                                                              NULL,
                                                              NULL );
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        if ((Lock->LockInfo.FileObject == FileObject) &&
            (Lock->LockInfo.ProcessId == ProcessId) &&
            (Lock->LockInfo.Key == Key) &&
            ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &&
            ((ULONGLONG)Lock->LockInfo.Length.QuadPart == (ULONGLONG)Length->QuadPart)) {

            DebugTrace(0, Dbg, "Ex Found one to unlock\n", 0);

            //
            //  We have an exact match so now is the time to delete this
            //  lock.  Remove the lock from the list, then call the
            //  optional unlock routine, then delete the lock.
            //

            if (FileObject->LastLock == &Lock->LockInfo) {

                FileObject->LastLock = NULL;
            }

            //
            //  Snip the deleted lock
            //

            LockQueue->ExclusiveLockTree = RtlDelete(&Lock->Links);

            if (LockInfo->LowestLockOffset != 0xffffffff &&
                LockInfo->LowestLockOffset == Lock->LockInfo.StartingByte.LowPart) {

                //
                //  This was the lowest lock in the tree, so reset the lowest lock
                //  offset
                //

                FsRtlPrivateResetLowestLockOffset(LockInfo);
            }

            if (!IgnoreUnlockRoutine && LockInfo->UnlockRoutine != NULL) {

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &Lock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

            }

            FsRtlFreeExclusiveLock( Lock );

            //
            //  See if there are additional waiting locks that we can
            //  now release.
            //

            if (CheckForWaiters && LockQueue->WaitingLocks.Next) {

                FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );
            }

            FsRtlReleaseLockQueue( LockQueue, OldIrql );

            return STATUS_SUCCESS;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)AlignedFileOffset.QuadPart) {

            //
            //  The current lock begins at a byte offset greater than the range we are seeking
            //  to unlock. This range must therefore not be locked.
            //

            break;
        }
    }

    //
    //  Lock was not found, return to our caller
    //

    FsRtlReleaseLockQueue(LockQueue, OldIrql);
    return STATUS_RANGE_NOT_LOCKED;
}


NTSTATUS
FsRtlFastUnlockAll (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PEPROCESS ProcessId,
    __in_opt PVOID Context
    )

/*++

Routine Description:

    This routine performs an Unlock all operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object and process id are freed.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id associated with the locks to be
        freed

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    None

--*/

{
    return FsRtlPrivateFastUnlockAll(
                FileLock,
                FileObject,
                ProcessId,
                0, FALSE,           // No Key
                Context );
}


NTSTATUS
FsRtlFastUnlockAllByKey (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in_opt PVOID Context
    )

/*++

Routine Description:

    This routine performs an Unlock All by Key operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object, process id, and key are freed.  The input Irp
    is completed by this procedure

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id associated with the locks to be
        freed

    Key - Supplies the Key to use in this operation

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    return FsRtlPrivateFastUnlockAll(
                FileLock,
                FileObject,
                ProcessId,
                Key, TRUE,
                Context );

}


//
//  Local Support Routine
//

BOOLEAN
FsRtlPrivateLock (
    __in PFILE_LOCK FileLock,
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PLARGE_INTEGER Length,
    __in PEPROCESS ProcessId,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock,
    __out PIO_STATUS_BLOCK Iosb,
    __in_opt PIRP Irp,
    __in_opt PVOID Context,
    __in BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine performs a lock operation request.  This handles both the fast
    get lock and the Irp based get lock.  If the Irp is supplied then
    this routine will either complete the Irp or enqueue it as a waiting
    lock request.

Arguments:

    FileLock - Supplies the File Lock to work against

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    Iosb - Receives the Status if this operation is successful

    Context - Supplies the context with which to complete Irp with

    AlreadySynchronized - Indicates that the caller has already synchronized
        access to the file lock so the fields in the file lock and
        be updated without further locking, but not the queues.

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE otherwise.

--*/

{
    BOOLEAN Results = FALSE;
    BOOLEAN AccessGranted;
    BOOLEAN ViaFastCall;
    BOOLEAN ReleaseQueue;

    PLOCK_INFO  LockInfo;
    PLOCK_QUEUE LockQueue;
    KIRQL       OldIrql;
    FILE_LOCK_INFO FileLockInfo;

    UNREFERENCED_PARAMETER (AlreadySynchronized);

    DebugTrace(+1, Dbg, "FsRtlPrivateLock, FileLock = %08lx\n", FileLock);

    //
    //  If the irp is null then this is being called via the fast call method.
    //

    ViaFastCall = (BOOLEAN) !ARGUMENT_PRESENT( Irp );

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(+2, Dbg, "FsRtlPrivateLock, New LockInfo required\n", 0);

        //
        // No lock information on this FileLock, create the structure.
        //
        //

        if (!FsRtlPrivateInitializeFileLock (FileLock, ViaFastCall)) {

            return FALSE;
        }

        //
        // Set flag so file locks will be checked on the fast io
        // code paths
        //

        FileLock->FastIoIsQuestionable = TRUE;

        //
        // Pickup allocated lockinfo structure
        //

        LockInfo = (PLOCK_INFO) FileLock->LockInformation;
    }

    //
    // Assume success and build LockData structure prior to acquiring
    // the lock queue spinlock.  (mp perf enhancement)
    //

    FileLockInfo.StartingByte = *FileOffset;
    FileLockInfo.Length = *Length;
    FileLockInfo.EndingByte.QuadPart =
            (ULONGLONG)FileLockInfo.StartingByte.QuadPart + (ULONGLONG)FileLockInfo.Length.QuadPart - 1;

    FileLockInfo.Key = Key;
    FileLockInfo.FileObject = FileObject;
    FileLockInfo.ProcessId = ProcessId;
    FileLockInfo.ExclusiveLock = ExclusiveLock;

    LockQueue = &LockInfo->LockQueue;

    //
    //  Now we need to actually run through our current lock queue.
    //

    ReleaseQueue = TRUE;
    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    try {

        //
        //  Case on whether we're trying to take out an exclusive lock or
        //  a shared lock.  And in both cases try to get appropriate access.
        //

        if (ExclusiveLock) {

            DebugTrace(0, Dbg, "Check for write access\n", 0);

            AccessGranted = FsRtlPrivateCheckForExclusiveLockAccess(
                                LockQueue,
                                &FileLockInfo );

        } else {

            DebugTrace(0, Dbg, "Check for read access\n", 0);

            AccessGranted = FsRtlPrivateCheckForSharedLockAccess(
                                LockQueue,
                                &FileLockInfo );
        }

        //
        //  Now AccessGranted tells us whether we can really get the access
        //  for the range we want
        //

        if (!AccessGranted) {

            DebugTrace(0, Dbg, "We do not have access\n", 0);

            //
            //  We cannot read/write to the range, so we cannot take out
            //  the lock.  Now if the user wanted to fail immediately then
            //  we'll complete the Irp, otherwise we'll enqueue this Irp
            //  to the waiting lock queue
            //

            if (FailImmediately) {

                //
                //  Set our status and return, the finally clause will
                //  complete the request
                //

                DebugTrace(0, Dbg, "And we fail immediately\n", 0);

                Iosb->Status = STATUS_LOCK_NOT_GRANTED;
                try_return( Results = TRUE );

            } else if (ARGUMENT_PRESENT(Irp)) {

                PWAITING_LOCK WaitingLock;

                DebugTrace(0, Dbg, "And we enqueue the Irp for later\n", 0);

                //
                //  Allocate a new waiting record, set it to point to the
                //  waiting Irp, and insert it in the tail of the waiting
                //  locks queue
                //

                WaitingLock = FsRtlAllocateWaitingLock();

                //
                //  Simply raise out if we can't allocate.
                //

                if (WaitingLock == NULL) {

                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                WaitingLock->Irp = Irp;
                WaitingLock->Context = Context;
                WaitingLock->CompleteLockIrpRoutine = LockInfo->CompleteLockIrpRoutine;
                IoMarkIrpPending( Irp );

                //
                // Add WaitingLock WaitingLockQueue
                //

                WaitingLock->Link.Next = NULL;
                if (LockQueue->WaitingLocks.Next == NULL) {

                    //
                    // Create new list
                    //

                    LockQueue->WaitingLocks.Next = &WaitingLock->Link;
                    LockQueue->WaitingLocksTail.Next = &WaitingLock->Link;

                } else {

                    //
                    // Add waiter to tail of list
                    //

                    LockQueue->WaitingLocksTail.Next->Next = &WaitingLock->Link;
                    LockQueue->WaitingLocksTail.Next = &WaitingLock->Link;
                }


                //
                //  Setup IRP in case it's canceled - then set the
                //  IRP's cancel routine
                //

                Irp->IoStatus.Information = (ULONG_PTR)LockInfo;
                IoSetCancelRoutine( Irp, FsRtlPrivateCancelFileLockIrp );

                if (Irp->Cancel) {

                    //
                    // Pull the cancel routine off of the IRP - if it is not
                    // NULL, this means we won the race with IoCancelIrp and
                    // will be responsible for cancelling the IRP synchronously.
                    // If NULL, we lost and our cancel routine is already being
                    // called for us.
                    //
                    // This must be done while holding the lock queue down since
                    // this is how we synchronize with the cancel.
                    //

                    if (IoSetCancelRoutine( Irp, NULL )) {

                        //
                        // Irp's cancel routine was not called, do it ourselves.
                        // Indicate to the cancel routine that he does not need
                        // to release the cancel spinlock by passing a NULL DO.
                        //
                        // The queue will be dropped in order to complete the Irp.
                        // We communicate the previous IRQL through the Irp itself.
                        //

                        Irp->CancelIrql = OldIrql;
                        FsRtlPrivateCancelFileLockIrp( NULL, Irp );
                        ReleaseQueue = FALSE;
                    }
                }

                Iosb->Status = STATUS_PENDING;
                try_return( Results = TRUE );

            } else {

                try_return( Results = FALSE );
            }
        }

        DebugTrace(0, Dbg, "We have access\n", 0);

        if (!FsRtlPrivateInsertLock( LockInfo, FileObject, &FileLockInfo )) {

            //
            //  Resource exhaustion will cause us to fail here.  Via the fast call, indicate
            //  that it may be worthwhile to go around again via the Irp based path.  If we
            //  are already there, simply raise out.
            //

            if (ViaFastCall) {

                try_return( Results = FALSE );

            } else {

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

        } else {

            Iosb->Status = STATUS_SUCCESS;
        }

        //
        //  At long last, we're done.
        //

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (ReleaseQueue) {

            FsRtlReleaseLockQueue(LockQueue, OldIrql);
        }

        //
        //  Complete the request provided we were given one and it is not a pending status
        //

        if (!AbnormalTermination() && ARGUMENT_PRESENT(Irp) && (Iosb->Status != STATUS_PENDING)) {

            NTSTATUS NewStatus;

            //
            //  We must reference the fileobject for the case that the IRP completion
            //  fails and we need to lift the lock.  Although the only reason we have
            //  to touch the fileobject in the remove case is to reset the LastLock field,
            //  we have no way of knowing if we will race with a reference count drop
            //  and lose.
            //

            ObReferenceObject( FileObject );

            //
            //  Complete the request, if the don't get back success then
            //  we need to possibly remove the lock that we just
            //  inserted.
            //

            FsRtlCompleteLockIrp(
                LockInfo,
                Context,
                Irp,
                Iosb->Status,
                &NewStatus,
                FileObject );

            if (!NT_SUCCESS(NewStatus) && NT_SUCCESS(Iosb->Status) ) {

                //
                // Irp failed, remove the lock which was added
                //

                FsRtlPrivateRemoveLock (
                    LockInfo,
                    &FileLockInfo,
                    TRUE );
            }

            //
            //  Lift our private reference to the fileobject. This may induce deletion.
            //

            ObDereferenceObject( FileObject );

            Iosb->Status = NewStatus;
        }

        DebugTrace(-1, Dbg, "FsRtlPrivateLock -> %08lx\n", Results);
    }

    //
    //  and return to our caller
    //

    return Results;
}


//
//  Internal Support Routine
//

BOOLEAN
FsRtlPrivateInsertLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN PFILE_LOCK_INFO FileLockInfo
    )

/*++

Routine Description:

    This routine fills in a new lock record of the appropriate type and inserts
    it into the lock information.

Arguments:

    LockInfo - Supplies the lock being modified

    FileObject - The associated file object to update hints in

    FileLockInfo - Supplies the new lock data to add to the lock queue

Return Value:

    BOOLEAN - True if the insert was successful, False if no resources were available
        to complete the operation.

--*/

{
    //
    //  Now add the lock to the appropriate tree.
    //

    if (FileLockInfo->ExclusiveLock) {

        PEX_LOCK ExLock;

        ExLock = FsRtlAllocateExclusiveLock();

        if (ExLock == NULL) {

            return FALSE;
        }

        ExLock->LockInfo = *FileLockInfo;

        FsRtlPrivateInsertExclusiveLock( &LockInfo->LockQueue, ExLock );

        FileObject->LastLock = &ExLock->LockInfo;

    } else {

        PSH_LOCK ShLock;

        ShLock = FsRtlAllocateSharedLock();

        if (ShLock == NULL) {

            return FALSE;
        }

        ShLock->LockInfo = *FileLockInfo;

        if (!FsRtlPrivateInsertSharedLock( &LockInfo->LockQueue, ShLock )) {

            return FALSE;
        }

        FileObject->LastLock = &ShLock->LockInfo;
    }

    //
    //  Fix up the lowest lock offset if need be
    //

    if ((ULONGLONG)FileLockInfo->StartingByte.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) {

        ASSERT( FileLockInfo->StartingByte.HighPart == 0 );
        LockInfo->LowestLockOffset = FileLockInfo->StartingByte.LowPart;
    }

    return TRUE;
}


//
//  Internal Support Routine
//

BOOLEAN
FsRtlPrivateInsertSharedLock (
    IN PLOCK_QUEUE LockQueue,
    IN PSH_LOCK NewLock
    )

/*++

Routine Description:

    This routine adds a new shared lock record to the File lock's current
    lock queue. Locks are inserted into nodes ordered by their starting byte.

Arguments:

    LockQueue - Supplies the lock queue being modified

    NewLock - Supplies the new shared lock to add to the lock queue

Return Value:

    BOOLEAN - True if the insert was successful, False if no resources were available
        to complete the operation.

--*/
{
    PSINGLE_LIST_ENTRY pLink, Link;
    PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
    PLOCKTREE_NODE Node, NextNode;
    PSH_LOCK NextLock;
    BOOLEAN GreaterThan;

    OverlappedSplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                                &NewLock->LockInfo.StartingByte,
                                                                &NewLock->LockInfo.EndingByte,
                                                                &ParentSplayLinks,
                                                                &GreaterThan );

    if (OverlappedSplayLinks == NULL) {

        //
        //  Simple insert case, build a new node
        //

        NextNode = FsRtlAllocateLockTreeNode();

        //
        //  If no resources are available, simply fail now.
        //

        if (NextNode == NULL) {

            return FALSE;
        }

        RtlInitializeSplayLinks(&NextNode->Links);
        NextNode->HoleyNode = FALSE;

        NextNode->Locks.Next = NextNode->Tail.Next = &NewLock->Link;
        NextNode->Extent = (ULONGLONG)NewLock->LockInfo.EndingByte.QuadPart;
        NewLock->Link.Next = NULL;

        if (ParentSplayLinks) {

            //
            //  We have a real parent node in the tree
            //

            if (GreaterThan) {

                ASSERT(RtlLeftChild(ParentSplayLinks) == NULL);
                RtlInsertAsLeftChild(ParentSplayLinks, &NextNode->Links);

            } else {

                ASSERT(RtlRightChild(ParentSplayLinks) == NULL);
                RtlInsertAsRightChild(ParentSplayLinks, &NextNode->Links);
            }

            //
            //  Splay all new nodes in the tree
            //

            LockQueue->SharedLockTree = RtlSplay(&NextNode->Links);

        } else {

            //
            //  First node in the tree
            //

            LockQueue->SharedLockTree = &NextNode->Links;
        }

        return TRUE;
    }

    //
    //  Now we examine the node to see if it is holey as a result of a resource-failed split.
    //  If it is, we must complete the split before adding the new lock.
    //

    Node = CONTAINING_RECORD( OverlappedSplayLinks, LOCKTREE_NODE, Links );

    //
    //  Search down the overlapped node finding the position for the new lock
    //

    for (pLink = &Node->Locks;
         (Link = pLink->Next) != NULL;
         pLink = Link) {

        PSH_LOCK Lock;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        //
        //  We sort locks on this list first by starting byte, then by whether the length is zero or not.
        //  This is important so that zero length locks appear prior to non-zero length locks, so that
        //  they are split out of nodes into the tree in the correct order.
        //
        //  if (NewLock->StartingByte <= Lock->StartingByte) ...
        //

        if (((ULONGLONG)NewLock->LockInfo.StartingByte.QuadPart < (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart) ||

            ((ULONGLONG)NewLock->LockInfo.StartingByte.QuadPart == (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart &&
             (NewLock->LockInfo.Length.QuadPart == 0 || Lock->LockInfo.Length.QuadPart != 0))) {

            break;
        }
    }

    //
    //  At this point pLink points to the record that comes right after
    //  the new lock that we're inserting so we can simply push the
    //  newlock into the entrylist
    //

    DebugTrace(0, Dbg, "InsertSharedLock, Insert Before = %08lx\n", Link);

    if (pLink->Next == NULL) {

        //
        //    Adding onto the tail of the list
        //

        Node->Tail.Next = &NewLock->Link;
    }

    NewLock->Link.Next = pLink->Next;
    pLink->Next = &NewLock->Link;

    //
    //  And splay the node we inserted into
    //

    LockQueue->SharedLockTree = RtlSplay(OverlappedSplayLinks);

    if ((ULONGLONG)NewLock->LockInfo.EndingByte.QuadPart > Node->Extent) {

        //
        //  The new lock extends the range of this node, so fix up the extent
        //

        Node->Extent = NewLock->LockInfo.EndingByte.QuadPart;

        //
        //  Walk across the remainder of the tree integrating newly overlapping
        //  nodes into the node we just inserted the new lock into.  Note that
        //  this isn't so much a walk as a repeated examination of our successor's
        //  until one does not overlap (or we hit the end).
        //

        ParentSplayLinks = OverlappedSplayLinks;

        for (OverlappedSplayLinks = RtlRealSuccessor(ParentSplayLinks);
             OverlappedSplayLinks;
             OverlappedSplayLinks = RtlRealSuccessor(ParentSplayLinks)) {

            NextNode = CONTAINING_RECORD( OverlappedSplayLinks, LOCKTREE_NODE, Links );
            NextLock = CONTAINING_RECORD( NextNode->Locks.Next, SH_LOCK, Link );

            if ((ULONGLONG)NextLock->LockInfo.StartingByte.QuadPart > Node->Extent) {

                //
                //  This node is not overlapped, so stop
                //

                break;
            }

            //
            //  If we are integrating a holey node into a non-holey node, try to split
            //  the node first.  It will be better to get this done with a smaller node
            //  than a big, fully integrated one.  Note that we are guaranteed that the
            //  node will remain a candidate for integration since the first lock on the
            //  node will still be there, and overlaps.
            //

            if (!Node->HoleyNode && NextNode->HoleyNode) {

                FsRtlSplitLocks( NextNode, NULL, NULL, NULL );
            }

            //
            //  Integrate the locks in this node into our list
            //

            Node->Tail.Next->Next = NextNode->Locks.Next;
            Node->Tail.Next = NextNode->Tail.Next;

            if (NextNode->Extent > Node->Extent) {

                //
                //  If the node we just swallowed was (still!) holey, we perhaps made this
                //  node holey too.  The resolution of this is left to the lock split we will
                //  perform after integration is complete.
                //
                //  Note that if the extent of the node we are swallowing is interior
                //  to the current node, we just covered whatever holes it contained.
                //

                if (NextNode->HoleyNode) {

                    Node->HoleyNode = TRUE;
                }

                Node->Extent = NextNode->Extent;
            }

            //
            //  Free the now empty node.
            //

            RtlDeleteNoSplay( OverlappedSplayLinks, &LockQueue->SharedLockTree );
            FsRtlFreeLockTreeNode( NextNode );
        }
    }

    //
    //  Now, perhaps this node is still holey.  For grins lets try one more time to split
    //  this thing apart.
    //

    if (Node->HoleyNode) {

        FsRtlSplitLocks( Node, NULL, NULL, NULL );
    }

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Internal Support Routine
//

VOID
FsRtlPrivateInsertExclusiveLock (
    IN PLOCK_QUEUE LockQueue,
    IN PEX_LOCK NewLock
    )

/*++

Routine Description:

    This routine adds a new exclusive lock record to the File lock's current
    lock queue.

Arguments:

    LockQueue - Supplies the lock queue being modified

    NewLock - Supplies the new exclusive lock to add to the lock queue

Return Value:

    None.

--*/

{
    PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
    BOOLEAN GreaterThan;

    OverlappedSplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                                   &NewLock->LockInfo.StartingByte,
                                                                   &NewLock->LockInfo.EndingByte,
                                                                   &ParentSplayLinks,
                                                                   &GreaterThan );

    //
    //  This is the exclusive tree. Nothing can overlap (caller is supposed to ensure this) unless
    //  the lock is a zero length lock, in which case we just insert it - still.
    //

    ASSERT(!OverlappedSplayLinks || NewLock->LockInfo.Length.QuadPart == 0);

    //
    //  Simple insert ...
    //

    RtlInitializeSplayLinks(&NewLock->Links);

    if (OverlappedSplayLinks) {

        //
        //  With zero length locks we have OverlappedSplayLinks at the starting point
        //  of a run of zero length locks, so we have to e flexible about where the new
        //  node is inserted.
        //

        if (RtlRightChild(OverlappedSplayLinks)) {

            //
            //  Right slot taken. We can use the left slot or go to the successor's left slot
            //

            if (RtlLeftChild(OverlappedSplayLinks)) {

                ASSERT(RtlLeftChild(RtlRealSuccessor(OverlappedSplayLinks)) == NULL);
                RtlInsertAsLeftChild(RtlRealSuccessor(OverlappedSplayLinks), &NewLock->Links);

            } else {

                RtlInsertAsLeftChild(OverlappedSplayLinks, &NewLock->Links);
            }


        } else {

            RtlInsertAsRightChild(OverlappedSplayLinks, &NewLock->Links);
        }

    } else if (ParentSplayLinks) {

        //
        //  We have a real parent node in the tree, and must be at a leaf since
        //  there was no overlap
        //

        if (GreaterThan) {

            ASSERT(RtlLeftChild(ParentSplayLinks) == NULL);
            RtlInsertAsLeftChild(ParentSplayLinks, &NewLock->Links);

        } else {

            ASSERT(RtlRightChild(ParentSplayLinks) == NULL);
            RtlInsertAsRightChild(ParentSplayLinks, &NewLock->Links);
        }

    } else {

        //
        //  First node in the tree
        //

        LockQueue->ExclusiveLockTree = &NewLock->Links;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support Routine
//

VOID
FsRtlPrivateCheckWaitingLocks (
    IN PLOCK_INFO   LockInfo,
    IN PLOCK_QUEUE  LockQueue,
    IN KIRQL        OldIrql
    )

/*++

Routine Description:

    This routine checks to see if any of the current waiting locks are now
    be satisfied, and if so it completes their IRPs.

Arguments:

    LockInfo - LockInfo which LockQueue is member of

    LockQueue - Supplies queue which needs to be checked

    OldIrql - Irql to restore when LockQueue is released

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY *pLink, Link;
    NTSTATUS NewStatus;
    BOOLEAN Result;

    pLink = &LockQueue->WaitingLocks.Next;
    while ((Link = *pLink) != NULL) {

        PWAITING_LOCK WaitingLock;

        PIRP Irp;
        PIO_STACK_LOCATION IrpSp;

        BOOLEAN AccessGranted;

        FILE_LOCK_INFO FileLockInfo;

        //
        //  Get a pointer to the waiting lock record
        //

        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks, Loop top, WaitingLock = %08lx\n", WaitingLock);

        //
        //  Get a local copy of the necessary fields we'll need to use
        //

        Irp = WaitingLock->Irp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        FileLockInfo.StartingByte  = IrpSp->Parameters.LockControl.ByteOffset;
        FileLockInfo.Length        = *IrpSp->Parameters.LockControl.Length;
        FileLockInfo.EndingByte.QuadPart =
            (ULONGLONG)FileLockInfo.StartingByte.QuadPart + (ULONGLONG)FileLockInfo.Length.QuadPart - 1;

        FileLockInfo.FileObject    = IrpSp->FileObject;
        FileLockInfo.ProcessId     = IoGetRequestorProcess( Irp );
        FileLockInfo.Key           = IrpSp->Parameters.LockControl.Key;
        FileLockInfo.ExclusiveLock = BooleanFlagOn(IrpSp->Flags, SL_EXCLUSIVE_LOCK);

        //
        //  Now case on whether we're trying to take out an exclusive lock or
        //  a shared lock.  And in both cases try to get the appropriate access
        //  For the exclusive case we send in a NULL file object and process
        //  id, this will ensure that the lookup does not give us write
        //  access through an exclusive lock.
        //

        if (FileLockInfo.ExclusiveLock) {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks do we have write access?\n", 0);

            AccessGranted = FsRtlPrivateCheckForExclusiveLockAccess(
                                LockQueue,
                                &FileLockInfo );
        } else {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks do we have read access?\n", 0);

            AccessGranted = FsRtlPrivateCheckForSharedLockAccess(
                                LockQueue,
                                &FileLockInfo );

        }

        //
        //  Now AccessGranted tells us whether we can really get the access for
        //  the range we want.
        //
        //  No matter what happens, this Irp must be completed now - even if we
        //  are resource starved.  User mode deadlock could be induced since there
        //  may no longer be a pending unlock to cause a rescan of the waiting
        //  list.
        //

        if (AccessGranted) {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks now has access\n", 0);

            //
            //  Clear the cancel routine
            //

            IoAcquireCancelSpinLock( &Irp->CancelIrql );
            IoSetCancelRoutine( Irp, NULL );

            //
            //  If the IRP got itself cancelled, it is cancelled and we won't grant it.
            //  The canceller is waiting for the queue spinlock right now.
            //

            if (Irp->Cancel) {

                AccessGranted = FALSE;
            }

            IoReleaseCancelSpinLock( Irp->CancelIrql );

            if (AccessGranted) {

                Result = FsRtlPrivateInsertLock( LockInfo, IrpSp->FileObject, &FileLockInfo );

                //
                //  Now we need to remove this granted waiter and complete
                //  it's irp.
                //

                *pLink = Link->Next;
                if (Link == LockQueue->WaitingLocksTail.Next) {
                    LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
                }

                //
                // Release LockQueue and complete this waiter
                //

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                //
                //  Reference the fileobject over the completion attempt so we can have a
                //  chance to cleanup safely if we fail
                //

                ObReferenceObject( FileLockInfo.FileObject );

                //
                //  Now we can complete the IRP, if we don't get back success
                //  from the completion routine then we remove the lock we just
                //  inserted.
                //

                FsRtlCompleteLockIrp( LockInfo,
                                      WaitingLock->Context,
                                      Irp,
                                      (Result? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES),
                                      &NewStatus,
                                      FileLockInfo.FileObject );

                if (Result && !NT_SUCCESS(NewStatus)) {

                    //
                    // Irp was not successful, remove lock if it was added.
                    //

                    FsRtlPrivateRemoveLock (
                        LockInfo,
                        &FileLockInfo,
                        FALSE );
                }

                //
                //  Drop our private reference to the fileobject
                //

                ObDereferenceObject( FileLockInfo.FileObject );

                //
                // Re-acquire queue lock
                //

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                //
                // Start scan over from beginning
                //

                pLink = &LockQueue->WaitingLocks.Next;


                //
                //  Free up pool
                //

                FsRtlFreeWaitingLock( WaitingLock );

                continue;
            }
        }

        DebugTrace( 0, Dbg, "FsRtlCheckWaitingLocks still no access\n", 0);

        //
        // Move to next lock
        //

        pLink = &Link->Next;
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
FsRtlPrivateCheckForExclusiveLockAccess (
    IN PLOCK_QUEUE LockQueue,
    IN PFILE_LOCK_INFO FileLockInfo
    )
/*++

Routine Description:

    This routine checks to see if the caller can get an exclusive lock on
    the indicated range due to file locks in the passed in lock queue.

    Assumes Lock queue is held by caller

Arguments:

    LockQueue - Queue which needs to be checked for collision

    FileLockInfo - Lock which is being checked


Return Value:

    BOOLEAN - TRUE if the indicated user can place the exclusive lock over the
        entire specified byte range, and FALSE otherwise

--*/

{
    PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks = NULL;
    PLOCKTREE_NODE Node;
    PSH_LOCK ShLock;
    PEX_LOCK ExLock;

    if (LockQueue->SharedLockTree &&
        (SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                           &FileLockInfo->StartingByte,
                                                           &FileLockInfo->EndingByte,
                                                           &LastSplayLinks, NULL))) {

        Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links);

        //
        //  If this node is holey, we'll have to walk the whole thing.
        //

        if (Node->HoleyNode) {

            ShLock = FsRtlFindFirstOverlapInNode( Node,
                                                  &FileLockInfo->StartingByte,
                                                  &FileLockInfo->EndingByte );

        } else {

            ShLock = CONTAINING_RECORD(Node->Locks.Next, SH_LOCK, Link);
        }

        //
        //  Look for overlap that we care about.  Perhaps no overlap existed in the holey case.
        //

        if (ShLock &&
            (FileLockInfo->Length.QuadPart || ShLock->LockInfo.Length.QuadPart)) {

            //
            //  If we are checking a nonzero extent and overlapped, it is fatal. If we
            //  are checking a zero extent and overlapped a nonzero extent, it is fatal.
            //

            return FALSE;
        }
    }

    if (LastSplayLinks) {

        LockQueue->SharedLockTree = RtlSplay(LastSplayLinks);
        LastSplayLinks = NULL;
    }

    if (LockQueue->ExclusiveLockTree &&
        (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &FileLockInfo->StartingByte,
                                                              &FileLockInfo->EndingByte,
                                                              &LastSplayLinks, NULL))) {

        ExLock = CONTAINING_RECORD(SplayLinks, EX_LOCK, Links);

        if (FileLockInfo->Length.QuadPart || ExLock->LockInfo.Length.QuadPart) {

            //
            //  If we are checking a nonzero extent and overlapped, it is fatal. If we
            //  are checking a zero extent and overlapped a nonzero extent, it is fatal.
            //

            return FALSE;
        }
    }

    if (LastSplayLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(LastSplayLinks);
    }

    //
    //  We searched the entire range without a conflict so we can grant
    //  the exclusive lock
    //

    return TRUE;
}


BOOLEAN
FsRtlPrivateCheckForSharedLockAccess (
    IN PLOCK_QUEUE LockQueue,
    IN PFILE_LOCK_INFO FileLockInfo
    )
/*++

Routine Description:

    This routine checks to see if the caller can get a shared lock on
    the indicated range due to file locks in the passed in lock queue.

    Assumes Lock queue is held by caller

Arguments:

    LockQueue - Queue which needs to be checked for collision

    FileLockInfo - Lock which is being checked

Arguments:

Return Value:

    BOOLEAN - TRUE if the indicated user can place the shared lock over
        entire specified byte range, and FALSE otherwise

--*/

{
    PEX_LOCK Lock;
    PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks;
    BOOLEAN Status = TRUE;

    //
    // If there are no exclusive locks, this is quick ...
    //

    if (LockQueue->ExclusiveLockTree == NULL) {

        return TRUE;
    }

    //
    //  No lock in the shared lock tree can prevent access, so just search the exclusive
    //  tree for conflict.
    //

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &FileLockInfo->StartingByte,
                                                              &FileLockInfo->EndingByte,
                                                              &LastSplayLinks, NULL);
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)FileLockInfo->EndingByte.QuadPart) {

            //
            //  This node is covering a range greater than the range we care about,
            //  so we're done
            //

            break;
        }

        //
        //  We may not be able to grant the request if the fileobject, processid,
        //  and key do not match.
        //

        if ((Lock->LockInfo.FileObject != FileLockInfo->FileObject) ||
             (Lock->LockInfo.ProcessId != FileLockInfo->ProcessId) ||
             (Lock->LockInfo.Key != FileLockInfo->Key)) {

            //
            //  We have a mismatch between caller and owner. It is ok not to conflict
            //  if the caller and owner will have/have zero length locks (zero length
            //  locks cannot conflict).
            //

            if (FileLockInfo->Length.QuadPart || Lock->LockInfo.Length.QuadPart) {

                Status = FALSE;
                break;
            }
        }
    }

    if (LastSplayLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(LastSplayLinks);
    }

    //
    //  We searched the entire range without a conflict so we can grant
    //  the shared lock
    //

    return Status;
}


VOID
FsRtlPrivateResetLowestLockOffset (
    PLOCK_INFO LockInfo
    )

/*++

Routine Description:

    This routine resets the lowest lock offset hint in a LOCK_INFO to
    the lowest lock offset currently held by a lock inside of the LOCK_INFO.

Arguments:

    LockInfo - the lock data to operate on

Return Value:

    None

--*/

{
    PEX_LOCK ExLock = NULL;
    PSH_LOCK ShLock = NULL;
    PFILE_LOCK_INFO LowestLockInfo = NULL;
    PRTL_SPLAY_LINKS SplayLinks;
    PLOCKTREE_NODE Node;

    //
    //  Fix up the lowest lock offset if we have non-empty trees and there was
    //  a lock in the low 32 bit region
    //

    if (LockInfo->LowestLockOffset != 0xffffffff &&
        (LockInfo->LockQueue.SharedLockTree != NULL ||
         LockInfo->LockQueue.ExclusiveLockTree != NULL)) {

        //
        //  Grab the lowest nodes in the trees
        //

        if (LockInfo->LockQueue.SharedLockTree) {

            SplayLinks = LockInfo->LockQueue.SharedLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
            ShLock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );
        }

        if (LockInfo->LockQueue.ExclusiveLockTree) {

            SplayLinks = LockInfo->LockQueue.ExclusiveLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );
        }

        //
        //  Figure out which of the lowest locks is actually lowest. We know that one of the lock
        //  trees at least has a lock, so if we have don't have exclusive locks then we do know
        //  we have shared locks ...
        //

        if (ExLock &&
            (!ShLock ||
             (ULONGLONG)ExLock->LockInfo.StartingByte.QuadPart < (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart)) {

            LowestLockInfo = &ExLock->LockInfo;

        } else {

            LowestLockInfo = &ShLock->LockInfo;
        }

        if (LowestLockInfo->StartingByte.HighPart == 0) {

            LockInfo->LowestLockOffset = LowestLockInfo->StartingByte.LowPart;

        } else {

            LockInfo->LowestLockOffset = 0xffffffff;
        }

    } else {

        //
        //  If there are no locks, set the lock offset high
        //

        LockInfo->LowestLockOffset = 0xffffffff;
    }
}


NTSTATUS
FsRtlPrivateFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN MatchKey,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine performs an Unlock all operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object and process id are freed.  Additionally,
    it is possible to free only those locks which also match a given
    key.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id associated with the locks to be
        freed

    Key - Supplies the Key to use in this operation

    MatchKey - Whether or not the Key must also match for lock to be freed.

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    None

--*/

{
    PLOCK_INFO              LockInfo;
    PLOCK_QUEUE             LockQueue;
    PSINGLE_LIST_ENTRY      *pLink, *SavepLink, Link;
    NTSTATUS                NewStatus;
    KIRQL                   OldIrql;
    LARGE_INTEGER           GlueOffset, EndingDeletedByte;
    BOOLEAN                 UnlockRoutine;
    PSH_LOCK                ShLock = NULL;
    PEX_LOCK                ExLock;
    PRTL_SPLAY_LINKS        SplayLinks, SuccessorLinks;
    PLOCKTREE_NODE          Node;


    DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, FileLock = %08lx\n", FileLock);

    if ((LockInfo = FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, No LockInfo\n", FileLock);
        return STATUS_RANGE_NOT_LOCKED;
    }

    FileObject->LastLock = NULL;

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue( LockQueue, &OldIrql );

    if (LockQueue->SharedLockTree == NULL && LockQueue->ExclusiveLockTree == NULL) {

        //
        // No locks on this FileLock
        //

        DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, No LockTrees\n", FileLock);
        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Remove all matching locks in the shared lock tree
    //

    if (LockQueue->SharedLockTree != NULL) {

        //
        //  Grab the lowest node in the tree
        //

        SplayLinks = LockQueue->SharedLockTree;

        while (RtlLeftChild(SplayLinks) != NULL) {

            SplayLinks = RtlLeftChild(SplayLinks);
        }

        //
        //  Walk all nodes in the tree
        //

        UnlockRoutine = FALSE;

        for (;
             SplayLinks;
             SplayLinks = SuccessorLinks) {

            Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links );

            //
            //  Save the next node because we may split this node apart in the process
            //  of deleting locks. It would be a waste of time to traverse those split
            //  nodes. The only case in which we will not have traversed the entire list
            //  before doing the split will be if there is an unlock routine attached
            //  to this FileLock in which case we will be restarting the entire scan
            //  anyway.
            //

            SuccessorLinks = RtlRealSuccessor(SplayLinks);

            //
            //  Search down the current lock queue looking for a match on
            //  the file object and process id
            //

            SavepLink = NULL;
            EndingDeletedByte.QuadPart = 0;
            GlueOffset.QuadPart = 0;

            pLink = &Node->Locks.Next;
            while ((Link = *pLink) != NULL) {

                ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                DebugTrace(0, Dbg, "Top of ShLock Loop, Lock = %08lx\n", ShLock );

                if ((ShLock->LockInfo.FileObject == FileObject) &&
                    (ShLock->LockInfo.ProcessId == ProcessId) &&
                    (!MatchKey || ShLock->LockInfo.Key == Key)) {

                    DebugTrace(0, Dbg, "Found one to unlock\n", 0);

                    //
                    //  We have a match so now is the time to delete this lock.
                    //  Save the necessary information to do the split node check.
                    //  Remove the lock from the list, then call the
                    //  optional unlock routine, then delete the lock.
                    //

                    if (SavepLink == NULL) {

                        //
                        //  Need to remember where the first lock was deleted
                        //

                        SavepLink = pLink;
                    }

                    if ((ULONGLONG)ShLock->LockInfo.EndingByte.QuadPart > (ULONGLONG)EndingDeletedByte.QuadPart) {

                        //
                        //  Need to remember where the last offset affected by deleted locks is
                        //

                        EndingDeletedByte.QuadPart = ShLock->LockInfo.EndingByte.QuadPart;
                    }

                    if (*pLink == Node->Tail.Next) {

                        //
                        //  Deleting the tail node of the list. Safe even if deleting the
                        //  first node since this implies we're also deleting the last node
                        //  in the node which means we'll delete the node ...
                        //

                        Node->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
                    }

                    *pLink = Link->Next;

                    if (LockInfo->UnlockRoutine != NULL) {

                        //
                        //  Signal a lock that needs to have a special unlock routine
                        //  called on it. This is complex to deal with since we'll have
                        //  to release the queue, call it, and reacquire - meaning we
                        //  also have to restart. But we still need to reorder the node
                        //  first ...
                        //

                        UnlockRoutine = TRUE;

                        break;
                    }

                    FsRtlFreeSharedLock( ShLock );

                } else {

                    //
                    // Move to next lock
                    //

                    pLink = &Link->Next;
                }

                if (SavepLink == NULL && (ULONGLONG)ShLock->LockInfo.EndingByte.QuadPart > (ULONGLONG)GlueOffset.QuadPart) {

                    //
                    //  Save the max offset until we have deleted our first node
                    //

                    GlueOffset.QuadPart = ShLock->LockInfo.EndingByte.QuadPart;
                }
            }

            if (SavepLink) {

                //
                //  Locks were actually deleted here, so we have to check the state of the node
                //

                if (Node->Locks.Next == NULL) {

                    //
                    //  We have just deleted everything at this node
                    //

                    LockQueue->SharedLockTree = RtlDelete( SplayLinks );

                    FsRtlFreeLockTreeNode( Node );

                } else {

                    //
                    //  Now that we have deleted all matching locks in this node, we do the
                    //  check on the node to split out any now non-overlapping locks. Conceptually,
                    //  we have deleted just one big lock that starts at the starting byte of the
                    //  first deleted lock and extends to the last byte of the last deleted lock.
                    //

                    FsRtlSplitLocks(Node, SavepLink, &EndingDeletedByte, &GlueOffset);
                }
            }

            if (UnlockRoutine) {

                //
                //  We dropped out of the node scan because we had a lock that needs extra
                //  processing during unlock. Do it.
                //

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &ShLock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                FsRtlFreeSharedLock( ShLock );

                UnlockRoutine = FALSE;

                //
                //  We have to restart the scan, because the list may have changed while
                //  we were in the unlock routine. Careful, because the tree may be empty.
                //

                if (SuccessorLinks = LockQueue->SharedLockTree) {

                    while (RtlLeftChild(SuccessorLinks) != NULL) {

                        SuccessorLinks = RtlLeftChild(SuccessorLinks);
                    }
                }
            }
        }
    }

    //
    //  Remove all matching locks in the exclusive lock tree
    //

    if (LockQueue->ExclusiveLockTree != NULL) {

        SplayLinks = LockQueue->ExclusiveLockTree;

        while (RtlLeftChild(SplayLinks) != NULL) {

            SplayLinks = RtlLeftChild(SplayLinks);
        }

        //
        //  Walk all nodes in the tree
        //

        UnlockRoutine = FALSE;

        for (; SplayLinks;
               SplayLinks = SuccessorLinks ) {

            SuccessorLinks = RtlRealSuccessor( SplayLinks );

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

            DebugTrace(0, Dbg, "Top of ExLock Loop, Lock = %08lx\n", ExLock );

            if ((ExLock->LockInfo.FileObject == FileObject) &&
                (ExLock->LockInfo.ProcessId == ProcessId) &&
                (!MatchKey || ExLock->LockInfo.Key == Key)) {

                LockQueue->ExclusiveLockTree = RtlDelete( &ExLock->Links );

                if (LockInfo->UnlockRoutine != NULL) {

                    //
                    //  We're dropping out of the node scan because we have a lock
                    //  that needs extra processing during unlock. Do it.
                    //

                    FsRtlReleaseLockQueue( LockQueue, OldIrql );

                    LockInfo->UnlockRoutine( Context, &ExLock->LockInfo );

                    FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                    //
                    //  We have to restart the scan, because the list may have changed while
                    //  we were in the unlock routine. Careful, because the tree may be empty.
                    //

                    if (SuccessorLinks = LockQueue->ExclusiveLockTree) {

                        while (RtlLeftChild( SuccessorLinks ) != NULL) {

                            SuccessorLinks = RtlLeftChild( SuccessorLinks );
                        }
                    }
                }

                FsRtlFreeExclusiveLock( ExLock );
            }
        }
    }

    //
    //  Search down the waiting lock queue looking for a match on the
    //  file object and process id.
    //

    pLink = &LockQueue->WaitingLocks.Next;
    while ((Link = *pLink) != NULL) {

        PWAITING_LOCK WaitingLock;
        PIRP WaitingIrp;
        PIO_STACK_LOCATION WaitingIrpSp;
        KIRQL   CancelIrql;

        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        DebugTrace(0, Dbg, "Top of Waiting Loop, WaitingLock = %08lx\n", WaitingLock);

        //
        //  Get a copy of the necessary fields we'll need to use
        //

        WaitingIrp = WaitingLock->Irp;
        WaitingIrpSp = IoGetCurrentIrpStackLocation( WaitingIrp );

        if ((FileObject == WaitingIrpSp->FileObject) &&
            (ProcessId == IoGetRequestorProcess( WaitingIrp )) &&
            (!MatchKey || Key == WaitingIrpSp->Parameters.LockControl.Key)) {

            DebugTrace(0, Dbg, "Found a waiting lock to abort\n", 0);

            //
            //  We now void the cancel routine in the irp
            //

            IoAcquireCancelSpinLock( &WaitingIrp->CancelIrql );
            IoSetCancelRoutine( WaitingIrp, NULL );

            //
            //  If this IRP got itself cancelled, it is cancelled.
            //

            CancelIrql = WaitingIrp->CancelIrql;

            if (WaitingIrp->Cancel) {

                WaitingIrp = NULL;
            }

            IoReleaseCancelSpinLock( CancelIrql );


            if (WaitingIrp) {

                WaitingIrp->IoStatus.Information = 0;

                //
                //  We have a match and the IRP, so now is the time to delete
                //  this waiter. But we must not mess up our link iteration
                //  variable.  We do this by simply starting the iteration over
                //  again, after we delete ourselves.  We also will deallocate
                //  the lock after we delete it.
                //

                *pLink = Link->Next;
                if (Link == LockQueue->WaitingLocksTail.Next) {
                    LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
                }

                FsRtlReleaseLockQueue(LockQueue, OldIrql);

                //
                //  And complete this lock request Irp
                //

                FsRtlCompleteLockIrp( LockInfo,
                                      WaitingLock->Context,
                                      WaitingIrp,
                                      STATUS_RANGE_NOT_LOCKED,
                                      &NewStatus,
                                      NULL );

                //
                // Reaqcuire lock queue spinlock and start over
                //

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                //
                // Start over
                //

                pLink = &LockQueue->WaitingLocks.Next;

                //
                // Put memory onto free list
                //

                FsRtlFreeWaitingLock( WaitingLock );
                continue;

            }
        }

        //
        // Move to next lock
        //

        pLink = &Link->Next;
    }

    //
    //  At this point we've gone through unlocking everything. So
    //  now try and release any waiting locks.
    //

    FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );

    //
    //  We deleted a (possible) bunch of locks, go repair the lowest lock offset
    //

    FsRtlPrivateResetLowestLockOffset( LockInfo );

    FsRtlReleaseLockQueue( LockQueue, OldIrql );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlFastUnlockAll -> VOID\n", 0);
    return STATUS_SUCCESS;
}


VOID
FsRtlPrivateCancelFileLockIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an irp saved in a
    waiting lock queue

Arguments:

    DeviceObject - Ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the FileLock
        structure for the lock is stored in the information field of the
        irp's iosb.

Return Value:

    none.

--*/

{
    PSINGLE_LIST_ENTRY *pLink, Link;
    PLOCK_INFO  LockInfo;
    PLOCK_QUEUE LockQueue;
    KIRQL       OldIrql;
    NTSTATUS    NewStatus;
    BOOLEAN     CollideCheck = FALSE;


    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  The information field is used to store a pointer to the file lock
    //  containing the irp
    //

    LockInfo = (PLOCK_INFO) (Irp->IoStatus.Information);

    //
    //  Iterate through the lock queue.
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Release the cancel spinlock and lock cancel collide if this is initiated by Io.
    //
    //  We already have the lock queue if this is the race fixup from ourselves,
    //  and the cancel Irql is in the Irp.
    //

    if (DeviceObject) {

        IoReleaseCancelSpinLock( Irp->CancelIrql );
        FsRtlAcquireCancelCollide( &OldIrql );

        //
        //  Indicate we will check the collide list first, as the lockqueue itself
        //  may be deallocated in a race with lock teardown.
        //

        CollideCheck = TRUE;
        pLink = &FsRtlFileLockCancelCollideList.Next;

    } else {

        OldIrql = Irp->CancelIrql;

        //
        //  We will iterate only the locks off of this specific queue.
        //

        pLink = &LockQueue->WaitingLocks.Next;
    }

    while (TRUE) {

        //
        //  Iterate through the waiting locks looking for the canceled one.
        //

        while ((Link = *pLink) != NULL) {

            PWAITING_LOCK WaitingLock;

            //
            //  Get a pointer to the waiting lock record
            //

            WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

            DebugTrace(0, Dbg, "FsRtlPrivateCancelFileLockIrp, Loop top, WaitingLock = %08lx\n", WaitingLock);

            if( WaitingLock->Irp != Irp ) {

                pLink = &Link->Next;
                continue;
            }

            //
            //  We've found it -- remove it from the list
            //

            *pLink = Link->Next;
            if (!CollideCheck && Link == LockQueue->WaitingLocksTail.Next) {

                LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
            }

            Irp->IoStatus.Information = 0;

            //
            //  Release the right lock and complete this waiter
            //

            if (CollideCheck) {

                FsRtlReleaseCancelCollide( OldIrql );

            } else {

                FsRtlReleaseLockQueue( LockQueue, OldIrql );
            }

            //
            //  Complete this waiter.  Note we pick the completion routine out
            //  of the waiting lock structure so we can surf over the collided
            //  cancel case.
            //

            FsRtlCompleteLockIrp( WaitingLock,
                                  WaitingLock->Context,
                                  Irp,
                                  STATUS_CANCELLED,
                                  &NewStatus,
                                  NULL );

            //
            //  Free up pool
            //

            FsRtlFreeWaitingLock( WaitingLock );

            //
            // Our job is done!
            //

            return;
        }

        //
        //  Flip over to the lock queue if we didn't find it on the collided list.
        //

        if (CollideCheck) {

            CollideCheck = FALSE;
            FsRtlAcquireLockQueueAtDpc( LockQueue );
            FsRtlReleaseCancelCollideFromDpc( OldIrql );
            pLink = &LockQueue->WaitingLocks.Next;

            continue;
        }

        break;
    }

    //
    //  Release lock queue.  This must actually not happen or we will have the
    //  potential to have had the IRP we were looking for come back unaware
    //  we wanted to cancel it.
    //

    ASSERT( FALSE );

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\largemcb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    LargeMcb.c

Abstract:

    The MCB routines provide support for maintaining an in-memory copy of
    the retrieval mapping information for a file.  The general idea is to
    have the file system lookup the retrieval mapping for a VBN once from
    the disk, add the mapping to the MCB structure, and then utilize the
    MCB to retrieve the mapping for subsequent accesses to the file.  A
    variable of type MCB is used to store the mapping information.

    The routines provided here allow the user to incrementally store some
    or all of the retrieval mapping for a file and to do so in any order.
    That is, the mapping can be inserted to the MCB structure all at once
    starting from the beginning and working to the end of the file, or it
    can be randomly scattered throughout the file.

    The package identifies each contiguous run of sectors mapping VBNs
    and LBNs independant of the order they are added to the MCB
    structure.  For example a user can define a mapping between VBN
    sector 0 and LBN sector 107, and between VBN sector 2 and LBN sector
    109.  The mapping now contains two runs each one sector in length.
    Now if the user adds an additional mapping between VBN sector 1 and
    LBN sector 106 the MCB structure will contain only one run 3 sectors
    in length.

    Concurrent access to the MCB structure is control by this package.

    The following routines are provided by this package:

      o  FsRtlInitializeMcb - Initialize a new MCB structure.  There
         should be one MCB for every opened file.  Each MCB structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeMcb - Uninitialize an MCB structure.  This call
         is used to cleanup any ancillary structures allocated and
         maintained by the MCB.  After being uninitialized the MCB must
         again be initialized before it can be used by the system.

      o  FsRtlAddMcbEntry - This routine adds a new range of mappings
         between LBNs and VBNs to the MCB structure.

      o  FsRtlRemoveMcbEntry - This routines removes an existing range of
         mappings between LBNs and VBNs from the MCB structure.

      o  FsRtlLookupMcbEntry - This routine returns the LBN mapped to by
         a VBN, and indicates, in sectors, the length of the run.

      o  FsRtlLookupLastMcbEntry - This routine returns the mapping for
         the largest VBN stored in the structure.

      o  FsRtlLookupLastMcbEntryAndIndex - This routine returns the mapping
         for the largest VBN stored in the structure as well as its index
         Note that calling LookupLastMcbEntry and NumberOfRunsInMcb cannot
         be synchronized except by the caller.

      o  FsRtlNumberOfRunsInMcb - This routine tells the caller total
         number of discontiguous sectors runs stored in the MCB
         structure.

      o  FsRtlGetNextMcbEntry - This routine returns the the caller the
         starting VBN and LBN of a given run stored in the MCB structure.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


//
//  Retrieval mapping data structures.  The following two structure together
//  are used to map a Vbn to an Lbn.  It is layed out as follows:
//
//
//  MCB:
//      +----------------+----------------+
//      |    PairCount   |MaximumPairCount|
//      +----------------+----------------+
//      |     Mapping    |    PoolType    |
//      +----------------+----------------+
//
//
//  MAPPING:
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : 0
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : PairCount
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     |
//      +----------------+----------------+
//
//                                          : MaximumPairCount
//
//  The pairs from 0 to PairCount - 1 are valid.  Given an index between
//  0 and PairCount - 1 (inclusive) it represents the following Vbn
//  to Lbn mapping information
//
//
//                     { if Index == 0 then 0
//      StartingVbn   {
//                     { if Index <> 0 then NextVbn[i-1]
//
//
//      EndingVbn      = NextVbn[i] - 1
//
//
//      StartingLbn    = Lbn[i]
//
//
//  To compute the mapping of a Vbn to an Lbn the following algorithm
//  is used
//
//      1. search through the pairs until we find the slot "i" that contains
//         the Vbn we after.  Report an error if none if found.
//
//      2. Lbn = StartingLbn + (Vbn - StartingVbn);
//
//  A hole in the allocation (i.e., a sparse allocation) is represented by
//  an Lbn value of -1 (note that is is different than Mcb.c).
//

#define UNUSED_LBN                       (-1)

typedef struct _MAPPING {
    VBN NextVbn;
    LBN Lbn;
} MAPPING;
typedef MAPPING *PMAPPING;

typedef struct _NONOPAQUE_BASE_MCB {
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PMAPPING Mapping;
} NONOPAQUE_BASE_MCB, *PNONOPAQUE_BASE_MCB;

//
//  A macro to return the size, in bytes, of a retrieval mapping structure
//

#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)->MaximumPairCount))

//
//  The parts of a run can be computed as follows:
//
//
//                StartingVbn(MCB,I)           Mapping[I].NextVbn
//                       |                             |
//                       V                             V
//
//        Run-(I-1)---+ +---------Run-(I)-----------+ +---Run-(I+1)
//
//                       A                         A
//                       |                         |
//                 Mapping[I].Lbn            EndingLbn(MCB,I)
//

#define PreviousEndingVbn(MCB,I) (                      \
    (VBN)((I) == 0 ? 0xffffffff : EndingVbn(MCB,(I)-1)) \
)

#define StartingVbn(MCB,I) (                                \
    (VBN)((I) == 0 ? 0 : (((MCB)->Mapping))[(I)-1].NextVbn) \
)

#define EndingVbn(MCB,I) (                     \
    (VBN)((((MCB)->Mapping)[(I)].NextVbn) - 1) \
)

#define NextStartingVbn(MCB,I) (                                \
    (VBN)((I) >= (MCB)->PairCount ? 0 : StartingVbn(MCB,(I)+1)) \
)




#define PreviousEndingLbn(MCB,I) (                      \
    (LBN)((I) == 0 ? UNUSED_LBN : EndingLbn(MCB,(I)-1)) \
)

#define StartingLbn(MCB,I) (         \
    (LBN)(((MCB)->Mapping)[(I)].Lbn) \
)

#define EndingLbn(MCB,I) (                                       \
    (LBN)(StartingLbn(MCB,I) == UNUSED_LBN ?                     \
          UNUSED_LBN :                                           \
          ((MCB)->Mapping[(I)].Lbn +                             \
           (MCB)->Mapping[(I)].NextVbn - StartingVbn(MCB,I) - 1) \
         )                                                       \
)

#define NextStartingLbn(MCB,I) (                                             \
    (LBN)((I) >= (MCB)->PairCount - 1 ? UNUSED_LBN : StartingLbn(MCB,(I)+1)) \
)

#define SectorsWithinRun(MCB,I) (                      \
    (ULONG)(EndingVbn(MCB,I) - StartingVbn(MCB,I) + 1) \
)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('mrSF')

//
//  A private routine to search a mapping structure for a Vbn
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PBASE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    );

VOID
FsRtlAddLargeEntry (
    IN PBASE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    );

VOID
FsRtlRemoveLargeEntry (
    IN PBASE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    );

//
//  Some private routines to handle common allocations.
//

#define FsRtlAllocateFirstMapping() \
    (PVOID)ExAllocateFromPagedLookasideList( &FsRtlFirstMappingLookasideList )

#define FsRtlFreeFirstMapping(Mapping) \
    ExFreeToPagedLookasideList( &FsRtlFirstMappingLookasideList, (Mapping) )

#define FsRtlAllocateFastMutex()      \
    ExAllocateFromNPagedLookasideList( &FsRtlFastMutexLookasideList )

#define FsRtlFreeFastMutex(FastMutex) \
    ExFreeToNPagedLookasideList( &FsRtlFastMutexLookasideList, (FastMutex) )

#pragma alloc_text(INIT, FsRtlInitializeLargeMcbs)
#pragma alloc_text(PAGE, FsRtlInitializeMcb)
#pragma alloc_text(PAGE, FsRtlUninitializeMcb)


//
//  Define a small cache of free mapping pairs structures and also the
//  initial size of the mapping pair
//

#define INITIAL_MAXIMUM_PAIR_COUNT       (15)

PAGED_LOOKASIDE_LIST FsRtlFirstMappingLookasideList;

//
//  The following lookaside is used to keep all the Fast Mutexes we will need to
//  boot contiguous.
//

NPAGED_LOOKASIDE_LIST FsRtlFastMutexLookasideList;


//
//  The following few routines define the small mcb package which is
//  implemented behind everyones back as large mcbs.  The only funny
//  thing we really need to do here is to make sure that unused Lbns
//  get returned as 0 and not -1.  This is the result of an historical
//  difference between the original Mcb and LargeMcb packages.
//

VOID
FsRtlInitializeMcb (
    __in PMCB Mcb,
    __in POOL_TYPE PoolType
    )
{
    PAGED_CODE();

    FsRtlInitializeLargeMcb( (PLARGE_MCB)Mcb,
                             PoolType );

    return;
}

VOID
FsRtlUninitializeMcb (
    __in PMCB Mcb
    )

{
    PAGED_CODE();

    FsRtlUninitializeLargeMcb( (PLARGE_MCB)Mcb );

    return;
}

VOID
FsRtlTruncateMcb (
    __in PMCB Mcb,
    __in VBN Vbn
    )
{
   PAGED_CODE();

   FsRtlTruncateLargeMcb( (PLARGE_MCB)Mcb,
                          (LONGLONG)(Vbn) );

   return;
}

BOOLEAN
FsRtlAddMcbEntry (
    __in PMCB Mcb,
    __in VBN Vbn,
    __in LBN Lbn,
    __in ULONG SectorCount
    )

{
    PAGED_CODE();

    return FsRtlAddLargeMcbEntry( (PLARGE_MCB)Mcb,
                                  (LONGLONG)(Vbn),
                                  (LONGLONG)(Lbn),
                                  (LONGLONG)(SectorCount) );
}

VOID
FsRtlRemoveMcbEntry (
    __in PMCB OpaqueMcb,
    __in VBN Vbn,
    __in ULONG SectorCount
    )

{
    PLARGE_MCB Mcb = (PLARGE_MCB)OpaqueMcb;

    PAGED_CODE();

    FsRtlRemoveLargeMcbEntry( Mcb, Vbn, SectorCount );
    return;
}

BOOLEAN
FsRtlLookupMcbEntry (
    __in PMCB Mcb,
    __in VBN Vbn,
    __out PLBN Lbn,
    __out_opt PULONG SectorCount,
    __out PULONG Index
    )

{
    BOOLEAN Result;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount = {0};

    Result = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    if (Result) {
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
        if (ARGUMENT_PRESENT(SectorCount)) { 
            *SectorCount = ((ULONG)LiSectorCount); 
        }
    }
    
    return Result;
}

BOOLEAN
FsRtlLookupLastMcbEntry (
    __in PMCB Mcb,
    __out PVBN Vbn,
    __out PLBN Lbn
    )

{
    BOOLEAN Result;
    LONGLONG LiVbn;
    LONGLONG LiLbn;

    PAGED_CODE();

    Result = FsRtlLookupLastLargeMcbEntry( (PLARGE_MCB)Mcb,
                                            &LiVbn,
                                            &LiLbn );

    if (Result) {
        *Vbn = ((ULONG)LiVbn);
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
    }

    return Result;
}

ULONG
FsRtlNumberOfRunsInMcb (
    __in PMCB Mcb
    )

{
    PAGED_CODE();

    return FsRtlNumberOfRunsInLargeMcb( (PLARGE_MCB)Mcb );
}

BOOLEAN
FsRtlGetNextMcbEntry (
    __in PMCB Mcb,
    __in ULONG RunIndex,
    __out PVBN Vbn,
    __out PLBN Lbn,
    __out PULONG SectorCount
    )

{
    BOOLEAN Result;
    LONGLONG LiVbn;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    PAGED_CODE();

    Result = FsRtlGetNextLargeMcbEntry( (PLARGE_MCB)Mcb,
                                         RunIndex,
                                         &LiVbn,
                                         &LiLbn,
                                         &LiSectorCount );

    if (Result) {
        *Vbn = ((ULONG)LiVbn);
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
        *SectorCount = ((ULONG)LiSectorCount);
    }
    
    return Result;
}


VOID
FsRtlInitializeLargeMcbs (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global portion of the large mcb package
    at system initialization time.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the lookaside of paged initial mapping arrays.
    //

    ExInitializePagedLookasideList( &FsRtlFirstMappingLookasideList,
                                    NULL,
                                    NULL,
                                    POOL_RAISE_IF_ALLOCATION_FAILURE,
                                    sizeof( MAPPING ) * INITIAL_MAXIMUM_PAIR_COUNT,
                                    'miSF',
                                    4 );

    //
    //  Initialize the Fast Mutex lookaside list.
    //

    ExInitializeNPagedLookasideList( &FsRtlFastMutexLookasideList,
                                     NULL,
                                     NULL,
                                     POOL_RAISE_IF_ALLOCATION_FAILURE,
                                     sizeof( FAST_MUTEX),
                                     'mfSF',
                                     32 );


}


VOID
FsRtlInitializeBaseMcb (
    __in PBASE_MCB Mcb,
    __in POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Mcb structure.  The caller must
    supply the memory for the Mcb structure.  This call must precede all
    other calls that set/query the Mcb structure.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal Mcb memory.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlInitializeBaseMcb, Mcb = %08lx\n", Mcb );

    //
    //  Initialize the fields in the Mcb
    //

    Mcb->PairCount = 0;
    Mcb->PoolType = PoolType;

    //
    //  Allocate a new buffer an initial size is one that will hold
    //  16 runs
    //

    if (PoolType == PagedPool) {
        Mcb->Mapping = FsRtlAllocateFirstMapping();
    } else {
        Mcb->Mapping = FsRtlpAllocatePool( Mcb->PoolType, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
    }

    Mcb->MaximumPairCount = INITIAL_MAXIMUM_PAIR_COUNT;

    //
    //  And return to our caller
    //

    return;
}



VOID
FsRtlInitializeLargeMcb (
    __in PLARGE_MCB Mcb,
    __in POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes the full large_mcb package by allocating the
    fast mutex and initializing the base mcb

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal Mcb memory.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlInitializeLargeMcb, Mcb = %08lx\n", Mcb );


    

    //
    //  Initialize the fast mutex
    //

    Mcb->GuardedMutex = FsRtlAllocateFastMutex();

    try {
        
        KeInitializeGuardedMutex( Mcb->GuardedMutex );
        FsRtlInitializeBaseMcb( &Mcb->BaseMcb, PoolType );


    } finally {

        //
        //  If this is an abnormal termination then we need to deallocate
        //  the GuardedMutex and/or mapping (but once the mapping is allocated,
        //  we can't raise).
        //

        if (AbnormalTermination()) {

            FsRtlFreeFastMutex( Mcb->GuardedMutex ); 
            Mcb->GuardedMutex = NULL;    
        }

        DebugTrace(-1, Dbg, "FsRtlInitializeLargeMcb -> VOID\n", 0 );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
FsRtlUninitializeBaseMcb (
    __in PBASE_MCB Mcb
    )

/*++

Routine Description:

    This routine uninitializes an Mcb structure.  After calling this routine
    the input Mcb structure must be re-initialized before being used again.

Arguments:

    Mcb - Supplies a pointer to the Mcb structure to uninitialize.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlUninitializeBaseMcb, Mcb = %08lx\n", Mcb );

    //
    //  Deallocate the mapping buffer
    //


    if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {
        FsRtlFreeFirstMapping( Mcb->Mapping );
    } else {
        ExFreePool( Mcb->Mapping );
    }

    DebugTrace(-1, Dbg, "FsRtlUninitializeLargeMcb -> VOID\n", 0 );
    return;
}



VOID
FsRtlUninitializeLargeMcb (
    __in PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This routine uninitializes an Mcb structure.  After calling this routine
    the input Mcb structure must be re-initialized before being used again.

Arguments:

    Mcb - Supplies a pointer to the Mcb structure to uninitialize.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlUninitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Protect against some user calling us to uninitialize an mcb twice
    //

    if (Mcb->GuardedMutex != NULL) {
        
        //
        //  Deallocate the FastMutex and base Mcb
        //

        FsRtlFreeFastMutex( Mcb->GuardedMutex );
        Mcb->GuardedMutex = NULL;
        FsRtlUninitializeBaseMcb( &Mcb->BaseMcb );
    }

    DebugTrace(-1, Dbg, "FsRtlUninitializeLargeMcb -> VOID\n", 0 );
    return;
}


VOID
FsRtlTruncateBaseMcb (
    __in PBASE_MCB Mcb,
    __in LONGLONG LargeVbn
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to the specified Vbn.
    After calling this routine the Mcb will only contain mappings
    up to and not including the input vbn.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    LargeVbn - Specifies the last Vbn at which is no longer to be
      mapped.

Return Value:

    None.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB) Mcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Index;

    DebugTrace(+1, Dbg, "FsRtlTruncateBaseMcb, Mcb = %08lx\n", BaseMcb );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (BaseMcb->PairCount == 0) ||
                                                  ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                   (((ULONG)LargeVbn) == 0xFFFFFFFF))));
    

    //
    //  Do a quick test to see if we are truncating the entire Mcb.
    //

    if (Vbn == 0) {

        BaseMcb->PairCount = 0;

    } else if (BaseMcb->PairCount > 0) {

        //
        //  Find the index for the entry with the last Vcn we want to keep.
        //  There is nothing to do if the Mcb already ends prior to
        //  this point.
        //

        if (FsRtlFindLargeIndex(Mcb, Vbn - 1, &Index)) {

            //
            //  If this entry currently describes a hole then
            //  truncate to the previous entry.
            //

            if (StartingLbn(BaseMcb, Index) == UNUSED_LBN) {

                BaseMcb->PairCount = Index;

            //
            //  Otherwise we will truncate the Mcb to this point.  Truncate
            //  the number of Vbns of this run if necessary.
            //

            } else {

                BaseMcb->PairCount = Index + 1;

                if (NextStartingVbn(BaseMcb, Index) > Vbn) {

                    (BaseMcb->Mapping)[Index].NextVbn = Vbn;
                }
            }
        }
    }

    //
    //  Now see if we can shrink the allocation for the mapping pairs.
    //  We'll shrink the mapping pair buffer if the new pair count will
    //  fit within a quarter of the current maximum pair count and the
    //  current maximum is greater than the initial pair count.
    //

    if ((BaseMcb->PairCount < (BaseMcb->MaximumPairCount / 4)) &&
        (BaseMcb->MaximumPairCount > INITIAL_MAXIMUM_PAIR_COUNT)) {

        ULONG NewMax;
        PMAPPING Mapping;

        //
        //  We need to allocate a new mapping so compute a new maximum pair
        //  count.  We'll allocate double the current pair count, but never
        //  less than the initial pair count.
        //

        NewMax = BaseMcb->PairCount * 2;

        if (NewMax < INITIAL_MAXIMUM_PAIR_COUNT) {
            NewMax = INITIAL_MAXIMUM_PAIR_COUNT;
        }

        //
        //  Be careful to trap failures due to resource exhaustion.
        //
            
        try {
                
            if (NewMax == INITIAL_MAXIMUM_PAIR_COUNT && BaseMcb->PoolType == PagedPool) {

                Mapping = FsRtlAllocateFirstMapping();

            } else {
        
                Mapping = FsRtlpAllocatePool( BaseMcb->PoolType, sizeof(MAPPING) * NewMax );
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

              Mapping = NULL;
        }

        //
        //  Now check if we really got a new buffer
        //

        if (Mapping != NULL) {

            //
            //  Now copy over the old mapping to the new buffer
            //

            RtlCopyMemory( Mapping, BaseMcb->Mapping, sizeof(MAPPING) * BaseMcb->PairCount );

            //
            //  Deallocate the old buffer.  This should never be the size of an
            //  initial mapping ...
            //

            ExFreePool( BaseMcb->Mapping );

            //
            //  And set up the new buffer in the Mcb
            //

            BaseMcb->Mapping = Mapping;
            BaseMcb->MaximumPairCount = NewMax;
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlTruncateLargeMcb -> VOID\n", 0 );
    return;
}


VOID
FsRtlTruncateLargeMcb (
    __in PLARGE_MCB Mcb,
    __in LONGLONG LargeVbn
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to the specified Vbn.
    After calling this routine the Mcb will only contain mappings
    up to and not including the input vbn.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    LargeVbn - Specifies the last Vbn at which is no longer to be
      mapped.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlTruncateLargeMcb, Mcb = %08lx\n", Mcb );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );
    FsRtlTruncateBaseMcb( &Mcb->BaseMcb, LargeVbn );
    KeReleaseGuardedMutex( Mcb->GuardedMutex );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlTruncateLargeMcb -> VOID\n", 0 );

    return;
}


NTKERNELAPI
VOID
FsRtlResetBaseMcb (
    __in PBASE_MCB Mcb
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to contain zero mapping
    pairs.  It does not shrink the mapping pairs array.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

Return Value:

    None.

--*/

{
    Mcb->PairCount = 0;
    return;
}



NTKERNELAPI
VOID
FsRtlResetLargeMcb (
    __in PLARGE_MCB Mcb,
    __in BOOLEAN SelfSynchronized
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to contain zero mapping
    pairs.  It does not shrink the mapping pairs array.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    SelfSynchronized - Indicates whether the caller is already synchronized
        with respect to the Mcb.

Return Value:

    None.

--*/

{
    if (SelfSynchronized) {
        
        //
        //  If we are self-synchronized, then all we do is clear out the 
        //  current mapping pair count.
        //
        
        Mcb->BaseMcb.PairCount = 0;
    
    } else {
        
        //
        //  Since we are not self-synchronized, we must serialize access to
        //  the Mcb before clearing the pair count
        //
        
        KeAcquireGuardedMutex( Mcb->GuardedMutex );
        Mcb->BaseMcb.PairCount = 0;
        KeReleaseGuardedMutex( Mcb->GuardedMutex );
    
    }

    return;
}


BOOLEAN
FsRtlAddBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __in LONGLONG LargeLbn,
    __in LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine is used to add a new mapping of VBNs to LBNs to an existing
    Mcb. The information added will map

        Vbn to Lbn,

        Vbn+1 to Lbn+1,...

        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).

    The mapping for the VBNs must not already exist in the Mcb.  If the
    mapping continues a previous run, then this routine will actually coalesce
    them into 1 run.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

    An input Lbn value of zero is illegal (i.e., the Mcb structure will never
    map a Vbn to a zero Lbn value).

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.

    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.

    SectorCount - Supplies the size of the new mapping run (in sectors).

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new
        Vbns did not collide with existing Vbns), and FALSE otherwise.  If
        FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    VBN Vbn = ((ULONG)LargeVbn);
    LBN Lbn = ((ULONG)LargeLbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    ULONG Index;

    VBN LastVbn;

    BOOLEAN Result;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeLbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeSectorCount)->HighPart == 0);

    DebugTrace(+1, Dbg, "FsRtlAddLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Lbn         = %08lx\n", Lbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    if (FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

        ULONG EndVbn = Vbn + SectorCount - 1;
        ULONG EndIndex;

        //
        //  First check the case where we are adding to an existing mcb run
        //  and if so then we will modify the insertion to complete the run
        //
        //      --ExistingRun--|      ==becomes==>  --ExistingRun--|
        //              |--NewRun--|                               |---|
        //
        //      --ExistingRun----|    ==becomes==> a noop
        //          |--NewRun--|
        //

        if (StartingLbn(BaseMcb, Index) != UNUSED_LBN) {

            //
            //  Check that the Lbn's line up between the new and existing run
            //

            if (Lbn != (StartingLbn(BaseMcb, Index) + (Vbn - StartingVbn(BaseMcb, Index)))) {

                //
                //  Let our caller know we couldn't insert the run.
                //

                try_return(Result = FALSE);
            }

            //
            //  Check if the new run is contained in the existing run
            //

            if (EndVbn <= EndingVbn(BaseMcb, Index)) {

                //
                //  Do nothing because the run is contained within the existing run
                //

                try_return(Result = TRUE);
            }

            //
            //  Otherwise we will simply trim off the request for the new run
            //  to not overlap with the existing run
            //

            Vbn = NextStartingVbn(BaseMcb, Index);
            Lbn = EndingLbn(BaseMcb, Index) + 1;

            ASSERT(EndVbn >= Vbn);

            SectorCount = EndVbn - Vbn + 1;

        //
        //  At this point the new run start in a hole, now check that if
        //  crosses into a non hole and if so then adjust new run to fit
        //  in the hole
        //
        //
        //            |--ExistingRun--  ==becomes==>        |--ExistingRun--
        //      |--NewRun--|                          |--New|
        //

        } else if (FsRtlFindLargeIndex(Mcb, EndVbn, &EndIndex) && (Index == (EndIndex-1))) {

            //
            //  Check that the Lbn's line up in the overlap
            //

            if (StartingLbn(BaseMcb, EndIndex) != Lbn + (StartingVbn(BaseMcb, EndIndex) - Vbn)) {

                //
                //  Let our caller know we couldn't insert the run.
                //

                try_return(Result = FALSE);
            }

            //
            //  Truncate the sector count to go up to but not include
            //  the existing run
            //

            SectorCount = StartingVbn(BaseMcb, EndIndex) - Vbn;
        }
    }

    //
    //  Find the index for the starting Vbn of our new run, if there isn't
    //  a hole found then index will be set to paircount.
    //

    if (((Index = Mcb->PairCount) == 0) ||
        (PreviousEndingVbn(BaseMcb,Index)+1 <= Vbn) ||
        !FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

        //
        //  We didn't find a mapping, therefore this new mapping must
        //  go on at the end of the current mapping.
        //
        //  See if we can just grow the last mapping in the current mcb.
        //  We can grow the last entry if (1) the Vbns follow on, and (2)
        //  the Lbns follow on.  We can only grow the last mapping if the
        //  index is not 0.
        //

        if ((Index != 0) &&
            (PreviousEndingVbn(BaseMcb,Index) + 1 == Vbn) &&
            (PreviousEndingLbn(BaseMcb,Index) + 1 == Lbn)) {

            //
            //      --LastRun--|---NewRun--|
            //

            //
            //  Extend the last run in the mcb
            //

            DebugTrace( 0, Dbg, "Continuing last run\n", 0);

            (BaseMcb->Mapping)[Mcb->PairCount-1].NextVbn += SectorCount;

            try_return (Result = TRUE);
        }

        //
        //  We couldn't grow the last mapping, now check to see if
        //  this is a continuation of the last Vbn (i.e., there isn't
        //  going to be a hole in the mapping).  Or if this is the first
        //  run in the mapping
        //

        if ((Vbn == 0) ||
            (PreviousEndingVbn(BaseMcb,Index) + 1 == Vbn)) {

            //
            //      --LastRun--||---NewRun--|
            //
            //      0:|--NewRun--|
            //

            //
            //  We only need to add one more run to the mcb, so make sure
            //  there is enough room for one.
            //

            DebugTrace( 0, Dbg, "Adding new contiguous last run\n", 0);

            FsRtlAddLargeEntry( Mcb, Index, 1 );

            //
            //  Add the new mapping
            //

            (BaseMcb->Mapping)[Index].Lbn = Lbn;
            (BaseMcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

            try_return (Result = TRUE);
        }

        //
        //  If we reach this point then there is going to be a hole in the
        //  mapping. and the mapping gets appended to the end of the current
        //  allocation.  So need to make room for two more runs in the mcb.
        //

        //
        //      --LastRun--|   hole   |---NewRun--|
        //
        //      0:  hole  |--NewRun--|
        //

        DebugTrace( 0, Dbg, "Adding new noncontiguous last run\n", 0);

        FsRtlAddLargeEntry( Mcb, Index, 2 );

        //
        //  Add the hole
        //

        (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
        (BaseMcb->Mapping)[Index].NextVbn = Vbn;

        //
        //  Add the new mapping
        //

        (BaseMcb->Mapping)[Index+1].Lbn = Lbn;
        (BaseMcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

        try_return (Result = TRUE);
    }

    //
    //  We found an index for the Vbn therefore we must be trying
    //  to fill up a hole in the mcb.  So first we need to check to make
    //  sure there really is a hole to be filled
    //

    LastVbn = Vbn + SectorCount - 1;

    if ((StartingLbn(BaseMcb,Index) == UNUSED_LBN) &&
        (StartingVbn(BaseMcb,Index) <= Vbn) && (LastVbn <= EndingVbn(BaseMcb,Index))) {

        //
        //  The mapping fits in this hole, but now here are the following
        //  cases we must consider for the new mapping
        //

        if ((StartingVbn(BaseMcb,Index) < Vbn) && (LastVbn < EndingVbn(BaseMcb,Index))) {

            //  Leaves a hole are both ends
            //
            //  --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--
            //
            //  0:  hole  |--NewRun--|  hole  |--FollowingRun--
            //

            DebugTrace( 0, Dbg, "Hole at both ends\n", 0);

            //
            //  Make room for two more entries.  The NextVbn field of the
            //  one we're shifting remains valid.
            //

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            //
            //  Add the first hole
            //

            (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
            (BaseMcb->Mapping)[Index].NextVbn = Vbn;

            //
            //  Add the new mapping
            //

            (BaseMcb->Mapping)[Index+1].Lbn = Lbn;
            (BaseMcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

            //
            //  The second hole is already set up by the add entry call, because
            //  that call just shift over the original hole to that slot
            //

            try_return (Result = TRUE);
        }

        if ((StartingVbn(BaseMcb,Index) == Vbn) && (LastVbn < EndingVbn(BaseMcb,Index))) {

            if (PreviousEndingLbn(BaseMcb,Index) + 1 == Lbn) {

                //
                //  Leaves a hole at the rear, and continues the earlier run
                //
                //  --PreviousRun--|--NewRun--|  hole  |--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at rear and continue\n", 0);

                //
                //  We just need to extend the previous run
                //

                (BaseMcb->Mapping)[Index-1].NextVbn += SectorCount;

                try_return (Result = TRUE);

            } else {

                //
                //  Leaves a hole at the rear, and does not continue the
                //  earlier run.  As occurs if index is zero.
                //
                //  --PreviousRun--||--NewRun--|  hole  |--FollowingRun--
                //
                //  0:|--NewRun--|  hole  |--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at rear and not continue\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Add the new mapping
                //

                (BaseMcb->Mapping)[Index].Lbn = Lbn;
                (BaseMcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                //
                //  The hole is already set up by the add entry call, because
                //  that call just shift over the original hole to that slot
                //

                try_return (Result = TRUE);
            }
        }

        if ((StartingVbn(BaseMcb,Index) < Vbn) && (LastVbn == EndingVbn(BaseMcb,Index))) {

            if (NextStartingLbn(BaseMcb,Index) == Lbn + SectorCount) {

                //
                //  Leaves a hole at the front, and continues the following run
                //
                //  --PreviousRun--|  hole  |--NewRun--|--FollowingRun--
                //
                //  0:  hole  |--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at front and continue\n", 0);

                //
                //  We just need to extend the following run
                //

                (BaseMcb->Mapping)[Index].NextVbn = Vbn;
                (BaseMcb->Mapping)[Index+1].Lbn = Lbn;

                try_return (Result = TRUE);

            } else {

                //
                //  Leaves a hole at the front, and does not continue the following
                //  run
                //
                //  --PreviousRun--|  hole  |--NewRun--||--FollowingRun--
                //
                //  0:  hole  |--NewRun--||--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at front and not continue\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Add the hole
                //

                (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
                (BaseMcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Add the new mapping
                //

                (BaseMcb->Mapping)[Index+1].Lbn = Lbn;

                try_return (Result = TRUE);
            }

        }

        if ((PreviousEndingLbn(BaseMcb,Index) + 1 == Lbn) &&
            (NextStartingLbn(BaseMcb,Index) == Lbn + SectorCount)) {

            //
            //  Leaves no holes, and continues both runs
            //
            //  --PreviousRun--|--NewRun--|--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues both runs\n", 0);

            //
            //  We need to collapse the current index and the following index
            //  but first we copy the NextVbn of the follwing run into
            //  the NextVbn field of the previous run to so it all becomes
            //  one run
            //

            (BaseMcb->Mapping)[Index-1].NextVbn = (BaseMcb->Mapping)[Index+1].NextVbn;

            FsRtlRemoveLargeEntry( Mcb, Index, 2 );

            try_return (Result = TRUE);
        }

        if (NextStartingLbn(BaseMcb,Index) == Lbn + SectorCount) {

            //
            //  Leaves no holes, and continues only following run
            //
            //  --PreviousRun--||--NewRun--|--FollowingRun--
            //
            //  0:|--NewRun--|--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues following\n", 0);

            //
            //  This index is going away so we need to stretch the
            //  following run to meet up with the previous run
            //

            (BaseMcb->Mapping)[Index+1].Lbn = Lbn;

            FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            try_return (Result = TRUE);
        }

        if (PreviousEndingLbn(BaseMcb,Index) + 1 == Lbn) {

            //
            //  Leaves no holes, and continues only earlier run
            //
            //  --PreviousRun--|--NewRun--||--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues earlier\n", 0);

            //
            //  This index is going away so we need to stretch the
            //  previous run to meet up with the following run
            //

            (BaseMcb->Mapping)[Index-1].NextVbn = (BaseMcb->Mapping)[Index].NextVbn;

            FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            try_return (Result = TRUE);
        }

        //
        //  Leaves no holes, and continues neither run
        //
        //      --PreviousRun--||--NewRun--||--FollowingRun--
        //
        //      0:|--NewRun--||--FollowingRun--
        //

        DebugTrace( 0, Dbg, "No holes, and continues none\n", 0);

        (BaseMcb->Mapping)[Index].Lbn = Lbn;

        try_return (Result = TRUE);
    }

    //
    //  We tried to overwrite an existing mapping so we'll have to
    //  tell our caller that it's not possible
    //

    Result = FALSE;

try_exit: NOTHING;

    return Result;
}


BOOLEAN
FsRtlAddLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __in LONGLONG LargeLbn,
    __in LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine is used to add a new mapping of VBNs to LBNs to an existing
    Mcb. The information added will map

        Vbn to Lbn,

        Vbn+1 to Lbn+1,...

        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).

    The mapping for the VBNs must not already exist in the Mcb.  If the
    mapping continues a previous run, then this routine will actually coalesce
    them into 1 run.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

    An input Lbn value of zero is illegal (i.e., the Mcb structure will never
    map a Vbn to a zero Lbn value).

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.

    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.

    SectorCount - Supplies the size of the new mapping run (in sectors).

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new
        Vbns did not collide with existing Vbns), and FALSE otherwise.  If
        FALSE is returned then the Mcb is not changed.

--*/

{

    BOOLEAN Result = FALSE;

    KeAcquireGuardedMutex( Mcb->GuardedMutex );
    try {

        Result = FsRtlAddBaseMcbEntry( &Mcb->BaseMcb, LargeVbn, LargeLbn, LargeSectorCount );

    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );
        DebugTrace(-1, Dbg, "FsRtlAddLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


//
//  Private support routine
//

VOID
FsRtlRemoveBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG Vbn,
    __in LONGLONG SectorCount
    )

/*++

Routine Description:

    This is the work routine for remove large mcb entry.  It does the work
    without taking out the mcb GuardedMutex.

Arguments:

    Mcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB) Mcb;
    ULONG Index;

    //
    //  Do a quick test to see if we are wiping out the entire MCB.
    //

    if ((Vbn == 0) && (Mcb->PairCount > 0) && (SectorCount >= BaseMcb->Mapping[Mcb->PairCount-1].NextVbn)) {

        Mcb->PairCount = 0;

        return;
    }

    //
    //  While there is some more mapping to remove we'll continue
    //  with our main loop
    //

    while (SectorCount > 0) {

        //
        //  Locate the mapping for the vbn
        //

        if (!FsRtlFindLargeIndex(Mcb, (VBN)Vbn, &Index)) {

            DebugTrace( 0, Dbg, "FsRtlRemoveLargeMcbEntry, Cannot remove an unmapped Vbn = %08lx\n", Vbn );

            return;
        }

        //
        //  Now that we some something to remove the following cases must
        //  be considered
        //

        if ((StartingVbn(BaseMcb,Index) == Vbn) &&
            (EndingVbn(BaseMcb,Index) < Vbn + SectorCount)) {

            ULONG i;

            //
            //  Removes the entire run
            //

            //
            //  Update the amount to remove
            //

            i = SectorsWithinRun(BaseMcb,Index);
            Vbn += i;
            SectorCount -= i;

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(BaseMcb,Index) == UNUSED_LBN) {

                NOTHING;

            //
            //  Test for last run
            //

            } else if (Index == Mcb->PairCount - 1) {

                if ((PreviousEndingLbn(BaseMcb,Index) != UNUSED_LBN) ||
                    (Index == 0)) {

                    //
                    //  Previous is not hole, index is last run
                    //
                    //  --Previous--|  Hole
                    //
                    //  0:  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous not hole, index is last run\n", 0);

                    //
                    //  Just remove this entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index, 1);

                } else {

                    //
                    //  Previous is hole, index is last run
                    //
                    //  --Hole--|  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous hole, index is last run\n", 0);

                    //
                    //  Just remove this entry, and preceding entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index-1, 2);
                }

            } else if (((PreviousEndingLbn(BaseMcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(BaseMcb,Index) != UNUSED_LBN)) {

                //
                //  Previous and following are not holes
                //
                //  --Previous--|  Hole  |--Following--
                //
                //  0:  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & Following not holes\n", 0);

                //
                //  Make this index a hole
                //

                (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;

            } else if (((PreviousEndingLbn(BaseMcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(BaseMcb,Index) == UNUSED_LBN)) {

                //
                //  Following is hole
                //
                //  --Previous--|  Hole  |--Hole--
                //
                //  0:  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Following is hole\n", 0);

                //
                //  Simply remove this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            } else if ((PreviousEndingLbn(BaseMcb,Index) == UNUSED_LBN) &&
                       (NextStartingLbn(BaseMcb,Index) != UNUSED_LBN)) {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous is hole\n", 0);

                //
                //  Mark current entry a hole
                //

                (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;

                //
                //  Remove previous entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 1 );

            } else {

                //
                //  Previous and following are holes
                //
                //  --Hole--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & following are holes\n", 0);

                //
                //  Remove previous and this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 2 );
            }

        } else if (StartingVbn(BaseMcb,Index) == Vbn) {

            //
            //  Removes first part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(BaseMcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if ((PreviousEndingLbn(BaseMcb,Index) != UNUSED_LBN) || (Index == 0)) {

                //
                //  Previous is not hole
                //
                //  --Previous--|  Hole  |--Index--||--Following--
                //
                //  0:  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Set the hole
                //

                (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
                (BaseMcb->Mapping)[Index].NextVbn = (VBN)Vbn + (VBN)SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (BaseMcb->Mapping)[Index+1].Lbn += (LBN)SectorCount;

            } else {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is hole\n", 0);

                //
                //  Expand the preceding hole
                //

                (BaseMcb->Mapping)[Index-1].NextVbn += (VBN)SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (BaseMcb->Mapping)[Index].Lbn += (LBN)SectorCount;
            }

            //
            //  Update the amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;

        } else if (EndingVbn(BaseMcb,Index) < Vbn + SectorCount) {

            ULONG AmountToRemove;

            AmountToRemove = EndingVbn(BaseMcb,Index) - (VBN)Vbn + 1;

            //
            //  Removes last part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(BaseMcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if (Index == Mcb->PairCount - 1) {

                //
                //  Index is last run
                //
                //  --Previous--||--Index--|  Hole
                //
                //  0:|--Index--|  Hole
                //

                DebugTrace( 0, Dbg, "last part, Index is last run\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (BaseMcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else if (NextStartingLbn(BaseMcb,Index) == UNUSED_LBN) {

                //
                //  Following is hole
                //
                //  --Previous--||--Index--|  Hole  |--Hole--
                //
                //  0:|--Index--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "last part, Following is hole\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (BaseMcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else {

                //
                //  Following is not hole
                //
                //  --Previous--||--Index--|  Hole  |--Following--
                //
                //
                //  0:|--Index--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "last part, Following is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index+1, 1 );

                //
                //  Set the new hole
                //

                (BaseMcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
                (BaseMcb->Mapping)[Index+1].NextVbn = (BaseMcb->Mapping)[Index].NextVbn;

                //
                //  Shrink back the size of the current index
                //

                (BaseMcb->Mapping)[Index].NextVbn -= AmountToRemove;
            }

            //
            //  Update amount to remove
            //

            Vbn += AmountToRemove;
            SectorCount -= AmountToRemove;

        } else {

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(BaseMcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else {

                //
                //  Remove middle of run
                //
                //  --Previous--||--Index--|  Hole  |--Index--||--Following--
                //
                //  0:|--Index--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "Middle of run\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Set up the first remaining run
                //

                (BaseMcb->Mapping)[Index].Lbn = (BaseMcb->Mapping)[Index+2].Lbn;
                (BaseMcb->Mapping)[Index].NextVbn = (VBN)Vbn;

                //
                //  Set up the hole
                //

                (BaseMcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
                (BaseMcb->Mapping)[Index+1].NextVbn = (VBN)Vbn + (VBN)SectorCount;

                //
                //  Set up the second remaining run
                //

                (BaseMcb->Mapping)[Index+2].Lbn += SectorsWithinRun(BaseMcb,Index) +
                                                SectorsWithinRun(BaseMcb,Index+1);
            }

            //
            //  Update amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;
        }
    }

    return;
}


VOID
FsRtlRemoveLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __in LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine removes a mapping of VBNs to LBNs from an Mcb.  The mappings
    removed are for

        Vbn,

        Vbn+1, to

        Vbn+(SectorCount-1).

    The operation works even if the mapping for a Vbn in the specified range
    does not already exist in the Mcb.  If the specified range of Vbn includes
    the last mapped Vbn in the Mcb then the Mcb mapping shrinks accordingly.

    If pool is not available to store the information this routine will raise
    a status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    VBN Vbn = ((ULONG)LargeVbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);

    DebugTrace(+1, Dbg, "FsRtlRemoveLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );

    try {

        FsRtlRemoveBaseMcbEntry( &Mcb->BaseMcb, Vbn, SectorCount );

    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveLargeMcbEntry -> VOID\n", 0 );
    }

    return;
}


BOOLEAN
FsRtlLookupBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __out_opt PLONGLONG LargeLbn,
    __out_opt PLONGLONG LargeSectorCount,
    __out_opt PLONGLONG LargeStartingLbn,
    __out_opt PLONGLONG LargeCountFromStartingLbn,
    __out_opt PULONG Index
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (even if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    ULONG LocalIndex;
    BOOLEAN Result;

    DebugTrace(+1, Dbg, "FsRtlLookupBaseMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, "  LargeVbn.LowPart = %08lx\n", LargeVbn.LowPart );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0) ||
                                                  ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                   (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    if (!FsRtlFindLargeIndex(Mcb, ((ULONG)LargeVbn), &LocalIndex)) {

        try_return (Result = FALSE);
    }

    //
    //  Compute the lbn for corresponding to the vbn, the value is the
    //  starting lbn of the run plus the number of sectors offset into the
    //  run.  But if it's a hole then the sector Lbn is zero.
    //

    if (ARGUMENT_PRESENT(LargeLbn)) {

        if (StartingLbn(BaseMcb,LocalIndex) == UNUSED_LBN) {

            *LargeLbn = UNUSED_LBN;

        } else {

            *LargeLbn = StartingLbn(BaseMcb,LocalIndex) + (((ULONG)LargeVbn) - StartingVbn(BaseMcb,LocalIndex));
        }
    }

    //
    //  If there sector count argument is present then we'll return the number
    //  of sectors remaing in the run.
    //

    if (ARGUMENT_PRESENT(LargeSectorCount)) {

        *LargeSectorCount = EndingVbn(BaseMcb,LocalIndex) - ((ULONG)LargeVbn) + 1;
    }

    //
    //  Compute the starting lbn for corresponding to the start of the run, the value is the
    //  starting lbn of the run.  But if it's a hole then the sector Lbn is zero.
    //

    if (ARGUMENT_PRESENT(LargeStartingLbn)) {

        if (StartingLbn(BaseMcb,LocalIndex) == UNUSED_LBN) {

            *LargeStartingLbn = UNUSED_LBN;

        } else {

            *LargeStartingLbn = StartingLbn(BaseMcb,LocalIndex);
        }
    }

    //
    //  If there sector count argument is present then we'll return the number
    //  of sectors in the run.
    //

    if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {

        *LargeCountFromStartingLbn = EndingVbn(BaseMcb,LocalIndex) - StartingVbn(BaseMcb,LocalIndex) + 1;
    }

    //
    //  If the caller want to know the Index number, fill it in.
    //

    if (ARGUMENT_PRESENT(Index)) {

        *Index = LocalIndex;
    }

    Result = TRUE;

try_exit: NOTHING;

    return Result;
}


BOOLEAN
FsRtlLookupLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __out_opt PLONGLONG LargeLbn,
    __out_opt PLONGLONG LargeSectorCount,
    __out_opt PLONGLONG LargeStartingLbn,
    __out_opt PLONGLONG LargeCountFromStartingLbn,
    __out_opt PULONG Index
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (even if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    BOOLEAN Result = FALSE;
    
    KeAcquireGuardedMutex( Mcb->GuardedMutex );

    try {

        Result = FsRtlLookupBaseMcbEntry( &Mcb->BaseMcb, LargeVbn, LargeLbn, LargeSectorCount, LargeStartingLbn, LargeCountFromStartingLbn, Index );
    
    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    Mcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{

    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    BOOLEAN Result = FALSE;

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeBaseEntry, Mcb = %08lx\n", Mcb );


    //
    //  Check to make sure there is at least one run in the mcb
    //

    if (BaseMcb->PairCount > 0) {

        //
        //  Return the last mapping of the last run
        //

        *LargeLbn = EndingLbn(BaseMcb, BaseMcb->PairCount-1);
        *LargeVbn = EndingVbn(BaseMcb, BaseMcb->PairCount-1);

        Result = TRUE;
    
    }
    return Result;
}



BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    BOOLEAN Result = FALSE;

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntry, Mcb = %08lx\n", Mcb );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );

    try {

        Result = FsRtlLookupLastBaseMcbEntry( &Mcb->BaseMcb, LargeVbn, LargeLbn );  

    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );
        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastBaseMcbEntryAndIndex (
    __in PBASE_MCB Mcb,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn,
    __out PULONG Index
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    Mcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.
    
    Index - Receives the index of the last run.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastBaseMcbEntryAndIndex, Mcb = %08lx\n", Mcb );


    //
    //  Check to make sure there is at least one run in the mcb
    //

    if (BaseMcb->PairCount > 0) {

        //
        //  Return the last mapping of the last run
        //

        *((PULONG)LargeLbn) = EndingLbn(BaseMcb, BaseMcb->PairCount-1);
        *((PULONG)LargeVbn) = EndingVbn(BaseMcb, BaseMcb->PairCount-1);
        *Index = BaseMcb->PairCount - 1;
        Result = TRUE;
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == UNUSED_LBN ? UNUSED_LBN : 0);
    ((PLARGE_INTEGER)LargeLbn)->HighPart = (*((PULONG)LargeLbn) == UNUSED_LBN ? UNUSED_LBN : 0);

    return Result;
}



BOOLEAN
FsRtlLookupLastLargeMcbEntryAndIndex (
    __in PLARGE_MCB Mcb,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn,
    __out PULONG Index
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.
    
    Index - Receives the index of the last run.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntryAndIndex, Mcb = %08lx\n", Mcb );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );

    try {

        Result = FsRtlLookupLastBaseMcbEntryAndIndex( &Mcb->BaseMcb, LargeVbn, LargeLbn, Index ); 

    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );
        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntryAndIndex -> %08lx\n", Result );
    }

    return Result;
}


ULONG
FsRtlNumberOfRunsInBaseMcb (
    __in PBASE_MCB Mcb
    )

/*++

Routine Description:

    This routine returns to the its caller the number of distinct runs
    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted
    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3
    will have 3 runs, one for the first mapped sector, a second for the
    hole covering Vbns 1 and 2, and a third for Vbn 3.

Arguments:

    Mcb - Supplies the Mcb being examined.

Return Value:

    ULONG - Returns the number of distinct runs mapped by the input Mcb.

--*/

{
    return Mcb->PairCount;
}



ULONG
FsRtlNumberOfRunsInLargeMcb (
    __in PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This routine returns to the its caller the number of distinct runs
    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted
    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3
    will have 3 runs, one for the first mapped sector, a second for the
    hole covering Vbns 1 and 2, and a third for Vbn 3.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

Return Value:

    ULONG - Returns the number of distinct runs mapped by the input Mcb.

--*/

{
    ULONG Count;

    DebugTrace(+1, Dbg, "FsRtlNumberOfRunsInLargeMcb, Mcb = %08lx\n", Mcb );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );
    Count = FsRtlNumberOfRunsInBaseMcb( &Mcb->BaseMcb );
    KeReleaseGuardedMutex( Mcb->GuardedMutex );

    DebugTrace(-1, Dbg, "FsRtlNumberOfRunsInLargeMcb -> %08lx\n", Count );

    return Count;
}


BOOLEAN
FsRtlGetNextBaseMcbEntry (
    __in PBASE_MCB Mcb,
    __in ULONG RunIndex,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn,
    __out PLONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine returns to its caller the Vbn, Lbn, and SectorCount for
    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,
    to construct to print out all of the runs in a a file is:

//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&Vbn,&Lbn,&Count); i++) {
//
//. .       // print out vbn, lbn, and count
//
//. .       }

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    RunIndex - Supplies the index of the run (zero based) to return to the
        caller.

    Vbn - Receives the starting Vbn of the returned run, or zero if the
        run does not exist.

    Lbn - Receives the starting Lbn of the returned run, or zero if the
        run does not exist.

    SectorCount - Receives the number of sectors within the returned run,
        or zero if the run does not exist.

Return Value:

    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,
        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and
        SectorCount parameters receive zero.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    BOOLEAN Result = FALSE;

    DebugTrace(+1, Dbg, "FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " RunIndex = %08lx\n", RunIndex );

    //
    //  Make sure the run index is within range
    //

    if (RunIndex < BaseMcb->PairCount) {

        //
        //  Set the return variables
        //

        *((PULONG)LargeVbn) = StartingVbn(BaseMcb, RunIndex);
        ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == UNUSED_LBN ? UNUSED_LBN : 0);
        *((PULONG)LargeLbn) = StartingLbn(BaseMcb, RunIndex);
        ((PLARGE_INTEGER)LargeLbn)->HighPart = (*((PULONG)LargeLbn) == UNUSED_LBN ? UNUSED_LBN : 0);
        *LargeSectorCount = SectorsWithinRun(BaseMcb, RunIndex);

        Result = TRUE;
    }

    return Result;
}


BOOLEAN
FsRtlGetNextLargeMcbEntry (
    __in PLARGE_MCB Mcb,
    __in ULONG RunIndex,
    __out PLONGLONG LargeVbn,
    __out PLONGLONG LargeLbn,
    __out PLONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine returns to its caller the Vbn, Lbn, and SectorCount for
    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,
    to construct to print out all of the runs in a a file is:

//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&Vbn,&Lbn,&Count); i++) {
//
//. .       // print out vbn, lbn, and count
//
//. .       }

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    RunIndex - Supplies the index of the run (zero based) to return to the
        caller.

    Vbn - Receives the starting Vbn of the returned run, or zero if the
        run does not exist.

    Lbn - Receives the starting Lbn of the returned run, or zero if the
        run does not exist.

    SectorCount - Receives the number of sectors within the returned run,
        or zero if the run does not exist.

Return Value:

    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,
        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and
        SectorCount parameters receive zero.

--*/

{
    BOOLEAN Result = FALSE;

    DebugTrace(+1, Dbg, "FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " RunIndex = %08lx\n", RunIndex );

    KeAcquireGuardedMutex( Mcb->GuardedMutex );
    Result = FsRtlGetNextBaseMcbEntry( &Mcb->BaseMcb, RunIndex, LargeVbn, LargeLbn, LargeSectorCount );  
    KeReleaseGuardedMutex( Mcb->GuardedMutex );

    DebugTrace(-1, Dbg, "FsRtlGetNextLargeMcbEntry -> %08lx\n", Result );

    return Result;
}


BOOLEAN
FsRtlSplitBaseMcb (
    __in PBASE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __in LONGLONG LargeAmount
    )

/*++

Routine Description:

    This routine is used to create a hole within an MCB, by shifting the
    mapping of Vbns.  All mappings above the input vbn are shifted by the
    amount specified and while keeping their current lbn value.  Pictorially
    we have as input the following MCB

        VBN :       LargeVbn-1 LargeVbn         N
            +-----------------+------------------+
        LBN :             X        Y

    And after the split we have

        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount
            +-----------------+.............+---------------------------+
        LBN :             X      UnusedLbn       Y

    When doing the split we have a few cases to consider.  They are:

    1. The input Vbn is beyond the last run.  In this case this operation
       is a noop.

    2. The input Vbn is within or adjacent to a existing run of unused Lbns.
       In this case we simply need to extend the size of the existing hole
       and shift succeeding runs.

    3. The input Vbn is between two existing runs, including the an input vbn
       value of zero.  In this case we need to add a new entry for the hole
       and shift succeeding runs.

    4. The input Vbn is within an existing run.  In this case we need to add
       two new entries to contain the split run and the hole.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn that is to be shifted.

    Amount - Supplies the amount to shift by.

Return Value:

    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.
        If FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Amount = ((ULONG)LargeAmount);

    ULONG Index;

    BOOLEAN Result;

    ULONG i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlSplitLargeMcb, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn    = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Amount = %08lx\n", Amount );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0)));
    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeAmount)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0)));


    //
    //  First lookup the index for the entry that we are going to split.
    //  If we can't find the entry then there is nothing to split.  This
    //  takes care of the case where the input vbn is beyond the last run
    //  in the mcb
    //

    if (!FsRtlFindLargeIndex( Mcb, Vbn, &Index)) {

        try_return(Result = FALSE);
    }

    //
    //  Now check if the input Vbn is within a hole
    //

    if (StartingLbn(BaseMcb, Index) == UNUSED_LBN) {

        //
        //  Before: --PreviousRun--||--IndexHole--||--FollowingRun--
        //  After:  --PreviousRun--||----IndexHole----||--FollowingRun--
        //
        //      In this case the vbn is somewhere within the hole and we
        //      simply need to added the amount of each existing run
        //      beyond the hole.
        //

        //
        //  In this case there is really nothing to do here because the
        //  ending code will already shift the runs by proper amount
        //  starting at index
        //

        NOTHING;

    //
    //  Now check if the input vbn is between a hole and an existing run.
    //

    } else if ((StartingVbn(BaseMcb,Index) == Vbn) && (Index != 0) && (PreviousEndingLbn(BaseMcb,Index) == UNUSED_LBN)) {

        //
        //  Before: --Hole--||--IndexRun--
        //  After:  --Hole------||--IndexRun--
        //
        //      In this case the vbn points to the start of the existing
        //      run and we need to do the split between the hole and the
        //      existing run by simply adding the amount to each existing
        //      run beyond the hole.
        //

        //
        //  In this case we need to decement the index by 1 and then
        //  fall to the bottom code which will do the shifting for us
        //

        Index -= 1;

    //
    //  Now check if the input vbn is between two existing runs
    //

    } else if (StartingVbn(BaseMcb,Index) == Vbn) {

        //
        //  Before: --PreviousRun--||--IndexRun--
        //  After:  --PreviousRun--||--NewHole--||--IndexRun--
        //
        //  Before: 0:|--IndexRun--
        //  After:  0:|--NewHole--||--IndexRun--
        //
        //      In this case the vbn points to the start of an existing
        //      run and the preceding is either a real run or the start
        //      of mapping pairs We simply add a new entry for the hole
        //      and shift succeeding runs.
        //

        FsRtlAddLargeEntry( Mcb, Index, 1 );

        (BaseMcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
        (BaseMcb->Mapping)[Index].NextVbn = Vbn + Amount;

        Index += 1;

    //
    //  Otherwise the input vbn is inside an existing run
    //

    } else {

        //
        //  Before: --IndexRun--
        //  After:  --SplitRun--||--NewHole--||--SplitRun--
        //
        //      In this case the vbn points within an existing run
        //      we need to add two new extries for hole and split
        //      run and shift succeeding runs
        //

        FsRtlAddLargeEntry( Mcb, Index, 2 );

        (BaseMcb->Mapping)[Index].Lbn = (BaseMcb->Mapping)[Index+2].Lbn;
        (BaseMcb->Mapping)[Index].NextVbn = Vbn;

        (BaseMcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
        (BaseMcb->Mapping)[Index+1].NextVbn = Vbn + Amount;

        (BaseMcb->Mapping)[Index+2].Lbn = (BaseMcb->Mapping)[Index+2].Lbn +
                                      StartingVbn(BaseMcb, Index+1) -
                                      StartingVbn(BaseMcb, Index);

        Index += 2;

    }

    //
    //  At this point we have completed most of the work we now need to
    //  shift existing runs from the index to the end of the mappings
    //  by the specified amount
    //

    for (i = Index; i < BaseMcb->PairCount; i += 1) {

        (BaseMcb->Mapping)[i].NextVbn += Amount;
    }

    Result = TRUE;

try_exit: NOTHING;

    return Result;
}


BOOLEAN
FsRtlSplitLargeMcb (
    __in PLARGE_MCB Mcb,
    __in LONGLONG LargeVbn,
    __in LONGLONG LargeAmount
    )

/*++

Routine Description:

    This routine is used to create a hole within an MCB, by shifting the
    mapping of Vbns.  All mappings above the input vbn are shifted by the
    amount specified and while keeping their current lbn value.  Pictorially
    we have as input the following MCB

        VBN :       LargeVbn-1 LargeVbn         N
            +-----------------+------------------+
        LBN :             X        Y

    And after the split we have

        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount
            +-----------------+.............+---------------------------+
        LBN :             X      UnusedLbn       Y

    When doing the split we have a few cases to consider.  They are:

    1. The input Vbn is beyond the last run.  In this case this operation
       is a noop.

    2. The input Vbn is within or adjacent to a existing run of unused Lbns.
       In this case we simply need to extend the size of the existing hole
       and shift succeeding runs.

    3. The input Vbn is between two existing runs, including the an input vbn
       value of zero.  In this case we need to add a new entry for the hole
       and shift succeeding runs.

    4. The input Vbn is within an existing run.  In this case we need to add
       two new entries to contain the split run and the hole.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn that is to be shifted.

    Amount - Supplies the amount to shift by.

Return Value:

    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.
        If FALSE is returned then the Mcb is not changed.

--*/

{
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    KeAcquireGuardedMutex( Mcb->GuardedMutex );
    
    try {

        Result = FsRtlSplitBaseMcb( &Mcb->BaseMcb, LargeVbn, LargeAmount );

    } finally {

        KeReleaseGuardedMutex( Mcb->GuardedMutex );
        DebugTrace(-1, Dbg, "FsRtlSplitLargeMcb -> %08lx\n", Result );
    }

    return Result;
}


//
//  Private routine
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PBASE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    )

/*++

Routine Description:

    This is a private routine that locates a mapping for a Vbn
    in a given mapping array

Arguments:

    Mcb - Supplies the mapping array to examine

    Vbn - Supplies the Vbn to look up

    Index - Receives the index within the mapping array of the mapping
        containing the Vbn.  If none if found then the index is set to
        PairCount.

Return Value:

    BOOLEAN - TRUE if Vbn is found and FALSE otherwise

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    LONG MinIndex;
    LONG MaxIndex;
    LONG MidIndex;

    //
    //  We'll just do a binary search for the mapping entry.  Min and max
    //  are our search boundaries
    //

    MinIndex = 0;
    MaxIndex = BaseMcb->PairCount - 1;

    while (MinIndex <= MaxIndex) {

        //
        //  Compute the middle index to look at
        //

        MidIndex = ((MaxIndex + MinIndex) / 2);

        //
        //  check if the Vbn is less than the mapping at the mid index
        //

        if (Vbn < StartingVbn(BaseMcb, MidIndex)) {

            //
            //  Vbn is less than the middle index so we need to drop
            //  the max down
            //

            MaxIndex = MidIndex - 1;

        //
        //  check if the Vbn is greater than the mapping at the mid index
        //

        } else if (Vbn > EndingVbn(BaseMcb, MidIndex)) {

            //
            //  Vbn is greater than the middle index so we need to bring
            //  up the min
            //

            MinIndex = MidIndex + 1;

        //
        //  Otherwise we've found the index containing the Vbn so set the
        //  index and return TRUE.
        //

        } else {

            *Index = MidIndex;

            return TRUE;
        }
    }

    //
    //  A match wasn't found so set index to PairCount and return FALSE
    //

    *Index = BaseMcb->PairCount;

    return FALSE;
}


//
//  Private Routine
//

VOID
FsRtlAddLargeEntry (
    IN PBASE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    )

/*++

Routine Description:

    This routine takes a current Mcb and detemines if there is enough
    room to add the new mapping entries.  If there is not enough room
    it reallocates a new mcb buffer and copies over the current mapping.
    If also will spread out the current mappings to leave the specified
    index slots in the mapping unfilled.  For example, if WhereToAddIndex
    is equal to the current pair count then we don't need to make a hole
    in the mapping, but if the index is less than the current pair count
    then we'll need to slide some of the mappings down to make room
    at the specified index.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToAddIndex - Supplies the index of where the additional entries
        need to be made

    AmountToAdd - Supplies the number of additional entries needed in the
        mcb

Return Value:

    None.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;
    
    //
    //  Check to see if the current buffer is large enough to hold
    //  the additional entries
    //

    if (BaseMcb->PairCount + AmountToAdd > BaseMcb->MaximumPairCount) {

        ULONG NewMax;
        PMAPPING Mapping;

        //
        //  We need to allocate a new mapping so compute a new maximum pair
        //  count.  We'll only be asked to grow by at most 2 at a time, so
        //  doubling will definitely make us large enough for the new amount.
        //  But we won't double without bounds we'll stop doubling if the
        //  pair count gets too high.
        //

        if (BaseMcb->MaximumPairCount < 2048) {

            NewMax = BaseMcb->MaximumPairCount * 2;

        } else {

            NewMax = BaseMcb->MaximumPairCount + 2048;
        }

        Mapping = FsRtlpAllocatePool( BaseMcb->PoolType, sizeof(MAPPING) * NewMax );

        //**** RtlZeroMemory( Mapping, sizeof(MAPPING) * NewMax );

        //
        //  Now copy over the old mapping to the new buffer
        //

        RtlCopyMemory( Mapping, BaseMcb->Mapping, sizeof(MAPPING) * BaseMcb->PairCount );

        //
        //  Deallocate the old buffer
        //

        if ((BaseMcb->PoolType == PagedPool) && (BaseMcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

            FsRtlFreeFirstMapping( BaseMcb->Mapping );

        } else {

            ExFreePool( BaseMcb->Mapping );
        }

        //
        //  And set up the new buffer in the Mcb
        //

        BaseMcb->Mapping = Mapping;
        BaseMcb->MaximumPairCount = NewMax;
    }

    //
    //  Now see if we need to shift some entries over according to the
    //  WhereToAddIndex value
    //

    if (WhereToAddIndex < BaseMcb->PairCount) {

        RtlMoveMemory( &((BaseMcb->Mapping)[WhereToAddIndex + AmountToAdd]),
                       &((BaseMcb->Mapping)[WhereToAddIndex]),
                       (BaseMcb->PairCount - WhereToAddIndex) * sizeof(MAPPING) );
    }

    //
    //  Now zero out the new additions
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[WhereToAddIndex]), sizeof(MAPPING) * AmountToAdd );

    //
    //  Now increment the PairCount
    //

    BaseMcb->PairCount += AmountToAdd;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

VOID
FsRtlRemoveLargeEntry (
    IN PBASE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    )

/*++

Routine Description:

    This routine takes a current Mcb and removes one or more entries.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToRemoveIndex - Supplies the index of the entries to remove

    AmountToRemove - Supplies the number of entries to remove

Return Value:

    None.

--*/

{
    PNONOPAQUE_BASE_MCB BaseMcb = (PNONOPAQUE_BASE_MCB)Mcb;

    //
    //  Check to see if we need to shift everything down because the
    //  entries to remove do not include the last entry in the mcb
    //

    if (WhereToRemoveIndex + AmountToRemove < BaseMcb->PairCount) {

        RtlMoveMemory( &((BaseMcb->Mapping)[WhereToRemoveIndex]),
                      &((BaseMcb->Mapping)[WhereToRemoveIndex + AmountToRemove]),
                      (BaseMcb->PairCount - (WhereToRemoveIndex + AmountToRemove))
                                                           * sizeof(MAPPING) );
    }

    //
    //  Now zero out the entries beyond the part we just shifted down
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[Mcb->PairCount - AmountToRemove]), AmountToRemove * sizeof(MAPPING) );

    //
    //  Now decrement the PairCount
    //

    BaseMcb->PairCount -= AmountToRemove;

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\fsrtlpc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    FsRtlP.c

Abstract:

    This module declares the global data used by the FsRtl Module

--*/

#include "FsRtlP.h"

#define COMPATIBILITY_MODE_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define COMPATIBILITY_MODE_VALUE_NAME L"Win95TruncatedExtensions"

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 64)

#ifdef FSRTLDBG

LONG FsRtlDebugTraceLevel = 0x0000000f;
LONG FsRtlDebugTraceIndent = 0;

#endif // FSRTLDBG

//
//  Local Support routine
//

NTSTATUS
FsRtlGetCompatibilityModeValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAllocateResource)
#pragma alloc_text(INIT, FsRtlInitSystem)
#pragma alloc_text(INIT, FsRtlGetCompatibilityModeValue)
#endif

//
//  Define the number of resources, a pointer to them and a counter for
//  resource selection.
//

#define FSRTL_NUMBER_OF_RESOURCES (16)

PERESOURCE FsRtlPagingIoResources;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG FsRtlPagingIoResourceSelector = 0;
BOOLEAN FsRtlSafeExtensions = TRUE;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked separately if
//  allowed.
//

#define _FAT_  FSRTL_FAT_LEGAL
#define _HPFS_ FSRTL_HPFS_LEGAL
#define _NTFS_ FSRTL_NTFS_LEGAL
#define _OLE_  FSRTL_OLE_LEGAL
#define _WILD_ FSRTL_WILD_CHARACTER

static const UCHAR LocalLegalAnsiCharacterArray[128] = {

    0                                   ,   // 0x00 ^@
                                   _OLE_,   // 0x01 ^A
                                   _OLE_,   // 0x02 ^B
                                   _OLE_,   // 0x03 ^C
                                   _OLE_,   // 0x04 ^D
                                   _OLE_,   // 0x05 ^E
                                   _OLE_,   // 0x06 ^F
                                   _OLE_,   // 0x07 ^G
                                   _OLE_,   // 0x08 ^H
                                   _OLE_,   // 0x09 ^I
                                   _OLE_,   // 0x0A ^J
                                   _OLE_,   // 0x0B ^K
                                   _OLE_,   // 0x0C ^L
                                   _OLE_,   // 0x0D ^M
                                   _OLE_,   // 0x0E ^N
                                   _OLE_,   // 0x0F ^O
                                   _OLE_,   // 0x10 ^P
                                   _OLE_,   // 0x11 ^Q
                                   _OLE_,   // 0x12 ^R
                                   _OLE_,   // 0x13 ^S
                                   _OLE_,   // 0x14 ^T
                                   _OLE_,   // 0x15 ^U
                                   _OLE_,   // 0x16 ^V
                                   _OLE_,   // 0x17 ^W
                                   _OLE_,   // 0x18 ^X
                                   _OLE_,   // 0x19 ^Y
                                   _OLE_,   // 0x1A ^Z
                                   _OLE_,   // 0x1B ESC
                                   _OLE_,   // 0x1C FS
                                   _OLE_,   // 0x1D GS
                                   _OLE_,   // 0x1E RS
                                   _OLE_,   // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x21 !
                            _WILD_| _OLE_,  // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x29 )
                            _WILD_| _OLE_,  // 0x2A *
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2B +
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x2E .
    0                                    ,  // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x39 9
                     _NTFS_              ,  // 0x3A :
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3B ;
                            _WILD_| _OLE_,  // 0x3C <
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3D =
                            _WILD_| _OLE_,  // 0x3E >
                            _WILD_| _OLE_,  // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5A Z
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5B [
    0                                    ,  // 0x5C backslash
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7B {
    0                             | _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7F 
};

UCHAR const* const FsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];

//
//  This routine is called during phase one initialization.
//

BOOLEAN
FsRtlInitSystem (
    )
{
    ULONG i;

    ULONG Value;
    UNICODE_STRING ValueName;

    extern KSEMAPHORE FsRtlpUncSemaphore;

    PAGED_CODE();

    //
    //  Allocate and initialize all the paging Io resources
    //

    FsRtlPagingIoResources = FsRtlAllocatePool( NonPagedPool,
                                                FSRTL_NUMBER_OF_RESOURCES *
                                                sizeof(ERESOURCE) );

    for (i=0; i < FSRTL_NUMBER_OF_RESOURCES; i++) {

        ExInitializeResourceLite( &FsRtlPagingIoResources[i] );
    }

    //
    //  Initialize the global tunneling structures.
    //

    FsRtlInitializeTunnels();

    //
    //  Initialize the global filelock structures.
    //

    FsRtlInitializeFileLocks();

    //
    //  Initialize the global largemcb structures.
    //

    FsRtlInitializeLargeMcbs();

    //
    // Initialize the semaphore used to guard loading of the MUP
    //

    KeInitializeSemaphore( &FsRtlpUncSemaphore, 1, MAXLONG );

    //
    // Pull the bit from the registry telling us whether to do a safe
    // or dangerous extension truncation.
    //

    ValueName.Buffer = COMPATIBILITY_MODE_VALUE_NAME;
    ValueName.Length = sizeof(COMPATIBILITY_MODE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(COMPATIBILITY_MODE_VALUE_NAME);

    if (NT_SUCCESS(FsRtlGetCompatibilityModeValue( &ValueName, &Value )) &&
        (Value != 0)) {

        FsRtlSafeExtensions = FALSE;
    }

    //
    // Initialize the FsRtl stack overflow work QueueObject and thread.
    //

    if (!NT_SUCCESS(FsRtlInitializeWorkerThread())) {

        return FALSE;
    }

    //
    // Initialize the FsFilter component of FsRtl.
    //

    if (!NT_SUCCESS(FsFilterInit())) {

        return FALSE;
    }
    
    return TRUE;
}


PERESOURCE
FsRtlAllocateResource (
    )

/*++

Routine Description:

    This routine is used to allocate a resource from the FsRtl pool.

Arguments:

Return Value:

    PERESOURCE - A pointer to the provided resource.

--*/

{
    PAGED_CODE();

    return &FsRtlPagingIoResources[ FsRtlPagingIoResourceSelector++ %
                                    FSRTL_NUMBER_OF_RESOURCES];
}


//
//  Local Support routine
//

NTSTATUS
FsRtlGetCompatibilityModeValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the Chicago compatibility mode information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                double space configuration location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    KeyName.Buffer = COMPATIBILITY_MODE_KEY_NAME;
    KeyName.Length = sizeof(COMPATIBILITY_MODE_KEY_NAME) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(COMPATIBILITY_MODE_KEY_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePoolWithTag(PagedPool,
                                                        RequestLength,
                                                        ' taF');

            if (!KeyValueInformation) {
                return STATUS_NO_MEMORY;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PULONG DataPtr;

            //
            // Return contents to the caller.
            //

            DataPtr = (PULONG)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
            *Value = *DataPtr;

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\notify.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Notify.c

Abstract:

    The Notify package provides support to filesystems which implement
    NotifyChangeDirectory.  This package will manage a queue of notify
    blocks which are attached to some filesystem structure (i.e. Vcb
    in Fat, HPFS).  The filesystems will allocate a fast mutex to be used
    by this package to synchronize access to the notify queue.

    The following routines are provided by this package:

        o  FsRtlNotifyInitializeSync - Create and initializes the
           synchronization object.

        o  FsrtlNotifyUninitializeSync - Deallocates the synchronization
           object.

        o  FsRtlNotifyChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This
           routine allocates any necessary structures and places the
           Irp in the NotifyQueue (or possibly completes or cancels it
           immediately).

        o  FsRtlNotifyFullChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This differs
           from the FsRtlNotifyChangeDirectory in that it expects to return
           the notify information in the user's buffer.

        o  FsRtlNotifyFilterChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This differs
           from the FsRtlNotifyFullChangeDirectory in that it accepts a
           FilterRoutine Callback.

        o  FsRtlNotifyReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine will
           walk through the notify queue to see if any Irps are affected
           by the indicated operation.

        o  FsRtlNotifyFullReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine differs
           from the FsRtlNotifyReportChange call in that it returns more
           detailed information in the caller's buffer if present.

        o  FsRtlNotifyFilterReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine differs
           from the FsRtlNotifyFullReportChange call in that it accepts a
           FilterContext parameter for notifyees who specified a FilterRoutine.

        o  FsRtlNotifyCleanup - This routine is called to remove any
           references to a particular FsContext structure from the notify
           queue.  If the matching FsContext structure is found in the
           queue, then all associated Irps are completed.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x04000000)

//
//  This is the synchronization object for the notify package.  The caller
//  given a pointer to this structure.
//

typedef struct _REAL_NOTIFY_SYNC {

    FAST_MUTEX FastMutex;
    ERESOURCE_THREAD OwningThread;
    ULONG OwnerCount;

} REAL_NOTIFY_SYNC, *PREAL_NOTIFY_SYNC;

//
//  A list of the following structures is used to store the NotifyChange
//  requests.  They are linked to a filesystem-defined list head.
//

typedef struct _NOTIFY_CHANGE {

    //
    //  Fast Mutex.  This fast mutex is used to access the list containing this
    //  structure.
    //

    PREAL_NOTIFY_SYNC NotifySync;

    //
    //  FsContext.  This value is given by the filesystems to uniquely
    //  identify this structure.  The identification is on a
    //  per-user file object basis.  The expected value is the Ccb address
    //  for this user file object.
    //

    PVOID FsContext;

    //
    //  StreamID.  This value matches the FsContext field in the file object for
    //  the directory being watched.  This is used to identify the directory stream
    //  when the directory is being deleted.
    //

    PVOID StreamID;

    //
    //  TraverseAccessCallback.  This is the filesystem-supplied routine used
    //  to call back into the filesystem to check whether the caller has traverse
    //  access when watching a sub-directory.  Only applies when watching a
    //  sub-directory.
    //

    PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback;

    //
    //  SubjectContext.  If the caller specifies a traverse callback routine
    //  we will need to pass the Security Context from the thread which
    //  originated this call.  The notify package will free this structure
    //  on tearing down the notify package.  We don't expect to need this
    //  structure often.
    //

    PSECURITY_SUBJECT_CONTEXT SubjectContext;

    //
    //  Full Directory Name.  The following string is the full directory
    //  name of the directory being watched.  It is used during watch tree
    //  operations to check whether this directory is an ancestor of
    //  the modified file.  The string could be in ANSI or UNICODE form.
    //

    PSTRING FullDirectoryName;

    //
    //  Notify List.  The following field links the notify structures for
    //  a particular volume.
    //

    LIST_ENTRY NotifyList;

    //
    //  Notify Irps.  The following field links the Irps associated with
    //
    //

    LIST_ENTRY NotifyIrps;

    //
    //  FilterCallback.  This is the filesystem-supplied routine used
    //  to call back into the filesystem to check whether a Notify block
    //  should see the change.  (Initially added for TxfNtfs development
    //  as part of a strategy to control when, not if, transactions see
    //  changes from other transactions.)
    //

    PFILTER_REPORT_CHANGE FilterCallback;

    //
    //  Flags.  State of the notify for this volume.
    //

    USHORT Flags;

    //
    //  Character size.  Larger size indicates unicode characters.
    //  unicode names.
    //

    UCHAR CharacterSize;

    //
    //  Completion Filter.  This field is used to mask the modification
    //  actions to determine whether to complete the notify irp.
    //

    ULONG CompletionFilter;

    //
    //  The following values are used to manage a buffer if there is no current
    //  Irp to complete. The fields have the following meaning:
    //
    //      AllocatedBuffer     - Buffer we need to allocate
    //      Buffer              - Buffer to store data in
    //      BufferLength        - Length of original user buffer
    //      ThisBufferLength    - Length of the buffer we are using
    //      DataLength          - Current length of the data in the buffer
    //      LastEntry           - Offset of previous entry in the buffer
    //

    PVOID AllocatedBuffer;
    PVOID Buffer;
    ULONG BufferLength;
    ULONG ThisBufferLength;
    ULONG DataLength;
    ULONG LastEntry;

    //
    //  Reference count which keeps the notify structure around.  Such references include
    //
    //      - Lifetime reference.  Count set to one initially and removed on cleanup
    //      - Cancel reference.  Reference the notify struct when storing the cancel routine
    //          in the Irp.  The routine which actually clears the routine will decrement
    //          this value.
    //

    ULONG ReferenceCount;

    //
    //  This is the process on whose behalf the structure was allocated.  We
    //  charge any quota to this process.
    //

    PEPROCESS OwningProcess;

} NOTIFY_CHANGE, *PNOTIFY_CHANGE;

#define NOTIFY_WATCH_TREE               (0x0001)
#define NOTIFY_IMMEDIATE_NOTIFY         (0x0002)
#define NOTIFY_CLEANUP_CALLED           (0x0004)
#define NOTIFY_DEFER_NOTIFY             (0x0008)
#define NOTIFY_DIR_IS_ROOT              (0x0010)
#define NOTIFY_STREAM_IS_DELETED        (0x0020)

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((PCHAR)(OFFSET) - (PCHAR)(BASE)))

//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

#define SetFlag(F,SF) {     \
    (F) |= (SF);            \
}

#define ClearFlag(F,SF) {   \
    (F) &= ~(SF);           \
}

//
//  VOID
//  AcquireNotifySync (
//      IN PREAL_NOTIFY_SYNC NotifySync
//      );
//
//  VOID
//  ReleaseNotifySync (
//      IN PREAL_NOTIFY_SYNC NotifySync
//      );
//

#define AcquireNotifySync(NS) {                                             \
    ERESOURCE_THREAD _CurrentThread;                                        \
    _CurrentThread = (ERESOURCE_THREAD) PsGetCurrentThread();               \
    if (_CurrentThread != ((PREAL_NOTIFY_SYNC) (NS))->OwningThread) {       \
        ExAcquireFastMutexUnsafe( &((PREAL_NOTIFY_SYNC) (NS))->FastMutex ); \
        ((PREAL_NOTIFY_SYNC) (NS))->OwningThread = _CurrentThread;          \
    }                                                                       \
    ((PREAL_NOTIFY_SYNC) (NS))->OwnerCount += 1;                            \
}

#define ReleaseNotifySync(NS) {                                             \
    ((PREAL_NOTIFY_SYNC) (NS))->OwnerCount -= 1;                            \
    if (((PREAL_NOTIFY_SYNC) (NS))->OwnerCount == 0) {                      \
        ((PREAL_NOTIFY_SYNC) (NS))->OwningThread = (ERESOURCE_THREAD) 0;    \
        ExReleaseFastMutexUnsafe(&((PREAL_NOTIFY_SYNC) (NS))->FastMutex);   \
    }                                                                       \
}

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('NrSF')


//
//  Local support routines
//

PNOTIFY_CHANGE
FsRtlIsNotifyOnList (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    );

VOID
FsRtlNotifyCompleteIrp (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify,
    IN ULONG DataLength,
    IN NTSTATUS Status,
    IN ULONG CheckCancel
    );

BOOLEAN
FsRtlNotifySetCancelRoutine (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify OPTIONAL
    );

BOOLEAN
FsRtlNotifyUpdateBuffer (
    IN PFILE_NOTIFY_INFORMATION NotifyInfo,
    IN ULONG FileAction,
    IN PSTRING ParentName,
    IN PSTRING TargetName,
    IN PSTRING StreamName OPTIONAL,
    IN BOOLEAN UnicodeName,
    IN ULONG SizeOfEntry
    );

VOID
FsRtlNotifyCompleteIrpList (
    IN PNOTIFY_CHANGE Notify,
    IN NTSTATUS Status
    );

VOID
FsRtlCancelNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    );

VOID
FsRtlCheckNotifyForDelete (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlNotifyInitializeSync)
#pragma alloc_text(PAGE, FsRtlNotifyUninitializeSync)
#pragma alloc_text(PAGE, FsRtlNotifyFullChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyFullReportChange)
#pragma alloc_text(PAGE, FsRtlNotifyFilterChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyFilterReportChange)
#pragma alloc_text(PAGE, FsRtlIsNotifyOnList)
#pragma alloc_text(PAGE, FsRtlNotifyChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyCleanup)
#pragma alloc_text(PAGE, FsRtlNotifyCompleteIrp)
#pragma alloc_text(PAGE, FsRtlNotifyReportChange)
#pragma alloc_text(PAGE, FsRtlNotifyUpdateBuffer)
#pragma alloc_text(PAGE, FsRtlCheckNotifyForDelete)
#pragma alloc_text(PAGE, FsRtlNotifyCompleteIrpList)
#endif


NTKERNELAPI
VOID
FsRtlNotifyInitializeSync (
    __in PNOTIFY_SYNC *NotifySync
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the synchronization object
    for this notify list.

Arguments:

    NotifySync  -  This is the address to store the structure we allocate.

Return Value:

    None.

--*/

{
    PREAL_NOTIFY_SYNC RealSync;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyInitializeSync:  Entered\n", 0 );

    //
    //  Clear the pointer and then attempt to allocate a non-paged
    //  structure.
    //

    *NotifySync = NULL;

    RealSync = (PREAL_NOTIFY_SYNC) FsRtlpAllocatePool( NonPagedPool,
                                                       sizeof( REAL_NOTIFY_SYNC ));

    //
    //  Initialize the structure.
    //

    ExInitializeFastMutex( &RealSync->FastMutex );
    RealSync->OwningThread = (ERESOURCE_THREAD) 0;
    RealSync->OwnerCount = 0;

    *NotifySync = (PNOTIFY_SYNC) RealSync;

    DebugTrace( -1, Dbg, "FsRtlNotifyInitializeSync:  Exit\n", 0 );
    return;
}


NTKERNELAPI
VOID
FsRtlNotifyUninitializeSync (
    __in PNOTIFY_SYNC *NotifySync
    )

/*++

Routine Description:

    This routine is called to uninitialize the synchronization object
    for this notify list.

Arguments:

    NotifySync  -  This is the address containing the pointer to our synchronization
        object.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyUninitializeSync:  Entered\n", 0 );

    //
    //  Free the structure if present and clear the pointer.
    //

    if (*NotifySync != NULL) {

        ExFreePool( *NotifySync );
        *NotifySync = NULL;
    }

    DebugTrace( -1, Dbg, "FsRtlNotifyUninitializeSync:  Exit\n", 0 );
    return;
}


VOID
FsRtlNotifyChangeDirectory (
    __in PNOTIFY_SYNC NotifySync,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in PLIST_ENTRY NotifyList,
    __in BOOLEAN WatchTree,
    __in ULONG CompletionFilter,
    __in PIRP NotifyIrp
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    FsContext  -  This is supplied by the file system so that this notify
                  structure can be uniquely identified.

    FullDirectoryName  -  Points to the full name for the directory associated
                          with this notify structure.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    WatchTree  -  This indicates whether all subdirectories for this directory
                  should be watched, or just the directory itself.

    CompletionFilter  -  This provides the mask to determine which operations
                         will trigger the notify operations.

    NotifyIrp  -  This is the Irp to complete on notify change.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyChangeDirectory:  Entered\n", 0 );

    //
    //  We will simply call the full notify routine to do the real work.
    //

    FsRtlNotifyFilterChangeDirectory( NotifySync,
                                      NotifyList,
                                      FsContext,
                                      FullDirectoryName,
                                      WatchTree,
                                      TRUE,
                                      CompletionFilter,
                                      NotifyIrp,
                                      NULL,
                                      NULL,
                                      NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyChangeDirectory:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFullChangeDirectory (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in BOOLEAN WatchTree,
    __in BOOLEAN IgnoreBuffer,
    __in ULONG CompletionFilter,
    __in PIRP NotifyIrp,
    __in_opt PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectContext
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

    This is the version of this routine which understands about the user's
    buffer and will fill it in on a reported change.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FsContext  -  This is supplied by the file system so that this notify
        structure can be uniquely identified.  If the NotifyIrp is not specified
        then this is used to identify the stream and it will match the FsContext
        field in the file object of a stream being deleted.

    FullDirectoryName  -  Points to the full name for the directory associated
        with this notify structure.  Ignored if the NotifyIrp is not specified.

    WatchTree  -  This indicates whether all subdirectories for this directory
        should be watched, or just the directory itself.  Ignored if the
        NotifyIrp is not specified.

    IgnoreBuffer  -  Indicates whether we will always ignore any user buffer
        and force the directory to be reenumerated.  This will speed up the
        operation.  Ignored if the NotifyIrp is not specified.

    CompletionFilter  -  This provides the mask to determine which operations
        will trigger the notify operations.  Ignored if the NotifyIrp is not
        specified.

    NotifyIrp  -  This is the Irp to complete on notify change.  If this irp is
        not specified it means that the stream represented by this file object
        is being deleted.

    TraverseCallback  -  If specified we must call this routine when a change
        has occurred in a subdirectory being watched in a tree.  This will
        let the filesystem check if the watcher has traverse access to that
        directory.  Ignored if the NotifyIrp is not specified.

    SubjectContext - If there is a traverse callback routine then we will
        pass this subject context as a parameter to the call.  We will release
        the context and free the structure when done with it.  Ignored if the
        NotifyIrp is not specified, NULL in these cases.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullChangeDirectory:  Entered\n", 0 );

    //
    //  We will simply call the full notify routine to do the real work.
    //

    FsRtlNotifyFilterChangeDirectory( NotifySync,
                                      NotifyList,
                                      FsContext,
                                      FullDirectoryName,
                                      WatchTree,
                                      IgnoreBuffer,
                                      CompletionFilter,
                                      NotifyIrp,
                                      TraverseCallback,
                                      SubjectContext,
                                      NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyFullChangeDirectory:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFilterChangeDirectory (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext,
    __in PSTRING FullDirectoryName,
    __in BOOLEAN WatchTree,
    __in BOOLEAN IgnoreBuffer,
    __in ULONG CompletionFilter,
    __in PIRP NotifyIrp,
    __in_opt PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback,
    __in_opt PSECURITY_SUBJECT_CONTEXT SubjectContext,
    __in_opt PFILTER_REPORT_CHANGE FilterCallback
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

    This is the version of this routine which understands about the user's
    buffer and will fill it in on a reported change.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FsContext  -  This is supplied by the file system so that this notify
        structure can be uniquely identified.  If the NotifyIrp is not specified
        then this is used to identify the stream and it will match the FsContext
        field in the file object of a stream being deleted.

    FullDirectoryName  -  Points to the full name for the directory associated
        with this notify structure.  Ignored if the NotifyIrp is not specified.

    WatchTree  -  This indicates whether all subdirectories for this directory
        should be watched, or just the directory itself.  Ignored if the
        NotifyIrp is not specified.

    IgnoreBuffer  -  Indicates whether we will always ignore any user buffer
        and force the directory to be reenumerated.  This will speed up the
        operation.  Ignored if the NotifyIrp is not specified.

    CompletionFilter  -  This provides the mask to determine which operations
        will trigger the notify operations.  Ignored if the NotifyIrp is not
        specified.

    NotifyIrp  -  This is the Irp to complete on notify change.  If this irp is
        not specified it means that the stream represented by this file object
        is being deleted.

    TraverseCallback  -  If specified we must call this routine when a change
        has occurred in a subdirectory being watched in a tree.  This will
        let the filesystem check if the watcher has traverse access to that
        directory.  Ignored if the NotifyIrp is not specified.

    SubjectContext - If there is a traverse callback routine then we will
        pass this subject context as a parameter to the call.  We will release
        the context and free the structure when done with it.  Ignored if the
        NotifyIrp is not specified.

    FilterCallback - This is the filesystem-supplied routine used
        to call back into the filesystem to check whether this Notify block
        should see the change.  (Initially added for TxfNtfs development
        as part of a strategy to control when, not if, transactions see
        changes from other transactions.)

Return Value:

    None.

--*/

{
    PNOTIFY_CHANGE Notify = NULL;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullChangeDirectory:  Entered\n", 0 );

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there is no Irp then find all of the pending Irps whose file objects
        //  refer to the same stream and complete them with STATUS_DELETE_PENDING.
        //

        if (NotifyIrp == NULL) {

            FsRtlCheckNotifyForDelete( NotifyList, FsContext );
            try_return( NOTHING );
        }

        //
        //  Get the current Stack location
        //

        IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

        //
        //  Clear the Iosb in the Irp.
        //

        NotifyIrp->IoStatus.Status = STATUS_SUCCESS;
        NotifyIrp->IoStatus.Information = 0;

        //
        //  If the file object has already gone through cleanup, then complete
        //  the request immediately.
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_CLEANUP );
            try_return( NOTHING );
        }

        //
        //  If the notify structure is not already in the list, add it
        //  now.
        //

        Notify = FsRtlIsNotifyOnList( NotifyList, FsContext );

        if (Notify == NULL) {

            //
            //  Allocate and initialize the structure.
            //

            Notify = FsRtlpAllocatePool( PagedPool, sizeof( NOTIFY_CHANGE ));
            RtlZeroMemory( Notify, sizeof( NOTIFY_CHANGE ));

            Notify->NotifySync = (PREAL_NOTIFY_SYNC) NotifySync;
            Notify->FsContext = FsContext;
            Notify->StreamID = IrpSp->FileObject->FsContext;

            Notify->TraverseCallback = TraverseCallback;
            Notify->SubjectContext = SubjectContext;
            SubjectContext = NULL;
            Notify->FilterCallback = FilterCallback;

            Notify->FullDirectoryName = FullDirectoryName;

            InitializeListHead( &Notify->NotifyIrps );

            if (WatchTree) {

                SetFlag( Notify->Flags, NOTIFY_WATCH_TREE );
            }

            if (FullDirectoryName == NULL) {

                //
                //  In the view index we aren't using this buffer to hold a
                //  unicode string.
                //

                Notify->CharacterSize = sizeof( CHAR );

            } else {

                //
                //  We look at the directory name to decide if we have a unicode
                //  name.
                //

                if (FullDirectoryName->Length >= 2
                    && FullDirectoryName->Buffer[1] == '\0') {

                    Notify->CharacterSize = sizeof( WCHAR );

                } else {

                    Notify->CharacterSize = sizeof( CHAR );
                }

                if (FullDirectoryName->Length == Notify->CharacterSize) {

                    SetFlag( Notify->Flags, NOTIFY_DIR_IS_ROOT );
                }
            }

            Notify->CompletionFilter = CompletionFilter;

            //
            //  If we are to return data to the user then look for the length
            //  of the original buffer in the IrpSp.
            //

            if (!IgnoreBuffer) {

                Notify->BufferLength = IrpSp->Parameters.NotifyDirectory.Length;
            }

            Notify->OwningProcess = THREAD_TO_PROCESS( NotifyIrp->Tail.Overlay.Thread );
            InsertTailList( NotifyList, &Notify->NotifyList );

            Notify->ReferenceCount = 1;

        //
        //  If we have already been called with cleanup then complete
        //  the request immediately.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_CLEANUP_CALLED )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_CLEANUP );
            try_return( NOTHING );

        //
        //  If this file has been deleted then complete with STATUS_DELETE_PENDING.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_STREAM_IS_DELETED )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_DELETE_PENDING );
            try_return( NOTHING );

        //
        //  If the notify pending flag is set or there is data in an internal buffer
        //  we complete this Irp immediately and exit.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                   && !FlagOn( Notify->Flags, NOTIFY_DEFER_NOTIFY )) {

            DebugTrace( 0, Dbg, "Notify has been pending\n", 0 );

            //
            //  Clear the flag in our notify structure before completing the
            //  Irp.  This will prevent a caller who reposts in his completion
            //  routine from looping in the completion routine.
            //

            ClearFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_ENUM_DIR );
            try_return( NOTHING );

        } else if (Notify->DataLength != 0
                   && !FlagOn( Notify->Flags, NOTIFY_DEFER_NOTIFY )) {

            ULONG ThisDataLength = Notify->DataLength;

            //
            //  Now set our buffer pointers back to indicate an empty buffer.
            //

            Notify->DataLength = 0;
            Notify->LastEntry = 0;

            FsRtlNotifyCompleteIrp( NotifyIrp,
                                    Notify,
                                    ThisDataLength,
                                    STATUS_SUCCESS,
                                    FALSE );

            try_return( NOTHING );
        }

        //
        //  Add the Irp to the tail of the notify queue.
        //

        NotifyIrp->IoStatus.Information = (ULONG_PTR) Notify;
        IoMarkIrpPending( NotifyIrp );
        InsertTailList( &Notify->NotifyIrps, &NotifyIrp->Tail.Overlay.ListEntry );

        //
        //  Increment the reference count to indicate that Irp might go through cancel.
        //

        InterlockedIncrement( (PLONG)&Notify->ReferenceCount );

        //
        //  Call the routine to set the cancel routine.
        //

        FsRtlNotifySetCancelRoutine( NotifyIrp, NULL );

    try_exit:  NOTHING;
    } finally {

        //
        //  Release the mutex.
        //

        ReleaseNotifySync( NotifySync );

        //
        //  If there is still a subject context then release it and deallocate
        //  the structure.  Remember that if FullDirectoryName is null, it means
        //  this is a view index, not a directory index, and the SubjectContext
        //  is really a piece of file system context information.
        //

        if ((SubjectContext != NULL) &&
            ((Notify == NULL) ||
             (Notify->FullDirectoryName != NULL))) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        DebugTrace( -1, Dbg, "FsRtlNotifyFullChangeDirectory:  Exit\n", 0 );
    }

    return;
}


VOID
FsRtlNotifyReportChange (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PSTRING FullTargetName,
    __in PSTRING TargetName,
    __in ULONG FilterMatch
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    FullTargetName  -  This is the full name of the file which has been
                       changed.

    TargetName  -  This is the final component of the modified file.

    FilterMatch  -  This flag field is compared with the completion filter
                    in the notify structure.  If any of the corresponding
                    bits in the completion filter are set, then a notify
                    condition exists.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyReportChange:  Entered\n", 0 );

    //
    //  Call the full notify routine to do the actual work.
    //

    FsRtlNotifyFilterReportChange( NotifySync,
                                   NotifyList,
                                   FullTargetName,
                                   (USHORT) (FullTargetName->Length - TargetName->Length),
                                   NULL,
                                   NULL,
                                   FilterMatch,
                                   0,
                                   NULL,
                                   NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyReportChange:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFullReportChange (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PSTRING FullTargetName,
    __in USHORT TargetNameOffset,
    __in_opt PSTRING StreamName,
    __in_opt PSTRING NormalizedParentName,
    __in ULONG FilterMatch,
    __in ULONG Action,
    __in PVOID TargetContext
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FullTargetName - This is the full name of the file from the root of the volume.

    TargetNameOffset - This is the offset in the full name of the final component
        of the name.

    StreamName  -  If present then this is the stream name to store with
        the filename.

    NormalizedParentName  -  If present this is the same path as the parent name
        but the DOS-ONLY names have been replaced with the associated long name.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    TargetContext  -  This is one of the context pointers to pass to the file
        system if performing a traverse check in the case of a tree being
        watched.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyReportChange:  Entered\n", 0 );

    //
    //  Call the full notify routine to do the actual work.
    //

    FsRtlNotifyFilterReportChange( NotifySync,
                                   NotifyList,
                                   FullTargetName,
                                   TargetNameOffset,
                                   StreamName,
                                   NormalizedParentName,
                                   FilterMatch,
                                   Action,
                                   TargetContext,
                                   NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyReportChange:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFilterReportChange (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PSTRING FullTargetName,
    __in USHORT TargetNameOffset,
    __in_opt PSTRING StreamName,
    __in_opt PSTRING NormalizedParentName,
    __in ULONG FilterMatch,
    __in ULONG Action,
    __in_opt PVOID TargetContext,
    __in_opt PVOID FilterContext
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FullTargetName - This is the full name of the file from the root of the volume.

    TargetNameOffset - This is the offset in the full name of the final component
        of the name.

    StreamName  -  If present then this is the stream name to store with
        the filename.

    NormalizedParentName  -  If present this is the same path as the parent name
        but the DOS-ONLY names have been replaced with the associated long name.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    TargetContext  -  This is one of the context pointers to pass to the file
        system if performing a traverse check in the case of a tree being
        watched.

    FilterContext - This is the filesystem-supplied routine used
        to call back into the filesystem to check whether each Notify block
        should see the change.  (Initially added for TxfNtfs development
        as part of a strategy to control when, not if, transactions see
        changes from other transactions.)

Return Value:

    None.

--*/

{
    PLIST_ENTRY NotifyLinks;

    STRING NormalizedParent;
    STRING ParentName = {0};
    STRING TargetName = {0};

    PNOTIFY_CHANGE Notify;
    STRING TargetParent = {0};
    PIRP NotifyIrp;

    BOOLEAN NotifyIsParent;
    BOOLEAN ViewIndex = FALSE;
    UCHAR ComponentCount;
    ULONG SizeOfEntry;
    ULONG CurrentOffset;
    ULONG NextEntryOffset;
    ULONG ExceptionCode = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullReportChange:  Entered\n", 0 );

    //
    //  If this is a change to the root directory then return immediately.
    //

    if ((TargetNameOffset == 0) && (FullTargetName != NULL)) {

        DebugTrace( -1, Dbg, "FsRtlNotifyFullReportChange:  Exit\n", 0 );
        return;
    }

    ParentName.Buffer = NULL;
    TargetName.Buffer = NULL;

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Walk through all the notify blocks.
        //

        for (NotifyLinks = NotifyList->Flink;
             NotifyLinks != NotifyList;
             NotifyLinks = NotifyLinks->Flink) {

            //
            //  Obtain the Notify structure from the list entry.
            //

            Notify = CONTAINING_RECORD( NotifyLinks, NOTIFY_CHANGE, NotifyList );

            //
            //  The rules for deciding whether this notification applies are
            //  different for view indices versus file name indices (directories).
            //

            if (FullTargetName == NULL) {

                ASSERTMSG( "Directory notify handle in view index notify list!", Notify->FullDirectoryName == NULL);

                //
                //  Make sure this is the Fcb being watched.
                //

                if (TargetContext != Notify->SubjectContext) {

                    continue;
                }

                TargetParent.Buffer = NULL;
                TargetParent.Length = 0;

                ViewIndex = TRUE;
                NotifyIsParent = FALSE;

            //
            //  Handle the directory case.
            //

            } else {

                ASSERTMSG( "View index notify handle in directory notify list!", Notify->FullDirectoryName != NULL);

                //
                //  If the length of the name in the notify block is currently zero then
                //  someone is doing a rename and we can skip this block.
                //

                if (Notify->FullDirectoryName->Length == 0) {

                    continue;
                }

                //
                //  If this filter match is not part of the completion filter then continue.
                //

                if (!(FilterMatch & Notify->CompletionFilter)) {

                    continue;
                }

                //
                //  If there is no normalized name then set its value from the full
                //  file name.
                //

                if (!ARGUMENT_PRESENT( NormalizedParentName )) {
                    NormalizedParent.Buffer = FullTargetName->Buffer;
                    NormalizedParent.Length = TargetNameOffset;

                    if (NormalizedParent.Length != Notify->CharacterSize) {

                        NormalizedParent.Length = (USHORT)(NormalizedParent.Length - Notify->CharacterSize);
                    }

                    NormalizedParent.MaximumLength = NormalizedParent.Length;

                    NormalizedParentName = &NormalizedParent;
                }

                //
                //  If the length of the directory being watched is longer than the
                //  parent of the modified file then it can't be an ancestor of the
                //  modified file.
                //

                if (Notify->FullDirectoryName->Length > NormalizedParentName->Length) {

                    continue;
                }

                //
                //  If the lengths match exactly then this can only be the parent of
                //  the modified file.
                //

                if (NormalizedParentName->Length == Notify->FullDirectoryName->Length) {

                    NotifyIsParent = TRUE;

                //
                //  If we are not watching the subtree of this directory then continue.
                //

                } else if (!FlagOn( Notify->Flags, NOTIFY_WATCH_TREE )) {

                    continue;

                //
                //  The watched directory can only be an ancestor of the modified
                //  file.  Make sure that there is legal pathname separator immediately
                //  after the end of the watched directory name within the normalized name.
                //  If the watched directory is the root then we know this condition is TRUE.
                //

                } else {

                    if (!FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT )) {

                        //
                        //  Check for the character size.
                        //

                        if (Notify->CharacterSize == sizeof( CHAR )) {

                            if (*(Add2Ptr( NormalizedParentName->Buffer,
                                           Notify->FullDirectoryName->Length,
                                           PCHAR )) != '\\') {

                                continue;
                            }

                        } else if (*(Add2Ptr( NormalizedParentName->Buffer,
                                              Notify->FullDirectoryName->Length,
                                              PWCHAR )) != L'\\') {

                            continue;
                        }
                    }

                    NotifyIsParent = FALSE;
                }

                //
                //  We now have a correct match of the name lengths.  Now verify that the
                //  characters match exactly.
                //

                if (!RtlEqualMemory( Notify->FullDirectoryName->Buffer,
                                     NormalizedParentName->Buffer,
                                     Notify->FullDirectoryName->Length )) {

                    continue;
                }

                //
                //  The characters are correct.  Now check in the case of a non-parent
                //  notify that we have traverse callback.
                //

                if (!NotifyIsParent &&
                    Notify->TraverseCallback != NULL &&
                    !Notify->TraverseCallback( Notify->FsContext,
                                               TargetContext,
                                               Notify->SubjectContext )) {

                    continue;
                }

                //
                //  Finally, if Notify block has a FilterRoutine *and* the caller specified
                //  a FilterContext, then we must finally call the filter routine.
                //

                if ((Notify->FilterCallback != NULL) &&
                    ARGUMENT_PRESENT( FilterContext ) &&
                    !Notify->FilterCallback( Notify->FsContext, FilterContext )) {

                    continue;
                }
            }

            //
            //  If this entry is going into a buffer then check that
            //  it will fit.
            //

            if (!FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                && Notify->BufferLength != 0) {

                ULONG AllocationLength;

                AllocationLength = 0;
                NotifyIrp = NULL;

                //
                //  If we don't already have a buffer then check to see
                //  if we have any Irps in the list and use the buffer
                //  length in the Irp.
                //

                if (Notify->ThisBufferLength == 0) {

                    //
                    //  If there is an entry in the list then get the length.
                    //

                    if (!IsListEmpty( &Notify->NotifyIrps )) {

                        PIO_STACK_LOCATION IrpSp;

                        NotifyIrp = CONTAINING_RECORD( Notify->NotifyIrps.Flink,
                                                       IRP,
                                                       Tail.Overlay.ListEntry );

                        IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

                        AllocationLength = IrpSp->Parameters.NotifyDirectory.Length;

                    //
                    //  Otherwise use the caller's last buffer size.
                    //

                    } else {

                        AllocationLength = Notify->BufferLength;
                    }

                //
                //  Otherwise use the length of the current buffer.
                //

                } else {

                    AllocationLength = Notify->ThisBufferLength;
                }

                //
                //  Build the strings for the relative name.  This includes
                //  the strings for the parent name, file name and stream
                //  name.
                //

                if (!NotifyIsParent) {

                    //
                    //  We need to find the string for the ancestor of this
                    //  file from the watched directory.  If the normalized parent
                    //  name is the same as the parent name then we can use
                    //  the tail of the parent directly.  Otherwise we need to
                    //  count the matching name components and capture the
                    //  final components.
                    //

                    if (!ViewIndex) {

                        //
                        //  If the watched directory is the root then we just use the full
                        //  parent name.
                        //

                        if (FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT ) ||
                            NormalizedParentName->Buffer != FullTargetName->Buffer) {

                            //
                            //  If we don't have a string for the parent then construct
                            //  it now.
                            //

                            if (ParentName.Buffer == NULL) {

                                ParentName.Buffer = FullTargetName->Buffer;
                                ParentName.Length = TargetNameOffset;

                                if (ParentName.Length != Notify->CharacterSize) {

                                    ParentName.Length = (USHORT)(ParentName.Length - Notify->CharacterSize);
                                }

                                ParentName.MaximumLength = ParentName.Length;
                            }

                            //
                            //  Count through the components of the parent until we have
                            //  swallowed the same number of name components as in the
                            //  watched directory name.  We have the unicode version and
                            //  the Ansi version to watch for.
                            //

                            ComponentCount = 0;
                            CurrentOffset = 0;

                            //
                            //  If this is the root then there is no more to do.
                            //

                            if (FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT )) {

                                NOTHING;

                            } else {

                                ULONG ParentComponentCount;
                                ULONG ParentOffset;

                                ParentComponentCount = 1;
                                ParentOffset = 0;

                                if (Notify->CharacterSize == sizeof( CHAR )) {

                                    //
                                    //  Find the number of components in the parent.  We
                                    //  have to do this for each one because this name and
                                    //  the number of components could have changed.
                                    //

                                    while (ParentOffset < Notify->FullDirectoryName->Length) {

                                        if (*((PCHAR) Notify->FullDirectoryName->Buffer + ParentOffset) == '\\') {

                                            ParentComponentCount += 1;
                                        }

                                        ParentOffset += 1;
                                    }

                                    while (TRUE) {

                                        if (*((PCHAR) ParentName.Buffer + CurrentOffset) == '\\') {

                                            ComponentCount += 1;

                                            if (ComponentCount == ParentComponentCount) {

                                                break;
                                            }

                                        }

                                        CurrentOffset += 1;
                                    }

                                } else {

                                    //
                                    //  Find the number of components in the parent.  We
                                    //  have to do this for each one because this name and
                                    //  the number of components could have changed.
                                    //

                                    while (ParentOffset < Notify->FullDirectoryName->Length / sizeof( WCHAR )) {

                                        if (*((PWCHAR) Notify->FullDirectoryName->Buffer + ParentOffset) == '\\') {

                                            ParentComponentCount += 1;
                                        }

                                        ParentOffset += 1;
                                    }

                                    while (TRUE) {

                                        if (*((PWCHAR) ParentName.Buffer + CurrentOffset) == L'\\') {

                                            ComponentCount += 1;

                                            if (ComponentCount == ParentComponentCount) {

                                                break;
                                            }
                                        }

                                        CurrentOffset += 1;
                                    }

                                    //
                                    //  Convert characters to bytes.
                                    //

                                    CurrentOffset *= Notify->CharacterSize;
                                }
                            }

                            //
                            //  We now know the offset into the parent name of the separator
                            //  immediately preceding the relative parent name.  Construct the
                            //  target parent name for the buffer.
                            //

                            CurrentOffset += Notify->CharacterSize;

                            TargetParent.Buffer = Add2Ptr( ParentName.Buffer,
                                                           CurrentOffset,
                                                           PCHAR );
                            TargetParent.MaximumLength =
                            TargetParent.Length = ParentName.Length - (USHORT) CurrentOffset;

                        //
                        //  If the normalized is the same as the parent name use the portion
                        //  after the match with the watched directory.
                        //

                        } else {

                            TargetParent.Buffer = Add2Ptr( NormalizedParentName->Buffer,
                                                           (Notify->FullDirectoryName->Length +
                                                            Notify->CharacterSize),
                                                           PCHAR );

                            TargetParent.MaximumLength =
                            TargetParent.Length = NormalizedParentName->Length -
                                                  Notify->FullDirectoryName->Length -
                                                  Notify->CharacterSize;

                        }
                    }

                } else {

                    //
                    //  The length of the target parent is zero.
                    //

                    TargetParent.Length = 0;
                }

                //
                //  Compute how much buffer space this report will take.
                //

                SizeOfEntry = FIELD_OFFSET( FILE_NOTIFY_INFORMATION, FileName );

                if (ViewIndex) {

                    //
                    //  In the view index case, the information to copy to the
                    //  buffer comes to us in the stream name, and that is all
                    //  the room we need to worry about having.
                    //

                    ASSERT(ARGUMENT_PRESENT( StreamName ));

                    SizeOfEntry += StreamName->Length;

                } else {

                    //
                    //  If there is a parent to report, find the size and include a separator
                    //  character.
                    //

                    if (!NotifyIsParent) {

                        if (Notify->CharacterSize == sizeof( CHAR )) {

                            SizeOfEntry += RtlOemStringToCountedUnicodeSize( &TargetParent );

                        } else {

                            SizeOfEntry += TargetParent.Length;
                        }

                        //
                        //  Include the separator.  This is always a unicode character.
                        //

                        SizeOfEntry += sizeof( WCHAR );
                    }

                    //
                    //  If we don't have the string for the target then construct it now.
                    //

                    if (TargetName.Buffer == NULL) {

                        TargetName.Buffer = Add2Ptr( FullTargetName->Buffer, TargetNameOffset, PCHAR );
                        TargetName.MaximumLength =
                        TargetName.Length = FullTargetName->Length - TargetNameOffset;
                    }

                    if (Notify->CharacterSize == sizeof( CHAR )) {

                        SizeOfEntry += RtlOemStringToCountedUnicodeSize( &TargetName );

                    } else {

                        SizeOfEntry += TargetName.Length;
                    }

                    //
                    //  If there is a stream name then add the bytes needed
                    //  for that.
                    //

                    if (ARGUMENT_PRESENT( StreamName )) {

                        //
                        //  Add the space needed for the ':' separator.
                        //

                        if (Notify->CharacterSize == sizeof( WCHAR )) {

                            SizeOfEntry += (StreamName->Length + sizeof( WCHAR ));

                        } else {

                            SizeOfEntry += (RtlOemStringToCountedUnicodeSize( StreamName )
                                            + sizeof( CHAR ));
                        }
                    }
                }

                //
                //  Remember if this report would overflow the buffer.
                //

                NextEntryOffset = (ULONG)LongAlign( Notify->DataLength );

                if (SizeOfEntry <= AllocationLength
                    && (NextEntryOffset + SizeOfEntry) <= AllocationLength) {

                    PFILE_NOTIFY_INFORMATION NotifyInfo = NULL;

                    //
                    //  If there is already a notify buffer, we append this
                    //  data to it.
                    //

                    if (Notify->Buffer != NULL) {

                        NotifyInfo = Add2Ptr( Notify->Buffer,
                                              Notify->LastEntry,
                                              PFILE_NOTIFY_INFORMATION );

                        NotifyInfo->NextEntryOffset = NextEntryOffset - Notify->LastEntry;

                        Notify->LastEntry = NextEntryOffset;

                        NotifyInfo = Add2Ptr( Notify->Buffer,
                                              Notify->LastEntry,
                                              PFILE_NOTIFY_INFORMATION );

                    //
                    //  If there is an Irp list we check whether we will need
                    //  to allocate a new buffer.
                    //

                    } else if (NotifyIrp != NULL) {

                        if (NotifyIrp->AssociatedIrp.SystemBuffer != NULL) {

                            Notify->Buffer =
                            NotifyInfo = NotifyIrp->AssociatedIrp.SystemBuffer;

                            Notify->ThisBufferLength = AllocationLength;

                        } else if (NotifyIrp->MdlAddress != NULL) {

                            Notify->Buffer =
                            NotifyInfo = MmGetSystemAddressForMdl( NotifyIrp->MdlAddress );

                            Notify->ThisBufferLength = AllocationLength;
                        }
                    }

                    //
                    //  If we need to allocate a buffer, we will charge quota
                    //  to the original process and allocate paged pool.
                    //

                    if (Notify->Buffer == NULL) {

                        BOOLEAN ChargedQuota = FALSE;

                        try {

                            PsChargePoolQuota( Notify->OwningProcess,
                                               PagedPool,
                                               AllocationLength );

                            ChargedQuota = TRUE;

                            Notify->AllocatedBuffer =
                            Notify->Buffer = FsRtlpAllocatePool( PagedPool,
                                                                 AllocationLength );

                            Notify->ThisBufferLength = AllocationLength;

                            NotifyInfo = Notify->Buffer;

                        } except(( ExceptionCode = GetExceptionCode(), FsRtlIsNtstatusExpected(ExceptionCode))
                                  ? EXCEPTION_EXECUTE_HANDLER
                                  : EXCEPTION_CONTINUE_SEARCH ) {


                            ASSERT( (ExceptionCode == STATUS_INSUFFICIENT_RESOURCES) ||
                                    (ExceptionCode == STATUS_QUOTA_EXCEEDED) );

                            //
                            //  Return quota if we allocated the buffer.
                            //

                            if (ChargedQuota) {

                                PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                               AllocationLength );

                            }

                            //
                            //  Forget any current buffer and resort to immediate
                            //  notify.
                            //

                            SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                        }
                    }

                    //
                    //  If we have a buffer then fill in the results
                    //  from this operation.  Otherwise we remember
                    //  to simply alert the caller.
                    //

                    if (NotifyInfo != NULL) {

                        //
                        //  Update the buffer with the current data.
                        //

                        if (FsRtlNotifyUpdateBuffer( NotifyInfo,
                                                     Action,
                                                     &TargetParent,
                                                     &TargetName,
                                                     StreamName,
                                                     (BOOLEAN) (Notify->CharacterSize == sizeof( WCHAR )),
                                                     SizeOfEntry )) {

                            //
                            //  Update the buffer data length.
                            //

                            Notify->DataLength = NextEntryOffset + SizeOfEntry;

                        //
                        //  We couldn't copy the data into the buffer.  Just
                        //  notify without any additional information.
                        //

                        } else {

                            SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                        }
                    }

                } else {

                    SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                }

                //
                //  If we have a buffer but can't use it then clear all of the
                //  buffer related fields.  Also deallocate any buffer allocated
                //  by us.
                //

                if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                    && Notify->Buffer != NULL) {

                    if (Notify->AllocatedBuffer != NULL) {

                        PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                       Notify->ThisBufferLength );

                        ExFreePool( Notify->AllocatedBuffer );
                    }

                    Notify->AllocatedBuffer = Notify->Buffer = NULL;

                    Notify->ThisBufferLength = Notify->DataLength = Notify->LastEntry = 0;
                }
            }

            //
            //  Complete the next entry on the list if we aren't holding
            //  up notification.
            //

            if (Action == FILE_ACTION_RENAMED_OLD_NAME) {

                SetFlag( Notify->Flags, NOTIFY_DEFER_NOTIFY );

            } else {

                ClearFlag( Notify->Flags, NOTIFY_DEFER_NOTIFY );

                if (!IsListEmpty( &Notify->NotifyIrps )) {

                    FsRtlNotifyCompleteIrpList( Notify, STATUS_SUCCESS );
                }
            }
        }

    } finally {

        ReleaseNotifySync( NotifySync );

        DebugTrace( -1, Dbg, "FsRtlNotifyFullReportChange:  Exit\n", 0 );
    }

    return;
}


VOID
FsRtlNotifyCleanup (
    __in PNOTIFY_SYNC NotifySync,
    __in PLIST_ENTRY NotifyList,
    __in PVOID FsContext
    )

/*++

Routine Description:

    This routine is called for a cleanup of a user directory handle.  We
    walk through our notify structures looking for a matching context field.
    We complete all the pending notify Irps for this Notify structure, remove
    the notify structure and deallocate it.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    FsContext  -  This is a unique value assigned by the file system to
                  identify a particular notify structure.

Return Value:

    None.

--*/

{
    PNOTIFY_CHANGE Notify;
    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyCleanup:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Mutex             -> %08lx\n", Mutex );
    DebugTrace(  0, Dbg, "Notify List       -> %08lx\n", NotifyList );
    DebugTrace(  0, Dbg, "FsContext         -> %08lx\n", FsContext );

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Search for a match on the list.
        //

        Notify = FsRtlIsNotifyOnList( NotifyList, FsContext );

        //
        //  If found, then complete all the Irps with STATUS_NOTIFY_CLEANUP
        //

        if (Notify != NULL) {

            //
            //  Set the flag to indicate that we have been called with cleanup.
            //

            SetFlag( Notify->Flags, NOTIFY_CLEANUP_CALLED );

            if (!IsListEmpty( &Notify->NotifyIrps )) {

                FsRtlNotifyCompleteIrpList( Notify, STATUS_NOTIFY_CLEANUP );
            }

            //
            //  Cleanup can only occur once, and will always remove the notify from
            //  the list.  Cancel will defer this work to cleanup, and cannot free
            //  a notify which has not gone through cleanup since we have a ref
            //  to ensure it.
            //

            RemoveEntryList( &Notify->NotifyList );

            //
            //  We assert this in cancel routine.
            //

#if DBG
            Notify->NotifyList.Flink = NULL;
#endif

            InterlockedDecrement( (PLONG)&Notify->ReferenceCount );

            if (Notify->ReferenceCount == 0) {

                if (Notify->AllocatedBuffer != NULL) {

                    PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                   Notify->ThisBufferLength );

                    ExFreePool( Notify->AllocatedBuffer );
                }

                if (Notify->FullDirectoryName != NULL) {

                    SubjectContext = Notify->SubjectContext;
                }

                ExFreePool( Notify );
            }
        }

    } finally {

        ReleaseNotifySync( NotifySync );

        if (SubjectContext != NULL) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        DebugTrace( -1, Dbg, "FsRtlNotifyCleanup:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

PNOTIFY_CHANGE
FsRtlIsNotifyOnList (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    )

/*++

Routine Description:

    This routine is called to walk through a notify list searching for
    a member associated with the FsContext value.

Arguments:

    NotifyListHead  -  This is the start of the notify list.

    FsContext  -  This is supplied by the file system so that this notify
                  structure can be uniquely identified.

Return Value:

    PNOTIFY_CHANGE - A pointer to the matching structure is returned.  NULL
                     is returned if the structure isn't present.

--*/

{
    PLIST_ENTRY Link;

    PNOTIFY_CHANGE ThisNotify;
    PNOTIFY_CHANGE Notify;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlIsNotifyOnList:  Entered\n", 0 );

    //
    //  Assume we won't have a match.
    //

    Notify = NULL;

    //
    //  Walk through all the entries on the list looking for a match.
    //

    for (Link = NotifyListHead->Flink;
         Link != NotifyListHead;
         Link = Link->Flink) {

        //
        //  Obtain the notify structure from the link.
        //

        ThisNotify = CONTAINING_RECORD( Link, NOTIFY_CHANGE, NotifyList );

        //
        //  If the context field matches, remember this structure and
        //  exit.
        //

        if (ThisNotify->FsContext == FsContext) {

            Notify = ThisNotify;
            break;
        }
    }

    DebugTrace(  0, Dbg, "Notify Structure  -> %08lx\n", Notify );
    DebugTrace( -1, Dbg, "FsRtlIsNotifyOnList:  Exit\n", 0 );

    return Notify;
}


//
//  Local support routine
//

VOID
FsRtlNotifyCompleteIrp (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify,
    IN ULONG DataLength,
    IN NTSTATUS Status,
    IN ULONG CheckCancel
    )

/*++

Routine Description:

    This routine is called to complete an Irp with the data in the NOTIFY_CHANGE
    structure.

Arguments:

    NotifyIrp  -  Irp to complete.

    Notify  -  Notify structure which contains the data.

    DataLength  -  This is the length of the data in the buffer in the notify
        structure.  A value of zero indicates that we should complete the
        request with STATUS_NOTIFY_ENUM_DIR.

    Status  -  Indicates the status to complete the Irp with.

    CheckCancel - Indicates if we should only complete the irp if we clear the cancel routine
        ourselves.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlIsNotifyCompleteIrp:  Entered\n", 0 );

    //
    //  Attempt to clear the cancel routine.  If this routine owns the cancel
    //  routine then it can complete the irp.  Otherwise there is a cancel underway
    //  on this.
    //

    if (FsRtlNotifySetCancelRoutine( NotifyIrp, Notify ) || !CheckCancel) {

        //
        //  We only process the buffer if the status is STATUS_SUCCESS.
        //

        if (Status == STATUS_SUCCESS) {

            //
            //  Get the current Stack location
            //

            IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

            //
            //  If the data won't fit in the user's buffer or there was already a
            //  buffer overflow then return the alternate status code.  If the data
            //  was already stored in the Irp buffer then we know that we won't
            //  take this path.  Otherwise we wouldn't be cleaning up the Irp
            //  correctly.
            //

            if (DataLength == 0
                || IrpSp->Parameters.NotifyDirectory.Length < DataLength) {

                Status = STATUS_NOTIFY_ENUM_DIR;

            //
            //  We have to carefully return the buffer to the user and handle all
            //  of the different buffer cases.  If there is no allocated buffer
            //  in the notify structure it means that we have already used the
            //  caller's buffer.
            //
            //  1 - If the system allocated an associated system buffer we
            //      can simply fill that in.
            //
            //  2 - If there is an Mdl then we get a system address for the Mdl
            //      and copy the data into it.
            //
            //  3 - If there is only a user's buffer and pending has not been
            //      returned, we can fill the user's buffer in directly.
            //
            //  4 - If there is only a user's buffer and pending has been returned
            //      then we are not in the user's address space.  We dress up
            //      the Irp with our system buffer and let the Io system
            //      copy the data in.
            //

            } else {

                if (Notify->AllocatedBuffer != NULL) {

                    //
                    //  Protect the copy with a try-except and ignore the buffer
                    //  if we have some error in copying it to the buffer.
                    //

                    try {

                        if (NotifyIrp->AssociatedIrp.SystemBuffer != NULL) {

                            RtlCopyMemory( NotifyIrp->AssociatedIrp.SystemBuffer,
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else if (NotifyIrp->MdlAddress != NULL) {

                            RtlCopyMemory( MmGetSystemAddressForMdl( NotifyIrp->MdlAddress ),
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else if (!FlagOn( IrpSp->Control, SL_PENDING_RETURNED )) {

                            RtlCopyMemory( NotifyIrp->UserBuffer,
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else {

                            NotifyIrp->Flags |= (IRP_BUFFERED_IO | IRP_INPUT_OPERATION | IRP_DEALLOCATE_BUFFER);
                            NotifyIrp->AssociatedIrp.SystemBuffer = Notify->AllocatedBuffer;

                        }

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        Status = STATUS_NOTIFY_ENUM_DIR;
                        DataLength = 0;
                    }

                    //
                    //  Return the quota and deallocate the buffer if we didn't pass it
                    //  back via the irp.
                    //

                    PsReturnProcessPagedPoolQuota( Notify->OwningProcess, Notify->ThisBufferLength );

                    if (Notify->AllocatedBuffer != NotifyIrp->AssociatedIrp.SystemBuffer
                        && Notify->AllocatedBuffer != NULL) {

                        ExFreePool( Notify->AllocatedBuffer );
                    }

                    Notify->AllocatedBuffer = NULL;
                    Notify->ThisBufferLength = 0;
                }

                //
                //  Update the data length in the Irp.
                //

                NotifyIrp->IoStatus.Information = DataLength;

                //
                //  Show that there is no buffer in the notify package
                //  anymore.
                //

                Notify->Buffer = NULL;
            }
        }

        //
        //  Make sure the Irp is marked as pending returned.
        //

        IoMarkIrpPending( NotifyIrp );

        //
        //  Now complete the request.
        //

        FsRtlCompleteRequest( NotifyIrp, Status );
    }

    DebugTrace( -1, Dbg, "FsRtlIsNotifyCompleteIrp:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

BOOLEAN
FsRtlNotifySetCancelRoutine (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify OPTIONAL
    )

/*++

Routine Description:

    This is a separate routine because it cannot be paged.

Arguments:

    NotifyIrp  -  Set the cancel routine in this Irp.

    Notify - If NULL then we are setting the cancel routine.  If not-NULL then we
        are clearing the cancel routine.  If the cancel routine is not-null then
        we need to decrement the reference count on this Notify structure

Return Value:

    BOOLEAN - Only meaningful if Notify is specified.  It indicates if this
        routine cleared the cancel routine.  FALSE indicates that the cancel
        routine is processing the Irp.

--*/

{
    BOOLEAN ClearedCancel = FALSE;
    PDRIVER_CANCEL CurrentCancel;

    //
    //  Grab the cancel spinlock and set our cancel routine in the Irp.
    //

    IoAcquireCancelSpinLock( &NotifyIrp->CancelIrql );

    //
    //  If we are completing an Irp then clear the cancel routine and
    //  the information field.
    //

    if (ARGUMENT_PRESENT( Notify )) {

        CurrentCancel = IoSetCancelRoutine( NotifyIrp, NULL );
        NotifyIrp->IoStatus.Information = 0;

        IoReleaseCancelSpinLock( NotifyIrp->CancelIrql );

        //
        //  If the current cancel routine is non-NULL then decrement the reference count
        //  in the Notify.
        //

        if (CurrentCancel != NULL) {

            InterlockedDecrement( (PLONG)&Notify->ReferenceCount );
            ClearedCancel = TRUE;
        }

    //
    //  If the cancel flag is set, we complete the Irp with cancelled
    //  status and exit.
    //

    } else if (NotifyIrp->Cancel) {

            DebugTrace( 0, Dbg, "Irp has been cancelled\n", 0 );

            FsRtlCancelNotify( NULL, NotifyIrp );

    } else {

        //
        //  Set our cancel routine in the Irp.
        //

        IoSetCancelRoutine( NotifyIrp, FsRtlCancelNotify );

        IoReleaseCancelSpinLock( NotifyIrp->CancelIrql );
    }

    return ClearedCancel;
}


//
//  Local support routine
//

BOOLEAN
FsRtlNotifyUpdateBuffer (
    IN PFILE_NOTIFY_INFORMATION NotifyInfo,
    IN ULONG FileAction,
    IN PSTRING ParentName,
    IN PSTRING TargetName,
    IN PSTRING StreamName OPTIONAL,
    IN BOOLEAN UnicodeName,
    IN ULONG SizeOfEntry
    )

/*++

Routine Description:

    This routine is called to fill in a FILE_NOTIFY_INFORMATION structure for a
    notify change event.  The main work is in converting an OEM string to Unicode.

Arguments:

    NotifyInfo  -  Information structure to complete.

    FileAction  -  Action which triggered the notification event.

    ParentName  -  Relative path to the parent of the changed file from the
        directory being watched.  The length for this will be zero if the modified
        file is in the watched directory.

    TargetName  -  This is the name of the modified file.

    StreamName  -  If present there is a stream name to append to the filename.

    UnicodeName  -  Indicates if the above name is Unicode or Oem.

    SizeOfEntry  -  Indicates the number of bytes to be used in the buffer.

Return Value:

    BOOLEAN - TRUE if we were able to update the buffer, FALSE otherwise.

--*/

{
    BOOLEAN CopiedToBuffer;
    ULONG BufferOffset = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyUpdateBuffer:  Entered\n", 0 );

    //
    //  Protect the entire call with a try-except.  If we had an error
    //  we will assume that we have a bad buffer and we won't return
    //  the data in the buffer.
    //

    try {

        //
        //  Update the common fields in the notify information.
        //

        NotifyInfo->NextEntryOffset = 0;
        NotifyInfo->Action = FileAction;

        NotifyInfo->FileNameLength = SizeOfEntry - FIELD_OFFSET( FILE_NOTIFY_INFORMATION, FileName );

        //
        //  If we have a unicode name, then copy the data directly into the output buffer.
        //

        if (UnicodeName) {

            if (ParentName->Length != 0) {

                RtlCopyMemory( NotifyInfo->FileName,
                               ParentName->Buffer,
                               ParentName->Length );

                *(Add2Ptr( NotifyInfo->FileName, ParentName->Length, PWCHAR )) = L'\\';
                BufferOffset = ParentName->Length + sizeof( WCHAR );
            }

            RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                    BufferOffset,
                                    PVOID ),
                           TargetName->Buffer,
                           TargetName->Length );

            if (ARGUMENT_PRESENT( StreamName )) {

                BufferOffset += TargetName->Length;

                *(Add2Ptr( NotifyInfo->FileName, BufferOffset, PWCHAR )) = L':';

                RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                        BufferOffset + sizeof( WCHAR ),
                                        PVOID ),
                               StreamName->Buffer,
                               StreamName->Length );
            }

        //
        //  For a non-unicode name, use the conversion routines.
        //

        } else {

            ULONG BufferLength;

            if (ParentName->Length != 0) {

                RtlOemToUnicodeN( NotifyInfo->FileName,
                                  NotifyInfo->FileNameLength,
                                  &BufferLength,
                                  ParentName->Buffer,
                                  ParentName->Length );

                *(Add2Ptr( NotifyInfo->FileName, BufferLength, PWCHAR )) = L'\\';

                BufferOffset = BufferLength + sizeof( WCHAR );
            }

            //
            //  For view indices, we do not have a parent name.
            //

            if (ParentName->Length == 0) {

                ASSERT(ARGUMENT_PRESENT( StreamName ));

                RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                           BufferOffset,
                                           PCHAR ),
                               StreamName->Buffer,
                               StreamName->Length );

            } else {

                RtlOemToUnicodeN( Add2Ptr( NotifyInfo->FileName,
                                           BufferOffset,
                                           PWCHAR ),
                                  NotifyInfo->FileNameLength,
                                  &BufferLength,
                                  TargetName->Buffer,
                                  TargetName->Length );

                if (ARGUMENT_PRESENT( StreamName )) {

                    BufferOffset += BufferLength;

                    *(Add2Ptr( NotifyInfo->FileName, BufferOffset, PWCHAR )) = L':';

                    RtlOemToUnicodeN( Add2Ptr( NotifyInfo->FileName,
                                               BufferOffset + sizeof( WCHAR ),
                                               PWCHAR ),
                                      NotifyInfo->FileNameLength,
                                      &BufferLength,
                                      StreamName->Buffer,
                                      StreamName->Length );
                }
            }
        }

        CopiedToBuffer = TRUE;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        CopiedToBuffer = FALSE;
    }

    DebugTrace( -1, Dbg, "FsRtlNotifyUpdateBuffer:  Exit\n", 0 );

    return CopiedToBuffer;
}


//
//  Local support routine
//

VOID
FsRtlNotifyCompleteIrpList (
    IN OUT PNOTIFY_CHANGE Notify,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine walks through the Irps for a particular notify structure
    and completes the Irps with the indicated status.  If the status is
    STATUS_SUCCESS then we are completing an Irp because of a notification event.
    In that case we look at the notify structure to decide if we can return the
    data to the user.

Arguments:

    Notify  -  This is the notify change structure.

    Status  -  Indicates the status used to complete the request.  If this status
        is STATUS_SUCCESS then we only want to complete one Irp.  Otherwise we
        want complete all the Irps in the list.

Return Value:

    None.

--*/

{
    PIRP Irp;
    ULONG DataLength;

    DebugTrace( +1, Dbg, "FsRtlNotifyCompleteIrpList:  Entered\n", 0 );

    DataLength = Notify->DataLength;

    //
    //  Clear the fields to indicate that there is no more data to return.
    //

    ClearFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
    Notify->DataLength = 0;
    Notify->LastEntry = 0;

    //
    //  Walk through all the Irps in the list.  We are never called unless
    //  there is at least one irp.
    //

    do {

        Irp = CONTAINING_RECORD( Notify->NotifyIrps.Flink, IRP, Tail.Overlay.ListEntry );

        RemoveHeadList( &Notify->NotifyIrps );

        //
        //  Set the Flink to NULL as a flag to CancelNotify to signal that this is no 
        //  longer on the list.
        //

        Irp->Tail.Overlay.ListEntry.Flink = NULL;

        //
        //  Call our completion routine to complete the request.
        //

        FsRtlNotifyCompleteIrp( Irp,
                                Notify,
                                DataLength,
                                Status,
                                TRUE );

        //
        //  If we were only to complete one Irp then break now.
        //

        if (Status == STATUS_SUCCESS) {

            break;
        }

    } while (!IsListEmpty( &Notify->NotifyIrps ));

    DebugTrace( -1, Dbg, "FsRtlNotifyCompleteIrpList:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
FsRtlCancelNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    )

/*++

Routine Description:

    This routine is for an Irp which is being cancelled.  We Null the cancel
    routine and then walk through the Irps for this notify structure and
    complete all cancelled Irps.  It is possible there is pending notify
    stored in the buffer for this Irp.  In this case we want to copy the
    data to a system buffer if possible.

Arguments:

    DeviceObject - Ignored.

    ThisIrp  -  This is the Irp to cancel.

Return Value:

    None.

--*/

{
    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;

    PNOTIFY_CHANGE Notify;
    PNOTIFY_SYNC NotifySync;
    LONG ExceptionCode = 0;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, "FsRtlCancelNotify:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Irp   -> %08lx\n", Irp );

    //
    //  Capture the notify structure.
    //

    Notify = (PNOTIFY_CHANGE) ThisIrp->IoStatus.Information;

    //
    //  Void the cancel routine and release the cancel spinlock.
    //

    IoSetCancelRoutine( ThisIrp, NULL );
    ThisIrp->IoStatus.Information = 0;
    IoReleaseCancelSpinLock( ThisIrp->CancelIrql );

    FsRtlEnterFileSystem();

    //
    //  Grab the mutex for this structure.
    //

    NotifySync = Notify->NotifySync;
    AcquireNotifySync( NotifySync );

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        //
        //  Remove the Irp from the queue provided we aren't racing with someone else who
        //  has already removed it.
        //

        if (ThisIrp->Tail.Overlay.ListEntry.Flink != NULL) {

            RemoveEntryList( &ThisIrp->Tail.Overlay.ListEntry );
        }

        IoMarkIrpPending( ThisIrp );

        //
        //  We now have the Irp.  Check to see if there is data stored
        //  in the buffer for this Irp.
        //

        if (Notify->Buffer != NULL
            && Notify->AllocatedBuffer == NULL

            && ((ThisIrp->MdlAddress != NULL
                 && MmGetSystemAddressForMdl( ThisIrp->MdlAddress ) == Notify->Buffer)

                || (Notify->Buffer == ThisIrp->AssociatedIrp.SystemBuffer))) {

            PIRP NextIrp;
            PVOID NewBuffer;
            ULONG NewBufferLength;
            PIO_STACK_LOCATION  IrpSp;

            //
            //  Initialize the above values.
            //

            NewBuffer = NULL;
            NewBufferLength = 0;

            //
            //  Remember the next Irp on the list.  Find the length of any
            //  buffer it might have.  Also keep a pointer to the buffer
            //  if present.
            //

            if (!IsListEmpty( &Notify->NotifyIrps )) {

                NextIrp = CONTAINING_RECORD( Notify->NotifyIrps.Flink,
                                             IRP,
                                             Tail.Overlay.ListEntry );

                IrpSp = IoGetCurrentIrpStackLocation( NextIrp );

                //
                //  If the buffer here is large enough to hold the data we
                //  can use that buffer.
                //

                if (IrpSp->Parameters.NotifyDirectory.Length >= Notify->DataLength) {

                    //
                    //  If there is a system buffer or Mdl then get a new
                    //  buffer there.
                    //

                    if (NextIrp->AssociatedIrp.SystemBuffer != NULL) {

                        NewBuffer = NextIrp->AssociatedIrp.SystemBuffer;

                    } else if (NextIrp->MdlAddress != NULL) {

                        NewBuffer = MmGetSystemAddressForMdl( NextIrp->MdlAddress );
                    }

                    NewBufferLength = IrpSp->Parameters.NotifyDirectory.Length;

                    if (NewBufferLength > Notify->BufferLength) {

                        NewBufferLength = Notify->BufferLength;
                    }
                }

            //
            //  Otherwise check if the user's original buffer is larger than
            //  the current buffer.
            //

            } else if (Notify->BufferLength >= Notify->DataLength) {

                NewBufferLength = Notify->BufferLength;
            }

            //
            //  If we have a new buffer length then we either have a new
            //  buffer or need to allocate one.  We will do this under
            //  the protection of a try-except in order to continue in the
            //  event of a failure.
            //

            if (NewBufferLength != 0) {

                LOGICAL ChargedQuota = FALSE;

                try {

                    if (NewBuffer == NULL) {

                        PsChargePoolQuota( Notify->OwningProcess,
                                           PagedPool,
                                           NewBufferLength );

                        ChargedQuota = TRUE;

                        //
                        //  If we didn't get an error then attempt to
                        //  allocate the pool.  If there is an error
                        //  don't forget to release the quota.
                        //

                        NewBuffer = FsRtlpAllocatePool( PagedPool,
                                                        NewBufferLength );

                        Notify->AllocatedBuffer = NewBuffer;
                    }

                    //
                    //  Now copy the data over to the new buffer.
                    //

                    RtlCopyMemory( NewBuffer,
                                   Notify->Buffer,
                                   Notify->DataLength );

                    //
                    //  It is possible that the buffer size changed.
                    //

                    Notify->ThisBufferLength = NewBufferLength;
                    Notify->Buffer = NewBuffer;

                } except( FsRtlIsNtstatusExpected( ExceptionCode = GetExceptionCode()) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH ) {

                    ASSERT( (ExceptionCode == STATUS_INSUFFICIENT_RESOURCES) ||
                            (ExceptionCode == STATUS_QUOTA_EXCEEDED) );

                    //
                    //  Return quota if we allocated the buffer.
                    //

                    if (ChargedQuota) {

                        PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                       NewBufferLength );
                    }

                    //
                    //  Forget any current buffer and resort to immediate
                    //  notify.
                    //

                    SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                }

            //
            //  Otherwise set the immediate notify flag.
            //

            } else {

                SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
            }

            //
            //  If the immediate notify flag is set then clear the other
            //  values in the notify structures.
            //

            if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )) {

                //
                //  Forget any current buffer and resort to immediate
                //  notify.
                //

                Notify->AllocatedBuffer = Notify->Buffer = NULL;

                Notify->ThisBufferLength =
                Notify->DataLength = Notify->LastEntry = 0;
            }
        }

        //
        //  Complete the Irp with status cancelled.
        //

        FsRtlCompleteRequest( ThisIrp, STATUS_CANCELLED );

        //
        //  Decrement the count of Irps that might go through the cancel path.
        //

        InterlockedDecrement( (PLONG)&Notify->ReferenceCount );

        if (Notify->ReferenceCount == 0) {

            if (Notify->AllocatedBuffer != NULL) {

                PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                               Notify->ThisBufferLength );

                ExFreePool( Notify->AllocatedBuffer );
            }

            if (Notify->FullDirectoryName != NULL) {

                SubjectContext = Notify->SubjectContext;
            }

            //
            //  Cleanup owned one of the refcounts, and must have removed this from
            //  the notify list.  If not, we are freeing pool with live links.
            //

            ASSERT( Notify->NotifyList.Flink == NULL );

            ExFreePool( Notify );
            Notify = NULL;
        }

    } finally {

        //
        //  No matter how we exit, we release the mutex.
        //

        ReleaseNotifySync( NotifySync );

        if (SubjectContext != NULL) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, "FsRtlCancelNotify:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

VOID
FsRtlCheckNotifyForDelete (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID StreamID
    )

/*++

Routine Description:

    This routine is called when a stream is being marked for delete.  We will
    walk through the notify structures looking for an Irp for the same stream.
    We will complete these Irps with STATUS_DELETE_PENDING.

Arguments:

    NotifyListHead  -  This is the start of the notify list.

    StreamID  -  This is the Context ID used to identify the stream.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Link;

    PNOTIFY_CHANGE ThisNotify;

    PAGED_CODE();

    //
    //  Walk through all the entries on the list looking for a match.
    //

    for (Link = NotifyListHead->Flink;
         Link != NotifyListHead;
         Link = Link->Flink) {

        //
        //  Obtain the notify structure from the link.
        //

        ThisNotify = CONTAINING_RECORD( Link, NOTIFY_CHANGE, NotifyList );

        //
        //  If the context field matches, then complete any waiting Irps.
        //

        if (ThisNotify->StreamID == StreamID) {

            //
            //  Start by marking the notify structure as file deleted.
            //

            SetFlag( ThisNotify->Flags, NOTIFY_STREAM_IS_DELETED );

            //
            //  Now complete all of the Irps on this list.
            //

            if (!IsListEmpty( &ThisNotify->NotifyIrps )) {

                FsRtlNotifyCompleteIrpList( ThisNotify, STATUS_DELETE_PENDING );
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\stackovf.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    StackOvf.c

Abstract:

    The file lock package provides a worker thread to handle
    stack overflow conditions in the file systems.  When the
    file system detects that it is near the end of its stack
    during a paging I/O read request it will post the request
    to this extra thread.

--*/

#include "FsRtlP.h"
//
// Queue object that is used to hold work queue entries and synchronize
// worker thread activity.
//

KQUEUE FsRtlWorkerQueues[2];

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('srSF')


//
//  Local Support Routine
//

VOID
FsRtlStackOverflowRead (
    IN PVOID Context
    );

#if defined(_AMD64_)

VOID
FsRtlpNopStackOverflowRoutine (
    IN PVOID Context,
    IN PKEVENT Event
    );

#endif

VOID
FsRtlpPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine,
    IN BOOLEAN PagingFile
    );

//
// Procedure prototype for the worker thread.
//

VOID
FsRtlWorkerThread(
    IN PVOID StartContext
    );

//
//  The following type is used to store an enqueue work item
//

typedef struct _STACK_OVERFLOW_ITEM {

    WORK_QUEUE_ITEM Item;

    //
    //  This is the call back routine
    //

    PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine;

    //
    //  Here are the parameters for the call back routine
    //

    PVOID Context;
    PKEVENT Event;

} STACK_OVERFLOW_ITEM;
typedef STACK_OVERFLOW_ITEM *PSTACK_OVERFLOW_ITEM;

KEVENT StackOverflowFallbackSerialEvent;
STACK_OVERFLOW_ITEM StackOverflowFallback;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeWorkerThread)
#endif


NTSTATUS
FsRtlInitializeWorkerThread (
    VOID
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Create worker threads to handle normal and paging overflow reads.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);

    for (i=0; i < 2; i++) {

        //
        // Initialize the FsRtl stack overflow work Queue objects.
        //

        KeInitializeQueue(&FsRtlWorkerQueues[i], 0);

        Status = PsCreateSystemThread( &Thread,
                                       THREAD_ALL_ACCESS,
                                       &ObjectAttributes,
                                       0L,
                                       NULL,
                                       FsRtlWorkerThread,
                                       ULongToPtr( i ));
        
        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        ZwClose( Thread );
    }

    //
    //  Initialize the serial workitem so we can guarantee to post items
    //  for paging files to the worker threads.
    //

    KeInitializeEvent( &StackOverflowFallbackSerialEvent, SynchronizationEvent, TRUE );

    //
    // Pass a NOP routine through FsRtlPostStackOverfow() in order to flush out
    // any prefetchw instructions that may lie in that path.  Otherwise we'll
    // try to patch the prefetchw instruction when we can ill afford the stack
    // space.
    // 

#if defined(_AMD64_)

    FsRtlPostStackOverflow( NULL, NULL, FsRtlpNopStackOverflowRoutine );
    FsRtlPostPagingFileStackOverflow( NULL, NULL, FsRtlpNopStackOverflowRoutine );

#endif

    return Status;
}

DECLSPEC_NOINLINE
VOID
FsRtlPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.

Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

Return Value:

    None.

--*/

{
    FsRtlpPostStackOverflow( Context, Event, StackOverflowRoutine, FALSE );
    return;
}


DECLSPEC_NOINLINE
VOID
FsRtlPostPagingFileStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.
    
Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

Return Value:

    None.

--*/

{
    FsRtlpPostStackOverflow( Context, Event, StackOverflowRoutine, TRUE );
    return;
}


VOID
FsRtlpPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine,
    IN BOOLEAN PagingFile
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.

Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

    PagingFile - Indicates if the read is destined to a paging file.

Return Value:

    None.

--*/

{
    PSTACK_OVERFLOW_ITEM StackOverflowItem;

    //
    //  Allocate a stack overflow work item it will later be deallocated by
    //  the stack overflow thread.  Conserve stack by raising here.
    //

    StackOverflowItem = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(STACK_OVERFLOW_ITEM),
                                               MODULE_POOL_TAG );

    //
    //  If this fails, go to the fallback item for the paging file overflows.
    //  We can't have a single fallback item for non-pagingfile IO since this
    //  could lead to deadlocks if it waits on a thread that itself needs
    //  the fallback item.
    //
    
    if (StackOverflowItem == NULL) {
        
        if (!PagingFile) {
        
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        KeWaitForSingleObject( &StackOverflowFallbackSerialEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        StackOverflowItem = &StackOverflowFallback;
    }
    
    //
    //  Fill in the fields in the new item
    //

    StackOverflowItem->Context              = Context;
    StackOverflowItem->Event                = Event;
    StackOverflowItem->StackOverflowRoutine = StackOverflowRoutine;

    ExInitializeWorkItem( &StackOverflowItem->Item,
                          &FsRtlStackOverflowRead,
                          StackOverflowItem );

    //
    //  Safely add it to the overflow queue
    //

    KeInsertQueue( &FsRtlWorkerQueues[PagingFile],
                   &StackOverflowItem->Item.List );

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
FsRtlStackOverflowRead (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine processes all of the stack overflow request posted by
    the various file systems

Arguments:

Return Value:

    None.

--*/

{
    PSTACK_OVERFLOW_ITEM StackOverflowItem;

    //
    //  Since stack overflow reads are always recursive, set the
    //  TopLevelIrp field appropriately so that recursive reads
    //  from this point will not think they are top level.
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FSP_TOP_LEVEL_IRP;

    //
    //  Get a pointer to the stack overflow item and then call
    //  the callback routine to do the work
    //

    StackOverflowItem = (PSTACK_OVERFLOW_ITEM)Context;

    (StackOverflowItem->StackOverflowRoutine)(StackOverflowItem->Context,
                                              StackOverflowItem->Event);

    //
    //  Deallocate the work item, or simply return the serial item.
    //
    
    if (StackOverflowItem == &StackOverflowFallback) {

        KeSetEvent( &StackOverflowFallbackSerialEvent, 0, FALSE );
    
    } else {
        
        ExFreePool( StackOverflowItem );
    }

    PsGetCurrentThread()->TopLevelIrp = (ULONG_PTR)NULL;
}

VOID
FsRtlWorkerThread(
    IN PVOID StartContext
    )

{
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;
    ULONG PagingFile = (ULONG)(ULONG_PTR)StartContext;

    //
    //  Set our priority to low realtime, or +1 for PagingFile.
    //

    (VOID)KeSetPriorityThread( &PsGetCurrentThread()->Tcb,
                               LOW_REALTIME_PRIORITY + PagingFile );

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue.
        //
        // By specifying a wait mode of KernelMode, the thread's kernel stack is
        // NOT swappable
        //

        Entry = KeRemoveQueue(&FsRtlWorkerQueues[PagingFile], KernelMode, NULL);
        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Execute the specified routine.
        //

        (WorkItem->WorkerRoutine)(WorkItem->Parameter);
        if (KeGetCurrentIrql() != 0) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem
                );
        }

    } while(TRUE);
}

#if defined(_AMD64_)

VOID
FsRtlpNopStackOverflowRoutine (
    IN PVOID Context,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine serves as a "dummy" stack overflow routine for the initial
    "prefetchw flushing" invocation of FsRtlPostStackOverflow().

Arguments:

    Context - Provides the context associated with the stack overflow condition.
              Not used.

    Event - Provides the event associated with the stack overflow condition.
            Not used.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Event);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\name.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Name.c

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  FsRtlDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FsRtlColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical ordering.

      o  FsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('nrSF')

//
//  Local support routine prototypes
//

BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAreNamesEqual)
#pragma alloc_text(PAGE, FsRtlDissectName)
#pragma alloc_text(PAGE, FsRtlDoesNameContainWildCards)
#pragma alloc_text(PAGE, FsRtlIsNameInExpression)
#pragma alloc_text(PAGE, FsRtlIsNameInExpressionPrivate)
#endif


VOID
FsRtlDissectName (
    __in UNICODE_STRING Path,
    __out PUNICODE_STRING FirstName,
    __out PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name component.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    PAGED_CODE();

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(WCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == L'\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != L'\\');
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(WCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(WCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}

BOOLEAN
FsRtlDoesNameContainWildCards (
    __in PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PUSHORT p;

    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( Name->Length ) {
        for( p = Name->Buffer + (Name->Length / sizeof(WCHAR)) - 1;
             p >= Name->Buffer && *p != L'\\' ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (FsRtlIsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


BOOLEAN
FsRtlAreNamesEqual (
    __in PCUNICODE_STRING ConstantNameA,
    __in PCUNICODE_STRING ConstantNameB,
    __in BOOLEAN IgnoreCase,
    __in_opt PCWCH UpcaseTable
    )

/*++

Routine Description:

    This routine simple returns whether the two names are exactly equal.
    If the two names are known to be constant, this routine is much
    faster than FsRtlIsNameInExpression.

Arguments:

    ConstantNameA - Constant name.

    ConstantNameB - Constant name.

    IgnoreCase - TRUE if the Names should be Upcased before comparing.

    UpcaseTable - If supplied, use this table for case insensitive compares,
        otherwise, use the default system upcase table.

Return Value:

    BOOLEAN - TRUE if the two names are lexically equal.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN FreeStrings = FALSE;

    UNICODE_STRING LocalNameA;
    UNICODE_STRING LocalNameB;

    PAGED_CODE();

    //
    // If the names aren't even the same size, then return FALSE right away.
    //

    if ( ConstantNameA->Length != ConstantNameB->Length ) {

        return FALSE;
    }

    NameLength = ConstantNameA->Length / sizeof(WCHAR);

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalNameA, ConstantNameA, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            ExRaiseStatus( Status );
        }

        Status = RtlUpcaseUnicodeString( &LocalNameB, ConstantNameB, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            RtlFreeUnicodeString( &LocalNameA );

            ExRaiseStatus( Status );
        }

        ConstantNameA = &LocalNameA;
        ConstantNameB = &LocalNameB;

        IgnoreCase = FALSE;
        FreeStrings = TRUE;
    }

    //
    //  Do either case sensitive or insensitive compare.
    //

    if ( !IgnoreCase ) {

        BOOLEAN BytesEqual;

        BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA->Buffer,
                                               ConstantNameB->Buffer,
                                               ConstantNameA->Length );

        if ( FreeStrings ) {

            RtlFreeUnicodeString( &LocalNameA );
            RtlFreeUnicodeString( &LocalNameB );
        }

        return BytesEqual;

    } else {

        for (Index = 0; Index < NameLength; Index += 1) {

            if ( UpcaseTable[ConstantNameA->Buffer[Index]] !=
                 UpcaseTable[ConstantNameB->Buffer[Index]] ) {

                return FALSE;
            }
        }

        return TRUE;
    }
}


//
//  The following routine is just a wrapper around
//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FsRtlIsNameInExpression (
    __in PUNICODE_STRING Expression,
    __in PUNICODE_STRING Name,
    __in BOOLEAN IgnoreCase,
    __in_opt PWCH UpcaseTable
    )

{
    BOOLEAN Result = FALSE;
    UNICODE_STRING LocalName;

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalName, Name, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            ExRaiseStatus( Status );
        }

        Name = &LocalName;

        IgnoreCase = FALSE;

    } else {

        LocalName.Buffer = NULL;
    }

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    try {

        Result = FsRtlIsNameInExpressionPrivate( Expression,
                                                 Name,
                                                 IgnoreCase,
                                                 UpcaseTable );

    } finally {

        if (LocalName.Buffer != NULL) {

            RtlFreeUnicodeString( &LocalName );
        }
    }

    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar = 0, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlIsNameInExpression\n", 0);
    DebugTrace( 0, Dbg, " Expression      = %Z\n", Expression );
    DebugTrace( 0, Dbg, " Name            = %Z\n", Name );
    DebugTrace( 0, Dbg, " CaseInsensitive = %08lx\n", CaseInsensitive );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhausted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhausted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset = (USHORT)(ExprOffset + Length);
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);

                    AuxBuffer = FsRtlpAllocatePool( PagedPool,
                                                    (ExpressionChars+1) *
                                                    sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset = (USHORT)(Offset + Length) ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is monotonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarantees non-duplication in the dest. array.
            //

            while ((SrcCount < MatchesCount) &&
                   (PreviousDestCount < DestCount)) {

                while ((SrcCount < MatchesCount) &&
                       (PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount])) {

                    SrcCount += 1;
                }

                PreviousDestCount += 1;
            }
        }

        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\pnp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    PnP.c

Abstract:

    The PnP package provides a method for file systems to 
    notify applications and services that a volume is being
    locked or unlocked, so handles to it can be closed and
    reopened.
    
    This module exports routines which help file systems
    do this notification.

--*/

#include "FsRtlP.h"

#ifndef FAR
#define FAR
#endif
#include <IoEvent.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlNotifyVolumeEvent)
#endif


NTKERNELAPI
NTSTATUS
FsRtlNotifyVolumeEvent (
    __in PFILE_OBJECT FileObject,
    __in ULONG EventCode
    )

/*++

Routine Description:

    This routine notifies any registered applications that a 
    volume is being locked, unlocked, etc.  

Arguments:

    FileeObject - Supplies a file object for the volume being
        locked.

    EventCode - Which event is occurring -- e.g. FSRTL_VOLUME_LOCK
        
Return Value:

    Status of the notification.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    TARGET_DEVICE_CUSTOM_NOTIFICATION Event;
    PDEVICE_OBJECT Pdo;

    //
    //  Retrieve the device object associated with this file object.
    //

    Status = IoGetRelatedTargetDevice( FileObject, &Pdo );

    if (NT_SUCCESS( Status )) {

        ASSERT(Pdo != NULL);

        Event.Version = 1;
        Event.FileObject = NULL;
        Event.NameBufferOffset = -1;
        Event.Size = (USHORT)FIELD_OFFSET( TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer );

        switch (EventCode) {

        case FSRTL_VOLUME_DISMOUNT:
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_DISMOUNT, sizeof( GUID ));
            break;
            
        case FSRTL_VOLUME_DISMOUNT_FAILED:
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_DISMOUNT_FAILED, sizeof( GUID ));
            break;            

        case FSRTL_VOLUME_LOCK:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_LOCK, sizeof( GUID ));
            break;

        case FSRTL_VOLUME_LOCK_FAILED:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_LOCK_FAILED, sizeof( GUID ));
            break;
        
        case FSRTL_VOLUME_MOUNT:
            
            //
            //  Mount notification is asynchronous to avoid deadlocks when someone 
            //  unwittingly causes a mount in the course of handling some other
            //  PnP notification, e.g. MountMgr's device arrival code.
            //
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_MOUNT, sizeof( GUID ));
            IoReportTargetDeviceChangeAsynchronous( Pdo, &Event, NULL, NULL );
            ObDereferenceObject( Pdo );
            return STATUS_SUCCESS;
            break;

        case FSRTL_VOLUME_UNLOCK:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_UNLOCK, sizeof( GUID ));
            break;
            
        default:

            ObDereferenceObject( Pdo );
            return STATUS_INVALID_PARAMETER;
        }
        
        IoReportTargetDeviceChange( Pdo, &Event );
        ObDereferenceObject( Pdo );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\oplock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Oplock.c

Abstract:

    The OPLOCK routines provide support to filesystems which implement
    opportunistic locks.  The specific actions needed are based on
    the current oplocked state of the file (maintained in the OPLOCK
    structure) and the Irp the Io system provides to the file systems.
    Rather than define separate entry points for each oplock operation
    a single generic entry point is defined.

    The file systems will maintain a variable of type OPLOCK for
    each open file in the system.  This variable is initialized
    when an unopened file is opened.  It is uninitialized when the
    last reference to the file is cleared when the Io system calls
    the file system with a close call.

    The following routines are provided by this package:

      o  FsRtlInitializeOplock - Initialize a new OPLOCK structure.  There
         should be one OPLOCK for every opened file.  Each OPLOCK structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeOplock - Uninitialize an OPLOCK structure.  This
         call is used to cleanup any ancillary structures allocated and
         maintained by the OPLOCK.  After being uninitialized the OPLOCK
         must again be initialized before it can be used by the system.

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x08000000)

//
//  Define the compatible filter oplock desired access flags.  We won't break
//  a filter oplock when these flags are the only flags specified.
//

#define FILTER_OPLOCK_VALID_FLAGS (     \
    FILE_READ_ATTRIBUTES            |   \
    FILE_WRITE_ATTRIBUTES           |   \
    FILE_READ_DATA                  |   \
    FILE_READ_EA                    |   \
    FILE_EXECUTE                    |   \
    SYNCHRONIZE                     |   \
    READ_CONTROL                        \
)


//
//  We encode the different bits so we can test without having to enumerate
//  all of the possible states.
//
//  NOTE - The LEVEL_1, BATCH_OPLOCK and FILTER_OPLOCK must be in this order.
//  We assume later on that they are in this order.
//

#define NO_OPLOCK               (0x00000001)
#define LEVEL_I_OPLOCK          (0x00000002)
#define BATCH_OPLOCK            (0x00000004)
#define FILTER_OPLOCK           (0x00000008)
#define LEVEL_II_OPLOCK         (0x00000010)

#define OPLOCK_TYPE_MASK        (0x0000001f)

#define EXCLUSIVE               (0x00000040)
#define PENDING                 (0x00000080)

#define OPLOCK_HELD_MASK        (0x000000c0)

#define BREAK_TO_II             (0x00000100)
#define BREAK_TO_NONE           (0x00000200)
#define BREAK_TO_II_TO_NONE     (0x00000400)
#define CLOSE_PENDING           (0x00000800)

#define OPLOCK_BREAK_MASK       (0x00000f00)

//
//  The oplock types consist of the appropriate flags.
//

#define NoOplocksHeld           (NO_OPLOCK)

#define OplockIGranted          (LEVEL_I_OPLOCK | EXCLUSIVE)
#define OpBatchGranted          (BATCH_OPLOCK   | EXCLUSIVE)
#define OpFilterGranted         (FILTER_OPLOCK  | EXCLUSIVE)
#define OpFilterReqPending      (FILTER_OPLOCK  | EXCLUSIVE | PENDING )

#define OplockBreakItoII        (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_II)
#define OpBatchBreaktoII        (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_II)
#define OpFilterBreaktoII       (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_II)

#define OplockBreakItoNone      (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_NONE)
#define OpBatchBreaktoNone      (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_NONE)
#define OpFilterBreaktoNone     (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_NONE)

#define OplockBreakItoIItoNone  (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_II_NONE)
#define OpBatchBreaktoIItoNone  (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_II_NONE)
#define OpFilterBreaktoIItoNone (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_II_NONE)

#define OpBatchClosePending     (BATCH_OPLOCK   | EXCLUSIVE | CLOSE_PENDING)
#define OpFilterClosePending    (FILTER_OPLOCK  | EXCLUSIVE | CLOSE_PENDING)

#define OplockIIGranted         (LEVEL_II_OPLOCK)

//
//  The oplock state is now just a ULONG.
//

typedef ULONG OPLOCK_STATE;

//
//  The non-opaque definition of an OPLOCK is a pointer to a privately
//  defined structure.
//

typedef struct _NONOPAQUE_OPLOCK {

    //
    //  This is the Irp used to successfully request a level I oplock or
    //  batch oplock.  It is completed to initiate the Oplock I break
    //  procedure.
    //

    PIRP IrpExclusiveOplock;

    //
    //  This is a pointer to the original file object used when granting
    //  an Oplock I or batch oplock.
    //

    PFILE_OBJECT FileObject;

    //
    //  The start of a linked list of Irps used to successfully request
    //  a level II oplock.
    //

    LIST_ENTRY IrpOplocksII;

    //
    //  The following links the Irps waiting to be completed on a queue
    //  of Irps.
    //

    LIST_ENTRY WaitingIrps;

    //
    //  Oplock state.  This indicates the current oplock state.
    //

    OPLOCK_STATE OplockState;

    //
    //  This FastMutex is used to control access to this structure.
    //

    PFAST_MUTEX FastMutex;

} NONOPAQUE_OPLOCK, *PNONOPAQUE_OPLOCK;

//
//  Each Waiting Irp record corresponds to an Irp that is waiting for an
//  oplock break to be acknowledged and is maintained in a queue off of the
//  Oplock's WaitingIrps list.
//

typedef struct _WAITING_IRP {

    //
    //  The link structures for the list of waiting irps.
    //

    LIST_ENTRY Links;

    //
    //  This is the Irp attached to this structure.
    //

    PIRP Irp;

    //
    //  This is the routine to call when we are done with an Irp we
    //  held on a waiting queue.  (We originally returned STATUS_PENDING).
    //

    POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine;

    //
    //  The context field to use when we are done with the Irp.
    //

    PVOID Context;

    //
    //  This points to an event object used when we do not want to
    //  give up this thread.
    //

    PKEVENT Event;

    //
    //  This field contains a copy of the Irp Iosb.Information field.
    //  We copy it here so that we can store the Oplock address in the
    //  Irp.
    //

    ULONG Information;

} WAITING_IRP, *PWAITING_IRP;

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('orSF')


//
//  Local support routines
//

PNONOPAQUE_OPLOCK
FsRtlAllocateOplock (
    );

NTSTATUS
FsRtlRequestExclusiveOplock (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp OPTIONAL,
    IN OPLOCK_STATE NextOplockState
    );

NTSTATUS
FsRtlRequestOplockII (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

NTSTATUS
FsRtlAcknowledgeOplockBreak (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN BOOLEAN GrantLevelII
    );

NTSTATUS
FsRtlOpBatchBreakClosePending (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

NTSTATUS
FsRtlOplockBreakNotify (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

VOID
FsRtlOplockCleanup (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FsRtlOplockBreakToII (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    );

NTSTATUS
FsRtlOplockBreakToNone (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    );

VOID
FsRtlRemoveAndCompleteIrp (
    IN PLIST_ENTRY Link
    );

NTSTATUS
FsRtlWaitOnIrp (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL,
    IN PKEVENT Event
    );

VOID
FsRtlCompletionRoutinePriv (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
FsRtlCancelWaitIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlCancelOplockIIIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlCancelExclusiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlRemoveAndCompleteWaitIrp (
    IN PWAITING_IRP WaitingIrp
    );

VOID
FsRtlNotifyCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAllocateOplock)
#pragma alloc_text(PAGE, FsRtlCompletionRoutinePriv)
#pragma alloc_text(PAGE, FsRtlCurrentBatchOplock)
#pragma alloc_text(PAGE, FsRtlInitializeOplock)
#pragma alloc_text(PAGE, FsRtlNotifyCompletion)
#pragma alloc_text(PAGE, FsRtlOpBatchBreakClosePending)
#pragma alloc_text(PAGE, FsRtlOplockBreakNotify)
#pragma alloc_text(PAGE, FsRtlOplockFsctrl)
#pragma alloc_text(PAGE, FsRtlOplockIsFastIoPossible)
#endif


VOID
FsRtlInitializeOplock (
    __inout POPLOCK Oplock
    )

/*++

Routine Description:

    This routine initializes a new OPLOCK structure.  This call must
    precede any other call to this entry point with this OPLOCK
    structure.  In addition, this routine will have exclusive access
    to the Oplock structure.

Arguments:

    Oplock - Supplies the address of an opaque OPLOCK structure.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( Oplock );

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlInitializeOplock:  Oplock -> %08lx\n", *Oplock );

    //
    //  No action is taken at this time.
    //

    DebugTrace(-1, Dbg, "FsRtlInitializeOplock:  Exit\n", 0);
    return;
}


VOID
FsRtlUninitializeOplock (
    __inout POPLOCK Oplock
    )

/*++

Routine Description:

    This routine uninitializes an OPLOCK structure.  After calling this
    routine, the OPLOCK structure must be reinitialized before being
    used again.

Arguments:

    Oplock - Supplies the address of an opaque OPLOCK structure.

Return Value:

    None.

--*/


{
    PNONOPAQUE_OPLOCK ThisOplock;

    DebugTrace(+1, Dbg, "FsRtlUninitializeOplock:  Oplock -> %08lx\n", *Oplock );

    //
    //  If the Oplock structure has not been allocated, there is no action
    //  to take.
    //

    if (*Oplock != NULL) {

        //
        //  Remove this from the user's structure.
        //

        ThisOplock = (PNONOPAQUE_OPLOCK) *Oplock;

        *Oplock = NULL;

        //
        //  Grab the waiting lock queue mutex to exclude anyone from messing
        //  with the queue while we're using it
        //

        ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

        try {

            PIRP Irp;

            //
            //  Release any waiting Irps held.
            //

            while (!IsListEmpty( &ThisOplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;
                PIRP ThisIrp;

                WaitingIrp = CONTAINING_RECORD( ThisOplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                RemoveHeadList( &ThisOplock->WaitingIrps );

                ThisIrp = WaitingIrp->Irp;

                IoAcquireCancelSpinLock( &ThisIrp->CancelIrql );

                IoSetCancelRoutine( ThisIrp, NULL );
                IoReleaseCancelSpinLock( ThisIrp->CancelIrql );

                ThisIrp->IoStatus.Information = 0;

                //
                //  Call the completion routine in the Waiting Irp.
                //

                WaitingIrp->CompletionRoutine( WaitingIrp->Context,
                                               WaitingIrp->Irp );

                ExFreePool( WaitingIrp );
            }

            //
            //  Release any oplock II irps held.
            //

            while (!IsListEmpty( &ThisOplock->IrpOplocksII )) {

                Irp = CONTAINING_RECORD( ThisOplock->IrpOplocksII.Flink,
                                         IRP,
                                         Tail.Overlay.ListEntry );

                RemoveHeadList( &ThisOplock->IrpOplocksII );

                IoAcquireCancelSpinLock( &Irp->CancelIrql );

                IoSetCancelRoutine( Irp, NULL );
                IoReleaseCancelSpinLock( Irp->CancelIrql );

                //
                //  Complete the oplock II Irp.
                //

                ObDereferenceObject( IoGetCurrentIrpStackLocation( Irp )->FileObject );

                Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            }

            //
            //  Release any exclusive oplock held.
            //

            if (ThisOplock->IrpExclusiveOplock != NULL) {

                Irp = ThisOplock->IrpExclusiveOplock;

                IoAcquireCancelSpinLock( &Irp->CancelIrql );

                IoSetCancelRoutine( Irp, NULL );
                IoReleaseCancelSpinLock( Irp->CancelIrql );

                Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Irp, STATUS_SUCCESS );

                ThisOplock->IrpExclusiveOplock = NULL;

                if (ThisOplock->FileObject != NULL) {

                    ObDereferenceObject( ThisOplock->FileObject );
                }
            }

        } finally {

            //
            //  No matter how we complete the preceding statements we will
            //  now release the waiting lock queue mutex
            //

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        //
        //  Deallocate the mutex.
        //

        ExFreePool( ThisOplock->FastMutex );

        //
        //  Deallocate the Oplock structure.
        //

        ExFreePool( ThisOplock );
    }

    DebugTrace( -1, Dbg, "FsRtlUninitializeOplock:  Exit\n", 0 );
    return;
}


NTSTATUS
FsRtlOplockFsctrl (
    __in POPLOCK Oplock,
    __in PIRP Irp,
    __in ULONG OpenCount
    )

/*++

Routine Description:

    This is the interface with the filesystems for Fsctl calls, it handles
    oplock requests, break acknowledgement and break notify.

Arguments:

    Oplock - Supplies the address of the opaque OPLOCK structure.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    OpenCount - This is the number of user handles on the file if we are requesting
        an exclusive oplock.  A non-zero value for a level II request indicates
        that there are locks on the file.

Return Value:

    NTSTATUS - Returns the result of this operation.  If this is an Oplock
               request which is granted, then STATUS_PENDING is returned.
               If the Oplock isn't granted then STATUS_OPLOCK_NOT_GRANTED
               is returned.  If this is an Oplock I break to no oplock,
               then STATUS_SUCCESS.  If this is an Oplock I break to
               Oplock II then STATUS_PENDING is returned.  Other
               error codes returned depend on the nature of the error.

               STATUS_CANCELLED is returned if the Irp is cancelled during
               this operation.

               STATUS_SUCCESS is returned if this is a create asking for
               a filter oplock.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    OPLOCK_STATE OplockState;

    PAGED_CODE();

    //
    //  Get the current IRP stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FsRtlOplockFsctrl:  Entered\n", 0);
    DebugTrace( 0, Dbg, "FsRtlOplockFsctrl:  Oplock      -> %08lx\n", *Oplock );
    DebugTrace( 0, Dbg, "FsRtlOplockFsctrl:  Irp         -> %08lx\n", Irp );

    //
    //  Check if this is the create case where the user is requesting a pending
    //  filter oplock.
    //

    if (IrpSp->MajorFunction == IRP_MJ_CREATE) {

        //
        //  Check that all the conditions hold to grant this oplock.
        //  The conditions that must hold are:
        //
        //      - This is the only opener of the file.
        //      - Desired Access must be exactly FILE_READ_ATTRIBUTES.
        //          This will ensure an asynch open since the SYNCHRONIZE
        //          flag can't be set.
        //      - Share access is precisely
        //          (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
        //

        if ((OpenCount != 1) ||
            (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                     ~(FILE_READ_ATTRIBUTES))) ||
            ((IrpSp->Parameters.Create.ShareAccess &
              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) !=
             (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE))) {

            Status = STATUS_OPLOCK_NOT_GRANTED;

        } else {

            Status = FsRtlRequestExclusiveOplock( (PNONOPAQUE_OPLOCK *) Oplock,
                                                  IrpSp,
                                                  NULL,
                                                  OpFilterReqPending );
        }

    //
    //  Case on the FsControlFile code control code.
    //

    } else {

        //
        //  Assume this is an OplockLevel I.
        //
        //  NOTE - This code depends on the defined bits for these oplock types.
        //      FILTER_OPLOCK = 4 * LEVEL_I_OPLOCK
        //      BATCH_OPLOCK = 2 * LEVEL_I_OPLOCK
        //

        OplockState = LEVEL_I_OPLOCK;

        switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_REQUEST_FILTER_OPLOCK :

            OplockState *= 2;

        case FSCTL_REQUEST_BATCH_OPLOCK :

            OplockState *= 2;

        case FSCTL_REQUEST_OPLOCK_LEVEL_1 :

            //
            //  Set the other flags for an exclusive oplock.
            //

            SetFlag( OplockState, EXCLUSIVE );

            //
            //  We short circuit the request if this request is treated
            //  synchronously or the open count is not 1.  Otherwise the Io system
            //  will hold the return code until the Irp is completed.
            //
            //  Also fail this if the flag is set which indicates that
            //  the IO system should copy data back to a user's buffer.
            //
            //  If cleanup has occurred on this file, then we refuse
            //  the oplock request.
            //

            if ((OpenCount != 1) ||
                IoIsOperationSynchronous( Irp ) ||
                FlagOn( Irp->Flags, IRP_INPUT_OPERATION ) ||
                FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
                Status = STATUS_OPLOCK_NOT_GRANTED;

            } else {

                Status = FsRtlRequestExclusiveOplock( (PNONOPAQUE_OPLOCK *) Oplock,
                                                      IrpSp,
                                                      Irp,
                                                      OplockState );
            }

            break;

        case FSCTL_REQUEST_OPLOCK_LEVEL_2 :

            //
            //  We short circuit the request if this request is treated
            //  synchronously.  Otherwise the Io system will hold the return
            //  code until the Irp is completed.
            //
            //  If cleanup has occurred on this file, then we refuse
            //  the oplock request.
            //
            //  Also fail this if the flag is set which indicates that
            //  the IO system should copy data back to a user's buffer.
            //
            //  A non-zero open count in this case indicates that there are
            //  file locks on the file.  We will also fail the request in
            //  this case.
            //

            if ((OpenCount != 0) ||
                IoIsOperationSynchronous( Irp ) ||
                FlagOn( Irp->Flags, IRP_INPUT_OPERATION ) ||
                FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
                Status = STATUS_OPLOCK_NOT_GRANTED;

            } else {

                Status = FsRtlRequestOplockII( (PNONOPAQUE_OPLOCK *) Oplock,
                                               IrpSp,
                                               Irp );
            }

            break;

        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :

            Status = FsRtlAcknowledgeOplockBreak( (PNONOPAQUE_OPLOCK) *Oplock,
                                                  IrpSp,
                                                  Irp,
                                                  TRUE );
            break;

        case FSCTL_OPLOCK_BREAK_ACK_NO_2 :

            Status = FsRtlAcknowledgeOplockBreak( (PNONOPAQUE_OPLOCK) *Oplock,
                                                  IrpSp,
                                                  Irp,
                                                  FALSE );
            break;

        case FSCTL_OPBATCH_ACK_CLOSE_PENDING :

            Status = FsRtlOpBatchBreakClosePending( (PNONOPAQUE_OPLOCK) *Oplock,
                                                    IrpSp,
                                                    Irp );
            break;

        case FSCTL_OPLOCK_BREAK_NOTIFY :

            Status = FsRtlOplockBreakNotify( (PNONOPAQUE_OPLOCK) *Oplock,
                                             IrpSp,
                                             Irp );
            break;

        default :

            DebugTrace( 0,
                        Dbg,
                        "Invalid Control Code\n",
                        0);

            FsRtlCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    DebugTrace(-1, Dbg, "FsRtlOplockFsctrl:  Exit -> %08lx\n", Status );
    return Status;
}


NTSTATUS
FsRtlCheckOplock (
    __in POPLOCK Oplock,
    __in PIRP Irp,
    __in_opt PVOID Context,
    __in_opt POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine,
    __in_opt POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    )

/*++

Routine Description:

    This routine is called as a support routine from a file system.
    It is used to synchronize I/O requests with the current Oplock
    state of a file.  If the I/O operation will cause the Oplock to
    break, that action is initiated.  If the operation cannot continue
    until the Oplock break is complete, STATUS_PENDING is returned and
    the caller supplied routine is called.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNONOPAQUE_OPLOCK ThisOplock = *Oplock;

    PIO_STACK_LOCATION IrpSp;

    DebugTrace( +1, Dbg, "FsRtlCheckOplock:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure or this is system I/O, we allow
    //  the operation to continue.  Otherwise we check the major function code.
    //

    if ((ThisOplock != NULL) &&
        !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        OPLOCK_STATE OplockState;
        PFILE_OBJECT OplockFileObject;

        BOOLEAN BreakToII;
        BOOLEAN BreakToNone;

        ULONG CreateDisposition;

        //
        //  Capture the file object first and then the oplock state to perform
        //  the unsafe checks below.  We capture the file object first in case
        //  there is an exclusive oplock break in progress.  Otherwise the oplock
        //  state may indicate break in progress but it could complete by
        //  the time we snap the file object.
        //

        OplockFileObject = ThisOplock->FileObject;
        OplockState = ThisOplock->OplockState;

        //
        //  Examine the Irp for the appropriate action provided there are
        //  current oplocks on the file.
        //

        if (OplockState != NoOplocksHeld) {

            BreakToII = FALSE;
            BreakToNone = FALSE;

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Determine whether we are going to BreakToII or BreakToNone.
            //

            switch (IrpSp->MajorFunction) {

            case IRP_MJ_CREATE :

                //
                //  If we are opening for attribute access only, we
                //  return status success.  Always break the oplock if this caller
                //  wants a filter oplock.
                //

                if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                             ~(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE) ) &&
                    !FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                    break;
                }

                //
                //  If there is a filter oplock granted and this create iS reading
                //  the file then don't break the oplock as long as we share
                //  for reads.
                //

                if (FlagOn( OplockState, FILTER_OPLOCK ) &&
                    !FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                             ~FILTER_OPLOCK_VALID_FLAGS ) &&
                    FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

                    break;
                }

                //
                //  We we are superseding or overwriting, then break to none.
                //

                CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

                if ((CreateDisposition == FILE_SUPERSEDE) ||
                    (CreateDisposition == FILE_OVERWRITE) ||
                    (CreateDisposition == FILE_OVERWRITE_IF) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                    BreakToNone = TRUE;

                } else {

                    BreakToII = TRUE;
                }

                break;

            case IRP_MJ_READ :

                //
                //  If a filter oplock has been granted then do nothing.
                //  We will assume the oplock will have been broken
                //  if this create needed to do that.
                //

                if (!FlagOn( OplockState, FILTER_OPLOCK )) {

                    BreakToII = TRUE;
                }

                break;

            case IRP_MJ_FLUSH_BUFFERS :

                BreakToII = TRUE;
                break;

            case IRP_MJ_CLEANUP :

                FsRtlOplockCleanup( (PNONOPAQUE_OPLOCK) *Oplock,
                                    IrpSp );

                break;

            case IRP_MJ_LOCK_CONTROL :

                //
                //  If a filter oplock has been granted then do nothing.
                //  We will assume the oplock will have been broken
                //  if this create needed to do that.
                //

                if (FlagOn( OplockState, FILTER_OPLOCK )) {

                    break;
                }

            case IRP_MJ_WRITE :

                BreakToNone = TRUE;
                break;

            case IRP_MJ_SET_INFORMATION :

                //
                //  We are only interested in calls that shrink the file size
                //  or breaking batch oplocks for the rename case.
                //

                switch (IrpSp->Parameters.SetFile.FileInformationClass) {

                case FileEndOfFileInformation :

                    //
                    //  Break immediately if this is the lazy writer callback.
                    //

                    if (IrpSp->Parameters.SetFile.AdvanceOnly) {

                        break;
                    }

                case FileAllocationInformation :

                    BreakToNone = TRUE;
                    break;

                case FileRenameInformation :
                case FileLinkInformation :
                case FileShortNameInformation :

                    if (FlagOn( OplockState, BATCH_OPLOCK | FILTER_OPLOCK )) {

                        BreakToNone = TRUE;
                    }

                    break;
                }

            case IRP_MJ_FILE_SYSTEM_CONTROL :

                //
                //  We need to break to none if this is a zeroing operation.
                //

                if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_ZERO_DATA) {

                    BreakToNone = TRUE;
                }
            }

            if (BreakToII) {

                //
                //  If there are no outstanding oplocks or level II oplocks are held,
                //  we can return immediately.  If the first two tests fail then there
                //  is an exclusive oplock.  If the file objects match we allow the
                //  operation to continue.
                //

                if ((OplockState != OplockIIGranted) &&
                    (OplockFileObject != IrpSp->FileObject)) {

                    Status = FsRtlOplockBreakToII( (PNONOPAQUE_OPLOCK) *Oplock,
                                                    IrpSp,
                                                    Irp,
                                                    Context,
                                                    CompletionRoutine,
                                                    PostIrpRoutine );
                }

            } else if (BreakToNone) {

                //
                //  If there are no oplocks, we can return immediately.
                //  Otherwise if there is no level 2 oplock and this file
                //  object matches the owning file object then this write is
                //  on behalf of the owner of the oplock.
                //

                if ((OplockState == OplockIIGranted) ||
                    (OplockFileObject != IrpSp->FileObject)) {

                    Status = FsRtlOplockBreakToNone( (PNONOPAQUE_OPLOCK) *Oplock,
                                                      IrpSp,
                                                      Irp,
                                                      Context,
                                                      CompletionRoutine,
                                                      PostIrpRoutine );
                }
            }
        }
    }

    DebugTrace( -1, Dbg, "FsRtlCheckOplock:  Exit -> %08lx\n", Status );

    return Status;
}


BOOLEAN
FsRtlOplockIsFastIoPossible (
    __in POPLOCK Oplock
    )

/*++

Routine Description:

    This routine indicates to the caller where there are any outstanding
    oplocks which prevent fast Io from happening.

Arguments:

    OpLock - Supplies the oplock being queried

Return Value:

    BOOLEAN - TRUE if there are outstanding oplocks and FALSE otherwise

--*/

{
    BOOLEAN FastIoPossible = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlOplockIsFastIoPossible: Oplock -> %08lx\n", *Oplock);

    //
    //  There are not any current oplocks if the variable is null or
    //  the state is no oplocks held.  If an exclusive oplock was granted
    //  but no break is in progress then allow the Fast IO.
    //

    if (*Oplock != NULL) {

        OPLOCK_STATE OplockState;

        OplockState = ((PNONOPAQUE_OPLOCK) *Oplock)->OplockState;

        if (FlagOn( OplockState, LEVEL_II_OPLOCK | OPLOCK_BREAK_MASK )) {

            FastIoPossible = FALSE;
        }
    }

    DebugTrace(-1, Dbg, "FsRtlOplockIsFastIoPossible: Exit -> %08lx\n", FastIoPossible);

    return FastIoPossible;
}


BOOLEAN
FsRtlCurrentBatchOplock (
    __in POPLOCK Oplock
    )

/*++

Routine Description:

    This routines indicates whether there are current outstanding
    batch oplocks.

Arguments:

    OpLock - Supplies the oplock being queried

Return Value:

    BOOLEAN - TRUE if there are outstanding batch oplocks and FALSE otherwise

--*/

{
    BOOLEAN BatchOplocks = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlCurrentBatchOplock: Oplock -> %08lx\n", *Oplock);

    //
    //  There are not any current oplocks if the variable is null or
    //  the state is no oplocks held.  We check whether there are batch
    //  oplocks or filter oplocks which have not been broken.
    //

    if ((*Oplock != NULL) &&
        FlagOn( ((PNONOPAQUE_OPLOCK) *Oplock)->OplockState,
                BATCH_OPLOCK | FILTER_OPLOCK )) {

        BatchOplocks = TRUE;
    }

    DebugTrace(-1, Dbg, "FsRtlCurrentBatchOplock: Exit -> %08lx\n", BatchOplocks);

    return BatchOplocks;
}


//
//  Local support routine.
//

PNONOPAQUE_OPLOCK
FsRtlAllocateOplock (
    )

/*++

Routine Description:

    This routine is called to initialize and allocate an opaque oplock
    structure.  After allocation, the two events are set to the signaled
    state.  The oplock state is set to NoOplocksHeld and the other
    fields are filled with zeroes.

    If the allocation fails, the appropriate status is raised.

Arguments:

    None.

Return Value:

    PNONOPAQUE_OPLOCK - A pointer to the allocated structure.

--*/

{
    PNONOPAQUE_OPLOCK NewOplock = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlAllocateOplock:  Entered\n", 0);

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Raise an error status if the allocation is unsuccessful.
        //  The structure is allocated out of non-paged pool.
        //

        NewOplock = FsRtlpAllocatePool( PagedPool|POOL_COLD_ALLOCATION, sizeof( NONOPAQUE_OPLOCK ));

        RtlZeroMemory( NewOplock, sizeof( NONOPAQUE_OPLOCK ));

        NewOplock->FastMutex = FsRtlpAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));

        ExInitializeFastMutex( NewOplock->FastMutex );

        InitializeListHead( &NewOplock->IrpOplocksII );
        InitializeListHead( &NewOplock->WaitingIrps );

        NewOplock->OplockState = NoOplocksHeld;

    } finally {

        //
        //  Cleanup the oplock if abnormal termination.
        //

        if (AbnormalTermination() && NewOplock != NULL) {

            ExFreePool( NewOplock );
        }

        DebugTrace(-1, Dbg, "GetOplockStructure:  Exit -> %08lx\n", NewOplock);
    }

    return NewOplock;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlRequestExclusiveOplock (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp OPTIONAL,
    IN OPLOCK_STATE NextOplockState
    )

/*++

Routine Description:

    This routine is called whenever a user is requesting either a batch/filter
    oplock or a level I oplock.  The request is granted if there are currently
    no oplocks on the file or we are completing the filter oplock request.

    NOTE - We already know that the open count on this file is exactly one.
        If the caller is requesting a PendingFilter Oplock then the state
        must be NoOplockHeld.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.  This is not specified if we are granting a pending
          filter oplock (during a create).

    NextOplockState - Indicates the type of oplock being requested.

Return Value:

    STATUS_PENDING if the oplock is granted (although it may be immediately cancelled).
    STATUS_SUCCESS if a pending filter oplock is requested and tentatively granted.
    STATUS_OPLOCK_NOT_GRANTED if the request is denied.

--*/

{
    NTSTATUS Status;

    PNONOPAQUE_OPLOCK ThisOplock;

    LOGICAL AcquiredMutex;

    DebugTrace( +1, Dbg, "FsRtlRequestExclusiveOplock:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock        -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp         -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp           -> %08lx\n", Irp );
    DebugTrace(  0, Dbg, "BatchOplock   -> %01x\n",  BatchOplock );

    //
    //  We can grant the oplock if no one else owns a level I or level II
    //  oplock on this file.  If the oplock pointer is NULL then there
    //  are no oplocks on the file.  Otherwise we need to check the
    //  oplock state in an existing oplock structure.
    //

    if (*Oplock == NULL) {

        DebugTrace( 0,
                    Dbg,
                    "Oplock currently not allocated\n",
                    0);

        ThisOplock = FsRtlAllocateOplock();
        *Oplock = ThisOplock;

    } else {

        ThisOplock = *Oplock;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    Status = STATUS_SUCCESS;

    AcquiredMutex = TRUE;

    ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we are requesting a PendingFilter Oplock then it must be
        //  safe to grant.  There is only one open handle and we are in
        //  the process of opening it.
        //

        if (NextOplockState == OpFilterReqPending) {

            ASSERT( FlagOn( ThisOplock->OplockState, NO_OPLOCK | PENDING ));

            ThisOplock->IrpExclusiveOplock = Irp;
            ThisOplock->FileObject = IrpSp->FileObject;

            ThisOplock->OplockState = OpFilterReqPending;

        //
        //  If the current oplock state is no oplocks held then we
        //  will grant the oplock to this requestor.  If the state is
        //  either of the OpFilter states then also grant the request.
        //  We won't check for a matching file object because there can
        //  only be one file object.  Grant the request anyway.
        //
        //  If the current state is OplockII granted then it must
        //  be owned by this request.  Break the oplock II and grant
        //  the exclusive lock.
        //

        } else if (FlagOn( ThisOplock->OplockState,
                           LEVEL_II_OPLOCK | NO_OPLOCK | PENDING )) {

            PFAST_MUTEX OplockFastMutex;

            if (ThisOplock->OplockState == OplockIIGranted) {

                ASSERT( ThisOplock->IrpOplocksII.Flink == ThisOplock->IrpOplocksII.Blink );

                FsRtlRemoveAndCompleteIrp( ThisOplock->IrpOplocksII.Flink );
            }

            //
            //  Put the address of the fast mutex on the stack.
            //

            OplockFastMutex = ThisOplock->FastMutex;

            //
            //  We store this Irp in the Oplocks structure.
            //  We set the oplock state to the correct exclusive oplock.
            //

            ThisOplock->IrpExclusiveOplock = Irp;
            ThisOplock->FileObject = IrpSp->FileObject;
            ThisOplock->OplockState = NextOplockState;

            IoMarkIrpPending( Irp );

            ObReferenceObject( IrpSp->FileObject );

            Irp->IoStatus.Information = (ULONG_PTR) ThisOplock;

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                FsRtlCancelExclusiveIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelExclusiveIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

            Status = STATUS_PENDING;

        } else {

            //
            //  We'll complete the Irp with the Oplock not granted message
            //  and return that value as a status.
            //

            if (ARGUMENT_PRESENT( Irp )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
            }

            Status = STATUS_OPLOCK_NOT_GRANTED;
        }

    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        DebugTrace( +1, Dbg, "FsRtlRequestExclusiveOplock:  Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlRequestOplockII (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a user is requesting an Oplock II on an
    open file.  The request is granted if there are currently no
    level 1 oplocks on the file and an oplock break is not in progress.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_PENDING if the oplock is granted.
    STATUS_OPLOCK_NOT_GRANTED if the request is denied.

--*/

{
    NTSTATUS Status;

    PNONOPAQUE_OPLOCK ThisOplock;

    LOGICAL AcquiredMutex;

    DebugTrace( +1, Dbg, "FsRtlRequestOplockII:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  We can grant the oplock if no one else owns a level I
    //  oplock on this file.  If the oplock pointer is NULL then there
    //  are no oplocks on the file.  Otherwise we need to check the
    //  oplock state in an existing oplock structure.
    //

    if (*Oplock == NULL) {

        DebugTrace( 0,
                    Dbg,
                    "Oplock currently not allocated\n",
                    0);

        ThisOplock = FsRtlAllocateOplock();
        *Oplock = ThisOplock;

    } else {

        ThisOplock = *Oplock;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    Status = STATUS_PENDING;

    AcquiredMutex = TRUE;

    ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the current oplock state is no oplocks held or OplockIIGranted
        //  then we will grant the oplock to this requestor.
        //

        if (FlagOn( ThisOplock->OplockState, NO_OPLOCK | LEVEL_II_OPLOCK )) {

            PFAST_MUTEX OplockFastMutex = ThisOplock->FastMutex;

            //
            //  We store this Irp in the Oplocks structure.
            //  We set the oplock state to 'OplockIIGranted'.
            //

            IoMarkIrpPending( Irp );

            Irp->IoStatus.Status = STATUS_SUCCESS;

            InsertHeadList( &ThisOplock->IrpOplocksII,
                            &Irp->Tail.Overlay.ListEntry );

            Irp->IoStatus.Information = (ULONG_PTR) ThisOplock;

            ThisOplock->OplockState = OplockIIGranted;

            ObReferenceObject( IrpSp->FileObject );

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                FsRtlCancelOplockIIIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelOplockIIIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

        } else {

            //
            //  We'll complete the Irp with the Oplock not granted message
            //  and return that value as a status.
            //

            FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
            Status = STATUS_OPLOCK_NOT_GRANTED;
        }

    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        DebugTrace( +1, Dbg, "FsRtlRequestOplockII:  Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlAcknowledgeOplockBreak (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN BOOLEAN GrantLevelII
    )

/*++

Routine Description:

    This routine is called when a user is acknowledging an Oplock I
    break.  If the level 1 oplock was being broken to level 2, then
    a check is made to ensure that the level 2 has not been broken
    in the meantime.

    If an oplock 1 break is not in progress then this will be treated
    as an asynchronous break request.  If this is an asynchronous break
    request and the file object owns an outstanding level 1 oplock, then
    the oplock will be broken at this point.

    A spurious break request via a file object which does not (or did not)
    own the level 1 oplock will generate a warning but will not affect
    the oplock state.

    At the end of an Oplock I break, all of the waiting irps are completed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    GrantLevelII - Indicates that this caller wants a level II oplock left
        on the file.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_INVALID_OPLOCK_PROTOCOL;

    LOGICAL AcquiredMutex;

    DebugTrace( +1, Dbg, "FsRtlAcknowledgeOplockBreak:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with invalid
    //  oplock protocol.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_INVALID_OPLOCK_PROTOCOL );
        DebugTrace( -1, Dbg, "FsRtlAcknowledgeOplockBreak:  Exit -> %08lx\n", STATUS_INVALID_OPLOCK_PROTOCOL );
        return STATUS_INVALID_OPLOCK_PROTOCOL;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    AcquiredMutex = TRUE;
    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        BOOLEAN DereferenceFileObject = TRUE;

        //
        //  If a break is underway but this is not the owner of the
        //  level 1 oplock, we complete the request and return a
        //  warning.
        //

        if (Oplock->FileObject != IrpSp->FileObject) {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "Not oplock owner -> %08lx\n",
                       Status);

            FsRtlCompleteRequest( Irp, Status );
            try_return( Status );
        }

        //
        //  If the user would like a level II and we are breaking to level II
        //  then grant the oplock.
        //

        if (GrantLevelII &&
            FlagOn( Oplock->OplockState, BREAK_TO_II )) {

            PFAST_MUTEX OplockFastMutex = Oplock->FastMutex;

            DebugTrace(0, Dbg, "OplockItoII\n", 0);

            //
            //  The acknowledgement should never be synchronous.
            //

            ASSERT( !IoIsOperationSynchronous( Irp ));

            //
            //  We need to add this Irp to the oplock II queue, change
            //  the oplock state to Oplock II granted and set the
            //  return value to STATUS_PENDING.
            //


            IoMarkIrpPending( Irp );

            Irp->IoStatus.Status = STATUS_SUCCESS;

            InsertHeadList( &Oplock->IrpOplocksII,
                            &Irp->Tail.Overlay.ListEntry );

            DereferenceFileObject = FALSE;

            Oplock->OplockState = OplockIIGranted;

            Irp->IoStatus.Information = (ULONG_PTR) Oplock;

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                AcquiredMutex = FALSE;

                FsRtlCancelOplockIIIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelOplockIIIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

            Status = STATUS_PENDING;

        //
        //  We will break to none since this is the expected case for these
        //  cases.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II | BREAK_TO_NONE )) {

            //
            //  We need to complete this Irp and return STATUS_SUCCESS.
            //  We also set the oplock state to no oplocks held.
            //

            DebugTrace(0, Dbg, "OplockItoNone\n", 0);

            Status = STATUS_SUCCESS;
            FsRtlCompleteRequest( Irp, Status );
            Oplock->OplockState = NoOplocksHeld;

        //
        //  In this case the user expects to be at level II.  He is
        //  expecting this Irp to be completed when the LevelII Oplock
        //  is broken.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II_TO_NONE )) {

            DebugTrace(0, Dbg, "AcknowledgeOplockBreak:  OplockItoIItoNone\n", 0);

            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
            FsRtlCompleteRequest( Irp, Status );
            Oplock->OplockState = NoOplocksHeld;

        } else {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "No break underway -> %08lx\n",
                       Status);

            FsRtlCompleteRequest( Irp, Status );
            try_return( Status );
        }

        //
        //  Complete the waiting Irps and cleanup the oplock structure.
        //

        while (!IsListEmpty( &Oplock->WaitingIrps )) {

            PWAITING_IRP WaitingIrp;

            //
            //  Remove the entry found and complete the Irp.
            //

            WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                            WAITING_IRP,
                                            Links );

            FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
        }

        if (DereferenceFileObject) {

            ObDereferenceObject( Oplock->FileObject );
        }

        Oplock->FileObject = NULL;

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlAcknowledgeOplockBreak:  Exit -> %08x\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlOpBatchBreakClosePending (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a user is acknowledging a batch oplock
    break or Level I oplock break.  In this case the user is planning
    to close the file as well and doesn't need a level II oplock.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlOpBatchBreakClosePending:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with invalid
    //  oplock protocol.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_INVALID_OPLOCK_PROTOCOL );
        DebugTrace( -1, Dbg, "FsRtlOpBatchClosePending:  Exit -> %08lx\n", STATUS_INVALID_OPLOCK_PROTOCOL );
        return STATUS_INVALID_OPLOCK_PROTOCOL;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try_finally to facilitate cleanup.
    //

    try {

        //
        //  If a break is underway but this is not the owner of the
        //  level 1 oplock, we complete the request and return a
        //  warning.
        //

        if (Oplock->FileObject != IrpSp->FileObject) {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "Not oplock owner -> %08lx\n",
                       Status);

        } else {

            //
            //  If this is an opbatch operation we want to note that a
            //  close is pending.  For an exclusive oplock we set the state to
            //  no oplocks held.  There must be a break in progress to
            //  process however.
            //

            if (FlagOn( Oplock->OplockState,
                        BREAK_TO_II | BREAK_TO_NONE | BREAK_TO_II_TO_NONE )) {

                //
                //  Break all oplocks for an exclusive oplock.
                //

                if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK | PENDING )) {

                    //
                    //  Clean up the oplock structure and complete all waiting Irps.
                    //

                    if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK )) {

                        ObDereferenceObject( Oplock->FileObject );
                    }

                    Oplock->OplockState = NoOplocksHeld;
                    Oplock->FileObject = NULL;

                    while (!IsListEmpty( &Oplock->WaitingIrps )) {

                        PWAITING_IRP WaitingIrp;

                        //
                        //  Remove the entry found and complete the Irp.
                        //

                        WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                        WAITING_IRP,
                                                        Links );

                        FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                    }

                //
                //  Set the state to close pending for batch and filter
                //  oplocks.
                //

                } else {

                    ClearFlag( Oplock->OplockState, OPLOCK_BREAK_MASK );
                    SetFlag( Oplock->OplockState, CLOSE_PENDING );
                }

            } else {

                Status = STATUS_INVALID_OPLOCK_PROTOCOL;
                DebugTrace(0,
                           Dbg,
                           "No break underway -> %08lx\n",
                           Status);
            }
        }

        //
        //  We simply complete this request.
        //

        FsRtlCompleteRequest( Irp, Status );

    } finally {

        //
        //  Release the synchronization object.
        //

        ExReleaseFastMutexUnsafe( Oplock->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlOpBatchBreakClosePending:  Exit -> %08lx\n", Status);
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
FsRtlOplockBreakNotify (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the Irp refers the user request to
    be notified when there is no level 1 oplock break in progress.
    Under any other condition this routine completes immediately with
    STATUS_SUCCESS.  Otherwise we simply add this Irp to the list
    of Irp's waiting for the break to complete.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LOGICAL AcquiredMutex;

    UNREFERENCED_PARAMETER (IrpSp);

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlOplockBreakNotify:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with status success.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
        DebugTrace( -1, Dbg, "FsRtlOpBatchClosePending:  Exit -> %08lx\n", STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Grap the synchronization object.
    //

    AcquiredMutex = TRUE;
    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding level 1 oplocks breaks underway
        //  or batch oplock breaks underway we complete immediately.
        //

        if (!FlagOn( Oplock->OplockState, OPLOCK_BREAK_MASK )) {

            DebugTrace(0,
                       Dbg,
                       "No exclusive oplock break underway\n",
                       0);

            FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            try_return( Status = STATUS_SUCCESS );

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Otherwise we need to add this Irp to the list of Irp's waiting
        //  for the oplock break to complete.
        //

        AcquiredMutex = FALSE;

        //
        //  Initialize the return value to status success.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 NULL,
                                 FsRtlNotifyCompletion,
                                 NULL,
                                 NULL );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlOplockBreakNotify:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine
//

VOID
FsRtlOplockCleanup (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to coordinate a cleanup operation with the
    oplock state for a file.  If there is no level 1 oplock for the
    file, then there is no action to take.  If the file object in this
    Irp matches the file object used in granting the level 1 oplock,
    then the close operation will terminate the oplock.  If this
    cleanup refers to a file object which has a level II oplock, then
    that Irp is completed and removed from the list of level II
    oplocked Irps.


Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "FsRtlOplockCleanup:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the oplock has no oplock held we return immediately.
        //

        if (Oplock->OplockState == NoOplocksHeld) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks on file\n",
                       0);

            try_return( NOTHING );
        }

        //
        //  If level II oplocks are held, check if this matches any of them.
        //

        if (Oplock->OplockState == OplockIIGranted) {

            PLIST_ENTRY Link;
            PIRP Irp;
            PIO_STACK_LOCATION NextIrpSp;

            DebugTrace(0,
                       Dbg,
                       "File has level 2 oplocks\n",
                       0);

            for (Link = Oplock->IrpOplocksII.Flink;
                 Link != &Oplock->IrpOplocksII;
                 Link = Link->Flink) {

                Irp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

                NextIrpSp = IoGetCurrentIrpStackLocation( Irp );

                //
                //  If the file objects match, then emove the entry found and complete the Irp.
                //

                if (IrpSp->FileObject == NextIrpSp->FileObject) {

                    //
                    //  Back up to remember this link.
                    //

                    Link = Link->Blink;

                    //
                    //

                    FsRtlRemoveAndCompleteIrp( Link->Flink );
                }
            }

            //
            //  If all the level II oplocks are gone, then the state is
            //  no oplocks held.
            //

            if (IsListEmpty( &Oplock->IrpOplocksII )) {

                Oplock->OplockState = NoOplocksHeld;
            }

            try_return( NOTHING );
        }

        //
        //  If this file object matches that used to request an exclusive
        //  oplock, we completely close the oplock break.
        //

        if (IrpSp->FileObject == Oplock->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            //
            //  If an oplock break is not in progress, we initiate one and
            //  complete the exclusive Irp immediately.
            //

            if (!FlagOn( Oplock->OplockState, OPLOCK_BREAK_MASK | PENDING )) {

                PIRP ExclusiveIrp = Oplock->IrpExclusiveOplock;

                DebugTrace(0,
                           Dbg,
                           "Initiate oplock break\n",
                           0);

                IoAcquireCancelSpinLock( &ExclusiveIrp->CancelIrql );

                IoSetCancelRoutine( ExclusiveIrp, NULL );
                IoReleaseCancelSpinLock( ExclusiveIrp->CancelIrql );

                ExclusiveIrp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;

                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );

                Oplock->IrpExclusiveOplock = NULL;
            }

            //
            //  Clean up the oplock structure and complete all waiting Irps.
            //  Don't do this if this is a pending opfilter request.
            //

            if (!FlagOn( Oplock->OplockState, PENDING )) {

                ObDereferenceObject( IrpSp->FileObject );
            }

            Oplock->FileObject = NULL;
            Oplock->OplockState = NoOplocksHeld;

            while (!IsListEmpty( &Oplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;

                //
                //  Remove the entry found and complete the Irp.
                //

                WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        DebugTrace( +1, Dbg, "FsRtlOplockCleanup:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
FsRtlOplockBreakToII (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    )

/*++

Routine Description:

    This routine is a generic worker routine which is called when an
    operation will cause all oplocks to be broken to level II before the
    operation can proceed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    LOGICAL AcquiredMutex;

    DebugTrace( +1, Dbg, "CheckOplockBreakToII:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  Grap the synchronization object.
    //

    Status = STATUS_SUCCESS;
    AcquiredMutex = TRUE;
    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding oplocks or level II oplocks are held,
        //  we can return immediately.
        //

        if (!FlagOn( Oplock->OplockState, EXCLUSIVE )) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks or level II oplocks on file\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  At this point there is an exclusive oplock break in progress.
        //  If this file object owns that oplock, we allow the operation
        //  to continue.
        //

        if (Oplock->FileObject == IrpSp->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If there is currently an exclusive oplock held then complete
        //  the exclusive irp.
        //

        if (!FlagOn( Oplock->OplockState, PENDING | OPLOCK_BREAK_MASK )) {

            PIRP IrpExclusive = Oplock->IrpExclusiveOplock;

            DebugTrace(0,
                       Dbg,
                       "Breaking exclusive oplock\n",
                       0);

            IoAcquireCancelSpinLock( &IrpExclusive->CancelIrql );
            IoSetCancelRoutine( IrpExclusive, NULL );
            IoReleaseCancelSpinLock( IrpExclusive->CancelIrql );

            //
            //  If the Irp has been cancelled, we complete the Irp with
            //  status cancelled and break the oplock completely.
            //

            if (IrpExclusive->Cancel) {

                IrpExclusive->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( IrpExclusive, STATUS_CANCELLED );
                Oplock->OplockState = NoOplocksHeld;
                Oplock->IrpExclusiveOplock = NULL;

                ObDereferenceObject( Oplock->FileObject );
                Oplock->FileObject = NULL;

                //
                //  Release any waiting irps.
                //

                while (!IsListEmpty( &Oplock->WaitingIrps )) {

                    PWAITING_IRP WaitingIrp;

                    WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                    WAITING_IRP,
                                                    Links );

                    FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                }

                try_return( Status = STATUS_SUCCESS );

            } else {

                NTSTATUS CompletionStatus;

                if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK | BATCH_OPLOCK )) {

                    SetFlag( Oplock->OplockState, BREAK_TO_II );
                    CompletionStatus = FILE_OPLOCK_BROKEN_TO_LEVEL_2;

                } else {

                    SetFlag( Oplock->OplockState, BREAK_TO_NONE );
                    CompletionStatus = FILE_OPLOCK_BROKEN_TO_NONE;
                }

                Oplock->IrpExclusiveOplock->IoStatus.Information = CompletionStatus;
                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );
                Oplock->IrpExclusiveOplock = NULL;
            }

        //
        //  If there is a pending opfilter request then clear the request.
        //

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If this is an open operation and the user doesn't want to
        //  block, we will complete the operation now.
        //

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            FlagOn( IrpSp->Parameters.Create.Options, FILE_COMPLETE_IF_OPLOCKED )) {

            DebugTrace( 0, Dbg, "Don't block open\n", 0 );

            try_return( Status = STATUS_OPLOCK_BREAK_IN_PROGRESS );
        }

        //
        //  If we get here that means that this operation can't continue
        //  until the oplock break is complete.
        //
        //  FsRtlWaitOnIrp will release the mutex.
        //

        AcquiredMutex = FALSE;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 Context,
                                 CompletionRoutine,
                                 PostIrpRoutine,
                                 &Event );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlOplockBreakToII:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlOplockBreakToNone (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine is a generic worker routine which is called when an
    operation will cause all oplocks to be broken before the operation can
    proceed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    KEVENT Event;
    NTSTATUS Status = STATUS_SUCCESS;
    LOGICAL AcquiredMutex;

    DebugTrace( +1, Dbg, "CheckOplockBreakToNone:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  Grap the synchronization object.
    //

    AcquiredMutex = TRUE;
    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding oplocks, we can return immediately.
        //

        if (Oplock->OplockState == NoOplocksHeld) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks on file\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If there is an exclusive oplock held, we begin the break to none.
        //

        if (!FlagOn( Oplock->OplockState,
                     LEVEL_II_OPLOCK | PENDING | OPLOCK_BREAK_MASK )) {

            PIRP IrpExclusive = Oplock->IrpExclusiveOplock;

            DebugTrace(0,
                       Dbg,
                       "Breaking exclusive oplock\n",
                       0);

            IoAcquireCancelSpinLock( &IrpExclusive->CancelIrql );
            IoSetCancelRoutine( IrpExclusive, NULL );
            IoReleaseCancelSpinLock( IrpExclusive->CancelIrql );

            //
            //  If the Irp has been cancelled, we complete the Irp with
            //  status cancelled and break the oplock completely.
            //

            if (IrpExclusive->Cancel) {

                IrpExclusive->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( IrpExclusive, STATUS_CANCELLED );
                Oplock->OplockState = NoOplocksHeld;
                Oplock->IrpExclusiveOplock = NULL;

                ObDereferenceObject( Oplock->FileObject );
                Oplock->FileObject = NULL;

                //
                //  Release any waiting irps.
                //

                while (!IsListEmpty( &Oplock->WaitingIrps )) {

                    PWAITING_IRP WaitingIrp;

                    WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                    WAITING_IRP,
                                                    Links );

                    FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                }

                try_return( Status = STATUS_SUCCESS );

            } else {

                Oplock->IrpExclusiveOplock->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );
                Oplock->IrpExclusiveOplock = NULL;

                SetFlag( Oplock->OplockState, BREAK_TO_NONE );
            }

        //
        //  If there are level II oplocks, this will break all of them.
        //

        } else if (Oplock->OplockState == OplockIIGranted) {

            DebugTrace(0,
                       Dbg,
                       "Breaking all level 2 oplocks\n",
                       0);

            while (!IsListEmpty( &Oplock->IrpOplocksII )) {

                //
                //  Remove and complete this Irp with STATUS_SUCCESS.
                //

                FsRtlRemoveAndCompleteIrp( Oplock->IrpOplocksII.Flink );
            }

            //
            //  Set the oplock state to no oplocks held.
            //

            Oplock->OplockState = NoOplocksHeld;

            try_return( Status = STATUS_SUCCESS );

        //
        //  If we are currently breaking to level II then change that
        //  to BreakToIIToNone.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II )) {

            ClearFlag( Oplock->OplockState, BREAK_TO_II );
            SetFlag( Oplock->OplockState, BREAK_TO_II_TO_NONE );

        //
        //  If there is a pending opfilter request then clear that request.
        //

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  At this point there is already an exclusive oplock break in progress.
        //  If this file object owns that oplock, we allow the operation
        //  to continue.
        //

        if (Oplock->FileObject == IrpSp->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If this is an open operation and the user doesn't want to
        //  block, we will complete the operation now.
        //

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            FlagOn( IrpSp->Parameters.Create.Options, FILE_COMPLETE_IF_OPLOCKED )) {

            DebugTrace( 0, Dbg, "Don't block open\n", 0 );

            try_return( Status = STATUS_OPLOCK_BREAK_IN_PROGRESS );
        }

        //
        //  If we get here that means that this operation can't continue
        //  until the oplock break is complete.
        //
        //  FsRtlWaitOnIrp will release the mutex.
        //

        AcquiredMutex = FALSE;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 Context,
                                 CompletionRoutine,
                                 PostIrpRoutine,
                                 &Event );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "CheckOplockBreakToNone:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
FsRtlRemoveAndCompleteIrp (
    IN PLIST_ENTRY Link
    )

/*++

Routine Description:

    This routine is called to remove an Irp from a list of Irps linked
    with the Tail.ListEntry field and complete them with STATUS_CANCELLED
    if the Irp has been cancelled, STATUS_SUCCESS otherwise.

Arguments:

    Link - Supplies the entry to remove from the list.

Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION OplockIIIrpSp;

    DebugTrace( +1, Dbg, "FsRtlRemoveAndCompleteIrp:  Entered\n", 0 );

    //
    //  Reference the Irp.
    //

    Irp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

    //
    //  Get the stack location and dereference the file object.
    //

    OplockIIIrpSp = IoGetCurrentIrpStackLocation( Irp );
    ObDereferenceObject( OplockIIIrpSp->FileObject );

    //
    //  Clear the cancel routine in the irp.
    //

    IoAcquireCancelSpinLock( &Irp->CancelIrql );

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // Remove this from the list.
    //

    RemoveEntryList( Link );

    //
    //  Complete the oplock Irp.
    //

    Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;

    FsRtlCompleteRequest( Irp, Irp->Cancel ? STATUS_CANCELLED : STATUS_SUCCESS );

    DebugTrace( -1, Dbg, "FsRtlRemoveAndCompleteIrp:  Exit\n", 0 );
}


//
//  Local support routine.
//

NTSTATUS
FsRtlWaitOnIrp (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is called to create a Wait Irp structure and attach it
    to the current Irp.  The Irp is then added to the list of Irps waiting
    for an oplock break.  We check if the Irp has been cancelled and if
    so we call our cancel routine to perform the work.

    This routine is holding the Mutex for the oplock on entry and
    must give it up on exit.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

    Event - If there is no user completion routine, this thread will
            block using this event.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    LOGICAL AcquiredMutex;
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    PWAITING_IRP WaitingIrp;

    DebugTrace( +1, Dbg, "FsRtlWaitOnIrp:   Entered\n", 0 );

    //
    //  Remember that we have the mutex.
    //

    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        PFAST_MUTEX OplockFastMutex = Oplock->FastMutex;

        //
        //  Allocate and initialize the Wait Irp structure.
        //

        WaitingIrp = FsRtlpAllocatePool( PagedPool, sizeof( WAITING_IRP ));

        WaitingIrp->Irp = Irp;

        WaitingIrp->Context = Context;
        WaitingIrp->Information = (ULONG) Irp->IoStatus.Information;

        //
        //  Take appropriate action if depending on the value of the
        //  completion routine.
        //

        if (ARGUMENT_PRESENT( CompletionRoutine )) {

            WaitingIrp->CompletionRoutine = CompletionRoutine;
            WaitingIrp->Context = Context;

        } else {

            WaitingIrp->CompletionRoutine = FsRtlCompletionRoutinePriv;
            WaitingIrp->Context = Event;

            KeInitializeEvent( Event, NotificationEvent, FALSE );
        }

        //
        //  Call the file system's post Irp code.
        //

        if (ARGUMENT_PRESENT( PostIrpRoutine )) {

            PostIrpRoutine( Context, Irp );
        }

        //
        //  Initialize the return value to status success.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        //  We put this into the Waiting Irp queue.
        //

        InsertTailList( &Oplock->WaitingIrps, &WaitingIrp->Links );

        //
        //  We grab the cancel spinlock and store the address of the oplock.
        //

        IoAcquireCancelSpinLock( &Irp->CancelIrql );
        Irp->IoStatus.Information = (ULONG_PTR) Oplock;

        //
        //  If the Irp is cancelled then we'll call the cancel routine
        //  right now to do away with the Waiting Irp structure.
        //

        if (Irp->Cancel) {

            ExReleaseFastMutexUnsafe( OplockFastMutex );
            AcquiredMutex = FALSE;

            if (ARGUMENT_PRESENT( CompletionRoutine )) {

                IoMarkIrpPending( Irp );
                Status = STATUS_PENDING;

            } else {

                Status = STATUS_CANCELLED;
            }

            FsRtlCancelWaitIrp( NULL, Irp );

        //
        //  Otherwise, we set the cancel routine and decide whether we
        //  are going to wait on our local event.
        //

        } else {

            IoSetCancelRoutine( Irp, FsRtlCancelWaitIrp );
            IoReleaseCancelSpinLock( Irp->CancelIrql );

            //
            //  If we wait on the event, we pull the return code out of
            //  the Irp.
            //

            if (!ARGUMENT_PRESENT( CompletionRoutine )) {

                ExReleaseFastMutexUnsafe( Oplock->FastMutex );

                AcquiredMutex = FALSE;

                KeWaitForSingleObject( Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL );

                Status = Irp->IoStatus.Status;

            //
            //  Otherwise, we return STATUS_PENDING.
            //

            } else {

                IoMarkIrpPending( Irp );

                Status = STATUS_PENDING;
            }
        }

    } finally {

        //
        //  Release the Mutex if we have not done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlWaitOnIrp:   Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
FsRtlCompletionRoutinePriv (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when an operation must be synchronous with
    respect to the oplock package.  This routine will simply set the
    event in the Signaled state, allowing some other thread to resume
    execution.

Arguments:

    Context - This is the event to signal.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlCompletionRoutinePriv:  Entered\n", 0 );

    KeSetEvent( (PKEVENT)Context, 0, FALSE );

    DebugTrace( -1, Dbg, "FsRtlCompletionRoutinePriv:  Exit\n", 0 );

    return;

    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine.
//

VOID
FsRtlCancelWaitIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for an Irp that is placed on the waiting
    Irp queue.  We remove the Cancel routine from the specified Irp and
    then call the completion routines for all the cancelled Irps on the
    queue.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;

    PLIST_ENTRY Links;

    DebugTrace( +1, Dbg, "FsRtlCancelWaitIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Iterate through all of the waiting locks looking for a canceled one
    //  We do this under the protection of the oplock mutex.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        for (Links = Oplock->WaitingIrps.Flink;
             Links != &Oplock->WaitingIrps;
             Links = Links->Flink ) {

            PWAITING_IRP WaitingIrp;

            //
            //  Get a pointer to the waiting Irp record
            //

            WaitingIrp = CONTAINING_RECORD( Links, WAITING_IRP, Links );

            DebugTrace(0, Dbg, "FsRtlCancelWaitIrp, Loop top, WaitingIrp = %08lx\n", WaitingIrp);

            //
            //  Check if the irp has been cancelled
            //

            if (WaitingIrp->Irp->Cancel) {

                //
                //  Now we need to remove this waiter and call the
                //  completion routine.  But we must not mess up our link
                //  iteration so we need to back up link one step and
                //  then the next iteration will go to our current flink.
                //

                Links = Links->Blink;

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelWaitIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlCancelOplockIIIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for an Irp that is placed in the Oplock II
    Irp queue.  We remove the Cancel routine from the specified Irp and
    then call the completion routines for all the cancelled Irps on the
    queue.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;
    BOOLEAN LevelIIIrps;

    PLIST_ENTRY Links;

    DebugTrace( +1, Dbg, "FsRtlCancelOplockIIIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    LevelIIIrps = FALSE;

    //
    //  Iterate through all of the level II oplocks looking for a canceled one
    //  We do this under the protection of the oplock mutex.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        for (Links = Oplock->IrpOplocksII.Flink;
             Links != &Oplock->IrpOplocksII;
             Links = Links->Flink ) {

            PIRP OplockIIIrp;

            //
            //  Get a pointer to the Irp record
            //

            OplockIIIrp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            DebugTrace(0, Dbg, "FsRtlCancelOplockIIIrp, Loop top, Irp = %08lx\n", OplockIIIrp);

            //
            //  Check if the irp has been cancelled
            //

            if (OplockIIIrp->Cancel) {

                //
                //  Now we need to remove this waiter and call the
                //  completion routine.  But we must not mess up our link
                //  iteration so we need to back up link one step and
                //  then the next iteration will go to our current flink.
                //

                Links = Links->Blink;

                FsRtlRemoveAndCompleteIrp( Links->Flink );

                LevelIIIrps = TRUE;
            }
        }

        //
        //  If the list is now empty, change the oplock status to
        //  no oplocks held.
        //

        if (LevelIIIrps && IsListEmpty( &Oplock->IrpOplocksII )) {

            Oplock->OplockState = NoOplocksHeld;
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelOplockIIIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlCancelExclusiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for either an exclusive or oplock I Irp.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;

    DebugTrace( +1, Dbg, "FsRtlCancelExclusiveIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Grab the synchronization object for this oplock.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        //
        //  We look for the exclusive Irp, if present and cancelled
        //  we complete it.
        //

        if ((Oplock->IrpExclusiveOplock != NULL) &&
            (Oplock->IrpExclusiveOplock->Cancel)) {

            FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_CANCELLED );
            Oplock->IrpExclusiveOplock = NULL;

            ObDereferenceObject( Oplock->FileObject );
            Oplock->FileObject = NULL;
            Oplock->OplockState = NoOplocksHeld;

            //
            //  Complete the waiting Irps.
            //

            while (!IsListEmpty( &Oplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;

                //
                //  Remove the entry found and complete the Irp.
                //

                WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelExclusiveIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlRemoveAndCompleteWaitIrp (
    IN PWAITING_IRP WaitingIrp
    )

/*++

Routine Description:

    This routine is called to remove and perform any necessary cleanup
    for an Irp stored on the waiting Irp list in an oplock structure.

Arguments:

    WaitingIrp - This is the auxiliary structure attached to the Irp
                 being completed.

Return Value:

    None.

--*/

{
    PIRP Irp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlRemoveAndCompleteWaitIrp:  Entered\n", 0 );

    //
    //  Remove the Irp from the queue.
    //

    RemoveEntryList( &WaitingIrp->Links );

    Irp = WaitingIrp->Irp;

    IoAcquireCancelSpinLock( &Irp->CancelIrql );

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Restore the information field.
    //

    Irp->IoStatus.Information = WaitingIrp->Information;

    Irp->IoStatus.Status = (Irp->Cancel
                            ? STATUS_CANCELLED
                            : STATUS_SUCCESS);

    //
    //  Call the completion routine in the Waiting Irp.
    //

    WaitingIrp->CompletionRoutine( WaitingIrp->Context, Irp );

    //
    //  And free up pool
    //

    ExFreePool( WaitingIrp );

    DebugTrace( -1, Dbg, "FsRtlRemoveAndCompleteWaitIrp:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
FsRtlNotifyCompletion (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the completion routine called when a break notify Irp is to
    be completed.  We simply call FsRtlComplete request to dispose of the
    Irp.

Arguments:

    Context - Ignored.

    Irp - Irp used to request break notify.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (Context);

    DebugTrace( +1, Dbg, "FsRtlNotifyCompletion:  Entered\n", 0 );

    //
    //  Call FsRtlCompleteRequest using the value in the Irp.
    //

    FsRtlCompleteRequest( Irp, Irp->IoStatus.Status );

    DebugTrace( -1, Dbg, "FsRtlNotifyCompletion:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fsrtl\tunnel.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    Tunnel.c

Abstract:

    The tunnel package provides a set of routines that allow compatibility
    with applications that rely on filesystems being able to "hold onto"
    file meta-info for a short period of time after deletion/renaming and
    reinstantiating a new directory entry with that meta-info if a
    create/rename occurs to cause a file of that name to appear again in a
    short period of time.

    Note that this violates POSIX rules. This package should not be used
    on POSIX fileobjects, i.e. fileobjects that have case-sensitive names.

    Entries are keyed by directory and one of the short/long names. An opaque
    rock of information is also associated (create time, last write time, etc.).
    This is expected to vary on a per-filesystem basis.

    A TUNNEL variable should be initialized for every volume in the system
    at mount time. Thereafter, each delete/rename-out should add to the tunnel
    and each create/rename-in should read from the tunnel. Each directory
    deletion should also notify the package so that all associated entries can
    be flushed. The package is responsible for cleaning out aged entries.

    Tunneled information is in the paged pool.

    Concurrent access to the TUNNEL variable is controlled by this package.
    Callers are responsible for synchronizing access to the FsRtlDeleteTunnelCache
    call.

    The functions provided in this package are as follows:

      o  FsRtlInitializeTunnel - Initializes the TUNNEL package (called once per boot)

      o  FsRtlInitializeTunnelCache - Initializes a TUNNEL structure (called once on mount)

      o  FsRtlAddToTunnelCache - Adds a new key/value pair to the tunnel

      o  FsRtlFindInTunnelCache - Finds and returns a key/value from the tunnel

      o  FsRtlDeleteKeyFromTunnelCache - Deletes all entries with a given
           directory key from the tunnel

      o  FsRtlDeleteTunnelCache - Deletes a TUNNEL structure

--*/

#include "FsRtlP.h"

#ifndef INLINE
#define INLINE __inline
#endif

//
//  Registry keys/values for controlling tunneling
//

#define TUNNEL_KEY_NAME           L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define TUNNEL_AGE_VALUE_NAME     L"MaximumTunnelEntryAgeInSeconds"
#define TUNNEL_SIZE_VALUE_NAME    L"MaximumTunnelEntries"
#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(ULONG)) + 64)

//
//  Tunnel expiration parameters (cached once at startup)
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG   TunnelMaxEntries = 256; // Value for !MmIsThisAnNtAsSystem()
ULONG   TunnelMaxAge = 15;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  We use a lookaside list to manage the common size tunnel entry. The common size
//  is contrived to be 128 bytes by adjusting the size we defer for the long name
//  to 16 characters, which is pretty reasonable. If we ever expect to get more than
//  a ULONGLONG data element or common names are observed to become larger, adjusting
//  this may be required.
//

PAGED_LOOKASIDE_LIST    TunnelLookasideList;
#define MAX_LOOKASIDE_DEPTH     256

#define LOOKASIDE_NODE_SIZE     ( sizeof(TUNNEL_NODE) +     \
                                  sizeof(WCHAR)*(8+1+3) +   \
                                  sizeof(WCHAR)*(16) +      \
                                  sizeof(ULONGLONG) )

//
//  Flag bits in the TUNNEL_NODE
//

#define TUNNEL_FLAG_NON_LOOKASIDE    0x1
#define TUNNEL_FLAG_KEY_SHORT        0x2

//
//  A node of tunneled information in the cache
//
//  A TUNNEL is allocated in each VCB and initialized at mount time.
//
//  TUNNEL_NODES are then arranged off of the TUNNEL in a splay tree keyed
//  by DirKey ## Name, where Name is whichever of the names was removed from
//  the directory (short or long). Each node is also timestamped and inserted
//  into a timer queue for age expiration.
//

typedef struct {

    //
    //  Splay links in the Cache tree
    //

    RTL_SPLAY_LINKS      CacheLinks;

    //
    //  List links in the timer queue
    //

    LIST_ENTRY           ListLinks;

    //
    //  Time this entry was created (for constant time insert)
    //

    LARGE_INTEGER        CreateTime;

    //
    //  Directory these names are associated with
    //

    ULONGLONG            DirKey;

    //
    //  Flags for the entry
    //

    ULONG                Flags;

    //
    //  Long/Short names of the file
    //

    UNICODE_STRING       LongName;
    UNICODE_STRING       ShortName;

    //
    //  Opaque tunneled data
    //

    PVOID                TunnelData;
    ULONG                TunnelDataLength;

} TUNNEL_NODE, *PTUNNEL_NODE;

//
//  Internal utility functions
//

NTSTATUS
FsRtlGetTunnelParameterValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value);

VOID
FsRtlPruneTunnelCache (
    IN PTUNNEL Cache,
    IN OUT PLIST_ENTRY FreePoolList);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeTunnels)
#pragma alloc_text(PAGE, FsRtlInitializeTunnelCache)
#pragma alloc_text(PAGE, FsRtlAddToTunnelCache)
#pragma alloc_text(PAGE, FsRtlFindInTunnelCache)
#pragma alloc_text(PAGE, FsRtlDeleteKeyFromTunnelCache)
#pragma alloc_text(PAGE, FsRtlDeleteTunnelCache)
#pragma alloc_text(PAGE, FsRtlPruneTunnelCache)
#pragma alloc_text(PAGE, FsRtlGetTunnelParameterValue)
#endif


INLINE
LONG
FsRtlCompareNodeAndKey (
    TUNNEL_NODE *Node,
    ULONGLONG DirectoryKey,
    PUNICODE_STRING Name
    )
/*++

Routine Description:

    Compare a tunnel node with a key/name pair

Arguments:

    Node              - a tunnel node

    DirectoryKey      - a key value

    Name              - a filename

Return Value:

    Signed comparison result

--*/

{
    return  (Node->DirKey > DirectoryKey ?  1 :
            (Node->DirKey < DirectoryKey ? -1 :
            RtlCompareUnicodeString((FlagOn(Node->Flags, TUNNEL_FLAG_KEY_SHORT) ?
                                        &Node->ShortName : &Node->LongName),
                                    Name,
                                    TRUE)));
}


INLINE
VOID
FsRtlFreeTunnelNode (
    PTUNNEL_NODE Node,
    PLIST_ENTRY FreePoolList OPTIONAL
    )
/*++

Routine Description:

    Free a node

Arguments:

    Node            - a tunnel node to free

    FreePoolList    - optional list to hold freeable pool memory

Return Value:

    None

-*/
{
    if (FreePoolList) {

        InsertHeadList(FreePoolList, &Node->ListLinks);

    } else {

        if (FlagOn(Node->Flags, TUNNEL_FLAG_NON_LOOKASIDE)) {
    
            ExFreePool(Node);
    
        } else {
    
            ExFreeToPagedLookasideList(&TunnelLookasideList, Node);
        }
    }
}


INLINE
VOID
FsRtlEmptyFreePoolList (
    PLIST_ENTRY FreePoolList
    )
/*++

Routine Description:

    Free all pool memory that has been delayed onto a free list.

Arguments:

    FreePoolList    - a list of freeable pool memory

Return Value:

    None

-*/
{
    PTUNNEL_NODE FreeNode;

    while (!IsListEmpty(FreePoolList)) {

        FreeNode = CONTAINING_RECORD(FreePoolList->Flink, TUNNEL_NODE, ListLinks);
        RemoveEntryList(FreePoolList->Flink);

        FsRtlFreeTunnelNode(FreeNode, NULL);
    }
}


INLINE
VOID
FsRtlRemoveNodeFromTunnel (
    IN PTUNNEL Cache,
    IN PTUNNEL_NODE Node,
    IN PLIST_ENTRY FreePoolList,
    IN PBOOLEAN Splay OPTIONAL
    )
/*++

Routine Description:

    Performs the common work of deleting a node from a tunnel cache. Pool memory
    is not deleted immediately but is saved aside on a list for deletion later
    by the calling routine.

Arguments:

    Cache - the tunnel cache the node is in

    Node - the node being removed

    FreePoolList - an initialized list to take the node if it was allocated from
        pool

    Splay - an optional flag to indicate whether the tree should be splayed on
        the delete. Set to FALSE if splaying was performed.

Return Value:

    None.

--*/
{
    if (Splay && *Splay) {

        Cache->Cache = RtlDelete(&Node->CacheLinks);

        *Splay = FALSE;

    } else {

        RtlDeleteNoSplay(&Node->CacheLinks, &Cache->Cache);
    }

    RemoveEntryList(&Node->ListLinks);

    Cache->NumEntries--;

    FsRtlFreeTunnelNode(Node, FreePoolList);
}


VOID
FsRtlInitializeTunnels (
    VOID
    )
/*++

Routine Description:

    Initializes the global part of the tunneling package.

Arguments:

    None

Return Value:

    None

--*/
{
    UNICODE_STRING  ValueName;
    USHORT          LookasideDepth;

    PAGED_CODE();

    if (MmIsThisAnNtAsSystem()) {

        TunnelMaxEntries = 1024;

    }

    //
    //  Query our configurable parameters
    //
    //  Don't worry about failure in retrieving from the registry. We've gotten
    //  this far so fall back on defaults even if there was a problem with resources.
    //

    ValueName.Buffer = TUNNEL_SIZE_VALUE_NAME;
    ValueName.Length = sizeof(TUNNEL_SIZE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(TUNNEL_SIZE_VALUE_NAME);
    (VOID) FsRtlGetTunnelParameterValue(&ValueName, &TunnelMaxEntries);

    ValueName.Buffer = TUNNEL_AGE_VALUE_NAME;
    ValueName.Length = sizeof(TUNNEL_AGE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(TUNNEL_AGE_VALUE_NAME);
    (VOID) FsRtlGetTunnelParameterValue(&ValueName, &TunnelMaxAge);

    if (TunnelMaxAge == 0) {

        //
        //  If the registry has been set so the timeout is zero, we should force
        //  the number of entries to zero also. This preserves expectations and lets
        //  us key off of max entries alone in performing the hard disabling of the
        //  caching code.
        //

        TunnelMaxEntries = 0;
    }

    //
    //  Convert from seconds to 10ths of msecs, the internal resolution
    //

    TunnelMaxAge *= 10000000;

    //
    //  Build the lookaside list for common node allocation
    //

    if (TunnelMaxEntries > MAXUSHORT) {

        //
        //  User is hinting a big need to us
        //

        LookasideDepth = MAX_LOOKASIDE_DEPTH;

    } else {

        LookasideDepth = ((USHORT)TunnelMaxEntries)/16;
    }

    if (LookasideDepth == 0 && TunnelMaxEntries) {

        //
        //  Miniscule number of entries allowed. Lookaside 'em all.
        //

        LookasideDepth = (USHORT)TunnelMaxEntries + 1;
    }

    if (LookasideDepth > MAX_LOOKASIDE_DEPTH) {

        //
        //  Finally, restrict the depth to something reasonable.
        //

        LookasideDepth = MAX_LOOKASIDE_DEPTH;
    }

    ExInitializePagedLookasideList( &TunnelLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    LOOKASIDE_NODE_SIZE,
                                    'LnuT',
                                    LookasideDepth );

    return;
}


//
//  *** SPEC
//
//    FsRtlInitializeTunnelCache - Initialize a tunneling cache for a volume
//
//    FsRtlInitializeTunnelCache will allocate a default cache (resizing policy is common
//    to all file systems) and initialize it to be empty.  File systems will store a pointer to
//    this cache in their per-volume structures.
//
//    Information is retained in the tunnel cache for a fixed period of time.
//    Assume that a value of 10 seconds would satisfy the vast majority of situations.  This
//    could be controlled by the registry or could be a compilation constant.
//
//  Change: W95 times out at 15 seconds. Would be a registry value initialized at tunnel
//  creation time, with a proposed default of 15 seconds.
//

VOID
FsRtlInitializeTunnelCache (
    __in TUNNEL *Cache
    )
/*++

Routine Description:

    Initialize a new tunnel cache.

Arguments:

    None

Return Value:

    None

--*/
{
    PAGED_CODE();

    ExInitializeFastMutex(&Cache->Mutex);

    Cache->Cache = NULL;
    InitializeListHead(&Cache->TimerQueue);
    Cache->NumEntries = 0;

    return;
}


//
//  *** SPEC
//
//    FsRtlAddToTunnelCache - add information to a tunnel cache
//
//    FsRtlAddToTunnelCache is called by file systems when a name disappears from a
//    directory.  This typically occurs in both the delete and the rename paths.  When
//    a name is deleted, all information needed to be cached is extracted from the file
//    and passed in a single buffer.  This information is stored keyed by the directory key
//    (a ULONG that is unique to the directory) and the short-name of the file.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        pointer to cache initialized by FsRtlInitializeTunnelCache
//        DirectoryKey    ULONG unique ID of the directory containing the deleted file
//        ShortName    UNICODE_STRING* short (8.3) name of the file
//        LongName    UNICODE_STRING* full name of the file
//        DataLength    ULONG length of data to be cached with these names
//        Data        VOID* data that will be cached.
//
//    It is acceptable for the Cache to ignore this request based upon memory constraints.
//
//  Change: W95 maintains 10 items in the tunnel cache. Since we are a potential server
//  this should be much higher. The max count would be initialized from the registry with
//  a proposed default of 1024. Adds which run into the limit would cause least recently
//  inserted recycling (i.e., off of the top of the timer queue).
//
//  Change: Key should be by the name removed, not necessarily the short name. If a long name
//  is removed, it would be incorrect to miss the tunnel. Use KeyByShortName boolean to specify
//  which.
//
//  Change: Specify that Data, ShortName, and LongName are copied for storage.
//

VOID
FsRtlAddToTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirKey,
    __in UNICODE_STRING *ShortName,
    __in UNICODE_STRING *LongName,
    __in BOOLEAN KeyByShortName,
    __in ULONG DataLength,
    __in_bcount(DataLength) VOID *Data
    )
/*++

Routine Description:

    Adds an entry to the tunnel cache keyed by

        DirectoryKey ## (KeyByShortName ? ShortName : LongName)

    ShortName, LongName, and Data are copied and stored in the tunnel. As a side
    effect, if there are too many entries in the tunnel cache, this routine will
    initiate expiration in the tunnel cache.

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory the name appeared in

    ShortName - (optional if !KeyByShortName) the 8.3 name of the file

    LongName - (optional if KeyByShortName) the long name of the file

    KeyByShortName - specifies which name is keyed in the tunnel cache

    DataLength - specifies the length of the opaque data segment (file
    system specific) which contains the tunneling information for this
    file

    Data - pointer to the opaque tunneling data segment

Return Value:

    None

--*/
{
    LONG Compare;
    ULONG NodeSize;
    PUNICODE_STRING NameKey;
    PRTL_SPLAY_LINKS *Links;
    LIST_ENTRY FreePoolList;

    PTUNNEL_NODE Node = NULL;
    PTUNNEL_NODE NewNode = NULL;
    BOOLEAN AllocatedFromPool = FALSE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    InitializeListHead(&FreePoolList);

    //
    //  Grab a new node for this data
    //

    NodeSize = sizeof(TUNNEL_NODE) + ShortName->Length + LongName->Length + DataLength;

    if (LOOKASIDE_NODE_SIZE >= NodeSize) {

        NewNode = ExAllocateFromPagedLookasideList(&TunnelLookasideList);
    }

    if (NewNode == NULL) {

        //
        //  Data doesn't fit in lookaside nodes
        //

        NewNode = ExAllocatePoolWithTag(PagedPool|POOL_COLD_ALLOCATION, NodeSize, 'PnuT');

        if (NewNode == NULL) {

            //
            //  Give up tunneling this entry
            //

            return;
        }

        AllocatedFromPool = TRUE;
    }

    //
    //  Traverse the cache to find our insertion point
    //

    NameKey = (KeyByShortName ? ShortName : LongName);

    ExAcquireFastMutex(&Cache->Mutex);

    Links = &Cache->Cache;

    while (*Links) {

        Node = CONTAINING_RECORD(*Links, TUNNEL_NODE, CacheLinks);

        Compare = FsRtlCompareNodeAndKey(Node, DirKey, NameKey);

        if (Compare > 0) {

            Links = &RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Compare < 0) {

                Links = &RtlRightChild(&Node->CacheLinks);

            } else {

                break;
            }
        }
    }

    //
    //  Thread new data into the splay tree
    //

    RtlInitializeSplayLinks(&NewNode->CacheLinks);

    if (Node) {

        //
        //  Not inserting first node in tree
        //

        if (*Links) {

            //
            //  Entry exists in the cache, so replace by swapping all splay links
            //

            RtlRightChild(&NewNode->CacheLinks) = RtlRightChild(*Links);
            RtlLeftChild(&NewNode->CacheLinks) = RtlLeftChild(*Links);

            if (RtlRightChild(*Links)) RtlParent(RtlRightChild(*Links)) = &NewNode->CacheLinks;
            if (RtlLeftChild(*Links)) RtlParent(RtlLeftChild(*Links)) = &NewNode->CacheLinks;

            if (!RtlIsRoot(*Links)) {

                //
                //  Change over the parent links. Note that we've messed with *Links now
                //  since it is pointing at the parent member.
                //

                RtlParent(&NewNode->CacheLinks) = RtlParent(*Links);

                if (RtlIsLeftChild(*Links)) {

                    RtlLeftChild(RtlParent(*Links)) = &NewNode->CacheLinks;

                } else {

                    RtlRightChild(RtlParent(*Links)) = &NewNode->CacheLinks;
                }

            } else {

                //
                //  Set root of the cache
                //

                Cache->Cache = &NewNode->CacheLinks;
            }

            //
            //  Free old node
            //

            RemoveEntryList(&Node->ListLinks);

            FsRtlFreeTunnelNode(Node, &FreePoolList);

            Cache->NumEntries--;

        } else {

            //
            //  Simple insertion as a leaf
            //

            NewNode->CacheLinks.Parent = &Node->CacheLinks;
            *Links = &NewNode->CacheLinks;
        }

    } else {

        Cache->Cache = &NewNode->CacheLinks;
    }

    //
    //  Thread onto the timer list
    //

    KeQuerySystemTime(&NewNode->CreateTime);
    InsertTailList(&Cache->TimerQueue, &NewNode->ListLinks);

    Cache->NumEntries++;

    //
    //  Stash tunneling information
    //

    NewNode->DirKey = DirKey;

    if (KeyByShortName) {

        NewNode->Flags = TUNNEL_FLAG_KEY_SHORT;

    } else {

        NewNode->Flags = 0;
    }

    //
    //  Initialize the internal UNICODE_STRINGS to point at the buffer segments. For various
    //  reasons (UNICODE APIs are incomplete, we're avoiding calling any allocate routine more
    //  than once, UNICODE strings are not guaranteed to be null terminated) we have to do a lot
    //  of this by hand.
    //
    //  The data is layed out like this in the allocated block:
    //
    //  -----------------------------------------------------------------------------------
    //  | TUNNEL_NODE | Node->ShortName.Buffer | Node->LongName.Buffer | Node->TunnelData |
    //  -----------------------------------------------------------------------------------
    //

    NewNode->ShortName.Buffer = (PWCHAR)((PCHAR)NewNode + sizeof(TUNNEL_NODE));
    NewNode->LongName.Buffer = (PWCHAR)((PCHAR)NewNode + sizeof(TUNNEL_NODE) + ShortName->Length);

    NewNode->ShortName.Length = NewNode->ShortName.MaximumLength = ShortName->Length;
    NewNode->LongName.Length = NewNode->LongName.MaximumLength = LongName->Length;

    if (ShortName->Length) {

        RtlCopyMemory(NewNode->ShortName.Buffer, ShortName->Buffer, ShortName->Length);
    }

    if (LongName->Length) {

        RtlCopyMemory(NewNode->LongName.Buffer, LongName->Buffer, LongName->Length);
    }

    NewNode->TunnelData = (PVOID)((PCHAR)NewNode + sizeof(TUNNEL_NODE) + ShortName->Length + LongName->Length);

    NewNode->TunnelDataLength = DataLength;

    RtlCopyMemory(NewNode->TunnelData, Data, DataLength);

    if (AllocatedFromPool) {

        SetFlag(NewNode->Flags, TUNNEL_FLAG_NON_LOOKASIDE);
    }

    //
    //  Clean out the cache, release, and then drop any pool memory we need to
    //

    FsRtlPruneTunnelCache(Cache, &FreePoolList);

    ExReleaseFastMutex(&Cache->Mutex);

    FsRtlEmptyFreePoolList(&FreePoolList);

    return;
}


//
//  *** SPEC
//
//    FsRtlFindInTunnelCache - retrieve information from tunnel cache
//
//    FsRtlFindInTunnelCache consults the cache to see if an entry with the same
//    DirectoryKey and ShortName exist.  If so, it returns the data associated with the
//    cache entry.  The entry may or may not be freed from the cache.  Information that is
//    stale but not yet purged (older than the retention threshold but not yet cleaned out)
//    may be returned.
//
//    File systems call FsRtlFindInTunnel cache in the create path when a new file is
//    being created and in the rename path when a new name is appearing in a directory.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//        DirectoryKey    ULONG unique ID of the directory where a name is appearing
//        Name        UNICODE_STRING* name that is being created
//        DataLength     in length of buffer, out returned length of data found
//        Data        pointer to buffer
//
//    Returns:
//        TRUE iff a matching DirectoryKey/Name pair are found, FALSE otherwise
//
//  Change: Add out parameters ShortName and LongName to capture the file naming information.
//  Plus: this avoids the need for marshalling/unmarshalling steps for the current desired use of
//  this code since otherwise we'd have variable length unaligned structures to contain the
//  strings along with the other meta-info.
//  Minus: Possibly a bad precedent.
//
//  Change: spec reads "may or may not be freed from cache" on a hit. This complicates unwinding
//  from aborted operations. Data will not be freed on a hit, but will expire like normal entries.
//

BOOLEAN
FsRtlFindInTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirKey,
    __in UNICODE_STRING *Name,
    __out UNICODE_STRING *ShortName,
    __out UNICODE_STRING *LongName,
    __inout ULONG  *DataLength,
    __out_bcount_part(*DataLength, *DataLength) VOID *Data
    )
/*++

Routine Description:

    Looks up the key

        DirKey ## Name

    in the tunnel cache and removes it. As a side effect, this routine will initiate
    expiration of the aged entries in the tunnel cache.

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory the name will appear in

    Name - the name of the entry

    ShortName - return string to hold the short name of the tunneled file. Must
        already be allocated and large enough for max 8.3 name

    LongName -  return string to hold the long name of the tunneled file. If
        already allocated, may be grown if not large enough. Caller is
        responsible for noticing this and freeing data regardless of return value.

    DataLength - provides the length of the buffer available to hold the
        tunneling information, returns the size of the tunneled information
        read out

Return Value:

    Boolean true if found, false otherwise

--*/
{
    PRTL_SPLAY_LINKS Links;
    PTUNNEL_NODE Node = NULL;
    LONG Compare;
    LIST_ENTRY FreePoolList;

    BOOLEAN Status = FALSE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) {
        return FALSE;
    }

    InitializeListHead(&FreePoolList);

    ExAcquireFastMutex(&Cache->Mutex);

    //
    //  Expire aged entries first so we don't grab old data
    //

    FsRtlPruneTunnelCache(Cache, &FreePoolList);

    Links = Cache->Cache;

    while (Links) {

        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        Compare = FsRtlCompareNodeAndKey(Node, DirKey, Name);

        if (Compare > 0) {

            Links = RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Compare < 0) {

                Links = RtlRightChild(&Node->CacheLinks);

            } else {

                //
                //  Found tunneling information
                //
                break;
            }
        }
    }

    try {

        if (Links) {
    
            //
            //  Copy node data into caller's area
            //
    
            ASSERT(ShortName->MaximumLength >= (8+1+3)*sizeof(WCHAR));
            RtlCopyUnicodeString(ShortName, &Node->ShortName);
    
            if (LongName->MaximumLength >= Node->LongName.Length) {
    
                RtlCopyUnicodeString(LongName, &Node->LongName);
    
            } else {
    
                //
                //  Need to allocate more memory for the long name
                //
    
                LongName->Buffer = FsRtlAllocatePoolWithTag(PagedPool, Node->LongName.Length, '4nuT');
                LongName->Length = LongName->MaximumLength = Node->LongName.Length;
    
                RtlCopyMemory(LongName->Buffer, Node->LongName.Buffer, Node->LongName.Length);
            }
    
            ASSERT(*DataLength >= Node->TunnelDataLength);
            RtlCopyMemory(Data, Node->TunnelData, Node->TunnelDataLength);
            *DataLength = Node->TunnelDataLength;
    
            Status = TRUE;
        }

    } finally {

        ExReleaseFastMutex(&Cache->Mutex);
    
        FsRtlEmptyFreePoolList(&FreePoolList);
    }
    
    return Status;
}


//
//  *** SPEC
//
//    FsRtlDeleteKeyFromTunnelCache - delete all cached information associated with
//    a DirectoryKey
//
//    When file systems delete a directory, all cached information relating to that directory
//    must be purged.  File systems call FsRtlDeleteKeyFromTunnelCache in the rmdir path.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//        DirectoryKey    ULONGLONG unique ID of the directory that is being deleted
//

VOID
FsRtlDeleteKeyFromTunnelCache (
    __in TUNNEL *Cache,
    __in ULONGLONG DirKey
    )
/*++

Routine Description:

    Deletes all entries in the cache associated with a specific directory

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory (presumably being removed)

Return Value:

    None

--*/
{
    PRTL_SPLAY_LINKS Links;
    PRTL_SPLAY_LINKS SuccessorLinks;
    PTUNNEL_NODE Node;
    LIST_ENTRY FreePoolList;

    PRTL_SPLAY_LINKS LastLinks = NULL;
    BOOLEAN Splay = TRUE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    InitializeListHead(&FreePoolList);

    ExAcquireFastMutex(&Cache->Mutex);

    Links = Cache->Cache;

    while (Links) {

        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        if (Node->DirKey > DirKey) {

            //
            //  All nodes to the right are bigger, go left
            //

            Links = RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Node->DirKey < DirKey) {

                if (LastLinks) {

                    //
                    //  If we have previously seen a candidate node to delete
                    //  and we have now gone too far left - we know where to start.
                    //

                    break;
                }

                Links = RtlRightChild(&Node->CacheLinks);

            } else {

                //
                //  Node is a candidate to be deleted, but we might have more nodes
                //  to the left in the tree. Note this location and go on.
                //

                LastLinks = Links;
                Links = RtlLeftChild(&Node->CacheLinks);
            }
        }
    }

    for (Links = LastLinks;
         Links;
         Links = SuccessorLinks) {

        SuccessorLinks = RtlRealSuccessor(Links);
        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        if (Node->DirKey != DirKey) {

            //
            //  Reached nodes which have a different key, so we're done
            //

            break;
        }

        FsRtlRemoveNodeFromTunnel(Cache, Node, &FreePoolList, &Splay);
    }

    ExReleaseFastMutex(&Cache->Mutex);

    //
    //  Free delayed pool
    //

    FsRtlEmptyFreePoolList(&FreePoolList);

    return;
}


//
//  *** SPEC
//
//    FsRtlDeleteTunnelCache - free a tunnel cache
//
//    FsRtlDeleteTunnelCache deletes all cached information.  The Cache is no longer
//    valid.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//

VOID
FsRtlDeleteTunnelCache (
    __in TUNNEL *Cache
    )
/*++

Routine Description:

    Deletes a tunnel cache

Arguments:

    Cache - the cache to delete, initialized by FsRtlInitializeTunnelCache()

Return Value:

    None

--*/
{
    PTUNNEL_NODE Node;
    PLIST_ENTRY Link, Next;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    //
    //  Zero out the cache and delete everything on the timer list
    //

    Cache->Cache = NULL;
    Cache->NumEntries = 0;

    for (Link = Cache->TimerQueue.Flink;
         Link != &Cache->TimerQueue;
         Link = Next) {

        Next = Link->Flink;

        Node = CONTAINING_RECORD(Link, TUNNEL_NODE, ListLinks);

        FsRtlFreeTunnelNode(Node, NULL);
    }

    InitializeListHead(&Cache->TimerQueue);

    return;
}


VOID
FsRtlPruneTunnelCache (
    IN PTUNNEL Cache,
    IN OUT PLIST_ENTRY FreePoolList
    )
/*++

Routine Description:

    Removes deadwood entries from the tunnel cache as defined by TunnelMaxAge and TunnelMaxEntries.
    Pool memory is returned on a list for deletion by the calling routine at a time of
    its choosing.

    For performance reasons we don't want to force freeing of memory inside a mutex.

Arguments:

    Cache - the tunnel cache to prune

    FreePoolList - a list to queue pool memory on to

Return Value:

    None
--*/
{
    PTUNNEL_NODE Node;
    LARGE_INTEGER ExpireTime;
    LARGE_INTEGER CurrentTime;
    BOOLEAN Splay = TRUE;

    PAGED_CODE();

    //
    //  Calculate the age of the oldest entry we want to keep
    //

    KeQuerySystemTime(&CurrentTime);
    ExpireTime.QuadPart = CurrentTime.QuadPart - TunnelMaxAge;

    //
    //  Expire old entries off of the timer queue.  We have to check
    //  for future time because the clock may jump as a result of
    //  hard clock change.  If we did not do this, a rogue entry
    //  with a future time could sit at the top of the queue and
    //  prevent entries from going away.
    //

    while (!IsListEmpty(&Cache->TimerQueue)) {

        Node = CONTAINING_RECORD(Cache->TimerQueue.Flink, TUNNEL_NODE, ListLinks);

        if (Node->CreateTime.QuadPart < ExpireTime.QuadPart ||
            Node->CreateTime.QuadPart > CurrentTime.QuadPart) {

            FsRtlRemoveNodeFromTunnel(Cache, Node, FreePoolList, &Splay);

        } else {

            //
            //  No more nodes to be expired
            //

            break;
        }
    }

    //
    //  Remove entries until we're under the TunnelMaxEntries limit
    //

    while (Cache->NumEntries > TunnelMaxEntries) {

        Node = CONTAINING_RECORD(Cache->TimerQueue.Flink, TUNNEL_NODE, ListLinks);
        FsRtlRemoveNodeFromTunnel(Cache, Node, FreePoolList, &Splay);
    }

    return;
}


NTSTATUS
FsRtlGetTunnelParameterValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the Tunnel parameter information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                double space configuration location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    KeyName.Buffer = TUNNEL_KEY_NAME;
    KeyName.Length = sizeof(TUNNEL_KEY_NAME) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(TUNNEL_KEY_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePoolWithTag(PagedPool,
                                                        RequestLength,
                                                        'KnuT');

            if (!KeyValueInformation) {
                return STATUS_NO_MEMORY;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PULONG DataPtr;

            //
            // Return contents to the caller.
            //

            DataPtr = (PULONG)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
            *Value = *DataPtr;

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fstub\drivesup.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    drivesup.c

Abstract:

    Default handlers for hal functions which don't get handlers
    installed by the hal

--*/

#ifndef _DRIVESUP_H_
#define _DRIVESUP_H_

#define BOOTABLE_PARTITION  0
#define PRIMARY_PARTITION   1
#define LOGICAL_PARTITION   2
#define FT_PARTITION        3
#define OTHER_PARTITION     4

#endif // _DRIVESUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\fstub\drivesup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    drivesup.c

Abstract:

    Default handlers for HAL functions which don't get handlers
    installed by the HAL.

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // condition expression is constant

#include "ntos.h"
#include "zwapi.h"
#include "hal.h"
#include "ntdddisk.h"
#include "haldisp.h"
#include "ntddft.h"
#include "mountmgr.h"
#include "stdio.h"
#include <setupblk.h>

#include "drivesup.h"
#include "fstub.h"

#define FSTUB_TAG               ('BtsF')

//
// Macro definitions
//

#define GET_STARTING_SECTOR( p ) (                  \
        (ULONG) (p->StartingSectorLsb0) +           \
        (ULONG) (p->StartingSectorLsb1 << 8) +      \
        (ULONG) (p->StartingSectorMsb0 << 16) +     \
        (ULONG) (p->StartingSectorMsb1 << 24) )

#define GET_PARTITION_LENGTH( p ) (                 \
        (ULONG) (p->PartitionLengthLsb0) +          \
        (ULONG) (p->PartitionLengthLsb1 << 8) +     \
        (ULONG) (p->PartitionLengthMsb0 << 16) +    \
        (ULONG) (p->PartitionLengthMsb1 << 24) )

//
//  Structure for determing if an 0xaa55 marked sector has a BPB in it.
//

typedef struct _BOOT_SECTOR_INFO {
    UCHAR   JumpByte[1];
    UCHAR   Ignore1[2];
    UCHAR   OemData[8];
    UCHAR   BytesPerSector[2];
    UCHAR   Ignore2[6];
    UCHAR   NumberOfSectors[2];
    UCHAR   MediaByte[1];
    UCHAR   Ignore3[2];
    UCHAR   SectorsPerTrack[2];
    UCHAR   NumberOfHeads[2];
} BOOT_SECTOR_INFO, *PBOOT_SECTOR_INFO;

typedef struct _PARTITION_TABLE {
    PARTITION_INFORMATION PartitionEntry[4];
} PARTITION_TABLE, *PPARTITION_TABLE;

typedef struct _DISK_LAYOUT {
    ULONG TableCount;
    ULONG Signature;
    PARTITION_TABLE PartitionTable[1];
} DISK_LAYOUT, *PDISK_LAYOUT;

typedef struct _PTE {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    USHORT StartingCylinder;        // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    USHORT EndingCylinder;          // Not used
    ULONG StartingSector;           // Hidden sectors
    ULONG PartitionLength;          // Sectors in this partition
} PTE;
typedef PTE UNALIGNED *PPTE;


//
// Strings definitions
//

static PCHAR DiskPartitionName = "\\Device\\Harddisk%d\\Partition%d";
static PCHAR RegistryKeyName   = DISK_REGISTRY_KEY;

VOID
HalpCalculateChsValues(
    IN PLARGE_INTEGER PartitionOffset,
    IN PLARGE_INTEGER PartitionLength,
    IN CCHAR ShiftCount,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfTracks,
    IN ULONG ConventionalCylinders,
    OUT PPARTITION_DESCRIPTOR PartitionDescriptor
    );

NTSTATUS
HalpQueryPartitionType(
    IN  PUNICODE_STRING             DeviceName,
    IN  PDRIVE_LAYOUT_INFORMATION   DriveLayout,
    OUT PULONG                      PartitionType
    );

NTSTATUS
HalpQueryDriveLayout(
    IN  PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION*  DriveLayout
    );

VOID
FASTCALL
xHalGetPartialGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG ConventionalCylinders,
    IN PLONGLONG DiskSize
    );

NTSTATUS
HalpGetFullGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDISK_GEOMETRY Geometry,
    OUT PULONGLONG RealSectorCount
    );

BOOLEAN
HalpIsValidPartitionEntry(
    PPARTITION_DESCRIPTOR Entry,
    ULONGLONG MaxOffset,
    ULONGLONG MaxSector
    );

NTSTATUS
HalpNextMountLetter(
    IN  PUNICODE_STRING DeviceName,
    OUT PUCHAR          DriveLetter
    );

UCHAR
HalpNextDriveLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  PSTRING         NtDeviceName,
    OUT PUCHAR          NtSystemPath,
    IN  BOOLEAN         UseHardLinksIfNecessary
    );

VOID
HalpEnableAutomaticDriveLetterAssignment(
    );

NTSTATUS
HalpSetMountLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  UCHAR           DriveLetter
    );

BOOLEAN
HalpIsOldStyleFloppy(
    IN  PUNICODE_STRING DeviceName
    );

PULONG
IopComputeHarddiskDerangements(
    IN  ULONG   DiskCount
    );

VOID
FstubFixupEfiPartition(
    IN PPARTITION_DESCRIPTOR Entry,
    IN ULONGLONG MaxSector
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpCalculateChsValues)
#pragma alloc_text(PAGE, HalpQueryPartitionType)
#pragma alloc_text(PAGE, HalpQueryDriveLayout)
#pragma alloc_text(PAGE, HalpNextMountLetter)
#pragma alloc_text(PAGE, HalpNextDriveLetter)
#pragma alloc_text(PAGE, HalpEnableAutomaticDriveLetterAssignment)
#pragma alloc_text(PAGE, HalpSetMountLetter)
#pragma alloc_text(PAGE, IoAssignDriveLetters)
#pragma alloc_text(PAGE, IoReadPartitionTable)
#pragma alloc_text(PAGE, IoSetPartitionInformation)
#pragma alloc_text(PAGE, IoWritePartitionTable)
#pragma alloc_text(PAGE, HalpIsValidPartitionEntry)
#pragma alloc_text(PAGE, HalpGetFullGeometry)
#pragma alloc_text(PAGE, HalpIsOldStyleFloppy)
#pragma alloc_text(PAGE, IopComputeHarddiskDerangements)
#pragma alloc_text(PAGE, FstubFixupEfiPartition)
#endif



VOID
FASTCALL
HalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    Given a master boot record type (MBR - the zero'th sector on the disk),
    read the master boot record of a disk.  If the MBR is found to be of that
    type, allocate a structure whose layout is dependent upon that partition
    type, fill with the appropriate values, and return a pointer to that buffer
    in the output parameter.

    The best example for a use of this routine is to support Ontrack
    systems DiskManager software.  Ontrack software lays down a special
    partition describing the entire drive.  The special partition type
    (0x54) will be recognized and a couple of longwords of data will
    be passed back in a buffer for a disk driver to act upon.

Arguments:

    DeviceObject - The device object describing the entire drive.

    SectorSize - The minimum number of bytes that an IO operation can
                 fetch.

    MBRIndentifier - A value that will be searched for in the
                     in the MBR.  This routine will understand
                     the semantics implied by this value.

    Buffer - Pointer to a buffer that returns data according to the
             type of MBR searched for.  If the MBR is not of the
             type asked for, the buffer will not be allocated and this
             pointer will be NULL.  It is the responsibility of the
             caller of HalExamineMBR to deallocate the buffer.  The
             caller should deallocate the memory ASAP.

Return Value:

    None.

--*/

{


    LARGE_INTEGER partitionTableOffset;
    PUCHAR readBuffer = (PUCHAR) NULL;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG readSize;

    *Buffer = NULL;
    //
    // Determine the size of a read operation to ensure that at least 512
    // bytes are read.  This will guarantee that enough data is read to
    // include an entire partition table.  Note that this code assumes that
    // the actual sector size of the disk (if less than 512 bytes) is a
    // multiple of 2, a fairly reasonable assumption.
    //

    if (SectorSize >= 512) {
        readSize = SectorSize;
    } else {
        readSize = 512;
    }

    //
    // Start at sector 0 of the device.
    //

    partitionTableOffset = RtlConvertUlongToLargeInteger( 0 );

    //
    // Allocate a buffer that will hold the reads.
    //

    readBuffer = ExAllocatePoolWithTag(
                     NonPagedPoolCacheAligned,
                     PAGE_SIZE>readSize?PAGE_SIZE:readSize,
                     'btsF'
                     );

    if (readBuffer == NULL) {
        return;
    }

    //
    // Read record containing partition table.
    //
    // Create a notification event object to be used while waiting for
    // the read request to complete.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        DeviceObject,
                                        readBuffer,
                                        readSize,
                                        &partitionTableOffset,
                                        &event,
                                        &ioStatus );

    if (!irp) {
        ExFreePool(readBuffer);
        return;
    } else {
        PIO_STACK_LOCATION irpStack;
        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
    }

    status = IoCallDriver( DeviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        ExFreePool(readBuffer);
        return;
    }

    //
    // Check for Boot Record signature.
    //

    if (((PUSHORT) readBuffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        ExFreePool(readBuffer);
        return;
    }

    //
    // Check for DM type partition.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) readBuffer)[PARTITION_TABLE_OFFSET]);

    if (partitionTableEntry->PartitionType != MBRTypeIdentifier) {

        //
        // The partition type isn't what the caller cares about.
        //
        ExFreePool(readBuffer);

    } else {

        if (partitionTableEntry->PartitionType == 0x54) {

            //
            // Rather than allocate a new piece of memory to return
            // the data - just use the memory allocated for the buffer.
            // We can assume the caller will delete this shortly.
            //

            ((PULONG)readBuffer)[0] = 63;
            *Buffer = readBuffer;

        } else if (partitionTableEntry->PartitionType == 0x55) {

            //
            // EzDrive Partition.  Simply return the pointer to non-null
            // There is no skewing here.
            //

            *Buffer = readBuffer;

        } else {

            ASSERT(partitionTableEntry->PartitionType == 0x55);

        }

    }

}

VOID
FASTCALL
xHalGetPartialGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG ConventionalCylinders,
    IN PLONGLONG DiskSize
    )

/*++

Routine Description:

    We need this routine to get the number of cylinders that the disk driver
    thinks is on the drive.  We will need this to calculate CHS values
    when we fill in the partition table entries.

Arguments:

    DeviceObject - The device object describing the entire drive.

    ConventionalCylinders - Number of cylinders on the drive.

Return Value:

    None.

--*/

{
    PIRP localIrp;
    PDISK_GEOMETRY diskGeometry;
    PIO_STATUS_BLOCK iosb;
    PKEVENT eventPtr;
    NTSTATUS status;

    *ConventionalCylinders = 0UL;
    *DiskSize = 0UL;

    diskGeometry = ExAllocatePoolWithTag(
                      NonPagedPool,
                      sizeof(DISK_GEOMETRY),
                      'btsF'
                      );

    if (!diskGeometry) {

        return;

    }

    iosb = ExAllocatePoolWithTag(
               NonPagedPool,
               sizeof(IO_STATUS_BLOCK),
               'btsF'
               );

    if (!iosb) {

        ExFreePool(diskGeometry);
        return;

    }

    eventPtr = ExAllocatePoolWithTag(
                   NonPagedPool,
                   sizeof(KEVENT),
                   'btsF'
                   );

    if (!eventPtr) {

        ExFreePool(iosb);
        ExFreePool(diskGeometry);
        return;

    }

    KeInitializeEvent(
        eventPtr,
        NotificationEvent,
        FALSE
        );

    localIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                   DeviceObject,
                   NULL,
                   0UL,
                   diskGeometry,
                   sizeof(DISK_GEOMETRY),
                   FALSE,
                   eventPtr,
                   iosb
                   );

    if (!localIrp) {

        ExFreePool(eventPtr);
        ExFreePool(iosb);
        ExFreePool(diskGeometry);
        return;

    }


    //
    // Call the lower level driver, wait for the operation
    // to finish.
    //

    status = IoCallDriver(
                 DeviceObject,
                 localIrp
                 );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject(
                   eventPtr,
                   Executive,
                   KernelMode,
                   FALSE,
                   (PLARGE_INTEGER) NULL
                   );
        status = iosb->Status;
    }

    if (NT_SUCCESS(status)) {

    //
    // The operation completed successfully.  Get the cylinder
    // count of the drive.
    //

        *ConventionalCylinders = diskGeometry->Cylinders.LowPart;

        //
        // If the count is less than 1024 we can pass that back.  Otherwise
        // send back the 1024
        //

        if (diskGeometry->Cylinders.QuadPart >= (LONGLONG)1024) {

            *ConventionalCylinders = 1024;

        }

        //
        // Calculate disk size from gemotry information
        //

        *DiskSize = diskGeometry->Cylinders.QuadPart *
                    diskGeometry->TracksPerCylinder *
                    diskGeometry->SectorsPerTrack *
                    diskGeometry->BytesPerSector;

    }

    ExFreePool(eventPtr);
    ExFreePool(iosb);
    ExFreePool(diskGeometry);
    return;

}


VOID
HalpCalculateChsValues(
    IN PLARGE_INTEGER PartitionOffset,
    IN PLARGE_INTEGER PartitionLength,
    IN CCHAR ShiftCount,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfTracks,
    IN ULONG ConventionalCylinders,
    OUT PPARTITION_DESCRIPTOR PartitionDescriptor
    )

/*++

Routine Description:

    This routine will determine the cylinder, head, and sector (CHS) values
    that should be placed in a partition table entry, given the partition's
    location on the disk and its size.  The values calculated are packed into
    int13 format -- the high two bits of the sector byte contain bits 8 and 9
    of the 10 bit cylinder value, the low 6 bits of the sector byte contain
    the 6 bit sector value;  the cylinder byte contains the low 8 bits
    of the cylinder value; and the head byte contains the 8-bit head value.
    Both the start and end CHS values are calculated.

Arguments:

    PartitionOffset - Byte offset of the partition, relative to the entire
        physical disk.

    PartitionLength - Size in bytes of the partition.

    ShiftCount - Shift count to convert from byte counts to sector counts.

    SectorsPerTrack - Number of sectors in a track on the media on which
        the partition resides.

    NumberOfTracks - Number of tracks in a cylinder on the media on which
        the partition resides.

    ConventionalCylinders - The "normalized" disk cylinders.  We will never
        set the cylinders greater than this.

    PartitionDescriptor - Structure to be filled in with the start and
        end CHS values.  Other fields in the structure are not referenced
        or modified.

Return Value:

    None.

Note:

    The Cylinder and Head values are 0-based but the Sector value is 1-based.

    If the start or end cylinder overflows 10 bits (ie, > 1023), CHS values
    will be set to all 1's.

    No checking is done on the SectorsPerTrack and NumberOfTrack values.

--*/

{
    ULONG startSector, sectorCount, endSector;
    ULONG sectorsPerCylinder;
    ULONG remainder;
    ULONG startC, startH, startS, endC, endH, endS;
    LARGE_INTEGER tempInt;

    PAGED_CODE();

    //
    // Calculate the number of sectors in a cylinder.  This is the
    // number of heads multiplied by the number of sectors per track.
    //

    sectorsPerCylinder = SectorsPerTrack * NumberOfTracks;

    //
    // Convert byte offset/count to sector offset/count.
    //

    tempInt.QuadPart = PartitionOffset->QuadPart >> ShiftCount;
    startSector = tempInt.LowPart;

    tempInt.QuadPart = PartitionLength->QuadPart >> ShiftCount;
    sectorCount = tempInt.LowPart;

    endSector = startSector + sectorCount - 1;

    startC = startSector / sectorsPerCylinder;
    endC   = endSector   / sectorsPerCylinder;

    if (!ConventionalCylinders) {

        ConventionalCylinders = 1024;

    }

    //
    // Set these values so that win95 is happy.
    //

    if (startC >= ConventionalCylinders) {

        startC = ConventionalCylinders - 1;

    }

    if (endC >= ConventionalCylinders) {

        endC = ConventionalCylinders - 1;

    }

    //
    // Calculate the starting track and sector.
    //

    remainder = startSector % sectorsPerCylinder;
    startH = remainder / SectorsPerTrack;
    startS = remainder % SectorsPerTrack;

    //
    // Calculate the ending track and sector.
    //

    remainder = endSector % sectorsPerCylinder;
    endH = remainder / SectorsPerTrack;
    endS = remainder % SectorsPerTrack;

    //
    // Pack the result into the caller's structure.
    //

    // low 8 bits of the cylinder => C value

    PartitionDescriptor->StartingCylinderMsb = (UCHAR) startC;
    PartitionDescriptor->EndingCylinderMsb   = (UCHAR) endC;

    // 8 bits of head value => H value

    PartitionDescriptor->StartingTrack = (UCHAR) startH;
    PartitionDescriptor->EndingTrack   = (UCHAR) endH;

    // bits 8-9 of cylinder and 6 bits of the sector => S value

    PartitionDescriptor->StartingCylinderLsb = (UCHAR) (((startS + 1) & 0x3f)
                                                        | ((startC >> 2) & 0xc0));

    PartitionDescriptor->EndingCylinderLsb = (UCHAR) (((endS + 1) & 0x3f)
                                                        | ((endC >> 2) & 0xc0));
}


#define BOOTABLE_PARTITION  0
#define PRIMARY_PARTITION   1
#define LOGICAL_PARTITION   2
#define FT_PARTITION        3
#define OTHER_PARTITION     4
#define GPT_PARTITION       5

NTSTATUS
HalpQueryPartitionType(
    IN  PUNICODE_STRING             DeviceName,
    IN  PDRIVE_LAYOUT_INFORMATION   DriveLayout,
    OUT PULONG                      PartitionType
    )

{
    NTSTATUS                    status;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION_EX    partInfo;
    IO_STATUS_BLOCK             ioStatus;
    ULONG                       i;

    PAGED_CODE();
    
    status = IoGetDeviceObjectPointer(DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);

    if (deviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(deviceObject);
        *PartitionType = LOGICAL_PARTITION;
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        deviceObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);

    if (!NT_SUCCESS(status)) {
        if (!DriveLayout) {
            *PartitionType = LOGICAL_PARTITION;
            return STATUS_SUCCESS;
        }
        return status;
    }

    if (partInfo.PartitionStyle != PARTITION_STYLE_MBR) {
        if (partInfo.PartitionStyle != PARTITION_STYLE_GPT) {
            *PartitionType = OTHER_PARTITION;
            return STATUS_SUCCESS;
        }

        if (IsEqualGUID(&partInfo.Gpt.PartitionType,
                        &PARTITION_BASIC_DATA_GUID)) {

            *PartitionType = GPT_PARTITION;
            return STATUS_SUCCESS;
        }

        *PartitionType = OTHER_PARTITION;
        return STATUS_SUCCESS;
    }

    if (!IsRecognizedPartition(partInfo.Mbr.PartitionType)) {
        *PartitionType = OTHER_PARTITION;
        return STATUS_SUCCESS;
    }

    if (partInfo.Mbr.PartitionType&0x80) {
        *PartitionType = FT_PARTITION;
        return STATUS_SUCCESS;
    }

    if (!DriveLayout) {
        *PartitionType = LOGICAL_PARTITION;
        return STATUS_SUCCESS;
    }

    for (i = 0; i < 4; i++) {
        if (partInfo.StartingOffset.QuadPart ==
            DriveLayout->PartitionEntry[i].StartingOffset.QuadPart) {

            if (partInfo.Mbr.BootIndicator) {
                *PartitionType = BOOTABLE_PARTITION;
            } else {
                *PartitionType = PRIMARY_PARTITION;
            }

            return STATUS_SUCCESS;
        }
    }

    *PartitionType = LOGICAL_PARTITION;

    return STATUS_SUCCESS;
}


NTSTATUS
HalpQueryDriveLayout(
    IN  PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION*  DriveLayout
    )

{
    NTSTATUS        status;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    PUCHAR          buffer;
    ULONG           bufferSize;

    PAGED_CODE();
    
    deviceObject = NULL;
    status = IoGetDeviceObjectPointer( DeviceName,
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }
    
    deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
    ObDereferenceObject( fileObject );

    if (deviceObject->Characteristics & FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject( deviceObject );
        return STATUS_NO_MEDIA;
    }

    //
    // Because the GET DRIVE LAYOUT ioctl doesn't return partial information,
    // we need to use a memory allocation loop, increasing the buffer size
    // when we fail due to low memory.
    //
    
    bufferSize = PAGE_SIZE;
    buffer = NULL;
    KeInitializeEvent( &event, NotificationEvent, FALSE );

    //
    // This will not loop infinitely because we increase the allocated
    // buffer size each iteration through the loop. Eventually one of the
    // calls to ExAllocatePool will fail, and we will break from the loop.
    //
    
    do {

        KeClearEvent( &event );

        //
        // Free the old buffer from previous